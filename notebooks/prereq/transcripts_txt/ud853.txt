Welcome to Android Fundamentals. Getting started on Android is straightforward. Simply installing Android Studio and creating a new project is enough to have ticked the "Hello World" box on your Android resume. But that's not why we're here. We're also not here to teach you Java and we're not going to walk you through every API in the Android SDK. But what we will do is to help you build a real app. We'll dig into the fundamentals of how Android works; its patterns and best practices. Our course is deeply rooted in code, but this isn't a copy/paste code lab. We'll teach you the principles you need, and help you navigate the hundreds of resources like sample code, documentation, and stack overflow that you'll be using in your career as an Android developer. Getting started is easy, but building something great is harder, which is why we're here. We'll work right alongside you, and by the end of this course, you'll be able to turn your app vision into reality, and you'll build it the right way. So, in that spirit of collaboration, we'll begin by telling you a little bit about us, and where you'll be seeing us throughout the course. Katherine, why don't you get us started? Sure. I'm Katherine Kwan, and I'm a developer advocate at Google. I started off by working as an engineer on the Android apps team. I worked there for three years on products like Google Play and Google Keep, the note taking app. I'm continually blown away by what you can build on this platform, and I'm particularly inspired by those apps that can truly improve people's lives. When I meet people, they often tell me about their great app ideas. But then they feel like they don't have the technical skills to actually build it. And that's why I shifted over to developer relations so I can help people like you really build something great. Throughout this course, I'll be helping you implement your very first app. My name is Dan Gauthan. I've been a developer advocate at Google for four years and I've worn a lot of hats here. My goal is to keep us on track to make Sunshine, something that had some resemblance to a production quality app. I'll introduce Android design patterns and principles. Many of which are often missed by new Android developers. You'll learn to lean on the framework, focusing on what makes your app unique instead of reinventing the wheel. I'm Rado Mya, and I've been a developer advocate for Android at Google for five years. I started working on Androids so long ago that back then there were no devices. All we had to work with were an emulator, a beater SDK, and an almost fanatical devotion to the platform. I'll be joining you from here, my underground Android developer bunker, and my goal isn't to get you up and running as quickly as possible. It's to teach you the context behind the choices we'll make. And the best practices you need, to really understand how to create great experiences specifically tailored to mobile devices. By the time you finished this course you'll know more than just how to create yet another app. You'll know how to build great apps that focus on the user. [BLANK_AUDIO] In the course, we're going to build a weather app called Sunshine. The main screen is a list of this week's forecast, with an emphasized presentation for today's weather. With just a quick glance, I can decide if, today is a stay inside and code day. Or if I should code from the park instead. We have icons to indicate conditions, like snow, rain, fog or sunshine. We can scroll through the list, to see a long range forecast. With a click on one of the forecasts, we bring up a detailed view containing the rest of the weathery goodness, which also gives us the ability to share the weather with our friends. We can go to Settings and change the unit of measure, as well as the location. The app can even post system wide notifications, to let us know about weather conditions without even entering the app. So, you might ask, why are we building a weather app? We chose the weather app because it's a simple concept, which touches most of the core APIs we want to teach and everyone can relate to weather, unless you're in a bunker. By the end of the course, you'll be able to use those APIs and concepts to build your own app for your final project. Now, it's important to remember that we're not here to teach you how to build a weather app. It's not even to teach you all the Android APIs that we use to build it. It's really about retraining your brain to start thinking like a mobile developer, which is really important, because at the end of this course we're gonna ask you to build your own final project. We're expecting you to already be familiar with object-oriented programming, and to have experience with Java or a similar language. Personally, I got started with Android after years of Delphi and C# development. As engineers, we're trained to map our experiences in one language or SDK into new ones. Looking for patterns and shortcuts we can get up to speed as quickly as possible. But mobile, and Android in particular, have some fundamental differences that mean some of our experience and intuition will actually make us worse mobile engineers. We like to think of Smartphones as computers that fit into our pockets. In a way that's true, but they're computers from the 90s, like this Powerhouse I was using nearly 20 years ago. With limited internet connectivity, low speed CPUs, and limited RAM, on top of which, they're all running on batteries. As we go through the course, I'll be returning to each of these key mobile challenges. Looking for places where you're experienced on desktop or server, or even other mobile platforms might lead you in the wrong direction. I will also be back to tell you some stories from the early days of Android. Stories that describe how the Android platform has evolved. And nowhere is that more readily apparent than here, at the Android Lawn sculpture garden. Join me here, at the very heart of Android, at the end of this lesson, to find out how this sculpture garden of tasty treats, also tell us the story of Android's history. For now, let's get back to building that weather app. So, we'll cross to Dan, to take a look at some mocks. Thanks Raido. But let's start thinking about Sunshine, meaning our app. I'm not convinced I'm ever going to tire of the obvious puns our app name allows. Remember, as we progress through this course and build this app together, you should be thinking about the app you want to create. There are too many weather apps already after all. By the end of the course, you'll be ready to tackle the final project, using all your new Android know how to build your own app. Once you install Android Studio you can open it and check for updates before proceeding. Looks like we have the latest version installed already, so we can close this dialog. We're going to be setting up a new project using Android Studio version 1.01. As you follow along, if things look differently on your computer, that's okay. It's probably because you're on a newer version of Android Studio. For the most up-to-date instructions on how to get started, you can always check the instructor notes below. Now, let's click here to start a new Android Studio project. In the project wizard, we set the app name to be Sunshine. Then we provide a corresponding package name. The package name should be globally unique across all packages installed on Android. To avoid conflicts, use the reverse of the name of the internet domain that you own. This follows the Java package name conventions. We're using the combat example name space for our Sunshine app because it's a sample. But you cannot publish an app on Google Play with that name space. Usually leaving the default package name is fine. However, this course was originally filmed with a older version of Android Studio where the module name app was included by default. So, we'll edit the package name here, so it matches what we had in the older version of Android Studio. For your code to match the rest of the code in this course, you should add the dot app as well. Next, we choose our project location and then we can hit Next. Now we need to choose our minimum SDK version. In previous versions of Android Studio, you would also have to select the target SDK. Now the project wizard automatically sets the target SDK to the latest version of Android. Even though it's already selected for you, it's important to know the distinction between minimum and target SDK. Android 1.0 launched in 2008. And in just the six year since then, there has been 11 new major platform releases. On the Android developer side, we show the relative number of active Android devices running a given platform version in this pie chart, because pie charts are awesome. For our purposes though, you're really better off looking at this as a histogram. If you squint, you can almost see a vaguely bell-shaped curve, with the oldest releases here at the left, their popularity dropping off as devices are upgraded or replaced. The largest proportion of devices are here in the middle, representing devices about two years old. And the newest platforms, gaining popularity as new phones are released or upgrades go out, are here on the right. So with that in mind, the Min SDK acts as your low-pass filter. Google Play won't show your app on devices running a platform version lower than its minimum SDK version. So why not just set the Min SDK to one and support everyone? Generally, you'll want to target as many users as you can, but there's a cost associated with supporting some of these older versions. Things like creating different execution paths around deprecated or update APIs or presenting a different UX to devices with different features. So you need to balance the opportunity of expanding your audience with the cost of supporting those new users. Also, remember that each release introduced with it new APIs and hardware support. So it may not make sense to make your app available to devices that don't support your minimum feature set. By comparison, the Target SDK is not a high-pass filter. It's used only to declare which platform version you've tested on. An app targeted to a certain API will continue to be forward compatible on future releases. The platform uses the Target SDK values in case a future platform makes a significant change to expected behavior. This ensures your app doesn't break when a user's phone gets upgraded. If you're developing a new app, there's really no reason to target anything but the latest Android version. And once your app has been released, make it a point to update your Target SDK and test as soon as possible when new platform releases roll out so you can take advantage of every new platform optimization and improvement it has to offer. The distribution and latest version of Android changes frequently. But based on this graph, which version of Android should be the target SDK to provide the best experience on the largest number of devices. That's right. While setting Froyo as a minimum SDK, would allow us to support 100 percent of devices, it's the wrong choice for our target SDK. To ensure the best experience for users on all phones, including the newest KitKat releases, we need to set our target SDK to the latest build, which is KitKat. Thanks for telling us about the importance of proper dessert selection. So let's choose our desserts now. The earliest platform version that our Apple support is Gingerbread. At the current time, choosing Gingerbread means we can cover over 99% of the devices active on Google Playstore. It's also the cutoff for using Google Play services for things like maps and location and the Android support library. The support library package offers an implementation of ui features that were added in later releases of Android but now can be used on older versions of the platform. So it's really useful. Notice how we picked the latest version of Gingerbread with API level 10 because it contains additional bug fixes that API level 9 doesn't have. The we can go ahead and click Next. We're going to choose the template, Blank Activity with Fragment. For background context and activity serves as the present layer for our UI, and a fragment represents a behavior or portion of the screen. And now we have an option to modify the names of the files that will be auto-generated from the wizard. The name of our activity is MainActivity, and the layout will come from activity_main, which is an XML file. In a similar fashion, the fragments layout will come from fragment_main, which is also an XML file. I'm going to do a small change for the name of the menu file to be called main.xml because on a older version of Android's tu, that was the default name. Then we go ahead and hit Finish. And now you should have a newly created sunshine app with the files on the left here. By default, you may see the Android view of the files, which is a flattened version of the project structure, and it highlights the key Android source files that you'll need to edit. In this course, though, we're going to be using the project view because that's what we had in the older version of Android Studio. You can choose any view that you prefer, though. Make sure you wait for the gradle build to finish. If you have any errors, you can check the guide and instructor notes below. As a tip, you can check the build.gradle file, which is located under the App folder. You want to make sure that the compileSdkVersion and the targetSdkVersion are both pointing at the latest stable version of the platform. In this case, it's 21 for the Android 5.0 Lollipop release. Once it's done building, we can add a custom app icon that's more fitting for our weather app. Right-click on the App folder and click New Image Asset. You can choose from any of the clip art options or you can use the one that we provide in the download below. Then, use a placeholder icon we provide in a download below. Now this will show up in the All Apps screen, so that clicking on this app icon will launch our app. It will also show up in the overview space if sunshine is one of your most recent tasks. The other place you might see this app icon is in the action bar of our app. In certain videos of this course that were filmed earlier on Kit Kat by default the action bar shows the app icon. With material design on Lollipop and later, the app icon doesn't show up by default anymore, so don't worry if you don't see it. It's fine, and we're going to be styling the action bar later in lesson five, anyways. And now for the moment you've been waiting for, let's hit this green Run button. It will prompt us to choose a device, without a physical device we can test the app using the emulator that comes with the Android SDK. An Android virtual device should have already been created for you automatically when you set up Android Studio. So you can go ahead and click OK. While the emulator's booting up, I want to point out that if you ever want to modify your emulator devices, you can click on this button with the purple device and the Android, and open up the AVD manager to manage your Android virtual devices. It lists out your existing devices, and you can always create another virtual device. You can select the category of device and then a specific device. Then you choose which platform version it should be running on. And this is the only one that's available on this computer now. So Lollipop is good, and we choose the Google API's target, because it will include some Google services already pre-installed on the emulator. You can choose Next. There's a couple more options and settings that you can modify, for example, if you want an SD card, or a camera you can change those here, and then you can go ahead and click Finish, and it'll create a new AVD for you. The simplicity of hitting run and having your app appear on an emulator, hides a lot of complexity. Remember that Android is a full software stack. Adspace is a Linux Kernel, which handles low level tasks like hardware fibers and panel management. On top of that, are some core C and C plus plus libraries like Libsc and SQLite and the Android Runtime. That includes cool Android libraries and the Android virtual machines, Dalvik or more recently ART. Your apps run within its own instance of the VM using the classes and services provided here in the application framework. On top of that, sits the application layer, which includes your app and every other app that's installed on the device. So, when you hit Run in Android Studio, the first thing that happens is your code gets compiled into byte code that can be run in the Android Virtual Machine. That then gets installed onto the device. In Android Studio, this is done using gradle, a build tool kit that manages dependencies and allows you to define custom build logic. You can manually start a gradle build in the IDE by selecting make project. You can also do this by going to the build menu and selecting make project from there, or you can use the gradle console to observe any logs or build errors, or open the gradle tasks window to see any available tasks. Double clicking on any of them will execute it. This will work from the command line too. Once you've navigated to the root of your project folder, you can run gradlew tasks to see all the tasks that you can run. You can learn more about gradle by checking out the links in the instructor notes. For now, note that we start with the project, which gradle then builds and then packages the byte code along with the external resources such as images, strings, and uixml into an application package. This is called an APK, and it's a specially formatted zip file. Once you've got your APK ready to go, it's signed and then pushed to the device using the Android Debug Bridge or ADB. If we return to the terminal, you can see that ADB lets you interact and debug apps on any device, physical or virtual. Things like pushing and pulling files, viewing logcat output, or even running a remote shell. So once Android's GDO has ADB installed the APK, it uses ADB again to launch the app by sending a stock command via the remote shell, by identifying the package and class name of your main activity. Thanks Veto. And now it's time to install the Sunshine app on our phones. So to get started, let's grab a USB cable. We'll plug in our device and then we'll need to enable USB debugging. This can be found in Developer options in the Settings app. But note that on Android devices 4.2 and above, the option is actually hidden by default. To find the secret menu, go to the Settings app. Scroll down to About Phone. Then go down to Build Number and tap on that seven times. Then, when you go back to Settings, you'll see the Developer options menu appear. Also, set up your computer to detect your device. Check the instructor notes for more details. We're going to continue using a device because it's faster and smoother for development. But if you don't have one, that's okay. You can continue using the emulator that we created previously. Now in Android studio, you can hit the play button to run the app on your device. In the device Chooser dialog, you should see your connected device. To prevent the dialog from popping up in future times, check this box, and then hit OK to continue. Within a few moments, you should see it on your phone. On the other hand, as Raido was mentioning, you can use command line tools. >From the root folder of the project, use grade lw to build your app on Mac or Linux. Check the link in the notes below if you're using Windows. This first command grants execution permission to the gradlw rappers script. And you only need to do it the first time you're trying to build from the command line. Then you can call grade lw assemble debug. Once the build is successful, it creates an APK file at the app/build/apk directory. You can use adb to install the app. The -r command means that you can replace an existing version of the app if you've already done it before. For more tips on adb, you can see the instructor notes below. Then you can use this adb command with the activity manager tool in order to start the main activity. And there you see it on the device. And now we see it running in our phones. Woo hoo! Fist bump! We're on a roll. Let's go find Dan so that we can build up the sunshine UI. Woo! Let's build up the UI for the weather app. We've created our Android project. And understand more about basic tools. So let's go to the user interface for Sunshine. Specifically, we're building the initial screen. A list of forecasts for the next several days. MainActivity is launched when you start the app. At the bottom of MainActivity, we have PlaceholderFragment. PlaceholderFragment was generated by the template we used when creating our project. A fragment is a modular container within your activity. In later lessons, we'll look at how to use multiple fragments in a single activity. And we'll actually explain why, we're using them at all. But for now, our activity contains just this one fragment. So here in PlaceholderFragment, is where we reference our UI layout resource, called fragment main. This XML file lives in the Resource's RES directory of our Project Folder. You can see other kinds of resources here besides layouts, such as design assets or drawables, or strings. When our activity runs, it creates this placeholder fragment which then inflates the XML layout resource, converting everything in the XML file to a hierarchy of view objects in memory. By holding CTRL or CMD, depending on your operating system, and clicking on this reference to fragment main. Android studio will drop us right into the visual layout editor. Once we're inside a layout XML file, we can switch between the design tab, where we can drag and drop new UI elements and modify the layout visually. And the Text tab, where we can see and edit the XML that defined the layout and UI elements. All of the views we'll talk about here ultimately extend the view base class. The template we used gives us a relative layout, with some padding around the edges. We'll get into layout features like padding and margins, later. Inside our relative layout, is a single TextView that says, hello world. EditText, is a text entry field that is an editable version of text view. It has many options, such as whether it supports single or multi line. There are several styled versions of editText, in the text field section of android studio, such as Name, E-mail, Phone, or Postal Address Each one sets the soft keyboard into an appropriate entry mode. ImageView displays the image defined in its source attribute. It has some really useful features, like zooming and cropping if the source file is too large or has a different aspect ratio than the image view itself. A list view is a special kind of view that contains one or more view that are replicated to display sets of data. In this case, this single textView is used to display the weather information replicated throughout the list. We'll get into much more detail about list view later on. The editor is quite powerful. Without using any code, one can create relatively sophisticated layouts. Make sure to use the built-in styled text widgets for large and medium text. All of the text is just placeholder text, so you easily enter it using the visual editor. If you're proud of your creation, take a screenshot and post it along with the XML into the forums. Now that you have some background on the basic tools in Android studio, and a few of the basic android user interface views, Katherine will show you how to start making some sunshine. Perfect, thanks Dan. Since he's turned you into a UI expert now, where should we define this list item layout? If you're thinking the layout folder, under the resources directory, then you are correct. Here you can create a new layout resource file called list item forecast. Inside that file, define a text view as the root view, then assign it an ID list item forecast text view. Give it a minimum height, so that the list item isn't too short for tapping on and vertically center the text within that item. Go ahead and try it yourself now. And check the box when you're done. And here's the solution. You create a new layout resource file. Call it list item forecast. And the root element is a TextView. Then you just hit OK. Now that we have the item created, we can switch to the Text pane. Here's the solution code. We have a single TextView where the width is match parent and the height is wrap content. We also give it a minimum height. So the item is tappable. We use the framework preferred item height for this. Since there'll be more vertical space now with the minimum height, we specify gravity so that the text inside the text view will be centered vertically. Lastly, we specify ID, which we gave you earlier. Great. Now we have a list item Imagine spending hours, crafting the perfect layout. What happens to that layout, when you rotate the device, into a landscape orientation? Or when it's run on a device, with a much larger screen? The good news, is that Android provides excellent tools to help you with layouts. You'll want to understand them to make your app look amazing across the wide variety of phones, tablets and other devices you'll want your app to work on. Building something that looks great in the visual layout editor is the easy part. You also need to consider different screens and orientations. As you begin to layout your UI, there's a temptation to build it pixel perfect for the device you happen to be using at the time. This is reinforced by the fact that your apps window doesn't generally change size while it's running. So you can't just grab the lower i-corner and grow and shrink your app to see how it behaves. But if you've ever developed for the web or desktop, you know this static approach is a bad idea. When Android first launched, HVGA 480 by 320 resolution screens were standard. As we began exploring how to build engaging user experiences on those devices, we could use absolute layouts to define the exact location of each screen element. But within a year, the first WVGA Android phones were released. And now Android runs on everything from phones to phablets, tablets, TVs and wearables with any screen size, resolution and aspect ratio you can imagine. So, just like desktop or web where you might use panels or CSS, your Android UI needs to scale based on the screen it's running within, which is why absolute layout was deprecated. [BLANK_AUDIO] In favor of layouts like LinearLayout, RelativeLayout and GridLayout, they can dynamically resize and adapt to any screen, following the principles of responsive design. Responsive design, I know. It's fun to resize your web browser and see which sites resize gracefully, and which sites remain defiantly large with gross horizontal scroll bars. But responsive design is not just for the web. Today, the lines between phones and tablets are disappearing. So it's important to think about how your UI will scale in our multiscreen world. Don't be overwhelmed. Just like designing responsive layouts for the web, build your layouts to be reasonably flexible or within a common device size. Then you can set break points, providing alternative layouts for those various sizes. Think about it this way, small phone, large phone, medium tablet, and large tablet. Going back to what Rato said, frame layout, linear layout, and relative layout are three of the most common layouts you will use in building out your UI. These all descend from the view group class, designed to contain and give order to child views. They each have their strengths and you should always try to use this simplest layout that will get the job done. Frame Layout is great for simple layouts when you only have one child to view, like a list view that fills the entire content area. Linear layout is perfect for stacking the views vertically or horizontally, one after another, it is also the only way to break up the display proportionately. Relative layout is powerful but a bit more complicated compared to the others. Throw a bunch of views inside a relative layout, and then you can configure each views position relative to parent, the relative layout, or to sibling views, tons of possibilities. We'll explore these layouts in greater detail when we build more complex screens. For now, let's get back to building our forecast list. On the surface, creating a list of items is simple enough. Android includes a ScrollView into which you can place any linear layout that in turn arranges each item it contains into a vertical list. Note the items which have fallen off the bottom off the linear layout, and therefore aren't currently visible in that UI. The ScrollView, as the name suggests, will let the user scroll through the contents of the layout it contains. But there's a challenge associated with that approach on a device with limited memory, and where touch responsiveness is critically important. If you have 50 items in a list and can fit 10 items on screen at any given time, what's the minimum number of views you'd need to create in order to scroll through every item on the list? The answer might not be immediately obvious, but think about ways in which you can be more efficient in your use of the views used to display the entire list. Adding every item to the Linear Layout within the Scroll View, means that every view we create sticks around, taking up memory, even if it's never been seen. We want to try and create a way, that we only need to use, as many views as are currently visible in the screen plus one on either end, to make sure we can scroll without flickering. To do that, Android uses ListView. So let's take a closer look at that now. The ListView starts by requesting a view for every visible item, however many you can fit onto the screen. It'll also create a couple in either direction to make sure we can scroll without seeing a flicker as a new view is created and populated. Then it creates new items just in time. So it's next in line to be visible to the user. So if the user never scrolls to the bottom of the list, the ListView will never request that view from the adapter. But this is really just a half measure. As you can see, if the user keeps scrolling, we could potentially just keep adding new views, even if they disappear off the top of the screen. Eventually that's going to lead to the same impact in memory use and performance as if we had just created all of these views directly at the beginning. The solution is recycling each view as it scrolls off the screen, allowing it to be reused when we need to show another item as it moves into view at the top or bottom. So rather than having to create and then hold in memory each item of the list as it comes into view, we only need to do the creation step for the number of visible items and a couple on either side. Then, whenever a new list item comes into view, we just update the data displayed in one of our items in our recycle bin. The result? Less memory overhead, smoother scrolling and less view management you have to do yourself. This same recycling behavior is implemented across all AdapterView descended classes, such as GridView and ListView, which also introduces the reason that the adapter isn't built directly into these controls themself. By keeping them separate, your adapter defines how to display each element of the underlying data, while the adapter view implementation itself is responsible for controlling how each of these elements is laid out. Be it a list or a grid in these particular instances. Thanks, Rado. Now that we know the distinct advantages of using a list view, we can use a list view to display the list of weather forecasts in our app. Now which file in the layout folder should we modify to accomplish this? Well, we want to add the list view directly to the fragment. If you open up the fragment_main.xml file, you'll notice that the layout includes a RelativeLayout as a parent view, as well as a child TextView. Modify this file so that we show a ListView instead of a TextView and assign it an ID ListViewForecast so we can reference it later. Also, since this layout only contains one child's view, it would be more efficient to actually switch to a FrameLayout instead of a RelativeLayout. After you make the changes, compile and run your app. You will be a little bit underwhelmed with the blank screen, but that's okay. That's because we haven't populated the list view with data yet, and that will come in a later step. Check the box when you're done. You should have changed the TextView into a ListView element. Then you can remove this text attribute because you don't need it anymore. Now from the UX Mocks, you'll remember that the list takes up the whole screen, so we want to set the width and height to be match_parent. That will make the ListView match the dimensions of its parent, which is this RelativeLayout. And to find out the parent of this RelativeLayout, it's actually in this activity_main XML file because the fragment is contained within the activity. Within this file, we see that this view is also match_parent for height and width. So now we can confirm that the ListView actually will take up the full screen. Going back to the fragment_main file, we can add the id, listview_forecast, onto the ListView. And then, since this layout only contains one child, we can simplify the layout by changing this into a FrameLayout. With our ListView ready to go, we'll want to create some fake data to populate it. Open up MainActivity.java and then scroll down to the bottom where the PlaceholderFragment class is. Within the onCreateView method, create an array list of strings to represent the weather forecast list items shown in the wire frames. For example, the Today list item will be represented as a string shown here. When you're done, check the box and submit. At this point, we should have created some fake data to display in our list. We created an array of strings to represent each weather forecast item and then we turned it into an array list. Given some sample data how do we populate a ListView? Let's look at an example of some contact data and how it can be displayed in the list. We start with our raw data of contacts which is three contacts, as well as our profile images. Then we pass this data into the adapter so it has a reference to it. The adapter also knows how to build a list item layout for each of these data items. So it could go ahead and create the layouts for them. But we don't need to create the views yet until the ListView requests that it needs them. For example, if you had hundreds of contacts here, you wouldn't want hundreds of layouts sitting around that aren't being used. Then when you bind the adapter to the ListView, the ListView will ask how many items are actually in the data set. And the adapter will check in the data set, there's three items, so we will return that to the ListView. Now the ListView knows that it will have to populate itself with three list items. Now the ListView starts at position zero and asks for the list item layout located at that position. It goes back to the adapter and the adapter checks that at position zero, we have the contact, Anna. The adapter knows how to create a list item layout from the contact, Anna. So, it goes ahead and does that. And then we return it to the ListView. And now we see that the 'Anna' list item is located at the zeroth position in the list. Next the ListView wants to get the item at position 1, so ask for the layout from the adapter. The adapter checks that at position 1, we have the contact, Bob. The adapter knows how to create a list item layout for Bob, so it goes ahead and does that and then it returns it to the ListView. And now we see that the list item for Bob has been successfully added to the ListView at position 1. Now the ListView fetches its last item because it knows that there was three list items to expect. It fetches the last list item layout at position 2 by asking the adapter. The adapter checks that at position 2, we have Charlie, as well as that image. And we know how to make a list item layout for Charlie, so we can go ahead and do that, and return it to the ListView. And now we have the list item for Charlie at position 2 in the list. And we have our complete list. In our code, we're going to initialize the adapter within the Placeholder Fragment onCreate view method. Because that's where we want the ListView to be populated with data. We're using a ArrayAdapter, and we can initialize it with four parameters: A context, the ID of a list item layout, the ID of a text view within that list item layout, as well as a list of data. We'll go through each of these parameters one by one now. First, for context -- it contains global information about the app environment. It allows us to access system services and resources, as well as the application specific resources that we've defined. We use the fragments containing activity as the context. So, we're going to call getActivity for our parameter here. Since the adapter needs to know the layout for each list item, it needs some reference to the XML layouts that we've defined. The r.java class is a generated file that creates human readable identifiers for our resources. For the list item layout, we refer to it in code as R.layout.list_item_forecast. This was the name of the XML file that we created earlier. Next, the array adapter needs to know how to take the weather forecast string and set that to be displayed in a text view. So you pass in the ID of the text view that we defined earlier, in the list item layout. Even though these two resource IDs look similar, one starts with R.layout while the other starts with R.id. R.layout refers to a layout file, while an ID refers to a specific XML element with the matching ID attribute. And lastly, we pass in weekForecast, which is the array list of forecast data that we defined earlier. Now go ahead and initialize your adapter. Check this box when you're done. When you've declared your ArrayAdapter of Strings, it should look something like this. We pass in the context, which is this fragment's parent activity, as well as the ID of the list item layout, and the ID of the TextView we want to populate. And lastly, we pass in the forecast data. Once the adapter is initialized, let's bind it to the ListView. But you may notice that we don't have a reference to the ListView in our fragment. It was only defined in the layout XML. The system takes and inflates layout XML files, and turns them into a full view hierarchy with a root layout of the main activity at the very top of the view tree. We can also assign IDs to each view in the tree, but it's not required if you don't need a reference to an individual view. For example, this ImageView doesn't have an ID associated with it and that's okay. Within the Java code of the associated activity or fragment, if we need a reference to the button, we can simply call findViewById, which will traverse down the view hierarchy until it finds a view with an ID button, and then it will return that. Similarly, we can traverse down the view hierarchy to find the linear layout with the ID container, and then return that. We could do the same to find a reference to this TextView by traversing down the view hierarchy. But you'll notice that we already have a reference to the container which is the direct parent of this TextView. Hence, we can just call container.findViewById to search this subtree to find the TextView with this ID, and then return it. With this method, we have a smaller sub-tree to search for a given view, as opposed to searching the entire view hierarchy. In the Android Java doc for the View class, which is linked below if you want to follow along, it contains an example with a button with Define in Layout XML. It was assigned an ID, my_button. Then, in the Activity, we can use the findViewByID method with that ID, so that we can get a reference to the button. Then we can change it dynamically, such as by adding a click listener to it. Now in the Placeholder Fragment class, bind the adapter to the ListView. Luckily, we did assign an ID to the ListView earlier, so we can find it easily now. Think about the smallest sub-tree in the view hierarchy that you can call findViewByID on, then set the adapter on it. If you want an example, you can see one in the link below. Check the boxes when you're done. Here's the solution for binding an adapter to a ListView within the PlaceholderFragment class. First, we find the ListView in the view hierarchy by using the findViewById call and then, we set the adapter to it. The adapter will supply list item layouts to the ListView based on the weekForecast data. Note that the rootView here refers to the root view of the fragment, which we just inflated up above here. And now we have this beautiful list of weather data in our app. Great job! High five! (hands slapping) You accomplished a lot in this first lesson. Starting with nothing more than Android Studio and hope, you've created your first project. Built and deployed it to virtual and actual devices, and even created a simple list-based UI that's populated using an adapter. You also learned a little about what makes mobile and Android, in particular, a different environment to develop for the desktop, web, and server. But we've only just gotten started. The app we've got so far is using static mock data. So join us in lesson two to learn how to hook it up to real weather data. But before that, take a moment to cleanse your palate with a brief interlude exploring the history and evolution of the Android ecosystem. I asked my first Android question on Stack Overflow, on August 25, 2008. Was about a problem I was having on the 0.9 Android Beta SDK. Android has evolved quickly since then, and no where is there more power than here, in the Android Dessert Sculpture garden, at the very heart of Android, building 44 at Google HQ. More than just a convenient place to take a photo with a life-size sculpture of your favorite dessert, it also tells the history of Android. In terms of food, every Android launch has two things in common. Work from work, Bacon Sundays, and the crunch time leading up to each launch. And a dessert themed code named memorialized forever here, in the Android Dessert Sculpture garden. [NOISE] Each release brings with it new hardware, APIs, and features for developers to play with. The third major Android release, 1.5 or Cupcake, as it was code named, brought video recording and widgets to the Android SDK, and the first baked good to our front lawn. Android 1.6 and 2.0 brought with them giant donuts and eclairs as well as support for different screen sizes, and tracking multiple simultaneous touch points. The biggest challenge for Android 2.2 was coming up with a baked dessert starting with the letter F. A challenge we ultimately ignored, instead introducing this giant bowl of froyo to the neighborhood. Along with that, in cloud's device messaging to the platform. [NOISE] That brings us to Android 2.3, and this giant life-size gingerbread man, along with system support for barometers, gyroscopes and NFC. Android 3.0 was the Honeycomb release. The first one targeted, specifically for tablets and paving the way for Android 4.0. Android 4, Ice Cream Sandwich brought phones and tablets back together. It also introduced Android Beam, and everyone's favorite font, roboto. Android 4.1 Jelly Bean was the first platform release to feature rich expandable notifications. It's also the first sculpture to spontaneously combust thanks to a version one design, that we've since patented as a solar powered pressure cooker. But that's another story. [NOISE] Which brings us to the newest member of our team, Android 4.4, Kit-Kat. With sensor batching, host card emulation and an API for text messaging. So how do the dessert names get decided? Well ultimately, the only real rule is sequential lettering. Then it's down to intense lobbying, threats, bribery and [UNKNOWN] on the ease of spelling, cultural resonance and statuability of each proposal. Eventually something just sort of sticks. Even then, we can surprise ourselves. Take a look at the GIT history for the K release, and you'll see that even KitKat wasn't always KitKat. As for what comes next, we'll have to wait and see what the next statue is, before we know for sure. In lesson one, we built a new project with a basic UI backed with mock data. In this lesson, we'll hook sunshine up with the Cloud, replacing the mock data with real weather data using the OpenWeatherMap API. To do that, we'll learn about the Android permission system, Network I/O, and how to move time consuming tasks off the main UI thread. On that note, we're going to make our sunshine app 100 times better now by connecting it over the network to the OpenWeatherMap service. OpenWeatherMap provides a free weather data and forecast API. And the site is linked below, so you can follow along. By scrolling through the site, you can see what type of data is available. It also has example queries so you can click on this one to see what the weather is like in London. It includes a user friendly description of the weather condition, such as broken clouds, in this case. And we'll use this later in our app. For the full list of weather conditions, you can go back to the main page. And scroll down. And then, click on this link here for the Weather Condition Codes. And on this page, we have the full list of weather conditions. It contains everything, from scattered clouds to freezing rain, or even volcanic ash. I don't know about you, but hopefully that doesn't happen too often. Take a moment now to become familiar with the API by going back to the main page, and looking at the different queries and the different parameters supported. Just modify the query params in the URL address bar. Check the box floating in the clouds when you're done. Now, we should be able to find the most appropriate URL that our app should use. Based on the UX wireframes we saw earlier, we want the weather forecast for a week's worth of data given a certain postal cost. For the purposes of this quiz and our example code that we'll be showing you. We'll be using the Mountain View postal code, which is 94043. By all means you should use the postal code for your own location. Or you can use city name or latitude, longitude coordinates. If it doesn't find your location based on postal code. Try using postal code followed by a comma, followed by the country code. See the discussion forum for more examples. Next, we want the response from the server to be in JSON format. And we also want the temperatures to be reported in metric units. We choose metric for doing the query, but our UI will be able to displace celsius or fahrenheit based ion user preferences. Wnd we'll just do the conversion ourselves. Enter the URL in the box that fulfills these requirements. For the Mountain View postal code 94043, this is what the query would look like. You could have also used 94043 comma USA and that would have given us the same result. We set the mode to be JSON format. In reality, you actually don't need this parameter because this API sends back JSON data by default. But just to be sure, we set this parameter. Then we set the temperature units to be in metric, and the count param to be 7 days of forecast data. Let's take this URL and use it in our app. To fetch the data from open weather map within an app, first we need to make an HTTP request to the API at the URL that we decided on earlier. Then we need to read the response from the input stream to get a JSON string. It hasn't been parsed yet, but we'll worry about that later. Then we clean up by disconnecting the connection and closing any input streams. We also log any errors that we catch. Since it's a lot of networking boiler plate code, we've provided you with a code snippet that handles these steps. See the link for the GitHub gist below. After you've taken a look at it, check this box to continue. In the sample code provided you'll notice that we create a Http Url connection. To use Http to send and receive data over the network, we have two clients on Android. The Http Url connection class, as well as the patchy Http Client class. Both options support Https, streaming uploads and downloads, configurable time outs, IPB 6 and connection pooling. We recommend the Http Url Connection class because it's general purpose and light weight, and it's been optimized to suit the needs of most Android apps. To learn more about connecting to the network, see the training guide and blog post link below. You'll also notice in the sample code that we have lines that call log.e, which log error messages. With the adb command line tool and with the device plugged in, you can type adb logcat to see the debug and error messages that are being printed to the logcat. For more details on the logcat options, see the link below. Another way to view the logs, is to use Android Studio. If you click on the Screen Android button, it launches the Android Device Monitor. Which includes the DDMS tool that Rado mentioned earlier. Then click on a device and you can see that our app here, is a running process. If you click on the LogCat tab, then you all these log messages here, which is what we saw with adb logcat. Now try viewing the logs yourself with either of those methods. If you do both, then you get brownie points. Check this box to proceed. When you're logging a message in your app, you need to determine what log level it should be displayed at. Verbose logs should never be compiled into your app, except during development. Debug logs are compiled in, but they're stripped out at run time. Error, warn, and info logs are all kept. And this is what the logging API looks like. The first parameter is the log tag, which can be any string that you want to identify the log message. It's good practice to define the log tag as a constant in your class. Usually it's the name of your class or the app. The second parameter is the actual log message. If we go back to monitor, we can see that this is the log tag column and this is where the log message is. If you click on this drop down here you can filter the logs by log level. For example you can click on Error to see all the error messages. If you click on warn, you'll see all the warning messages as well as anything more severe than that. The same goes for the other levels. And verbose means that you can see all the logs at all log levels. As a PROTIP, you should avoid log spam for your sake and the sake of other developers. The log buffer could fill up and important error messages that you really need to see will either roll of the logs or it will get lost in the sea of unimportant log messages. Cool. Now that we know that we can use logging to debug our app, we're going to return to this networking code snippet here and drop it into the sunshine app to query for actual weather data. Open up your project in main activity.java. In this class, scroll down to the placeholder fragment class within the placeholder fragment class in the on create view method, scroll down and go ahead and add the networking code snippet here. To get her blank, is pasted below again if you need it. You may need to enable these options in auto import or add the imports manually. See the instructions below. When you run the app, you'll see that is crashes. Use log cat to figure out which error is the guilty culprit that caused the crash. We're assuming that for this quiz question. You're using a device that's running honeycomb or later. Use the emulator if needed. If you run it on your phone, your Apple crashed because of a network got main thread exception. We found this answer by connecting our device to our computer and then checking Android device monitor for the error. You can see here that this is our package name and this is our process ID. If you search the logs for that process ID then our error appears. It's triggered ultimately by a network on main thread exception. If you're curious as to what line of our code actually caused this, you can scroll down the stack trace to read more. This is our framework code that you can skip and here's where it actually hits our app. It's within the placeholder fragment class, in the onCreateView method. And it happens in main activity.java file, in line 116. So if we go back to the code, on that line you can see that urlConnection.connect actually caused the error, and that we can't do that on the main thread. When we said that the framework didn't want us to run network operations on the main thread, what is the main thread? Well, Android apps run by default on the main thread, also called the UI thread. It handles all the user input as well as the output, such as screen drawing. Thus we want to avoid any time-consuming operations here, otherwise the URI is going to stutter. Instead, kick off a background worker thread if you have to do some long-running work. This includes doing network calls, decoding bitmaps, or reading, and writing from the database. Okay. So, somehow, we have to move the networking code off the main thread. But how are we going to do that? Well there are several options, but let's look for the name of the Android class that simplifies background thread creation and UI thread synchronization, so that the results from the background work will come back onto the main thread, and then we can use it to update our UI. Search online and figure out the answer to this question and then enter the class name in the box. Here's some advice for you. If you ever get stuck on how to do something in Android and you can't find it on the developer's site you can try to check stackoverflow.com. It's a question and answer site that many Android developers use as a valuable resource. So chances are likely that someone has already asked a similar question that you have. If you answered Async Task, then you are correct. To understand why we chose Async Task as the answer, we can check the developer documentation. In this API guide on processes and threads, we can scroll to the Worker threads section. Right away, if you want to follow along, the link is included below. Say, for example, that you want to download an image from the network at this URL and then you want to update the UI so that it displays this bitmap. Well, creating your own thread to download the image is a valid option, but there's a lot of overhead to handle in making you app actually thread safe. After you download your image, you cannot directly update the UI from a background thread. However, Android has several options to run code that manipulates the UI to run from other threads. In this example, yet another runnable is created to get the bitmap result back onto the main thread to update the image view. This solution is a little cumbersome because you have to manage two runnables here. To abstract away this complexity we can use an async task and then to kick off the async task. For example, when someone clicks a button, then you just initialize the task, and then you can call execute on it, and then pass in any parameters that are needed. Notice that when you're extending the Async class, there's a couple of generics that you need to specify. The first is the type that will be passed into the do in background method. So, if you want to pass in this image URL that is specified string here and then in doing background you'll get a string parameter. The second one is for the type of object that you'll get when you get progress updates as a task gets executed. We're not using that here, so it's okay to specify that as void. And the third type is type of results that we'll be sending back to the main thread through the onPostExecute method The main advantage of the AsyncTask is that you get to focus on your app logic, what you need to do on the background thread, and what you need to do when it comes back to the main thread. You don't have to worry about the details of threads and handlers. Of the methods that I showed you, only doInBackground is required to be implemented. onPostExecute is optional as well as some other methods. For each method, tell us whether it's on the main or background thread. You have a 50% chance of getting each one correct or a 100% if you actually go check the java doc, so go do that now. In the documentation for Async Task, we can scroll down to the section that talks about protected methods. Here we see that different methods are called on the UI thread versus on the background thread. It also contains information on what order these methods are called in. Relative to the doInBackground method. For example, onPreExecute gets called on the UI thread before doInBackground. So with that information now, we can populate the answers to our quiz. As we mentioned before, onPreExecute happens on the main thread. And here you can do any setup work. Then doInBackground happens on the background thread. While this is running, you can actually call publishProgress as many times as you want, so that you can pass information to the UI. So that it can update an then tell the user that a certain percentage of the work is done. Each time this is called,. It triggers onProgressUpdate with some information. Then, you can show a loading indicator in your UI that says something's 10% done, 50% done, 100% done. And all this happens on the main thread. And then, once all of this is complete in the background thread, then it calls onPostExecute with the results on the main thread. Let's apply what we just learned by opening up the MainActivity.java file within our project. We're going to take this networking code snippet and move it over to it's own AsyncTask, so it runs in a background thread. The task is going to be defined within this fragment class. But speaking of which, it's actually still called PlaceholderFragment. Let's do a little bit of refactoring now by giving it a real name. Let's call it ForecastFragment. And then you can update it in other appropriate places as well. We can also move ForecastFragment into its own file that way the MainActivity won't get so long and cumbersome. Within ForecastFragment we should define a new inner class called FetchWeatherTask which extends from AsyncTask. And then you can move the networking code snippet here. After you make the changes and run your app, it should look something like this. There really should be no difference except it doesn't crash now. In the next step we will add code to execute the task. And later in the lesson, we'll do JSON parsing and updating the UI. In the meantime though, make these initial changes to your code. For the solution within forecast fragment, we implemented FetchWeather/task, which extends AsyncTask. The generics we use are just Void, and this is fine for now. Then within the doInBackground method, we copied our networking codes snippet, here. It's the same, except [INAUDIBLE] in certain cases we return null instead of setting the forecast JSON string to be null. Previously, the code was an on create view, which expected us inflate and return a view. So it's important that it got to the rest of the code. Even if there was an error in the networking code. Now that the networking code is in a sync task, there's really nothing that comes after this in the given background method. So it's fine to just bail early whenever there's an error. Also know that for our log messages, we've defined a log tag constant. At the top of this task. This log tag is defined to be the name of the FetchWeatherTask.class. The reason we use this syntax instead of declaring a string FetchWeatherTask, it because we want these two to be in sync. If you ever rename the class then it will throw an exception unless you also update it here. As we mentioned before, you're going to still see fake data in the app. We'll need to add code to actually kick off a background task from the main thread. For debugging purposes, it will be nice if we can execute the task any time we wanted by interacting with the UI somehow. So, we're going to add a Refresh menu option for debugging. A warning, though, this menu option should not shift in the final app. Before we go any further, I need to jump in here. Catherine has already said that the refresh button is for debugging only, but let's look at why. In real life, you should always seek to eliminate the refresh button from your app. A good app should work like a good butler, giving you what you want before you even have to ask for it. Much like the Save button, it's a relic of a bygone age. That's the best a reassuring safety blanket for those of us who grew up with floppy disks. With the ability to run background tasks or send messages directly from the server to our app, there's really no reason to force users to manually hit refresh. But the app is up to date and sync with the cloud should be a given. But like we said, this is for debugging, so like print line it's acceptable for this particular purpose. Let's also take a look at our background threading model, which of the following is potential an issue? Well, the transfer isn't happening on the UI thread, but that's not a bad thing. In fact, it's good that it's not happening on the UI thread. So that's not a problem either. Data transfers are an integral part of most modern smartphone apps, so that's not a problem. The real problem is that the transfer is happening on a thread whose lifetime is tied explicitly to a UI component, in this case an activity. So if the activity is terminated by something like a screen rotation, the transfer will also be terminated. Because it's being created within an activity, it can be terminated as simply as rotating the phone into a different orientation. So, should only ever be used for tasks whose lifecycle is tied to the host activity, and is expected to run for only a second or two. On mobile, it's unwise to assume that even the most trivial network access is going to happen quickly. So a better approach would be to use a service. An application component without the UI that's less likely to be interrupted. Possibly scheduled using an inexact repeating alarm. Even better, Android has a specialized solution know as Async Adapter. And it's designed especially to schedule your background data syncs as efficiently as possible. Better still would be using Google Cloud Messaging. This lets you notify your Async Adapter of changes on the server side. So you're only ever initiating network requests from your app when you know there's something to be updated on the server. For now we're concentrating on making our app work when it's in the foreground. But we'll return to look at these approaches to invisibly updating your app from the background a little later. For now, keep in mind that the Refresh button and the new thread solution is just a place holder while we hook up the rest of the app. Thanks Raido, with that in mind let's add a Refresh Menu button to our app. For temporary purposes only though, otherwise Raido would be mad at us. On Android, menu options are defined in XML and they can be declared for fragments or activities. When the fragment or activity is created, it inflates this XML into the actual menu items in the app. You'll see that there are Action buttons which are menu items that appear in the Action bar, such as this Search Menu item. This space is reserved for the most prominent actions in your app. Then anything else that's less important falls into the overflow menu by tapping on this button with the three dots. These menu items are ordered from most frequently used to least frequently used. And on larger devices that have more screen real estate, you can specify that some of these menu items can actually go into the Action bar if there's room. If you go back to our project in the Resources folder which is called res, there is a Menu folder and inside that there's a main.xml file. If you open that up you see the menu layout XML, and that there's a single menu option defined for Settings. It will never show up as an action in the Action bar, meaning that it will be in the Overflow menu. You can verify this by checking the app on your phone. To define the ordering of menu items, you can just add multiple items to this XML file, and then they will show up in that order in the app. If you don't like the order though, and you want to explicitly set it, then you can specify this order in Category, value. Right now it's set as 100, so that the Settings menu will be at the bottom of all the other menu options that we define in our app. The only Menu option that should show up below the Settings menu is the Help menu. Check out the link for more details. Since the fetch weather task is in the fragment, the menu option to trigger that task should be inside the fragment too. That means we should create a new menu layout for the fragment and we'll call it forecastfragment.xml. The file will live within the menu folder under the Resources directory. Inside that file, we'll declare the new menu option for refresh and give it this menu item ID. We'll also need to define a string label for this word, Refresh. We're taking this one step at a time, so just make the menu xml file change in this exercise. If you compile and run the app, there'll be no visible change. It won't show up on the device yet because we haven't inflated the menu item. Inflating it will be in the coding test after this. See how the menu main.xml is implemented as an example. For an additional hint, see the menu training guide below. When you're done, you can click on this box here. Here's the code for the Refresh button in the forecastfragment menu XML file. We want it to appear in the overflow menu, so we set showAsAction as never. We also declare the string. You can find the string here in the strings.xml file, which is located in the values folder, which is in the res folder. You can get your strings.xml file translated into different languages. This adds additional values folders, under Res. For example, you would have values-es, for Spanish, values-fr for French. And within each of those values folders, you would have a strings.xml file, which would contain the localized strings for that language. Since translation does cost money, as a pro tip, you can mark strings that you don't need translated using translatable=false. For example, if it's a proper name or if it's for debugging like this one, then you can indicate to the translator that they can skip over this strings Now that we have the menu XML, add the code in the fragment to inflate it. You can leave a placeholder for when the Refresh button is selected. This is what it should look when you're done. You should see the Refresh menu item there, but tapping on it doesn't do anything. That's fine for now. If needed, you can look at mainactivity.java for reference. If you get stuck and don't see the menu item appear, try to answer this question first: what fragment method do you need to call in order to report that it has menu options to display? The solution is that we need to call Fragment.setHasOptionsMenu(true). That way, we'll get appropriate options menu callback methods in the fragment, so that we can inflate the menu and for when a menu item is selected. And this is where the fragment inflates the menu. Remember from before that in the ForecastFragment class, we have a public empty constructor, and we also override onCreateView? We also define fetchWeatherTask here. Now, we're going to overide an additional fragment life cycle method called onCreate. This is where the fragment is created, and this happens before the onCreate view method, which is where the UI gets initialized. So, in onCreate, we're going to call setHasOptionsMenu to be true to indicate that we want call backs for these methods. When onCreateOptionsMenu is called, we're going to inflate the menu layout that we defined earlier called forecast fragment. We'll also get notified when a menu item is selected. When a menu item with ID action refresh is called, we're going to return true for now. We're going to go over the activity and fragment life cycle methods in more detail in later lessons, but if you want, you can read the documentation linked below for now. Now modify the code so that when the Refresh menu item is selected, it executes the FetchWeatherTask. But hang on. When you tap on the Refresh button, it actually crashes. Why don't you go check the logs to see what error is causing this. In the forecast fragment class, we modify the onOptionsItemSelected method. When the Refresh menu item is selected, we create a new FetchWeatherTask and then we call execute on it. While the call is no longer blocking the UI thread because it's an AsyncTask, the app will still crash. If we check the logs, we see that the app crashed. This time though, with a security expression. It says Permission denied and ask if you're missing the INTERNET permission or not. And indeed, we are missing the INTERNET permission, so we need to request it. Take a moment to explore the security section of developers.android.com. Which of these following activities can only be done after declaring a uses-permission in the manifest? While declaring a commission is required for using a camera, making a phone call, or accessing contact details. You can do each of these things using a system app as an intermediator. Because the camera app, dialer, and contacts app will each be used to provide the data you request users have the chance to cancel the action you initiated giving them run time ability to refuse your access. However, UI can only access the user's current location if it explicitly declares a user's permission. Thanks Fredo! So, like old times, we're going to need to ask for permission. Go ahead and change the Android Manifest file, to request the Internet permission. And then tell us the exact string name of the permission that you used. Run the app again, to ensure that it doesn't crash. You can also log the output of the network call, to verify that you got the weather data back correctly. The answer is android.permission.INTERNET. I'll show you now, where it's located in the code. Under the main folder open up the Android manifest.xml file. Within the Android manifest file, we declare uses permission, with the name of the permission. We verified that the data returned is correct by adding a verbose log statement for printing out the forecastJsonStr. This is in the fetch weather task. We can verify that it's going to show up in the logs. For this example, I'm going to use the command line. These are the real time logs, and then if I hit refresh, then I see the weather data here. The verbose log, and this is our log tag fetch weather task. Here's the forecastJsonStr, and this is all the output from the server. Great work. Thumbs up. The data has landed safely on our phones. But I was thinking about it, and actually instead of hard coding our post code in, we'd really [SOUND] like our sun train app user, to be able to change their location in the settings. So let's make the FetchWeatherTask more flexible by having it take as input a postal code parameter. While we're doing that, we should also take this opportunity to do a little bit of refactoring. Instead of concatenating the strings for the server query URL, we should use a UriBuilder Class to build up he URL. We can declare a base URL and then append each pair of query PARAM and PARAM values onto it. This includes PARAM's for post code. JSON format, metric units, and date count. This'll make it easier in the future if we ever have to make these options configurable by the user. If you want to verify that the URL is built up properly. After you do these tasks, you can use verbose logging to print it out. In the Forecast Fragment, we want to modify the FetchWeatherTask, so that we can pass in the postal code parameter when we execute that task. You can click on this class, to jump to where it's defined or you can use this shortcut. And here you see that we modified the generic input type, to be a string so that the doInBackground method receives string params. Now, we only passed in one string param, 94043. So when you see down here later, we can read out the zeroth position in the params array, to get that postal code. Notice that we're using the UI builder here, and we're appending query parameters, one by one. We define constants for these query params, as seen here. And for the values, we also define them up here. You can imagine that in the future these might be configured outside of this class, but for now we're just going to define them here. To verify that this URI was defined properly, we add a verbose log command to print out the built URI. Let's verify that the log we added actually shows up. In overflow menu we tap Refresh. Then we see the log tag FetchWeatherTask with our UI printed out. It says 94043, jSON format metric units, seven days. So this looks correct. The URL that we built looks good, and the JSON string from the server, also looks good, however, it still is one long string. Let's look at it more carefully to see what data, we should extract from it. In order to make sense of the string that comes back from the server. We can put it through a JSON formatter or a JSON prettifier. If you Google for those terms, you'll be able to find a helpful tool, such as this one. Here we pasted the result of the web query. Then it formatted the output for us, showing us the hierarchy of these element. Now based on the wire frames that you saw for the sunshine app, can you tell us which of these leaf nodes we care about extracting? Even though we will have to traverse through parent nodes, for the purposes of the quiz on the next screen, we're just looking at the leaf nodes. Make your selection below on which attributes we'll need to display the list of forecasts. These are the attributes that we care about. You might be wondering why time is not included. The weather API provides the date and GMT time, but doesn't provide time zones for the location. So unfortunately, the date could be incorrect in some cases depending on your location and time of day. Instead, for a more accurate experience, we'll be computing the date ourselves based on the device time of when you fetched the weather forecast from the server. For the next step, let's do an exercise that focuses on extracting out the value of one of those attributes. We're going to do this exercise a little bit differently. You'll implement this on the Udacity platform. And we'll be able to verify that your code is correct. After this video, you'll see an IDE like this. Where it contains some starter code, as well as some j unit tests in a separate tab. In particular, we want you to implement this function, to get the max temperature for a day. You're given a weather JSON string, formatted the same way as you would get from the Open Weather Map service. And you also get the day index that we care about. Feel free to play around with the code in Android Studio, or a separate development environment, before you paste your answer here. Or you can use the Udacity IDE. Whichever feels more natural to you. For the solution we look for the list array. Each element in the list represents one days forecast. Given the day index we find the temperature node and then the max temperature. And this is what the code would look like. We change the JSON string into a JSON object. Then we look for the list array. Within that we find the day we care about. Then we look for the temp node. And then find the max temperature. Once you've learned how to parse JSON data, it's pretty straightforward to be able to parse the rest of the fields that we need. Since this isn't a course on Java or JSON, we're going to provide you with the parsing code in the gist below. And this is what the gist looks like. There are three helper methods. The first is for formatting dates. The second is for rounding temperatures. The third is returning a forecast JSON string into an array of forecasts. This method also handles associating a date with each forecast entry. We start with a current date, and we increment one for each successive day. Notice that we also use Julian dates, which is the number of days that have passed since the beginning of the Julian period. More information is in the instructor notes below, but it's how we'll consistently deal with dates in our app. That way, when comparing dates, we don't have to worry about taking into account time zones or daylight savings time. Update the fetch weather tasks to use these helper functions and the doInBackground method should return a string array of forecasts. You can log the output to check that the array is correct. The format of one day's forecast should look like this. We want the FetchWeatherTask to return an array of string forecasts. This means we need to modify the return type of the AsyncTask to be a string array. The effect of this is that the doInBackground method will now return a string array. In this method, after we query the server and then read in the input stream, we're going to perform this code. To parse the response from the server, we call getWeatherDataFromJson. We pass in the forecast JSON string, as well as the number of forecast days. To make sure that this is returning the right string array, we can go into the method, and then at the bottom of the method, we just add some logging statements to print out every element of the string array. Now, when you compile the code and run it on your device, you can hit the Refresh button to pull the data from the server. Then, if you open up log cat, you can see that it was parsed correctly, where you see all the forecast entries being printed out. >From the logs, we know that we have the right forecast data and it's in the right format that we want as an array of strings. So it's finally time to update the UI. Think back on how AsyncTasks are able to pass data back onto the main thread. You can hit Ctrl+O to see the list of available methods we can override in AsyncTask. If you click on any of them, it will be prepopulated in the code for you. Then, you can update ArrayAdapter with the new data that was retrieved by the AsyncTask. As a hint, you can make the ForecastAdapter be a global variable. That way, you can access it from within the FetchWeatherTask. Make sure that this is not a static class, otherwise, you won't be able to access the member variable from the forecast fragment. Then, go ahead and compile and build the app. When you run it, and you hit the refresh button, you should see a week's worth of weather data for your location. Once it's working, you can remove the verbose log statements so you don't clutter the logs. As you're working on this code, if you see an unsupported operation exception, make sure that when you're creating the fake data, that when you initialize ArrayAdapter, you passed in a list of strings, and not an array. That way you can call the clear method or the add method on this list collection. The solution is to override the onPostExecute method of the AsyncTask. And this runs on the main thread. We received the string array of forecast results, which came as a return value from the do in background method above. First, we clear the ForecastAdapter of all the previous forecast entries. Then we go ahead and add each new forecast entry one by one to the ForecastAdapter. This is what ultimately triggers the listView to update. Note that if you're targeting Honeycomb devices and above, you can use an addAll method here, so you don't have to add them one by one. You can just add it once and update the listView once. Once you hit Refresh, you'll see the weather forecast for the next seven days for your location. Even though we hit Refresh, we don't have any verbose logging statements being printed out here. We don't need them anymore, because we have a way to check that our code is correct by looking at the UI now. Do you remember this diagram from lesson one? The adapter has a reference to the raw data. And has instructions on how to build each list item layout. These layouts eventually make it into the list view here. But what happens if any of this data changes. Let's say for example, there's a fourth contact named Don. The adapter knows how to create a list item layout for Don. But now the list view is outdated because it only has three items. Somehow, we need the adapter. To notify the list view that things have changed. And lucky for us, there's a method called: adapter.notifyDatasetChanged( ). This notifies any attached observers, like this one, that the underlying adapter data has changed. Then the list view needs to populate its children again. So it asks the adapter how many items there are? And the adapter responds with four. Then the ListView goes and fetches each one individually until it fills up the screen. And it's through that method that the ListView is able to get all its list items. But now you must be thinking. How did we actually update the ListView successfully, without adding this line of code in our app? Well, with a ray adapter, whenever you add or remove elements from it, it internally calls notifyDataSetChanged. That means we don't have to do anything. But how can be confirm this? Well, we can check the actual implementation of the ArrayAdapter class in the framework. And here's the code for the ArrayAdapter class within the Android framework. You can follow along with the link below. First, we're going to search for the Add method. Remember, we added forecast strings. To the adapter using this method. And sure enough we see that, the notify data set changed method is called internally. But you might be thinking what about this Boolean here. Well let's look it up. If you scroll to the top you'll see that, notify on change is declared as true initially. As you go through your other references you'll see that it's only changed here. In this set notify on change method. Since we don't call this public method, with the value false, then we know that we're going to be safely notified each time the adapter updates. Now let's go back to the add method. I want to show you one more thing. You'll notice in the add all method, it only notifies its observers once. Whereas in the add method every time you call this it will update it's observers. That means that our code actually is refreshing the list every time. So, if you're targeting honeycomb of above you can use this method to be a little more efficient. In general don't be afraid to try and do this on your own. As a general pro tip, if you're ever unsure about something, feel free to go and check the Android source code. Don't treat the framework code like a black box. Take advantage of the fact that Android is open source. The more you learn about the platform the better of an Android developer you can become. Now that our app is showing real data, we should take a screenshot of our app, so we can remember what it was like when we made it this far. I personally like doing this throughout the process of building an app, because then I can look back, and see how it evolved. I'm going to show you one way that you can take a screenshot of your device. Open up Android Device Monitor and then click on the device here. Then, click on this camera icon, to do a screen capture. When it pops up, you can hit Save, and then you're done. On certain physical devices, there are actually hardware keys that allow you to grab a screenshot. For example, on the Nexus 5, you can long press on the volume down and the power key, at the same time. That takes a screenshot. It gets saved to the Photos app and then you can share it out to anyone you want. You can show them what an awesome app you're building. And now you're done with lesson two. Woohoo. You've made a huge step in being able to transfer data from a server and bring it all the way down to your device. Think about all the possibilities now of valuable information you could bring down to users to be available at their fingertips. And that's pretty powerful. Speaking about making an impact, have you thought about what you're going to do for your final project yet? You can choose any topic that you want. Share your ideas in the class discussion forum, and you can share with your friends on social media too. Over to beta now, while I take a quick nap on this Done pillow. I'll see you in lesson three. So now you've taken a UI with mock data and learned how to update with the real data. You learned how to use permissions, move time consuming processes of the UI thread, and were introduced to the basics of network I/O. Join us again in lesson three, where we'll create more activities and learn how to navigate between them. But first, come with me as I take you on another voyage in to the history of Android As of July of 2013, one and a half million new Android devices were being activated every day. So it's hard to believe that just a few years ago, I started all meetings with potential developers explaining what Android was and convincing them that it was worth their time and effort developing for the platform. It wasn't until 2010 that we even shared numbers to indicate the growth of the platform, 100,000 daily activations in May of that year. Which quickly grew to 500,000 in mid-2011 and crossed the million daily activations mark in 2012. That represents over a billion Android devices around the world, which is why I don't start my presentations asking if anyone in the room has an Android device anymore. To me though, the biggest surprise in those early days was how much effort was required to convince people that developing for mobile at all was a worthwhile investment. A huge number of people use their phones to go online and many of them use their phone as the main way to do so. One study by the Pew Research Internet Project in 2013 found that nearly two-thirds of mobile owners use their phones to go online, double the rate found in 2009. And that a third of phone users use mostly their phone to get online. Think about that for a second. These portable phones have become pocket computers constantly connected to the cloud to make the sum of human knowledge available to us at a touch and a glance. It's no wonder then that for a growing number of people, mobile isn't how to get online when you're away from your desk. It's actually displacing PCs as their primary computing platform. The change is so dramatic and the trend so clear that companies like Google, who depend entirely on the internet, have a mobile first policy, ensuring that the mobile experience is the first consideration when building new products. This trend is particularly evident amongst younger users who grew up using mobiles and especially in emerging markets like Africa and Asia, where the infrastructure to support ubiquitous broadband for desktops isn't as readily available. I saw this firsthand when I had the good fortune to visit Kenya a few years ago. Ubiquitous phones and passionate, talented developers weren't really familiar, but what really struck me was the degree to which mobile phones had become an integral part of people's everyday lives. It wasn't just checking email and posting to Facebook, it was using [UNKNOWN] to buy everything from groceries to bus fare. Mobiles was such a part of life that I heard rather than buying someone a drink to show that you're interested, you'd send them a phone credit so that they can call you if they felt the same way. In the transition of smartphones from tech accessory to a part of life to the main way you get online to how you pay for things, even how you flirt, represents a huge opportunity for us as developers. The question is, how are you going to change the world? Sunshine is now using real data thanks to the OpenWeatherMap API. And it's time for us to build out more of the UI. In this lesson you'll learn how to create activities, create the structure of your app, and learn how to navigate between screens. And that means learning more about activities, the intent framework and even learning how to use activities that come from other apps within your own. Hey, Dan. want to see our weather app, so far, that we've been building? Pretty cool. But I want something more. Well, we're not done yet. We just started two lessons ago. Give us a break. But fair enough, there's still a bunch more work left to do. What do you think we should do next? Well for starters, let's make the list item do something when you click on it. Well, since you seem to be the expert on clicking on list items, why don't you do it? I'm going to go eat some jellybeans. I think Catherine was mocking me there. Speaking of mocks, let's go do some UI. Sunshine looks something like this, but it doesn't show most of the fun information we have about the weather. We want to show a detailed view when the user clicks on a day within the list. Okay, that was a bit anticlimactic. It doesn't really do anything useful yet. But it will contain all sorts of great weathery details, things that weather nerds love such as barometric pressure and that navigators love such as wind speed and direction eventually, but baby steps. >From the mocks, we can see when a list item is clicked we should perform an action to open up the details page for the forecast. How do we implement the click listener behavior? Take a look at the ListView documentation. What method is used to wire up behavior on a list item when it is clicked? The answer is setOnItemClickListener. We should register an OnItemClickListener with the list view via the setOnItemClickListener method. Then, when an item in the list view is clicked, the callback is invoked. When the list item is clicked, use Android's Toast mechanism to display the weather forecast string. A Toast is a pop-up that displays a message for a few seconds before fading out. It's particularly useful for debugging, where it can be used as a way to indicate status visually without altering the app UI. We're going to put our list view, set item click listener into forecast fragment inside of the onCreate view method. We'll just start typing listView.setOnItemClickListener and let the auto complete fill in the rest. Inside of this function, we're going to add click listener, which we can instantiate in place. Here's where we can call the code in Android to display the Toast. Now that you know where to place the Toast code, take a look at the Toast documentation. Add a Toast when the list item is clicked that contains the weather information. Hint. You can get the forecast by getting an item from the forecast adapter, at the position given by the OnItemClickListener. Done already? Let me show you how it's done. As I said before, we get the forecast by calling getItem from the forecast adapter. And here's how we actually display the toast. Note that the context is actually available through getActivity in our fragment. However, it won't do anything unless we also show the toast. Displaying a toast is useful to see how an Android interaction works. But this method should really be used to start our detail activity. This is what we'll do next. You're going to use Android Studio to create the DetailActivity from the Blank Activity with Fragment template. The template asks for the hierarchical parent of DetailActivity, which defines the UP button noted by the app icon, and a left-pointing carat here. But what does "up" mean? If you mapped out a hierarchy of all screens in the Sunshine app, the root of the tree would be the MainActivity, and it's child would be the DetailActivity. So, the UP goes to the MainActivity. While the BACK button can achieve the same effect, it can also bring you back home, or to another app, depending on your history of screens. UP will always navigate you within the same app to the parent, regardless of how you arrived at this screen. Create the detail activity now, and look at how the activity is declared in the Android manifest file. We start by right-clicking on our package name to create the new activity from the Blank Activity with Fragment template. So for Name, we use DetailActivity, and again, the hierarchical parent of this class is going to be our MainActivity. So as you can see, we now have a new DetailActivity along with the XML for activity_detail. And, a fragment associated with that activity. Great! You're done. But we still aren't launching our new activity. To move from one activity - in this case, the MainActivity in our Sunshine app, to another, here the DetailActivity - we call StartActivity. But note that when using the StartActivity method, rather than specifying the class name of the activity to start directly, that class name is packaged explicitly within an Intent. The basic premise is simple: Whenever you need your app components to communicate with each other, or the system, you use Intents to identify the target destination. Starting activities within your app is the simplest example... with your Intent explicitly indicating the target using the context and a class name of the activity. Intents that use the name of the component you're targeting directly are known as Explicit Intents. I like to think of intents as envelopes, each one who includes who, or in this case, which component you want it delivered to. And there's room for a small amount of data to be delivered, packaged as extras. Primitive tuples that will be available to the application component that ultimately receives and opens this intent. An explicit intent explicitly specifies the name of the recipient, as you can see on this envelope. Implicit intents are a lot more interesting. Here, we don't specify the name of the class. We don't even know what it is. So, how do we indicate which activity to launch? You know those stories you sometimes hear about letters with fake addresses like these that somehow still find their way to the recipient? Well the intent resolution system on Android works the same way, finding an activity capable of performing the action you specify on the associated data. So, rather than specifying the name of a class, you indicate an action you'd like an activity to perform, and on what data that action should be performed. Like this, where we want to address an activity that's capable of viewing a website. And because intents can cross through application boundaries, the activity that started may not be part of your app. So, you can include functionality like this, browsing websites or making phone calls or choosing a contact from your address book, all from within your app, without you having to implement any of it yourself. You don't even need to know about the app that will ultimately service your request. You can find details of some of the intents supported by native apps in Common Intents page of the Android developer site. Thanks, Rado. Now that you understand what intents are in glorious metaphor, let's use them to do something useful. We'll replace the Toast, with an intent to launch the DetailActivity. You'll need to pass in weather forecast data for the detail activity to display. For more information, see the intent extra contants defined in the intent class. The solution is to lauch an explicit intent to the Detail Activity Class. We'll go to On Create View, where our On Item click listener is defined. To pass in the Weather Forecast information, we can use an intent extra, which is a key value pair in the Intent. We use the key name, Intent.extratext, but we can use any string for the key, as long as we use the same key when reading the information out. Just as in the toast, we obtain the forecast data from the current list item by calling get item on the adapter at the given position. Once we've added the intent, we just start the activity. Once the Detail Activity is launched, it shows Hello World. Instead, we want to read the forecast data from the Intent, and display it. Make the appropriate changes in the app, so it matches the mocks. Then verify the behavior by compiling and running the app. In the fragment detailed layout, a text view is already defined. We have to assign it an ID so that within the detail fragment of detail activity we can use view by ID to find the text view. To determine the forecast info that the text view should display, we can access the intent that the detail activity was launched by. We're going to use this inside of onCreateView. (clicking, pressing key) Since we added an intent extra with the forecast data there, we can read that intent extra back to display in the text view. As you can see, we pulled the forecast string from the intent, find our rootView, and then set the text to that forecast string. Woo Hoo! Clicking our list items works. Woo Hoo. (claps) - Our app is awesome. - Yeah. But clicking on the settings menu does nothing. Wah wah. #sadtrombone. Mm, don't do that again. Let me save you from Dan. And let's go build the settings now. Let's go through the wire frames for the Settings UI. Within the detail activity in the overflow menu, there's a Settings menu item. When you tap on the Settings' menu item, it opens up the settings activity. If you tap of location, it pops up a dialog, where you can enter in your postal code. Feel free to use your preferred method for inputting location, such as city name. Just verify that the data coming back from the server is for the location you expect. Note that there's no validation on this string input. If you're trying to make this app a production app, you would want some kind of error handling here. If you tap on pick your units, it opens up a dialogue where you can choose to display temperature within the app as either metric or imperial units. This is basically just Celsius or Fahrenheit, and that is what this settings activity does. Remember that you don't want to make everything a setting. If you're discussing a feature with a teammate and you can't decide on something, don't compromise by just making it a user setting. There are instances where making a difficult product decision now will be better for the user, because then they won't have the burden of having to decide what the value of the setting should be. And remember, there's always an opportunity in an app update to add the setting later. If you add it to begin with, it's infinitely harder to take away the setting because some users might get angry with you. If you're having trouble deciding if something should be a setting or not, you can check out the setting section in the Android design guide, which is linked below. It contains a workflow diagram that could help you. Very few roads often lead to making something a setting. Open up the Developer API Guide for Settings, if you want to follow along. If you've pondered it carefully and you've decided you really want this to be a setting, this is what you do next. Android provides a way to display a hierarchy of preferences, including headers, such as the ones shown here. The value of the preference is called the preference summary, and that's seen here. It looks almost like the subtitle text. The preference also provides UI to allow users to modify that setting. You just need to supply the strings, but you don't have to implement the UI like the spinner here. Common preference types are the check box preference, list preference, edit text preference. We can see some examples in the settings app under developer options. Here's a bunch of preferences. This is an example of a check box preference. This is an example of a list preference where you have different radio button options here. Once the user changes the setting, it gets saved in the default share preferences file. This stores a bunch of key value pairs of primitive data. An example integer preference could be how many days of e-mail history should be saved locally on the device. You could have a string stored integer preferences for what the currently selected account and device is. Then at any time you can fetch the value of this shared preferences, as long as you pass in the name of the key that you want. You can also use shared preferences outside the context of settings as well. This information is located in the developer API guide, for storage options, which is also linked below. We'll take advantage of what the framework offers in order to build our SettingsActivity. Since we're supporting Gingerbread devices, we'll use a preference activity class. If you're targeting Honeycomber later, you'll want to use the PreferenceFragment class. Create a new SettingsActivity class from the gist provided below. Update the AndroidManifest to declare this new activity. You can see the way detail activity is declared as an example. If you see that APIs are deprecated, that's okay. That's a side effect of using PreferenceActivity, in order to target Gingerbread devices. When you create your app for your final project, you can use the wizard in Android Studio to create a new SettingsActivity. The code the wizard provides will make your app backward compatible, by using a combination of preference activity and PreferenceFragment. Our gist is meant to be a simplified version of that for learning purposes. So later, you'd be able to understand better what the wizard is doing. Check these items off when you're done. First, we create our settings activity, and this is the code that we got from the gist. Then, in the Android Manifest, we declare the settings activity. We give it an activity named Settings, which is declared in the Strings file. We also declare the main activity as the parent activity. That way, when you hit the up button in the settings activity, it will return back to the main activity. Now it's time to launch a settings activity from the menu item. We need to launch it from two places, the Main Activity and the Detail Activity. Afterwards, compile and run the app to make sure that it works. This is what it should look like from the. Main Activity, if you tap on Settings menu, it should be bring you to the Settings Activity. It is expected for it to be blank, because we haven't populated it yet. Now let's try the Detail Activity. If you tap on a Forecast, you can go into the Detail Activity and then you can go into the Settings Activity. Complete the task and then verify that your app behavior is like this. In the directions that I just provided and in the following videos of this course, you'll notice that the settings activity had an action bar at the top of the screen. When building your app with the latest version of the Support library, the action bar doesn't show up by default in the Settings Activity. As a result, it's expected and correct that your device looks like this with no action bar. Don't worry, we'll add the action bar back when we change the theme of the Settings Activity in lesson five. For more info, check the instructor notes. In order to launch the SettingsActivity, we modify Mainactivity.java in the On options item selected method. When the Settings Menu Item is selected, we create a new, explicit intent to the SettingsActivity Class. We call Start activity to launch this intent. We don't call StartActivity for results because we're not expecting a result from the SettingsActivity. Similarly, in the detail activity class, when the settings menu is selected, we launch a new intent to SettingsActivity. We have our settings screen, but no settings. In the next several sections, you're going to be adding our two settings. I'll walk you through how we add our first setting for location, then you'll do the temperature setting on your own, so listen closely. First, we design a Preference XML file. The root element should be a PreferenceScreen. In this example, we have a CheckBoxPreference and a ListPreference inside of it. In order to add the Preferences XML file to our app, we first need to create an XML folder under the resources res directory. Right-click on the res folder, go to New / Android resource directory, and then type in xml as the name of the directory. For resource type you can use xml and then hit OK. Inside this folder, we right-click to create a new XML Resource File. We call it pref_general, and the Root element is a PreferenceScreen as we saw on the developer's site. And then our Preferences file is created. Then, add the location preference. Since the wireframes showed an editable text field to input user location as a string, we make this an EditTextPreference. If you want to learn more about all the possible XML attributes, you can Google for EditTextPreference. First, we specify a title for the preference, which will be the label that's displayed to the user. Then, we specify a key. And this key is actually the Key Value in SharedPreferences. Going back to the code, we also add these attributes to describe the Edit Text field in the pop up dialog that was shown in the wire frames. Going back to the code, we can also configure properties of the Edit Text field. We specify the input type to be text, and we cap it to a single line of text. It's bad practice to hard code these strings here, so we declare them as constants in the strings.xml file. These are the strings we declared. This is the name of the label of the preference. It's user-visible, so we add a char limit for translation purposes. You also specify location, which is the name of the key in Shared Preferences. We don't want to translate it because we always want to find the key based on this name. We also specify a constant for the default location. We also don't translate this because we need to send it to the server API like this. When you're done with these steps, check them off and continue. To make the preferences appear on the phone, we need to modify settings activity. In the on-create method, we're going to replace this to do with some code. We're going to call addPreferencesFromResource with the pref_general xml that we defined. Then we need to bind the preference summary to the value of the location preference. This means that when the user changes the preference, the summary value underneath the label will be updated. If you look at the declaration of this method, we see that for a given preference, it sets a preference change listener on it. If you scroll to the top, you see that the settings activity actually implements the interface on preference change listener. That method is found down below, where we override the on preference change method. Remember that our location preference is actually an edit text preference. So it won't fall into this case, but it will fall in this case down here. Then, in the settings UI, you can see that the summary is now the value. Make these changes in your app. See the instructor notes for the lines of code you need. Once the user's location preference has been stored, when do we make use of it? We need the preferred location when we query the weather service. Luckily, in lesson two, we modified fetch weather task to accept a location parameter. We hard coded it to be the Mountain View zip code, but now we should use the location stored in shared preferences. We haven't explicitly shown you how to do this, so you might need to do some digging around on the Ander developer site to figure out how to do it. Once you've made the change, check the box to continue. Within the forecast fragment class, when the refresh menu item is selected, we read from SharedPreferences. Since they are key-value pairs, we get their value stored for the location key. If there's no value stored then we fall back to the default location. Then we pass the location into the fetch weather task. On app launch, I know that you're probably tired of seeing the dummy data and needing to hit the refresh button for real data every single time. I'm going to show you how to display the data using the current settings each time the activity is loaded. In forecast fragment, we just refactored the code so that when the refresh button is selected, we call this helper method, updateWeather. Now that it's in a helper method, we can also call it from the onStart method. We over write onStart so that the refresh happens whenever the fragment starts. This will cause the weather data to appear. We'll learn all about onStart, and the rest of the Android life cycle in the next lesson. At this point, we can also remove all the fake data that we had in the onCreateView method. Then we pass in an empty array list to the ArrayAdapter. Now we can test this. We need to make sure that this is the first app launch and that it wasn't already running, so if it's already running, kill it. Then tap to open the app, and then you should see the actual weather data immediately. Under settings we can change the location to be the pairs postal code. We hit OK, and then return to the main list, and then we see that the weather data has updated. Now it's your turn to build the temperature unit setting. This will bring together a lot of the concepts that you've learned and will take some time to implement, but we think you're ready for it. Modify the app so that the right temperature units are displayed to the user. Use the assumption that we're syncing metric data from the server. Eventually, we'll have a database on the device and we don't want a mix of Fahrenheit and Celsius data in there. Hence, we'll stay consistent by getting metric data from the server. And then we'll convert on the fly to the preferred units when we update the UI. After you make these changes, I'll show you what it looks like on the device. If you go to settings, you'll see the temperature units preference. If you tap on that, you see a dialog with two options. If you switch to imperial and then you go back to the forecast list, then you see that all the temperatures now are in Fahrenheit. Once it works, answer this question. Which subclass of preference did you use? The solution to this question is ListPreference. When the setting is tapped, it presents a list of choices as a dialogue. When the user selects an option, it's saved into Shared Preferences. Here are the steps to do this. Within the pref_general.xml file, we add a list preference. We give it a title, and this maps to the string temperature units. We also need to give it a key for the shared preferences, and so we specify that to be units. If there is no value in shared preferences, then it falls back to a default value of metric. The preference also wants to know the list of all possible values here. The two possible values are metric or imperial, so we pass those in as an array, into entry values. Now, these are just constants for use within the logic of our app. These are not the user visible strings. So we need to create entries which is an array of user visible strings that maps to each one of these possible values. To have the temperature unit preference show up in the settings activity, we modify the on create method. We add this line of code for the temperature units setting. When the user makes a selection in the dialog, we set the preference summary to be the new value of either metric or imperial. Here, when we receive a high and low temperature, we read from shared preferences to know whether the temperature should be converted to imperial units or left as metric. Then we return the formatted string for display in the UI. That completes the code for saving the temperature unit setting. I'll show you how we can add breakpoints in our code. Go ahead and click on the screen bug icon to attach the debugger. We'll go to the Settings menu. In the SettingsActivity, I'm going to add two breakpoints in the onPreferenceChange method. I'm going to add a breakpoint at line 59 in the case of a ListPreference when it's about to set the summary. I'm also going to add a breakpoint at line 63 when it's not a ListPreference and it sets the summary. Let's go into the app to try it out. Tap on the Location and change the postal code. If you hit OK then it triggers the breakpoint to stop right here. These are the values of the variables at this time, and we see the new postal code here. You can step over or into the method for more details, or you can hit Play to continue, or Stop to stop the debugger. Let's hit Play to continue. And then we see that the UI has been updated so that the preference summary is the new postal code. Let's try it for Temperature Units. We tap here, and then select Imperial. It triggers this breakpoint in the ListPreference case. We hit Play to continue, and then we see that Imperial is now the preference summary. Hey, Dan, we finished the settings. Do you want to check it out? Oh, great. Wait, what's with all this stuff right here? I'm glad you asked. All this stuff will help me demonstrate the power of implicit intents, leveraging other apps to get functionality for your app for free. For example, why would you write a bar code scanning app when you can just launch an intent to do it for you. (crunching glass) Or a camera app, when you can just launch an intent to fire a photo. (glass shatters) And of course, it would make no sense to write a phone app just to dial a phone number. - You would just call the intent. - Wait, I need that. In other words, don't reinvent the wheel. Lazy programmers make fewer mistakes. Now, let's go implement an implicit intent. Raydo? Dan's being implicit again. Add a menu option to view the user's preferred location on a map. It will be handled by any maps app that's available on your device. If there is no map app on your device, handle this case gracefully to avoid a crash. You might want to recall that we use SharedPreferences to store the preferred location. Done already. Let's go to the solution. In the menu layout file for the main activity, called main.xml, we add another menu item that will always be in the overflow menu. We also define the string in the strings.xml file. The menu will be inflated in the main activity class, so we can handle the map menu item being inflated. by calling helper method called open preferred location in map. The helper method reads the users preferred location from shared preferences. Then we create a view intent, indicating its location in the data URI. The format of the data URI was from the documentation page on common intents, where you can append a postal code as a query parameter. Finally, we start an activity with this intent. (typing) Note that we only start the activity if the activity resolves successfully. So, how did the system know that the Maps app could handle this intent? The activity within the Maps app included an intent filter, like this one, within its manifest entry. It indicates that the Maps app is capable of performing this view action on all data which has a geo scheme. You can use intent filters for your activities to define the actions they're capable of performing, and optionally, the kind of data that they can perform it on. So when you use an implicit intent to address or request to start an activity, much like you did with Catherine and the openweathermap.org link, Android resolves this request by checking the intent filters of every activity that's installed on the device until it finds the best possible match. If multiple activities match, as in the case with the web URL, the user is given a choice. One of the most used implicit intents in Android is the share intent. (laughs) It's awesome. It's a great way to waste time for both you and your friends. (cell phone rings) - (chuckles) - (director) Dan! You can leverage your favorite apps to share photos, texts, videos and general links. And the best part is you don't have to even know what the user's favorite apps are. Just tell Android what data you want to share and it shows your users a list of apps that will share it, apps that may not have existed when you app was written. To make it even easier to share, Android 4.0 added the share action provider and we have it for previous releases of Android as part of a support library. It operates using the action send intent. If we use Raytoe's glorious envelope metaphor, it would be addressed to anyone who could perform action send. The data descend would be included with it as extras, either as text, or URI to the binary data. And the MIME type would indicate what the URI points to. Here's what the share action provider will bring to our app: the glorious wire frame. There will be an additional icon in the action bar, which will drop down a menu when clicked to reveal potential share actions. Another icon will be added to the right of this one that contains the last application shared to. Add a ShareActionProvider to the fragment within DetailActivity. It will share weather in the following format. Yes, it's just the string we passed into the view, plus #SunshineApp. Here's our coding solution for the share action provider. Lets start by adding a string. The string will be used for the label for our action. Now we're going to add a new menu resource. This resource will be for the detail fragment. We'll start by adding the name space used by the Android support library for its widget XML. Finally, we add the actual item. This menu item contains the string that we just added from the strings file. It's always shown as an action, so it appears on the action bar. And its actionProviderClass is the ShareActionProvider from the Android support library. The Android support library allows the ShareActionProvider to be used on earlier versions of Android, then 4.0, when it was officially added to the framework. Next, let's go to the DetailActivity. We're going to be looking at the DetailFragment within the DetailActivity. So the first thing we can do in our fragment is to add a few useful things. Let's add a log tag, a string for the share hashtag, #SunshineApp, and we're going to take the forecast string and make it a member variable. Next, in onCreate view, let's actually populate our member variable. And then finally, use it to set the text. Lets create a share intent. This intent uses ACTION_SEND. This FLAG_ACTIVITY_CLEARED_ WHEN_TASK_RESET is somewhat important. It prevents the activity we're sharing to from being placed onto the activity stack. What will happen, if we don't have this flag, is when you click on the icon to return to the application later, you may actually end up in another application, the one that's actually handling the share intent. When FLAG_ACTIVITY_CLEAR_WHEN_TASK RESET is used, it'll actually return you to your application instead. We've set the type, test/plain, to let Android know we're going to be sharing plain text. And then we share our forecast string, plus our hashtag. Only one more thing left to do. We have to add the menu to the fragment. To do this, we have to set a flag that this fragment has an options menu at all. Otherwise, it won't actually call the onCreate options menu member function. Finally, here's our onCreate options member function. As you can see, we're inflating the detailfragment menu that we created earlier. Finding the share item, getting the ShareActionProvider, and attaching our intent to this ShareActionProvider. You'll want to update this whenever the data you want to share changes. And that's it. You've now added a ShareActionProvider into Sunshine. We've talked about using intents within Sunshine to start activities and send data between apps. But what if you want to broadcast a message to many apps? For example, the system will broadcast a message, saying that the device is charging or that it's just finished rebooting. To do that ourselves, we use the SendBroadcast method to broadcast an intent. And those broadcasts are recieved by broadcast receivers, typically referred to as, simply, receivers. Using intent filters, like the ones we saw earlier, they indicate which broadcast they're interested in. So if we return to our envelope metaphor from earlier, in the case of a broadcast intent, your envelope is basically addressed to any broadcast receiver that's interested in knowing that this event has happened. And it does that using intent filter. So intents, which are broadcast, are transmitted to every app with a broadcast receiver that has an intent filter telling the system your ideas are intriguing to me and I wish to subscribe to your newsletter. As you can see, the receiver itself is pretty simple. Extend the broadcast receiver class and override the onreceive handle as you can see here. Receivers are lightweight components meant to listen for broadcasts, react, and complete within five seconds that usually means simply starting a service or sending a notification. To have your receiver start listening for broadcasts, you need to register it either through an entry in your manifest like this or dynamically within another application component, usually an activity like this. Then you define the intent filter that specifies the broadcast event you want to receive. You can do that either here in the manifest, or if you're registering your receiver with an application component such as an activity, you can create your new intent filter like this. The biggest difference between manifest and dynamic receivers is when they're triggered. A programmatically-registered receiver will only receive broadcasts while the app is running, while a manifest declared reciever will start your app specifically to receive your broadcasts. For example, I usually code with my noise cancelling headphones on, so a music app app like this might want to register a runtime reciever to listen to the system intent broadcast that announces when headphones are unplugged. That will allow it to automatically pause playback when your audio routing switches from headphone to speakers. In this case, we can use a runtime receiver because the app is guaranteed to be running if music is playing. On the other hand, if I'm using Google Cloud Messaging to listen for new data from my server, I want to register a manifest receiver that always listens for incoming tickles from my server and will wake up my app if it's being terminated to trigger the update code, usually a sync adapter, which is something we will discuss later in lesson six. There's a bunch of system broadcasts you can monitor to help your app react to changes in the system. You can see the system broadcast actions within the intent documentation at developer.android.com. One great use for broadcast receivers is to monitor for changes to internet connectivity or charging status. Imagine your app has to upload a movie or calculate the next 10,000 moves in a game of chess. How might you use a receiver to wait until the device is plugged in before starting that process? Should it be a manifest receiver or a broadcast receiver? You could register a listener for the action power connected event and you should do that within your manifest. That way, it can be called to start your app once the device is getting charged, even if it's been terminated since the last time you were using it. You can use a similar approach to delay trying to send data until the device has internet connectivity. Would it change behavior of the user experience when you're connected to a car or desk dock? In this lesson we added new activities to our apps and explored ways to structure and navigate between them. And that meant learning all about intents and how they're used in Android. Next up in Lesson 4, we're gonna learn about the activity life cycle and make our apps that much more useful by saving data. We'll began to databases and learn about content providers, but first let's take another journey into the history of Android. 50. That's how many apps were available in Android Market as Google Play was known when it first launched alongside the first Android device in 2008. A few days later, Android Market opened for all app developers to register and start publishing their apps without any review or validation requirements from Google, OEMs, or carriers. For us as developers, the ability to distribute apps and the possibility of monetizing them through up front payments, in app billing, and advertising, directly to the owners over a billion android devices, is one of the most exciting opportunities made possible by the Android ecosystem. Growing up in the dark days before smartphones and the Internet, If I wanted a new game or app, I had to go to a physical store and pay for a cardboard box filled with floppy disks or CDROMs. As developers, a big part of our business plan back then was how to get those boxes of our software onto those shelves. Or in the world of mobile, how to secure a carrier or OEM deal to get our apps preloaded onto devices. Today I can install over a million apps or games created by tens, if not hundreds of thousands of developers via Google Play, all with a click of a button. That's translated into tens of billions of app installs, an incredible opportunity to distribute apps to Android users in hundreds of countries. Now in the early days of Android, being fast and launching first was a pretty solid strategy for success, but as those first 50 apps quickly grew to hundreds, thousands, and now over a million apps, it takes a lot more than speed to stand out from the crowd. These days, the tables stakes are a base line of quality, and willingness to create great experiences for all your users. Of course, app quality can be somewhat subjective, but over the years we've identified the core criteria that users identify with apps of high quality. And to make your life easier, they're all available on the Android developer site for you to review. This is the same checklist that the merchandising team for Google Play used to ensure only apps of quality are featured in their promotions and editor's choice categories. And they include everything, from following the app design guidelines to supporting different screen orientations, tablets, and other devices. And, of course, ensuring that your app is stable and performant. So, with over a million apps already available in Google Play it's no longer just a numbers game. We don't need just more apps or games, or even more developers. What we want is high quality apps from great developers, like you. Finally, Sunshine has multiple activities and we can move between them using InTense. We also know how to use Implicit InTense to integrate activities from other apps. In this lesson, we'll dive into just how the Android framework deals with your activities, in particular, how the activity life cycle maybe different from what you're used to from other platforms and environments. Don't worry, there's plenty of code for you to write. Yes. Plenty of code. Lots and lots, and lots of code. We'll move Sunshine along, implementing an underlying database and wrapping that in a content provider. Everything you need to know to use persistent storage. The goal is to ensure your app provides a seamless, efficient experience for your users, even when networks may be slow or unavailable Okay. So before Dan gets carried away with databases, let's look at what happens when you use an intent to transition between activities. Within Sunshine, if you tap on a list in the main activity it opens up the detail activity. But the main activity remains on the backstack, ready to reappear as soon as you hit Back. Now, in that example, both activities are within the same app. But as we learned in lesson three, you can also watch the browser or Maps app from Sunshine. Or for that matter, the user can hit Home. And launch apps from there, or they can use the Recent key or switch to another app using Notifications. All of these options mean you can end up with a lot of apps on your backstack. Now, keep in mind that our resources on devices are extremely limited. So it's not a good idea to have dozens of apps sitting idle in the background. Android solves this for us, so you don't have to use those awful task killer apps. So, how does it do that? Well, it kills low priority applications that you haven't used in a while. We'll go into detail on exactly how it figures out which app needs to die in lesson six. But for now, it's important to realize that your app isn't in control of its own destiny. It can be killed at any time. So you need to know how to deal with that. And that means understanding the lifecycle of an activity and the signals we get from the framework to indicate its progress through the lifetime. A platform which terminates apps on its own is a pretty radical departure for anyone like me who cut their teeth on desktop Winforms development. If you come from a similar background you probably have a pretty good idea of what to expect in terms of lifecycle event handles. You start with the onCreate call back where you build and wire up your UI. Once that's done, your activity has been created. It likely won't be a surprise to you that there are also event handlers for when the activity becomes visible. Which is onStart and another for when it gets focus and becomes the active foreground app, which is onResume. That same sequence, then happens in reverse. [SOUND] onPause indicates that the activity has lost focus, followed by onStop when the app is no longer visible. Finally, there's an onDestroy method, indicating the end of the app lifecycle. When your app is first launched, you'll quickly move through these states. Create, Start, Resume, one after the other [BLANK_AUDIO] But within the full application lifetime, from when onCreate is first called and till the app is finally terminated. It will move through the active lifetime and the physical lifetime, many times. Let's look at those in a little more detail. The active life cycle is when your activity is in the foreground and has focus. Here it is actively receiving input from user events and no other activities are obscuring it. On [UNKNOWN] and the active lifetime ends as soon as your activity is partially obscured, like in this example. [SOUND] You can see here the permissions dialogue is displayed in front of Google Play for an app in store. Or the same thing happens when you have another activity trying to fulfill an implicit intent and the user needs to make a selection. So to make efficient use of limited resources, you'll want to use these signals to adjust your app's resource burden. So, most updates through a UI, can be paused when this lifetime ends, which is announced by onPause. But as you see, the app is still visible, so you shouldn't pause any processes that are drawing your UI. The visible lifetime on the other hand continues whenever the app is at all visible and ends as soon as it's completely obscured by another app. Like this. [SOUND] At this point, our app is moved to the background. So when you see on stop, you know the user can't see your app at all. So, while OnCreate and OnDestroy will be called at most once, each time your app is run, these handlers are likely to be called many times, while the app is running. Now, this is where things get a little different. On almost al platforms, app life cycles are deterministic. Generally, you'll start a program and it'll keep running, until it either completes or the user cancels it. You look at traditional desktop development that means your app keeps running until your user chooses quit or exit from the file menu. At that point you can say stay and free resources. But as we know on Android life cycles work a little differently. So, let's take a closer look at exactly how that works now. So now go ahead an add logging statement to the onpause, onresume, onstop, onstart and oncreate and ondestroy life cycle handlers for the main activity. Start the app and try rotating your phone. Now observe the logs. Whats the sequence of these lifecycle events that your activity goes through, simply by changing its orientation. Starting with tear down, the app will first be paused, stopped, destroyed and then recreated, restarted and resumed. Let's see if we can figure out what happens when an app is terminated in the background. Start the app again then hit the Home key. Now launch some other apps before returning to ours. Try and pick apps with large memory footprints. Can you figure out, which of the following lifecycle event handlers is the last one guaranteed to be called, before your app maybe terminated by the runtime? Since Honeycomb, Android apps can rely on, on stop being called, before the app is at risk of being terminated. But if you're supporting pre-Honeycomb devices, you should prepare for termination, as early as after on paused. [BLANK_AUDIO] Let's take a closer look at how you should prepare for an untimely app death. As you are moving around between apps, you probably notice that from a user perspective, Android doesn't announce changes in app state. It doesn't announce, that it's low in memory or ask users to close apps to free up resources. In fact, it does everything it can to make the resource limitation to the device, invisible to the user. That means keeping the foreground app running smoothly, and switching between apps seamless, and that means killing apps in the background. And it does that if it needs their resources to make sure that the foreground apps can continue to run. So we know that as soon as your app is visible, its lifetime is as perilous as that of a Stark at the Red Wedding: likely to die without notice, but ready to return from the dead. That tells us some very important things about how our app should behave to be good citizens and provide a great user experience. >From a system perspective, onPause and onStop are signals that our app may be killed eminently. So we need to clean up any resources that need an orderly tear down such as closing any open connections or sockets. It's also a signal to app that the system now considers it alert priority. Given the limited resources available, we should respond by reducing our use of system resources. Particularly, anything that could continue draining the battery. That includes anything that's being used exclusively to update the UI. So, what are some examples of listeners or updates that should be paused or disconnected when onpause or onstop are received? Put your answer in the text box below. Some good examples of answers include, Sensor Listeners, Location Updates, Dynamic Broadcast Receivers or Games Physics Engines. Any task that your application needs to keep happening, even when your activity is paused, shouldn't really happen within an activity at all. We'll have a look at some solutions to that problem in Lesson 6. Keep in mind that when you're activity is paused, it's still visible. It's just obscured by something else, usually a dialog box. But it's not stopped. So, don't stop drawing your UI when you receive onPause. For the purposes of the Sunshine app, this information is purely theoretical. In fact, you'll really only need to consider this later, when you're adding things like Sensor or LocationListeners. Until then, the default components will handle much of this behavior for you. In any case, now that you understand the lifecycle and the way the system handles exiting your app, when it needs its resources, you should hopefully understand why Exit or Quit buttons in Android apps serve no practical purpose. At most, you can call "Finish" on an activity and it will get torn down instantly. That's actually exactly what happens when the user simply hits "Back" from within their activity. If you're still not convinced, check out the video in the Instructor Notes where I explain my reasoning with a little more, color. As app developers, it's our job to maintain the illusion that once started, every app is waiting patiently in the background looking for its chance to be the star when called on. So whenever the user switches back to your app, whether or not the system is killed during in the interim, they should be presented with the same UI they had when they left. To help, Android has a pair of handlers specifically for persisting state in these circumstances. OnSaveInstanceState is called immediately before onPause. So, as soon as your app is no longer active, an onRestoreInstanceState is called immediately after onCreate, but only if the app is being restarted after having been terminated by the system. That means you can read the bundle of state information saved the last time your app was moved to the foreground here. The next time, you'll use the switches to your app even if it was killed by the system in the mean time. Using that bundle, you can return your UI to the same state it was the last time the user saw it, creating a seamless transition that hides the resource management happening under the covers. That's enough of the "why," let's go back to Dan and see how to put this theory into practice. A key takeaway from life cycles is that your application runs until Android needs to free resources or something else. That means, it's best if we design Sunshine to continue to work well even if the operating system has to close us and the app no longer has weather data. One might ask, this is the error of the connected cloud. Why don't we just always fetch the weather on demand? Do we really need to worry about saving anything on the device? Well, first, user experience is important. When Sunshine is launched, we want our users to be immediately greeted with up to date hot off the API weather information and not a blank screen. The faster people can use an app, the more it will be used. For something like weather, people want the details immediately available. Second, using any radio is detrimental to the battery life of the device, especially the cellular radio. Storing the weather data rather than fetching it each time saves battery life. And that leads to happier users. Third, there are many users on metered data plans or users may be roaming when they want to use Sunshine. All those unnecessary data fetches can add up. Fourth, if you're running a web service for your application, you'll be highly motivated to reduce the server load and network bandwidth. Fifth, there are still lots of places that don't have a network connection available constantly. One of the prime advantages of having a mobile app is being resistant to bad or non-existent network conditions. Sixth, and finally, you never know where a user will want to use your app. Although our weather API currently doesn't support outer space locations. Being smart about the way we use system resources is key to making the Sunshine a good Android citizen. As conscientious developers, we strive to make all of our apps adhere to these principles by minimizing network activity and working seamlessly between offline and online states. We persist data in Sunshine to make it both a better experience for users, while making it use less network and battery resources. As you might expect, Android stores your persistent data in the file system. To simplify what app developers need to write, Android provides several structured storage options on top of the file system. For Sunshine, we'll leverage both Shared Preferences and an SQLite Database. Let's look at both of these options. The Shared Preferences class, which we are already using to store our user zip code in units, provides a general framework that allows you to save and retrieve persistent key value pairs of primitive data types, such as Booleans, floats, ins, longs and strings. There are times when a simple key value pair framework like Shared Preferences doesn’t provide enough flexibility. Fortunately, Android also has SQLite. SQLite implements a light weight relational database. We interact with SQLite databases by writing queries and statements and SQLite's variant of the structured query language or SQL. Storing something in a a database is more complicated than using Shared Preferences. So why would we ever choose this option? After all, Android supports both raw files and shared preferences as alternatives. Well, for the same reason that it's inefficient to find things if you throw your clothes in a pile on the floor. Storing things in an SQLite Database helps you organize and find data easily. Thanks to the power of indexing and tables. Let's see what this looks like. Here is an SQLite Database table from our weather database. Note not all fields are represented. All of the data for the first day is in the first row. The data for the second day is in the second row and so on. With key valued pairs, it would be difficult to associate a row of data this way. As you continue through this section on database storage and Android. We're going to expect some basic understanding of SQLite and relational databases, including what a create, select, update, delete and insert operation is. We'll help you write these operations. But if you are new to SQLite or need a refresher, head over to the tutorial linked in the instructor notes below. Once we have a database up and running on our device for our app. Getting the information we need using SQL is easy. We can perform queries against this database, such as this SELECT statement here, which returns the weather on the specified date. Similar to what we would want to do for the detail view. We can use this slightly more complex query to return a range of dates, which is similar to what we'd do on the main forecast list view. Once again, if any of this was unfamiliar, please consider working through the SQLite tutorial link in the instructor notes. And even if isn't unfamiliar, you might just learn something. Okay. Here's a slightly more complicated SQL query. See the instructor notes for some resources that you can use to help parse the SQL statement. One note, max is the name of the column that stores the high temperature for the day. It will actually return a single row containing the max high temperature. We're using a descending order for the column, which will place the largest value at the beginning of the query. The limit statement tells SQLite to only return a single row. We return a row that has the largest value. If we wanted to get the most recent high, we could order by max desc, date desc. Using SQLite makes it easy to delete, update, and insert rows, using highly expressive queries. One can even add new columns as you revision your database, while retaining existing user data. It's not a surprise that just about every popular app makes some use of SQLite in Android. It's a very powerful and important component of the Android solution. Android also provides a huge set of helper functions to make working with databases easy, including functions to automate query building, display list views, and even utilize pre-compiled statements. For more information about databases in Android, see the instructor notes. Well that's what you need to know to get started with data storage on Android. All of this is documented if you search for data storage on developer.android.com. We'll be working with these storage APIs to build our sunshine database. Here's an overview of the changes we're going to be making to Sunshine. We'll continue to refer to this map as we move these coding exercises. There are lots of terms in this map that we haven't discussed before such as database contract, content provider, and DB Helper. Each one of these blocks represents a section of our modular data storage solution. We start by defining our data storage in terms of a contract. We then implement the database using SQLite. And finally, we layer a fundamental Android class between our UI and the data storage called a content provider. Ultimately, building our data storage in this way allows Sunshine to leverage powerful Android frameworks. We'll explain all of this in more detail as we implement each section. Let's get started. We will begin building our database for Sunshine by defining our weather contract. You might ask, what is a contract? A contract is an agreement between the data model, storage, and views, presentation, describing how information is accessed. The agreement in a contract is implemented in a contract class that contains a list of constants, typically database table column names, that are used to associate data from the data source within the UI of an application. So, if this represents the user interface, then the bottom table represents the data source that is being used to feed data to the UI. Each column in the data source represents a UI element. If we search developer.android.com for the word, contract, we see that there are many such contracts to find. In the Contacts Contract, for example, we can see that part of the contract contains a list of column names. And we can have some sense of what the contact database looks like. It has a column for the display name, flags for the contact, columns for ID's that are used to link the contact to data in other tables. And columns for URI's that point to images associated with the contact. In Sunshine, our contract is used to both create and interact with our database tables. Which is why we need to define it at the start of building our database. Of course, to create our contract, we first need to know what we need to store in the database. This is a good time to revisit our final detail wireframe. If we're going to store our weather forecast information in a database table, which columns should our contract have? In our database, we will have a table of weather forecast entries. We use a row to represent each forecast day. And we'll store each piece of data associated with the forecast in a separate column. Taking a look at our weather UX, which columns would we need for the weather database table? Think of which columns should be in each database record. All right, let's see how we did. If you checked record ID, weather condition ID, minimum temperature, wind speed, humidity, maximum temperature, date, weather direction and pressure, you've got this right. Now technically, one could have included either date or time, as time includes date. Month doesn't really make any sense here. But since we're really displaying the date, it makes sense for the database to actually replicate what's on the display as much as possible. Units should be stored in a separate table with preferences. There's no reason to store things we aren't displaying, such as, you know, rainfall or average temperature. And besides, we cannot get these from the OpenWeatherMap API. We do need weather condition ID, since we use this to both display the forecast, and determine the image to display. And finally, while it's not displayed in our UI, we need an ID column to uniquely identify each row. As discussed, it's required for all SQLI database tables that are going to be displayed in Android list views. We're not storing a key piece of data in our weather table, the location at which the weather is going to occur. This is because we are going to use a separate table for weather locations. Using a separate table has several advantages. In addition to being more efficient because we do not duplicate our location data with each record, it also allows us to update information about our location without having to update every weather forecast record. To implement this, we're going to create a relation between our weather and location tables by adding a column to the weather table that refers to an ID in the location table. This column is created with a constraint that identifies it as a foreign key, which is a unique ID from another table. What does this look like? Our list of columns in the weather table has a location ID, which points to IDs in the location table. We can use this location ID to perform an operation known as an inner join. Inner joins combine the data queried from two rows in different tables into one row in the results. When we create our tables in this way we can get any combination of columns from both tables. In this case we're getting the location query from the location table, and the date, description, and min and max temperature from the weather table Read through the documentation provided in the instructor notes on foreign keys and joins. Describe what the foreign key constraint does for sunshine. What does this mean in terms of testing our weather table? The foreign key constraint keeps the link between the tables by preventing invalid data from being inserted into the foreign key column, because the value has to be one of the values contained in the table the constraint points to. Well, what does this mean for testing? It means that we cannot test the weather table without having the location table, because the foreign key constraint enforces that the location ID is a valid ID in the location table. It also means that we have to use the result of an insert in the location table in order to insert in the weather table. In other words, the weather table cannot be unit tested independently from the location table. We are going to be writing a database test for sunshine, which will have to work with a constraint. Remember, that a contract is an agreement between our data model and our views describing how information is stored. It contains constant strings to represent all the fields that our user interface will display, and in the case of Sunshine, that our database will store. We've just covered all the columns that we'll need to use in our 2SQLI databases that will store weather and information. Now let's learn how these column names constraints are declared in our weather contract. Let's take a quick look at the weather contract class file that we've given you. The contract class has two inner classes, WeatherEntry and LocationEntry. Each of these inner classes contains constant strings that define tables. Right now, we only have column constants for WeatherEntry, the table that contains weather forecast information. The first constant is the TABLE_NAME which, for the WeatherEntry, is simply the word "weather". The constant values as defined in the WeatherEntry class match the values we're storing in the weather table. For example, we've got minimum temperature, which is defined here as COLUMN_MIN_TEMP. Pressure column is defined as COLUMN_PRESSURE. But we're missing a column to define the unique ID. This is because we're implementing the class, BaseColumns, which contains a constant called _id. By adding an _id column to our table as a primary key, we can utilize various Android helper classes that rely on the _id column being created. The LOC_KEY column is the foreign key we talked about earlier, that points to records in the location table. Since the column names don't actually contain data types, it's usual to annotate these types in the variable names, and or comments to make our contract more explicit Now, that you've seen the WeatherEntry class for the weather table, it's your turn. Add the constants for the location table in the LocationEntry inner contract class. These constants included the table name, and the name of each column. As we've shown in a few previous diagrams, the columns need to store the location setting, latitude, longitude, and the city name. After you finish coding the location entry class, make sure to look at the solution video. You'll want to use the same constant names that we use, since the code in the other classes you received relies on these constant names being the same. Once you've finished, you will have defined all of the columns for both of the tables. Next, we'll be ready to use these column names to actually create the tables in the database. Here's our solution. You are given the unique table name. The rest of this inner class lists the columns we're going to use to store our data. Once again, you'll want to use the same constant names that I used in this solution, since the code in the other classes you've received, such as the weather DBHelper, uses these same constant names. Now that's a contract. At this point, we define the names of the columns we want, but we still don't have a database. To actually make a database, we're gong to extend Android's SQLiteOpenHelper. SQLiteOpenHelper contains cool stuff to create the database and help us handle database versioning. As we make changes to our database in the future, tt will help us modify our tables. For many apps, being able to upgrade to a new version without data loss is critical. For Sunshine, we just want to make sure that upgrades in that involve schema changes happen smoothly. Let's take a look at SQLiteOpenHelper more closely in action. We're going to be working in the WeatherDBHelper class that you've been given which extends SQLiteOpenHelper. It contains code to create and initialize the weather database. Let's examine it. At the beginning of the DbHelper, you can see that we've defined constants for DATABASE_VERSION and DATABASE_NAME. The DATABASE_VERSION typically starts at version 1 and must be manually incremented each time we release an updated APK with a new database schema. The DATABASE_NAME is the name of the actual database file in the file system, which will be weather.db in our case. Note that we're using version 2 since this revision of the course uses an updated database version. These values get passed into the constructor to initialize the database helper. Next we have the onCreate method. This is where the SQL we've been talking about and our new contract class are used together. The first time the database is used, SQLiteOpenHelper's onCreate will be called. We need to write the correct SQL statement string so that we can create the table sunshine needs. We then have the system execute this SQL by calling db dot execSQL. Note how we're using all of the weather entry constants to write our sequel statements. Also note that we use lots of not null constraints on this table. These constraints help prevent us from inserting records without columns being filled out into the database, and that helps to prevent bugs. Here is the implementation of the FOREIGN KEY constraint from the not yet created location entry table. This means that we cannot insert a weather entry into the database until a location entry for the weather location has been inserted. And we cannot delete locations while there exist weather entries that point to them. That being said, it's going to be a while before we have UI that can demonstrate that our database code is working. Fortunately, there's a way we can have Android run any code we want, even if there's no UI yet ready. Android has a built in testing framework that allows us to create a test APK that executes a JUnit test that call into classes in our main APK. If you aren't already familiar with JUnit, it is a testing framework that allows you to write automated test suites. You can run your automated tests easily. You can find your tests in this section of the Android Studio project. Just right-click on the test package and select Run. Once the test pass or fail, you'll see the output down here at the bottom of the screen. I'm not going to display the emulator on our screen because it won't actually show that we're doing anything. The tests we're running don't have any user interface. But you can see here in the test runner, we're instantiating tests. An empty window and a green result means the test succeeded. Let's look at the TestPractice class. You can see it sits in the data package of our test project and extends AndroidTestCase. When you extend AndroidTestaCase, you can implement the setUp method which will be run before each test. You can also implement tearDown which we run after each test. Similar to JUnit test, you simply add new methods in the class with the prefix test such as testThatDemonstratesAssertions. And those will automatically be run by the test processor. Some other things to note. The FullTestSuite class contains code to include all of the Java test classes in its package into a suite of tests the JUnit will run. This allows us to easily add additional tests, by just adding additional Java class files to our test directory. You'll likely have a class like this in each test project you make. They aren't typically project specific. So you can literally just copy this file. Each test should have at least one check which uses an assert to see if the program applies the correct output. An assert is just that, it's a declaration that the outcome after part of a test is run matches our expectations. If the assert does not match, the test will fail. Let's look at our testThatDemonstratesAssertions in TestPractice.java. AssertEquals asserts that the expected value equals the actual value. If they are not equal than an assertion failed error is thrown with the given string message. Other useful methods include assertEquals, assertFalse, assertNull, or we can just call fail if a certain code path should never have been reached. Feel free to write your own test cases to play with assertions. Let's see what happens when we make a test fail. As you can see our results are now red, and we can see exactly where in the test are application failed. Let's uncomment out the testCreateDb function inside of the TestDb class. You might have to import a few classes to get this to compile. Let's also uncomment out the createNorthPoleLocationValues and the insertNorthPoleLocationValues functions from within TestUtilities. This is the last chance to fix up your location contract if things don't compile. So let's run our new test with our TestDb. As you can see, we get a pretty good error message back, that our database was created without both the location entry and weather entry tables. Don't worry. We can fix it. Modify onCreate to create the LocationEntry database table using the constants we defined in the contract. The good news is that this is a similar but simpler statement than what we have in WeatherEntry. You'll be creating and executing a string that stores an SQLI command. You want to make sure to use the correct data types for each column. Also, make sure that you have the right constraints. In general, for all the model of the weather table. With the exception of the ID, all columns must be defined as not null. The location query should additionally be defined as unique or coordinates are real, or floating point values. You should consider adding logging statements to print the SQLI statement, and verify that it looks as you intended. Pay close attention to spaces, parenthesis, and commas. Once you have finished writing the SQL to create the table, continue to run test create TestcreateDB from within the test DB, and let it guide you as to how to fix your creation statement. Once you have finished coding, I recommend looking at our solution, just in case our test missed something. Here's the solution for the location table creation statement. As I mentioned before, we make the location setting unique. This is particularly important because the ID of the existing location is used as a foreign key in our weather table, and therefore must not change. And this constraint will prevent the same location setting from having multiple IDs. Let's continue looking at our DB helper. The other important function that we are required to fill in is the on-upgrade method. This function gets called when the database has already been created but the version is changed. A version change or upgrade should signify that the columns, tables or general structure the database has changed. The SQLite Open Helper knows the database version has changed because the version we passed into its constructure has changed. Make sure to always change the database version when you make changes to the database tables. You might think, why would I care about this? I'm not upgrading anything yet, so why bother? Because it's important to make sure that your application won't have errors when you make changes to the database tables. Since we are going to be using our database as a cache for web data, and not for use generated content, we'll drop the tables, which deletes all of the data. If the data had contained information that was user generated, of course, we'd want to preserve it. To do that, we'd likely use alter table to add new columns. See the instructor notes for more information on alter table if you are interested in how this is done. We tested that the database was created successfully. But now we should test that reading from and writing to the sunshine database works as expected. I'll show you how we insert a row of data into the database, and then query the database to read it back out. First, we get a reference to the database from our SQLI Open Helper. Which is an instance of an SQLI database object. We use this in test create DB. Since we're writing to the database, as well as reading, we're going to get a writable database. If we were only reading, then we should use a readable database. To represent the row of data, we want to insert into the database, we use a content values object. We create one of these, in the create North pole location values utility function. Content values, contain a set of key value pairs. You put a key string associated with the value, into the content value set. The key string is contain the names of columns in your database. The value can contain many different data types. Content values, are used to write databases in Android. Once we've created our content values. We call database.insert, with the table name and content values to actually create the new row of data. The return value, from our insertion is a long, that contains the new row ID from the _ID column. If there's an error inserting, the return value is negative 1. Now that we have a row ID, we can query the database for that row. There are several query methods that take in different numbers of parameters. A query method, is just a helper function to make it easier to construct and execute a select statement. Let's show how the query function constructs a statement. Here's what the base, SQLiteDatabase query function looks like. The most basic query we can make with this only has a table name. And it returns all columns and all records. The rest of the parameters, would modifying filter the output of this query. Adding a projection, in array of columns, we wish to return, changes what we are selecting in select statement below. The selection parameter filters the results. One can optionally also use the selection arguments to replace any question marks in the query. Android creates these as bound parameters, in a low level interface to SQLite, which means, we don't have to worry about things like escaping the strings to keep the query valid. We can also change the selection arguments, after our query has been made this way. The last parameter, as you would expect, affects the order by cause of our query, causing it to sort our result in descending order by date. The query functions all return a database cursor. A cursor object, is a control structure, that enables traversal over the rows and columns of our query results set. Typically, we'll start traversing results set by calling cursor.move to first, which will return false if there were no rows in the result, which means nothing matched the query parameters. We can then call move to next, iterate through each row. Once the cursor points to a valid row, one can call get column index to return the index of each database column within the results set. You can save these values and use them for every row in the result. And then you can call get or methods, that retrieve the values from that row based upon column index. Everything we've covered so far, is how we read and write from the database in our app. In tests and in our app code. For our unit test, though, we add a step to validate the values from the cursor with the ones we originally created the contentValues object with, by using assert statements. And, when we're finished we should close our cursor and database to release the system resources as soon as possible Follow these steps to create a unit test to insert a row of data into the location database table. Then, query the table and validate the values. We're going to be filling out the test location table function within TestDB. The comment in that function should guide you in completing your test. This test function returns the ID of the inserted row. When you're done, check the box to continue. Here's what the testLocationTable method looks like. First, we grab a reference to a writable database because we'll be modifying the database. Then we create content values for a row of location data using the function within test utilities. Then we insert that content values object into the location table. The return value of the insert statement should be row ID. If it's negative one, we know the insertion failed, so we assert that. Then we query the location table and pass in null for all the parameters to get a default query of all tabled rows and columns, since we want a precisely verify that our database only contains our inserted record. The query will return a cursor. And we are assert if we cannot move it to the first row. Finally, we call validate current record from the test utility to validate the query will return the correct record. Validate current record grabs the set of value pairs from the content values that we inserted. It then iterates through them, using cursor.getColumnIndex to get the index of each column in the record set by name. We need the column index to get data from the cursor. Note the projections are always return in order. So if we specify a projection, we can safely use the indexes from our projection array without having to look them up like this. Let's go back to our test. We checked to make sure the database has only one record by making sure we moved to next fails, then we close the cursor and database, we don't leak resources. Finally, we return the locationRowId. Let's run the test and see what happens. And the test past, [SOUND], only one more test to write. We've tested the location table so now we should test the weather table in a test weather table method. Follow the steps to create a test to Insert a row of data into the weather database table. Noting that we have to first insert into the location table to get the location key for the weather query. Then query the table and validate the values. Before we go ahead and build a content provider you wouldn't be out of line to ask, well why. The simplest answer is that it allows you to share your data safely and efficiently across app boundaries by abstracting the underlying data source, be it SQLite like this or files or really anything else. So that other apps can access it without really needing to understand how you stored it. In fact, the calendar, SMS, and contacts APIs work that way, using shared content providers. We're going to share our weather database later, but if you're not planning to expose your app's data, you're probably thinking you can skip this bit, right? Well, almost, in a lot of cases you could, but really shouldn't. For example, in Sunshine we're using SQ Lite. But you could be storing data in files, dynamic run-time data or even just a different database library. By using content providers, it's easier for you to potentially switch out the data source and much easier for someone other than you to manage the UI layer code without them having to understand the depths of your data storage implementation. On the UI layer, it's a generic mechanism that returns cursors. The same of those returned by SQLite databases. So, if your data layer implementation changes, then your content provider is effected. Still, it's just you writing the code right now and that's a lot of boilerplate for the sake of following a neat design pattern. Well, keep in mind that as far as the framework is concerned, all data is handled through content providers. So, if you want to interact with anything outside of your app, such as sending data to a widget or returning search results from the newer app, you'll need a content provider for that too. In fact, that's how the Google play store and Gmail widgets work. As well as the ability to get search results from Google Play. Similarly, there's a bunch of APIs designed to optimize the process of synching and querying data, and updating UI accordingly. And all of them also expect content providers. That includes sync adapters and cursor loaders. Which make your app able to efficiently sync with your server, load data in your UI layer, and which include built in content observers that will update your UI automatically when the underlying data changes. You could, of course, build all of that yourself but at a certain point the advantage you gained by not writing a content provider to begin with is lost in the process of having to recreate all of the useful clusters that utilize it. We'll take a look at publishing your content provider and using Lotus to access it efficiently later in this lesson. And we'll explore sync adapters in lesson six when we look at doing efficient background updates. But first, Dan is going to show you how to actually build a content provider. In Sunshine, we'll using content providers to help us efficiently sync data from the Internet. Combined with utilities in the Android framework. It also simplifies getting database content to and from our user interface. We implement a content provider, by extending the content provider class. In Sunshine, we'll call this class WeatherProvider. We'll use the weatherprovider to read and write the database we just created. You're probably excited to get started on building our weather provider, but if you're still unsure about what content providers are and how they work, we've built a great exercise that demonstrates how to take advantage of all this gnarlishious goodness. Why gnarlishious? Because, this exercise leverages the user dictionary provider. So, if you ever wanted to make your radicaloutius vocabulariousness understood by your mobile friendpanion while learning more about content providers, check the instructor notes below, for a link to the bonus lesson. Building a content provider, involves several steps. Determining the URIs your application will need to support. Updating the contract to include these URIs, filling out a URIMatcher that supports each of these URIs and implementing the six required content-provider functions. Okay, the task is determining URIs, but, what's a URI anyhow? A content provider allows us to think of the data associated with our views in terms of universal resource identifiers or URIs. URIs do exactly what their name implies. They identify a resource, in our case a row, or rows, in a database. You're almost certainly familiar with the concept of a URI. Since the URL used for every web address, is actually a type of URI. In the case of the web, it's a URI used to identify web content, with an HTTP or HTTPS scheme. In this example, sunshine is using a URI to query the weather for 94043 location. Our content provider returns a cursor, containing the database rows that correspond to the URI. By changing the query value of the URI, we can have Sunshine display weather from different parts of the country. Each URI can contain the content scheme. A scheme is the first part of a URI, that proceeds the colon, and it identifies the protocol that the URI will be using. You are used to seeing schemes such as HTTP and FTP in URIs. Content colon implies that the URI refers to a content provider. A content authority, which is a unique string used to locate your content provider and it should almost always be the package name of the application. A location, which typically points to a database table within the application. And optional query, this query can either be part of the URI path or it can take the form of a traditional URI query following a question mark. As it turns out, a URI is the primary piece of data, that is passed in these intents that Ray To so gloriously described. In Sunshine, we'll leverage this to start the detail view, with a URI that points to the weather, on a specific day. The detail view, uses this URI to query weather provider and get the right weather data to display. Another thing that these content provider URIs, is used for in android is to notify the user interface that a piece of the data it is displaying has changed. The code registers an Android construct called a content observer, during our initial query, against the URI that is being displayed. When running a database update routine, likely on another thread. That routine will tell Android that the data associated with the URI has changed. And ultimately, that the URI should requery the database, and refresh the display. This will cause the display to refresh, and show the latest data. Even though as you can see here, the URI hasn't changed. Content providers, can return all sorts of data. But the abstract functions return either a cursor containing a list of items or a single item. How these URIs are structured is up to each application. But Android provides support, for appending an ID to the URI path, to indicate that the application is interested in a specific record, rather than a range of records. In Sunshine, the value for a specific date and time, is appended to the query for weather at a specific location. And that causes a single weather record to be returned. So, defining URIs. To make it easy for us, I've defined these data URIs that we'll be supporting. Some of these URIs, exist because the UI has a view that needs to expose that particular data. Such as weather with location, which will be used to display the main list of forecasts. And of course, weather with location and date. Which would be used to display the detailed forecast information. Others, are used primarily for writing the database, inserts, updates and deletes. Having these base URIs, is also useful for testing. Now it's time to go back to our weather contract. When we first described what a weather contract is, we said that it is an agreement between the data models, storage and views. Presentation describing how information is accessed. It turns out, that in addition to the column names for our database, the contract is also a great place to define the URIs, that our application will be using to access its data. Next, we'll explain what you need to add to your weather contract. When you've completed adding this code to your project, I'll explain a bit about what you've done Now that you've added the URI information to the WeatherContract, step two of building our Content Provider, I've got some explaining to do. At the beginning of our WeatherContract, you can see we defined the CONTENT_AUTHORITY. Next we added strings for the BASE paths for our URIs. Note how these paths match our two tables. For each of our tables, LocationEntry and WeatherEntry, we created a CONTENT_URI that represents the base location for each table. Something else that is convenient to have in the contract are functions to help build the Content Provider queries. Now, for some URI builders and decoder functions for WeatherEntry. It's convenient to have these, as it makes fewer places in your code aware of the actual URI in coding, keeping this knowledge in the contract. Strings such as the location setting can be impended with the impend path function. You'll be implementing the build weather location function shortly. In this case adding an additional path to the URI does not change the type of the URI. See, they're both type DIR. We can also use these functions to add potentially useful query parameters. In this case, we use a query parameter for the start date. Query parameters are useful when, for when we have a fixed database query that we want to have some limited parametrization for. In this case it will be a parameter for our join between the two tables. More on that later. URI queries look just like the queries you see in web URLs, and give us the ability to add more richness and complexity to our URI contract. Finally, we have this function that builds a two part URI with both weather and date segments. Below this we have helper functions that hide the URI structure from our code. For retrieving values in the URI and place all this knowledge in one place. Looking back at our list of URIs, you can see that for each URI I called out whether the URI returned a list of items. By labeling it with dir for directory or a single item by labeling it with item. Cursors returned from a content provider have unique types based upon their content and the base path used for the query. Android uses a form similar to the internet media type or mime type to describe the type returned by the URI. Cursors that can return more than one item are prefixed by the CURSOR_DIR_BASE_TYPE string. While cursors that return only a single item are prefixed by the CURSOR_ITEM_BASE_TYPE string. We define these types here for both the location and the weather queries. Write code to build a URI to query the weather with location within the weatherEntry inner class within weatherContract. Look at the instructor notes for a link to the URI builder classes for how to do this. Uncomment out the test weatherLocation function within test weatherContract to verify your implementation. This one is pretty short. We just need to append the path segment for the location to the weather URI, using the buildUpon function from the URI class We've given you codes for the beginnings of a weather provider class within the data package that extends content provider. One of the tools that Android provides to help write a content provider is a UriMatcher, which we are going to write shortly. Filling out a UriMatcher is the third step in building our content provider. Content providers implement functionality based upon URIs passed to them. Our content provider will implement four types of URIs. Each one of these URIs will be used to execute different types of operations against the underlying SQL databases. For ease of implementation, content providers typically tie each URI type internally to an integer constant. These integer constants have already been added to the provided weather provider class. Android provides a UriMatcher class to help match incoming URIs to the content provider integer constants. This is important because we need to have a way of knowing which type of URI is passed into our content provider so we can perform the requested operation. Once we have the integer constants, we can easily use them in switch statements. UriMatcher provides for an expression syntax to match various URIs that works a bit like regular expressions. Hash symbols will match a number. And an asterisk will match any string. Here are some examples In the previous explanation of our content URIs, I showed the four types we will use in this app. Fill out the buildUriMatcher function in the WeatherProvider class we gave you. To help you, we've given you a link to the UriMatcher documentation in the instructor notes. Un-comment the UriMatcher test in test UriMatcher, and run it to see if you've done your work correctly. All right, you're done. Hopefully you started with the provided buildUriMatcher function. We begin with the new UriMatcher that contains the NO_MATCH function because we don't want the root node to match anything. This is typical behavior to make the code more easy to read. I'm making a shortcut to the WeatherContract.CONTENT_AUTHORITY. Our two base URIs are pretty simple. Since we've already defined PATH_WEATHER and PATH_LOCATION in the contract, we can just assign them to their corresponding integer constants there. For PATH_WEATHER, we're going to match a path with just one additional item. WEATHER_WITH_LOCATION we're going to match a path that just has one additional item on it. Because location can be a string, we have to match it with an asterisk. For WEATHER_WITH_LOCATION_AND_DATE we're going to match two path items. The first one of course will be our location, a string. But the second one will be our date, which will always be a number. Because of that we can match with the hash sign. The URIMatcher we just coded is central to coding our Content Provider. And will be used in the implementation of our core Content Provider methods. We've given you Tests to help you along the way as you code Weather Provider. Since several of these tests have been re-purposed from the database test you helped write. You may want to look at how the content provider calls replace the SQL database calls in tasks such as test location table and test weather table. But before we can start implementing step four in testing our content provider, we need to register it to the AndroidManifest, so that Android knows about it. Once the weather provider has been registered with the package manager, we can use an Android utility class called the ContentResolver to refer to it. The ContentResolver locates our class using the Content Authority and makes direct calls to the weather provider on our behalf. Add a provider tag into the androidmanifest.xml file to register the WeatherProvider class with the Content Authority as defined in the WeatherContract. Note that the two fields you need to populate in the provider tag are android:name and android:authority. Uncomment the testProviderRegistry test within TestProvider, to test to see if you've done this correctly. Alright, you're done. Let's take a look at the solution. Hopefully, you added a provider tag to the Androidmanifest.xml file to register the weather provider class with the content authority. The authorities attribute needs to match the content authority from the weather contract, while the name attribute needs to match the class name of your weather provider. Note that you don't have to specify the full package name. The additional package of the class is all you need, as I did here. Now that we've registered our weather provider in the Android manifest, it's time to begin coding our weather provider. This is the final and most involved step in implementing our content provider. We'll be filling out these core content provider functions. Except for onCreate, which we've already done for you, we've added an instance variable for our data base helper. We initialize this in our onCreate function. We will use this database helper in most of the content provider methods. The first of the content provider methods that we will look at is getType. Implementing the functional version of getType isn't strictly necessary for our application. But it's a nice way to review what uris we're planning to handle. We partially filled out the getType function for you. We use the urimatcher we built earlier to match the given uri against the expressions we've compiled in. For each match, we return the types that we've defined in the weather contract. Remember that the key information that this conveys, is weather the content uri will be returning a database cursor containing a single record type item, or multiple records type directory. Content providers can also be used to return other kinds of data than just database cursors. For example, if we wanted the content provider to return JPEG images for a content uri, we would have this function return the standard mime type, image/jpeg. Let's un comment the testGetType test from within TestProvider. This will get us ready for the next coding exercise. Finish up get type, adding the remaining unhandled cases in the switch statement to return mime types for the remaining URI types. Once again, use test get type within test provider to validate that our answer is correct. Remember, the stuff to add is in weather contract. The WEATHER_WITH_LOCATION_AND_DATE function can only return a single row. So we give it the ITEM_TYPE. While the WEATHER_WITH_LOCATION type returns multiple items. So it gets CONTENT_TYPE, which is a dir. For us, query will be the most complex of the required content provider methods. We've given you the bones, of the query operation. As you can see, we use our SURI nature object, once again to switch on the type of URI. Note that each response from this function, will return a cursor that corresponds to the incoming query as defined by the URI. This is the only function where we will have to fill out a different response for every type of URI in the content provider, as several of them are used in queries only. At the bottom of our function, we're going to set the notification URI for our cursor to the one that was passed into the function. This causes the cursor to register a content observer, to watch for changes that happen to that URI and any of its descendants. This allows the content provider, to easily tell the UI when the cursor changes, on operations like a database insert or update. We'll see more on this later, when we cover inserting and updating the database. Uncomment the test basic weather query function within test provider and run this code when you're finished, to make sure all of this is working well. Implement the queries for weather and location in our content provider. Note that these are both basic queries. Un comment out the test basic location query function within test provider. And, run the code to make sure all of this is working well. Alright, you're done! Let's take a look at the solution. For weather, we just get a readable database and pass all of these parameters from the content provider call. The solution for weather and location is pretty much the same. For each one, we're going to pass the parameters that come through the content provider into the query function of our readable database. Again, these are the parameters that come through the content provider, and these are the parameters that we pass into the database. Location looks approximately the same. When we first defined our tables, we defined the relationship between them in terms of constraints. I'm going to show how we implemented that relationship into our query using a JOIN. This JOIN allows us to query the Weather table for values from a specific location setting. In Sunshine's case, the user sets this in Preferences. You'll notice that there's an SQLiteQueryBuilder class variable at the top of WeatherProvider. As you might guess, this class helps construct queries and is actually used as the basis for the query functions you've already used in the SQLite database class. We initialize the SQLiteQueryBuilder in the static constructor of the class, describing the join between both tables. SetTables fills out the content in the from part of the SQL query. Note, since both tables have a field with an underscore ID, we must explicitly use the table name in order to disambiguate which ID we are talking about in the join. Then we define the selection. The selection is defined using the question mark replacement syntax. The selection parameters will replace these values. As you can see, our selection has two parameters, a location setting and a date. Then we have a function to get the weather by location setting using the same query builder. Note that we fetch the parameters from the URI and built a string array so that they can be substituted into our query. We do that for both of the queries that we're creating this way. Finally, we added the functions into the query routine of the content provider, for both WEATHER_WITH_LOCATION_AND_DATE and WEATHER_WITH_LOCATION Now that we've covered querying with our content provider, it's time to start inserting data. Let's take a look at the incomplete content provider insert function we provided in the source code. As you can see, this function takes advantage of the URI matcher code. But it only requires the base URIs. That's because inserts are fundamentally simpler. We simply want to make sure that the right record ends up in the right table. The data that is contained in the other URI, such as location and date, will actually be in the content values used in the insert. Note that if we wanted to, we could support all of the URIs here. But it makes the implementation of the insert function far more complicated. When we insert into the database. We wanted to notify every content observer that might have data modified by our insert. It turns out that cursors register themselves as notify for descendents. Which means that notifying the route URI will also notify all descendents of the URI, ones that contain additional path information. Just like with calling our content providers. We can use a content resolver to notify our content observer. As you can see, the root URI for each table in sunshine just contains the context scope, the authority, and the table name. In the case presented, the content URI that contains a date. Is a descendant of the plain weather content URI. If we notify based on anything other than the root URI. Then a cursor listening on the root URI will not get notified of a change that would certainly impact it. So we have to be very careful when doing that. Let's go back to the source code. For weather, we just passed the perimeters that came into the content provider into the data base insert call. We should throw an exception if the insert fails. The only trick here is to make sure we return the correct value. Which is a URI. Fortunately we made a function to build these URIs which contained the weather path followed by an ID. If we were being complete in our content provider implementation, we should also implement these URI types in the contract URI matcher and query function. But the beautiful thing about implementing a content provider, especially if it's only being used by your application, is it you only need to implement the features you use. So we just set the return URI by using the build weather URI function. Implement the rest of the Insert() content provider method. Handle the location URI, and use the content resolver to notify any registered contentObserver of the change. Uncomment the test insert test, to see if you've done this right. All right, you're done. Let's take a look at the solution. Adding support for the location insert looks almost identical to adding the support for weather. We just have to select the right table name, and return the right location URI. Remember, at the end of the function, we can just call notify change on the content resolver to notify all of the registered observers. Note that we must use the past in URI, and not the return URI, as that will not correctly notify our cursors of the change. Since we also uncommented test insert read provider, lets run our test just to make sure everything's still working well. Note that nothing appears on device screen. And, our test passed. We're well on our way to building our content provider. The update and delete methods look a lot like the insert method, except they update and delete. And, both return the rows modified, rather than a URI upon completion. As you complete each section, uncomment the test updater, or test delete test to check your result. Of course, make sure to notify your content observers, and, of course, close the database while you're at it Alright you're done. Let's take a look at my solution. For the delete method things are pretty straight forward. We just called db.delete with the appropriate table, and the selection, and the selection arguments. One thing that I've done is if the selection is null I set it to one. This makes delete all rows return the number of rows deleted. And that can be useful. I only notify the content resolver of a change if we actually have deleted some rows. This isn't strictly necessary. Update looks almost exactly like Delete. Once again, based upon the URI we select a different table and call the update function with the values in the selection arguments. And I only notify for a change we've actually updated some rows. Alright. Let's go to test our function. In test provider you can see we've uncommented out test delete records as well as test update location. Let's run the test to make sure everything works correctly. And as you can see everything passes. We've done everything correct for updating and deleting the content provider. Let's take the look at the implementation, of an optional method, we've got in the content provider. Anyone out there who has done work with SQLite, knows that putting a bunch of inserts into a single transaction is much faster than inserting them individually. BulkInsert allows us to do that. The default implementation, just calls insert a bunch of times. But, we can wrap it in a transaction, if we implement it ourselves. Note that we've only added support for weather forecast transactions here, since they are the only ones we insert in bulk. We start by calling db.beginTransaction. For each of the content values passed in, we insert and update the number of records inserted. When we're done, we set the transaction to be successful. And then rely on the finally statement endTransaction. Note, that if we do not set the transaction to be successful, the records will not be committed when we call endTransaction. And, that's it. We finished creating our ContentProvider. Since this has been an involved section, let's talk about what we created. We started off by defining the URI's that our ContentProvider will support. We then updated our contract to reflect these URIs. >From there, we built a URIMatcher that matches these URIs to constants we use in switch statements in all of the other required content provider functions. Then we implemented the getType function to return the type of cursor returned for each URI. We then implemented the ContentProvider query functions, followed by the write operations insert, update, and delete. Finally, we talked about the optional BulkInsert function to make updates to our database in a single transaction. This performs much faster, and causes less wear and tear on the flash chip, compared to updating the database in multiple transaction. There are lots of libraries out there in the Android open source world to help you built ContentProviders. If you want to use them, you'll be able to use them now with the confidence that you know how they work, and what they are doing. So all queries and updates to the database can now be done through the ContentProvider interface. But, we're still not using it in our code. Let's fix that. All right, let's get serious now. We need to change our code to store our weather information in the database using the content provider we just built. After all, weather is serious business. The next step just involves some refactoring, to make sure you get it right, we'll give you some instructions next. The refactoring you just completed gets our code ready to use the weather provider. For this quiz, you're going to code the addLocation method. As you can see, this method takes a locationSetting, cityName, latitude and longitude for the new location. If the location already exists, we return the ID of the existing location. If we add a location, we return the ID of the added location. We can do this by first querying the content provider, to see if the location query already exists, and only performing the insert if it doesn't yet exist. Uncomment test add location within test fetch weather task, to validate your solution. All right, you're done. Let's take a look at the solution. Just like in our content provider test, we can use get content resolver to query based upon the content URI. Remember, that the default location entry content URI just passes all of the parameters into the database. So, we can easily construct a query containing the location query to see if it is in the database yet. Remember that the default location entry content URI passes all of the parameters into the database, so we can easily construct a query containing the location setting to see if it is in the database yet. If it's not, then the query will return an empty set. And we should insert the new city name, location setting, and coordinates together. Note that we're calling that ad location method, from inside doing background. Which calls getWeatherDataFromJson. We've uncommented out the test ad location function. Now, we'll run our tests, and our tests all pass. We're ready to move on to the next step. We're still not actually inserting weather data into the ContentProvider. So, this is a good time to talk about BulkInserts. Remember, that BulkInsert allows us to insert multiple rows far more efficiently by using a database transaction. We can apply this when we need to insert 14 days worth of weather data into the table. Use the ContentProvider to BulkInsert the vector of content values into the database. Note, there are a few lines underneath the area where you add your BulkInsert code that you can use to test displaying the values you just inserted. It will read those values out of the data base, create content values for them, and pass them into the same display function we already have. All right, you're done. Let's take a look at the solution. While we cannot insert a vector directly, we can easily convert a vector to an array. Once we've done this, the bulk insert method will insert very efficiently. As you can see, we've uncommented out this next series of lines. This allows us to test our output to make sure that we've actually inserted the right thing into the database. Let's actually run our app. And as you can see, we're actually reading the data out of the database that we just inserted all correctly. Now our back end will update efficiently, but we really need to be querying things before requesting them from the internet. After all, the main point is to have a responsive application. We're still not even updating the screen until we've pulled data down from the web. We also want to avoid doing our query on the UI thread, because doing operations like queries on the UI thread cause Android to not be able to draw frames fast enough, which introduces frame rate jitter. Fortunately, Android offers a pattern for that known as Loaders. Let's talk about Loaders. Loaders are awesome. They were introduced in Honeycomb, but are available as part of the support library. So you can take advantage of them when supporting earlier platform releases. Loaders are essentially the best practice implementation for asynchronous data loading within an activity or fragment. So when you create a Loader, it creates an async task to load data on the background thread. It then syncs with the UI thread when the initial loading is complete, and can be set up to monitor the underlying data, and deliver any updates to the UI thread as well. Best still, all that work you did adding a content provider to your database pays off right now, with the cursor loader. The cursor loader is an implementation of the async task loader, specifically designed to query content providers, and return a cursor, which you can then bind directly to a UI. It will automatically update that cursor, whenever the underlying content provider changes, based on changes to the underlying database. And it will reconnect to the last returned cursor after being recreated, along with the host activity, after a configuration change. That means you won't have to requery data, just because the device was rotated. So the cursor loader handles all of your cursor management and background thread creation, UI thread synchronization, and data source monitoring. If you chose not to use content providers, you chose poorly. But still, you can take advantage of loaders, you just need to create your own loader by extending a think task loader directly. You can find out more in the instructor notes below. Loaders provide a framework to perform a synchronous loading of data. They are registered by ID with a loader manager, which allows them to live beyond the life cycle of the activity or fragment they are associated with. In addition to loading data, loaders include mechanisms to monitor the source of their data, and deliver new results when the contents change. Up till now, we've used AsyncTask to load data from the internet and Sunshine. We typically create our AsyncTask in the onCreate method of our activity. It starts a thread which begins a background task. If we rotate the device, or do something else that requires the activity to be restarted, we'll create another AsyncTask to do the background operation. We'll create extra network usage, or file system usage as both threads run in parallel. And, it'll take a longer time for the user to see the result of the load. The AsyncTask Loader implements the same functionality as Async Task, but because it's a loader, it's lifecycle is different. With an Async Task Loader, once we rotate the device, the loader manager will make sure that the old loader is connected to the Async Task Loader equivalent of on post execute. The onLoadFinished function. The loader thread keeps running in the loadInBackground function, and once it finishes the activity gets notified through onLoadFinished. CursorLoader is derived from Async Task Loader but has an additional optimization. If the cursor has already finished loading and load in background before the activity restarts, the CursorLoader recognizes this during the loader initialization. And the cursor is immediately delivered to the UI through onLoadFinished Early versions of Android didn't have the loader pattern. It was added to avoid directly querying the database from the UI code. What are the disadvantages for directly querying the database from the UI code? Early versions of Android don't have cursor loaders. Instead, the cursor adapter requeried the database on the main UI thread, when data from a content provider changed. This caused frame rate drops in many applications. The first answer is a definite yes. We noted how things like async tasks are bound to the UI. So something as little as an orientation change could cause the query to complete after the activity stops. So that's another definite yes. The cursor being tied to the activity also means that the data would generally have to be requeried when the screen rotates, so there are definitely disadvantages. We've spent a long time building a content provider. But, we are only using it just enough for us to test that we got the content provider working. When we query the database, here's how these classes are used. Our UI, first, builds a URI, using the weathercontract. The UI then uses this UI to call a method in the Content Resolver. Which ultimately forwards the request to our WeatherProvider. Our WeatherProvider uses Weather DB Helper to get an instance of SQLite Database. Creating, or updating the tables of our database is necessary. We then pass the SQL query to the SQLiteDatabase class, which sends our query off to our SQLite database. Cursor Loader takes the URI, and calls the Content Resolver on our behalf, inside of an AsyncTask. Ultimately, the cursor gets returned to the Android UI, and it will be used by a cursor adapter, to populate the list view, in Sunshine from our database cursor. Similar to the way our array adapter populated the list view from an array. For our next task, we are going to replace the array adapter, we have currently in forecast fragment, with a cursor adapter. We'll eventually connect it to our database using a cursor loader. All right we're going to show you how to create a CursorLoader in three easy steps. We start by creating an integer constant for a Loader ID. Then we implement the Loader Call backs. Finally we initialize the Loader with the LoaderManager. We start just by creating a Loader ID, which is an integer constant. A single activity can use multiple Loaders and they are differentiated by these ID's. The we have to fill in the Loader Callbacks. The Loader Callbacks are a generic interface class, with one parametrized type. When we use the Loader Callbacks with a CursorLoader, the parameterized type we use is Cursor, which makes the callbacks look like they do here. The most interesting one for us is onCreateLoader. OnCreateLoader returns a loader with parameterized type, Cursor. This is where we create and return our CursorLoader. CursorLoader has a constructor that takes all of the standard content provider query parameters, and will call the content provider on our behalf. When it is executed by the LoaderManager. Since CursorLoader derives an Async TaskLoader, it will be executed in a background thread. OnLoadFinished is called when the loader completes, and our data is ready. To use the data in our cursor adaptor, we just call SwapCursor, but this is where we would also perform any other UI updates we'd want to make when the data is ready. OnLoaderReset is typically only called when our loader is being destroyed. It means that we need to remove all references to the Loader Data. To do that we call SwapCursor on our cursor adaptor with null. Finally, we use the LoaderManager to initialize our loader. We pass in that loader ID, the loader call back we just filled out, and an optional bundle. This will do all that cool life cycle stuff we covered in the loader intro, such as, calling onCreate loader if the loader doesn't already exist. When using loaders in a fragment, we initialize our loader in the onActivityCreated method. And that's it, you've got a basic CursorLoader. We're going to have you write one for our next exercise. All right, it's your turn. Implement a CursorLoader in the forecast fragment to load the cursor used in the cursor adapter. You want to pass zero in for the flags when you create the cursor adapter as the loader will now be responsible for re-querying when data changes. Also, it's easiest to have ForcastFragment implement the Loader Callbacks. If after you're doing all of this, your app still displays the weather, you've probably done it right. Make sure to check that you are using the support library versions of all of our classes. Otherwise, you won't get Android 2.3 compatibility. I've provided the exact import statements you need to use in the instructor notes below. Alright, you're done. Let's take a look at my solution. For our first step, we created a loader ID integer constant. These just have to be unique for every loader you're using in your activity. Then we had forecast fragment implement the loader manager loader callbacks with type cursor, as required by CursorLoader. We added our three loader callback functions. For on CreateLoader we move the ContentProvider query we had for creating the cursor, and use this to initialize the CursorLoader. In odd load finish, we swap the cursor in our ForcastAdapter with our new loaded one. In onLoader reset, we want to release any resources that we might be using. And that's it. Let's run this, and make sure it's all working correctly. And, as you can see, some fabulous weather. This is actually using the loader, even though it looks exactly like the output from the last section that we completed. Whenever we query the database, we get a cursor back that contains columns. Each column has an integer index assigned to it. Up until now, we've had to call getColumnIndex for each column in order to get this index. But, there is a way to avoid doing that. We can create a projection which is just an array of the columns we want to return in our cursor. This is more efficient because we are only fetching the data from the database that we need to use and since the database always returns the columns in the order we specify, we can rely on the indices matching the order from our projection. So we can then just use these indices to get information from our cursor. One minor note. Since we are doing a join on our weather with location queries, we have to specify which ID we want explicitly in our projection by adding the table name followed by a dot before the column name, as in this example. All right. Now it's your turn. Use a projection in your implementation of the CursorLoader and ForecastAdapter to make your code a bit more efficient in its use of the content provider and database. In the ForecastAdapter, you'll be modifying the convert cursor row to UX format function. Because our code will be making use of this projection in future sessions, we've done step one and step two for you. See the instructor notes for the string array you should use for our projection and the constants for the column indices. Note that we get more data than we are using in the UI right now. All right. You're done. Let's look at my solution. First, I hope you grabbed the projection from the notes. Since we're populating a list view, we need a weather entry ID, but since we have a join, we have to specify this ID precisely with a table name followed by the dot followed by the column name syntax. We're not using all of these columns. But, having these constant defined will help us keep the code compatible with the updates we are doing in the next lessons. Of course, these indices are tied to our projection. If the forecast columns changes, we have to modify these accordingly. In onCreateLoader we then pass FORECAST_COLUMNS as the projection into our CursorLoader constructor. Finally, we can fix a convertCursorRowToUSFormat within our forecast adapter to take advantage of these declared indices. And that's it, we're done. Lets run it. And it looks exactly like the last time we run it. [LAUGH] Is pretty typical for this section. But the good news is that it's still working correctly. And, it's a little more efficient. We're going to take more advantage of this in lesson five as we make more sophisticated user interfaces. Okay, now for the big quiz. Implement the details view using a CursorLoader*. We've just implemented a CursorLoader* for forecast fragment, so if you're unsure where to start, start with the same steps we used for forecast fragment. Consider taking advantage of projections. The trickiest part of all this is making sure that your sharing function is still working when you're all done. But don't worry too much about that. The important thing is to understand how cursor loaders work. If you're at all confused about how sharing is done, just look at the solution. Great. You're done. Let me show you how I implemented this one. Inside of detail fragment, within detail activity. First, of course, we add a constant for the loader. I've also added a projection for the columns I want to get from the database. And, of course, corresponding constants. Then we have our detail fragment implement our loader callbacks for cursor loader. Of course, with parametrized type cursor. In on create loader. We create a new cursor loader for the URI that came in from the intent. In onLoadFinished, I format a string to match what was in the original forecast fragment and set it to the mForecast variable as well as the TextView. We don't have to do anything with onLoaderReset. Because there isn't any data that we were holding onto that needs to be cleaned up. But, how do we fix the share intent? I start by creating a member variable for the share action provider. I set this variable in on create options menu. Only if we have a forecast. We don't make any assumptions about the order in which our loader happens. Finally in onload finish, I set the share intent. This will update the share action provider if it already exists. Let's make sure this still works. The list as we would expect it to be and when we click on one of these. We get the detail view. We even have a share action provider. And as you can see, we can share it, and there's our forecast. Its actually quite straightforward to make your apps content provider available to third party apps. The key is to modify the export flag in the manifest entry here to true. As simple as that, any app that knows the content URI can use the content resolver to access it, the same way that you do. Now depending on the sensitivity of your data, you may want to protect it by requiring specific permissions to read or write to the database. So if you want to, you can effectively limit access only to other apps you've created, or to third party apps which know other permissions and users agree to. Then you just need to publish this contract to interact with the content provider. Specifically the URI and column names. And as simple as that, you've created a new API just for your data. This is exactly the same approach used by many of the native content providers, including the context database, media store, calendar and call log. Explore the native content providers linked to in the instructor notes below. What's the name for the static constant used to find the content URI for accessing audio stored on the internal data store? There's a number of different content providers available to access different kinds of media stored in different locations. To access audio media stored in the internal data store, you'd use the INTERNAL_CONTENT_URL provided in the MediaStore.Audio.Media class. (Dan) So, Rato, what have we learned in this lesson? (Rato) Well, I learned that I do not want to write databases and content providers. What did you learn in this lesson? (Dan) Well, JUnit tests are awesome, and building the back end framework of our apps is the most glorious of work. It's an absolutely vital part of creating a robust app with a great user experience. (Rato) I also learned that Dan cannot do an English accent. Fortunately, you can get ready to welcome back Katherine for lesson five where we'll shatter our activity into fragments, use our content providers to populate more complex UIs, and build layouts that work as well on tablets as they do on phones. (Dan) Which seems like a convenient segueway into the history and evolution of Android hardware. Of all the Android launch devices, the Nexus 1 will always hold a special place in my heart. That's not to take anything away from my first Android device, the HTC G1, that launched Android to the world with its distinctive chin and slide-out keyboard. Or the HTC Magic, first prerelease android phone I got to dog food when I joined Google. And the first, the wave of devices we gave every attendee starting at Google I/O in 2009. 2010 was the year Android went from "that's interesting" to global phenomenon. Growing from 100,000 activations a day in May, to over 300,000 by December. That was seriously helped by the release of the Motorola Droid. I can still remember the offices here in Building 44, echoing with the constant refrain of "Droid" as each device rebooted. The Droid was the first of the thinner, higher res, more powerful Android devices that have since become standard. And it was also the device whose release on Verizon here in the U.S., really kicked off the flood of Android activations. But I was a Londoner then, and the Droid was a [inaudible] only phone, so it was never really a device I truly used. Then, there was the Nexus 1, code-named Passion. The first device I felt was pure Android, was also the phone we brought with us on our 2010 Android Developer Labs World Tour. Me and my colleagues traveled across the world. Seven cities in ten days, introducing over 20,000 developers to Android by way of presentations and a free Nexus 1. As a result, I made a lot of friends across Europe, and learned exactly how many boxes of phones I can carry across snow drifts in Stockholm, and icy roads in Berlin. Since then, The Nexus S4 and 5 have each improved on what it takes to make a great Android phone. And OEMs across the world, have created thousands of different Android devices. Starting with the Motorola Xoom, which led Android's official expansion into tablets, and leading the way for the Nexus 7 and 10. But that was just the start. Those changes paved the way for the Android [inaudible] to grow into what could be, the brains behind anything from phones and tablets, to TVs, cars and wearables, like Android Wear. It's impossible to know, what comes next. Who knows? Maybe the next Android devices, will be Androids themselves. Now that we're storing the data we downloaded in a sensible fashion, we're ready to build rich UIs for each of our activities. That means learning about fragments and how we can use them to create complex user interfaces that can easily be adapted to work seamlessly on a range of different devices and screens. But first I'd like to tell you a little more about the principles behind great Android design. Enchant me. Simplify my life. Make me amazing. They're incredibly one-sided wedding vows, and the three key principles underlying the Android team's creative vision for the platform and the apps that run on it. As engineers, it can sometimes be difficult to see past our own delight at harnessing the power of an SDK to bend a machine to our will. But ultimately, our goal must be to create that same empowering experience for our users. And we do that by creating apps that are as aesthetically pleasing as they are functional and easy to use. Users judge the quality of your app within the first 30 seconds. It may not be fair, but, a disproportionate amount of that judgement will be based not on the functionality, but on the visual aesthetics. Does it look polished? Does it look professional? How easy is it to use? More than just looking pretty, the entire user experience is critically important. With 30 seconds to win users over, it's critical that that onboarding process, that time and effort required to go from downloading your app to performing it's main function, should be as short and frictionless as possible. Not only that, but a well designed app should evoke a visceral reaction that speaks to the subconscious. It should be fun to use. It should surprise in delightful ways through subtle animations and smooth transitions that contribute to a feeling of power and effortlessness. It should let users touch and interact with objects directly rather than having to use buttons and menus. And it should use rich imagery and pictures in place of lots of words and long sentences. It allows users to customize your app, to make it theirs while providing beautiful and sensible defaults. Create something that works like magic, learning your preference in the context provided by the device, so it never asks users for information that they've already provided. Provide simple shortcuts to complete complex tasks, and remember data settings and customizations making them available across every device. While it's good practice to create a familiar and welcoming experience by creating a look and feel that's consistent with the platforms, styles and themes, it's just as important to remember that this, and all the other principles I've discussed here, are really just a starting point for your own creative vision. Deviation from the guidelines is encouraged, but when you do so, deviate with purpose. Before we move on, take a moment to consider some of your favorite apps. What do they have in common? What about them makes them enjoyable to use? Select your favorite examples and post screenshots in the forum. Describe how the design of the app contributes to your enjoyment using it and click this box when you're done. Thank you for posting your favorite apps on the forum, we'll be checking in on them periodically. But for now, let's get back to building Sunshine. Great. So to move one step closer to building awesome apps like the ones you submitted to the discussion forum, we're going to learn about how to build up the Sunshine UI. We'll do a quick recap first to help remind you of the concepts that you learned in lesson one. In order to build a UI in Android, we use Views. Views are rectangles on the screen, and we may or may not see the borders of that rectangle. Essentially, a view handles drawing and event handling, and all the basic widgets in Android extend from this base class. The Android design guide has visual examples of these basic building blocks of apps. For example, we have the basic text field, as well as editable text fields. You can do auto complete on them, and it comes with text selection as well, where it pops up a contextual action bar, for you to copy and paste. There are also buttons, and also a suggestion to use borderless buttons. It also has spinners, where you can select from a drop down menu. There's also checkboxes, radio buttons, on/off switches, and they also have some progress bars. There's a ton more basic widgets here, and also in the Java docs. Check those out, and even ones that aren't listed here. You'll come across them as you need them. Now, if you want to display multiple views together, you'll need a view group. A view group is a container for children views. Here are a couple of common view groups, which Dan introduced earlier. First, we have a frame layout. A child that gets added will be default positioned in the top left corner of the view group. If you add a second view here, it will overlap the first one. So typically, we only have one child per frame layout. Next we have a linear layout, it's composed of children either in a horizontal row or in a vertical column. We can also specify layout weight. Layout weight allows us to distribute the width or height of a parent across the children. For example, this has weight one, and this has weight one then the width of the parent can be split across them evenly. Then we have a relative layout where we can specify that a view should be aligned to the parent's left, top, right or bottom edge. We can also specify that one view should be relative to another view. It doesn't fill up the spaces nicely compared to a linear layout, but there are pros and cons to each. There's a grid layout where the views fill up cells in a grid. You can also have views that span multiple cells. I also want to point out that a view group is a view. In our code when we refer to a list item layout as being a single view, that just means the root view of the whole view hierarchy for that layout. Chances are that root view is a ViewGroup, so it contains children views as well as ViewGroups. So basically you can nest ViewGroups within ViewGroups. The reason why we care so much about parent child view relationships, is because the way a child view gets laid out depends on its parent. The simplest example of this is specifying a view's width and height. By now you've seen that every view requires a height and width. The two possible values are either wrap content or match parent. This diagram shows all the possible combinations for width and height for this text view. This is the balance of the view when we set wrap_content for height and width. This is what happens when we do match_parent for the width and match_parent for the height. And this is what happens when both are set as match_parent. It fills up the full dimensions of the parent. When you run this on the device, all of these would visually look the same, because you wouldn't see these boundaries. So why does it matter which one we pick? Well, it matters as soon as you have other children that need to be beside this view. Another reason is if you want to specify gravity. Let me spend a quick moment explaining gravity. Say for example, you have this text view within a frame layout. By default, the text is left aligned, and in this case, no gravity is set. If we specify gravity equals center, then it will center the content within the text view Vertically it can't move because it's already centered, but horizontally it does shift over to be in the middle. Instead of this, if we specify layout gravity equals center, that means to center horizontally and vertically within the parent. So we grab the whole child text view and we move it into the center. Now it can't be centered horizontally because it already takes up the max width of the parent. If we really want to move the content to the middle, then we should specify wrap content on this text view, so that it can be moved to the center with this attribute. You can also specify padding and margin on views. For example, if you added padding on this text view, then it would shift the content inside by x amount on all sides. If you specify layout margin to be x, then remember that the parent is the one who will be interpreting this layout prim. In this case, it adds a margin of x all around the text view. The text view is only this size. When you render both of these, they would visually look the same. Here's one case where it could matter. If this was a button and you pressed it, there could be a gray background here showing. In some cases you may want padding or margin or both. All views have a visibility property. For this image view, it can be visible, invisible, or gone. If it's invisible then it's not shown, but there's still a place holder for it, we still have to go and measure the size of it. If it's gone, then it's not even in the layout. It's as if it didn't exist in the XML. You can also toggle the visibility of a view dynamically during runtime. In the Java doc, you can find all the possible XML attributes for that class. It also shows inherited XML attributes, for example, from the view class for this image view, and then it shows the corresponding Java methods for those attributes. Now as a briefer, now we have some basics to help us get started, but definitely check out the developer site for more details later. Much like the real world, if you were working with a team to build an Android app, you would start by implementing the wire frames first. This has a correct flow for how the user will interact with the app. But it doesn't have the final visual look and feel yet. We'll build this up step by step, starting with the main activity then we'll move on to the detail activity and then later build up the tablet UI. Then we'll receive a set of visual marks, red lines and assets, all of this will help us build a pixel perfect layout To build out our UI, let's start with the wire frames for the main activity. It displays a list of forecasts where each item contains an icon, a date, weather description, as well as high and low temperatures for that day. Since today's weather is probably most relevant to the user,. We give more prominence to it as the list item compared to the other dates. We'll start off by building the list item layout for future dates because it's simpler and then afterwards we'll come back to do the today layout. In the current implementation the list item forecast layout xml. Is a horizontal, linear layout of four text views. We'll need to modify the layout so that it looks like this wire frame. We should divide and conquer until we can use the view group layouts that we're familiar with. Can you imagine how you'd break down this UI into components that you know how to build? As a hint, what if I draw these separators here? Within those elements, can you find a way to break it down even further with view groups you're familiar with? You'll need nested view groups which means view groups with children view groups. By the way, use the view id names that we provide in the instructor notes below so that your code will match ours. To verify that the layout is being built correctly, hard code some text values into the fields. Such as tomorrow for the date, or clear for the weather condition. For images, we can specify a placeholder drawable called ic_launcher. It's named this way because it's the launcher icon. Which is also known as the app icon and this is already included in our app. We'll be getting to the rest of the weather icons for our app later in this lesson. If you want to see what this layout looks like, you can click on the design pane to see a preview of it. On the right we see a component tree listing out the different views. We can also see for a given view what the properties are and their values. We can change the orientation of the device that you're previewing. You can also select different devices, such as Nexus 7 or Nexus 10. You can also preview multiple devices at the same time. As you build out your layout for this task, don't worry about the font color or font size, or any other visual details until later. After you compile and run, the app should look something like this. Every list item has the same dummy data. When you change the layout, it will actually cause a crash in your app because your code previously assumed that this list item layout only had one text view. So you'll need to go to the ForecastAdapter.java file. And comment out the lines of code in the bindview method. We're going to fix this method in a later video. To build up this List Item, we created a horizontal linear layout with three children. The first child is an image view. The second child is a vertical linear layout composed of two text views stacked on top of each other. The third child is the same. It's a vertical linear layout composed of the two temperature text views stacked on top of each other. Now, you might be wondering why we didn't use a relative layout. Because that would give us less layers of hierarchy. Well, relative layouts are good if you want to specify that one view should be to the right of another, or on top of another view. Relative layouts are also good if you want a view to be aligned to the parent's left, top, right, or bottom. But it's harder, in this case, to center these two text views within the vertical height allocated by this image view. It's easier with the linear layout here and here, so if the image was any taller, these two text views would still stay vertically centered. And this is what it looks like in the Device Preview within Android Studio. I want to point out one thing about this horizontal linear layout, which has three children: the image view, the vertical linear layout, and the other vertical linear layout. The second child actually has a width of 0DP but a weight of 1. That means that any horizontal space that's not taken up by other children will be distributed among views that have assigned weights. So, if we look at this third child, it has a width of wrap_content and a weight of 0. If we gave it a weight of 1, then it would stretch out like this. Basically, the icon is a fixed width, and then the remaining horizontal space is divided among these two children. Since they both have a weight 1, it's distributed equally. But if you look at the wire frames, these temperature views are actually aligned to the right. So, all we need is for the width to be wrap_content, and for the weight to be 0. Then, any remaining horizontal space will be assigned to this middle element, with a weight of 1. And this is the code for the XML layout. We have a linear layout in horizontal orientation. The width is match_parent to match the width of the screen, and each list item has wrap_content on its height. But it does have a minimum height at least of this attribute, listPreferredItemHeight. We specify gravity to be center_vertical so that all of its children are vertically centered within it. We also specify a little bit of padding. Inside of it, we add an ImageView, which has wrap_content for height and width, and we specify the source as this placeholder drawable. Next, we have the vertical LinearLayout, where the width is 0dp and the weight is 1. We specify a little bit of padding between this view and the icon beside it. Within the linear layout, we have the date_textview as well as the forecast_textview. Beside that, we have another vertical linear layout with the high temperature_textview and the low temperature_textview. And that's it. Next, we'll create the Today List Item. Since this layout is different from the other list items, we're going to need to create a new XML file under the resources layout folder. Use the same place holder image as you did before. Also, use the same IDs that you declared in the list_item_forecast_xml file. For example, in our code, we called this list item Icon, and we called this list item Date Text View. So, we use those same IDs for the elements in this XML file. You'll see why when we introduce view holders later. After you've finished adding it, make sure the app still compiles. You won't see any visual difference until the next step. Let me the explain the reasoning that I use when I look at a new layout. It looks like there's two equally spaced columns here. That signals to me, that we need LinearLayout weights, where each of these have equal weights. So let's create a horizontal LinearLayout. Within this first child, we have three vertically stacked text views, so we have a vertical LinearLayout, and the same goes for this second child, which has two elements vertically stacked on top of each other which means we use a vertical LinearLayout as well. And here's the code, we created a new list_item_forecasts_today.xml file under the layout folder. The code looks very similar to list_item_forecast. It has a horizontal LinearLayout, as a root element. The first child is a vertical LinearLayout with width zero and a weight of one. The second child is another vertical LinearLayout with a width of zero and a weight of one, that way the horizontal space will be distributed evenly among each child. If you go back to the first LinearLayout, notice that we have three TextViews within it, for date, high temperature, and low temperature. We specify gravity to be center horizontal, so anything within the LinearLayout will be centered horizontally. Otherwise, by default, they would be left-aligned to the LinearLayout. The same applies for the second LinearLayout. We specify gravity to be center horizontal so that the icon and the weather forecast TextView within it are also centered horizontally. Apparently the app shows dummy data that was hard coded into the XML file. Let's make the actual weather data appear on screen using the forecast adapter. For now we'll use the same layout for all list items, but we'll incorporate the today XML layout in the next video. Conceptually the forecast adapter manages the logics so that for each row of cursor we create corresponding list item. Think back on the explanation in lesson one about the array adapter, except instead of the datasource being an array, now the datasource is a cursor from the database The layout for the list item is defined in the list item forecast XML file. For one row of the cursor, we're going to go through and extract out the values. We call it binding the data to the views because we take the value in each column and we set it on to a different view. For example, the high temperature value would be set on to the high temperature text view. The low temperature value will be set onto the low temperature text view. For the next row, we bind the data in the same way until we create a list item for each row in the cursor. Currently, our code defines forecast adapter as extending from the cursor adapter class. If you look at the documentation for cursor adapter, you'll notice that it's an abstract class. There are two abstract methods that we need to override, bindView, and newView. The newView method returns a new list item layout, but has no data in it. The bindView method takes an existing list item layout and updates it, with the data from the cursor. In the forecast adapter class in the newView method we inflate the list item forecast XML layout. Then in the bindView method, we bind the data from the cursor to the individual views. For example, from the cursor we read out the weather description. Then we have to go through the view hierarchy to find the TextView that has the id list_item_forecast_textview. Once we find the TextView, then we can update it with the right description. We've provided a gist of code for the bindView method, to help you get started. But we left some to-dos in there for you to do. In the gist, we also included some helper methods and strings for date formatting. That's because, in our current implementation, all the dates are displayed in the same way. In the wire frames, though, we have a more friendly date format. Such as today, tomorrow, Wednesday, Thursday, etc. Here's the logic for what the helper method does to get the friendly date string. If it's this week, it says today or tomorrow or the day of the week. If it's more than a week out, then we use the format Monday June 8 and so on. After you compile and run the app, the actual weather forecast data should now be showing in the app. And it's using a more friendly date format. Check these boxes when you're done. And here's the solution. In the Utility class, we add all the helper methods that were provided in the gist. We also declare the related strings in the strings.xml file. After we read the high temperature value from the cursor, we go and try to find the TextView represented by the ID list_item_high_textview. Then we use a Utility function to format the temperature so that it can be displayed in the TextView. Then we do the same for the low temperature value. Currently, all the list items have the same layout. However, we want the today item to use a different layout which we defined earlier in the list item forecast today XML file. This is where adapter item view types will save the day. This is a general concept for all adapters, not just cursor adapter. Instead of just knowing about one item view type which yields the same layout for all list items, the adapter can declare multiple item view types, so it will have different list item layouts. For a given row in the cursor, the forecast adapter needs to decide if it should be a regular list item or a today list item. Then it will inflate, and bind data for the appropriate layout. We'll jump into the forecast adapter code now to learn how to handle a second item view type. Normally, in a sub class getViewTypeCount returns one, but we're going to override it so it returns two for the two different layouts. But how does it know when to use one layout, or the other? Well we override getItemViewType, so that when the position in the list is zero then we say that it's the today view type. Otherwise, it's the FUTURE_DAY view type. These two view types are declared up above. These are just integer representations of the view type. The numbering has to start at 0, because these values cannot be greater than or equal to getViewTypeCount. So the possible values for us are 0 and 1, so that we know that 0 always maps to the view_type_today, and that one always maps to view_type_future_day. We're going to use this information in the new view method. Remember that previously, we inflated the list item forecast xml. Now we're going to use item view type to determine whether we should use one layout or the other. Fill in the TODO to address this behavior. LayoutID refers to resourceID which is in the form of r dot layout dot something. To finish Todo we modify the NewView method to choose layout ID based on view type. If the view type is today, then we use this resource ID. This points to the layout XML file list item forecast today. If the list type is for a future day, then we use this resource ID. This points to the list item forecast layout XML. Then we inflate that layout. In the ForecastAdaptor bindView method, we have to traverse a view hierarchy to find the views in order to set data onto them. If it's a recycled view, meaning it's been used in the list previously to display other data, we still have to traverse the view hierarchy to find all the views. To remove unnecessary find view by ID calls, we can use the view holder pattern. For a list item layout that contains different views, we can create a view holder object. It contains member variables that reference each view in the layout. The view holder object is stored in the tag field of the view. The next time that the view is recycled and used again, we can just immediately set the data onto these fields. You don't have to go find all the views again. This is our ViewHolder class, you can name it anything you want, it's just a java class. Given the list item layout, we do all the fine view by ID calls. That way, we can hold references to all the child views. In the newView method, after we've inflated the view, we create a new viewHolder object from that view. Then we set the ViewHolder as the tag of the view. The tag can be used towards any object, but don't abuse it, because when you read it back, you have to know what you stored in there. Then in the adapter bindView call, we read from the tag to get back the viewHolder object. Now we immediately have references to all the individual views that we need to update, such as the icon view, date view, description view, and so on. Currently this is our forecast list. It looks okay, but it would be nice if we could show the degree symbol for these temperature values. Using this notation is best practice. It will help the translator know how to reorder the text and the parameters so that it fits the local language. Now let's look at how we can use this method to format temperatures within our app. Within the string.xml file, we declared the format temperature string resource. We use XLIFF tags to denote that this is where the decimal temperature value will go. This is followed by the unit code character for the degrees symbol. In the utility class, in the format temperature method, we can use this string resource. Remember that in this method, we take in a temperature and a user's preference for metric or imperial. Then we return the converted temperature. We're going to modify this method so that it also returns the formatted string with a degrees symbol after the value. In order to do this, we need to pass in a context, >From the context we can get access to the string resource ID that we declared earlier. Then we passed in any additional parameters for that string template. In this case we only have one parameter so we pass in the temperature value. Then this fully formatted string gets returned to the caller. This method is used in the forecast list, as well in the detail page. So we also have to update the code there so that it would compile with this new parameter. And this is what the app looks like after the change. Go ahead and make the change in your code to add a string resource for displaying temperature in degrees. Check this box when you're done. And remember, use this notation going forward, for when you need to format strings. You've implemented the main activity wireframe, so now we can move onto the detail activity wireframe. This is what it looks like. We have the date, the high and low temperatures, and then additional weather information. We also have the weather icon, and the weather forecast. And these line up horizontally. Build up the layout XML for this wire frame. Then modify the detail fragments that you can populate all this information, including these new views. While you're doing that, you might as well move the detail fragment into its own file, so it's separate from the detail activity. Before you get started, I want to point out that this layout has the information taking up a lot of vertical space. If you rotate your device into landscape mode, or you have a smaller height device,. Some of the content could get cut off. So think about how you can make this layout be vertically scrollable. To show you what I mean, I added a couple of more lines of text at the bottom of the layout. Then I made the content vertically scrollable. So you could see all the information. So go ahead and make that change to your layout as well. When you're done with all these steps, this is what the App should look like. We don't care about the visual details now. We just want to make sure that the functionality is hooked up, so all the right information is displayed on screen. You can use the code snippets provided below for helper functions and strings that you're going to need. And again, leaving a place holder image is fine for now. So how did you break up the UI into smaller components? Well, you might've thought that this could be two columns. But then it would be hard to position the elements here. You could center them vertically within the height of the screen. But it wouldn't necessarily line up with the temperature views on the left hand side. Instead this looks more like a horizontal linear layout. Then the rest of the elements could be laid out by using a vertical linear layout. The vertical linear layout would have six children. The third element would be a horizontal linear layout composed of two children. The first would be another vertical linear layout with these two text views and the second element would be another vertical linear layout composed of. These two elements. To make the contents of the whole screen vertically scrollable we put it inside a scroll view. Using a list view her would be overkill because we don't need to scale to an infinite number of item and we don't need recycling. There's a fixed number of fields on the screen so the scroll view is the perfect choice. I can show you our implementation for the fragment detail XML layout. We hardcoded some data in the layout. So that it would show up as a preview in the Design pane. At the root of the view hierarchy, we have a ScrollView. ScrollViews can only have max one child. So we set that to be the vertical LinearLayout. Inside of this layout, we have a TextView for the day of the week. The calendar date and then a horizontal linear layout. This is followed by the humidity text view, wind text view, and pressure text view. In the XMO code we see the scroll view with the child linear layout. We give it some padding of 16 dips so that the content is not flesh up against the edge of the screen. Then we see the text views followed by the horizontal linear layout. We specify layout margin top of 16 dip to give it some more space from the bottom of this text view. Within this horizontal linear layout we have one vertical linear layout. Which has a width of 0 and a weight of 1, and another linear layout with a width of 0 and a weight of 1. That means that both of these children have equal width. For this linear layout, we specify gravity to be center horizontal. That means that the contents inside of it will be centered horizontally. Which includes the icon as well as the forecast text view. Lastly we have the remaining text views for the other weather details. When the layout looks good, we update the detail fragment. At this point, we also move it into its own file. In the unload finish method, we used to have a find view by ID call to find the text view. Now that the detail fragment has a lot more views we don't want to continue adding even more fine view by ID calls here. Because it will have to traverse the view hierarchy every time that the loader refreshes. Instead we modify the on create method. Once the fragment is inflated we go ahead and find a reference to all the views we are going to need later on. We store these views as member variables of the class, which is why the name starts with the letter m. In the on create loader method we make sure that the projection for our content provider query contains all the information that we need. It's declared at the top of the file. Before we had it called forecast columns, but we just renamed it to detail columns. And we also added some more columns because now we're displaying more information on the screen. Then in the onLoadFinished method we get a cursor back with the data we need. We read the weather condition ID from the cursor because we're going to need it to determine which image to display but for now we can use a place order icon. We continue reading from the cursor to get the date, the description and the other fields. To format the data properly for the user we also copied over the strings and the utility method from the gist. Now that you know how to create an arbitrarily complex nested layout, it's important to understand that they don't come for free. Once again, the resource constraints of the platform spoil the party. Inflating complex layouts can be expensive, potentially impacting the performance and responsiveness of your app. So there are two good rules of thumb to help. First, keep your layout shallow and wide, rather than deep and narrow. That means you're better off with more siblings and fewer children. Because it's never as simple as that, you also want to avoid having excessive Views. In the most general terms, that means your activities' full hierarchy should never have more than ten nested Views or over 80 Views in total. That probably sounds like a lot, but let's open up the Hierarchy Viewer tool in Android Studio and see just how quickly that can add up. Here you can see Hierarchy Viewer, lets you select from a list of devices both physical and virtual on the left, each of which then contains, each of the running activities and applications running on that device. You simply select the activity from the application that you want to profile. Then the LoadView Hierarchy button here, and you'll see a representation of the selected activity's entire View hierarchy represented here in the TreeView, from left to right. You can see that the entire hierarchy is also show here, in the overview, and the layout itself is shown in a wireframe here. Clicking on any view, at any point within the hierarchy, will show you what is displayed, showing us the number of Views which are contained within the hierarchy from this point onwards. You can also obtain the performance metrics to find out how long it takes to measure, layout and draw each element of the hierarchy. It's a powerful tool, and you can find out more about how to use it to optimize your layouts and Views in the videos and guides linked to from the instructor notes below. For now, note that we can use it to find surprisingly deeply nested layouts that need to be flattened. For example, here we have a layout we can describe using one of two techniques. One solution is using two nested LinearLayouts. But a better solution would be using a RelativeLayout. The RelativeLayout is one level shallower. Another tip is to avoid using the FrameLayout as the root for layout that will always be inserted as a child into another one. In these circumstances, the merge tag is a better alternative. This will be eliminated when the layout is included into the parents' hierarchy. To help you remember all of these tips and tips, Android has a powerful static analysis tool called Lint. As you can see here in the Lint window, in addition to the layout warnings we've already talked about, it also checks from everything from accessibility problems, missing translations, and hard coded strings. You can find all the things lint checks for at the developer tools page linked to in the instructor notes. So now we have the wireframes implemented for both screens. But what does it look like on the tablet? Well, unfortunately, when we take the phone UI and stretch it out on a tablet, it doesn't look that great. There's a lot of empty white space here. We could better take advantage of this screen real estate by showing more useful information. For example, why do these details need to be a tap away when they could just as easily fit on this screen? And, furthermore, if the user wants to look through the full list of forecasts, their eyes must go like this, which is an unpleasant reading experience. If we want the user to read some content, we should keep the width narrower, so that they can scan it quickly. These considerations are part of responsive design. Responsive design means designing your app by keeping in mind that it'll be used across a range of different device screen sizes. How do we do that, and what does it mean to build for larger screen devices like tablets. Well, I can show you some examples of how apps adapt using multi-pane layouts. In the Android Design Guide, there's a section on multi-pane layouts. One technique is to combine multiple views together. For example, in the People app, you have the contact list and the contact card for additional details. On the tablet, we can put them side by side. This is also known as the MasterDetailFlow. This is the master list and this is the detail pane. In the settings app, we have another example. The column width adjust based on the available screen width. In the calendar app, we have panels, and they stack vertically in the portrait orientation, but horizontally in the landscape orientation. There also a couple of other examples that you can look through as well. If you want more information on designing for tablets or responsive design in general, you can check out the links below for more details. In this course, we're learning how to build up the phone UI first, and then the tablet UI. But in reality, when we're designing it, we thought about responsive design from day one. When you're building your own app, it'sbad practice to just completely design and build your phone app and then start to brainstorm about the tablet UI. That's because the tablet UI often has an impact on the phone design, as well as the architectural decisions made here. So, we need to build an app that adapts well to all different devices. But there's so many types of devices, so where do we begin? Well, we can start by grouping them into buckets based on physical size. We can have a bucket for phones, and a bucket for 7-inch tablets, and a bucket for 10-inch tablets as well. You can go even more granular based on screen width. But these are the most common buckets that you'll need. Now, classifying based on size alone is not enough. Even among devices of the same size, there's still a wide range of screen densities. Screen density is calculated from the number of dots per inch on the device or DPI. The scale starts off with low density devices, also known as LDPI devices. It has about 120 dots per inch, then it increases to medium denisty, high density, all the way to extra, extra, extra high density devices, where the number of dots per inch is much higher. So, how do we build an app that accounts for all these different screen densities? Well, when we specify layout dimensions, we quickly realize that we can't use pixels. For example, a 48 pixel button that looks fine on an MDPI device, will look much smaller on a higher density device where the pixels are more compacted and the physical size of 48 pixels is much smaller. The user wants a button to be easily tappable, so it shouldn't change based on screen density. So we need a consistent unit of measure to define physical size, and in Android we call that density-independent pixels or dips, or dp for short. That way, a 48dp button will be the same physical size across all these different screen densities. So, we know we need to create layouts and assets optimized for different screen pixel densities and sizes. So, now's a great time to introduce you to the Android resource framework. All externalized Android resources, everything from strings to layouts, to drawables and animations, are all stored within your project's res folder. You've already been putting your strings in the strings.xml file stored in the values folder. And you've been putting your layouts into the layout folder. And you know to reference your resources using @ notation within both your XML or within the code, and then at runtime, Android will insert, the appropriate resource for you. So far, so good. And here's where things get a little more interesting. Android allows you to create alternative versions of every resource by placing them into folders with different qualifiers. We separate each of those using a hyphen. And we add those qualifiers based on anything from language and/or dialect, to whether the device is docked, the type of touch screen, the pixel density of the display, the orientation of the screen, and most importantly, for a responsive design in particular, the smallest available screen width which you can support with that layout. At runtime, Android will check the current device configuration, it's language, it's screen size, pixel density, everything, and then load the right layout strings and drawables accordingly. And you can even chain these qualifiers together. For example, to create a different layout for German language users, to account for all of those really long German words, or more typically for a combination of screen size and device configuration. Now keep in mind, that many of these values can change at runtime. The most common change being that of orientation. And it's for this reason, that Android activities are destroyed and recreated, whenever the device configuration changes. And that's because the layout and all of the resources within it could be completely different based on something as simple as screen orientation change. Now it's good practice as well, to localize your apps and provide translated strings for all of your users using this mechanism. And that's a task made a lot easier, thanks to Google Play Publisher site that can offer you this service. It's also a really good idea to provide different drawables at the appropriate pixel density, so you can get a nice crisp image on every device. And when it comes to providing alternative layouts, Android has gone through a few alternative models, starting in the early days, with this screen buckets idea of small, normal large and extra large. But, since Android 3.2, the new smallest width qualifier has given us much more fine grained control over our layouts. Using the screen support page and whatever technical specification details you can find on the internet, what are the sizes and densities of these two devices, the Nexus One and the Nexus 5? For these purposes, the screen size should be one of the available buckets, small, normal, large, or extra large. And, the pixel density should always refer to one of our buckets, LDPI, MDPI, HDPI, XHDPI, or XXHDPI. The Nexus One has a 3.7 inch screen, and the Nexus 5, a 4.9 inch display, so they both fall comfortably within the normal range for screen size. The Nexus One has a screen density of 252 dpi, which is hdpi, whereas the Nexus 5, which was released three years after the Nexus One, has a much higher screen density, 445 dots per inch. That makes it xxhdpi. Beto mentioned that we should provide bitmaps at different resolutions. In our app, the 48dp icon on the Nexus S looks to be about the same size as on the Nexus 4, and on the Nexus 5. However, in reality, this asset that's being displayed, is actually a lot bigger in terms of pixels compared to this one. To confirm, we can check out the app resource folders. In the drawable folders, we see that our app has a 48 x 48 pixel launcher icon for mdpi devices located in the drawable mdpi folder. To make an equivalent icon, for the higher density devices, we need to make that icon progressively larger. To know exactly how big to make these images and what the dp pixel conversion should be, we use an mdpi device as the baseline. This is where one dp equals one pixel. Then on the HDPI device, one dp equals 1.5 pixels. And then it increases from there, all the way to an XXHDPI device, where one dp equals four pixels. For more info on the conversions, see the link below. Following those rules, these are the sizes of the launcher icon in our drawable folders. The MDPI one is 48 pixels x 48 pixels. The one for HDPI is 1.5 times the size of this one. For an XHDPI device, the icon is two times the size of the MDPI one, And for an XXHDPI device, the icon is three times the size of this one. We're providing you with an asset drop, view the link below, so that you can download the images and include them in the app. When we open up the assets ZIP file, we see that the same icon is provided at different sizes for different resolutions. In the drawable MDPI folder, we see the assets that will be used on an MDPI device. In the drawable HDPI folder, we see the assets that will be used on an HDPI device. And the same goes for the other folders. Under the res directory copy over all the asset folders provided in the download. Clicking on an image shows a preview of it and the size and pixels is also shown. At this time you can also remove the old placeholder ic launcher icons. Our new launcher icons are located in mipmap folders. These are distinct folders from the drawable folders. If you build an APK for a target screen resolution like HDPI, the Android asset packaging tool, AAPT, can strip out the drawables for other resolutions you don't need. But if it's in the mipmap folders, then these assets will stay in the APK regardless of the target resolution. But when would you need an image at a resolution different than the resolution of the device? Well, one example is the Android launcher app, which controls the home screen as well as the All App store. The launcher app won't use the icon at the current density of the device, but rather pulls an icon for the next highest resolution up. For an XXHDPI device like the Nexus 5, normally the assets will be pulled from the drawable XXHDPI folder. However, in this case the launcher icon will pull the XXXHDPI version of the launcher icon. That will make the larger app icons appear sharper on the all apps screen. In the code replace @drawable/iclauncher with @mipmap/iclauncher because of the new location of the icons. For the rest of the icons modify the forecast list and the details screen to display the right weather icon instead of the placeholder one. See the hints below in the instructor notes. Using the helper functions we've provided in the gist below, you can map the weather condition code to the icon that you'll need. This is what the app should look like when you're done with this step. Note that there are two types of each weather icon, a gray icon and a colored art image. In the main forecast list we'll be using the gray icon. However, for the today layout, we'll use the colored icon. When you go inside the detail activity, you'll also use the colored icon. At this time, you can also remove any images you hard coded into the layout XML, because they'll be populated dynamically now. After copying over the assets, updating the launcher icon in the Android manifest, and adding the helper methods to the utility class, we need to modify to detail fragment and forecast it after classes. In the detail fragment onload finished method, we read the weather condition code from the cursor. Then we pass this into the utility helper method to get the resource ID for the colored icon in order to set it on the image view. The ForecasterAdapter change is a little trickier because we want to use a colored icon for the today layout and we want to use a gray icon for the other days. In order to distinguish between the two, we call getItemViewType given the current cursor position. If the view type is today. Then we get the weather condition code from the cursor. Then we get the resource ID for the colored image from the helper method. And then we set that on to the image view. If the view type is for a future day, then we read the weather condition code from the cursor. Then we pass it into the helper method to get the resource ID for the gray icon and then we set that on to the image view. If you previously hard coded an image into the layout, then you should remove that value now. Otherwise on app launch, it will load up the placeholder image and then flash to the actual icon. Now that the wire frame implementation for the phone UI is pretty much complete, let's look at the tablet UI. When we were learning that responsive design, we saw that a common pattern was to use the MasterDetailFlow, which is what were going to use for Sunshine. Here are the tablet mocks. We have a list of forecasts on the left, and then for the selected item, we see the detail pane on the right. This applies for 7-inch and 10-inch tablets, both portrait and landscape orientations. In portrait mode, the columns are just a little bit narrower, but it's still a two-pane UI. In terms of implementation, all of this will be under the MainActivity. Then on the left we have the ForecastFragment. And then on the right, we have the DetailFragment. On the phone, we would still have the MainActivity with the list of forecast. And then selecting an item would still launch the DetailActivity. Here's another way to visualize it. On the tablet, we have two fragments side by side under one activity. And then on the phone, we have the first activity containing the first fragment. Selecting an item will launch the second activity containing the second fragment. We're going to break this up into multiple coding tasks until we build up the final layout. First we'll build up the two-pane UI for tablets. Then we'll hook up the communication between the two fragments so that's selecting an item replaces the detail pane on the right. Then we'll learn how to show and activated state on the currently selected item, so we know what the details pane corresponds to. We'll also need to make sure that the scroll position is maintained across orientation changes. After that, we'll update the DetailLayout so it's optimized for these wider screens. And then we'll modify the adapter so that the today layout looks like the other days. There's no special today layout on the tablet. So hopefully it's clear how we're going to approach implementing this tablet behavior and we're going to step through it slowly, one by one. So now you know, where fragments are used and where we're going to use them in our app. You're probably starting to ask, why use fragments at all? If we want to group UI components, couldn't we just create a View Group, or maybe a re-usable XML layout definition? Yes, but the real power in fragments goes beyond grouping UI elements. They allow us to fully modularize our activities, including the life cycle events they receive in the app state that they maintain. Fragments were first introduced in Honeycomb to solve a particular problem. Honeycomb was the first Android release to support tablets and it turned out, the best way for most apps to create a great tablet UI was to put two or more of their phone activities alongside each other. For example, if you had a phone app that started with a list activity like this, which you then clicked an item, would open a detailed activity like this one. What we call a Master Detail Flow. A good tablet UI would put them side by side like this. Functionally, clicking an item on this list, now replaces this activity on the right, rather than starting a new one, as it would have done here on the phone. Now, unfortunately, Android didn't always support embedding activities within other activities. At least, it didn't, until we introduced fragments. Now, if you just look at the UI elements, you could be excused for thinking that you could achieve much the same thing using an activity that was built using U Groups and layouts, without bothering with fragments, which is true, up to a point. But then you'd have to pass through all of the activity life cycle events, manage the state of each piece of the UI, keep track of the state of each of the portions as they changed, and remember which screen elements were on screen at any given time, in order to maintain app state. All of which, is exactly what the Fragment Manager does for you, when you use Fragments. And that lets you take a step back and treat each fragment as though it were a mini activity. For example, in the world of activities, you start one activity from the other, and that transaction is recorded on the back stack. So, hitting the Back button, will undo that transaction and bring the first activity to the front. Now, the same thing can happen with fragment transactions. In this case, rather than starting a new activity, we simply replace the list fragment with the detail fragment. And then, the Back button will undo that transaction and reverse it. So in theory, you can really take any app with multiple activities and replace it with a single activity that's host to multiple fragments. Think about how that might work. What are some of the reasons you may not want to create only a single activity within your application? There's a number of reasons you'd be potentially better off breaking your app into different activities. Having a single monolithic activity increases the complexity of your code, making the creation and management of intent filters much harder and making it more difficult to maintain, test, and read your activity code. It also increases the risk of tightly coupling independent components and makes it much more likely to introduce security risks if the single activity includes both sensitive information and information that's safe to share. A good rule of thumb is to create a new activity whenever the context changes. For example, displaying a different kind of data, while switching from viewing to entering data. So if we treat fragments as mini activities, each with its own independent life cycle in UI, how does that compare to the life cycle of a real activity? Well as you might expect, the basic life cycle events are much the same as the parent activity. And as it moves through the cycles of starts, resumes, pauses, and stops, those same life cycle events will be triggered within the fragment itself. So, in most cases, you can simply move anything that you would have put into the activities life cycle handles, into the corresponding fragment handles. With, of course, a couple of exceptions. Rather than building your UI here and onCreate, fragments introduced a new event specifically for this. OnCreateView is where you construct or inflate your UI, hook up to any data sources, and return it to the parent activity which can then integrate it into its view hierarchy. There's a corresponding onDestroy view handler, which is called immediately before the fragment is added to the back stack, independent of the parent activity. Now keep in mind that the FragmentManager can add any fragment transactions adding, removing, or replacing fragments to the back stack, with a single parent activity's actives. So a fragment can move through this cycle multiple times independent of the host activity. So onDestroy view is, where you should clean up any resources specifically related to the UI, such as bitmaps in memory, cursors to data, anything like that to help ensure that your app's memory footprint isn't bloated by data that's not needed when the fragment isn't visible. Now as soon as the fragment is returned from the back stack, on CreateView is called, and you can re-create the UI and reconnect data sources before your fragment transitions through the rest of the life cycle to become active again. And because a fragment can only exist within an activity, we also need callbacks to tell us when a fragment is attached and detached from its parent. OnAttach is your opportunity to get a reference to the parent activity. While onDetach is the last thing that happens, even after your fragment has technically been destroyed. Now, the final piece of the puzzle is onActivityCreated. This notifies our fragment that the parent activity has completed its OnCreate handler and represents the point at which we can safely interact with its UI, potentially including other fragments. Now, just like the activity lifecyle we discussed in lesson three, once the fragment is no longer visible, there's a chance it will be terminated with no further code being executed. That can happen, after onStop, in the case of the activity being terminated while the fragment is part of that activity's view hierarchy, or after onDestroyView, if the fragment has already been placed in the back stack once the activity is destroyed. I've mentioned the FragmentManager, FragmentTransactions in the back stack a few times. Now, take a look at the documentation on the Android developer site, and complete the code, which will replace the contents of the fragment_container with a new instance of the Details Fragment. Keep in mind that this transaction should allow the user to reverse the transaction using the Back button. And in this case, we'll be calling this code from within an activity. We use the FragmentManager to begin a transaction, to look that we want to add this transaction to the back stack, and the use the replace command specifying the container i.d. whose contents we want to replace and the new fragment we want to put in there. And we execute the transaction by calling commit. Now you can actually chain a number of changes together within the same transaction, so it's also possible to achieve much of the same effect by first removing the contents of container A and adding fragment B to that container. The final advantage of fragments, doesn't involve user interfaces at all. As you know, as visual components, activities are destroyed and recreated, whenever the device configuration changes. Most notably when the screen orientation switches. That makes sense, because there's a good chance we'll want to create a different layout, to better suit the new configuration. But, if we can use fragments to break up visual activity modules, why not logical ones as well? It turns out we can do exactly that. And because these fragments are non-visual, there's no need to recreate them every time the UI needs updating. Within the onCreatehandler of your non-UI fragment, call setRetainInstance, passing in true, and return null, within your onCreate view handler. Then, once the parent activity is created, you can kick off any connections, threads or tasks that are bound to the lifetime of the activity, which don't need to be interrupted every time the device rotates. Great. So, let's apply what we learned about fragments and resource folder qualifiers to update our Sunshine app. Figure out which layout folders should contain an activity-main layout file, so that we can accomplish a one pane UI on phones, and a two-pane UI on tablets. You can select from these options for this quiz. You can use the link provided below to help you answer the question. We mentioned this several times, but the SW in the resource folder name stands for smallest width. To drive home that point, let's walk through a hypothetical situation. Say you have an app directory structure like this. We have some layouts defined in the base layout folder, and we override some of those in the layout-sw600dp folder. We also override one of these in the layout-sw720dp folder. Let's look at which layouts would be applied on which device. Say your app is running on a Nexxus 5. The Nexxus 5 has dimensions 360dp x 640dp. Of the two, the smallest width is 360dp. So we use this number to compare it against the folder names. 360dp is less than 600 and is less than 720, so all the layouts will come from the space layout folder. For the Nexus 7 2012 version, the dimensions are 600dp x 960dp. Of the two sides 600dp is the smaller width. So you compare this against the folder names. It turns out that the smallest width is better than or equal to 600dp, so for the detail and the item layouts, we pull it from this folder. Now the main.xml file is not declared in this folder, so we fall back to a less specific folder, which turns out to be this one in the base layout folder. For the Nexus 10 the dimensions are 800dp x 1280dp. Of the two sides, 800dp is the smallest width. Now this device satisfies the categories for all of these because 800 is greater than 720 and greater than 600. However, the system chooses the most specific folder first. So it will choose this item layout over these two. Since the detail layout is not defined here, it will fall back to a less specific folder, which is this one. Then for the main.xml file, it's not declared in either of these, so it falls back to this one. By taking the knowledge that we learned about overriding resources in other folders, we'll walk through the code together on how to build up the two-pane tablet UI. First remove the values W820dp folder because we don't need to provide specific logic when for when the current orientation is greater than 820dp. Then go ahead and make the layout XML changes. Then create a new layout SW 600dp folder. And then add a new file called activity_main. We use the same file name as in the base layout folder activity_main so that this one overrides the behavior specifically on tablets. To see the code for this file you can check out the gist below. Essentially it's a horizontal linear layout that can hold a forecast fragment on the left and a detail fragment on the right. Now's a good time to talk about static verses dynamic fragments. In our implementation the forecast fragment is the static fragment because we're defining it in the XML layout no matter what orientation or device size we know that we're going to need a forecast fragment in the main activity. On the other hand, we only declare a container for the detail fragment, but not the actual fragment. It's initialized with different arguments each time as a dynamic fragment, so it's better to dynamically create and add that fragment in a fragment transaction in the main activity Java code. That way the fragment manager can keep track of those initialization arguments and pass those back to us on, after device rotation. Then we need to update the one pane UI layouts so that they're consistent with the two pane case. So in the activity main file for the base layout folder this used to be a frame layout we're going to declare it as a forecast fragment. That way it will match the two pane UI, where this also is declared as a fragment in the XML. That way the main activity never has to worry about dynamically adding the forecast fragment. In the main activity on create view method. Since the fragment is already inside this layout we can just remove this so we don't dynamically add it again. Similarly we modify the activity detail layout in the base layout folder we change the frame layout ID to be weather detail container. So that it matches the container view id in the two pane UI case. The pattern here is that the detail fragment will always be added to a container called weather_detail_container, both in the two pane, and one pane case. Since we changed the name of the container, we should also update the detail activity. This is only used in one pane mode. Here's where we change the container name. In the one pane mode the detailed activity will add the detail fragment dynamically to this container. After we modify the layout we should update the main activity so we dynamically add the detail fragment. In the main activity on create method we check for the presence of the weather detail container in the layout to know whether this is a two pane UI or not. We keep track of this information in a Boolean called mTwoPane. Remember that we start with the letter m, because it's a member variable. In this case, the Boolean should be true. So we go ahead and create a new detail fragment, and add it to the weather_detail_container. We commit the change by using a fragment transaction, which Rado introduced earlier. Otherwise If the detail container is not present in the layout, then the boolean should be false, meaning that this is a one-pane UI for phones. In this case, the detail activity will handle showing the detail fragment. Notice for the two-pane case that we check if the saved instant state bundle is null. If the save instant save bundle is not null, then we don't create a new one, and here is the reason why. Say you want to rotate the device. Before the activity and fragments get torn down, we store information in save state bundles. Then after the orientation change, the system restores the activity and the fragments, by passing back the same bundle, so that it can be recreated with the same state. That means if the bundle exists, then we should let the system handle restoring the detail fragment, and we can skip this code. Once a detail fragment is added dynamically. Make it show some placeholder data just for testing purposes. Later we'll plumb through the right logic, so that it can display the right information for the selected date on the left. Modify the detail fragment so that it doesn't expect the incoming intent to have a data URI. In this case, the detail fragment will just fall back to some placeholder data that we have in our XML. The reason the intent could be blank is because the detail fragment can now exist within the main activity. And the main activity isn't launched with a URI for only one date like the detail activity is normally launched with. Once you make the changes for the wire frames this is what the app should look like. The reason it doesn't show an icon here is because we removed the icon from being hard-coded in the layout. But once this data is populated dynamically in a later section, it should show up again. Once the two panes are showing up on the tablet, let's modify our code to handle the list item click. On the phone, if an item is clicked in the forecast fragment, then we must launch the detail activity. On the tablet UI, once an item in the forecast fragment is clicked, we notify the main activity which goes and replaces the detail fragment. The reason the two fragments don't talk to each other is because we want to maintain abstraction from each other. If the forecast list fragment started assuming that the detailed fragment was always right next to it, then the assumption would break, for example on the phone, where the data fragment is not inside the main activity. Therefore, a fragment must go through it's activity. An activity must know how to dispatch the event to the other fragments. Keep in mind that a fragment doesn't always has to be used in the same activity. In order for the forecast fragment to talk to the main activity, we should create a callback interface. It's a better assumption to say that the fragment will always be within an activity that implements this callback; then to say that the forecast fragment will always be inside the main activity. The detail fragment is a good example of how a fragment can be used in two different activates, the main activity and the detail activity. So don't rely on get activity returning a specific activity class. Using the gist that we provided, use a callback class to notify the activity that a list item has been selected. See the hint below on the OnItemClickListener. Then, the activity can either launch the detail activity or replace a detail fragment based on whether it is a phone or tablet. When you work on this task you'll run into an issue of how to pass the selected items you arrive to the detail fragment, now your instinct might say to create a custom constructor where you can pass in the date, however, we don't normally create custom fragment constructors. If you ever rotate the device, for example, the system can't call your custom fragment constructor with the right parameters. However, it can use the empty fragment constructor and initialize it with the same bundle of arguments used earlier. So to pass information to initialize a fragment, create a bundle of key value pairs and then set that as the arguments on the fragment. Don't confuse this arguments bundle with the savedInstanceState bundle. Once a fragment has been initialized, you can't change the arguments, you can only read from them, as seen here. On the other hand the save state bundle is for storing information once a fragment has been running, and you can populate it in the on save instant state method. The bundle can preserve state across orientation changes or if the fragment or activity gets killed by the system, that's why you receive it back again in the onCreate or onCreateView methods. Once the detail fragment starts being displayed on the tablet, we need to make sure that doesn't get out of date if the location changes. If the user went to Settings and entered in a new location, when they come back to the main activity, in the onResume method, we should detect that the location has changed. We do this by comparing the nLocation string with the location that's stored in shared preferences. If there's a difference, then we find the ForecastFragment and notify that the location has changed. Similarly, we find the DetailFragment and notify that the location has changed. Since the DetailFragment is a dynamically added fragment, we need to make sure we find the right instance in the FragmentManager. We do this by calling findFragmentByTag and passing in this tag. We associated this tag with this fragment when we first did the fragment transaction to add it to the screen. If you didn't already create a tag and associate it with the detail fragment in the fragment transaction, then go ahead and do it now in the onCreate method of the main activity. And you'll notice that the detail fragment tag is just declared as a string at the top of the file. After we make the changes to the main activity we go over to the detail fragment, we add a new method onLocationChanged that takes in a new location string. First, we try to figure out what is the date for the data that we're currently showing. Then we create a new Uri with the new location, as well as the date we're already displaying. We update the nUri and then we restart the loader. See the instructor notes for the code related to handling the location change. This is what the app should look like when you're done. When you tap on a different date, it updates the detail pane. You can remove any hard coded data because the layout should be populated dynamically now. In the Forecast Fragment class, we add the Callback interface that was provided in the gist. Then, in the onCreateView method, we modify the list item click behavior. When an item is clicked, instead of always launching a new intent to the detail activity, we want to notify the Callback instead. We call getActivity and then cast it to a Callback object, then we can call onItemSelected on it. We pass the URI that represents the selected location and date. Then, in the main activity, we implement the Callback interface. In the onItemSelected method, we fork the behavior based on the mTwoPane variable that we defined earlier. If we're in two-pane mode, then we create a DetailFragment and put the URI inside the arguments bundle. Then we replace the existing DetailFragment in the weather_detail_container, using the DETAILFRAGMENT_TAG. In one pane mode, we create a new Intent to launch the DetailActivity and we set the data URI. In the DetailActivity, we modify the onCreate method to read the data URI from the incoming intent. We take the URI and set it as an arguments in the new DetailFragment. Then we dynamically add this fragment to this container. In the detail fragment, we modify the onCreateView method to read the arguments that the fragment was initialized with. We read the data URI and store that in the member variable mUri. In the OnCreateLoader method, we remove some code that relied on incoming intent, and switched it to use mUri instead. Whether this DetailFragment is in the main activity or the DetailActivity, it should have mUri set. Then we're going to use mUri to query the content provider for the data to display in this DetailFragment. When you try it out on the tablet, there is one bug related to navigation that we should fix. Say we select tomorrow's date, if you navigate to the settings activity, and then hit the up button, the detail fragment is blank. That's because a brand new instance of main activity got launched, and for a brand new instance, nothing is selected yet. To fix this, when the setting activity up button is pressed, we want to navigate to the previous running instance of the main activity where the tomorrow item is selected and now create a new instance of main activity. In the SettingsActivity, override this method, which the system will call in order to get the parent activity intent for the up button behavior. Get the parent activity intent from the super class, this should create a new intent to main activity. Then add the intent flag called FLAG_ACTIVITY_CLEAR_TOP. This flag indicates that we should check if the main activity is already running in our task. And to use that one instead of creating a new main activity instance. Also this method didn't exist prior to Jelly Bean so we need to add this @TargetApi annotation. If you check the documentation for the activity class, the getParentActivityIntent method was only added in API level 16, and you can check that version 16 maps to Jelly Bean. In the tablet wire frames, when a list item is selected, it shows this blue activated state background. This can be done by setting the background of the list item to be a state drawable. We can look at the documentation for this StateListDrawable, which is linked below. Essentially, a StateListDrawable allows you to specify different drawables based on the state of the view. We provide you a code for the StateListDrawable. Drop it in by creating a drawable folder under the res directory. When set as the background of a list item, we see that the background is just transparent by default such as this today lay out here. When the view is pressed, then we see a grey background. When the view is activated, then we see this blue color. This is also indicating that it's the selected item in the two pane mode. We also have a second version of the touch_selector file for Lollipop devices and above. This is saved in the drawable-v21 folder. Set on platforms API level 21 and above, it will use this version of the touch_selector. On older devices it will fall back to the touch_selector in the base drawable folder. One of the main principles of material design is responsive interaction. One way to accomplish this is that when a user touches a device, the device will acknowledge the interaction, and a ripple will radiate out from the touch point. This is done with a ripple drawable. You can add a ripple element in your state list drawable xml. For the v21 touch selector, it's the same except that for the pressed state, we have a ripple drawable with a grey color for touch feedback. And on a Lollypop device, you can see the ripple. In the list item layout, we set the background to be this touch_selector. We do the same for the list_item_forecast_today layout. Back in the touch_selector file, I want to note that there's some colors here. The @android color notation is for a framework defined color. The other colors are ones that we defined in the colors.xml file. This file is located in the Values folder of your app. It's useful to store colors in a central location if you need a reference colors multiple times in your app. As a hint. to make a list item show its activated state, you can look at the documentation for the XML attribute choiceMode for the ListView. Once you find the right attribute, you'll realize that you want different behavior for one pane versus two pane mode. While you could change the behaviour programatically in the Java code, we'd like you to do it purely via the resource XML files using a style. Read this doc to learn about how styles can be defined in XML. And use what you learned earlier about defining alternative resources for different size devices. In general, styles are a way that you can group together attributes for a view. For example, these text attributes are replaced by this style CodeFont. The CodeFont style is defined in the styles.xml file located in the Values folder. You can also have styles inherit other styles by specifying the parent. There are a couple of other examples you can check out on this page. This is what the app should look like when you're done. In one pane mode, we don't see the activated state. But there's still the regular press state with the ripple and then it goes away >From the documentation, we want single choiceMode so that the list item only shows one selected item at a time. We can declare this attribute on the ListView in the fragment_main file. However, we don't want to specify choiceMode in one pane mode. To have these different code paths, we could copy the file in the Layout folder and put it in the Layout-sw600dp folder. A better solution is to declare a style, so we have one layout file but different styles. In the Base styles file in the Values folder, we declare ForecastListStyle. We leave it empty because we don't need to specify choiceMode. We create a new styles file in the values-sw600dp folder. In the two-pane case, the ForecastListStyle does include the choiceMode. The two files have a different number of styles. If it's not declared a higher folder, then it will just fall back to the Base style. On the tablet, there's a bug where if you select an item near the bottom of the list and then you rotate the device, the selected item is no longer scrolled into view. You have to manually scroll the list. That means we should store the position of the selected item in the SavedInstanceState Bundle. If the app is killed, when it's restored, we should read the position back from the Bundle. If the list isn't populated at that time, then we should wait for the onLoadFinished callback to use a position to scroll to the selected item. Check these boxes when you're done. In the forecast fragment, we create a position variable. Whenever an item is clicked, we update the position. Then, in the onSaveInstanceState method, we store the position in the bundle. If the app gets killed, then we can restore the position from the Saved State bundle. This is on the onCreateView method. The reason we store in a global variable is because the list view probably hasn't been populated yet. We wait for the onLoadFinished callback to happen when the cursor is swapped. Then, we can tell the list view to set selection on that position and that position will be scrolled into view. We're not quite done yet with implementing the tablet UIwire frames. The detail fragment should look like this, but instead it looks more like this. For the tablet UI, we try to optimize it more for wider screens like tablet landscape mode. Another good place for this layout, is in the phone landscape view, where there's more horizontal space than vertical space. For this quiz, figure out which layout folders, we would need to define the fragment-detail layout in. in order to achieve this layout on phone portrait and this layout for phone landscape and tablet. We definitely need to define fragment detail in the base layout folder, then we override it in the layout-land folder, so that we can achieve this layout on phone landscape orientation. Tablet landscape view would work fine because of this folder, but then tablet portrait would fall back to this layout so we should just define it in the layout sw600dp folder so that all tablets, regardless of orientation, use this layout. The solution of the previous quiz said that we had to define the wide detail fragment layout in two places: the layout-land and the layout-sw600dp folder. To avoid having multiple copies of this file, we should use layout aliasing. We can check the documentation for layout aliases to see an example. Saw we have a main layout file that's for one pane UI. In the layout-large and layout-sw600dp folders, we want a multi-pane layout. In case you're wondering, layout-large is for backward compatibilty purposes for large devices prior to Android 3.2. That's when the SW qualifiers were introduced. So back to the point. To avoid code duplication, we can define the two pane layout in the base layout folder. Then, in the values-large and values-sw600dp folders, we can create a reference so that the main layout actually maps to the two pane layout. In the Java code, you can reference it as r.layout.main, but it's actually referencing the two pane layout. This is what the detail fragment should look like afterwards. And this is what the phone landscape view looks like. If you rotate the device, the phone portrait view should be different. In the next coding task, we're going to make the today list item look more like the other items in the list for the tablet. We build a wider detail fragment layout, using a horizontal LinearLayout composed of three vertical LinearLayouts. This is what the XML code looks like. And you can see it linked below. Then we use layout aliasing to override the fragment_detail layout. In the values-land and values-sw600dp folders, we create res.xml files. In both files, we alias fragment_detail through fragment detail wide. And now we have a more responsive layout to wider screens. Going back to the wireframes. In the phone layout, we wanted the Today item to be a little bit bigger, but on the tablets, we just want it to look like all the other items, because we have an expanded detail pane here. To do this in the forecast adapter newView method, we should return the layout for a list item forecast not for the today layout. Then in the bindView method, for the today item, we should use the gray icon instead of the colored icon. These decisions get controlled by the return value of the getItemViewType method. Therefore we modify the getItemViewType method so that at the zero position, if we have to use the special today layout, then we return View type today. Otherwise, if we shouldn't use the special today layout, then we should just return the View type for all future days. This Boolean is controlled by the setter method. To access this Boolean, we created a public setter method on the forecast adapter. But who knows how to set this value properly? Well the main activity knows whether it's one-pane or two-pane UI. So, it can decide whether we should use the special today layout or not. We don't have access to the forecast adapter here, but we can plumb the values through the ForecastFragment. To get access to the ForecastFragment, we can ask the fragment manager and pass it the fragment ID. Finish changing the code so the app looks like this. In the MainActivity, we tell the forecast fragment to use a special today layout if it's one pane mode. In the fragment, we pass on this value to the forecast adapter, if it's not null. The reason it could be null, is because the activity onCreate method will happen before the fragment onCreate view method. And this is where the forecast adapter is initialized. So we set the Boolean here as well. The reason we have this code here is because it's a public method. So, in the future it could be called before or after this method. Hurray, you're done implementing wire frames for the app. Now comes the visual polish part, where we tweak the styles and the views to make the app look awesome. Here's the visual mocks, for what the app should look like when we're done. If you work with a designer, they should also give you redlines. Redlines specify everything from sizes, font styles, colors, spacing, etc. This should help you achieve pixel perfect layouts that match the visual mocks. How did we come up with these values? Well we used the Android design guide which has information on metrics and grids, and we adapted them to fit our app's needs. You can click on the link for more info. Earlier we learned about styles and how you can apply them to an individual view. If you want to apply it to all the views in an activity or application, you can do it by specifying a theme attribute on the activity or application tag in the Android manifest. Now we style the action bar to look like these visual mocks for the main and detail activity. The settings activity is a special case because it extends from the preference activity class, instead of the action bar activity. So that's going to be done in the next section. For both cases here we want the background color to be this blue hex color. We notice that the detail activity only shows the title, no app icon. And this button is to go up to the parent activity. If you see visual marks that have the app icon or a different up button, they are outdated. The material design, this is our new look. On the other hand, the main activity shows the logo. It's a different attribute than the app icon. And this was provided in an acid drop earlier in the lesson, and it's called ic_logo. Because of these differences, we need two separate themes. We use AppTheme for the detail activity and ForecastTheme for the main activity. In material design you can choose several app colors and specify them in your theme to colorize certain UI components that are controlled by the framework. For example the framework will use colorPrimary as a background of your action bar or your tool bar. The framework will also use colorPrimaryDark as the status bar color. To customize our app theme, go to the Styles file in the values folder. Our AppTheme inherits from the system Theme for a Light app because we have a Light content area with a DarkActionBar. We specify colorPrimary to be this sunshine_blue color. And this will be displayed in the action bar, also known as app bar. And then we set the colorPrimaryDark to be this darker color. This is going to be shown in the status bar, and typically the status bar is a darker color than the app bar. Both of these colors are defined in the colors.xml file as seen here. Then for the main activity, we create a ForecastTheme. We inherit from AppTheme in case there's more attributes that we want to add here, and then we'll inherit them for free. However, we do override the actionBarStyle. This is so that we can set the logo to point to this drawable file and also change the displayOptions so that the logo does appear. For more information on the action bar displayOptions, you can see the list here. If you run the app now, there's a shadow below the action bar that is default behavior. However, according to our visual designs, we want the action bar and the today item with the blue background to be on the same plane, meaning we don't want one to cast a shadow over the other. As a result we set the action bar elevation to be zero if it is in one pane mode. If it's in two pane mode, then the today item does not have a special background, and it's fine if the action bar casts a shadow. Go ahead and make these changes now using the gists provided. It's time to implement the redlines for the main activity. We can do one part together so that you get the hang of it. We begin by styling the list item Forecast Layout. The redline specifies that the image should be 32dp by 32dp. We could hard code the image view to be 32 by 32dp, but it's actually the same as leaving it as wrapped content for height and width. To know what the icon size would be if we wrap content, we open up the MDPI version of the icon, and we do verify that it is 32 pixels by 32 pixels. Whether we hard code it or just add wrap content, visually, the image will still look the same, but in the future it will be more flexible if we just specify wrap content in case the image size changes. Next we style the text. On Ice Cream Sandwich and above, Roboto is the default font for text views. It is created specifically to satisfy the requirements of UI and to optimize for high density screens. The redline indicates that the font family is Roboto sans serif condensed, so we add that to the code. On the topic of font sizes, having too many font sizes in your app, can confuse your user about the visual hierarchy of your app, as to what's important and what's not important. The Android design guide recommends these four type sizes for consistency with a platform and for user experience. In our app, we stick to the standard type sizes. Unless it's an intentional part of the design, such as the large temperature values. Hence, when the redline says that the date text should be 22sp for font size, we could specify Android text size to be 22sp, but the text appearance large attribute already maps to that value. Note that the font sizes are specified in sp, and not dp. Sp stands for scaled pixels, so you can scale with the device font size. In our app we specify text appearance large, and text appearance small, which will give us 22sp and 14sp respectively. The default font color is black, so we don't need to specify the android text color attribute on our text views. Let's look at the spacing for the elements within the list item now. We have three children. The first one is 60dp wide, with the image centered inside of it. So we can add a frame layout around the image view and set the gravity to be center on the image, that way the image centers itself within the parent. For the other two columns, we shouldn't hard code such high dp values. Because otherwise the layout won't scale across other devices. Instead, we can use linear layout weights, with the weight of seven here, and the weight of five. We just tried different values until we got approximately equal to these values. The trick in doing redlines is that you want to match the visual specs, but you also want to be flexible in the code, so that it adapts to different screen sizes. And this is what the code looks like for the list_items_forecast layout. We have a horizontal linear layout, containing the frame layout with the image view. Then we have a vertical linear layout with weight seven. And then we have another vertical linear layout with weight five. We can check the link below for the full code file. This is what it should look like when you're done. These items looks polished but we haven't gotten to the today item yet. Implement the rest of the redlines on your own. Test on the phone and tablet, and in both orientations. Here's a useful tool to help you with redlines. Under developer options, you can click show layout bounds. When you go back to the Sunshine app, you can see the bounds for all the views, including padding and margin. When you're done, feel free to check with our implementation at the link provided below, then check the box to continue There's always more changes that we wish we could do, if we just had a little more time. We're going to leave those as exercises to you if you want to keep polishing it up. For example, for simplicity, we had all tablet sizes and orientations, use the same layout. However, 7 inch portrait would actually look better as a one pin UI. So you can modify your resource folders to make 7 inch portrait use the phone layout. You can also tweak the two pane behavior so that the today layout is auto selected when you first launch the app. Also, this should just say "today" instead of having the full date. That way, it'll look more like the other items. As you play around with the app, feel free to make any changes you think would help improve the user experience. To evaluate how accessible any app is, you can step through the Accessibility Testing Checklist. Some of those steps will involve changing the accessibility settings in the setting's app. The user will be able to choose from these options. We have TalkBack, Captions, Magnification, increased font size, and more. I want to point out one item in particular, TalkBack service. Blind and low vision users can turn on the TalkBack service. It allows them to navigate around the device with spoken feedback as they interact with each UI element on the screen. There are slightly different gestures for example to select, or to focus on an item. If it's the first time you turn it on, there will be a tutorial that you can step through. When the user navigates to these elements TalkBack service will read aloud the context description provided. Every UI component that doesn't have any visible text has a content description. Using TalkBack or another accessibility tool from the checklist, open the Sunshine app, find and fix at least one accessibility issue in the app. Then please share what you did in the class discussion forum. Thanks for your answer. If you tried TalkBack on the Sunshine app, you'll notice that one easy fix to make our app more accessible, is to add content descriptions to our image views. Because there's no spoken text when a user taps on it. In the forecast adapter, after we read the weather forecast from the cursor we also set it as a content description on the icon. Similarly, in the detail fragment, once we get the weather forecast, we set that as the content description on the icon. Now clicking on the image, speaks the weather description out loud. Knowing the standard widget library is nice, but as someone who was once accused as not so much recreating the wheel, as hand machining my own nuts and bolts, I know there are times when nothing in the tool chest will quite do the job. That's when it's time to dive in and build your own custom view from scratch. Now we're not going to be including any custom views within Sunshine, but we can still take a look at how you would build one. We'll start by creating a new class for our view. Let's call it My View. If you're building something from scratch, rather than modifying an existing view, it should descend from either view itself, or from surface view. View offers a lightweight, canvas-based approach while surface view is designed specifically to support UI elements that require rapid redraws and/or 3D graphics, using something like Open GL. It's perfect for views that display video or games. Now the existing widget library is entirely view-based. So let's take that approach. The base view class draws an empty, borderless, 100 x 100 pixel box. To change that, we override the onMeasure handler, which allows us to indicate the view size. We'll also override onDraw, in order to draw our own custom view content. Now if it turns out that your view should always be an empty 100 pixel box then you're in luck. Otherwise we need to do some work. So let's start by setting our view's size. onMeasure is called when your view's parent is laying out its children. As you know, when you add a view to a layout, you can specify a specific height or width, but in most cases you'll want to either match parent or wrap the content. When a view's onMeasure is called by its parent layout, it asks how much space will you use? And passes in how much space is available and whether the view will be given exactly that much space, or most of that much space using these parameters. You can decode those parameters like this. And that'll allow you to obtain the size and the mode for your height and width specifications. In this example we're demonstrating just for the height parameter, but it works the same for width. We can then use the decoded mode parameter to find out what size we should set our view to. If the returned mode is exactly, the view will be placed into an area of exactly that size. You'll be passed that value if the layout has specified a specific size or if the view has been asked to fill the parent. In either case, it's best practice to simply return the value passed in unless that value is below your your view's minimum size, in which case you can return the minimum value and rely on the parent layout to crop or scroll as necessary. Another alternative is AT_MOST. This indicates that your view can define its own size, up to the size given. This is typically the case for views set to wrap content, where the view should be as wide as it needs to be to display its content, but no wider than that. And of course, all of that's provided that it still fits within the parent container as indicated by the size parameter. And we've just finished calculating all of that for the height parameter and you'd need to do exactly the same thing again for width. Once you've done that and determined the size of your control, you have to call the setMeasuredDimension method. Here you pass in your width and height values. If you don't call these setMeasureDimension method, your app will crash as soon as your view is laid out. Now let's take this opportunity to go ahead and create our own custom view. We don't need one in particular for Sunshine, so you can go ahead and choose anything. Personally, I'm a fan of Compass Control, so that's what I've been building. You'll need to include three Constructors to support your view being created in code through a resource or through inflation, then simply override the onMeasure method and set your dimensions. Click here when you're done, and, you're ready to get started drawing the contents of your view. Excellent. Now let's get started putting some actual content into our custom view. Now it's time to finish creating our new view by drawing its contents. And we do that within our custom view's onDraw method. Now the Android canvas is pretty standard, as far as canvas APIs go. Used as a painter's algorithm, meaning that each new thing you paint will cover anything beneath it. The canvas and paint classes. Up for a variety of brushes and help us to draw and fill lines, boxes, circles, and text with colors, patterns, gradients, and images. As well as offering the ability to move, rotate, and scale the campus while you draw. And I could spend a lot of time here detailing exactly how to use each of these tools, but there's nothing unique to Android and it's covered really well on the documentation link below. It is possible though to create pretty advanced UIs this way. For example if we start by drawing a circle and then add a second circle, and then you just need to finish drawing the rest of the compass. Here's an example I prepared earlier. The specifics of what you draw are different for every view, but one thing that is consistent is the resource constraint device you're drawing on. And that the onDraw method will be called every time the screen is refreshed. Potentially many times a second. That means any object created here within your onDraw method, including things like paint objects will be created and destroyed with alarming frequency. Object creation and destruction can be expensive on Android, potentially affecting the smoothness of your UI when garbage collection is initiated. The solution? Move the scope of any object used within the onDraw loop. Into the class scope. Go ahead and override the onDraw method within your new view, and draw the new control. In fact, why not take this opportunity to create a custom control that can display the wind speed, and direction fused within sunshine. Once you're done, you can add it to your layout, using its full package name and class name in your XML, like this. Run it, and then post a screenshot of your new view into the forum. Thanks. Now take the opportunity to browse the forum and see what other students have managed to create. So you've got a pretty sweet looking control, but what about users who can't see the shiny hotness? Accessibility is a key consideration when building apps and particularly when you're creating new views. You can start by adding a content description, as you would for every other view in your layout, to ensure that they are all accessible. But what about views like our wind speed and direction gauge where the content isn't static? Knowing you're looking at a wind gauge isn't very useful if you don't know what the speed and direction it's displaying are. Well, there are couple of options here. For generic views which don't control their own values, this simplest alternative is to set the content description within your app at runtime. An even more robust solution is to send an accessibility event from within your view. Whenever the visual content has been modified. Then override the dispatch populate accessibility event, and then the current control's visual value, the accessibility event. Go ahead and add accessibility handlers to your view, and then click here when you're done. Perfect. Now our views look good, and are accessible to everyone. The final step in your custom view creation is adding interactivity. You can listen for user input events including key presses, trackball movement, and most importantly, screen touch events. All by overriding the corresponding event handlers. Android supports tracking of up to 11 individual contact points in what we like to call, jazzhands mode which enables you to complete complex, multi-finger interaction models. Now, there's really no interaction required for a wind gauge, but you can find out more about handling input events by checking the motion event docs or the developer guide describing how to create your own, fully interactive custom views, both from the instruction notes below. Now, be careful not to let this new found power go to your head. By definition, your users will have never encountered your brand spanking new control. So learning how to use it is going to add friction to the use of your app. At the very least, it should behave consistently with the rest of the system and you should avoid creating your own versions of system controls. If it looks kind of like a button and works kind of like a button, you should probably just go ahead and use a button. But I think this non sequitur has gone on long enough. In this lesson, we learned how to create rich, responsive user interfaces that work across a variety of different hardware types and screen sizes. We also learned more details on the Android layout managers and screen widgets, and even how to create our own views from scratch. Join us for lesson six where we take our foreground-only app and discover how to make it update and trigger notifications from the background. All without draining your battery. But first, join me back at Google for another story from the Android history books. Andy Rubin, head of Google's Android team until 2013 famously defined Android's openness with this Tweet, offering the instructions for downloading and building the Android source code. As app developers, it's handy to be able to peak behind the curtains and see how the framework actually works. And it's an excellent way to find answers to tricky Stack Overflow questions. But the Android Open Source Project, or AOSP as its commonly known, is much more than that. The source code is available under the Apache 2 license, so anyone can take it and do anything they want with it, including modifying it and redistributing it. And they have. Android has always had a passionate community of modders, from Steve Kondik and the Cyanogen community to XDA and many others who have been distributing modified images of Android for phone owners brave enough to try them. Even big companies like Amazon have taken the Android source code and modified it for use in their own line of products. That openness extends to the apps themselves. The AOSP includes key mobile apps like the dialer, app launcher, calendar, and email. And Google offers its own versions of each as well. In the early days those native apps were tightly bound to the framework and could only get updated along with the platform. Which admittedly in the early days seemed like every few weeks. But as the time between platform releases grew, so did the efforts to unbundle those apps, allowing them to be updated through Google Play. That was great news for users, but it had an even better side effect for us developers. Because apps like Gmail and Maps depend on a number of proprietary Google APIs, Google released Google Play Services. Also code named after food to support the Google apps, while also giving us developers Google specific APIs, like Maps, Wallet, Drive, and YouTube. So now we get the latest and greatest Google specific APIs every six weeks or so. And rather than being tied to a specific platform, they're available on every device, back to Gingerbread. Oh, and of course every native app is also entirely replaceable. So you can publish apps to replace any of the apps shipped with the device. And we can build our own SMS apps, homescreens or maps apps, publish it on Play and give users the choice to make it their default. When Android was first announced, Andy Rubin described the AOSP as, all the software to run a mobile phone but without the proprietary obstacles that have hindered mobile innovation. Today, Android runs on more than just mobiles, but the core of its purpose remains the same. A platform and ecosystem that allows models, carriers, OEMs and app developers to innovate and compete. So armed with an open, evolving platform enriched by a growing set of Google API's and the ability to create great apps that let users customize every aspect of their user experience, you can use other people's work to help define the computing platform of the future. And that's my definition of open. Now that we've finished building the UI for our app, it's time to think about how it should operate when it's not in the foreground. One of the most powerful features of Android, is the ability for any app to run in the background. But with great power comes great responsibility. So you need to be very conscious of how it's consuming resources. In this lesson, you'll learn more about how the Android framework manages background apps. And you'll be introduced to the service class to help make that happen. You'll also learn techniques for efficient data transfers using sync adapters and Google Cloud messaging. And be introduced to the notification framework to send messages to your users when your app isn't in the foreground. Remember back in lesson two when Katherine used an AsyncTask hooked up to a refresh button to update our data? Rato talked about how that was a bad idea because the AsyncTask is not tied to the activity life cycle. The virtual machine will hold on to the activity object as long as the AsyncTask is running, even after Android has called onDestroy for the activity and expect it to be discarded. If you rotate your phone, the behavior is to destroy your activity and instantiate a new one. The naive AsyncTask implementation now has two threads trying to perform the same update, and so forth. The point is, it's not the best pattern for a potentially very long background operation, such as fetching from web services. If you leave the app, the AsyncTask will continue to run for as long as your process is kept alive, but will run at a low priority, and your process will be the first thing to be killed if the device needs more resources. And there's a bigger problem. Your app has to be visible and running in the foreground to instantiate the task in the first place. Because we started a task, to update the weather when we started the app, this can have undesirable behavior if the weather changes rapidly. So now we're going to learn the right way to perform updates. We'll want to automate the process while the app is in the foreground. But even more importantly, we want the app to get regular updates in the background with minimal battery drain. That will be especially important later in this lesson when we introduce weather notifications. Back in lesson four we learned that the Android runtime will kill apps with no visible activities in order to free resources needed by the foreground app. But what if your app has tasks that need to continue when the activity isn't visible? Things like downloading files, uploading photos, or playing music. Well, there's an application component for that. Services. We've already introduced activities, content providers, broadcast receivers and intents. Services are the final piece to the Android app component puzzle. You start services much like you do activities, by passing in an intent to a startService call. And you can stop services the same way. By calling stopService and passing in the name of the service you want to stop. Unlike activities, services have no user interface and they run at a higher priority than background activities. This means that an app with a running service, is less likely to be killed by the runtime in order to free resources for the foreground activities. In fact, by default, the system will attempt to restart services that are terminated before they are stopped from within the app. This is reflected in this simplified lifecycle. Compared to activities, services are designed to execute longer running tasks that shouldn't be interrupted. Typically, you'll only need to override the onStartCommad handler, which is where you begin the background task you wish to execute. But notice that there are no handlers for monitoring changes in state, to reflect the app moving to the background. This is because the running service itself, sends a signal to the framework, that the containing app should be considered higher priority than other apps in the background that don't have running services. In some cases your service may performing a task, that while not having UI, can't be interrupted without interfering with the user experience. For example, playing music or helping with in car navigation. In these cases you can indicate that your server should be considered to be running in the foreground by calling startForeground. You'll notice that this call takes in a notification. This will be displayed, and can't be dismissed until the service has stopped or you call stopForeground. You'll learn more about notifications a little later, with Dan. But for now, note that a foreground service runs at the same priority as a foreground activity. Making it nearly impossible for the runtime to kill in order to free resources. Now you may be thinking to yourself, I could save a lot of trouble dealing with lifecycles, just by creating long running or even foreground services. Well, I grew up along the coast in Australia, so I learned young that swimming against the current is exhausting and ultimately futile. In this case, that means making it more difficult for the system to manage resources, ultimately leading to a worse user experience. Swim with the current. Use foreground services only when and for as long as absolutely necessary. And stop all service as as quickly as possible. It's also important to note that like activities and receivers, services run on the main thread. So you'll need to use a background thread or think task to execute the long running tasks you wish to do within your service. To make life easier, you can use the intent service class. Which implements the most common best practice pattern, for using intents, which are executed within a service. It creates a queue of incoming intents, passed in when start service is called. These are then processed sequentially on a background thread, within the onHandleIntent handler, within your intent service implementation. When the queue is empty, the service self terminates until a new intent is received, and the process begins again, Services are a powerful tool and it's important to understand how you can use them, but in practice there's often a framework alternative to rolling your own service implementation. Whether that be an intent service for executing background tasks or the sync adapter which you'll learn about later in this lesson. Perfect for performing background data synchronization. So now that we understand how services work, let's review how Android determines your app's priority. App priority is divided into three general buckets. Critical, high, and low. Within each bucket the apps are prioritized in a queue, with the app that's been at the lowest priority for the longest the first to be executed. Critical apps are those that are active. They're in the foreground, interacting with users. That includes activities in the foreground, and apps running foreground services. High priority apps, include any visible activities, and any application with a running service. While less impactful than killing a foreground app, destroying visible activities or cancelling services running tasks like background updates, is still going to be noticeable to users. So, the system will only kill them in an extreme resource crunch. Apps in the background though, they're the red shirted ensigns of the app priority landing party. Any background app will be killed as needed in a last seen, first killed order, in order to help support the higher priority apps. I like to think of this as the three laws of Android resource management. Law one, Android will keep all apps that interact with the user running smoothly. Android will keep all apps with visible activities or running services running, unless doing so violates the first law. And third, Android will keep all apps in the background running, unless this violates the first or second laws. So with all of that in mind, consider these four apps. What do you think is the priority order of each of these apps, according to the system? That's right. Maps isn't visible or running any services, so it's the most likely to be killed. Gmail is running a service, but it's not interacting directly with the user. While Google Music and the camera app are. Of those two, the Music app must have been in the foreground for longer than the camera. So it's got a slightly lower priority, though neither are in any danger of being killed. So, how would we use a service to implement our application? Fortunately, we've already done most of the work. We have a content provider with a content notifier that will notify our content observers. Our FetchWeatherTask already runs completely independently of our UI Good on us. Now we can make use of that Intent Service that Rato mentioned earlier. With just a few small changes, we can get our code working with an Intent Service, instead of with our FetchWeatherTask. To start, let's create a new package for our service. Then we'll add a new Java class in that package that extends Intents Service. We hit Ctrl+I to once again, add the required abstract method. And Ctrl+O in order to add the constructor. Since the service is an Android component, you guessed it, it needs to be in the manifest. Okay, let's do this. Let's finish implementing the SunshineService and call it from ForecastFragment. You can start a service using an Intent with the StartService method. It will help to remember how to use explicit intents. All right. You're done. Let's talk about how I solved this one. Let's take a look at the sunshine service you just wrote. To begin with, it's useful to have some constants, a log tag, so we can actually see how it's functioning. And most importantly, this location query extra. We use this location query extra to pass the location query. Into our Intents service. In onHandleIntent, we actually put the code that we had in do in background in our fetch weather task. However, as you can see the only parameter we get is an intent. So we pull the location query out of a stringExtra. Using the location query extra string. We can copy the rest of the code from fetch weather task here because intent service also creates a helper thread for us to run code on, similar to what a string task does. Note that we also fix up all of the code that refers to m context. As a service, also has its own context. The final thing we do, is call our service from update weather, with in forecast fragment. We simply put an extra for the location query, instead of using it as a parameter. And then start the service. Then we can delete the fetch weather task, and its associated test. So now we have a simple service. Wasn't that easy? But it still doesn't wake itself up. Fortunately, there's a system service for that. This is a good opportunity to introduce the alarm manager. The alarm manager allows you to tell the system that you want it to wake a component of your application up after a period of time and do some processing in the background. You can even have it wake up your application periodically, but what do we wake up in the background? That would be an Android component we haven't seen before, called a broadcast receiver. A broadcast receiver is a special class that is used to receive intent broadcasts, often from other applications. Typically, a broadcast receiver will register an intent filter for these broadcasts. It's also one way the application will listen in on alarms. Alarms take advantage of a new kind of intent, called a PendingIntent. A PendingIntent is a special kind of intent that is handed from one application to another. The big difference between a PendingIntent and a regular intent is that a PendingIntent gives permission for the app using it to send data with the same permissions and application identity as the app that created it. In Android this allows the system process to call your application back in a specific asynchronous way without compromising the Android security model. In alarms a pending intent is used by the alarm manager to talk to the broadcast receiver we create. Let's add some alarm stuff. First, I'm going to add a BroadcastReceiver as a static inner class of SunshineService. Since this is an Android component, I'll register this broadcast receiver in the manifest. Note the way a static inner class is notated. Okay. I've given you the bones of a broadcast receiver that can handle an alarm. But now it's your turn. You can create a PendingIntent from an explicit intent to have the alarm manager activate your broadcast receiver. I recommend setting the alarm to something absurdly short, like five seconds, so you can easily test that it's working. All right, you're done. Let's look at the solution. As I said in the question, we're going to be working inside a forecast fragment in the updateWeather function. First, we're going to need to create a standard intent for our alarm receiver. We then add our location query as an extra. We then wrap that in a PendingIntent. A pending intent is a special kind of object that describes an intent. This allows other applications to implement the feature of the original intent that's used to create the PendingIntent. We're only going to use this PendingIntent once, so I set Flag One Shot. Then, we get the alarm service and set the alarm to trigger five seconds from now. But we still need for our alarm to do something. Back in the Broadcast Receiver, we need to send the standard intent to start our service, and that's it. Let's try running the app. All right, so now we've got the Alarm Manager getting in the way of our service. We hit refresh. It'll take us about five more seconds before we actually see the data now. And there we have it - a very, very simple alarm. Even with this updating in the background potentially, and using a service, we could still be more efficient in our use of phone resources. Rato can tell us more about that. Typically when we talk about data transfer efficiency, we're talking about limiting the amount of data being transferred. That reduces the bandwidth and the cost and is generally a pretty good idea. But on mobile there's an extra factor. As you can see, it turns out that the cell radio is one of the biggest battery drainers on the device. So making your data transfers more efficient will also result in improved battery life. Now at a basic level, being more efficient means spending less time transferring less data, reducing your payloads, and updating less often can take you some of the way there. But then what? Can timing make a difference? It turns out that it can, and it's a situation I like to think of as the cookie Droid conundrum. Do we perform fewer downloads with larger payloads? Or do we perform lots of small transfers just in time for when we need them? One big cookie or lots of little cookies? So, what do you think? Should we have a smaller number of large downloads illustrated by this big cookie? Or a large number of small downloads, as illustrated by lots of little cookies? Now at first glance, reducing the payload of each transfer, and only transmitting data when it's required seems like a sound approach. You're reducing the amount of data being transferred, so that's less data on the network. That's less superfluous work being done storing processing data on the device. It's basically a case of putting off any work until you actually know you need to do it. But it turns out that this approach has it's drawbacks, compared to the big cookie model of doing all that work up front. So, overall, this is a better solution. But let's take a closer look at the big cookie model. And to do that, we really need to understand the underlying cell radio state machine. The cell radio in your device operates roughly like this. >From an initial idle state, it takes a couple of seconds to turn on, until it can start transmitting. That kind of latency makes for a sucky web browsing experience. So rather than going back to idle, state machine stays on at full power for a certain amount of time, typically around five to ten seconds, before dropping to an intermediate low power mode that uses less battery than full power, and has lower latency to return to full power than the standby mode. If a new transfer is initiated, the radio will be promoted back to full power mode. And if nothing happens for another period of time, typically around 30 seconds to a minute, it'll drop back to standby. The exact latency in tail times varies between carriers, and even within carriers between states and countries, as they try to balance low latency with longer battery life based on factors like cell congestion, and typical or prevailing network conditions. So if the exact timings vary, how do we optimize our transfer frequency? Ultimately, it doesn't matter what the specific timings are. You just need to understand that the network is going to attempt to balance low latency with high battery life. For us, when it comes to planning out data transfers, we'd really like to be somewhere around here. Now if we return briefly to the cell radio state machine, we know that every time we perform a data transfer, the radio will stay active for at least another five seconds of full tail time, and anywhere from 30 seconds to a minute at low power before it finally returns to standby. That means every time you initiate a transfer, you're powering the cell radio up for at least 20 seconds. So let's take a look at how that affects an app, using the little cookie approach. An app like this can drain the battery without even having to transfer much data. Each of these small peaks is an app pinging its analytics back to the server. In this case, every 15 seconds. These larger peaks represent intermittent data transfers based on user interaction. For example, they may be viewing a restaurant listing or looking at tomorrow's weather forecast. Beneath it, we've graphed how this affects the radio state. The blue shows active data transfers. The red, the radio in full power. And yellow, showing low power mode. The gaps in between, if there were any, indicate when the radio was idle. So while this app is running, what is the percentage of time that the cell radio is able to go back to its idle state? That's right, whenever this app is running, it's keeping the cell radio powered on continuously. In fact, the radio updates alone, are enough to prevent the radio from ever returning to idle. In this app, we see an example, of a defragmented network traffic that uses the big cookie model. All the repeating transfers have been bundled together, and all the intermittent transfers have been largely replaced with aggressive prefetching. Obviously, you usually can't entirely predict what data users might need. Nor can you ignore either client or service site changes that need to be synchronized. You can aim to minimize the number of radio state transitions through a combination of aggressive prefetching in addition to batching and queueing any transfers that aren't time critical and bundling these with user initiated time critical transfers, or those initiated from the server. If we compare the impact on the radio of the big cookie model compared to the previous on demand approach, you can see it's now idle nearly two thirds of the time. Even the active radio percentage has significantly dropped, thanks to improved download efficiency as a result of transmitting more data in one shot. The most important thing you have to remember, is that every time you transfer data, no matter how small, the radio could stay powered up for nearly half a minute. So every decision you make, should be based on minimizing the number of times that this happens. But of course there's a balance here. You want to download all the data a user is likely to need for the current section, in a single burst, over a single connection at full capacity. But of course, you don't just want to pull down everything wasting battery power and bandwidth downloading data that's never going to be used. Now I could go on for hours on this topic, but Dan's getting impatient, and you can learn the details on how to implement each of these best practices, including pre-fetching, batching, and bundling, burying you rupdate frequency, and minimizing your payloads, by watching the series of Dev Lite videos or reading the developer guides linked to in the instructor notes below. Now before I leave it to Dan to show you how to implement a sync adapter for Sunshine that takes advantage of a lot of the best practices I just described, let's consider what the best practice would be if you were building something like a news reader app. How much data should you download when the app is first started? Just the front page of headlines? All the stories and images linked to from that front page? Every story available, but none of the images? Or every story and every image currently available? Pulling down all the data will reduce latency and maximize the battery efficiency. But it's unlikely the user is going to read every article, so you'd just be wasting a lot of bandwidth. Downloading all the articles without pictures, actually doesn't improve our efficiency if you're just downloading the front page, because you'll still need to activate the radio to download those pictures whenever an article is selected. The right answer is to get the headlines and the articles linked to from that front page, because they're the most likely to be read as the user starts browsing through the app. You can then incrementally download more articles each time the user moves into an area you haven't prefetched for yet. There's a lot to learn with making background transactions efficient, but the good news is that Android gives you the SyncManager framework that implements many of these best practices. You utilize that framework by implementing a SyncAdapter. The framework, originally introduced in Android 2.0 Eclair or Android API level 5, allows Android applications to leverage the same basic framework that Google apps use for efficient synchronization. Ultimately, it's a centralized place to put all of the device data transfers in one place. So that they all be scheduled intelligently by the OS. In other words, that's one big cookie! Android SyncManager handles synchronization requests using SyncAdapters. The SyncManager batches and time shifts these requests, when possible, to allow your data transfers to be scheduled with transfers from other apps, all working towards the goal of reducing the number of times the system has to switch on the radio. If your device has less memory, it will schedule fewer simultaneous synchs. The SyncManager also takes care of things like checking for network connectivity before initiating transfers and retrying downloads when connectivity is dropped. The synchronization framework works with content providers for two way synchronization and leverages the Android Account Manager to provide synchronization services that are tied to accounts. Our application will do neither of these things, but we'll still have to deal with some of the complexity of these features. This can make SyncAdapter seem daunting at first. What does the SyncManager do to help you fetch data from the network? Does it schedule your network jobs with other apps, implement a syncrhonization protocol, store account information, or has logic to retry your request? Select all of these that match. The SyncManager does schedule your SyncAdapter jobs but they don't have anything to do with what goes over the wire. There's no standard synchronization protocol. And while they are tied to AccountManager, they have nothing to do with storing account information. However, they will auto retry requests, if network conditions are spotty. All right, here's a big one. Finish the SynchAdapter, making it fetch the weather and store it in the database. Alter the updateWeather function within the ForecastFragment to start a sync with the SyncAdapter. Some hints here. Pull the code from on handle intent into our SyncAdapter. On handle intent is inside of our Sunshine service. The good news is that abstract threaded sync adapter provides a background thread to run the server fetch on, just like intent service does. Also, just fetch the location query from our utility class. Eventually, we want to run syncs like this without any involvement of the user. Finally, make the sync adaptor run when we call Update Weather. All right, you're done. Let's look at the solution. Okay, we'll begin by adding a log tag in to our AbstractThreadedSyncAdapter. Since this stuff runs in the background, it's helpful to have some logging. Since we ultimately want the syncAdapter to run in an unattended mode, we pull the location query from our Utility class, and then we paste in the code from our existing sunshine service. We'll have to patch a few things up. We'll have to call get contexts to get the current context. For example, we copy over the getWeatherDataFromJson function as well as the addLocation function. Finally we fix updateWeather to use our syncAdapter. All right, here's a big one. Finish the SynchAdapter, making it fetch the weather and store it in the database. Alter the updateWeather function within the ForecastFragment to start a sync with the SyncAdapter. Some hints here. Pull the code from on handle intent into our SyncAdapter. On handle intent is inside of our Sunshine service. The good news is that abstract threaded sync adapter provides a background thread to run the server fetch on, just like intent service does. Also, just fetch the location query from our utility class. Eventually, we want to run syncs like this without any involvement of the user. Finally, make the sync adaptor run when we call Update Weather. All right, you're done. Let's look at the solution. Okay, we'll begin by adding a log tag in to our AbstractThreadedSyncAdapter. Since this stuff runs in the background, it's helpful to have some logging. Since we ultimately want the syncAdapter to run in an unattended mode, we pull the location query from our Utility class, and then we paste in the code from our existing sunshine service. We'll have to patch a few things up. We'll have to call get contexts to get the current context. For example, we copy over the getWeatherDataFromJson function as well as the addLocation function. Finally we fix updateWeather to use our syncAdapter. You indeed must have a content provider marked as syncable, as well as enable automatic sync for the sync adapter. You don't need to schedule an immediate sync, although it's nice for users, as we did. And, this is a minor note, you don't set the interval in milliseconds, but instead set it in seconds. You indeed must have a content provider marked as syncable, as well as enable automatic sync for the sync adapter. You don't need to schedule an immediate sync, although it's nice for users, as we did. And, this is a minor note, you don't set the interval in milliseconds, but instead set it in seconds. Inexact repeating alarms. Infinitely better than exact repeating alarms, but still far from ideal. The problem with any kind of repeating alarm is that it's still polling your server to check for updates. So the more frequently you poll, the fresher the data you can display but the higher the cost in battery life. You can pull as frequently to conserve battery but that just means your content will be stale for longer. You could just let the user decide the update frequency themselves, but then you lose the magic. If only there was a better way. Is such a thing possible? Yes it is. Google cloud messaging lets your server notify your app directly when there's data ready to be downloaded. Or it can even include the new data in the message payload itself. Using Google Cloud Messaging, you can send messages from your server to any installed instance of your app via the Google Cloud. As a result, you can stop polling, which will immediately improve battery life and also improve the freshness of your app. And instead, rely on your server notifying clients when there's data to sync. These messages can be simple tickles, that trigger a sync adapter by notifying your app that there is new data or need to download. Or you can include the new data within the message payload. In the sunshine example, we're using someone else's server. But even then, it may make sense to create your own middle tier that pulls the source and notifies your installed app instances when it notices a change. Now we're not going to set up a server in this lesson, but you can see the full details for using Google cloud messaging from the developer guide linked to instructor nets. All right, you're done. There were a lot of new things that time. But, after all, you're becoming a seasoned Android programmer by now. As I mentioned before, we're going to use NotificationCompat.Builder to build our notification. It's easy to build a nice looking notification that has our icon representing the weather forecast, the title for our app. And our content text, the forecast with highs and lows. We're going to use another class from the support library, to create a task stack builder for our pending intent. This is a simple case of task stack builder, because all we have is a single item on our stack. We just add the next intent and use it to build out pending intent that we pass into the notification manager. Finally we call the notification manager with the built intent from our builder, with a notify function. One of the great things about notification manager is it can be used from any thread even though it is displaying UI. All right, you're done. There were a lot of new things that time. But, after all, you're becoming a seasoned Android programmer by now. As I mentioned before, we're going to use NotificationCompat.Builder to build our notification. It's easy to build a nice looking notification that has our icon representing the weather forecast, the title for our app. And our content text, the forecast with highs and lows. We're going to use another class from the support library, to create a task stack builder for our pending intent. This is a simple case of task stack builder, because all we have is a single item on our stack. We just add the next intent and use it to build out pending intent that we pass into the notification manager. Finally we call the notification manager with the built intent from our builder, with a notify function. One of the great things about notification manager is it can be used from any thread even though it is displaying UI. If an app updates in the background, but no one opens it to find out, did it really happen? Notification started off as a convenient way to notify users of background updates. But they've grown to become a powerful standardized shortcut to interact directly with apps in a lightweight way. Starting in Jelly Bean it was possible to expand notifications, making them larger and containing more information. That also introduced the concept of the rich notification, which is able to include actions like these, to be performed on the data included within the notification. This speeds up interaction and helps users streamline their notification triage experience. As a standardized UI designed specifically for conveying timely information in limited screen space. Notifications were the obvious mechanism to use, when Android expanded into wearables with Android Wear. Suddenly those rich notifications that you designed for phones and tablets make your app wearable compatible, for free. Don't overdo it though, there's a fine line between useful and spammy. And it's only a couple of clicks for a user to disable your app's notifications permanently. So check out the instruction that's below for links to the design guide in creating good notifications. All right. We're just going to add a few more details to the app. We're going to implement a weather notification preference We'll do this by adding a new preference to the app settings to turn off notifications. And then, use that preference to turn off the notification. Hint: you're going to want to use a CheckBoxPreference. Alright, you're done. Let's start by adding all of the strings we're going to need for our new preference. Key, label, and some things like true, false, and default. Then we'll additional preference into pref general xnl, a check box preference that uses those strings we just defined. Let's go over to our sync adaptor. In the notify function, we add the code to fetch the preference and make use of it. And there we have it. Now we won't display notifications if the user doesn't want us to, which is a great thing for an app to do. One of the things you may have noticed, is that our app database continues to grow forever, eventually filling up the device. This is a great way to get our app uninstalled. So let's fix this. Add code to delete weather data that is more than one day old. Use the Calendar function to do data arithmetic. All right, you're done. Let's look at the solution. Inside of our sync adapter, right after doing our bulk insert, we can just call the content provider with a delete, with the date as our current JulianStartDay minus 1. This is one of the advantages of using Julian days. Done. All of you detail-oriented people probably noticed that we never actually used the coordinates we get from the server for location, relying instead on both the maps API, and the weather API to do the same thing with location queries. Unfortunately, they don't always agree. Implement maps using the coordinates stored in the location table. You'll want to start by moving the menu code from MainActivity to WeatherFragment. All right. And here's the solution. To start off, let's look at our forecast fragment query. Since it's a join between two tables, it's really easy for us to add additional parameters to our query. Now we make sure we keep the column indices consistent. Now we've grabbed the latitude and longitude at the same time we're grabbing our weather entries. The next thing to do is to move the function open preferred location in map over to forecast fragment. Instead of using shared preferences to get these values, we can actually get the cursor from the forecast adapter. We can get our cursor moved to a reasonable position, and then build our new string which is just latitude colon longitude. We'll leave our comment where it was. Finally, we just have to fix up a few things in the code and that's it. Well, at least for the code. We still need to do some work in the XML. Let's move this R.ID.action map now over to forecast fragment inside of it on options item selected. And now we've got to do some XML work. Let's look at our main menu. We'll just pull this action map item out, and we'll place it right into forecast fragment. All right. One more thing to do while we're here. One of the things Raito talked about was wanting to get rid of the refresh menu item. So, let's just comment it out. When we remove that action refresh item, we should probably comment it out from our source code too. After all, you never know when you'll want to use that for debugging. So, there we have it, our final app. No longer having a refresh button. With new exciting setting to turn off and on weather notifications. Details are taken care of. I hope you've enjoyed building Sunshine. There's still lots of things left to do in Sunshine. For example, we could also add a lot more intelligent things to its user interface. And of course, we could make it a lot smarter about syncing data. And I hope the practices you've learned building Sunshine will help you in all of your future applications Congratulations. You now know how to build an app that runs beautifuly in the foreground, and efficiently in the background. In this lesson, you learned how to use services and SyncAdapters, as well as creating rich notifications, all ways to provide a great user experience even when your app isn't visible. Join me now for the final story time, as I take you into a possible future for Android. I was 12 years old when I got my first modem, a 1200 baud ACE compatible, and starting getting online. And not the internet online, local BBSs. At around the same time, yuppies were sporting the first brick-sized mobile phones as the first GSM network started rolling out. Fast forward less than 17 years to 2007, and the iPhone launches, followed less than a year by Android. And almost overnight, we've come to expect the world's information in the palm of our hands. Just six years after the first Android phone launched, it's powering everything from phones, to tablets, watches, TVs and cars. So where do we go next? The most obvious answer is enabling the same handheld cloud connecting computing platform to the next 5 billion people. As hardware becomes cheaper and more powerful, more of the world's population will be able to get internet-connected computers. And the smartphone is going to be what makes it possible To facilitate this, we're seeing new approaches to getting online, mesh networks, white spaces, or even Google's Project Loon. We'll hopefully soon see ubiquitous world-wide internet connectivity become a reality. At the same time, smartphones will start to disappear. In the same way that we don't think of computers as computers once they become part of our dishwashers, cars, or TVs, we'll stop thinking of mobiles as such when they disappear into our watches and white goods. We'll come to expect that anything that can be improved through the incorporation of a wireless internet connection will simply have one. For that to happen, we need to find more creative ways to interact with computers than using mice, keyboards, and touch screens. I can already pick up my phone or lift my wrist, address Google, and perform searches, send texts or email, set alarms, or take notes without having to touch a screen or keyboard. Screens themselves have become so sharp that their pixel densities aren't perceptible to the human eye. And the team at Google X are building contact lenses capable of measuring blood sugar levels. Speaking of senses, not only can I control my phone by putting it either face up or face down, it has a battery of sensors similar to an aegis class warship. Light meters, temperature gauges, barometers, gyroscopes, all of which can be used to replace text entry or automate processes. Wearables, cars, and thermostats introduce even more possibilities of sensors. Connect all of that to the cloud, and the possibilities are endless. Future of Android isn't a more powerful phone operating system. It is the brains behind invisible, ubiquitous, cloud connected computing. So the skills we learn today to build cool apps are the same skills we'll use tomorrow to control everything around us. We've taken the first step into that future. I can't wait to see what you do next. (noise maker) (surprised scream) Content providers! Congratulations, everyone, you've finished building the Sunshine App. But there's always room for more sunshine. There is, Dan, but now it's time for the students to go build their final project. And you can get a lot of the resources you need to build really great mobile apps at the Android developer site. And stay tuned for more from us and Udacity. For now, I think it's time to celebrate with some cake. Woohoo! Lemon tarts! Lava cake! (music)