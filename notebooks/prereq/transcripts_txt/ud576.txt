Before you take the Grand Central red pill, there's something you must know. Something about closures. There are a few things about closures that we skipped in the Swift syntax lesson, because they were not relevant at that point. Now we need them. So take your red pill, and by the end of this lesson you will have total control over closures. The most important properties of closures that we've missed so far are they're first-class citizens of the language, and they capture their lexical environmental. Sound like Greek to you? Have no worries, little grasshopper. These are just fancy names for very simple concepts. Let's take a look at this first-class thing. So what does it mean to be a first-class type? It means that you can use closures just like any other type, such as ints, floats, strings, etc. You may assign them to variables and constants. You may put them inside arrays, or dictionaries, or actually any collection. You can return them from functions and closures. And you can receive them as parameters of another function or closure. This last part sure sounds weird, so let's get started with the easy ones. Grab a playground, and let's play. We'll start with the playground from scratch and go through the code. However you can also download a rich playground with more information for your reference. You may find the link in the instructor notes. So what does it mean for a closure to be a first class citizen of the language? It means you can use closures just like any other type, such as ants, floats, strings. Whatever. You can assign them to variables or constants. Put them inside arrays or dictionaries. Return them, as the result of a function or closure. And even receive them as parameters of another function or closure. That last part seems a little bit weird so let's start with the most obvious part. First of all, we're going to assign a closure to the Bar or a constant. Ok so here we are creating a closure using Syntax closure. And we're assigning that closure to a constant. So that's a little bit different, and And this closure to six. When integer returns another integer and within the body of it, it should be x by the way, it adds 42 to x. Okay so it's a pretty simple closure. And closures have types too. Look right here in this result sidebar. And you'll see that the type of this closure is Int arrow Int. It means it takes one integer and returns an integer. And we can call this closure just like we would call any function or any other closure. So, let's give it a try. So, the bottom line is we can use the closure that we saved into the constant F, in the normal way, using the regular syntax. However, try to call it passing the string as a parameter. This will cause an error and by now you should already know what's going on. It's not the type that the closure accepts, so it works exactly as functions, so far. Let's get rid of this, and now let's try something fancier, let's put a bunch of closures inside an array. Let's see if it's possible. So here we have an array called closures. With just one closure, inside and the type, is as you would expect, an array of int to int. So this defines what kind of closure we can put inside. Try this array. As long as the closure takes one int and returns an int, which would be able to put it in there. Let's add a few more. Okay, so here we have the final array with several closures in there. All these closures have one thing in common. They have the same type. They take an int and return an int. How does the compiler know that? Because of the first one. So this sets the type of closure that can go in there. The second one over here has the full closure syntax with type information. For the parameter and the return type, that's not really necessary, because the compiler has that information already. So the next one avoids the type information, and it works fine. The other one, the next one. Doesn't have the return, why? Because when a closure just has one statement, one line, the return is implicit. So, the compliant knows it should return x times x. And last but not least, we have this ultra simple version where we don't even provide a name for the parameter because in Swift, closures and functions can access their parameters or arguments. By the position so dollar zero means position zero. The first parameter times 42 and return that. Could we call those closures that are stored in the India rate. Yes, definitely yes. So let's give it a try. So right here, we're iterating through the array of closures and for each closure we call it passing 42. And here you can see the results. You can also see it this way. Ok. Now I've got an exercise for you. Try to create an array with two closures. One that takes two integers and returns the sum as another integer. And the other closure should take two floats and return the sum as a float. Would this compile? Think why. So will this code run? Don't cheat by pasting it into Playground. Think about it. Yes it will. When you assign a closure to a variable or a constant, you may use it as any regular function or closure. Actually creating a constant and binding it to a closure is exactly what the compiler does for you when it sees a funk statement. Would this code compile? Why? No, it will not. It will not compile it, because the type of the two closures is slightly different. Sum takes an integer and another integer, and returns another integer. While sumf takes two floats and returns a float. That's different enough for the compiler, so this code will not compile. Welcome back, and as before, you have a rich playground for future reference. Check it out, we will go through all the code right here. So far, it looks like a closure, and is a function with a few extra features and a slightly different syntax. Not so, little grasshopper. Functions and closures are exactly the same thing. They just have a different syntax. Therefore, all the extras that closures pack are also available to functions. Closures and functions are just like our alter egos for the same thing. Like Peter Parker and Spiderman. So the function enclosure that I'm going to show you right now are exactly equivalent. They don't just do the same thing. Check them out. They are the same thing. So we have first a function that takes an integer and returns an integer and it adds 42 to it. And then we have a closure that does exactly the same thing. They look equivalent, but actually they are more than just equivalent. They are exactly the same thing. Actually when the compiler finds a function declaration such as foo over here, it will take the following steps. First of all, create a closure that takes an integer and returns 42 + that integer. And then assign that closure to a constant called foo. Sounds familiar, yeah. That's exactly what you've done here for bar. So the bottom line is since functions and closures are the same thing, you should use whatever syntax makes more sense at a given time. It's up to you to choose which one you prefer at any given point. So if closures and functions are exactly the same thing we should be able to add functions to a collection, such as an array, as we did with the closures in the previous playground certainly. So lets give it a try. I'm going to show you a few functions and then we'll add them to an array and iterate through the array, and call the functions, just as we did before. So, here we have three functions that take an integer, and return an integer. Just like those that we've seen before. And we're going to add them to an array, and see if it works. And it certainly does work. Here we have the three functions with in the array. So could we add the bar closure over here to this array? Think about it. Yes. They have the same type and it doesn't matter if they were defined using the closure syntax or the functioned one. Let's add it. And now we can just call all those functions and closures that are inside stooges. So for, and again it works exactly as expected. And we can display it also as a line graph. So now I have a question for you. Could we add the function baz that is here, to this array? Think about it, or try it if you must, but you shouldn't need it by now. Which of these statements is true? A closure is a special type of function. A function is a special type of closure. Or functions and closures are the same thing. It's the last one. Functions and enclosures are exactly the same thing. Swift has two different syntaxes for the same concept. You may choose whichever is more practical at any given moment. We know by now that functions and closures are the same thing. But there's one last thing we need to know. It's very easy to understand and even seems very natural. But not all languages have this feature. When you add it to the first type nature of Swift functions and closures, it turns into super powerful tools. But before we get started, make sure to also download the Rich Playground for this lesson. You have the link in the instructor notes. Before we get started, let's take a look at a concept that will be very useful in our examples of variable capture. Actually, the fancy name for this is capture of lexical environment. Feel free to drop this in any casual conversation if you really want to look like a nerd. An alias is a simple way of calling something or someone that has a complex or funny name. For example, say you're a huge, professional wrestler and you want your name to scare the crap out of your opponent. Do you seriously think Terry Gene Bollea will do? Of course not. That's why he goes by his type alias, Hulk Hogan. Or you're just starting your career as a pop singer, but your parents bestowed upon you the aristocratic sounding name of Florian Cloud de Bounevialle Armstrong. It certainly sounds impressive, but your fans will have a hard time remembering it. Better go by the tape alias, Dido. In Swift, you can also give new names to existing types. And this is extremely useful when the original name is complex. Something like being able to call Kurt Douglas. Much better, don't you think so? Let's see a few examples. Let's start with something simple. Let's say I don't like having to call an integer an Int. Can we change that? Of course. We have the typealias statement, and it always follows the same template. It's typealias, new name equal old names. So, it would be typealias, new name Integer, old name Int. >From now on, I can use Integer instead of Int whenever I feel like. It's all the same to the compiler. Let's see an example. These two lines that we have here are exactly the same. Integer has become an alias for Int, and we can use it any time we want. This truly becomes useful when dealing with funky types such as those of functions and closures. As an example of an odd type, it would be a function or a closer that takes an Int and returns a name. The type for this function would be this, (Int)->Int. That can be confusing. I don't like it, so let's give it another name. And I'll call it InttoInt. Now this is much better. Now instead of having to use this funky type, I can use simply InttoInt, that makes our life much easier. Now let's create a typealias for a function that takes no parameters, void, and returns an Int. And I'll call it IntMaker, because it makes an Int out of thin air. Now we can use any of these types to define a function that takes an integer and returns a integer, or one that takes nothing, and returns an integer. This will become very, very useful in the next lesson where we finally tackle variable capture. See you there. Now we can finally move onto the main course, how functions and closures capture variables. Take a close look at the function make counter below. The code is pretty short, but it will require some close inspection to understand it the first time. What's special about this? Well it returns a function, an int maker. That's OK. There's nothing really special about that. We've seen that functions and closures, and by the way here I'm using function instead of a closure syntax simply because the syntax is simpler. That's the only reason. It work exactly the same with a closure. So we're returning a function or a closure, remember it's the same thing. And since functions and closures are class objects, we can return them from another function. So far, that's normal. Just like some machines create other machines, some functions can create other functions. There's nothing special about that. What else is interesting or at least unusual? It has a function within itself. So it contains a function defined within make counter. Well, don't panic, that's normal too. Just like you can have machines that contain other machines, and these are only visible from the within the contained machine. Think of your radio inside you car. So no big deal there. And it's actually useful and good practice to break down a long function, not this one, but a long function, not this one but a long function or a complex one. Into small, simple functions by using interfunctions that do part of the total job. What else is interesting about this? The really, really interesting and funky part, by the way, this should be this, is that adder. The inner function can access this variable that is defined before it. Not only can it access it, but it's changing it. It's adding one to that, that's what we call variable capture. So to understand how this works, Let's create two closures of type IntMaker by calling twice makeCounter and save them into two variables. So both counter1 and counter2 take no arguments and they return an integer. Think very carefully what the output should be when I call counter1 thrice. Try to think before using the Playground. So the first time n will have value 0, we add 1 and adder returns 1. Let's see if it's true. And what happens when I call again, counter1? What do you expect? Let's give it a try. So as you can see, when we call it again, counter which is a type of adder, keeps adding one to n and that value remains there, so we get two, three, four, et cetera. And now for the grand finale, what do you think this would return? Calling counter2 for the first sign. Think before trying it, and as we can see, it returns one. You might have expected it to return four. Actually, that would not be very useful, because that would mean that every function adder shares this n. The first languages that implemented this variable capture feature did behave that way, but it will soon realize that this was a bug. It was not a feature. So, right now, every single closure that we return from makeCounter takes its own copy of all the captured variables. So every time an adder is created, it takes a copy of all the captured variables. Therefore each closure has its own copy of the environment. And environment means all the values of all the variables that were captured. This is done for safety. And also to keep you sane. The value of a variable will never change out of the blue, because somewhere, some closure decided to change it. Everybody has its own copy. Let's rap up. We've learned quite a few things about Swift in this lesson, so let's recap. First of all, functions and closures are the same thing. We just have two different syntaxes, so you express one same thing. Functions and closures are first class citizens of our language. We can treat them like any other type. And also functions and closures capture variables defined before the closure or function is defined. It might not seem obvious to you at this point, but those two last features make Swift a far more powerful language. They are the base of a different style of programming called functional programming. Its popularity is increasing a lot lately. However, you won't need it to finish the nano degree or even land your first job, so don't worry, it's something that you can learn later on if you want. If you're interested, you might want to check any of the books that are linked in the instructor notes. There are introductions to functional programming. And in the meantime, we'll move to the next chapter, which deals with Grand Central Dispatch. This is a library that allows us to create background tasks with great ease. This is vital to ship great apps and avoid being rejected from the app store. Our newly gained knowledge of closures would make understanding GCD a breeze. So let's move on and learn it. This typealias defines a type for a function that takes two Ints and returns an Int, or a class with three Ints. It's the first option, and BinaryFunc is just a shorter and more convenient way of expressing a function type that takes two Ints and returns an Int. Would this code run? No, because the function g cannot access the variable z because it was defined before the function. Or no, because g is a function and only closures can capture variables. Or yes, function g can access variable z by capturing it. The correct answer is yes. Both functions and closures can access any variable or constant defined before the definition of the closure or function. Closures hold no secrets to us anymore. So let's get back to threading and GCD. We still have to learn about queues. So far we've been talking a bit about Grand Central Dispatch, or GCD but without getting into too many details. Time to put an end to that. GCD is an open source framework from Apple for both iOS and OS 10. It's one of the crown jewels of the Apple's programming stack. For reasons that are beyond this course dealing directly with threads in inherently dangerous and complicated. This is one of the reasons why concurrent programming has always been available only to gurus. Not anymore. GCG makes concurrent programming approachable by mere mortals by hiding threads, and using queues of closures instead. How on earth does this help? Patience young padawan, lets start with a queue. A queue is like a line at the super market, each customer is a closure waiting to reach the cashier. The cashier is a thread that picks a customer, or closure, and allows it to run. Once the closure finishes running, it is removed from the queue, and the next one in line runs. Which of these two statements is correct? Grand Central Dispatch makes it safer to use threads directly. Or, Grand Central Dispatch makes asynchronous programming easier and safer by hiding threads from the developer. The correct one is number two. Threads are inherently complex and dangerous. If you try to write a concurrent app by using threads directly, it's very easy to create hard to predict bugs, and seriously hurt the performance of your app. GCD makes it easier and safer to write asynchronous programs, by hiding the threads within the concept of a queue of closure. Blades, for example, are inherently dangerous, so we added handles to make for safer knives. This is the same idea. The queue is the handle for the thread. GCD provides us with two types of queues. Serial, or synchronous queues, and concurrent, or asynchronous queues. Serial queues behave as explained earlier. Every closure gets to run when it reaches the end of the queue. On the other hand, concurrent or asynchronous queues have several threads that pickup closures at any point of the queue for running. These are harder to control and we won't be using them. An app can have several queues, but not all queues are created equal. There is a very special one called the main queue. This is the queue that handles the UI of your app, as well as any of your code that doesn't explicitly ask to run in background queue. It is vital that you never run code that blocks on this queue. What does it meant to block? Blocking is when your code takes a human perceivable amount of time to execute, and prevents your app from continuing until it's done. You can do this either by doing something computationally expensive, such as applying a filter to a video, or a big image. However, the most common way of blocking is by using the network. Say you wrote some code to make a network request on the main queue, then none of your UI could update until the network request finishes. We cannot allow this to happen. If you do block the main queue, your UI will be sluggish, and your app will provide a terrible user experience and will likely be rejected from the app store. We won't have any of that. Only concurrent queues allow for concurrent programming on iOS, is this true or false? Absolutely false. Even though all blocks in a serial queue run one after the other, that doesn't mean that we've lost concurrency. Each queue will run on its own thread and will not block each other. The main difference between serial queues and concurrent queues, is that in former, the order in which closures run is predictable, while in the latter, it isn't. Synchronous cues are easier to use, so we'll stick to them. The basic functionality of GCD is as follows. We need to be able to create a queue, either from scratch or reuse an existing one. Get the main queue and also add a closure to an existing queue. Grand Central Dispatch was not written in SWF, but see. Unlike SWF, C has no classes or objects. So, Grand Central Dispatch is made of functions and types instead of classes and methods. These functions and types have different naming conventions than those used in SWF, but they behave exactly as if they were SWFcode. First of all, we need a type to represent queues. That's dispatch_queue_t, then we will need a function to create a queue from scratch. Dispatch_queue_create. It takes two parameters, a name and the type of the queue, serial or concurrent. To specify serial, just pass dispatch_queue_serial or nill. IOS always gives each app four extra queues on top of the name one. These are called global queues. We access those global queues with a function, dispatch_get_global_queue. The only difference between those four queues is the priority or how fast it will get the attention of the CBU. It's a good practice to avoid creating queues when using an existing one is enough. We will use dispatch_get_ global_queue for that. We also need a way to obtain the main queue. This is the queue that runs all your UI. We will use the dispatch_get_main_queue function for this. Why we need this might not be obvious right now, but it will be as soon as we get started with the sample app. Last but not least, we need a way of adding closures to the queue, that's where dispatch_async comes in. This function takes a queue and a closure, it adds this closure to the queue and then returns immediately. The code inside the queue will run sometime in the immediate future, the exact time will depend on how many closures already waiting in the queue and the priority of the queue. Take a look at this code and tell me which text would print first, tic or tac? Let's take a look at it first. In the first line, we create a queue of the highest priority possible. Then, with dispatch_async we add a block which prints tic to this queue, and then we call print("tac"). Which one do you think it will run first? Tac. Why? Because dispatch_async immediately returns. So what it does is, it will return immediately, and add this block to this cue. So this will run first, and some time in the near future, this block will run, so it will be first tac, and then tic. Take a close look at this code, and think in which order would the print statements run? 1, 2, 3, end, or end, 1, 2, 3, or who knows? Surprisingly it's, who knows? Keep in mind, that dispatch_async adds your closures to each queue and then returns immediately. Therefore, the print("end") statement will likely run before any of the closures get a chance to run. Later on, the closures will run. However, the precise order in which each of them will run will depend on how busy the queues that you reuse are at that moment. With dispatch_async inference we can run things in the background, but we apparently lose the ability to predict in which order the code will run. There is a way around this and we will see it in the sample app. Until then see if you can find it by yourself. We need the following. Each print statement must run in its own queue. They should always run in the following order, end, and then 1, 2, and 3. Think of a way of achieving this. I'll give you a tip. It's much, much easier than you might expect. Think of the movie Inception, dreams within dreams within dreams. Think about it. When the framework can run in the background it is said to be thread safe. However, there are several frameworks that are not thread safe and can only run in the main queue. There or two notable cases in the apple stack. These are two banana peels waiting for a newbie to step on them. These are UIKit and Core data. Let's start with UIKit. You cannot run anything from UIKit in the background, or your app will crash intermittently. That's the beauty of concurrency bugs. Sometimes they show up, sometimes they don't. The bottom line is never use anything who's name ends with view in the background. Or else. Core data is a bit more complicated, and we will deal with this in greater detail once we reach core data. The thing to remember here is that ns manage object context can only be used in the same queue it was created. Therefore, if you created the context in the main queue, you may only use it in the main queue. However, if you create a context in a background que, then you may only use it in the background. My recommendation is to wait until we feel really confident with core data and GCD before you try to mix them together. Core data in the background is second than core data, so tread carefully, Daniel son. Until then, wax on wax off. Remember to breath, very important, hai. Take a close look at this code and tell me if you think it would crash. We create a queue, and within this background queue, we obtain the NSData, turn it into a UI image, and then display it. Yes, no, or maybe? So the answer is yes, but maybe, probably yes. This code uses UI kit in a background queue. Will this make the code crash every single time? No, and that's the bizarre beauty of concurrent bugs. They are impossible to reproduce. If you run this code ten times, it will likely crash a few times, but not always. Make sure you always use UI kit code in the main queu, or eventually you will have to face the toughest bugs ever, concurrency bugs. How would you get the offending line of code to run in the main queu? We'll see how to do this in the sample app. But in the meantime, try to do it yourself. Remember Inception, the movie, dreams within dreams. I know GCD. Enough talk, now grab your Xcode and show me some code. We're now ready to harness Grand Central Dispatch and write our first concurrent app. Before GCD, concurrent programming was the realm of uber gurus only, and you're entering it with confidence. So grab a well deserved drink, and let's finish this job. In the instructor notes, you'll find the URL for this revel. The first step is, unsurprisingly, on branch step one. So, make sure you checked it out correctly. Now, let's go to Xcode. Let's first take a look at the main storyboard. As you can see, it's very simple, and it has one image view, a slider, and three buttons. The slider changes the alpha channel or transparency of the image view. So, it's basically there so we can tell if the UI is blocked or not. If you can move it while it's downloaded it means the UI is not blocked. Whenever you lick on any of these buttons, a large image will be downloaded. This is by far the easiest way to block. So for each button we'll write a different action. The first button, over here, sync, will use a naive serial code that blocks. The second button will use in an asynchronous version using GCD. And the last button, will use a more elegant version that takes a completion closure. Let's get started. Let's get started with the serial version. First of all, we have the three ID actions, synchronousDownload, this is the first button, simpleasynchronousDownload, this is the second button. And asynchronousDownload. This is the one that will use completion block. So let's get started with a synchronous one. And we need to do four steps. These are the four steps that we need in order to download this image. So first of all, we need to get the URL for the image. Then once we have the URL, we will need to obtain the NS data for the image. And we don't really care for NS data. What we really need is a UI image. So we have to turn this NS data into a UI image. And finally, we're going to display it. So, let's just insert the code. Okay, so this is the source code. As I said previously, the first steps you get the URL, and there is a catch here. NSURL may return an. So, this actually won't be a URL, it's going to be an optional with a URL inside. Then, we have to turn this URL in to a NSdata. We have to fetch this image from the URL. And we're using NS data contents of URL, which only accepts a URL, not an optional. So we have to unwrap it. Once we have the NS data, we need to turn this NS data into something that we can use, a UI image. Again, just as before, the method that we're going to use, does not accept an optional. So we have to unwrap it. And provide the NSData. So, this is not very nice, what we're doing here. Having all these unwrapping's. But I want to have it line by line, so you can easily spot who's the culprit. Start thinking who might block In this code. And last but not least, we have to display the image. So, once you have this code written down, let's run the simulator, and make sure if it blocks or not. It should, and indeed it does. As you see when I click here, it should just blink. Instead, it remains inactive for a certain time, while the image is being downloaded. And while that happens, you can't do anything, the GUI is blocked and it's blocked for a user perceivable amount of time. So, congratulations you have just been rejected from the app store. We cannot deliver code that behaves like this, under no circumstances. Fortunately, after all the wax on, wax off of the last lesson, we now have all the tools to fix this. However, before we do it in the next video, see if you can refactor this code, and put everything inside of a single if let statement. It is not good practice to have all these exclamation points into your Swift code. And besides, it's also unsafe. So, before you move on try to refactor this. Put it into a single if let statement, and we'll continue on the next video. Before we get started, let's take a look at our previous code, once refactored. Now it looks much better, and most important of all, it won't crash if we provide a badly formatted URL and NSURL returns a nil. However, even though it does look good, it still sucks. It blocks the main queue, so we're going to fix this. First of all we need to find the line that it's blocking. Can you spot it just by looking at the code? Yep. It's this one. The NS data one. That's the one that downloads the hued image and stuff it into an NS data. We need to send this fellow to background queue. Actually, the next line where we convert this NS data into a UI image might also take some time, although much less. So let's send both to the background. But hold on, UI image belongs to UI kit. So we should never use it in the main queue. Well no, not really. Not all of UI kit is threat and save. There are a few exceptions such as UI image. However all the visual stuff, the views are unsaved. So changing the image property here, that must be done in the main queue. Always remember the famous haiku from Zen master Basho. If the name ends in view it belongs in the main queue. First of all, lets create a queue from scratch. So, the first step is to create the URL. Now that we have the URL we need to create a queue from scratch. To create a queue from scratch, we use the function dispatched queue create, and it takes two parameters. The first one is just a name you can put there whatever you want. Doesn't really matter, and the second one tells GCD what kind of queue you want. Neil in this case tells GCD that we want a synchronous or a serial queue, otherwise you would have to use a different constant that you can check on the documentation. To create an asynchronous queue. But we're not going to use those in this course. The following step is to recall dispatch async. It will take two parameters, the queue, in this case download and the closure. Although, notice that here I'm using the trailing closure syntax. So in here is where we need to download the NS data, turn it into a UA image and then display it. Let's get started. Once we have the queue we can call dispatch_async and send, encapsulate in a closure, the fending code and send it to the background. However we have a problem here, we're downloading the image in the background queue, we're turning it into a UI image. Also in the background queue but we need to run this code and display this image in the main queue. How could we do this? How can we hop from a background queue to the main queue. Well I've been hinting it for some time. You gotta think of inception, with dreams within dreams. In this case it's closures within closures. So from within the background closure in here, we're going to get a reference to the main queue, and then call dispatch async within this closure and send another closure to the main queue. So basically we're going to start here in the background, and once we reach this point we're going to jump to the main queue. Let's see how we can do this. Let's take a look at this code again. So, first of all, we jump to the background, run a few lines of code that will block. And once we're done with this, we jump to the main queue using the same function. Dispatch async. But this time, we're providing the main queue with dispatch_get_main_queue. And within this closure, that will run in the main queue, we set the image for the ImageView. So this way, we make sure that all of the code that updates the UI runs in the maiden queue. So this is not only efficient, it's absolutely safe. And this is the true beauty of grand central dispatch. It makes asynchronous code look like it's serial which is easier to understand one line after the other while you're actually hopping from one queue to the other queue. Before we move on, let's make sure that this code actually does not block. Let's run it and take a look. So let's try again. The synchronous, it blocks. See? And let's try the asynchronous. See that it just kind of blips and that's it. So, even though it seems like it's instantaneous, it's actually downloading the image in the background. So let's get here and once we click here it just blinks and we can, while it's downloading, you can use the, the UI. So, so far, looks good. Let's move to the next step and implement this last method. This is kind of your graduation for this lesson. It's an asynchronous method with a completion closure. Let's give it a try. Could you write a method that downloads in the background and then returns the image once it's done? Try to write one, I'll wait. No luck? That's because it's impossible. Let's see why. When you call a function and wait for it to return, you're making an assumption you probably never paid attention to. You have seen the function knows where to return. This is fine in serial synchronous code where the calling code will be blocked until the function returns. In asynchronous code, however, the calling code may continue doing something else, therefore, we need to provide the function, with the information on what it needs to do once it's finished. In SWF, that information could be passed in a closure, a completion closure. You've seen many so far, in Apple's code. Now, you're going to write your own. Yeah! Here we are, ready to tackle completion closures. We've seen many in other people's code, but now we're finally ready to write our own. Writing a method that takes a closure as a parameter has a wacky syntax, but don't worry, we have a great tool called www.goshdarnclosuresyntax.com. Let's take a look at it. This is www.goshdarnclosuresyntax.com, and it's a list of all the different ways that you can declare a closure in Swift. So you have as a variable, optional variable, type alias, etc. The one we're actually interested in is argument to a function call. So we want a function that takes a closure as one of its parameters or arguments. There is another version of this site with a far more memorable name, but our lawyers told me I couldn't use it. Finding it is left as an exercise to the interested student. Anyway, let's get back to Xcode. Now we're going to write a method called withBigImage that takes a completitionHandler as a parameter. What will this method do? It's going to download the image in the background and once it's finished, once it's done, it will run the completion handler. The completion function closure, or handler, however you want to call it, is what it should do with this image once it has it. So let's get started. This is the signature for the withBigImage method. It takes one parameter and this parameter has two different names, an internal name called handler, and an external one called completion handler. But the important stuff is here. It returns nothing, but it takes one parameter, a UI image. That's because since it's going to do something with a UI image, it must have access to that UI image that this method is going to provide. So the completion handler must take as a parameter the image that has been downloaded. Next, we will have to fill in the code, and it's going to be very similar to what we wrote previously. We are going to need to create a download queue, and then we're going to add to that queue a closure that downloads the queue in the background. And then we will finally, once we're done, we're going to run this handler. And you can start thinking right now in which queue do you think that the completion handler should run? Let me write the code and we'll get there. Okay, this first step is to call the spare chasing. And we need also a queue, but this time we're not going to create a queue from scratch, we're going to reuse one of those four queues that the system allocates for each application on iOS, and we need to choose also the priority of this queue. It depends, if it's something very urgent, something that has been initiated by the user, then it should get a decent priority. If it's something that can wait, then you could give it a lower priority. But first we need to get this queue. The first parameter for dispatch_get_global_queue is something called the identifier that's actually a constant that gives you the priority of the queue. This QOS by the way means "quality of service." Class_Background, that means pretty bad quality of service. It's going to have low priority. And user_interactive is the top priority and user_initiated is the normal hold priority, I'll set that. And the flags, those are not being used right now. That has been set up for the future, so right now you should pass zero. And we have the closure. So within this code, that's where we have to get the URL, download the NS data, turn it into a UI image, and then, once we have the image, run the completion handler. Let's write, this should be familiar by now, but lets write it. So here's the code that we've been writing over and over and over, it's encapsulated in a nice if-let statement so nothing evil will happen if we get a nil. The only thing that is left is to run the completion closure, and that's just like calling any closure or function. So it would be handler, image, and the image that we downloaded. Now look carefully at this code and think if this is wise, if this is a good idea. Everything that is running inside this closure is running in the background queue. However, completion handlers or completion closures are usually used to update the UI, so they will very likely use an axis UIKit. So this is definitely not a good idea, okay? It might crash if whatever code is in that handler, we don't know exactly what's in there, because we get it as a parameter, as a black box, if that accesses UIKit, this code will crash definitely. So it's a good practice to make sure that always all your completion handlers run in the main queue. This is not a rule, but It's a very good practice. Make sure that always, all your completion handlers, those that you write, run in the main queue. When you get a library from a third party, and it has completion handlers, you should check the documentation to make sure where those completion handlers are run. The usual is the main queue. So we need to wrap this code here, in a dispatch_async, dispatch_get_main_queue, and then call the completionHandler. This should be trivial by now. Let's finish it. Here it is, we call dispatch_async, as usual, then dispatch_get_main_queue, because we want to run the next closure, within the main queue. And inside this closure we will run the completion handler, so this way we're also hopping from one queue to the other. We hop to a background queue here. Then when we have the image, we go to the main queue and run the completion handler. And either if this completion handler uses UIKit or not, it's okay, the code will not crash. And now we're finally done. No, hang on there, this is a very good moment for you to go and take a look at the black box code that hides the reality of GCD from most students. It should be obvious to you right now. Just by staring at the code, you should be able to see the lady in the red dress. And there's extra nerdy points for you if you know what I'm talking about. Unlike dispatch async, dispatch sync won't return immediately and run the closure sometime in the near future. It will wait until the closure exits before exiting itself. Take a closure look at the function with big image that we wrote previously to download a heavy image. Would it be okay to replace the last call to dispatch async by dispatch sync? Would it be okay to call dispatch sync in here? Certainly yes, after all once the handler is finished there's nothing left to do. Therefore, it doesn't matter if you call dispatch sync or dispatch async, it's pretty much the same, or absolutely not. What if this completion closure does something stupid and blocks? What do you think? The solution is absolutely not. We should not use dispatch_sync here, because we don't know what the completion closure will do. What if it blocks? Then the whole call to, with BigImage will stall. Which it wouldn't if we use dispatch_async. The bottom line is, always use dispatch_async, unless you know very well what you're doing. We have reached the end of this lesson, but we have barely scratched the surface of GCD. Grand Central Dispatch is a treasure trove waiting for you to explore. There are functions to run a closure after a delay, to run it only once, to run a for loop in parallel and more. So read the docs and find out how far the rabbit hole goes.