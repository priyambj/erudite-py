Now, we've talked a lot about algorithms, set-ups, and equations, but what we haven't really talked about is how to get your assets into the game in the proper way. And that's what we're going to talk about in this unit, proper asset loading. Which, by the way, is the dark art of high performance programming. If you get it right, your games load quickly and you get happy users. If you get it wrong, you get bad load times and then all of a sudden people are starting flame wars on the internet about how long it takes for you to load your level. Choice seems kind of obvious to me. We've done some simple code at this point, to load assets and resources in memory. But as our code base gets more complex, we'll quickly find that we need additional power and flexibility to help us get larger amounts of data into memory. For example, what if you issue a load of the same file multiple times. Well, each load will hit disk or at worst the web, and load that asset into memory. This can become a large performance burden as each from disk fetch can have performance costs. As an improvement, it would be great if once an asset had been loaded, to know if it's in memory already, so that we can return the in memory version, rather than going back to hitting the disk, or the web, multiple times. This concept starts us down the path of an asset loading manager, which we'll cover in this unit. Now in contrast to other languages which handle File I/O as a synchronous or a blocking functionality, all File I/O functions in JavaScript are by definition asynchronous. As you already saw before, we specify a load function that is called later, once the image has been loaded. This is a benefit to JavaScript, because we don't have to put together all the logic of communicating between threads in order to load our assets asynchronously. Giving HTML5 an edge in terms of features for gaming. While we write our asset manager, asynchronous loading is one of the core features. Can you think of others that would be critical to have? Should it have a cached asset management system? Should it need asynchronous callbacks on loading success? What about batched asset loading, so that you can submit multiple file requests and have them loaded from a single call? In general, we would expect our asset manager to have the following features. First off, loaded assets should be cached so that multiple requests won't trigger reloads of content, but instead use the in-memory version. We should also be able to receive asynchronous notification when an asset has been loaded. This allows us to go ahead and load the asset while also rendering the game scene at the same time. In addition, we should allow batches of assets to be loaded in a single call. This is very critical for when we do map loading or other heterogeneous file computation where we need to pass images, JSON files, and sounds into the system to allow them to load in a single call. Let's take a look at our previous code to load an image. Now remember, it was three lines of code to create an image, set a callback, and then define the source. The first steps in writing an asset manager would be to cache this image once it's loaded so that duplicate calls won't issue a reload, but rather would return the image we've already loaded in memory. To do this, you're going to implement the concept of a cache. What will happen is, the first request will go through, and the data will be loaded. When it's loaded, you add it to the cache using some key value, like its name, so that subsequent requests, rather than going out to disk, or to the web, will check the cache first, and return the already loaded asset. What I'd like you to do is to modify the following code so the asset loader checks the cache before attempting to load the image. Now there's a couple things to point out here, is that gCachedAssets is actually a dictionary object, which means that you need to specify a key and value when accessing and referencing to it. Also take note, that here in the img.onload callback is where you need to do your heavy lifting to push your data into this cache object. Good luck. Hi, welcome back to the show. Let's take a look at the solution here. So, our loadAsset function should first check the gCachedAssets dictionary for the file name that was provided if the file is not present in the cache, then the result of this access will return no. If this happens we know that the image has been loaded, and we need to actually issue a load call. From here we can actually create our image do our on load, and set our source. Once is all done we actually set the image object as the value to the key of asset name inside of the cache. This allows us later, once again, to go through, query for a name and get an object, which you can see down here. If the object has already been loaded, then when we query for it, we'll get a something back, which allows us to pass that image object to the callback function that was given to us. Now the coding solution is fantastic for a single file, but practical usage fails. Once we want to load a suite of files, we effectively need to specify a callback for each one of them. Instead, we should add support to our asset manager to allow us to pass a list of files to load. And receive one callback once they've all been loaded. So what we'd like you to do, is modify the load assets function to taking a list of asset names in a single callback function. Now just as a heads up, this process may be a little bit tricky. You'll probably want to do something right here in the onload function to keep track of how many files have been loaded so far. Make note of it, so that you only have to issue one callback function. One other interesting aspect that you're going to have to change is what if all of the assets are loaded, or what if some sub-portion of them are loaded and other ones need to be loaded? In this situation make sure you also take into account, what happens if half of the images are loaded, or none of the images are loaded, or all of the images are loaded? In these three different scenarios you should have a different logic path on when the callback function actually gets issued. So for example if all of the assets are loaded, you may only need to do one callback function immediately. Hi, welcome back to the show. Let's walk through the solution for this one because it's just a little bit tricky. First, we need to keep some sort of count on how many of the assets have been loaded and how many we're waiting to load. To do this, we create a nifty little object here, that has a count that represents how many objects have been loaded, a total which is how many objects we're waiting to load, and then the given call back function. Now we want to take our code, which previously only loaded one asset and issued a call back, and add loop around it so that we can do this for the entire asset list. Now, there's one tricky thing here, is that once we actually load an object and get a call back function for it, we want to do some logic before we issue the call back. So for instance once the first image is loaded, we don't want to issue the call back then, we want to wait until the entire set has been loaded. For this, we added the new function called onLoadedCallback. This function, given an asset that's been loaded, will actually go through and increase the count on the batch. Once our count equals that total number of assets we're waiting for, we actually issue the callback at that time. With this setup, you have the ability to issue a batch of assets, load them, and when they've all been loaded, you finally get your callback. So far we've seen success with loading image data. But it would be great if we could extend this functionality into loading JavaScript files too. The good news is that you can add a JavaScript file to the DOM dynamically and just like with images, you get a callback function, once the file has been loaded. So, what you need to do now, is to fill in the rest of this code, to allow the load assets function to take a list of file names, which might be images, or JavaScript, and load them correctly. Which means is that in here, before we actually issue off our command, we need to figure out what type of file we're trying to load. Tricky, tricky. You may have to look at the file name's extension, to determine this. Hi kids. Welcome back. Here's what we're going to do. Step one, we're actually going to analyze the file name itself and determine what file type it is by looking at the extension of the file name. This function is going to return an integer, which represents what type of file it is. For our purposes, we've defined that 0 should be an image, and type 1 should be a JavaScript file. Now, as you can see, loading a JavaScript file is very similar to loading an image. We actually create the object, we set a callback, and then we actually set its source. Now, there's a couple other things we have to do because we're injecting script into the DOM, like setting its attribute type and then actually appending it to the DOM. But other than those two things, it's pretty similar. The real magic comes down here at the bottom, when we actually analyze the file name to determine what type it is. So, for example, if it has a .jpg, we assume it's an image, versus a .js, which we assume is then JavaScript. In the early '90s, CD-ROM's burst onto the scene starting first with computers and then actually moving to consoles. Of course, with it became larger asset sizes as well as increased load times. See, the medium of actually getting data off of a CD-ROM was much slower than cartridge counterparts were for earlier game systems. This means for the first time in history, game developers are actually forcing users to stare at a very, very boring screen that just told them content was loading. This of course was because the assets took time to get into memory and they weren't being streamed of disc fast enough. More importantly, game developers didn't really have the proper knowledge of how to work around this problem. Most of the architectures back then were single-threaded, which meant all the file iO was actually synchronous, or blocking, so they had to come up with very, very tricky mechanisms to load data and render that little UI. Now for grits we run into the same problem. If a user is on a very, very slow connection, it's actually going to take a lot of time to stream that data in. For our purposes we actually employ an asynchronous asset loading methodology. Which means we can actually render things to the screen, while actually pulling data in from the net. And that's what we're going to talk about here in just a bit. Phase one is the pre data, or menu data. This is the first set of screens the user sees and needed to be loaded immediately. In GRITS, all of our menu assets are defined and positioned in HTML. So the browser will handle loading of these assets as part of parsing and processing the HTML file for presentation. Since these assets are defined in a DOM, their loading is handled by the browser's page parser and handler. So, we don't have to do anything explicit here. Once the user hits Join Game, we enter into a new phase. We must load all the scripting data that's used by the game. The data hasn't been defined by the DOM. As such, we need to issue commands to our asset loader to fetch that information and wait until it's been loaded. It's worth pointing out that the game scripting and menu scripting are really two separate code bases. Which is why we load the separately, as well. The scripting code will load up the object definitions, systems, physics, et cetera, and all of the other things we need to run the game. But not needed during menu browsing. So here is a list of scripts that we use inside of GRITS. What we'd like you to do is pass the array of file names, to the asset manager as a batch operation to load all of the data. After the batch is entirely loaded call window.alert to notify the player that the files are loaded With all the work that we've already done to load assets in a batch form, the code here is actually pretty simplistic. We take the input scripts array of file names, pass it to load asset, and on the call back function we simply call window.alert letting the user know that everything has been loaded. So once this scripting data has been loaded, we can now move forward with our assets, images, maps, etc. Now typically you can load assets and scripts at the same time, but I've been burned by that in HTML once or twice. Injected JavaScript code can easily suggest more assets to be loaded, which would require more kickoffs of async calls and tracks that follow. As such for sanity, well, mainly my receding hairline, we let Grids' scripting code come in first, define their systems and asset needs and then kick off all the subsequent asset loads afterwards. In Grids instead of calling Windows Alert this is where we actually kick off phase three where we parse our texture packer outlet's definition and load the map objects. Once that was done, we can actually let the user play the game by turning off the UI and showing the canvas elements. Once we've gone through our three phases of loading the menu, descripting data and then the assets, finally we can allow the user to get to the screen and play the game. It's only through the combination of all of these together do we ensure a nice easy transition for the user that constantly shows them a refreshing UI. So now that we have a working asset manager it's probably worth taking a step back and talking about how good asset loading works in good games. See, proper asset loading means you need to take into account how a user's going to experience your game and benefit from that properly. So for instance, if you were on a CDROM drive you have to know that it's going to take a certain amount of time to actually stream data from the disc into memory. So, you have to pretty much cover that by doing some 3 second animation or something else to hide from the user, that's streaming overhead. Now, some very interesting examples of this come to mind. The first is probably one of the more famous ones, Devil May Cry, back on the original PlayStation 2. This game had a really cool mode, that while the scene was actually loading, if you did your button smashing, you'd actually do damage to the loading bar. I actually remember sitting in my room watching my roommate kind of smash on this button controller as mad as possible, because he was so angry that it was taking so long to load. But by the time the level actually loaded, he was happy again and could go on killing all sorts of demons. The second example that comes to mind is actually Metroid Prime for the Game Cube. This was actually a simplistic tunnel shooter, effectively you had segments of geometry that your player would move through over time. They did something really cool, is that they only allowed one section of tunnel in memory at a time. This meant that each tunnel could be super high resolution graphics because there was nothing else competing for space. As you moved towards the end of the tunnel, though, towards one of those little doors you've got to shoot to open, it would start streaming in the next level. The problem with this though was if you started running too fast, you would get to the door before the streaming was done. You'd sit there shooting the door and it wouldn't open yet because the next level hadn't loaded. My personal favorite is actually Jak and Daxter. These guys had probably one of the earliest streaming mechanisms that I ever found. And the coolest way to hide it too. They had an infinite terrain. So you could run around and do all sorts of stuff. But if you for some reason were able to move fast enough that you were moving in an area that the terrain hadn't been streamed off a disk yet, they'd trip your player. This is the only time in the entire game where your player would actually fall down, and then play a 3 to 4 second get up animation. Of course during that time they had plenty of extra space to spit up the rest of the data from the disk. The point is this, most of game development is smoke and mirrors, so take advantage of that to give your user a believable experience. Now as a game developer throughout your entire career you're going to constantly be fighting against load times. No matter how many times you ship a game, you're always going to be trying to get more data into less memory over time. So take this to heart kids, don't be a fool. Write an asset loading tool. Wait, does that make any sense? [LAUGH] [CROSSTALK] Now, once we have the ability to manipulate the canvas, the next step is figuring out how to do the right way. So, you'll find that as the number of images in your environment and the number of images in your asset set start increasing exponentially, the management of that and drawing to the screen, is actually going to get exponentially harder as well. So, in this unit, we're actually going to introduce the concept of an atlas, and talk to you about how to boil all of this complexity down into something that's usable, and easy to do. Now it's important to understand that there exists an upper limit on the number of requests that a browser can make to a single server. The browser itself sets this upper limit generally it's about six connections for a modern browser. And when the upper limit is reached, the browser will actually block subsequent requests until an open connection becomes available. So, for instance, if you have 4,000 pending requests, and only six connections are available, all the other requests get stacked until something gives. You see this in a situation where you may have a 4000 pixel by 4000 pixel texture that may be fetched from a server. This single fetch can take about 241 milliseconds to download, which is actually pretty fast. If you were actually to chop up that image into smaller little pixels, so, for example, we would create 4,000 separate images, the total load time to request all of those images to occupy the same amount of space would change drastically. In fact, it would actually increase from 241 milliseconds to 4.3 seconds, that's an increase of 17 times. With this in mind, it makes sense then that in order to reduce load times for high performance web applications, we should group as many of the small elements together into one large image to reduce the number HTTP requests. This process of packing smaller images into larger images is known as texture atlasing and is a very well-studied process in most games. For example, in real-time graphics, a texture atlas is a single large image that contains many smaller sub-images, each of which can be referenced independently. Now, if you've been around software engineering long enough, you'll realize that most of the technology that makes up the web isn't really new or cutting edge. It's actually old technologies with new, sometimes worse names. Now, I think Atlases and spreadsheets are a perfect point of this. So a spreadsheets in the HTML5 world actually describes that what we use an Atlas. But this is very, very wrong. See back in the 2D days of making games. Atlases were used to define many sorts of charts in a single image, where spreadsheets was a term reserved just for animated objects. The spreadsheet concept only really existed when you needed particles to fly around or a character to make a swipe with his sword, everything else was just an Atlas. Now, for you web developers out there who are actually using the term spreadsheet incorrectly, I forgive you. But let's try to fix that, okay? Creating a texture atlas is actually a very tricky engineering task. Texture packing is a type of bin packing problem that has been proved to be np hard. The problem is so challenging, that I frequently use a variant of this algorithm as an interview question to evaluate the skill of potential hires, GRITS, rather writing our own version of texture packing. Grits uses texture packer, which is a great off-the-shelf tool that fits into most content pipelines quickly. It will generate the atlas data given a list of loose textures, alongside a data file, that maps the individual source images to their final locations in the atlas. Now the output from texture packers is actually going to be a JSON file. We will need to load and parse the data in this file, in order to render all our sprites on the screen properly. Now, for each chart in the atlas, the JSON file lists a nice set of data, that allows us to understand more about this chart. For our purposes, we're really only concerned with two things. The first, being the name of this chart. Now, this was the name of the original loose asset before it was packed inside of our atlas. And secondly, is the data here in the frame parameter. Now, frame has 4 items that we actually care about. The first two, x and y, represent the top left corner of the chart inside of the atlas. The next two are width and height, which represent the size of this chart in the atlas itself. Now, we're going to use all 4 of these values to actually draw this chart to our canvas. Now, we've given you a sample data file to parse that's actually part of the grid scheme. What we'd like you to do is use this data to load the assets into our sample by filling out the parseAtlasDefinition function in the sprite sheet class. Our solution for parsing the atlas definition is pretty straightforward. First, we're given atlasJSON data that's been loaded from an xhr request. The first step that we need to do is actually go through and call JSON.parse on that. This will turn the text JSON data into an actual JavaScript object with members and values that we can iterate over. We use this to affect here. The parsed object has a frames dictionary that we'll actually iterate over to load all of our sprites. We'd like to fetch each key inside of our dictionary. And then, fetch the associated sprite object that comes with it. From here, we now have the sprite name and effectively, the sprite values. The next step we take here is to actually define the center of the image. So, we actually multiply the width and the height times 0.5, which would give us the half width and half height. Now, we store this value in the cx and cy as a negative offset. The reason for this is that we'll use the cx and cy values a little later on, during rendering, to transform our object into proper space. We store them as negatives here so that we don't have to do the mathematics later on when we're drawing the image. Once we've got this data, we go ahead forward and call the defSprite function, passing in the image name as a key. And then, the frame.x, frame.y with height and center data that you've already seen before. Now that we have our ASA data parsed we can use it to render to the screen. Although you notice that our previous drawimage function doesn't allow us to draw sub section of an image. Effectively it only took in x and y position. Thankfully there's a version of drawimage that supports this ability but we haven't really discussed it yet. There's an advanced version of the drawimage API that takes in a few more parameters giving us more control on how we want to get the pixels to the screen. In order to understand more about this we cruise over to webplatform.org so we can take a look at the data. The new parameters that we should be looking at are this. First off we handle the same image object that we took with our previous drawImage API. And then we have the source x, source y, source width, and source height parameters. These represent the xy position of our chart in our atlas as well as the width and the height of that chart in the atlas. The destination x, y, width, and height represent the position and size that this small subsection of our atlas is going to be drawn to in the output canvas. So, for example, we can set source x and source y to 2, 2. Width and height to 32, 32. And draw to a position on canvas of 128, 128 by 64 by 64, drawImage is smart enough to know that if the source, width, and height don't match the destination, width and height. To probably scale the image to match the desired output size. For our purposes in grids we really don't do any scaling so for 99.9% of the time source, width, height and destination, width, height are the same size. With this in mind, your next assignment requires you to use the data file you've parsed to render the few images on the screen. You're going to need to fill out the two functions below to properly draw images on the screen. Now, before you get started, let's talk about something real quick. Note that, before now, your artists were actually generating assets referencing loose files. And artists create some sort of texture, they put it on disk, and then they reference an object to that texture. Well, of course, there's a post-process. We've all crammed that all into a small little box, and we now have a missing correlation. The artist file still is going to reference the loose asset. But we've got it sitting around in a larger texture. How do we make a connection between the two? The drawSprite function needs to fix this. It assumes that it's going to be given a spritename, which represents the name of the loose asset file as well as the position X and position Y on where it wants to render it on the canvas. Since we're just given a spitename, we need to map where that spritename exists inside of the atlases that we've loaded. Now, for your benefit, we're going to help you out with this. Taking a look at the top of the file, we define a global dictionary object that represents every sprite sheet that's been loaded. In the load function for sprite sheet, we go ahead and add this sprite sheet into the global array, setting the sheet name as the key for the dictionary element. What this will allow you to do is when you're given the spritename inside of the draw function, you can iterate through all of the sprite sheets and for each sprite sheet, determine whether or not the given spritename exists in the sprites that have been defined for that sheet. This should be pretty straightforward since we've already covered the defined sprite function and you already have a list that includes a name. Once the drawSprite function figures out what atlas this given sprite is actually in, it can pass that data to drawSpriteInternal, handing off the sprite information, what atlas sheet its coming from, as well as the position X and Y that was given to us from drawSprite. Drawspriteinternal should actually do the heavy lifting of positioning the element, and drawing it to the world, taking advantage of the draw image API that we just covered with all of its new fancy bells and whistle parameters. All right. So let's take a look at how this falls out. The drawSprite function is given a string representing the name of the loose asset that we'd like to draw. In order to draw it on the screen, the first thing we have to do is iterate through all of the sprite sheets that have already been loaded, and determine whether or not this sprite name exists on that sprite sheet. Now, to make this a little bit easier, we've actually abstracted out and created a new GetStats object on our spreadsheet. The getStats function will effectively take in a name, and walk through all of the sprites for the sheet to determine whether of not this sprite with that name exists on this sheet. If so, it will go ahead and return the sprite information, if not, will return no. Passing it, the sprite information from the sheet. The sheet itself as well as the position x and position y, passing it through. Now drawSpriteInternal is where all the magic happens. First we start at the top of it by defining a few sanity checks to make sure that someone else in the code base isn't calling this function with improper data. Next what we do is actually create a nice little variable that holds off the center x and center y translation value that we defined when we were loading our asset. Next we go to our version of draw image that has all the fancy perameters. From here, we define the source x, y, width and height values passed to us directly from the sprite object that was defined from our json atlas definition. The next 2 values is the, where we want to draw this sprite to on the destination canvas. And that's going to equal to the position x that we've been given by the calling function, as well as half x and half y. So that we can actually put the center of the Sprite, at the location that we're interested in drawing in, as opposed to the top-left corner. And, as we said before, the destination width and height should be equal to our source width and height in the sprite atlas. Now it's worth putting out that this magical program, Texture Packer, provides a nice little output option that you can see right here, called trim. What this option will do, is that for each image, it'll find out the true boundaries for it. So let's say an artist gives you a texture but only puts pixels in the center part of it. The needed pixels of this image only occupy a sub-portion of the physical space that's been provided. As such we get a lot of wasted pixels. Texture packer provides this trim option that will go through and remove unneeded and unused pixels, mostly transparent, from all of the sprites that are given to an atlas. The results are actually pretty significant. You can see that the size of the atlas that contains the blank unused pixels is significantly larger than the one that trims properly. Now it's worth pointing out however, that when you use this option the format of the data in your output JSON, from Texture Packer is going to change a little bit. So previously the frame parameters width and height values matched the same as the sort size. So if your input image was 128 by 128, the size in your texture atlas was going to be 128, 128. And of course the trimmed value is false. Once you start with trimmed equal to true, you'll notice that the frame width and height represents the true boundaries of the used pixels in the input texture. It no longer matches the size of the input texture exactly. Firstly we'll need to update our parseAtlastDefinition function to take into account if a sprite has been trimmed, using this data to modify the corner x and corner y offset values. This is important because if you recall the coordinate system of the canvas will place an image according to its top left corner. Well, the trimming process in texture picker can move the top left corner to the new trimmed location. As such, we need to refer to the trim data against the source data to figure out what the proper offset is to draw the sprite in the correct location. With this in mind you need to update the parse atlas definition to take into account the differences between the framed version and the source version to properly update the offset values so that the sprite draws in the right location. Now, in order to update the cx and cy offsets for trimmed sprites, we have to do a couple of interesting things. First off, you need to understand that [unknown] will only do a smart trim from the edges to the center. So, for instance, if you end up in a situation where you got a nice box and pixels in the top left quadrant, it won't actually trim that sprite because it can't shrink it to the center. Because of this, we don't actually need any of the information from the frame in order to create the new cx and cy values. Instead, all we have to do is figure out the half dimensions for the sprite and create an inverse of that, which represents our offset. Now, we store the cx and cy here, which means if the sprite is or is not trimmed, it doesn't really matter in the drawing function that uses these values later. For a game developer, tools are the life force of your development cycle. It's starts all the way at the beginning with the compiler that the programmers use, all the way to the art creation tools for the artists and even notepad and text editors for the designers. Basically, it's how we get things done. And believe it or not, this has actually been going on for about 30 years now. So, it really hurts my heart when we hear a lot of web game developers say that they have to go start from scratch creating a brand-new HTML 5 game development tool. That's simply not true. So, before you go out and actually start throwing all of your venture capitalist money at a new studio to try and put together some HTML 5 development tools, go back and take a look at the stuff that we've been using for the past 30 years to make really good 2D and 3D games. You'll actually find that HTML 5 and JavaScript, in particular, is very capable of reading in data formats from all these tool systems. So, go out and educate yourself before you throw your money away, you'll find some good stuff out there. Now, we all know that you all love animated robots running around and shooting each other. I mean, after it all, it is good family friendly fun. But we also need to draw the environment map. We draw the environment map through many of the same processes that we used to draw animated sprites. Firstly, all of our map data resides in one large atlas. This allows us to then simply call the canvas.draw image tag to be able to draw subportions to our map. In addition to that atlas we have, we also have a very large and very complex data file. This data file represents how the atlas should be rendered to draw the entire map. Now this is a pretty complex file because its actually been generated by an external tool, called tile. Prior to running the game, and artist would take our atlas data and the tile tool. For grids, we actually read the exported JSON data into our game, which tells us how to render the images and the tiles on the screen. Now, in order to actually render our map, we need to parse the exported data file that we've been given from the tiled editor. The data the we extract from this will tell us a number of things. First off, what atlases to load. And secondly, how the layers are organized, given to us by the artist. For example, you can see that the data layer here actually references what tiles to render, as well as the height and the name of the layer itself. We'll need to be able to scrape all this and properly understand how it's laid out to render our final image. Now tiled, similar to texture packer, outputs a JSON file that we first need to load into memory. What we would like you to do is to perform a xhr in the load function here to load the tiled JSON data into our game. Since we've already covered how xhrGet works as a function, this should be pretty simplistic. Give in the input to some URI on the internet, do an xhrGET on it, fetch the data and set this.fullyLoaded=true. This effectively means that we allow the loading function to occur and when we set this flag, this allows other external functions to query the class and have logic defined on what to do or not to do depending on its load state. Now that we have the tiledJSON loaded, we need to parse it. So, let's take a closer look at the structure of this file. There's a few things that should interest you about this file, right away. First is the initial parameters discussing the size of the tiles that this map expects. The second, is the number of vertical and horizontal tiles used. For instance, the width parameter here defines that this map is 100 tiles wide. Of course, the total size of the map, in pixels, is width times tile width or 64 pixels per tile, given you 6400 pixels. Secondly, you'll notice that there's a section devoted to what atlases this map uses, called tilesets. This section will list for each atlas, the image location, given the absolute path from the editor as well as the width and the height of the input images, any particular names or properties that you've attached to the atlas, and most importantly firstgid, which we'll get into in a minute while we're parsing our layer data. Finally, we have a separate section of the JSON file devoted to the layers that you've defined. Now, each layer that exists has a data element, which actually lists out a large, very large, ludicrously large array of integer values that represent each tile that you've placed on this layer. Of course, this layer also has other properties like the height in number of tiles, as well as the opacity, and then any other information like the name and whether or not this tile is visible. This type parameter is also interesting, because tiled allows you to have both tilelayers and object layers. Of course, this layer you're looking at is defined as a tilelayer. Now let's take a little deeper look at what is contained inside of the data array. Now, if you recall, each layer is actually a large two-dimensional grid of tile data. It's listed here in the JSON file as a single integer array. Effectively, this is what we call raster scan order, where each row is listed in the file after the previous row, linearly. The value of each element in the data array actually has significance in itself. First off, if you see a zero value that effectively means that no tile has been placed in that x,y position inside of this layer. Any non-zero value represents a tile index for a given atlas. Now, this is where things start to get a little bit tricky. Now, if you recall, this little element here, first GID, that exists for each atlas that's listed in our tile sets array. Now, if a zero value in the data array for a layer, it means that there is no tile there. That means that the first element to represent that a tile does exist must start with one. Each atlas that exists inside of the tiled file will have an increasing first GID. Now, tiled has its own heuristics on what the first GID should be for each subsequent atlas that's loaded. We won't get into that other than to say that you need to know what this number is. So, what we see here is that if we have a value of 167 in this data array, and the first GID of the atlas starts with 1, this effectively means that 167 is the first atlas, tile number 166. Now, this makes a little bit more sense once you start getting 4 or 5 different atlas layers on there. Right now, it may seem a little bit [unknown]. The larger issue that you have to run into is what does 166 actually mean. Now, recall once again that the atlas that's being given to us is in raster scan order as well. So, the value of 166 is actually the raster index into the 2-dimensional array. With this set up, computing the coordinates for the atlas simply involves mapping the tile size to the right offset inside the atlas itself. Loading these TILEDmaps is actually a pretty complex process, so we're going to walk through it piece by piece. First, to parse the JSON, you'll notice that we've actually modified our load function call to call parseMapJSON with the data we get from our xhr request. Now the data we've received from the internet is actually a JSON blob. The first thing we need to do is actually call JSON.parse, passing the JSON blob, to actually give us an object in Javascript. Next, what we'd like to do is to actually cache some of the values of this new JSON object inside of the map class itself, so, we don't have to keep walking through and querying that data object later on. The parameters we care about keeping track of right now are the total number of tiles crossing down in the atlas. The size of each of those tiles in pixels, and then the size of the entire map in pixels. Now, once you've retrieved that data from our JSON object, go ahead and set the fullyLoaded attribute to true. Basically, all we have to do is once we have the map object, we go through and cache width, height, tile width, tile height. And then, we actually compute the pixel size of x and y by multiplying the number of tiles times the tile size. Once this is done, we can actually set fully loaded to true allowing any external processing to work on this object. Now, the second step of parsing our map involves loading all the tileset data described in the file. For each tileset, we need to create a new image, set a call back function for once it's loaded, and then set the source value to the tilesets image attribute. This is the same basic image loading process that we've been using previously. It's worth pointing out now, that we're kicking off asynchronous loads of images for our map data, which already has been asynchronously loaded. As such, we may want to actually wait on setting the fully loaded flag to true until after all the images are loaded. To do this, you'll need to use a counter variable to keep track of how many images have been loaded, and only set the fully loaded flag to true once all the tilesets have bee successfully loaded into memory. Fantastic. The solution for this is pretty straight forward, based upon what we've already seen. Firstly, we walk through all the tile set's inside of the map object that we've created. For each one of them, we've created a new image, set it's on load function, and then set it's source name. Once we are loaded, effectively we increment the imgLoadCount variable, and then we test if the imgLoadCount variable is equal to the number of tile sets that could potentially occur. So effectively, we are saying that our number of images loaded equal to number of images that exist. If so, we can set fully loaded to true. Now, you'll notice one annoying little variants of the JSON format for tiled, is that the image path is actually an absolute path to the file from where the editor and base file were formed. So effectively, what this is saying is that, given the path to tiled, there's some really crazy file path to actually get to the grid's master PNG from the source file we're using. So, to properly load that, what we'd like to do is strip out all of the other data that's not just the file name. And then, append the file name to our data directory. Now, this is because our editing environment may be in a different directory structure than our production environment that users are actually playing. For grids, we use this nifty little regular expression here that allowed us to replace all of the data before the final slash with blank characters, giving us the file name for this image. We appended that filename to the ../data directory, giving us the source. Now we're ready for the final step of parsing our map data. We want to keep track of each tile set that our map loads. So we need to keep an array of available tile sets in our tile map class. Now what you need to do is while we are parsing our tile sets, create a new object and populate the array we just showed you containing all the attributes or our tile set from our data file. For example, first GID, image, image width, et cetera. Finally we'll need push this object into our array of tile sets. Much like loading the map data parameters itself, loading from the tile sets is pretty straight forward. All you have to do is create a new object and set its properties equal to those that are defined in the map objects. For example, first GID, image height, image width, name, etc. You'll also notice that we pass off the image parameter to the one that we actually just loaded in the previous quiz. We also commute the number of x and y tiles for this atlas by dividing its width and height by the tile size defined in the global map object. Now that we have our tile sets parsed, we need a way to find the image and coordinate position of a specific tile in a tile set from our data array. Now to do this, we're going to have to create a new function called getTilePacket. That takes the index value we want from the data array of a layer, and determines an object like you see here. With the parameters of image set to the atlas image, and then px and py set to the x index and y index of the tile in the atlas. To grab the specific tile we want, we first need to lewd through all of the atlases in the tile sets array, checking the first GID of each one. If our first GID parameter is less than or equal to the tile index that we're given in this function, then we know that the tile we're looking for exists in that tile set. Once we have the correct tile set, we can grab the tile set image, and compute the necessary offset for the specific tile we want. Based on first GID, the number of tiles for across and down, and the size of the individual tile. This should be some easy math to determine the x and y value you need. And so here's that code in practice, the first thing we do is loop through each of the tileSets images, checking the firstgid against the tileIndex. Once we find the correct one, we'll break out knowing that i is the proper index. Once we find this, we can set the pkt.img value to equal the image of the atlas, and then we go through and do a little bit of math to determine what the tile offset is. Now, recall that the tile index is actually added to the firstgid for this array. So, 167 as a tile index, is actually atlas with gid1. Tile 166. We remedy this by actually subtracting the tileIndex from the firstgid, giving us localIdx. From there, we can do a little simple math, given the localIdx and the numXTiles horizontally for this atlas to give us to give us our x and y indexes. Once we have the indexes, we can multiply them by the tileSize to give us our px and py. Finally, return pkt, and we're good to go. If you take a look at our JSON file, this is where the layer data exists to describe what we want to draw. First, we need to loop through each layer and then for each layer loop through the tile IDs contained in the data of each layer. Now, if you recall a significant portion of these IDs will be set to zero. That indicates not to draw any tile at that specific location. If the given ID is not zero, then we go ahead and grab the packet information by calling the getTilePacket function, passing in the tile ID that we have. First, probably the most important thing, is that we actually quarry whether or not all the images have been loaded. If we don't do this little step, where we query this.fullyLoaded, then what's going to happen is you can go through your draw function trying to draw image data that hasn't actually been loaded into memory. Of course, you'll just see nothing on the screen but it's generally a good practice to let the entire thing load before you try to start working on it. Next, we actually loop through all of the layers. And for each one, determine whether or not it's actually a tile layer. Remember, we can actually get object layers from the tiled setup. So, we need to make sure that we're only rendering tile layers. From there, we actually create a convenient handle to the data array. And then we walk through all the tile IDs inside of that data array. If it equals zero, we go ahead and continue on because no tile needs to be drawn there. If it's not zero, we go ahead and grab the packet information for this tile. Once you get this setup going, now we can move on to the next part, actually drawing the tile. To do this, requires a couple of steps. First, we need to calculate the position in our game world that we want to draw the tile at. To do this we need to use a little bit of math magic based upon the tile ID within a tileset and the number of tiles across that the entire map is, as long as the xy size of each tile. By combining these things, we actually get a nice little setup that tells us the number of pixels x and y offset from the origin of the canvas to draw this tile. Now, you make that happen. Just like we computed the xy position of the tile index for our atlas, we can use the same math magic to determine what position in the worldX and worldY we need to draw this tile. We change the numbers, right? Given the tile index, we modulate it by the number of x tiles, and divide it by the number of x tiles times by the tile size, to give us our pixel offsets in the world. From there, we go back to our accelerated draw image API, that passes the image, x, y in the source, tile size and tile x in the source. And then, where we would like to draw it in the world X and Y? Notice that the tile size for the source and the destination are identical here. This means we'd actually like to draw a 64 pixel by 64 pixel atlas image, to represent a 64 pixel by 64 pixel image inside of our world. Now, the first stop in your trip to Awesometown starts with the backbone of all old-school graphics engines. How to write a 2D tile-based rendering engine. Now, in HTML5, this starts with a single DOM element called the Canvas Object. So, the first thing we need to know is, what is canvas? Canvas is a new HTML5 element which exposes APIs allowing you to draw graphs, images, and text to portions of the page. A canvas only has two attributes specific to it, width and height, which specify what size this drawing surface is on your page. Since canvas is effectively a large memory blob of pixel data, or bitmap for you Yankees, it closely resembles the memory layouts that game developers have been using for years to generate 2D games. Now, without further ado, let's create our first canvas. What I'd like you to do is grab the canvas element that we've already specified in our HTML page and set its width and height attributes appropriately. The basic HTML for grabbing the canvas object is pretty straightforward. We've seen this before. The interesting thing that we haven't yet covered is grabbing the context of the canvas. Think of the canvas object that we fetched from the DOM as a DOM element. While the context is a handle to the drawing APIs that we'll be able to use to modify the canvas visuals later. In this simple example, we set the width and height to 1200 by 720 respectively. Now, it's worth pointing out, that any time the user would resize the screen, the canvas will remain this size. For the purposes of GRITS, we actually use the window.innerwidth and window innerheight. sizes for our canvas, allowing it to occupy the fullscreen for the user. The bulk of canvas interaction that GRITS uses, is through rendering images to the canvas. In order to draw an image to the canvas, we first have to load it. In order to load an image, we need to create a new image object, which in Javascript, is comprised of three steps. Number 1, is we need to declare the image object. Number 2, is we need to define its onload function. Then number 3 we need to set the image.source attribute. It's worth noting that as soon as the source property if this image is set through a value Javascript will kick off onload function. Because of this, we need to specify the callback function first before setting the source attribute. Otherwise the image will load the data and we won't get a callback received. Now let's take a look at this code. Here is the url of the image that we'd like you to load. What we want you to do is create a new image object, following the steps we just mentioned, and set the onload function and source properties for that image described in the code. Make sure that your onload function is assigned to this onImageLoad down here, which will actually print out some nice little message to the console log, letting you know that things have loaded properly. If you're confused about whether or not your image is loading, don't forget to check out Chrome's developer tools on the network tab, which will list whether or not the image has been loaded, and how long it took to do it. Good job. Now, as we noted before, loading an image is comprised of three steps. We actually declare a new image object, then, we specify the function to be called when the image has been loaded and finally, we set the source of the image itself. Down here, we specified our onImageLoad function, which simply prints out a statement to the console alerting us when this image has been loaded. Now that we have a loaded image, we need to draw that image to the canvas via the canvas.drawImage API. This function takes the image object itself as well as the locations on the canvas that we'd like to draw that image. As you can see, there are some other parameters that drawImage takes. Don't worry about those just yet. For now you can leave those blank. By the way, if you are ever interested in finding out more about an API for HTML5 development, make sure you check out webplatform.org. It's a nifty little space where all your questions can be answered. For our next step, why don't you go ahead and fill in the onLoad function that we defined earlier. So that rather than logging a message to the console, instead, it draws the image at pixel location 192 by 192. We were able to look at the documentation and see that context.drawImage allowed us to pass in the image object as well as the position on the canvas we'd like to draw, 192 by 192. Before we move on let's cover an important topic about canvas drawing, coordinate systems. Now we draw our image at location 192 by 192. Which as you can see placed the top left corner of the image, 192 by 192 pixels up from the top left corner of the canvas, which has been conveniently placed at location zero, zero on the page. That is to say that on the canvas, the origin of its coordinate system, i.e., the location of it's zero, zero, is in the top left hand corner. Any drawImage functions will follow this coordinate system and place the top left hand corner of the image at the location specified by the drawImage call. So let's take a quick moment and talk about something else that's very important to game development: what format your images are in? Now typically on the internet when you find photos or pictures of cats just floating around on random web pages, it's actually in a JPEG format. JPEG was developed some time ago by a joint efforts group from some of the industry's largest contributors. Now when I say a while ago, I actually mean back in you know, the early days of the internet back when Al Gore still rode the Moon Worm through the plains of Handedoff. Another type of image format that you can use on the internet today, is actually one called PNG. Now where JPEG gives you better size comparison, PNG lacks in that department. However, PNG does give you one important feature: transparency. JPEG itself gives you better compression formats but doesn't allow you to use transparent pixels in your scene, which means the general rule of thumb is if you have an image on the internet that doesn't require it to be transparent you should probably be using JPEG. If it requires alpha you need to be using PNG. Now the cool thing about the internet is that it's always moving forward and new technologies are being developed every day to make the experience for end users better. Besides JPEG and PNG, there's a new image format coming down the pipe called WebP. WebP offers and interesting ground. First off, it has compression ratios similar if not better in some cases than JPEG but also allows you to have alpha transparency supported by PNG. Therefore we have with this new image format the ability to get good compression and alpha transparency where we need it. Don't you love the internet? Now we'd like you to write this flip book animation style in code. We've given you a list of image assets to use for "Evil Devices". What you need to do is load all of these image assets and place them in the frame array. After your images are loaded, you should go through and fill out the rest of the animation function here, which will actually draw the flip book animation images to the screen as we described before. Make sure that when your animation is finished you loop back to the beginning. Now before this you need to have some logic that checks for whether or not the images are loaded, and once all of the frames have been loaded, actually does a call to setInterval. Now setInterval takes as input a pointer to a function you'd like to call as well as a millisecond count on how often you want it to be called. So, for instance, if I made a function and wanted it to be called once every 30 milliseconds, those would be parameters that I pass into it. Make sure that your setInterval call, actually calls the animate function, once every 30 milliseconds. Lets take a look at the solution to this its a little bit tricky. Firstly, at the top of our file we declare two new variables, frameRate and frame. Now, frameRate represents how often we'd like to actually call the animate function. Frame is a variable that we're going to use to represent what the current frame in our flip book is. Since we already have our frames array available, the next step is to actually loop through our predefined assets, and load each of the defined images into the frames array. This follows the same 3 step process we saw before: create a new image, set its on load result, and then set its source. Once this is done we can actually call this setInterval function, which will call the animate function at the frameRate that we provided before. Now the animate function has a little bit of tricky logic inside of it. First off, we have our frame counter that we've defined. We use this to define what image out of the frames array we have to draw to the canvas, and of course, at our lovely position of 192 by 192. Once we've drawn the current frame we actually have to increment it, and that's where this little nice piece of math comes along. What we do is increment the frame counter and then modulo it by the frame's length. What will occur here is that if frame ever becomes longer than frame length, the modulo function will have it loop around back to 0 without us having to have all the other if statements involved. This is a nice little piece of math that you should put in your code. Your employer will be impressed by it. Now if you followed all the code, you should see something like this running around on the screen. If you'll notice, something of this doesn't exactly look right. You actually get each of the frames drawn over each other, creating this sort of halo effect. There's a reason for this. It's worth noting that the canvas doesn't actually clear itself each frame. Instead it allows you to just keep piling pixels on it as you go. In order to get rid of that ghosting effect, you have to put this line that we've conveniently left out of our previous function back in, and that is context.clearRect. What this will do is actually clear all of the pixels to some default value allowing us to draw back on top of it. So you won't get the previous images actually drawn on top of each other. The result is a nice, nifty walking robot running around on your screen, just like it should. The result with clearRect is this nice, fancy walking robot. Now, back in the early 90's, specialty hardware was used to get smooth graphics on early machines. Things like the NES, Genesis, and Gameboy had custom hardware that was built into the form factor that was allowed you to draw tons and tons of tiles very quickly on modern screens. Now desktop computers at the time didn't have that much power, in fact, they didn't have any of that specialty hardware at all. Modern desktops around that time running at 33 hertz were considered top of the line. Now, one day a young John Carmack made a demo called Dangerous Dave in copyright infringement, which actually showed off a Super Mario Brothers 3 level running at full 30 frames a second, on desktop hardware. He showed that demo to a young John Romero and that very day ID Software was born. The same studio that went on to actually create the first person shooter genre with titles such as Wolfenstein, Doom and Quake. Now, the trick that Carmack realized to get the same performance from the specialty hardware on the desktop, was actually an optimization. See, these early machines weren't too good at actually copying pixels over here to over here in memory. It was actually a pretty difficult concept, especially with the bitmap colors and everything. But what they were good at was actually just copying rows of memory from different registers. So what Carmack realized was that he could use the previous frame and somehow just use meme copies to sort of shift it, so that it looks like the scene is actually scrolling. They need to be able to only have to update the small portion of the screen that changed as your character was moving. Thus was born the concept of "Dirty Rect". Now, this is the same concept that's been used today in tons and tons of games. See, that's the trick with game industry techniques like this: they never really die, they just kind of get rebranded as technology evolves over time. Alright, now we're getting into the good stuff. We've got the ability to draw things on screen, move them around with user input and actually draw a map. So it's time to get into the really core of game development. We need to start actually giving thought, work and automation to an environment and that starts at the top with the all encompassing concept known as an entity. In order to support all of these related types of entities, we need to ask ourselves what properties do we want all entities to support? Does an entity need to keep track of its position in the world? To know when it's time to die? To think or be able to do something each tick? To know what sounds to play? Or post to your Google Plus Stream? Please check all that apply for all entities. Note, we're not just talking about one entity, we're talking about all entities. First, to keep track of its position in the world, that's correct. All of our entities in grids, need to know what position in the world they're at for a number of reasons, like physics, collision and rendering. What about this, to know when it's time to die? this is actually not required. Not all entities have a concept of time, nor have a concept of death. For instance, landmine entities only live on the map for about 30 seconds. As such, they need to know how long they're staying around in life before they explode. Other entities like these spawners, which will actually generate energy canisters and health canisters, never die. So they have no concept of life or death. They stick around until the map is unloaded. What about this one? To think or be able to do something each tick? This one is definitely a requirement. The definition as an entity as we've discussed before, is that you have a class which contains some unique logic, that makes this entity different from all the other ones in the world. The ability to think or have custom processing associated with an entity, is critical to its definition. How about knowing what sounds to play? this is a little vague. Some entities will need the ability to know, and play sounds during events. For instance, when a rocket hits the wall, we would hope that it plays its explosion sound [SOUND]. The player for instance, may not need to know any sounds, because the environment is making sounds on their behalf. And finally, what about the need to post to your Google Plus Stream? this is more of wishful thinking on my part, but in reality you shouldn't be coding in the ability to do HTTP requests to each one of the entities in your game. Although, you should definitely check out this place, I hear it's cool. Now there was a very early time in my career where I learned a very valuable lesson. I had just finished up an internship with a great game studio called Petroglyph Games and I was actually on an on site interview for a new company. I got into a light debate with someone during one of my interviews about what things should be named. More specifically, we were describing what an object is that walks around in the world. Unfortunately, I probably got too deep on that conversation, and it turns out that I was actually arguing with the technical director of the project over a naming convention. Needless to say, I didn't get the job. The point was this, as game development goes on lots of people have lots of different names for things. You just spend less time worrying about what something called and more time worrying about what it does. Now pretty much every game architecture out there is going to have some encompassing object that has logic associated with it that may or may not have a visual representation and may or may not actually be represented on the server. This is a basic object that every game has. You can call it an actor or an entity or a jabberwocky, for all it's concerned. Trust me. Worry less about the nomenclature of what things are called, you'll get more jobs that way. So now we need to implement the basic entity class with the properties mentioned before. Please fill out the provided code to create a basic entity. The basic definition of an Entity Class is actually pretty bare bones. As we talked about in the quiz, all entities need a position variable to reference where it exists in the world. This is going to be used in the future for things like collision and rendering of our visibility. We'll also need to know the size of this entity and there's a couple reasons for this. Number one it's important to know the size of the bitmap that this entity represents, 32 pixels, 64 pixels. But it's also important to know the size for physics calculations. Some objects are bigger than others. And keeping that data around is going to be important for us later on. And finally, in our bare bones Entity Class, we actually define an update function. This update function will be called by a larger game manager class, about every frame. Allowing any given override-ed entity to have a time slice in order to do execution. Now with our basic entity type defined, we can use it to create various overloaded types of entities based upon our need later in the game. In order to spawn an instance of one of these entity types, we provide a spawn entity method, which takes a string, containing the desired class type name and returns an instance of the appropriate entity object. I'd like you to fill out this spawn entity method to handle creation of these example entities given the appropriate strings. Thanks. Now let's take a look at this. Simply we can take in the typename and have a series of if statements checking the typename against a given class name that we're interested in. If we find a match, we can return a new instance of that class out from the spawnEntity function. Now this works, technically, but there's a problem. What if we have a dozen types of entities that we might need to spawn, or, 50, or even 100. Real time strategy games for instance contain many different entity definitions. Writing out a spawn entity function to represent all of these items would involve a large case statement that wouldn't really scale well for programmer maintenance over time. For instance, if a designer wanted to add a new type of entity, they'd actually need a programmer's help to do it, to go in and add a specific line of code for that entity type. The problem is further visible if you consider code maintenance. Adding reference to class definition throughout your code basis is just asking for problems. To address this issue, we're going to take advantage of an interesting property in JavaScript. Namely, that we can create a new object given a handle to its definition. To allow this, each overloaded entity definition will update a hash table with a pointer to its class definition. Once we have a hash table entry between the string name of the instance class, we can then use this instance to create a new version of that class. Remember that in grids, map development is done through a program called Tiled which allows our content creators to place objects in the world, and set their type via a string. This means the data that we'll be receiving from our map definition file, is a list of objects with a string property representing their class type. Our code needs to be able to react to this by using the hash table that maps these string values to the class definitions they represent. What this means is this previous definition of spawnEntity function needs to be replaced with a nice healthy reference to this factory object, and use it as we've defined. The resulting code is much cleaner, easier to maintain, and simpler to understand. We have our factory class that's been defined at top. The spawnEntity function still takes a string that contains the typename and the class definition. Which is looked up against the factory hash table that we previously filled in with the class. This is all used together to create a new instance of that entity object that's returned from spawnEntity. Now, there comes a point in every game developments life where content creators, artists and designers, become very frustrated with the engineers on a project. You see, most novice engineers for game dev, when adding artwork and content into a game, will usually hard code the path references to assets. Which means that if a designer or artist, wants to change that data, they have to go talk to an engineer first. Which, engineers usually have a back-log of 30-60 days worth of tasks, kind of slowing down the entire project. More experienced engineers know how to avoid this and actually move themselves towards a concept of data driven design. A concept which allows non-engineers to effectively change the execution of the flow and the assets in the game without ever having to talk to an engineer. Basically this works by providing some sort of simplistic data file outside of the game code, a text file, XML, JSON. Something that the designers and the artists can quickly iterate on without having to talk to anybody in the pit. Case in point, let's say a designer and an artist need to find the optimal animation time for some kick maneuver on a 2D fighting game. Well, it'd be great if they could actually sit at the desk and try different variations of art creation and timing without actually having to go talk to an engineer to change the frames that are referenced. Most games these days actually have a huge backbone of data-driven design. Of course, you end up in a very, very weird position is that if you have too much data driven design you actually become a slave to it, in the sense that most of your code exists out there. So changing small situations becomes very, very difficult, and you actually have to bring an engineer back in. So walk that line very finely. You want to be just data driven enough that it makes sense and everyone can get their job done, but not so much that it actually causes problems to your larger architecture. Now that we can spawn entities, we need to keep tract of them, update them as necessary, and kill them off when they refuse to comply with our wishes! In order to do this, the game engine keeps a list of active entities that it can then use to iterate over during our update and render functions later. Implement the functionality in the given code calling each entity's update method in the given function. The solution for this is pretty straight forward. Using a for loop, we can walk through all of the entities, inside of the entities list, and call the update function for each one. Note that with our setup, this call to an entity's update function, will allow each entity's unique logic function to be called. For example, the landmine update function will check against a timer, each frame, to determine whether or not it should blow up. While self-destructive in nature, this type of functionality is the backbone of our gaming system. [SOUND] Now the game engine is capable of updating all live entities, but it's calling a blank update method on each entity class instance. We need to fill in each entity's update method. But this might be a little too involved for a quiz. Let's instead, look at a single sub class of entity. The landmine disk class represents a landmine that's been placed in the environment, waiting for an unknowing robot to walk on top of it. We have a couple properties that make this possible. First off, is the landmine disk actually defines a lifetime of 100 units. Secondly, is we override the kill function for the entity. To remove the physics engine body as well as the entity itself once this landmine is dead. Your job, if you choose to accept it, is to fill in the rest of this update function where we subtract 0.5 from the lifetime each update call, and then once we reach the bottom we call the kill function and return out. As you can see the update function is pretty straight forward. Each time is called we subtract 0.05 from the life time of this unit, and if time becomes less than 0, we cal the kill function and then return. It's worth pointing out once this unit has killed due to the other code we've aleready written. It is removed from my larger entity processing loops, so that update no longer be called in the future. It's also worth noting, at the end of the update function, we call this dot parent. This will allow the entities update function to be called, after we've done our local update. With spawning and updating entities taken care of, the last piece of the puzzle is figuring out how to remove entities that might be dead. For instance, if a rocket will hit a wall it should be removed from processing. To accomplish this, we add a flag to the entity class that defines whether or not it has been killed. Dead objects will not update or render while this flag is set, well of course unless their zombies. As an exercise, let's update the game engine update function to check for this flag, and not call the update of any entity that's been marked as killed. As you can see, the solution is pretty straight forward. All we need to do is add a simple function, that checks whether or not this entity has been killed, and if it hasn't, call the update function. To understand this a little bit more, let's take a look at a very unique scenario. Let's say we have a happy, little tank trudging along through a war zone. The tank randomly fires a bullet into the air, which is actually aimed at a bunch of little enemy soldiers camping out in the environment. The tank itself has a small amount of hit points, say three or so. And the mortar in flight will actually destroy all of these awesome little enemy soldiers up here. The question for you, then, is this. Which updates first in your update loop? Let's say, for instance, the infantry update first. Well, this frame, the infantry, will shoot at the tank and kill the tank, and then the bullet will update, killing the infantry. This would actually create a level playing field. An alternative scenario, however, is what if the bullet updates first? The bullet would actually kill the infantry and they wouldn't have time to update and kill the tank. In this solution, the tank itself will actually be pretty happy trudging along through the war zone. Now, there's not really a good pattern to attack all this. Most networked RTS games actually allow this to occur quite blindly, and simply ensure that all the clients in the simulation have the same ordering of entities. This ensures that one client doesn't update infantry then bullet then tank and the other one do tank then bullet then infantry. I've also seen some games take a different approach to it, in a bucketized manner. So, for instance, you may go ahead and bucketize and say that all of your infantry update first, and then all of your tanks and then all of your bullets. If you ensure this grouped ordering of entities this allows you to have the infantry get the upper hand on tanks which gets the upper hand on those evil, evil bullets. With this layout the infantry would update first, killing the tank, and then the bullet would update this frame killing the infantry, leaving a level playing field for next frame. Now that we understand the problem we need to write some code. First, add a deferredKill list to the game entity class. Then, as you walk through the entity's list, add any killed entities to the deferred list. After that, we walk through the differed list again removing all elements from the original entities list. Once again the solution is pretty straightforward. If an entity is alive, we call its update function. Otherwise, we push it onto the deferredKill list. Once the entire list has been iterated, we are then free to walk the deferred list again. Erase any of the entities that are referenced there from the original list, and then of course at the end, we clear the final deferredKill list, so that we don't try to delete entities that don't exist anymore. Now let's update the EntityClass to support this additional properties. First, we're going to need to add a current sprite name string variable to the EntiryClass. As well as a draw function which uses it to fetch the app's information from the sprite and called Canvas.drawimage. The solution here is pretty straightforward. First, we add a currSpriteName to our EntityClass. If this is defined, we actually use this sprite name to call the drawSprite function that we defined previously. This will take the sprite name looked up the proper values in the [INAUDIBLE]. And then draw to the map. What we provide here is actually a position for where this sprite should be drawn in the universe. Again, recall that we actually use an offset of half size of the entity in order to center it around it's location, rather than having the origin be the top left hand corner. You'll soon notice an issue with our setup. If we walk through our entities and render them in the list as they've been allocated, then we get into situations that some objects will render above or below other objects, which may cause visual issues. For instance, explosions should draw above everything else. But with our current setup, this won't happen, depending on how our entity list is sorted. The classic solution to this problem is to introduce a z index property to each entity, that describes in what order an object should be rendered. If we assume the map is at z index equal to zero, then our engine will draw entities with lower z indexes first, such that they appear underneath objects with higher z order values. Once we've added the z index value to each of our entities, we have to modify the game engine class's draw function to take this into account. So, looking at the code here, first, our draw function will, of course, go through and draw the map. Then, as before, we walk through each of our entities. And if it's within our viewRect, we render it to the screen. Now, your job is to figure out how to modify this code Sort of we properly reder zindex into account Now your solution may be a little bit different than ours, so let's take this into account when walking through this code. Now you'll notice that the full range of the indexes aren't actually used inside of grid. We allow, for instance, a z index value to be between 0 and 100. But in reality we only use about 10 or 11of them. But, the values we do use are actually scattered across the number line. You have a bunch of them in the range of 20, some of them in 50, and then some of then in 90. The naive approach to this solution would be to actually Create a simple for Loop, that would represent, and count through, each of the Z index values, searching through the array, for any entity that has that value, and rendering them. Rather than wasting the CPU cycles, reiterating over the list, grips employs a bucketized method. What we do, is if an entity is visible given our view rec, we'll actually go through and place the entity, in a bucket, based on its Z index value. Much like the hash table we used before with the entity class map. So, if we find that the zIndex for a given entity already exists in our array, then we simply go ahead and add that entity to our array. If we find that the zIndex for an entity does not already exist in our array, then we go ahead, create a bucket for that zIndex, so that future entities that have that same value can be sorted appropriately. Once that's done, we go and ahead and assign this entity to its proper z index bucket. Afterwards, we have a simple sorting function that will sort the buckets by their z index value and then iterate over the buckets, drawing each entity in turn. You know what I'm a big fan of? Atom-atons, you know, self-thinking robots running around doing chores and all that stuff. Of course, if they have the ability to think for themselves, they're probably going to get into some trouble? Nah, we'll worry about that later. Anyhow, entities are a fantastic concept, attaching logic to units is the backbone about how your simulation is going to exist. Now, don't get too far down the rabbit hole here, entities bridge the line between design and code. So, at every step of the way, when you add features, you're going to have to negotiate between how much of the control is on the designer side and on the programmer side. So, make sure when you're designing your framework, keep both parties involved. Hi, I'm Sean Bennet - Course Architect with Udacity I'm Colt McAnlis - Developer Advocate at Google I'm Peter Lubbers - a Program Manager at Google. Now HTML5 has a rich suite of functionality to build amazing experiences on the web. This course is about leveraging those tools to build fun engaging games. Now Colt here is going to be acting as our game expert Hi I like games! And Peter is going to be acting as our HTML 5 expert. I love HTML 5. Now there are two different ways you can enter this course. If you're not already familiar with JavaScript or modern browsers, then we have an optional JavaScript crash course for you to take. Now if you're already familiar with all of that, then you can go ahead and skip that. And go straight to our canvas unit. Can't wait to see you in class! In order to interact with our robots moving in the environment, we need to capture the input from the user and react to it in proper fashion. For Grids, we have two primary forms of input. Number one is keyboard, where we use the w, a, s, d keys to actually allow our robot to move around and get into all sorts of conky trouble. In order to shoot, we allow mouse input for your player so you can actually see that as I move the mouse, the little mouse cursor moves. We don't actually rotate the upper body of the robot until you actually fire though. So you can see that as the mouse moves around, my projectiles are of course following it in suit. This allows the player to move as well as shoot at the same time. Now for those of you out there that do most of your gaming or programming on a laptop, you probably don't have an external mouse. We've also allowed the ability so that you can play Grids as well. And for that, rather than actually aiming your robot to shoot at things using the mouse we allow you to use the arrow keys. So that pressing in the specific direction will shoot in that direction as well. And, of course, combinations of keys will allow you to shoot in diagonals. Now, fair game play has always been a requirement of multi-player games. Although, it didn't always start that way. See back in the early 90s, video game players were actual able to tweak some of their perimeters to get an unfair advantage. Quake players, for example, would actually lower their resolution on the graphics card to lowest quality setting, reducing the amount of processing time required to process a frame, so they would actually get higher frame rates. Another good example, that I'm not really, you know, bitter about, or anything, was my Quake clan actually lost the last round of a very expensive tournament because all of us were on dial-up while the other team was all on DSL. Again, this was back before cable modems, again, not that I'm bitter about that. The point is, that unfair game-play makes it bad for everyone and then makes bitter people get bald. Since then, multi-player games have actually done a lot to reduce this kind of cheating and unfair advantage, but it is something that we had to worry about Inside of GRITS. See, if you're actually using mouse controls, you have a lot more degrees of freedom because there is more resolution to it than someone who is playing on a four pad keyboard. We decided to actually attack this for GRITS because some of us were bitter about losing unfair games in the past, and actually lock the mouse to the same directional output that you get from a keyboard. Ensuring that both players actually have a same and fair chance to play. Now, your designers should mostly take care of this, but if you're one of those types that likes to design and program make sure you start from the beginning worrying about fair game play. Or you can create someone like this. Now, in order to understand how we obtain input from the user, it's best represented in a simple analogy. Newspaper subscription. For instance, newspapers are printed every day with a rich set of data that I don't have access to unless I willingly subscribe to, or receive, that paper. Input handling in HTML5 is a lot like that. In JavaScript we have the ability to subscribe to this input data, such that when an event occurs, a block of code will be called. To get started with this process you need to tell the browser that you'd like to subscribe to a certain event such as On Click, On Mouse Move, or On Key Down alongside what function you'd like to call when that event happens. Let's take a look at the code. You can see here that we grab an element from the dom named pLubbz, for life, and add an EventListener to it from mousemove. What occurs is that when the mousemove event happens on the dom object the onMouseMove function will be called where we've previously defined onMouseMove before this declaration. Now for this next task, what we'd like you to do is actually hook up mousemove and keydown to proper listener events. So that we can receive and then respond to those two actions appropriately. Now remember, the proper syntax to add an event listener is as such. Make sure you utilize this while filling out your code. Now for mousemove, the event object itself will contain two properties that you'll need to use. The client x and client y values represent the position of the mouse on the canvas itself not on the webpage. So make sure you take that into account. The onKeyDown event, instead of containing a clientX and clientY, contains a keyID property. So let's take a look at the solution for this quiz. As defined before, we can go ahead and add the event listener objects to the canvas element for our document specifying the mouse move and key down events. To be given these functions. Looking at the filled in code, you can see that things are actually pretty simplistic. The event itself actually specifies client.x and client.y as member variables that we can then query and print out to the console log. The onKeyDown event, in contrast, is given a similar event objects, but rather than having the client.x and client.y variables it actually has the keyID variable. Which specifies the ASCII value of the key that was pressed on the keyboard. While it's tempting to respond to the input event inside of the event hamper, it's generally considered bad practice to do that. Now to get a better understanding of that, let's look at this representation of a frame over time. Our green boxes represent the update of individual items that exist. And the red boxes represent the rendering of those items. Now, let's say, for instance, the user hits their keyboard which would move the player around. And, let's say, that our engine actually gets that call back right here. So, our updating of the player in a specific position has already occurred, including physic engine processing and everything else. While our rendering will now be pulling data for a new position in the environment. Now what this particular instance can lead to is an interesting phenomena. This makes a disjoint correlation between our update loop and our render loop. We can actually be updating our environment with the player at this position. Yet rendering with the player at this new position. Now while all this may seem minute in a 30-frames or 60-frames per second environment. Things get a little cooky once you start factoring in network physics which hopefully we'll cover a little bit later. In practice the events come out a little bit like this. So, let's say we have a timeline of events that are going to be passed into our application. In a timeline that represents our update loop. Now what occurs is that we're not really sure when the events are going to come to us from the browser. They can occur [SOUND] pretty much any time [SOUND] they want. Now, what happens is, if we respond to them in turn, we're not going to have the ability for our update system, or rather, our game code, to properly be able to react to them. And so what we do is actually store the input event data inside of our input manager. So that the update loop, or game code, can query it whenever it wants. The keyID property is going to represent the Ask E value of the key that was pressed by the user. For this next quiz what we'd like you to do is exercise what we've talked about in action. You need to create an element array of 256 named keyState, whenever the user presses or releases a key you should mark that state in that array. To do this, make sure you utilize the code that we've already written. For capturing and hooking up the listeners for KeyDown and KeyUp. Finally, inside of the update function, make sure that you're querying the keyState to determine whether or not you should or should not drop the beat, in proper fashion. So let's take a look at the quiz solution. First off, you should be able to define a key state array of 256 elements wide. Again, this represents the potential key input from an ASCII keyboard. In addition to that, we already had the key down event listener attached. You had to simply go through and add the on key up one. To properly cache state into our array, the key down and the key up event handlers simply needed to use the key ID variable of the event input, and set the state to either true or false. And then in the update function, as we see, nothing really changed except dropping the beat. Key mapping is a technique that game developers use, to allow players to customize their experience in playing the game. So for instance, if they don't like moving around using WASD, they can shift over their controls to use the arrow keys instead. Now looking at the grids controls, we can see a number of different potential input methods that we need to keep track of. For example, we can move around with WASD, but we allow two different variations for how to shoot. So at some point in the future, we may have a need to change how our keys are laid out. This means, that somewhere in our code we need to have the ability to variably modify what key corresponds to what action. Now looking at the code we just wrote, what we really want to do is change this from querying the value of KEY.W to move-up, which is the actual game information we care about. In order to do that, we need to bind keys to events in our game engine like so. In order to enable this functionality, what you're going to need to do is to modify the input manager class just a tad bit. First thing, what you'll need to do is actually add a bind function. Now the bind function will need to take the key value, and attach it to the action, via the bindings dictionary value that we placed up here. Secondly, you'll actually have to modify your onKeyDown and KeyUp events, such that the keyCode actually modifies the state in the array. Now, we've left these two functions as exercises for you to figure out. Good luck. Take a look at this simple exercise. The solution is somewhat straightfoward. The bind function will take the key value that we're given and map it to an action string that we define before. The on-key down event will then need to do something a little bit different too. It will actually have to look up the action value given the key code through the binding system and then mark the action as true. If the code hasn't actually defined the action, which is possible, this block of code won't be executed. Thus saving you from any sort of weird out-of-bounds errors or code being executed that doesn't actually exist. Because all of our entities are simulated using physics bodies, we lack the ability to simply move our player to our desired position. This type of teleportation can cause issues with your physics environment, mainly, teleported objects ignore physics calculations until after their teleportation has been resolved. For instance, if we move the player to a teleported position which is intersected at the wall we could potentially get stuck there. And then confuse the PhysicsEngine on what to do next, since the player is, of course, stuck. As such, rather than teleporting the player we need to update it's velocity such that the PhysicsEngine moves that unit to where we want it to go, next update loop. Now all of our players actually have an mpPhysBody variable. This physics body is given to us on the instantiation of the player, by allocating it from the PhysicsEngine. Since we can't set the physics body position directly, due to teleportation issues, what we do instead is a little bit of a workaround. We take advantage of the fact that the PhysicsEngine is going to update all of the physics bodies that it owns every frame. The physics bodies themselves allow you to define a velocity vector on them. When the PhysicsEngine updates, it adjusts the position of the physics body by the vector, moving it correctly. We, in GRITS can take advantage of this. By supplying a velocity vector that will move our physics body to the position we want it to be in. Avoiding the teleportation issues. Now directly, the physics body itself exposes a function that allows us to set a linear velocity vector on it. The trick here however is properly constructing this velocity vector such that it does the right thing as the physics engine is moving. Now your job during this next quiz is to properly fill in the move_dir vector with input from the user. Such that setLinearVelocity will do the right thing over the next few frames. The solution is something that we've seen in the previous examples. In order to update the move_dir vector, we query the state of the move-up, move-down, left, and right actions. And adjust the movement vector accordingly. Once this is done, we can test whether or not the length of the vector is equal to 0 or not. This gives us the ability to determine if the user's even pressed a key. If the user hasn't pressed a key. Then the length of mov_dir will actually be 0. We can test this with the LengthSquared function. It allows us to then only call normalize or multiply when a user has pressed a movement key. And of course all of this data after being computed gets funneled into setLinearVelocity so we can move our fancy awesome robot into the future. Now that we have the ability to move the player around the world using keys The next step is to figure out how they actually fire their fancy missiles towards the other robots. Now the fire projectile from one awesome robot, towards the other evil robot, we have take into account just a teeny bit of math. Firstly, for mouse input, we need to find the directional vector that represents a line from the robot location to the mouse cursor in game space. To do this, we simply subtract the mouse position from the robot position, giving us an unnormalized vector. We can normalize this vector and use it to define the velocity path for the projectile, fill in the code, as specified. To calculate what direction we're firing, the first thing we need to do in our update code, is figure out whether or not the user has pressed one of the fire keys, fire0 or fire1. Once they have, the next step we need to do is figure out what the player's position is in screen space. Our render engine actually defines a function called getScreenPosition. Which will actually project a world space position into the canvas screen coordinates. What this means is that we'll now have the player's position in the same coordinate space as our mouse input. Because the two are now in the same space, we simply need to subtract the mouse input from the player position to give us an unnormalized vector. A simple normalized will give us a unit length vector. And we can now use the directional vector as basis to launch our projectile towards the other evil, evil robot. Because grits is an equal opportunity fragging environment, we need to allow players without mice to be able to still compete in our environment. This means, that we need to allow them to shoot with keyboard controls, as already mentioned. The code for this is very similar to what we've seen before. For example, we need to simply go through and pull the key state of our shooting directional keys, to create a directional vector that we then use to launch projectiles. Your task is to fill in the supplied code below, to sum up the keyboard input, and normalize the resulting vector. Hopefully, that one was pretty simple for you. Again, we're pretty much duplicating the same logic that we've used before with moving the player in the environment. The only difference is that we're actually sampling a different set of actions for firing upwards, downwards, leftwards, and right. Now, as you can see, keyboard input only allows firing in the cardinal and ordinal directions from where the player is, i.e the red and black arrows here. With this, players using mice as an input would get an unfair advantage. As you can see where the cursor is here, a mouse player would be able to shoot in a direction and at an angle that keyboard players wouldn't be able to use. In order to level the playing field, what we do in GRITS is eliminate that advantage by snapping the firing vector to one of the eight directions that keyboard controls allow. So, if you click where the cursor is now, it would go along the right-up vector. Each of the shaded regions corresponds to only one firing vector. We started out the unit talking about how important it was to make sure that every player had a fair experience. But an issue is, that mouse players with the current code can actually fire in more directions than keyboard players. So, what we need to do is take the actual mouse input and snap it to one of the eight directions that the keyboards actually have access to. In order to do this, we need to do a little bit more trigonometry. Now, in order to snap the arbitrary directional vector that we're getting from mouse input to one of our eight directional values that a keyboard player can use, we are going to utilize a lookup table. This lookup table is already populated to contain the eight directional vectors, unitized, that keyboard players have access to. Now, the magic sauce here, is taking this arbitrary directional vector and turning it into a lookup index that we can then query against the lookup table. For us, we have a magical pixie of a function, called getQuantizedAngleIndex. Now, I'll spare you most of the math that's inside of this function, because really, our intent is not to teach you trigonometry. The overview is this, we use the atan2 function to find the angle between the input directional vector, and the x positive vector. This gives us an angle between the two InRadians. We then use some nice fun little tricky math here to scale that angle value into an integer between zero and seven. That zero and seven value is passed back and used as an index inside of our lookup table. The result gives us a directional vector that matches exactly what keyboard players can use Now back when the Nintendo 64 was still in prototype, the execs over at Nintendo did a little bit of tricky marketing. They brought in a bunch of reporters, put them in a room, they pretty much had a screen rendering a little character on it, and a little interesting black box in front of them. Now the black box was completely hidden. All the reporters could do was stick their hands inside and fumble around with the controller that was in it. After a while of playing with these things, one of the reporters said that the controllers were so revolutionary, it was like his thoughts were being extended right into the game, which is a great case and point. If you get the controls right, the world plays along with you. Get it wrong and, well I'm pretty sure you can guess what happens then. Now, in this unit, we're going to be going over the basics of JavaScript, and how to interact with a modern browser. Things like manipulating the DOM, accessing JSON and making an XMLHttp request. First thing we start off with is, we create a variable here called Render Engine Class and you define a variable by starting with the keyword var, and then the variable name, and then you say equals, whatever you would like it to be equal to. In this case we use an opening brace, to indicate that we'd like this to be a javascript object. This is the object literal notation, for defining an object in Javascript. From there we can declare methods and member variables of that object by specifying the name of the member, a colon and then the value that its going to take. In this case we declare the method of the name drawString, we use a colon and then we say that this is going to be a function, we use the keyword function to define this and then we give a list of all the parameters and then open the function with an opening brace, similarly to how you would in many other languages. Now, again, we create a variable, name it, and then assign to it, the value of gRenderEngine.context. Now this is going to take the JavaScript object, gRenderEngine and the dot notation is going to tell us that we want the context member of this object and we do something similar down here where we, grab the font member of the ctx object and assign it this value here. Now you notice that we're using addition in strings: addition is over loaded in javascript to also designate string concatenation, again similar to a lot of other languages you might have seen. Next we have an example of an if statement. If statements work essentially the same way that they would in any other language, where you have the keyword if, then in parenthesis you specify the predicate that's going to return a boolean value, either true or false and then the body of the if statement that executes, if that evaluates to true. Now, note that the statement here doesn't have braces around it designating what executes if the if statement evaluates to true. This is similar to some other languages where, if there's a single line that you need to evaluate, you don't require those braces. We use this here there, just for readability purposes. So you might see this in the code. Now for larger f blocks, you can delineate them with a opening brace, and then once they are done, way down here, you close them with another brace. From there we have a number of more examples of declaring and setting variables and then we come to a for loop. For loops are structured essentially the same way they are in C, were we have an initializer value, then a predicate to evaluate for, when the for loop should end, and then an expression to execute at the end of each for loop. And similarly to the if blocks, the block of code that you'd like to execute each time the for loop runs, is delineated by braces. Although again, if it's a single line, you don't require those braces to be there. Now here we see words n where n is in square braces and again, n is the variable that our for-loop is looping over. This is an example of accessing a list, where n is the n-th element in that list. Now, like most other languages, this is zero indexed as well. So keep that in mind. Now one important detail we'll need to understand is how to get our image data that our artists create into our game. For example, the image file name. Also the width and height of the image, whether it's been rotated at all and various other pieces of information we might need to know. Now to do this, we're going to use JSON, which is a very lightweight data interchange format that's based on JavaScript object syntax. Now, since it's based on JavaScript, it turns out that it's really easy to use with JavaScript. Much easier than, say XML. Now, here's an example of a JavaScript object, right here. Now, this is in JSON. Technically. It is the JavaScript object representation of JSON that has been passed in. The difference between a JavaScript object and JSON is that JSON is simply a string that we can then parse to create a java script object. And that's what we're going to do. Now, you see we have a parseJSON function that takes a string of JSON in, and then we're going to parse it using the JSON.parse method that is included in and accessible in just about any modern browser. JSON.parse takes this string, Weapon.JSON in and will return a JavaScript object representing the JSON that it's parsed. Now, once we've done that what I want you to do is grab a specific piece of data, from that JSON. Let's say you want to grab data from the JavaScript object returned from JSON.parse and let's say you put that JavaScript object into the variable "parsed". Now in order to grab the chaingun sub object then you'd simply say parsed frames chaingun.png like so and then put it in the variable chaingun lets say. Now lets take a look up above at this structure. What I would do, it'd walk down first on frames and then in the chaingun and what would be stored in the chaingun variable, would then be this entire structure, so everything inside of chaingun.png. Now what I would like you to do, is grab the x data field inside spriteSourceSize of chaingun_impact.png and go ahead and print that out to the console. chaingun_impact.png isn't up in our example JSON, but the JSON that we'll be running through this function does have it. Alright. So, this actually isn't too much code. So first, what we do is run weaponJSON through JSON.parse and then store the return JavaScript object into parsedJSON. From there, we print out to the console parsedJSON frames chaingun_impact.png spriteSourceSize finally, the x data field. Alright. So now we know how to parseJSON data. How do we actually retrieve that from our server? This is where XMLHttPRequest come in. An XMLHttpRequest allows our Javascript code running in a browser to fire a request off to our server to a specific URL. We can also specify a function call once the server responds to our request. Now, there are a few steps to this. First, we need to create a new XMLHttpRequest object, and we do this using the new keyword, followed by XMLHttpRequest with the parentheses. Now, note that case is sensitive here. Next, we need to call the XMLHttpRequest open method. First, we need to specify the HTTP method to use. In our cases, we're pretty much always going to want to use GET. Second, we specify the URL to call out to. For example, if we were requesting a JSON file, we would specify the file name that we were interested in. Finally, we specify a Boolean value that is set to true if we want the call to be asynchronous. We pretty much always want the call to be asynchronous. Next, we specify the onload parameter, which is a function that we define that gets called once the server responds to our request. Finally, we need to call the xhr.send method. This will actually kick-off the request. Note that we need to do all of these things first, before we can call send. Otherwise, the request might hit the server and respond before we can specify our onload function. And if that happens, we won't actually know what to do with the response yet. Alright, now let's try creating our own XML HTTP request. What we'd like to do is requestWeapon.JSON which is the previous JSON code that we parsed. Then, once the response kicks in, we'd like the onLoad function specified to parse it, like we did before, If you're a little confused, more detailed instructions are provided in the comments here. Alright, so not too much code. First we call a new XMLHttpRequest, then we specify the open method with the parameters GET, weapon.json, and true since we want the call to be asynchronous and then we set the onload function to be our parsing code from before and finally we kick-off the request with xhr.send. Now, if we open this in chrome's developer tools, we can see that we actually do make this request for weapon.JSON, method get and it's successful status, and it takes about thirteen milliseconds. And if we look at the console, we can see that we do actually print out the value of the X parameter that we were looking for before. Now, this is great for JSON, but what if we want to grab something else, say, a sound file. To do that, we need to set the response type of the XMLHttp request object to arraybuffer and what that will do is specify that it is binary information rather than text that we can then decode as necessary. What we like you to do is create another XMLHttp request but this time we're going to request "bg_menu.ogg", a sound file and set the response type to arraybuffer. Now, we've already created the on load function for you to use. Don't worry if you don't understand any of this. We'll be going over this in more detail later in the sound unit. For right now, your job is just to fire off the XMLHttp request. Just a few lines of code. Create a new XMLHttpRequest object like before. We call request.open again, pretty much the same except that we've changed weapon.jsan to bgmenu.ogg, and we set request.responseType to be arraybuffer. And if we fire this up in our browser, we see that we do make that request, and it starts playing our sound file. Alright. So, we've written this XMLHttp request code a few times now. Let's go ahead and extract it out. What I'd like you to do is fill out the function xhrGet that does, well, exactly what we've done the past couple of times with xhrs. Takes in the request URI, like weapon.json, or bg_menu.ogg, it takes in a callback function to set the onload function too and it takes in a type, which could be either nothing, if we're expecting text data or arraybuffer, if we are expecting arraybuffer data. Now, one quick note about the callbacks, we're going to create the callbacks such that we assume that it takes the request object as a parameter. So, for example, you can see our parseJSON function here takes the xhr, and then parses xhr.responseText. Now, we have both the parseJSON and playSound functions here, that if passed in as callbacks, will appropriately play sound or parseJSON as we've done before. Now, down at the bottom of this file, we make 2 calls to xhrGet with weapon.json and bg_menu.ogg. Just for you to test again to make sure that your xhrGet function is behaving properly. Alright, so the skeleton of this code is pretty much what you've already done before, but we're going to introduce a few other things here. First of all, we set this caller variable to be the caller of xhrGett. Now, this is a special thing in Javascript and what it does is, whoever ends up calling xhrGet, will be set as this xhrGet.caller parameter, and you can grab that as necessary. Next, we do the same thing that we've done this entire time, create a new XMLHttpRequest and call the open method, then we check the type: if it exists, then we set it, otherwise, we assume by default that it is just text. Now the onload function is where things get interesting if we set a callback then we go ahead and try and call it otherwise we don't do anything and this try catch block is something that some of you might be familiar with. We try to do what is in this try block here and if it fails then we catch the error and throw an exception. Now this is basically just going to print out a whole bunch of information about the exception. And this is where caller comes in as well. You can see that we print out the exception. The response text and the caller just for debugging purposes. Finally, we call xhr.send, and that's it. And if we load this up in our browser, we can see we make both calls. The first one takes a lot less time than the second one, since it's only JSON. We can see our output JSON in the console. And our song starts. [MUSIC] So now we've gone through the basics of javascript syntax: structuring and interacting with JSON data, and requesting data from a server. Now, we need to talk about how to interface to the browser. More specifically, we need to talk about the DOM, or document object model. The DOM is an interface to the structure of an HTML.document, for example, the head or body element. The DOM allows us to access and modify our HTML document dynamically, using Javascript. Our game is primarily going to exist within a single element, the canvas, which we'll get into later. But what this means is that we won't have a lot of reason to heavily access the DOM. In fact we're only going to need a few things. So let's take a look at a quick example. Let's say you want to validate whether a user has entered a valid password into an input field. Here's how you would do that using the DOM API in Javascript. You can see the basic HTML here with the form and the password input and the submit button, and we have a script down here where we start executing our javascript. First, we have this document.getElementById method. What this does is grab a DOM element of the given id. In this case, it's exampleForm, which is right here, so we would grab this entire form. When it's submitted, we run this function in here. Now, you don't really need to worry about the passwordRegex too much. We're interested in this part down here. Now if the password doesn't match, then we create a new "p" tag element, assuming it doesn't already exist. We check if it exists by again using the document.getElementById method and checking for the ID "notify". If it doesn't exist we use the document.createElement method specified at "p" tag. This parameter is just the name of a type of element. For example p or form or canvas. Now we set the text content of that p tag to this bit here and we set the ID attribute to notify. That way, if we submit multiple times, we don't simply create a new p tag every single time. Finally, we grab a reference to the body tag, since the body element has an ID of body we can do that, and we append "notify" to the body. Now if we look at this in our browser, we can see we have an input form with a submit button and you can see our basic HTML down here. However, if we submit an incorrect password -- press submit -- we can see that this pops up right here, which is the text that we set our p tag to. You can also see that this p tag was created down here. With an idea of notify and the correct text. You'll also see that if we keep pressing Submit again, more p tags don't get created, since we made that check. Alright, now that we've seen this in action, let's go ahead and use it ourselves. What I'd like you to do is create a new canvas DOM object inside a new div DOM object, that is then put inside the body element. To do this, we're going to have to grab the body element by its id of body. We're going to have to create a new element, using document.createElement, both for the div and for the canvas, then we'd like to set their ids. For the div, we'll set it to gameContent and for the canvas we'll set it to gameCanvas. Finally, we'll have to append both of those, the canvas to the div, and then the div to the body. You'll have to use document.getElementById, document.createElement, the appendChild method of DOM objects, and the id property to do all of this. So, the first thing we do, is grab the body dom object using document.getElementById, with an id of body, and we create a div object, as well as a canvas object, and set their id's appropriately to div.id = "gameContent" and canvas.id = "gameCanvas" and finally, we append the div object to the body and the canvas object to the div. If we open this up into our browser, we can see that we have indeed created a div element and inside that is our new canvas element and both with a proper id. Now, Javascript at first glance really doesn't resemble the same sort of object oriented programming languages that you see in C and C++ code. Now these are typically the languages that games are written in, NES, Super NES, XBox 360, PS3, all had some resemblance of this. Now Javascript provides a way that you can define a set of variables as well as functions encapsulated as an object called a prototype. But for game dev, we're really missing the inheritance factor, that is the ability to define that prototype and have another one inherent from it. Luckily, we can duct tape JavaScript just enough to make it look like we're getting classes and structure definitions. Now this type of setup is actually the backbone of how everything works inside of grids. So, before we move on, make sure that you're very, very familiar with this type of programming model. All right. Now that quote's explained, why we want to use a more traditional object-oriented class base set up, let's go ahead and do that. Now, we'll be using a piece of code by John Resig that fakes class-based object oriented programming. Feel free to take a look at the code or the linked blog below to see how it works. Now, we're not terribly interested in the internals for our purposes. What we care about is how to use it for instantiating the proper class-based inheritance trees for our game objects. So, let's say we want to create the following inheritance tree. We want weapon and entity to both inherit from Class. And we want MachineGun and ChainGun to inherit from Weapon. And Teleporter and EnergyCanister to inherit from entity. Now we've started this off for you, but we're going to have you complete this yourself. First, we set weapon to be Class.extend. What this means is that weapon extends all of Class's functionality, whatever that happens to be, and then adds it's own on top of it. Similarly, MachineGun is set to weapon.extend, which extends all of weapon's functionality, and then builds on top of that. Now, we've created these for you for a template. And, what I'd like you to do is fill in the rest of the inheritance tree we discussed above. Alright. So really, all you have to do is set ChainGun equal to Weapon.extend and in this case, we're not extending it with any further functionality. We'll be getting to that later. And similarly, we're defining Entity to extend Class, Teleporter to extend Entity, and EnergyCanister to extend Entity. This bit of code doesn't really do anything by itself but we'll be adding more functionality to these, as we go. And this way, we have a nice clean framework for doing that. Great job. Now that we've got the fundamentals down, we're going to build on that in the later units to create fun interactive games. Now it's time to actually start putting some reality into our games. Robots running over walls and going through things is so 1983. So what we're going to be talking about this unit is how to actually add collisions and physics to your environment so that your robots can run around, shoot missiles, get into all sorts of cooky troubles. Now be warned, this is a little bit of a deep unit so make sure you've had a bio break and you've got enough caffeine handy to get through the whole thing. I'll see you on the other side. First, let's talk about how we make things collide. Now, our world consists of beautiful pixels and so, let's determine whether two images collide based on their pixel data. So, let's say you have these two objects in your game world. The first is 72 by 72 pixels and the second is 50 by 50 pixels, and you want to figure out if they have collided with each other. How many pixel comparisons do you need to calculate to determine whether these two objects have collided with each other? Enter your answer in this text box. And the answer is 12,960,000 because you have to compare every single pixel in one image with every single pixel in the other. So it's 72 times 72 times 50 times 50. This is clearly insane, now we only have two objects and we're all ready doing way, way too much work. So, instead of computing the intersection between every single pixel and every other pixel in the world, we'll use an approximation of our pixel shape, which simplifies our collision calculations. And we'll do this by representing each object as a box and this is called an access aligned bounding box or AABB for short. Let's take a quick closer look at this. So with this image's axis aligned bounding box, we only need to take into account 4 different values. The minimum X Y position, and the maximum XY position. Or the top left corner and the bottom right corner. Alright so let's go ahead and code this up. We've got a function intersect direct here, which you might find somewhat familiar, that takes 2 rectangle objects, that have a top left bottom right value, and we need to test whether they intersect based on those values. Alright so this is fairly straightforward. And you might remember it actually from unit two where we had to deal with intersecting rects with the view rects and the canvas styles. So to do this we simply take each rectangle and compare the left most and right most edges of both. And see if they overlap and do the same with the top and the bottom of each rectangle. After that, we return a Boolean based on it and we're done. This works fine, but things can get a little bit more complex particularly once you start wanting more data out of the collision. For instance, it's generally useful to know the exact point of intersection. Now, let's take a bit of a closer look at that. So, the question I want to answer is, what point should we single out for the specific point of intersection between these two? Should it be over here, over here, right here, here, or here? Which point should we use as the point of intersection? Check any that you think would be a good choice. The problem is that you could make an argument for just about any of these. You could make an argument for any of the corners or intersection points of the bounding boxes or even the centroid of them. Or, maybe you don't want to use a point of intersection, maybe instead you want to select the entire area as a subsection of these bounding boxes. Which one you do is really up to you and it can have a lot of effect on how the rest of your physics or collision engine works. Now there are other situations we can run into, too. For example, let's say we have 2 robots that are shooting at each other through a wall. Maybe they're not the brightest robots in the world. Or, maybe they are. Let's take a closer look at this situation. We have a few different bounding boxes to consider. We have this wall made up of a few bounding boxes, and we also have the bounding box of the rocket. So let's say we have this rocket here, and in one time step of the physics engine, it is on this side of the wall. But on the next time step of the physics engine, it is on this side of the wall. Now, everything in our physics engine happens at discrete steps, so there's no point at which this bounding box and this bounding box intersect. So then, which bounding box should we use? Do we want to end up using this bounding box, right here? Or maybe we should calculate some halfway point between the 2, right here, and use that bounding box. Or maybe we want to use the entire swept area, swept out between the 2 time steps and use that instead. Now the box I've drawn is a little bit bigger than the path that would be swept out between these 2 time steps. Which of these do you think that we should use to properly calculate collisions? Check which ever single one you think is appropriate. This one works in this case, but you could imagine cases where it wouldn't work. For example, what if the wall was very thin and actually is just right in here, then this wouldn't work anymore. Now however, the swept area does work no matter how fast the rocket is moving. The swept area will still collide with anything that is in the rocket's path between the two time steps, which is really what we're looking for. Now you might be thinking that this rabbit hole keeps going down into a pretty crazy place full lots of little things that we didn't plan on coding in the first place. And you'd be right. So the question I have for you is, do you wand to see how far the rabbit hole goes? Yes you do or no, you've really got other stuff you need to worry about when making your game. Check whichever one you feel applies. Obviously, either one of these could be right, and the answer does really depends on what kind of game you're making, whether you have the time to make your own physics engine, and whether there's any off the shelf software you can use to fill your needs more easily. Now when designing grids, we decided not to write our own physics engine, instead to use this physics engine that was already up, working, and open source. Now, before we get into some of the minute details of using our physics engine, let's take a minute, and go through our wish list of what we'd like our physics engine to do for us. And why it makes our lives a lot simpler. The first thing is, that we like to be able to create physics objects for each of our game entities that needs them. We'd also like to be able to update the physics engine each frame, or rather, we'd like to be able to allow the physics engine to update itself, and take care of most of the work for us. We'd also to be able to fire off collision events between different physics objects, and then respond to them arbitrarily. And finally, we'd really like to be able to pull updated position information for each of our game physics objects, each frame. That means effectively, that we can use the physics engines calculations to feed position information into our rendering engine for drawing next frame. So to accomplish all of this for grids, we decided to go with a physics engine called Box2D. Now, Box2D was originally written in C++, horded the action script, and used in hundreds of games. Including the incredibly popular Angry Birds. And recently the action script version of Box2D has also been converted further to JavaScript by Jonas Wagner. For grits, we grab the JavaScript part of Box2D from the Intertubes and placed it into our source folder. Now, if you have further questions about the Box2D API that we don't answer here. We recommend you take a look at the Box2D manual shown here, and linked below. It was written for the Flash version, but the concepts translate. Now, the first thing we need to do to use Box2DJS is to load it into the Dom. And we do that, using this fairly simple script tag. Now as you can tell, Box2D is a fantastic library and the best part is it's actually free use. And then we can go download it off the internet and put it in our game. The author's only ask one thing though in their licensing. That you give them credit for using their work. Now back to GDC 2011, a very popular mobile game developer who is actually using Box2D in their game. But actually forgot to credit the Box2D authors. This actually came to a head at GDC, when the very popular game makers were actually on stage during a panel. Some lonely representative actually stood up in the audience and asked them a question from the crowd. Asking them what physics engineer are you using, to which they responded, Box2D. The individual then said hey, did you know that licensing actually requires you to give attribution to them? They said didn't know that, and he said cool. My name's Aaron Cotto, I wrote the library. Would you be willing to give me credit? Of course, the person said let's talk afterwards. The point is this, all that open-source software out there comes with some license. So before you actually go grab it, make sure that you read through their licensing terms very, very carefully. And that you're abiding by their using in a proper, legal way. Otherwise, you might get an angry Aaron Cotto showing up at your next GDC talk. Now, the goal of this unit will be for you to write a PhysicsEngineClass to manage the interaction of Box2D to your game engine. Now, first things first, is that we'll need to create a new PhysicsEngineClass and create a global instance variable for it. Now the core of Box2D simulation is a variable type called World. Which is used as the main handle to the rest of the APIs. As such, we need to add a create function to our class. And inside here, create a new instance of the World object. Note, that typically, the World constructor takes a vector that represents the gravity of the world. Since now, we're a top down game, we really don't need a 2D gravity vector. So we're just going to leave this as 0, 0 for now. Now, the second variable in the constructor, is a boolean, which tells Box2D, if an object is allowed to sleep or not, given some time threshold tolerance for the computation. Now, for our purposes, we don't want to let objects sleep, so we set this, to false. The core of Box2D simulation is a variable type called World. Now, this is going to be used as the main handle to the rest of the API's that we're going to use. As such, we need to add a create Function to our class, and inside of there create an instance of the World object. So, to move on, go ahead and create an instance of the World object passing in a vector and a boolean value. So now typically the world constructor actually takes a vector which represents the gravity in the word. Now since we're a top down game we don't really have a 2D gravity vector so we leave this at 0 0 for now. Now the second variable is a little tricky. This is a boolean value which tells Box2D whether or not an object is allowed to sleep in the world given some threshold of tolerance for their computation. For our purposes we don't want to let objects sleep, so set this to false. The update function for the world object is called Step, and its inputs are a little bit tricky, so let's take a look at them. The first parameter here represents the frame rate frequency that our physics engine uses to track through its calculations. Think of this value as the amount that we want the physics engine to move the physics world forward each computational frame. And of course, we want this value to match what the visual world update loop is doing, too, otherwise things might feel off. Now for our purposes, we make the assumption that the game is running at a solid 60 frames a second. Thus, we expect the update loop to be called 60 times a second, giving us a time slice value of 1 over 60. Next, we pass two values to the Step function which represent the number of iterations that the physics engine should spend solving collisions and velocities to ensure proper placement. Now, without going into too much detail, solving for collisions in an environment while also ensuring that objects aren't interpenetrating is actually a pretty cumbersome process, and can't really be solved in a single pass. For example, consider if two objects are penetrating and fixing the penetration causes the penetration collision with a new object. And of course in turn fixing that one may cause yet another collision. And so on and so on. As such, the physics engine will do passes over the physics object and solve the items iteratively. The number we pass in here represents how many passes Box2D should do before moving on. I.e., the higher the numbers are, the more precise the collision data, since we're iterating to find a solution. The lower the number, the less precise the collision information, but the more performant it is, because we're not spending extra cycles. Now, one important little gotcha here, which I'm sure didn't actually fall through your example, was the calling of this dot world dot clear forces every frame. Now this is an important point in our physics engine implentation. Typically, in a physics engine, you'd set the velocity, toss around some objects and be on with your day. The reason for this is that box 2D assumes that you're in a two dimensional environment with the gravity vector always pointing down. As such if you were to create an object and throw it through the world, the gravity forces on it would actually move it downward. However in grids this is not the correct policy. What we'd like to do is for a projectile to move forward along a straight path without vertical gravity influencing it. However, because we're a top down game and don't have a gravity vector, any small velocity vector gets accumulated on our physics object each frame without friction allowing it to continue bouncing around in the environment. Or rather, you should think of gravity as something that produces friction on an object, slowing its velocity. We fixed this sort of gliding, hockey puck motion by reducing the influence of the physics engine on our world. Namely, we allowed the velocity of an object to be set for a given frame, the physics engine to move that object and compute the position and rotation and collisions. And at the end of the frame, we erase and remove that velocity vector. Now unless we reapply a velocity vector to the next frame, the object will sit in this position not moving. Awesome. So now Box2D is created and can be updated each frame. Our next step is to add physics body to the world, so that we can simulate them properly. To create a physics object, we have to jump through a few hoop. The first thing we need to do is actually create a BodyDef object. Now Body Definition object is going to be used later to actually create our body. But what we do in here is that we actually set some specific properties on it. For example, whether or not its dynamic or static. Think of static objects as the ones that will never move in your environment. Walls, trees, stone chickens, things like that. Dynamic bodies are the ones that move and can react to physics. Once you've set your properties for your body definition, you need then to call world.CreateBody. This will actually tell Box2D to create a, Physics object based on the definitions that you just passed into it. And of course, it will return a handle to this object, so that you can use it too. Once your object has actually been created, the next thing you need to do is actually set the physics properties on the object. Box2D does this using what they would call a Fixture Definition. Now fixture definition defines properties that allow you to set the density, friction, restitution, mass, things along these lines. Basically how this object is going to interact with the physics of the world around it. Generally in a game, you'll have groups of objects that all resemble the same similar physical characteristics. As such, you may want to go through and actually group them into certain types of fixtures. For Grits/g, we actually have the majority of objects in the world use a specific fixture object that react to the world in the same way. However, we have one type of bullet that can be launched from the bouncy bullet gun, that actually uses a different fixture. As such, we allow the entity Def object, passed in from the user, to actually have a flag defining whether of not this is a BouncyFixture object. From there we can actually set the density and friction differently, so that it hits the wall and contains its velocity moving forward. As you write your game application, it's probably worth while to take into account. How all things should react in the environment and use different fixtures appropriately. Now, once you've defined the fixture information about how the world should react with the object, we actually need to define the shape of the object. The shape is the most critical, as it defines how this object should interact with the rest of the world. Now, Box2D has support for polygons, circles and oddly enough, boxes, right, who'd the thunk/g? Now it's worth pointing out, that most physics engines support a suite of whole definitions. But give huge performance winds to simplistic wholes like spheres, circles, boxes and cubes. Polygons are always an option, but expect to pay a performance penalty for the flexibility you're gaining. The fixture definition supports a suite of these API's. Such as the SetAsBox method, which of course will define the fixture definition as a box. Once you've got all these parameters set, you call the CreateFixture method on side of the Body Definition that's been given to you. And this will effectively attach the shape and information, to the body definition. From there, you're pretty much done. You've got a physics object that'll react to the world and do all the things you tell it to do. So go ahead and return it out to the calling function. Alright, so let's take a look at this monster of a function. Once again we start by defining whether or not this is a static or dynamic object, and of course setting the proper flag to the body definition type. So the first thing we do is we actually start off by defining whether or not this is a static or dynamic body and assign a particular flag to the type property of the body definition. Next, since the calling function probably has information about where they want this object to be spawned, we go ahead and set the position x and position y value so that the physics object can actually exist in the world in correct place. From there we call registry body function which will of course invoke box 2D to create a physics object and return to us a handler representation of it and then we go through with creating a fixture definition. Now, the defaults for a fixture definition object are generally pretty good and that's what we use for most objects and grids. However, for the bouncy fixture we actually changed the density, friction and restitution, so that when an object hits a wall, it'll contain a lot of its velocity moving away. This means that bouncy bullets maintain a high velocity and ability to kill other players since they don't lose any energy in impacts with walls. Finally, what we'll do is actually create a shape object with a new polygon shape as standard API calling defines, and then we'll call SetAsBox passing in half width and half height. From there we call the CreateFixture objects which attaches this definition to the body object and return it out to the calling class. And if you got all that, then you deserve a cookie. Now once an object is created, it will one day have to die, because that's the ebb and flow of the universe. Now once it dies, we need to remove it from the physics simulation, and can do so by calling the destroy body function on the world object. Now we rap up this call in a remove body function so that external systems don't need to know about the presence of the world object from box 2 D. And voila. This is one of the few times in your career, that you'll be able to sit and ponder on the simplicity of a simple solution. Take a second, look it over, breathe it in, it works and it's simple. Now, InGrids, we allow any entity definition to have a physics object, that is an entity doesn't inherit from physics object and isn't required to have one e. Now from those daring digital souls who want one, they'll need to actually create a handle to the physics body and keep it around over time so they can manipulate it. Before they can do that, of course they have to first fill out the entity definition object and pass that out to the gPhysicsEngine.addBody which we've coded up previously. Now for grids, every object in the world is in a box. So our description is pretty easy to generate. First off, we passed the x and y position values to the class, alongside the halfWidth and halfHeight of the box representing its size. In addition to that, box 2d expects some specific surface properties such as dampening, friction, things along those lines. So we go ahead and set them here as well if we want them. Alright. Now this is pretty straightforward. Seeing as though the calling code has given us an X and Y value of where to exist in the world, we simply pass those through to the entity definition object. Next, we actually determine the half width and the half height of the bounding box for this object. Now for the simple projectile class that we're using here, we statically define its width and height to five units. Of course, passing half of that to the right variable. In addition, we also set the surface parameter of dampening to zero. Now in order to facilitate as a debugging aid for our purposes, we pass in an ID object to the entity definition. Now inside the addBody method, we attach this ID properly so that later on we can identify this object differential from everything else. This helps with debugging and determining whether it's a missile hitting you in the forehead, or a rubber chicken. Now, note that once an object is being created in the environment, the PhysicsEngine will simulate each frame, updating the position and velocity of any physics bodies that it has in its world. In order for GRITS objects to properly receive the data and update positions for the rendering, we need to query the PhysicsEngine results by the physics bodies created for an entity. Note that the position values for an object already exists as it's inherited from our entity base class. Inside of our update loop, given that the entity has a physical body, we can query it's position and update the entity position accordingly. This way the visual representation of an object will match the physical representation as is. To do this, you need to call the physics body's GetPosition method and then assign it to our local positional values. This is actually pretty easy when you get down to it. First off we check whether or not physics body exists for this object. If it does, we continue forward by calling GetPosition object. And then caching it so that we can render with it later. Note that the position object has an x and y parameters to it. Which identically matches the x and y parameters in the vector given to us from the collision system. Having these two match up, allows us to pass positions and vectors back and forth between the physics engine and our game code quite easily. Now, that we can receive the position of our physics object in the world, we have to figure out how to set the position of a physics body, which in contrast is a little bit trickier. Scrolling through the documentation, you'll most likely see a nice API called set position, which will do exactly what you think, and set the position physics body in the world, regardless of how physics are acting upon it. Note that this type of teleportation will ignore any types of collision that may occur before the position is set. In other words, set position teleports you to the desired position first, and then calculates the physics response. As such, you should only use set position when you're intentionally trying to teleport, and, when you know where you're going. Imagine how Nightcrawler feels. So, in order to get moving with this, the first thing we need to do, is once the physBody has been created, we can actually call the SetLinearVelocity function, on the physBody. Setting its initial velocity vector, so this body can be simulated and updated properly. And if you recall, we remove the velocity from objects each frame, in order to keep them from sliding around our world like hockey pucks. As such, any objects that want continuous movement, say for instance a rocket moving at a constant speed, need to set the linear velocity of the physBody, each frame, to insure it's moving. We see a perfect example of this in the simple projectile class, which will set the linear velocity, before sampling from the physBody. So, to set the initial linear velocity, we simply pass it a vector two object. Now, for our simple projectile, we have a little bit of nuance here, because, what happens is, once the projectile is created, we pass it in a directional x and y, representing the vector of travel for this projectile alongside its speed object. So this basically says, move this direction this much per frame. Now again, we've set this as the initial linear velocity on the physics body. And of course, once the first update loop happens, we'll actually remove the velocity from the object, and we need to set it again inside of the update function. We set it to the same value, the same speed. So, now we're in a fancy little spot. We can create a physics engine, update it, delete objects from it, add bodies to it, entities in the environment can add their own physics bodies and of course update them over time. And now, we get to the final part of the equation, how we actually drive the entire simulation from our game engine object. This is a little bit easier than you think. Inside of our game engine class, we first define the number of physics updates that we want per frame. Now remember, before, we were talking about the number of physics loops steps we would like to occur inside of a frame to move our world forward. In the game engine's setup function, we actually need to call an initializer on our Global Physics Engine class. And also inside of the game engine's update function, we need to actually call the physics engine dot update method so that it'll do a step process on all of the world objects. Easy peasy lemon squeezy. First thing we do is actually called gPhysicsEngine.create, inside the setup function for the game engine class. And at the bottom of the update loop, we call gPhysicsEngine.update. We can create the engine, update the engine, all the entities in flight can create objects. We're good to go. So now we've got the full spectrum here. We can create objects, move them, and see them sliding around in the world, which is great, because now, we can actually throw missiles from one robot at another. The final missing piece, however, to our grand scheme of world domination, is what to do once the missile hits the other robot. Now, in our current set up, we receive no information that a collision has occurred. But we only get back the positions of the objects that the physics engine has adjusted. But fret not my children, there is a solution. We're going to need to jump around between a few different files and concepts, but once we're done you'll be able to allow each entity to respond to a collision independent of other entities. Now the start of this nice aside is a Box 2D function that allows us to define an onCollison callback that when called is given two physics bodies that are touching. Now to receive these callbacks. We first go back to the physics engine class and add a nice wrapper function that allows us to set some of the callback functions for box2D. In general Box2D allows you to get callbacks during multiple phases of collision. We have a begin contact, which occurs when things are touching, but the collision calculated hasn't done yet. End contact when the contact analysis is over, and post solve which is called once the physics collisions have occurred. For our purposes, we need to find a new function in the physics engine that allows the engine to pass in customs callbacks, to be executed when anyone of these phases occurs. This code is fairly simple although deep. We take in an object that contains callbacks we're looking for and define logic that will issue a callback to those functions, once the engine hits that phase. So, for instance, we assume that is the callbacks.PostSolve method exists, then we define the PostSolve method on our listener as a function that takes in the contact and impulse, pass for Box2D. And we'll actually send that to the PostSolve function in our contact, giving it the 2 bodies for the fixtures that are touching. Now Box2D operates in a different environment than we do. That is that it operates in fixtures that are colliding, and we have to go then fetch the body object that we're using. Once we've set all of our callback handlers that we want, we actually can call world.SetContactListener and pass in the listener object. This will effectively bake in all of our contact objects into the world, so that any time we get these collision objects, we'll get collision callbacks. Now having the body object from inclusion is good, but it lacks specific information that allows us to react with our game logic code. As such, we need some way to correlate a body to an entity that created that body. Now there's number of ways to do this. We could create hash tables and lookups and all this other stuff. Or, we can use one of the interesting nuances of box 2D, specifically physics bodies in box 2D contain a user data property that can point to any other object in memory, or some subset of data. For our purposes, we're going to use that member and assign it to whatever the owning entity is for this body. That way, when a collision call back occurs, each body will have a pointer to its owning entity, allowing us to do game-specific logic as we need to. To get started with this, we need to modify the physics engine addBody code, and assign body.userData if a userData variable has been passed in as part of the calling settings to this function. Of course, this solution is pretty simple. If we expect that there's a user data object that's passed in as our entityDef structure that's given to us. We can simply assign bodyDef.userData equal to the past entity.userData. Now, from here, we need to bounce back and update any entity file that create a physics body. In the entity definition object that's passed into the physics engine, we need to add a user data object, which contains some metadata that we can later use for collision responses. Most importantly, is an object that points back to the this object for this entity. And any other datda that you might need. For example, a unique string that represents an ID. Pretty simplistic is how this comes forward. We pass in a unique identifier that represents the object, plus the guid that represents this unique identity in the world, as well as a pointer to the this object. So getting back to the point, now that we have the physics engine executing a callback, we need to define the callbacks somewhere. Now for our purposes, we're going to let game engine define the collision callback structure. Now in the post solve collision function, we're given body A and body B. The next step for you is to call the associate get user data function from these objects getting the variable to the entity that created them Now, in our callback, we drill down to get the GetUserData function. This will actually give us a pointer to the entity that created these physics bodies that are touching. Now from here, we start down a new magical rabbit hole. For each of the objects that are touching, we need to signal, that a collision has occurred to it. We do this by calling a new function, called onTouch, and passing it in the other physics body that it's touching. So you can see that entity A gets an onTouch function called, passing in body B, and entity B gets an on touch function called passing in bodyA. This set up allows each individual entity to respond to collisions in their own way. So for instance, the onTouch of that for missile, would remove five health from the player it' colliding with. Or if it's just hitting a wall, it may just decide to self-destruct. But we haven't written this onTouch function yet. And in order to do that, we need to hop all the way back to entity.js and add an onTouch function. That allows other units to overload this function with custom logic later. It's probably worth pointing out that you should be doing a whole series of data checking to ensure that the information given to the post cell function is valid. So for example, whether or not body A and body B are valid objects or simply null. And whether or not the points of proper entity types and have onTouch functions. Now we'll let you graffle through all of these issues in the future. But we figured, that we let you get a glimpse at the madness behind the mask. So, that means that anyone who defines a physics body should define an onTouch function. So, for example, the simple projectile class defines an onTouch function that does some crazy things. Now, I'm going to walk through them, so that you can see, the type of logic that can occur here. First off, we ensure that we have a physics body, to make sure that the onTouch function isn't being called erroneously. In addition, we also ensure that the other physics body that's being handed to us is valid, and it has user data as well. Otherwise it might be an invalid object or a wall or some other static trigger object. Finally, we can actually call otherBody.GetUser entity Data to actually get the entity from the game engine that responds to this physics object. Now, this simple projectile class will actually spawn an impact visual when it hits another object, a wall or the face of a robot. This nice little block of code here defines whether or not we've actually defined an impact collision. And then it'll go through and actually spawn an InstancedEffect object and allow it to start doing its flip book animation. Once this is done, it actually calls the dealDmg function on the game engine. This will actually reduce the health of the physOwner, or the other object that we're running into, by the amount specified by this object. This allows the missile to reduce the health of any other robot that it hits. Once this is done, we set the markForDeath flag equal to true so that later on, our entity will be cleaned up using our sweeping process. Now that you've seen how crazy things can get, the goal is for you to fill out the rest of the onTouch function for the EnergCanisterClass. Now don't forget, the energy canister is something that you picked up to receive energy. Energy is effectively ammo inside of grits. Now, the onTouch function has some of the setup that we saw for a simple projectile class. Your goal, is that in this onTouch function, we will update the entity of the touching physOwner, and then mark this object for deletion. To get started, we add in some nice little sanity checking to ensure that we're not actually trying to do operations on null data that may cause the game to crash. Or we're not trying to set the energy on an entity that has been marked for death. If the user is not already at max energy, that means that we can go ahead and modify its value. For this purposes, we set that all energy canisters will update the physOwner.energy value by plus 10. Once that's been done, we simply call the mark for death flag to true, allowing the sweeping function to destroy this object. So, you made it through! Physics is a head trip, right? It's really hard to believe that adding just a few lines of code here and there can actually give you the ability to interact in the environment in such a fun way. I tell you the truth, that's what I really love about game development. For a little bit of work you get endless hours of fun. Do you know what the best part is, of running for your life from a horde of zombies? Hearing them scream so they don't sneak up on you. Sound is really the crucial part of any game. It's the immersive glue that ties together the user and their world. And in this unit, we're going to be looking at how you can use audio api's for the web to make your games really stand out. Let's take a look at how sound works. Now say a bird starts singing [SOUND] and this travels through the air as a sound wave before reaching the ear. The sound wave is a analog signal, but in order to represent it on a computer we need to convert it to digital information. After it's converted to digital, we might want to perform some audio transforms on it. To change the volume. [NOISE] Or apply some other echo effect. [NOISE] Or something much more complicated and awesome [NOISE]. We can think of all these transforms as a graph of processing notes that each transform our sound in some way. And you can put them together, and that's exactly how Web Audio is structured. In this case, you can take this sound, run it through a series of nodes to transform it into, for example, a slap-back echo effect. Let's take a look at the Web Audio Playground, which is a web application built by Chris Wilson. It's a great way to visualize how Web Audio works and you can actually play around with all the different nodes, you can create source nodes and add all these different processing nodes to your sounds. And you can create that same slap-back effect like this [SOUND]. Now, Web Audio is a node graph that is contained in something called an audio context. Everything in the audio context is run natively in high performance code, specifically designed for audio processing. Of course, what we see here is a simple example, a real node graph may look quite complicated, but ultimately it's all using the same concepts. For grids, were primarily interested in getting robots to shoot each other in the face. So the question we need to ask is, what sound effects do we need for our game? Do we need to play just basic sound clips? Do we need to have the ability to adjust the volume of sound effects in the game, based on the game state? Or do we really need all the abilities of Web Audio to perform audio processing on all of our sounds. Go ahead and check which ever answers you feel apply. Of course we do need to play basic sound clips. For Grits though we have robots moving around a 2D world making noise and causing mayhem. It doesn't make a lot of sense for a sound on the opposite side of the game map from the player to be just as loud as the one right next to them. So it's not quite enough for a game like Grits/g. What we need, is to also add the ability to adjust the volume based on the game state. And that solves the problem I just mentioned. With web audio, you can adjust the volume of sounds based on how far that are from a play position on the screen. [SOUND]. This provides a much more realistic sound environment than you could achieve with, for example, the audio element. You can think of a lot more situations where it could be cool to have more involved sound effects. Maybe you want to apply an echo effect based on how sound [SOUND] reflects over that walls. Or apply a Doppler effect [SOUND] based on the velocity of a player or a projector. This can quickly get pretty involved. In Grits we simplify this and go for basic volume changes. The point is you need to think about what level of sound complexity is right for your game and your team. Now, getting sounds into grits was a bit of an interesting process. You see we really didn't have funds to actually get a sound designer to make anything for us. So we had to act like a scrappy little start up. This actually started at the beginning. Where do we get our sounds? Well, thanks to the indie gaming boom of 2009, there's actually tons and tons of resources out there for independent game developers to go get sounds for free. So we employed that strategy. Now when you do this, be very clear of what you're actually getting. Most sounds on the Internet actually follow with some sort of weird licensing restriction, either Creative Commons or attribution or something along those lines. So when you grab your sound, make sure you understand how you have to credit it. Usually it comes with something. The second thing you have to worry about is when you grab a lot of sounds from the internet that were made from different designers on different sound boards, they probably aren't very unified, which means they're not going to sound cohesive inside of your game. For this, you actually need to take your sounds through a post-processing tool. Personal favorite of mine is one called Goldwave, I've been using it probably since about 1998, it's free and easy to grab on Windows. Inside of these tools, you basically want to cut your sounds, trim your sounds and make it sound as though everything is in the same environment. Case in point, there's a lot of little gotchas out there when you're trying to get good content into a game. And sounds are really tricky to do. So do your due diligence, post process your sounds, make awesome. [SOUND] Because Grids doesn't need the full power of web audio, we want to create a wrapper to hide all the potential complexity. What we really want is a simple node graph consisting of the gain node that adjusts the volume. We want to keep track of that, the audio context, and all the sound effects that are currently playing. Can you try to fill out the provided sound manager class with that functionality? It should only be about three or four lines of code. Like I said just a couple of lines of code. We have remembered to keep track of our context, our primary gain node, and all of our currently loaded sound effects. We also have an enabled flag that we can use the turn the entire sound engine off if we want to. Note that we use an object to keep track of our effects instead of a list. This is important so that we can still query our effects by our URL path. Note that web audio is still not fully supported in all browsers, it's supported in web kit browsers only today and Mozilla is actively working on adding support for it in Firefox. It would be nice if we caught this and let potential players running in those browsers know that they might have a degraded experience. In order to do this, we need to catch any exceptions when we try to initialize our sound manager class and alert the player. Go ahead and fill in the init function shown here, catching any exceptions to the WebKitAudioContext initializer throws. So, as you can see here, we've wrapped our webkitAudioContext in a try-catch block, catching any exceptions, and opening an alert dialog box to let the player know that the Web Audio API is not supported in their browser. After this, we create a new gain node, and we connect it to our main node. Then, we connect it to our destination, which in most cases would be the speaker. Now that their sound manager is initialized. The next thing we need to take care of is actually loading our sound effects so that they're ready to play. Now the Web Audio API is similar to the image loading process that we use for Canvas. We only load images asynchronously. Now for essentially the same reasons. So what we're going to do is check if the sound has already been loaded. And if it is, we call our call back function. If its not we kick off a load in the form of an XML a to the p request, and then assign a callback function for once the load has completed. Finally we're going to return to actual clip data either way. Now here's some skeleton code to get you up and running. What we'd like you to do is to fill in the code So let them performs the Asynchronous loading that I just desribed First, we check if the clip is already loaded. And if it is, and we call the callback function with that clip sound. If it isn't, we create a new clip and we fire off an XMLHttpRequest to load that sound clip. Now, the response type from this request won't be plain text but it will be an array buffer, and that's something we need to decode. Using the Decode Audio Data method. We'll store dat audio buffer into da clip. And den call our callback function once more. Finally, we'll send the request, and return da clip data at the very end. Great. Now that we've got our data loaded, we're at the point where we can start playing some sounds. [SOUND]. Let's take a look at our skeleton code for this. We have a play sound method, that takes a path to the sound effect that you want to play. As well as an object containing all the settings. For our purposes, lets say that the setting's dictionary contains a bullion looping for checking whether we want to loop an effect, and volume to set our initial gain at. What we want you to do, is to create a source to play this sound. Connect it to our main node, and then start playing it. Now there will be a bunch of little things that you're going to have to keep track of here. Is the sound manager enabled? Is the sound loaded? Or are we trying to play a null sound? Don't worry, we're going to be giving you feedback as you submit your code, and which possibilities you haven't taken into account yet. The first thing we want to check is whether the sound manager is actually enabled. We define default settings for looping and volume. And we reset them if they are actually defined. Next, we use the path that was passed in earlier, to locate the sound effect. We create a new audio buffer source. Next we tell the source which sound to play, and pass in the volume, whether it's looping and connected to the gain node. Finally, we simply play the sound clip. [MUSIC] Now there are a few other features we'd like to enable for our sound effects. For example, what if a player enters a menu or switches to another tab? We might want to be able to cut out all sound effects immediately in those circumstances. The way we do that, is by simply disconnecting our main node from the node graph, creating a new one in its place, and connecting it to our output. The new node won't be connected to any of the sound effects the old one was, so we can start from a clean slate. For the next assignment, we've provided this stop all method, for you to implement this functionality. You should be able to do this in just a couple of lines of code. Hopefully, you've come up with something similar to this. First, you disconnect from the mainNode, after that you create a new GainNode and connect it to the mainNode. Finally, you'll connect all of that to the destination. One of the last things we need to implement is the ability to mute our sound. Anyone who continuously plays games at work, like Cold, knows that muting is one of the single most important features that was ever devised. We want the ability to mute and unmute. So we need to set the value of our gain node depending on whether it's muted or not. Now take a moment to implement this functionality for yourself. As you can see it's pretty straight forward. We check to see if the gain value is greater than 0, which means it's not muted. So in that case we want to set it to 0 to mute the sound. If it isn't greater than 0 that means it is muted and we'll want to toggle it back to 1. Now we'd also like to have a sound object that we can pass around or attach to various entities in the rest of the game code. Say, for instance, that some entity has a specific [NOISE] death sound that always plays. We'd want to be able to actually attach that to that entity. As you can see here, we have a sound object that has two methods, init, and play. Init, initializes the sound in any way we might need to. Play takes a boullian loop that plays a sound and playSoundInstance, which is an external function used by both init and play, is a fire and forget version that takes a sound URL, loads it, and then immediately plays it. Now, we want you to fill in these methods as described with everything we've already built. And that should only be a few lines of code. See, I didn't lie, it was just a few lines of code. Init is really just an empty function that we needed to extend the class. Play method calls the previously defined playSound function, passing in the looping, and volume settings. playSoundInstance, takes a path, loads it and immediately plays the sound. Now we've got everything we need to play basic sound effects with no unfly audio processing. [SOUND]. The only thing we have left to do, is to adjust the volume of various effects based on where they happen in the game world. For example, when my character picks up quad damage, I hear it at full volume. [SOUND]. An explosion that happens in the distance may only be heard at half volume. [SOUND]. And it won't even hear an enemy who picks up an energy canister on the far edges of the map. Now, Grits uses a pretty simple distance calculation based on the ViewRect side. We want to be able to hear the sound, within the screen radius at full volume. Then, we'll want to scale down the volume to zero, as we reach two times the radius. Finally, you won't hear any sound at all outside of that radius. Alright, let's take a look at how we implemented the playWorldSound function. Now remember it takes the parameters, first the soundURL representing the sound that we want to play in the world, and then the x and y position that this sound should be played at. So first we're going to check if the player is null for some reason, just as a sanity check. If it is, then we simply return and don't worry about playing it. If there's no players to hear the sound, does the sound actually play? And we're going to do a little bit of shorthand here just to make it a bit easier for us to write for ourselves by shortening gGameEngine.gMap to just gMap, locally. And now we're going to do the calculation for fading the volume out. Based upon the distance from the player that the sound is supposed to be played at. First, we check the viewSize of the, for the map's viewRect. And we're actually going to do this as a square rather than as a rectangle for simplicity's sake. So we take the maximum of the width and the height. Then we multiply it by half, since we don't want the full width. We only want the half since we're going to set the center of that view size to be the player's current position. And we want the distance from the player to the sound. Now, we're going to take the x value, the absolute x value, from the player position to the sound's x position, and similarly for the y value. And now, we simply compute the distance function, which is the same one that you've probably learned in high school, which is the square root of the x distance squared plus the y distance squared. Now we're going to normalize that distance, and what we mean by that is we're going to take the distance to the observer that we've just calculated, and we're going to divide that by the view size that we calculated earlier to see how many view sizes from the player we are. Like we talked about four. If we are more than two view sizes away, then maybe want to start reducing the sound like we discussed. So in this case, if the normal distance is greater than one view size away, then we set the norm distance to one, since we're going to reduce the volume by the norm distance later on, and it doesn't really make sense to have a negative volume. Norm, norm distance, is for whatever reason less than zero, then we simply return and don't play. And then we create a call back function. And immediately calls play sound on that sound object. The path of that sound object that is and with settings saying looping is false and that volume is the volume that we have just calculated. So, once this function is written, we'll have a nice effect where the further the sound is away from a player, the more quietly it's played until the player can't hear it at all, creating a more realistic sound environment. As you can see, sound is a really important part of any project, especially games. Take for example Half Life 2. Someone out there actually made an entire mod pack to replace the sounds of the original game. So, instead of hearing footsteps you heard duck quacks, instead of hearing the missile hitting the alien, you actually heard a crowd laughing. The result was pretty offsetting. You didn't really feel like you were connected in the environment. The drama was gone, the suspense was gone, it really wasn't the same game. Now it's also worth pointing out, that sound design is often one of the more expensive parts of production. It's long, tedious work, and often tied very closely to the design of the game. Take for example Quake one, when your quad damage was running out, the designer decided that you'd get a three second pulse warning you that it was about to run out. Now if you actually look at the code, they coded in the bright flashes that you see, once every second. However, the sound itself was actually a three second clip with the pulses. If the artist of designers came back and actually decided they wanted a different length, shorter or longer, the sound would have to be started from scratch. This is why sound design is usally really expensive for video games, and left to the end. Most of these changes happen very iteratively, so you have to end up scrapping a lot of the work you've been doing.