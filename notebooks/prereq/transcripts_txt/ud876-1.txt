You're probably familiar with many of the services that are offered by Google. And if you develop applications your users likely are too. Perhaps they need to find a location or see what's interesting nearby. They're using Google Maps. Maybe you want to monetize your apps so that app usage is rewarded and your users, they don't have to pay upfront. Google Ads is your friend. As well as these, we've got lots of great APIs for you, storing files in the cloud with Google Drive, accessing Goggle Analytics. Signing into your application, integrating with Google Fit and much, much more. In this course, you'll learn how to use these services in your apps. You'll see how easily you have the power of Google at your fingertips, allowing you to build better apps. Before you can get started, let's take a look at getting the tools that you need. You'll be building your apps using Android Studio, which is available at no cost to you and can be downloaded from developer.android.com. If you want some help in setting it up, check out the Android Fundamentals course at the url below. To build applications that use Google Play services, you need a development environment. And to install the development environment there's two main things that you'd need. First, is Android studio. You can download Android studio from the developer.google.com site. When you install Android studio, you get the ability to use the Android SDK Manager, that you can see here. And using the Android SDK Manager, you should install the Google Play Services SDK. You'll see it as an item on the list, under extras, near the bottom of the screen. Make sure that you install the most recent version of this. I would also recommend that you take a look at the Android Fundamentals courses offered by Udacity. There are two of them at the moment, and I strongly recommend that you at least take the first. And it's really not a bad idea to take the second as well. These will give you a head start in Android development and teach you many of the concepts that we'll be covering in this course. Here you can see that I'm running a very simple app that I've called LocationLesson1. You build this application using Location Services and the techniques that you'll use for building this application can be used across many of the different services that you'll learn in this course. So, how did we get here and how did we build this? Let's take a quick look. So, to build an app like this one for location services and many of the other services that you'll be encountering in this course, you're going to do the following steps. First of all, the easiest way to get started is to create a new app using a Blank Activity in Android Studio. Once you've done this, you'll edit the build.gradle to add the services libraries. You'll using something like this, but the version number may change. Then, you'll edit AndroidManifest.xml, to tell your application that you're using these services libraries, and the particular version that you're using. When you put this value, integer Google Play services version. When you do a gradle sync, the correct version number will be put in for you. So it's good just to use this string. And then finally, in AndroidManifest.xml you're probably going to be adding a bunch of permissions as well. In this case I was doing location so you see I set users permission for access_fine_location. Depending on the activity or depending on the type of application that you're building, you'll be putting different permissions in here. When building an app that uses the Google services, you'll generally use an Asynchronous Programing Model that looks a little bit like this. In the onCreate of your activity, you create a Google API client. And then in the onStart of your activity, you connect that Google API client to the relevant APIs. In this case Location Services. In order to use this, you're going to need to override a number of different methods. One is OnConnectionFailed, which the services will call whenever the connection drops and you need to handle what to do. Generally just reconnecting. One is OnConnectionSuspended, which is very similar to OnConnectionFailed and will be called if the connection gets suspended but not necessarily broken. And you might want to cache some information. When you succeed in making a connection to Location Services, Location services calls back to OnConnected, telling you that you're now connected to the services. And in the case of something like location, you'll then create a LocationRequest. They had passed to Location Services to get your location details back. And it would call you back with OnLocationChanged, letting you know that your location request details have changed, and there's new location information available to you. And you'll get a Location object, which you can then use to write to your screen. So in the application that we just saw, that location object included a latitude, and I was able to update my screen and write the latitude to it. Now this programming model isn't just limited to location services. As I've said, many of the services that you'll be using during this course follow a very similar programming model to this. You're going to have an OnCreate and an OnStart. You're going to have a GoogleApiClient that you connect to the services that you want to use. And then you have to handle certain overrides. Usually, they'll be OnConnectionFailed, OnConnectionSuspended, OnConnected, and then an override that's specific to the services that you're using. In this case, it's OnLocationChanged for location services. Don't worry if you don't know all of these by now. Take the best guess that you can and by the time you finish this course, this will hopefully be second nature to you. So first of all, you'll create a blank that uses your desired API. What do you think that would be? Secondly, you extend your activity with the blank call backs. Which call backs do you think they would be? Third, you also extend your activity with the blank listener in case the connection fails. And then, finally, after connecting the blank, you'll wait for the blank callback. What do you think these will be I'll give you a clue. The answer in one and the beginning of four are the same. And which callback do you think you'll be waiting for when you connect to the services? Once you've done all of this, you'd then follow the requirements of your specific API. Fill out the blanks and then continue. So the correct answers are here. First of all, you'll create a Google API client that uses your desired API. In the example I showed earlier, I was using the location services API with a Google API client. With others, you may be doing login, you may be doing maps, you may be doing other things, but you'll still be using a GoogleApiClient for that. You'll next extend your activity with the ConnectionCallbacks. These are the heart of the asynchronous programming model, where the services can call you back whenever something important happens. You'll also need to extend your activity with the OnConnectionFailedListener. In case the connection fails, so that you can handle it gracefully. And then, finally, after connecting the GoogleApiClient that you created earlier on, you wait for the onConnected callback. Once you get the onConnected callback, you know that your ApiClient is connected to the services. And you're able to make the calls on those services. And then once you've done that, you can follow the requirements of your specific API. Like for example, as you saw earlier on, I was doing location work, so I also had an on location changed method, that was firing whenever the location changed, as a result of the location request. You'll see all of this in much more detail in the location services module, as well as all of the other modules. This sequence will be used in every app that you build and you'll want to be sure that you know it as you move through the rest of the class. Since this sequence is so important, take some time to think of a good way to remember these steps and then maybe go post in the forum about it. Also take some time to read what other people have said. You might find a methodology that works for you. Some APIs will also require you to set up credentials and access using the Google Developers Console. For example, in the maps course, you'll need to enable your map to use the maps API. And if you look here on the left, there's APIs & auth. When I select that, and I select APIs, and then I select enabled APIs, you can see the APIs that I've enabled. And one of the map apps that I build, I'm using here the Google Maps Android API version 2. You'll also need credentials for some of your apps. So for sign in maps, and some of the others, the system needs to know which apps are using which resources, and as a result credentials need to be enabled. And here you can see I've selected credentials. And here you can see I've generated an API key for the apps that I've built that are using Maps. As you need them, you'll be stepped through everything that you need to do on the Google Developer's Console in the lessons, but it's good to have a look at it. Go to console.developers.google.com and have a play around. You've now gotten everything you need to get started with building Android apps that use Google Services. The API's that you've installed, give you access to all of this functionality. And they give it to you in a consistent way. Remember that Google API client that you saw for accessing your location? It's the same object, and very similar code to what you'd use to access Google+ or Maps or Wallet or Drive. You can learn these in any order you like. But the most important thing is to get started and to get coding. So, you'll see just how easily you can harness all this goodness. You should go and take the location module first, because many of the concepts you'll need for the others are covered there. Let's go. Location and context are vitally important for building the best possible mobile app. The mobile nature of the platform is that it is designed to be operated anywhere, from sitting on a bus, to sitting in your office, or beyond. As such, the behavior of your app may need to change based on your location. For example, for a weather app such as Sunshine, that you might have worked on in the developing Android app scores here at Udacity. Should you really have to type in your current zip code in order to get a forecast? Shouldn't the phone know where you are? Indeed, if you take a look at Android Fundamentals Part Two, you'll learn how to do just that. Or, for example, a music app. It's usually great to have a detailed UI that allows you to search for your music, but what happens when you're driving? Shouldn't there be a less distracting UI or perhaps voice operation? In these scenarios, along with countless others, how your device should behave is determined by the location and context of your phone. You'll learn about the powerful APIs that allow you to determine this information for your phone in a battery friendly way. There are many sensors on your phone that can be used to determine your location and the context of what you're doing. To access these in a power friendly way, you can used the Fused Location Provider and the Activity Recognition APIs. The Fused Location Provider analyzes your GPS, your cellular connection And your WiFi network. And it does this in order to get the most accurate data. With this, you can also access the user activity recognition service to determine, based on the movement of your phone, if you're in a vehicle, if you're on a bicycle, if you're on foot, if you're standing still, or even if you're tilting. Your phone provides a number of sensors that can be used to determine your location. Which of these are supported by the Fused Location Provider? The GPS system, a neural interface, spy satellites, a cellular connection, or your WiFi network. Select all of these you believe apply. The correct answers to this are GPS, your cellular connection, and your WiFi network. We don't yet support a neural interface, and spy satellites, sadly, don't offer an open API. Great. Now that we understand what the fuse location provider is, let's create a simple application that uses it. It's a very basic application that contains a single text field. When you run it, your latitude is determined and written into this text field. If you don't already have a development environment set up for Android development, check the videos linked below from Developing Android Apps, Android Fundamentals. To get your environment set up for location services, check back to the intro lesson for this course. Once you're good to go, we can build your first location-sensitive app together. Building an app that uses Google Services generally follows this pattern. First, you'll create a Google API client, and on that client you'll specify the services that you want to use the desired API. In this case, it's location services. Now, the activity that hosts this client will need to be extended for the appropriate callbacks and listeners. The first of these is GoogleApiClientConnectionCallbacks. These allow you to code against events in the Api Client itself, such as connecting, or disconnecting from the services. The next is the GoogleApiClient.OnConnectionFailedListe- ner. This can alert you when the connection drops, so that you can handle failures to connect to Google Apis Gracefully. Specifically for location services, you'll also need the location listener. And as its name suggests, it listens to location updates so that you can respond to them in your application. You then connect your clients and wait for the on connected call back. Now for this app, you're going to have code that makes a request for your current location. You put that in the OnConnected Callback, and this sets up another Callback called OnLocationChanged. And when the OnLocationChange Callback fires, it will contain your location information so that you can capture details such as the latitude, and update your UI accordingly. When you communicate with Location Services, what type of programming are you doing? Is it functional? Is it procedural? Is it asynchronous? Or is it aspirational? Check the one that you think is correct. Let's create a new app using Android Studio. We'll create a basic Android application that has a single empty activity. I'm just going to call it Location1, and it's in this location. The company domain, you can put whatever you like. I'm just going to keep that Android.example.com. I'm going to make it a Jelly Bean application for phone and tablets. And like I said earlier, it's going to be a single blank activity. I'll keep the defaults and continue. Now once this has been created, I'm going to edit the activity to add a single text view. When you run the app, location services will start getting updates and it will write details about them to this text view. To edit the text view in the activity editor, just select the Text tab and you can see what your layout would look like. So, here's the basic layout that has been built for you in the default in Android Studio. You can see, it already has a text view and the text for this is held in a string refered to in strings.xml called hello world. I'm just going to change that to something hardcoded for now. I'll just say location goes here and then I'm going to give this control an ID. So, I'm going to give it the ID like this, android:id=@+ID/txtOutput. So when I refer to this control in code in a few moments, you will see that the control will be called txtOutput. So this control is where the location is going to get written. So when we get details from location services, in this case, the latitude of the phone, we'll write it into this control called txtOutput. And if I look at the design, you can see location goes here. It's faint, but you can see it's there in this one. In the Android Fundamentals course, you learned all about the Android manifest.xml file and how this is used to add permissions to your app. But before you can access location on Google Services, you have to add the ability to use different location sensitivities. You can specify that you want fine location. Or you can specify that you want coarse location. Now what are these? Fine location updates involve using the device's GPS, cell signal, or WiFi to get the most accurate possible position, but possibly costing you extra battery life. So alternatively, you can use the coarse location, and this gets your location using only the cell signal or WiFi. It won't be as accurate as fine, but it'll cost a lot less battery power. For our project, you will need to add the permission that allows your app to access fine location. What line would you add to AndroidManifest.xml to get this to work? To give your app permissions, you'll use the user's permission tag within AndroidManifest.xml. The user's permission tag should be a child of the manifest tag, and a sibling of the application tag. It should not be within the application tag itself. Here's what it should look like. Here, you can see I've set user's permission, and I've specified that I'm using ACCESS_FINE_LOCATION. This means that I've specified my application will use FINE LOCATION. So, you've added find location to your app. But what if you just use the coarse permission? What sensors would you have access to then? Would you only have access to the cell? Would you only have access to WiFi? Do you think you'd have access to cell, WiFi and GPS? Maybe you could only access just the cell and GPS, but not WiFi. Or maybe you have cell and WiFi only. Check the box that you think applies. The correct answer is cell and WiFi only. While GPS provides very accurate position updates, it does incur the highest power costs. So, if you just want the coarse location that cell and WiFi offer at a much lower battery cost, you would use the coarse location permission. The coarse location is usually enough to know your general location, such as knowing you're in a mall or a movie theater or a sports event without giving away the exact spot. Okay, great, we now have a UI defined and our Android manifest is almost done. But because we're using Google Services, there is one meta tag that we need to add, and that's just to specify that we're using the Play Services Library. We do that like this. The metadata tag is used within the application tag and it should be a sibling of the activity, not a child. Within that, your specified Android is com.google.android.gms.version, and the value for this is atInteger/GooglePlayServices_version. Now as you can see here it's showing up red. It's showing up as an error you cant resolve symbol, but we're going to fix that in a moment. And also once that's been fixed, once your application has been configured to use these services libraries whenever you compile, this will be filled in automatically with the correct number. So let's go ahead and do that. So in order to do that there's one other place that we need to ensure that we're using the libraries for the services and that's in the build.gradle for the app itself. So if I go into the build.gradle for the app, down here you can see the dependencies at bottom of build.gradle. We're going to add a new dependency in here. So what we want to add is quite simply, to compile conduct google.android.gms:play-services:6.5+. Now it's important to note that your version here may be different. It depends on what you're using, and what version of Play Services you've installed. You can take a look in your system to see what versions have been installed for you. And I'm just using this plus, just to make life a little bit easier. I believe I have 6.5.0.87. But of course, by the time your watching this Play Services might be in version 7 or later and as you can see here, you should avoid using plus in version numbers because it can lead to unpredictable behavior. But I'm just going to leave it in for the time being, for simplicity. But do note when you're building your applications that you should use the correct version number here. So now, once we've done this, we're going to go to our main activity, and we're going to access the location provider. Now, in our main activity, remember that it contains just a single text view. When the user runs the app, we want it to get the current location using location services, and write the latitude of the current location into that text view. In order to do this, we're going to need to write some code in the activity. This code will create the Google API Client, and set up the required call backs to catch responses back from location services. So first of all, we need our activity to implement the various callbacks and listeners that we've been discussing about. So, you can see here our public class MainActivity already extends ActionBarActivity. We want to implement a few things. So we want it to implement the following. It's going to implement GoogleApiClient.ConnectionCallbacks, GoogleApiClient.ConnectionFailedListe- ner, and the location listener. Instead of you watching me typing, I'm just going to paste these in. I've now added these, but we can see we have a few errors because some of the symbols haven't been resolved. You just need to import the correct libraries to resolve them, and I've added those libraries here. We can now see that we still have an error, and that's because there are some methods that need to be implemented and we haven't implemented them yet. But we will be doing that in just a moment. Before we do that, there's a few things that I want to add to the code. First up, we just want to add a tag, which is a string, to the code that allows you to track the name of this application if we're writing it out to the log. So we do that with a private final string, it's called tag. And you can put whatever you like in there. I'm just going to put LawrenceTestApp and the code would look like this. Next there's a few local variables that we need to set up within this class. Things, for example, for tracking the text view that we call TxtOutput, the Google API client itself, and a location request object. So I'll add these now. You can see when I added them in, it detected that it needed to import this class. So just go ahead and say okay to that. And the class will be imported. So you can see here I have a TextView object that I'm calling txtOutput that will just be used to address the TextView on the UI. I have a GoogleApiClient that I call mGoogleApiClient. And I have a LocationRequest that I call mLocationRequest. Okay, now in our onCreate method, we need to set up the GoogleApiClient. And we use this with a GoogleApiClient builder, and we add the requisite APIs to that. Let's add this code and then we can talk through it. So, we go to onCreate and I'll add the code in here. So what it simply does is it creates a new builder for an API client, and it adds that we want to use the location services API by saying just LocationServices.API to the addAPI method. We want the connection callbacks on the Google API client to come to this class. And we want the OnConnectionFailedListener also to come to this class, and then we build it. So that's now going to give us a Google API client that allows us to talk to Google services. Now, if you remember, we had a UI element called a text view. And this will render the location information. Of course, we want that text view to be addressable in code, using this txtOutput class. So let's set up something to do that right now. And we do that like this. We just specify that txtOutput is found my looking for the ID, or .id.txtOutput. If you remember, when we specified the text view in the XML for the activity, we called it txtOutput, the same name as this. We just find that view and then we cast it into a text view, and now we're good to go. So just to recap, what did we actually do here? Well first, we created an instance of a Google API client using its builder. We set it to use the LocationServices API here, and then we told it what the callbacks for OnConnectionFailed were this, so we're going to be handling them within this class, or within this activity, and then we hooked up to text view to code. You've actually done a lot but there's still more to come. So let's have a quick quiz first. What interfaces do you need to implement in order to use the Google API Client with connection callbacks, connection failed listeners, and location listeners? Read these pieces of code carefully and then check the one that you believe applies. The correct answer is this. You implement GoogleApiClient.ConnectionCallbacks, GoogleApiClient.OnConnectionFailedListe- ner, and a LocationListener. It's important to remember these in your activity. If you don't, you'll discover bugs when you implement the interface functions later, because you're writing them in a class that doesn't support them. So, before going any further, think about what we've done thus far. We've set everything up in our environment to give us location services. And in our main activity, we've created a connection to them and instructed the API to call back to this activity when it connects, as well as when the connection fails. We don't yet have enough code to run the application. There are several overrides that we have to add because of the interfaces we specified. Let's take a look at these next. When building an app that uses location services like this, there are a number of events that happen in the app lifecycle, in addition to the usual activity lifecycle events. Let's take a look at the entire set of events, one by one, and specify what we need to do in each. First of course, is the OnCreate method. We've implemented this already. This is called when our activity is created. In this we set up the GoogleApiClient. And we tell it to use location services and the location of the call backs to call when stuff happens on the client. Once OnCreate has done its thing the app will start running. And because we're using asynchronous callbacks on the GoogleApiClient more functions are going to fire while the client is running. So immediately after OnCreate Android calls the OnStart activity. And in this we will tell the GoogleApiClient again to start connecting to location services. Depending on the relationship between the client and the location services, one of three things will happen. If it connects successfully the OnConnected callback will fire. We'll look at this in a moment. If it fails, the OnConnectionFailed will fire. If it was previously connected, but something has gone wrong with the connection causing it to suspend, then the OnConnectionSuspended will fire. You need to implement all three of these functions or your app won't compile. So be sure at the very least to put a logging line in the ones that you don't want to write detailed code for yet, for example the OnConnectionFailed and the OnConnectionSuspended. Now let's look at OnConnected. In this method, we'll create a new LocationRequest object. We'll set its priority, we'll set its interval, and then we'll start requesting updates from Location Services. We'll see what that code looks like in a moment. Now when the Location Services see a new location for the device, they will then give a callback to OnLocationChanged, and this will give you a location object. This object, you can parse with details about the location, such as the latitude and longitude. You've seen the OnCreate already. This is where we created the GoogleApiClient and the textView object for the text field in our UI. As you might recall, we also need to connect our GoogleApiClient in the OnStart method. And we also need to disconnect it in the OnStop method. Take a moment to write the code to do this now in these methods, and check the box when you're done. Wonderful. These functions are each fairly small. And you'll be including this code in every app that uses location services. The version I wrote begins with onStart. This simply connects the GoogleApiClient to the services by calling the connect method. Next, we also see onStop. So, if something happens that stops the client from accessing the services, it disconnects. And you should explicitly disconnect it in the onStop method. The next part is new. You'll be writing the unconnected function, which will involve creating a location request object. You'll then set its priority, and its interval. And then, you'll request location updates from location services, using your Google API client and the location request object. Take some time to look through the documentation, and then write the onConnected function. When you're done, check this box. The on connective function has at a minimum three steps. And I've coded them like this. First, I created location request object, then, I set its priority. And I set the priority to use priority high accuracy, as you can see here. Then I set the interval, and in this case, I've set the interval to be a 1000 milliseconds, so the location will get updated once a second. Then using the LocationServices.fuselocationApi, I can start to request location updates. The parameters that this take are simply the API client that we're using, the location request that we've just set up. And the class to receive callbacks, in which case it's this class. Since the location services class and the location request class are both very important here, it's a good time to take a moment to go to the forums, and to discuss how they differ, and how they're related. Be sure to read some of the answers provided as well. It's an excellent place to find places where your mental model may not quite match the way things are actually working, or if you're stuck with anything it's a great way for you to get started. To code the unconnected function, we used functions of the location request object. First of these was setInterval. Now, this sets the desired interval for active location updates measured as a period in milliseconds. So right now, if it's set for a thousand milliseconds, that means it will check the location once every second. That's pretty fast. So, if you wanted to change that to be less frequent, for example, once every ten seconds, you could just change this to 10,000. Remember, it's always measured in milliseconds. Then we use set priority. This is used to set the priority of the call, as it's name might suggest. The priority is a strong hint to the location client about which location services it should use. There are many factors about which physical devices it will use, such as the available hardware on the phone. It has four potential values, so let's take a look at these. This one that I'm showing, PRIORITY_BALANCED_POWER_ACCURACY, will give you accuracy to about 100 meters. It's nicknamed block level accuracy for obvious reasons. It's course, and very battery friendly compared to some of the others. PRIORITY_HIGH_ACCURACY will give the finest possible location, based on phone hardware. But, as you can imagine, this could impact your battery much more. PRIORITY_LOW_POWER will request what is nicknamed city level activity. It gives you a range of about ten kilometers. It's a very low power consumption activity. And finally, PRIORITY_NO_POWER will request the best possible accuracy at no power cost. So if other clients in the app have gotten a location, this can actually be a passive listener to them. Do note, that if you have set the access course location in the Android Manifest, it will override these settings, and can effectively reduce the frequency of location poles, as well as obvious gating it's accuracy. It's important to consider these values you set these parameters to, as they can have a huge impact on battery life. As we saw with the priorities and coarseness, battery usage is impacted by which sensors you activate. However and maybe with a bigger impact is the interval that you use, consider how often you really want to read the sensors. In this case, you can see we ping them once a second, which isn't too bad. But do you really need that level of accuracy? What would happen if you were more accurate and pinged them a hundred times a second? What would your app experience be like if you ping them once every ten minutes instead? These are the type of questions that you need to consider for your users, when designing an app that uses location services. So for example, an app for a hockey coach might want very frequent updates of players' locations on the ice during a game. So the coach can plot that data after the game, to see the players' effectiveness. Conversely, an app that tells you if your kids are home yet might only need to check your location details a few times per hour. Following on from that, we have our functions for on connection suspended and on connection failed. For now, in these, I'm just going to log that the event has happened. And you can see this here, log.I, log tag. Google API connection's has been suspended. And similar here, Google API connection has failed. Now we're almost done. And we are almost ready to get location updates from our phone. Now there is one more thing that needs to be implemented, and that's the on location changed call back. Now I've created a simple skeleton for it here. Here you can see what I am doing is the on location call back gets a location, that I call location with a lower case l. And I'm just going to log the location.toString and I'm going to set tax location.tostring on that as well. So we can see the full location details. So let's run this code and see what actually happens. Here we can see what has happened after I've run the code, and it's not the friendliest in the world, does it? But we can see that it's basically working. We can see our latitude, and our longitude, and acceleration and altitude and even bearing. So all this is just because we converted the location to string. But let's pull out, say for example the latitude, and get the latitude information and put it in. And you can actually see that it updated there and it just updated again, because of slight movements and me moving the phone. So let's update this and see what happens. Now if you'll recall, I just had set the txt output to be location.tostring. But let's make this something a little bit more interesting. For example, let's pull out the latitude from this and we'll work with that. And the easiest way to do this will be I'll just paste the code in. And we can see here that what we're going to do is we're going to set the text to be location.getLatitude. Now this returns a double, so of course we have to pass that to Double.toString in order to convert that double to a string. So now, just the latitude from the location object will be written to the text view. So let's run that and take a look. So now here, we can see the same application is running. But I've just gotten the latitude of my current location, and I've written it into the text label. That's a lot friendlier. And we could use that for example to have a tax label for latitude, another one for longitude, another one for altitude, etcetera, etcetera, etcetera. So very straight forward and congratulations you've just gotten your first location updates. When you create an application that uses Location Services, there are a number of steps that you'll typically follow. I'm going to list the six steps here. And you're going to have to fill in the blanks as to what you're going to do in each step. The first step is, you're going to create a something that uses the Location Services API. Think about what that is. The second step is that you're going to extend your activity with the number of callbacks. What do you think those callbacks might be? The third step is that you then extend your activity with a particular listener in case the connection fails. Do you remember what that listener is? The fourth step will be that you continue to extend your activity and you extend it with another listener. This time it's a listener for location updates. Again, think about what that is. The fifth step is, after you've connected, there's something will wait for the something callback. What do you think that is and what callback do you think it's waiting for? And then finally, in this callback, you'll set up something, and it's another callback, and in this you can capture your location information. These are all the steps that you'll typically follow. Can you fill in the blanks? The correct steps for setting up a location services application are as follows. First, you create a GoogleApiClient that uses the location services API. Then, you extend your activity with the GoogleApiClientConnectionCallbacks. The next step is to extend your activity with the GoogleApiClient.OnConnectionFailedListe- ner. You use this in case the connection fails. Following that, you'll extend your activity using a location listener, and this listens for location updates. After you've connected the Google API clients, you'll wait for the on connected callback. And then finally, in this callback, the onConnected callback, you'll set up the onLocationChanged call back. And in this you can capture your location information. This sequence will be used in every app that uses the location provider and you'll want to be sure you know all of these as you move on throughout the rest of this class. Since this sequence is so important, take some time to think of a good way to remember all these steps. And then go ahead and post in the forum about it. Practice always makes perfect of course. And do take some time to read in the forums what other people have said, and you might find a pneumonic that works for you. I just got it down after a little while. I hope you could do something similar. Welcome to the wonderful world of Location-Aware apps. In this lesson, you learn the basics of using location services, including the most parts of setting it up for use in your app and also how to optimize for battery use. In the next lesson, you'll work through a simple sample that gets some of the useful date from location services that go beyond latitude and longitude. You can use the techniques that you will learn to get cool stuff like altitude, bearing, and speed. You'll see more about how location services give intelligence, such as getting the address at your current location. These are the beginnings of understanding context, which will then give you the ability to do cool stuff, depending on where your device is in the world. Are you ready to get started? Let's go. So far you've seen how to access the location services that are available to you, and how to plan for location accuracy versus power cost. You learned how to build a very simple application that gave you your current latitude. Let's look at extending this to get more geographic information. So here's the application that you're going to build over the next few minutes. It's a simple app that gives you your latitude and your longitude, helping you to accurately position yourself on the globe. Now as you can imagine, there's lots of great uses for this kind of information. One of the first mobile apps I personally ever built was for dog walkers. They would run the app when they walked the dog for someone else so that the dog's owner could see the path of the walk. It worked by taking a very accurate latitude and longitude reading every few seconds. In this case, of course, we're just taking it once. But let's see how you would do that. Let's see how you would get that type of information. In the previous lesson, we were getting continuous updates on the location, but in this one we're going to do it a little differently. We're going to get the latitude and longitude only once upon connection. Now I think it's important to learn by doing, so we're going to learn how to build this application by stepping through what needs to be done little by little. So if you haven't already done so, open Android Studio and create a new project. Give it a name, in this case I'm calling it Location2_1, and you're going to pick it to have a single blank activity. So you can see here in this option I'm going to say blank activity, I'm going to give it a single blank activity, and I'm going to keep all the defaults. And when Android Studio's finished doing its thing, you'll have your project created for you, and the activity, generally by default, is opened. But if it isn't, just find the layout folder and look for activity_main within that folder. Then you can see that this is the basic hello world layout that's created for you. So what we're going to do is we're going to just take a look at the tags for this, and we can see in here there's a TextView simply containing the words hello world. In the next couple of steps we're going to change this to update it for the UI that we showed in the demonstration just a moment ago. Here's the user interface for the application again. As you can see it has text views for the Latitude and Longitude labels, as well as others that act as labels so that the user knows what the values are. Your task will be to modify your layout to match this picture. When you're done, check this box. So if you've updated it correctly, your view should look something like this. Here's my four TextViews with all of their details. Now notice that I've named them accordingly, so I have a latitude label that I called latitude_label. I have the latitude text where I'm going to write whatever the latitude of the device is, and I called it latitude_text, and ditto for longitude. Here's the label and you can see, here's the text. Now, one thing to note is that I am hard coding the text in the labels as you can see here, longitude goes here. Now best practice would be to put that in a string resource. And if you haven't learned how to do that yet, Go to the Android Fundamental's course, follow the link below to learn how. It does make it much easier to maintain your app, as well as of course, doing things like localization. So if I touch on Design, now this is what our user interface will look like. Before we go to the code, we'll need to go through the rest of the steps as discussed in the last session. You'll do that next. To use Location Services, you have to have the SDK installed. If you haven't done this, please go back to the previous lesson to be sure on how to do so. Also, to use Location Services, your Android app will have to refer to the service libraries in the build.grade file. Check the box when you're done with this, and ready to continue. In the build.gradle for your app, you'll need to tell the app that you're using the service libraries and you can do that with this line, compile 'con.google.android.gms:play-services:6- .5+'. Now, one thing to note is that you really should use the full version number here instead of the + the way I've done. At the time of recording this, this would be 6.5.87. But you might have a later version. If you have any problems compiling, it might be because this number is wrong. To check what you have installed, you can look in your maven repository and you'll see the libraries with their version number. Check the instructor notes to see how to find the repository on your machine. But I'll just demonstrate it here for this machine. So first of all, you need to find the SDK path. And in Android Studio, there's a nice little trick that helps you to do that. Simply open the SDK Manager and you'll see the SDK path is listed at the top. So once you have the SDK path, if you use a terminal like this, you can change to the SDK path by just saying cd and the path directory itself. In my case, Wacky Users, Wack Udacity, Wack Library, Wack Android, Wack SDK. Now once you're in the SDK path, you can take a look at extras/Google/M2repository/com/Google/A- ndroid/GMS/play-services. And you'll see all the versions of the play-services library that are in there. And in this case, the most recent one is 6.5.87. So if I were to go into my build.gradle, I could just use 6.5.87 instead of 6.5+. But I'm just leaving it here for convenience right now. But, again, strongly recommended. Find the latest version that you're using and put that full number here instead of the 6.5+ that I'm actually doing. There's a couple of steps that you'll have to follow to add some lines to your app.manifest. The first, is to specify that you're using the Google services that you've already downloaded and included in your build.gradle file. The second, is to specify the permission to access fine location. When you're done with these, check this box. To add Google Services you use a meta-data tag in your app manifest.xml. Here I've pasted it in and you can see it's a meta-data tag as a child of the application tag. You're specifying that the name is the gms.version and the value is this integer/google_play_services_version. This will get replaced for your actual run time or whenever you compile. But just leave integer/google_play_services_version, and Android studio will do the rest. In addition to that, we want to specify find location, and we do that using the user's permission tag. So the user's permission tag goes here under the application and above the closing manifest. And again, we're just saying, uses permission, and the permission that we're going to use is access find location. If you're asked to do so, like I've been asked here to do a grade all sync, go ahead and do that. And that's, once we're done, we'll if everything compiles okay. If you look closely at the bottom of the screen, that's where Gradle provides its update of what it's actually doing. We can see that it's synced and everything worked. We have no errors, so let's go ahead and write our code. Okay, so now we have the lay out for our activities as designed, and our manifest and grader files are set up. So the next thing to do is to write the code. If you haven't done so already, open up the main activity and at the top you'll see there are a number of imports. We have to add a few more. Let's take a look at what they'll be, I'll just paste them in. So you can see here, these are the imports that we're going to be using. Things such as the login utility, the text View control that we've seen earlier on. A location object that we're using for determining location details, and then all this stuff that's going to be used by the location services; connection results, API client, connection call backs, the on connection failed listener. And of course the location services themselves. So these provide all the classes that we're going to be using, and next we're going to edit main activity code itself. We can see that the basic one that we have just extends action bar activity, but we need a few more interfaces. To have connection callbacks and to be able to handle connection failed events, what do you add to your public class MainActivity extends ActionBarActivity? Do you add the first line where you say you implement ConnectionCallbacks and you implement OnConnectionFailedListener? Do you add the second line where you say it implements ConnectionCallbacks and OnConnectionFailedListener? Do you pick the third line where you say adds ConnectionCallbacks and OnConnectionFailedListener? Or do you do nothing, it works already. Check the box that you think is the correct answer. The correct code to add is answer two, this one here. You want to set your activity to implement ConnectionCallbacks and an OnConnectionFailedListener. Let's go over to Android Studio and see what that looks like. Before going any further, let's put some module level variables into our code. We can see these are pretty straight forward. The first one is just the tag that we're going to be using, and the tag is just the string with the details of the application that you're going to use for logging. Then we're going to create a Google API client, called mGoogleApiClient, a location object that we call mLastLocation, a text view object, that we call mLatitudeText, and another text view object, that we call mLongitudeText. So next up, what we need to do is update the onCreate function. We're going to create it to set the content view, get a reference to each of our views, and then finally build the Google API client. Let's see what that looks like. So here's the code. I'm just again, creating a text view by finding the latitude text and setting that to my latitude text, text view. And then ditto with the longitude text, finding the item, cast it to a text view and assigning it to longitude text. And then I've written a helper function called buildGoogleApiClient. As you can see, it's red right now. That's okay, it's just because I haven't actually implemented this yet. We'll do that in the next step. As you might recall from previous lessons, when you create your GoogleApiClient, you have to use a builder. And you have to tell it the connection callbacks, such as OnConnectionFailed, OnConnectionSuspended, and OnConnected. You then add the Location Services API to it in order to access location, so when it is called, Location Services can do its thing. Write your build GoogleApiClient method, and when you're done, check this box. Now here's how you would create the Build Google API client function. And it's very straightforward, where you add connection call backs, you add an unconnection fail listener, you point them both back at this object and then you add the API for the location services API and build it. So now, mGoogleAPIClient becomes your point of reference for communicating with Google services, in order to get location details. When your application starts, Android will call the onStart override. How do you get this to connect to your Google API client? Here's the code, and fill this line in for yourself. To connect the GoogleApiClient, you simply call its connect method, like this. Now, when Android starts your activity onStart will fire, and the GoogleApiClient will be connected to location services. Conversely, when the activity stops, Android calls the onStop override. In this case, if the client is still connected, we should disconnect Google API Client. So fill in the lines of code that will achieve this. You want to check if the client is still connected, and if it is, you want to disconnect the Google API Client. How would you do that? When the activity stops, you'll want to disconnect your API Client. Of course, you should only do this if you are already connected. So you should check if Google API Client is connected. And you do that very simply with this method. This returns a boolean for you. So if mGoogleApiClient.isConnected returns true, then you want to be able to disconnect your client. And then you can do that very simply by calling the disconnect method, as you can see here. After we connect the client in the onStart, it takes some time for the connection to happen. And when it does, the onConnected callback will fire. This is the meat of our app. We've connected to location services, so we should be able to get the last location from the fused location provider. And if we do get something, then we can read the latitude and the longitude from it. We convert that to a string and then load it into the appropriate text field as you can see here. Now, remember, all this will happen if last location is not null. So, here I've just checked if mLastLocation is not equal to null, then I will do all of this. Because if it was equal to null, then getting the latitude and getting the longitude might produce an error. Here's a stub of code for the onConnected callback. How would you edit this to get the latitude and longitude? I've started the code for you. First of all, you have to set mLastLocation to something. And you would enter the code here. Then if it is not equal to null, then you can set the Latitudeext. By entering this code and the LongitudeText by entering this code. Fill in the code and then continue. So here's the code that will do this for you. mLastLocation is set up by getting the last location from the FusedLocationApi for the API client. You simply say LocationServices.FusedLocationApi.getLa- stLocation and then passive the client. This has getLatitude and getLongitude properties, which will return a double. So you can just call these and then convert that to a string, with String.valuieOf and then set the text of labels accordingly. Now, finally, there are some overrides that we need for when the connection fails called onConnectionFailed, or the client gets disconnected called onDisconnected. For these, we'll just log the event, and in the case of failure, we'll also log the relevant error code. And now that we've added these, we've gotten everything that we need, so let's run the application and see what happens. Awesome! As you can see, it works. Now take some time to make your changes and finish up the app on your own machine. Maybe you could even do something simple like making these labels a little big bigger so they're easier to read. Have fun playing with the application and seeing the kind of things you can do with it. Maybe visualizing latitude and longitude in a lot more nicer way than we've done here, by just using numbers. You might be able to use, like, a dial on a compass, or something along those lines. Well, whatever you do, have fun with it and let's see what you can do next. At this point, we've built an application that got the latitude and longitude of your device. Well done. Did you notice a difference between this app and the one we created earlier? This app just updated the lat-long once, and then it left it at those values, whereas the previous one updated the data periodically. Now what did we do differently this time? Take a look at the code and see. There's an important and distinct difference between the two samples and learning what that is will help you build better location apps. If you need a hint, take a look in the unconnected override and you'll see the difference between the two apps. Now that you've reviewed the code for the last couple of apps, how would you update this app to provide continual updates? Now depending on requirements, it sometimes makes sense to have a continuous update. For example, if you're writing a dog walker or recycling app, or something else that's going to plot your position over time, you'll want continuous updates. Now, I've given you a little hint. Your MainActivity extends to ConnectionCallbacks here and an OnConnectionFailedListener here. But to receive continuous updates it also needs to be a location listener. How would you do that? In order to get continuous updates, the first thing you need to do is ensure that your activity is a LocationListener. So you'll have to implement this interface. You can find it in com.google.android.gms.location.Locatio- nListener. If you don't want all of this in your class declaration, of course you can just import the name space and then extend LocationListener, and that should work well. You'll also need a module level variable for the location request. So be sure to add it at the top of your code along with all the others. It should look something like this, protected LocationRequest and you give it a variable name. In my case, I've called mLocationRequest. Once you have that in your on connected, instead of just getting the last location, you would setup a location request class with an interval for polling the location services. You'd then request location updates, calling back to this activity. You have a location request called mLocationRequest. And you want to set it to give you highly accurate location updates every second. To do it every second, you call the setInterval property and pass it a number of milliseconds. And as you can see here, I've passed it 1000. But what's the rest of this code? How would you set this up with a call back to this activity? You would do everything in your onConnected method, as you can see here. So what do you set the mLocationRequest to, how do you set the priority, and what do you do to the FusedLocationApi? Fill in the details, and then we'll see you in the next video. Here's the solution. To create your mLocationRequest, you just simply call LocationRequest.create and then to set the high accuracy priority, you call LocationRequest.setPriority and pass it a constant PRIORITY_HIGH_ACCURACY which you'll find in the location request class. You've already set the interval to 1000 milliseconds so then finally, all you have to do on the FusedLocationApi is requestLocationUpdates and pass it to GoogleApiClient, to LocationRequest, and this referring to this activity so that the call backs will come to this activity. All of these code should be on one line, I've just broken it up into separate lines here for easy reading. Now because you were requesting location updates, you'll need to implement a call back called on location changed which, as its name suggests, will get called whenever the location changes even just a little with this interval and this high accuracy determining that. When you implement the OnLocationChange callback, you can write the latitude and longitude that you receive from location services to your UI. This is essentially the same as in our old OncConnected method before we switched to continuous updates. If you remember there we had location.getLatitude that we converted to a string loaded into mLatitudeText. And similarly location.getLongitude, that we converted to a string and loaded into an longitude text. Now, we had done this previously in On Connected so we would just get it once whenever we connect, but now that we're using the fuse location API and we're requesting location updates from that, those location updates will be called back to us in the on location change function. And as a result, we'll get continuous updates. Great! Now, you've written an application that gets continuous updates. And you've converted an application that gets a single update to one that gets continuous updates. You've see all about different ways to access the location services available to you. But as well as location, you can also do context, where you can detect what the phone is doing. Is it on a bike? Is it in a car? Are you walking? Are you running? You can detect this type of activity using the activity recognition APIs. Let's take a look. Here's the completed app for looking at activities. I've started to show all the possible activities it detects and you can see that it has a percentage for each one. For example, when I was testing this earlier, it determined there was a 45% chance I was on foot, 45% chance walking, 25% in a vehicle, etc. Now it can't be 100% sure for some activities, so it's up to you as a developer to figure out what works best. When you start a car for example, you're driving really slowly. And it might think you're biking or running for example. This app will just show you how to get the data, its up to you to figure out how to use it in the best possible way for your app. You're going to build this from scratch. As before, you'll create a new application with a blank activity. Android Studio will take you to the activity designer, and as you can see, here, it's populated with a very basic hello world text field. I'm going to paste it in the UI declaration for the activity recognition app, and you'll see the code for this in the instructor notes below the video. So, I'll just replace all of this with my code. And my code, as you saw, had the two buttons for requesting activity updates and for removing activity updates. And then this text view, which just had the details of the activities. Now you'll see that there are some errors. This is because I don't have any strings set up. These are values that you specify using XML files, keeping them separate from the UI declaration. This is good practice. To this point in the course, I've been hard coding them, but that's not a best practice. I'm not going to go into detail on explaining them now. Check out the Android fundamentals courses, or the documentation for how they work. It's pretty straightforward and once you've done it a few times, it becomes second nature. I'm just going to paste in these string values. And you can get the code from the instructor notes. Strings are in res > values > strings.xml. You can see there isn't much in here. And I'm going to paste the new stuff in. So now I've pasted in all the different string resources that I'm going to be using in this application. And if I go back to my layout file, we'll see that the red has gone away, that those errors are now fixed. Next, as you've done before, you'll need to update your build.gradle to use the services libraries. Build.gradle can be found in your gradle scripts, and that's the one for the module app. And you can see it here. I'm just going to paste it in my Play services version. Do remember that when you're building this to check the version of the library. I'm just using 6.5.+ here. If you have a later version of the library, use that, and also try to use the specific latest version of the library you have on your machine as we demonstrated earlier. For the purpose of keeping things simple, I'm putting the plus in here, but that's bad practice. Also, the name may change. Just look out in the documentation. At the moment its called com.google.android.gns:play-services, but this name may change over time, so just keep an eye out for that. Once you're done with that, you also need to update the app manifest. The first thing your going to add to the app manifest are details on the services libraries that you're going to use. You enter these just above the closing application tag and I'm just going to paste mine in. You see right now it has red indicating an error, but when I do my next grade, I think that'll go away. You don't need to worry about that. And the final thing that you have to add to your app manifest is the ability to use the activity recognition APIs. And you do this with a user's permission tag. So, I'm just going to go to underneath my application tag, and I'll paste in the user's permission. So you can see, I'm just setting it to user's permission. And the Android name is the activity recognition details. So now my manifest is set up, my build.gradle is set up. So I've done everything I need for my project to work for activity recognition. So now all we have to do is actually write the project. Take some time now to get your own app to the point tha we just showed. You'll need to do the following steps. First, create the app. Then, edit the layout, and remember the layout code that I used is pasted in the speaker notes. Then, add strings.xml, and use the strings that I provided also in the speaker notes. And then finally, update Build.gradle And AndroidManifest.xml. Make sure you do all of these before continuing. Back in the introduction, we spoke a little about the various programming models that you'll use when building Android applications. And in particular, using Services to build them. One pattern that is available to developers for a synchronous programming in Android is when you use an IntentService. When using these, clients send requests through a method called StartService. And if needed, the service then starts and it handles each intent in turn using a worker thread. It captures all of these in the onHandleIntent override and when it runs out of work, it will simply stop itself. This design pattern is commonly called a work queue processor and it's often used to offload tasks from an application's main thread. We'll be using one in this sample but I won't go into depth on how it works, just on how we can use it for our own needs. If you're interested on how it works on a deeper level, take a look at the resources in the instructor notes below. Let's get started. At this point, our only code module is our main activity. We'll get back to that in a little while. But first, let's create our intent service. We're going to call DetectedActivitiesIntentService. I'll do this by creating a new Java class, and calling it as I said, DetectedActivitiesIntentService. So here you can see my new class has been created for me, but there's a few things I'm going to need to set this up. First of all, there should be a tag that we're going to use for logging events and a constructor for the class. Here's the tag I'm setting up, I'm just calling it detection is, where is stands for intends service and here's the constructor, and all I'm just going to do with the constructor is super the tag. There's one more thing that I need to do, and that is because this is an intent service, I have to get it to extend the IntentService class. And we do that right here. Because I've pasted IntentService in, and Android Studio recognized that I haven't imported that yet, It's asking me if I want to import it, and yes of course, I do. You may notice that I have a red under line here, and that's because I haven't implemented on the on handle intent yet. And if you remember earlier, we mentioned that you have to implement that, and you pass the desired intent to that, so we will do that next. Handling the Intent in the Intent Service requires a few steps. First, you'll get the activity recognition result from the Intent. Luckily enough, that can be easily extracted using the .extractResult() method on ActivityRecognitionResult. This result will give you an array list of detected activity objects when you call the getProbableActivities( ) method on it. Once you have this, you need to create a new Intent on which you're going to send the results. It's good to give it a name with the package of your app or something like that added to it, something that's easily recognizable. You should set this up as a constant in a constants file. Once you've got this new Intent, you can then add the detected activities array list onto it. And finally, use a LocalBroadcastManager to broadcast the Intent so that it can be picked up. Go ahead and implement the on handle Intent override now, doing all of these steps. You'll see the solution to this in the next video. Here's what my onHandleIntent should look like. It of course accepts an Intent that I'm just calling intent with a lower case i. >From this I'm going to create an ActivityRecognitionResult object. And I do this by extracting the Result from the Intent. I then create a new Intent that I call localIntent and I initialize this with Constants.BROADCAST_ACTION. Now what is Constants.BROADCAST_ACTION, you may ask? Well, I've created a Constants.java file, and in that Constants.java file, I create a number of constants. Now when I'm creating the broadcast intent, I need to identify that. So I'm using BROADCAST_ACTION to identify it. And I set up BROADCAST_ACTION as PACKAGE_NAME Plus the string .BROADCAST_ACTION. While package name can be anything I want, but of coarse I'm just using the full package of my app. And as you can see here I called it package lmoroney.com.udacityactivity, and that's what I called it here. So the broadcast action would be that with .BROADCAST_ACTION added. So that's my new Intent. Now I'm going to create an array list of detected activity. And this array list is going to be initialized based on result.getProbableActivities. So this will return to me the results that the activity API is saying, this is what I think is going on at this moment in time. And if you remember when I showed the demo earlier on, it had a number of different options, and that's all the different probable activities that are available. And they are returned in an array list. And of course its an array list of detected activity. So I just log out what I'm doing and now in my localIntent I put this data, the detected activities as an extra on it. And I just want to identify that again using a constant and I call it Constants.ACTIVITY_EXTRA. If we go back to my Constants file, you can see ACTIVITY_EXTRA is just the package name with ACTIVITY_EXTRA added on the end. And then finally, back in my DetectedActivity Intent service. I'm just going to call the Local Broadcast Manager, getting an Instance, and then sending a Broadcast of this Intent. We;ll be catching that Broadcast in the main activity, and in the main activity we'll update the UI. With what the activity recognition API's detected about the actual device. There's one final thing, we need to tell Android about this intent service, and we'll do that in the Android manifest. Here you can see the Android manifest and I just have to paste the service details in. Now I usually do it here just before the closing application tag. And in doing this I just create a service tag. I give it the name prefix by a dot. So our service was detected activities intent service so the name is .DetectedActivitiesIntentService and then to just say android exported="false". With this we've now created the intent service when we're ready to build the main app. Great! You've just implemented the work horse of a very complex and powerful design pattern, the IntentService. To learn about intents and how android uses them for a synchronized functionality, check back to the android fundamentals courses. They will make you a better developer. Now that you've built the service, you'll need to build the activity that calls the service. Remember earlier we saw it. You'd press a button and various activity types will appear on your screen. Well that's what's next on your list, so let's get coding. Our Main Activity class will use the Google Services and the Google API Client in the way that you're probably familiar with by now. And, the first thing that you're going to need to do is, on the Class Declaration, you have to implement onConnectionCallbacks and onConnectionFailedListener. Once these are added, the class will then expect a number of overrides to be implemented. These are onConnected, onConnectionSuspended, And onConnectionFailed. So, go ahead an implement these now on your main activity, and check this box when you're done. So here you can see how I've added to the MainActivity. I've set it so that it implements GoogleAPIClient.ConnectionCallbacks and GoogleAPIClient.OnConnectionFailedListe- ner. I've then implemented the onConnection function, which takes a bundle connectionHint and overridden it. I've implemented onConnectionFailed, which takes the ConnectionResult that I call result and I've implemented onConnectionSuspended and this takes an integer which is the cause. You should log each of these events as they happen, but just for brevity I'm leaving them blank. In the onConnectionSuspended when you have a Google API client, you should connect it but I haven't defined my GoogleAPIClient yet. And so I've just commented it out. So then you're going to do this in the next step. And we'll get our onCreate function going so that we can set up the GoogleAPIClient and the UI and the other goodies. To set up your own create function there's a couple of things that you need to do. First of all you're going to to need member variables for the various aspects of the UPI. Use a TextView for the status as you had in the layout and you ought to have button controls for request and remove. So create these member variables and then in uncreate use find view by ID to set them up. Then of course the next thing you need to do is to build the GoogleApiClient itself. So go ahead and implement this now in onCreate, and check this box when you're done. So here you can see I pasted my code in. First of all, on my class, I've created a few member variables. I have a Google API Client, called nGoogleApiClient, I have a text view called nStatusText, and I have two buttons called requestUpdatesButton and removeUpdatesButton. Then in uncreated self, I set up these variables, so request updates button, I use find view by ID to get the request activity updates button. And if you go back to the layout file you'll see that's what we called it. Ditto for remove updates button, I use find view by id to get the remove activity updates button. And then finally for text, I cast to a TextView, and I use findViewByID the detectedActivities. So these are my three controls, the requesting updates, the removing updates, and the status text that you may recall from the demo we showed earlier on. And then finally in OnCreate, I just called this helper function called buildGoogleApiClient and build a Google API client is the standard thing that you've seen all along, where I create a new GoogleApiClient.Builder and I pass it the various parameters. Adding the on connection callbacks to this, adding OnConnectionFailedListener to this, adding the API to be the ActivityRecognition.API because that's what we're doing. And then building it, and setting that to be my nGoogleApiClient. So now that' we've done this, the next thing that we want to do is that we want to remember on our intent service we were broadcasting the activities back and we want this class to receive them. So we have to implement the receiver details on it. Remember earlier, we implemented a DetectedActivitiesIntentService, and we saw that we sent the array list of detected activities back to our main class using the local broadcast manager. Well you can receive this in a class that extends BroadcastReceiver. And to make life even easier, this class can be embedded in the main activity as a nested class. If you're not familiar with nested classes, you can learn more about them in the link that I've put underneath, in the speaker notes. So next, you should create a nested class, and you should call it ActivityDetectionBroadcastReciever. And this should extend BroadcastReceiver, as we've said, and it should override a method called onReceive which takes a Context and an Intent. When you've done this, check this box. So here you can see I've implemented the ActivityDetectionBroadcastReceiver class, and this extends BroadcastReceiver as we had said. In here I've just created the onReceive @Override and this takes a Context context and an Intent intent. Now you may notice that this class is embedded within the main class, here's my opening bracket for the class, and here's the closing bracket for the class. But underneath here, we still have the closing bracket of the main class, our main activity, and there is its opening bracket. So our entire class is encapsulated within the main class, and this is really useful because we can then pass data back to the main class, or call methods on the main class from inside here. So what we're going to do now is implement the onReceive function. So this is going to catch the data that was broadcasted by the local broadcast manager with the activities details. And we'll take them and use that to update the UI on the main class itself. In the onReceive that you've just implemented, you got a context and an intent. Now remember earlier when you broadcasted the detected activities, you created an array list of detected activities and you put them into the intent. See now if you can create a new array list of detected activities and get them out of the intent. And here's a hint, you can use the get parcelable array list extra method. On the intent to do it. Check out the documentation for that. But that's the key. Now, once you've done this, you're going to easily iterate through this array list of detected activities, and you can get their type using the getType. Once you've done this you can iterate through the DetectedActivity objects in the ArrayList. Getting their type and the confidence for this type using the getType and getConfidence methods. Note that getType will actually return a code and not the string for the activity. You can find these codes on the DetectedActivity class. Go ahead now and write a helper function that turns this code into a string, and then implement this on your onReceive. When you're done, check this box. First, let's look at this helper function that turns the detected activity type code into a string. It's a very simple switch statement that just looks at the different codes, be they in_vehicle, on_bicycle, on_foot, etc. And then returns a string from our resources file that matches this. So if I have detected activity in_vehicle, I'm returning the string for r.string.in_vehicle. And if you remember earlier on, when we pasted into our strings file, I had put those codes in there. So if I come back down to my strings file, here you can see I have things such as in vehicle, in a vehicle on bicycle, there's on a bicycle, etc. So I've just set up those strings in my strings file. And then back on my main activity, whenever I detect that code, I'm just returning the equivalent string. So now, let's take a look at what we've done in the on receive function. Now if you remember, you created it earlier on and it received a context and an intent. So what do we do? Well, first of all we create a new array list of detected activity. I call this updated activities and we just get the value of this from the getParcelableArrayListExtra that we spoke about. Now if you remember when we pushed the detected activity array list onto the intent, in the intent service, we called it by a name, which was Constants.ACTIVITY_EXTRA. So we just use that name to address it to get it right back out. So now we have the array list of detected activities in our main activity, or at least in the nested class within the main activity. So now we can just go through and update the status string as a result. And because this is a nested class, I can actually call mStatusText directly. So now all I have to do it I say String strStatus equals empty to empty it. And then for each activity, for each DetectedActivity within this updatedActivities, I now just update my status to be the string that corresponds to the actual code returned by getType(). And then the actual confidence as a percentage. So the confidence is returned as a percentage. So I just put the percent character afterwards on a new line. And that's where we were able to get all of the activities that we saw on the demo earlier on on new lines and a rough estimate of what of the accuracy of that activity. Now there's one more step that we need to do, and we have to declare this receiver class on the main activity and make sure that we're using it. This is pretty simple. Let's go ahead and do that right now. So first of all, on my MainActivity class where I've declared these other member variables, I'm going to declare one for our broadcast receiver, and here it is. I'm just saying protected ActivityDetectionBroadcastReceiver and I'm going to call it mBroadcastReceiver. Then in my onCreate function, as I create all the other member variables, I'm just going to come in here and paste in that mBroadcastReceiver is a new ActivityDetectionBroadcastReceiver. We're almost there now. We just need to finish the last part, and that's to hook up the buttons. Great! You've come a long way towards finishing this app. You've also implemented the IntentService and its receiver class. Now let's put everything together by implementing the rest of the main activity. You'll connect the Google API client and you'll manage the two buttons. Allowing it to start the activity service, to start receiving updates, and to stop it also, if you so desire. Let's go. When building apps that use the API Client, you have the usual onStart() and onStop() methods that need to be implemented. Go ahead and do these now, and make sure that you connect the API Client to the onStart(), and you disconnect it at the onStop(). You also need the onPause() and the onResume() overrides, and these are a little more complicated in this case. So an onPause(), you should get a LocalBroadcastManager, and use that to unregister our receiver. For onResume( ), you're going to do the opposite. You get the LocalBroadcastManager and you re-register the receiver. But make sure when you re-register it, you're going to use an IntentFilter. And that IntentFilter should have the same name as the one in the service. In which case we called it BROADCAST_ACTION. Implement all these now in the main activity, and check this box when you're done. I'll get started just by adding the onStart and onStop methods. These are the easy ones. As you can see, onStart is just doing the GoogleApiClient.connect, and onStop is just doing the GoogleApiClient.disconnect. Next I'll add the onPause. As you can see, onPause just gets a LocalBroadcastManager, gets an instance on this, And uses that to unregister the receiver that we called mBroadcastReceiver. And once we're done with that we're just going to just super onPause. Now let's take a look at onResume. And here you can see the onResume. I just used a Local Broadcast Manager, getInstance on this to get my local instance. And then I called registerReceiver, giving it the same Broadcast receiver. But setting it up with an IntentFilter defined by Constants.BROADCAST_ACTION. This is the same name as we had used in this service when we first created it with a localIntent called Constants.BROADCAST_ACTION. That way, we keep the Intent consistent across pausing and resuming. In your layout file, you had actually set up the button handler functions for the two buttons. Go and check it out now. Now, you had specified that these be called request activity updates button handler, and remove activity updates button handler. Go ahead and create these functions now. They both take a view as a parameter. In the request function, you should do the following. First, you should call ActivityRecognition.ActivityRegonitionA- PI.RequestActivityUpdates and set its results call back to this. It takes three parameters. The first is the API Client, the second is an interval in milliseconds. And then the third is a pending intent. You don't have that pending intent yet, so for now, just enter this function, getActivityDetectionPendingIntent(). You're going to create this function in the next step, and this function will return the pending intent for you. Similarly, in the removeActivityUpdatesHandler, call activity recognition.activityrecognition API.removeActivityUpdates. And this just takes two parameters, the API client and a pending intent. And as you don't have the pending intent yet, just use the same function call as in the request function. When you're done implementing these, check this box. Let's start by taking a look at the requestActivityUpdatesButtonHandler. You can see the code here. First, I just want to check if the Google API Client is connected, and if it isn't, just send a notification to the user to say that we're not connected. Then, using ActivityRecognition.ActivityRecognition- Api.requestActivityUpdates, I'm going to start the activity updates process going. I pass it the Google API client. I pass it my detection interval in milliseconds which I've just stored as a constant. And then I pass it this function, getActivityDetectionPendingIntent(), which will return a PendingIntent for me. I haven't written this function yet which is why it shows up in red. We'll see that in a few minutes. Now once I've done all this, I just set its ResultCallback to this. And then I'm just enabling and disabling the relevant buttons. So similarly, now let's take a look at the removeActivityUpdatesButton, and it's very similar. We're going to say, if the Google API client isn't yet connected, we'll just throw an error to the message. And now, using ActivityRecognition.ActivityRecognition- Api, I'm going to removeActivityUpdates, passing it the API Client and the same PendingIntent function handler that we had earlier. I'm then setting the ResultCallback to this. And then just enabling and disabling the buttons as appropriate. And now as you can see, because I set the ResultCallbacks to this, I have to enable the callbacks on this class. And I do this on the class level itself. If I come here where I'm implementing, I want to implement the callbacks. And what we get in this case is a ResultCallback. So I'm just going to paste it in here. Okay, we get a ResultCallback of Status. So then I just set up the callback here, and it's going to be a ResultCallback of type Status. Now as you can see, this is triggering an error for us because it's expecting us to implement this abstract method onResult. So let's go ahead and implement this now. So I'm just going to paste it in here. Again, all this code will be in the speaker notes. And onResult just takes a Status, and what I should do in this case is just to log something. I haven't specified my tag yet. That should just be a string for this. So let's go ahead and implement the onResult now. I'm going to paste it in here. And it's just going to take a Status, and if the Status is success, I just want to say that we've successfully added activity detection in my logs. Otherwise, I'm just going to say there was an error adding or removing activity detection and qualify that with a status message for the status. So now, you can see my class. There's no more red underlines, and I'm good to go to compile. But there's one more thing that I need to implement. And that was, if we remember, we had created this getActivityDetectionPendingIntent() function which returns a PendingIntent to us. So let's go ahead and just implement that quickly. So I'm just going to go ahead and paste the code for that in. In this function, I'm just going to return a PendingIntent, and how I'm going to do that is I'm going to create a new Intent. And this is a new Intent based on the DetectedActivitiesIntentService class that we created earlier on. And then I'm going to return a PendingIntent by calling the abstract class PendingIntent.getService, passing this intent to it, and just saying I want to flag update current. And the idea behind FLAG_UPDATE_CURRENT means I'm just going to return the same instance of the class if I have one already. I know this is pretty complex stuff, but just check out how PendingIntents work and how Intents work by checking the Android fundamentals courses and by reading the documentation. And that's it. I now have everything I need to be able to build and run the application that we saw earlier on. Congratulations, you've just built your first activity recognition app. In this lesson, you learn more about building apps that use location services. You saw how to get a single location update, as well as how to get continuous ones. You also saw how to recognize various activities in your device. In the next lesson, you'll learn about geofencing. The ability to draw a virtual fence around a location in the real world, and how to generate events when the device enters or exits that fence. This can be used to, for example, set a notification when you or a member of your family has arrived home. If you've gotten this far, you've done some really cool stuff with understanding the location and context of your device. >From the skills you've learned, you'll be able to write applications that know where your phone is, where it's going, and maybe even how high off the ground it is. Now how about we take it to the next level? How about an app that tells you when you enter or leave a specific location? You could use this for social checkings, or maybe, as a parent, you can use this to tell when your kids get home. I've even seen games that use this, where they virtually hide loot, and when you go to the real world location, your device knows and can react. A great and easy way to implement this is using a geofence. Simply, a geofence is a location in latitude and longitude, a radius around that location and a time for which it's active. So for example, you could put the latitude and longitude of your lute stash. A radius of, say, ten meters and data that is only active on weekends. The location APIs will take this and when you exit or enter that space, it can be used to generate a notification. It's up to you, as a developer, how you handle this. Does that sound exciting? Well I think so. So let's dive in and learn how it works. Geofencing combines awareness of the user's current location and nearby features, defined by the user's proximity to locations that may be of interest. For example, consider this case where there are a couple coffee stores on this street. As the user gets close to a store, the app could give them notification of a special offer. For example, come in the next five minutes and you'll get your coffee for half price. As the user exits the area for that store, the notification could be removed too, in order to play nice and not clutter their notification tray. In this case, a geofence could be drawn around each of the coffee shops. And, when the user enters that geofence, a notification is triggered, letting them know that they're in the coffee shop. And, when they exit the geofence, another notification could be triggered, or functionality, for example, to clear any notifications could be triggered. Now, let's take a look at how you would build this. As with everything else, when building an app for Geo Fencing, you'll need a GoogleAPIClient. You've seen these earlier in the course, and you've seen how to set them up, so let's assume at this point that you've done that. In order for your app to monitor the GeoFences, you have to define them. And a GeoFence is defined using the GeoFence object, which you create using a GeoFence Builder. It takes the following properties. Latitude and longitude define where the GeoFence is in the world. These are just the typical latitude and longitude that define any location anywhere. The radius defines a circular area around the latitude and longitude. This determines how close the user needs to be to that location from any direction before any alert gets triggered. The expiration time determines how long the fence should remain active. Once this time expires, the GeoFence is deleted. And you can of course set up permanent ones if you like. And the GeoFence ID is an identifier to use so that you can know which GeoFence has been triggered. This should be unique. If you consider the fact that GeoFences are based on latitude and longitude and a circle around them, you can actually have GeoFences that overlap each other. When a user enters a particular space, they may trigger two or more GeoFences. As such, as a developer, you may want to know which ones, and you do that using the ID of the GeoFence. Now, I'm going to define a GeoFence as looking something like this. You can then define a number of GeoFences as an array of GeoFence objects. So, I'm going to wrap the list of GeoFences in ArrayList like this. Once you have your ArrayList of GeoFences, you can then use a GeoFencingRequest class simply by calling its addGeoFences method and passing the ArrayList to it. Once this is working, you can then add the GeoFencingRequest to your client and specify a pending intent that is used to process the call backs from the location services API. This pending intent uses an intent service in a similar way to the address example that we saw earlier. Now, whenever a GeoFencing action happens, the intent service will catch it, and it will route it to your app. Which of the following are properties of a GeoFence object? Radius, height, expiration time, or weight? Check the answers that you think apply. The correct answers, of course, are radius, which defines the circular area around your geofence, and a user entering or leaving that area will trigger the geofence, and expiration time, so you can set your geofence to expire at a particular time. It can, of course, live forever. But say you wanted it to live only for one day after you've set it, you can do that. Geofences don't have a height and they don't have a weight. Before we start coding, let's take a look at a simple app that uses geofencing. You can see it here and it's very simple indeed. I've created a geofence for the location that I'm in. This is a studio in Mountain View, California. And I've created it with a radius of a mile. I ran the application before I drove into the studio today. And then once I got within a mile of the studio, a notification was fired. And you can see the notification icon in the tray here. And when I swipe it down, it says I've entered UDACITY Studios, or I've entered that geofence of UDACITY. Now, were I to leave this one mile radius on my way back to my hotel tonight, I would see a notification from me having left. Now of course you don't have to use your notification tray, you could have your activity do anything in response to the geofencing event. The nice thing about using the notification trays, now if I'm in my general desktop for my Android tablet, the notification is still there. So, I was traveling and it showed that I entered the geofence that I want, and when I touch that, it relaunches the application. So we're going to see next how to build this application and how to use notifications within a geofenced environment. For example, and this is a true story, my entire family uses an application that has geo-fencing in it. And we've specified particular environments to be geo-fenced, such as our home, our place of work, and our schools. Now, whenever one of us enters of leaves on of these areas, a sound will play on everybody else's phone. So, for example, when I get home from work a particular sound will play. My dog has gotten to associate that sound with one of us coming home and he gets really excited as dogs do. So if I'm feeling particularly mischievous, I'll play back that sound and he'll bolt straight to the garage. I actually have to let him into the garage and walk him around so that he can be sure that somebody hasn't just come home. He'll be looking for them to see if he can find them. Now let's roll up our sleeves and we'll build a simple geo-fence app like this one for ourselves. I think the best way to learn is to build an example from scratch. The sample I showed earlier is from Google's canonical samples, and there's a link to them in the speaker notes. We're going to build the same thing from first principles so that you can see how it's done. You should be familiar with the first few steps by now. You'll create a new app in Android Studio. Make it a single zoo application, don't use any templates. You'll then add the service libraries to your build.gradle file and then once you've done this, you'll edit your app.manifest to use these service libraries. When you've done all of this and you're ready to go, check this box to continue to the next video. Now, here you can see the very simple UI that we're putting into this app. You should edit your layout.xml file to match this. Note that you should add an onClick attribute to the button, and you should call it addGeofencesButtonHandler as I show here. Also for good practice, don't hard code the string with the caption of the button. The caption here are the words Add Geofences. Instead, use the strings.xml file and put a reference to that in your UI declaration. When you're done, check this box to continue. Here's what your layout code should look like when you're done. If you set the android.text the same way as I did, by referencing a string using @string/add_geofences, you'll also need a strings.xml file with content like this. Here you can see I have a string that I call add_geofences, and I put the text add_geofences into that string. So now, when I draw my activity, my button will be using that string. This is always handy for localizing or if you want to change it later to geofences capitalized or something along those lines. Other than that, it's a very straightforward button, and I've added the onClick handler here. I'm just saying, android:onClick equals add.GeofencesButtonHandler. Of course, that can be done at runtime in the onCreate event, but I've done it in here now just to make things a little simpler. An IntentService is the base class for services that are used to handle asynchronous requests, expressed as intents and done on demand. Your app will send a request by starting the service and passing it an intent. If the service hasn't already started, it will start if needed. And it will handle each intent in turn, using a worker thread. When there are no more intents, it will just stop itself. It uses a single worker thread, meaning that only one request will be processed at a time. But it won't block the application from continuing doing what it needs to do. In the next steps, you'll create the IntentService class called geofenceTransitions IntentService. To implement the intent service, there are a number of steps that you're going to need to follow. The first thing to do is to create a GeoFenceTransitionsIntentService class and have this extend the IntentService base class. You'll then need to add a constructor and add an onCreate override to this. Generally these will be empty, but in the constructor you could call super tag, and in the onCreate you could just pass onCreate up to super as well. Finally, you'll need to create an override for onHandleIntent. Now this takes an intent as a parameter and returns void. Once you've created all this stub code, check this box when you're done. Here, you can see my GeofenceTransitionsIntentService and this extends the base IntentService class. In it, I've defined a TAG, which is just a string, called gfservice. I've created a constructor, which has the same name obviously, GeofenceTransitionsIntentService. And I super the TAG. I've created an onCreate override function, and in that, I just called super.onCreate. And then finally, I've created this protected void, onHandleIntent, and I'm passing it an intent called Intent, and returning a void. There's a lot of code in here and we'll see how to build that in the next steps and what that does, but this is how you get started with your GeofenceTransitionsIntentService. The main workhorse of an intent service is its onHandleIntent method. Most of the work you will do in the service is writing the code in this method. Now there's a lot to do, so we're going to break it down into a number of steps. The first of these steps is to get the geofencing data from the intent that was passed into the service. This can be achieved using the geofencing API, so check the documentation for that. The data that you want will be in an object called geofencing event. Once you've done that, it's good practice to ensure that the data is good and without any errors. Think about the code for this and write that into your onHandleIntent, and then check this box when you're done. So the answer you can see here in Android Studio. First of all, I create a GeofencingEvent object. And I'm going to use the GeofencingEvent abstract class with its fromIntent method, passing it my intent to get the GeofencingEvent. Then once I have the GeofencingEvent, it has an hasError property, so I can say if geofencingEvent.hasError(), do something. I'm creating a string called errorMessage, and I'm using the geofencingEvent's getErrorCode method to create the error string out of that. Now you'll notice here I have GeofenceErrorMessages.getErrorString, and this creates the string for me. Now you may not find this class anywhere in the documentation because this is one that I actually built myself. And you can see it in here. So the GeofenceErrorMessages class is just a simple class that converts an error code from the GeofenceStatusCodes into a string. So for example, Geofence not available. There are too many Geofences registered. There are too many PendingIntents registered. Each of these status codes has a friendly string that we can associate with it, and then that friendly string will be returned to the caller. So that's how we get our onHandleIntent started. We get our GeofencingEvent. We check if it has an error. If it doesn't have an error, we'll continue. If it does have one, we'll log it and then just return out of this function and end right there. So great, now you've gotten the geo-fence event from the intent. The next thing of course to do is to figure out, well, what kind of event did you get? Has someone entered the geo-fence? Has someone left the geo-fence? And in order to keep my poor dog from getting confused, you might want to play a different sound in these circumstances. To get a transition type on a geo-fencing event, you call the get geo-fence transition class. This would return an integer which contain the value one, if someone enters the geo-fence, or two if they're exiting the geo-fence. The geo-fence API contains constants that will make your code easier to read, instead of checking for the values one or two. Update your code to get the transition, and then to check if it's an Enter or Exit event. And when you're done check this box. So here now we can see we can get the transition type using geofencingEvent.getGeofenceTransition. This is going to return an integer to us. Now, the geofence object contains these constants GeofenceTransitionEnter and GeofenceTransitionExit. So all we have to do then is if the geofence transition is this or the geofence transition is this, then we're going to run a block of code. We'll see what that block of code is in a few moments, but this is all you'll have to do to check the transition type if you're entering or if you're existing. Of course, it's up to you how you build your application. If you want to build it so that events only happen when you enter, then you don't need to check for the geofence transition exit and vice versa. The first thing you need to do is to get the list of Geofences that you may have triggered. So you can just create a list of Geofence and call it, triggeringGeofences. To get them, the geofencingEvent has a method that returns them in this data structure. Check the documentation to see if you can find it and enter it here. When you have the list of Geofence objects, you'll note that each Geofence object has a request ID associated with it. Again, can you figure out what the method is to return this request ID? Now, write a helper function that takes this list of Geofences and concatenates all of their IDs into a single string. Call this helper function, getGeofenceTransitionDetails. When you're done creating it, check this box. So here you can see I'm getting the list of geofences and I'm going to call it triggeringGeoFences. And I get this by calling the getTriggeringGeoFences method on my geofencing event. So no matter how many geofences have been triggered, be it one, be it many, they will return to this list of geofences for me. Now the getGeoFenceTransitionDetails helper function. We'll turn all of these into a string. So, I just say string, geofenceTransitionDetails equals getGeofenceTransitionDetails, and I pass at this, I pass at my geofenceTransition, and I pass at my triggeringGeofences. Let's take a look at this function. Here's the getGeofenceTransitionDetails. And you can see it takes the context and it takes the geofenceTransition, which was just an integer. And it takes a list of geofences, which are my triggeringGeofences. So first of all I'm going to get the transition string for my actual transition. And I'm just going to call that string geofenceTransitionString. And then I'm going to iterate through each of my geofences, and get a string out of them. Load that string into an array list and then use TextUtils.join on that array list to join all of those strings together and to concatenate them. There are a number of ways that you could do this, but ultimately what you're interested in is this. The geofence.getRequestId. This gives you the ID of the geofence that triggered the event and it's up to you how you would handle that ID, in this case. Like I said, I'm just concatenating them all together, so, if there were a number of different geofences triggered, I would get their IDs all listed in this single notification, saying, for example, Lawrence has entered Mountain View. Lawrence has entered entered the Audacity Studios. Lawrence has entered Studio X. That type of thing all in a single notification instead of multiple notifications. And then, as a result, I just return my geofenceTransitionString and the list of IDs that came. So it would be entered plus the list or exited plus the list. That type of thing. So this helper function achieves all of that for you. As you might remember when we showed the application earlier, geofence events, such as entering or leaving the geofence, generated notifications on our device. The next step that you'll need to do to get these notifications is to write a sendNotification helper method. This takes the string you created in the last step and creates a notification out of it. If you aren't familiar with notifications, you should learn more about them in the instructor notes below. So your next task is to write the sendNotification helper method, put it in the GeofenceTransitionsIntentService.java file, and it should take a string and generate a notification containing that string. Check this box when you're done. If you're really stuck, don't worry, I've included an implementation in the code for this course. Here's the send notification helper method. This method takes our string, and turns it into a notification, as we saw demonstrated earlier on. I'm not going to through all the ins and outs of creating a notification. You should have covered that already in the Android fundamentals class, or you can just use this source code, and check the Google developer documentation for details on how to built notifications for yourself. The important thing to take a look at here are as follows. First of all you'll notice that the send notification takes in notification detail string as a parameter. Then, when it creates the notification, if I just scroll up a little bit, we'll see in the builder for the notification, the set content title becomes our notification details. Our set content text becomes click notification to return to the app, and our intent becomes the notification pending intent itself, and as a result this is all we have to do. It's a standard notification that we actually build. We're just sending the text to this of the notification details, and the notification details is what you just built earlier on where you had a list of the action followed by all of the IDs that triggered that action. So, when I demonstrated it earlier on, I had a geo fence called udacity, and when I triggered that by entering within one mile of udacity, it just showed entered udacity, and that's what was sent here in the sent content title, the notification details. So, this is all it takes. It's a standard notification builder. Again, if you're not familiar with this, check the documentation on notification builders, or check the underwrite fundamentals courses, or just use this code and dissect it. You'll see the links in the speaker notes below. Let's have a quick checkpoint of what we've done so far. You've done a lot. So, first of all, you were able to get the geoFencing Event. And then you were able to determine what the transition was from that event, whether you were exiting or leaving the geoFence. You then got the list of geoFences that were triggered during that event. Remember, more than one can be triggered if they're overlapping. You created a string out of this list. And then you created a notification helper that generated a notification from that string. So now, all you have left to do is to call the method, the send notification method that sends the notification for us, and add that to your onHandleIntent. So here's our finished on handle intent function, and you'll see here the last thing that I've done is just to send notification with the geofence transition details. The geofence transition details, as we saw earlier on, is this string that was created by calling the get geofence transition details handler. And that listed all the different geofences and the transition that happened between them. So we have that string, and then we just call sendNotification with that string. We're now done with the IntentService, and we're ready to go back to the main activity and wrap up the code in that. Much of the process of coding the main activity is setting it up to use Location Services. You've done this several times already. You may be familiar with the flow. In OnCreate, you set up your GoogleApiClient. In OnStart, you connect the GoogleApiClient to Location Services. You implement the OnConnectionFailed and OnConnectionSuspended callbacks. And you also implement the onConnected callback, in which you setup your LocationRequest. Once you've implemented all these functions and built it in the usual way, check this box when you're done. Great. Now that you've built the boilerplate, let's take a look at the sample app that we'll be building. In this video, I've built a sample app that has geofences around the studios that I'm filming in. As you build out your app, you'll likely want to use a different geofence. As we've explained earlier, a geofence uses latitude and longitude and an easy way to find the lat long for any location is to use Google Maps. You can either look at the URL when you are in a particular location, and pull the latitude and longitude from them, or if you prefer, you can drop a pin and then you can see the latitude and longitude in the pop-up. Note that it also depends on your zoom level. So, here I zoomed into the the top secret military base at Area 51 and you can see it can actually get the latitude and longitude for the baseball field there. That must be where the aliens play baseball. Or if they're more the tennis type, I can drop the pin here and then get the latitude and longitude for the tennis courts. Yes, believe it or not, there's a baseball field and tennis courts in area 51. Now if you prefer to go to a slightly less secret place, you can zoom in on anywhere you like, for example the Google campus. And here I'll find the latitude and longitude of my favorite coffee shop, which is right here in this building. There's the latitude and longitude. So it's up to you. You can find locations wherever you like on Google Maps, and like I said you can either look at the URL, as you can see here, to get the latitude and longitude, or you can drop the pen and the latitude and longitude will be presented to you. So the next step is to create the list of geo-fences that you want the app to actually trigger upon the user entering or leaving them. You're going to do this using a final class. So create this final class called constants, in which you're going to store the constants. Here's some starter code for you. In this class create a HashMap. And the hash map's key will be a string and it's data will be of type LatLng. Give it any name you like. I'm just calling it Bay_Area_Landmarks. And then, in this HashMap, just create the list of entries based on their latitude and longitude. And you just saw how to find out latitude and longitude. So when you're done creating this class, check this box. Perfect. Now you're ready to move to the main activity and finish writing your application. In your main activity, you should now populate the Geofence list. To do this, first create an array list of Geofence objects. Then, create a helper function, call it populateGeofenceList, and in this helper function perform the following steps. Number one, read the HashMap. Number two, create Geofence objects out of the data that was in the HashMap. And then add these Geofence objects to this ArrayList<> that you created earlier. When you're done with this, check this box. So here's this simple function that I've created for populating the GeoFence list. This is my hash map, so for each entry in the hash map, I'm going to call it entry. I'm going to add to my GeoFence list, which is the array list we created earlier. A new GeoFence object using a GeoFence builder. Then this GeoFence builder I set a number of properties on it. I called set request ID with the key that was in the entry with the hashmap. I then called set circular region and here's where I specified the latitude and longitude of the GeoFence. And then the actual radius of the GeoFence defined in meters. I've just set one in my constants. I then set my expiration duration. And again, in my contents I just set the GeoFence expiration in milliseconds. When you look at the constants file you'll see these values and you'll be able to edit them as you like. And then I finally set the transition types that will trigger the geo fence. And these were GeoFence enter or GeoFence exit. And then I'd build the GeoFence. So to recap, it's very simple I iterate through my hash map. Each entry in my hash map I called entry. And then from that I can derive my latitude and my longitude that I use to define the GeoFence. And then I have constants for the radius of the GeoFence, the expiration of the GeoFence. And I pass all of these to the GeoFence builder to create a new GeoFence. And then that new GeoFence is added to my GeoFences list. And as you can see, that's all down here for me. So when this function is finished, I will now have this array list, called MGeoFence list, with a list of all my FeoFences, based on their latitude, their longitude, and my radius and my expiration times that I've defined as constants. So to create the geofencing request you're going to use a geofence request builder. The builder requires two things. The first is an initial trigger condition. And you'll see in the geofencing request class there are some constants specifying this. Take a look and see if you can find them. The builder also needs a list of geofences, and you've created that already calling it mGeofencelist. So for the next task, you're going to fill out this helper function. private GeofencingRequest getGeofencingRequest () {}. Check this box when you're done. So here's my getGeofencingRequest method that returns a GeofencingRequest objects. I'm going to create a GeofencingRequest.Builder called builder. And to this I call two methods. First is to set the initial trigger. And I'm going to set that my initial trigger is an INITIAL_TRIGGER_ENTER, which is a notification when the Geofence is added and if the device is already inside that Geofence. Then I'm going to add the Geofences that I want to monitor and that's just my mGeofenceList. I call addGeofences to add them to it, and then I returned builder.build to get my GeofencingRequest back to the caller. It's as simple as that. The next step is to create the Geofencing pending intent. So, the best first thing to do is create a function that returns a pending intent, like this. You can call it whatever you like, but I've called it getGeofencePendingIntent. Inside this function, you're going to create a new intent with some kind of parameters. What do you think they may be? And then, you're going to return a PendingIntent.getService with some kind of parameters. What do you think they may be? Give it a shot, and then check this box when you're done. So here's my method, get GeoFence pending intent. To this I create a new intent and I pass it that this is the context. And if you remember earlier we created a GeoFence transitions intent service. So we just specify the class of that. So our new intent is going to be a GeoFence transitions intent service type. And then we return pending intent or get service. This, zero, intent, which is the intent we've just created. And then this PendingIntent.FLAG_UPDATE_CURRENT. We use FLAG_UPDATE_CURRENT so that we get the same PendingIntent back when we call addGeofences. We want to keep the PendingIntent consistent across them all. So when adding GeoFences to LocationServices, so they can monitor them for you, there were a number of steps that you had to follow, and you've done all of these now. Most notably, you were calling the addGeoFences method on the GeoFencingApi object. You're passing it a GoogleApiClient, a Geofencing Request and a Geofencing Pending Intent. Now, whenever you add one of the Geofences to the services, the service will callback onResult(), and will pass you a status code. You can then check this status code to see if the GeoFence was added successfully, or if there was an error. In the next step you're going to implement this onResult(), and check this box when you're ready to go forward. So this is what your end result should look like. It's going to be a public void, and accepts a status parameter incall status. If status.isSuccess is true, then you're just going to make a toast called Geofences Added, and show that toast. Otherwise, create an error message and get this status code from the status itself, and then log this out. And this will happen if adding the geofences actually failed. That's the complete OnResult. It's pretty straightforward. When we press this button, we want to let the location services know about the list of Geofences that we're working with. And this is called adding the list of Geofences. To do this, in LocationServices.GeofencingApi, there's a method called addGeofences and addGeofences requires these parameters. First is the GoogleApiClient, which you'll have already. Then it's the Geofencing Request, which you're going to create shortly and then it's the Geofencing Pending Intent which you created earlier on. It also requires you to set a callback called onResult, and we'll see how to create that shortly. You've already implemented your GoogleApiClient, so let's take a look at the others starting with this Geofencing request. Check this box when you're ready to continue. So here's our addGeofencesButtonHandler. It's pretty straightforward what it does. So first of all, we check if our Google API client is connected. And if it isn't we just throw an error at the user and let them know. If it is, then we go to our addGeofences that we've been discussing. We pass it the API client. We pass it the result of getGeofencing request, which of course is a Geofence request object. And we pass it the result of getGeofencePendingIntent which is our pending intent. And once we've passed it these we then set the result callback to this. And by doing so the results will be called back into the onResult that we created just a moment ago. When doing this you gotta put it in a try catch loop. And we want to catch a securityException. And if we get one, we're just going to log it. And that's it. That's everything we need to do to have our Geofences configured when we push the button within this application. And then the services will monitor the Geofences for us. And inform us when we enter or exit a Geofence. There's a couple of extra things that you're going to need to do in AndroidManifest.xml. First of all is to define a service for your Geofence TransitionIntent Service. This should be inside the application tag. And then secondly, you want to ensure that the application uses ACCESS_FINE_LOCATION permissions. Add these to your manifest, and check this when you're done. So here you can see my AndroidManifest.xml class. And here, I've used the service tag to add .GeofenceTransitionsIntentService. This allows me to use this service within my Android application. And then secondly, uses-permission has been configured for ACCESS_FIND_LOCATION. And in general, you're going to need to use find location when using geo fence's particularly smaller ones. You now have everything you need to run this application and to build it. So run it, give it a try, and demonstrate your geo fence in action, the way that I did with mine earlier on. And have fun building geo fence applications. In this application, you saw the infrastructure for how Geo-fences work in Android. You saw how easy it is to set up Geo-fences, and how you can use an intent service to handle the transitions between Geo-fences. In this case, we hard coded several locations but there's no reason why you couldn't put your Geo-fence data into the cloud and have your phone dynamically update the number of Geo-fences that it tracks. So for example, if you wanted to have a virtual treasure hunt with locations that change every day, you could do so and have your app update them whenever it launches. There's just so much that you can do with Geo-fencing. Particularly, now, that the users carry these powerful mobile devices with them all the time. We scratched the surface of what you can do. But in doing so, we've built a powerful scaffolding that you can use in your future apps.