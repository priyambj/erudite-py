Hey, I'm Walter, your instructor. After learning all the cool things you can do with code, writing documentation might seem a bit stale. I'm here to show you why that's, in fact, not the case and why you should get excited about documenting your code. In this course you'll be cooking up your very own readme file. You'll learn what documentation is and why it's an important part of the development process and you'll be able to incorporate it into your projects moving forward. This course is relevant to anyone who either writes code or works with others who do. Throughout this course, you'll be seeing examples of documentation for a variety of tools and languages, some will be familiar and others will not. That's okay. Focus on the concepts, not the actual code that we'll be documenting. To help us get started, I've cooked up a little something for you. How does this relate to readme's? Well, you'll understand in a minute. This recipe has taken me years to perfect, and I think it's finally ready to share with the world. I just published it in my brand new cookbook, Cooking with @walterlatimer. [NOISE] So, what is a cookbook? Well, a cookbook is a way of documenting recipes, it helps us make sense of all the tools and ingredients in the kitchen. Without this documentation, I might have everything I need to make a delicious meal but I wouldn't have any idea how to put it all together. Technical documentation exists for a similar purpose. To help us make sense of code. Without it, developers, you included, won't know how to use other people's code. They might not even know how to run it. I read documentation for all my projects, including this one. In the instructor notes, you can find a link to the Read Me I created for this course. There, you can find helpful resources to help you along as you work through this lesson. When you hear the phrase, technical documentation, you might think of dry literature that's difficult to understand. But good documentation isn't boring or unapproachable. Often it's written in plain English. Sometimes it's even written as a series of guides or tutorials. As it turns out, there isn't a secret ruling body that makes laws for what documentation should and shouldn't look like. That's because, unlike your code, which is written for computers, documentation is written for humans. Documentation exists to help us make sense of the code that we've written, which may not always be quite as intuitive as we'd like it to be. For instance, if you're working on a large open source library that other people can use, good documentation is absolutely essential for acquiring both users and contributors. If your documentation is good, people will want to use your library in their projects. If your documentation is great, people might even chip in to help you with your library. Perhaps your project is a portfolio piece to help you land your first job as a developer. In that case, you want to document your work in a way an employer can easily skim and pull relevant information. Give some thought as to who is going to be reading your documentation. You won't always know who that is. You want it to be easy for anyone to dive into your code and get it up and running. With that in mind, who do you think might be a potential end user of documentation? Yourself, your coworkers, or your users? As I mentioned previously, we want our code to be easy for anyone to dive into. Your users may need to use your code to make changes or to understand how to use it, predictably, so might your coworkers. And while it may surprise you, you are also an end user of documentation. You of the present and you of the future are two different people. And future you will not remember every little detail about your code. Treat future you just like you'd treat a coworker, and give them the things they'll need to succeed. I'll touch more on that in just a bit. But let's first take a look at how some of the engineers here at Udacity use documentation. I'm here with Daija, a div ops engineer here at Udacity. So tell me, how do you consume documentation as part of an engineering team? You consume documentation every day because we use third party libraries and tools. So, one of the easiest things to do is when we want to get up and running, we look for an example for how to do that in the documentation. And what would you do if you did not have this documentation available? We would be very sad. Realistically, we may not use that library, or we may switch to a library that is better documented. Or we might write our own internal documentation if that's really the library that we need to use. How would you figure out the code if the documentation wasn't there? You'd have to dig through the source code a lot of the times, or examine it using a debugger. Or, a number of other more advanced trouble-shooting tools. That sounds like a big headache. It's kind of like reverse engineering somebody else's thought process. Sometimes it doesn't work so well in practice. Thanks Daija. So, I told you earlier that sometimes you might be the end user of your own documentation. I'm here with Art, director of engineering here at Udacity. So Art, tell me a horror story. Tell me a time when you're really kicking yourself for not writing documentation. That's a good question, Walter. Feedbacks, early in my career. I was doing a project for a very sort of conservative stuffy investment bank on Wall Street. And I was doing the support screen that comes up like, if somebody that's using the app needs help. They click help and it comes up with a phone number. But we didn't yet have the phone number, so like a placeholder phone number. But I forgot to put in the read me, that somebody needed to update that before they shipped it. So I just put in the first thing that popped into my mind, which was 1-900 of the name of the company, we'll say, ABC-4EVA. [LAUGH] 4EVA, right? Yeah. And I shipped it, I collect my fee, don't think anything of it. Six months later, I get this frantic call from the project manager. Freaking out because one of their customers had called the number, nobody ever updated the help number. This guy calls me up and he's like, why did you put an adult 900 number on the help screen of our app? Because I had forgotten to document that it was just a placeholder and somebody in Utah updated it. [CROSSTALK] [LAUGH] No, God. [LAUGH] [LAUGH] That's not even a true story. [LAUGH] You'd never do something like that, right? I know, I know. Yeah, I would never. What is- [MUSIC] I'm future Walter, and I completely agree with everything you just said, Art. Present Walter over here forgot to document the code on some of the projects we've been working on. And now, we can't seem to remember what we were thinking. Walter, I'm so disappointed. [MUSIC] Take a look at some of your own older projects. Can you remember everything that you were thinking when you were writing that code. Wouldn't it be helpful to have a handy reference of all the decisions that past you made. All right, so now we know we need to be documenting our own projects. But all the documentation we've looked at so far is pretty intense. In fact, for a small personal project, the type of documentation is often overkill. It would be like writing a cook book when all you need is a single recipe. Luckily, there's a type of documentation that lends itself well to small projects, known as a readme file. A readme file's a convention that's existed since back when computer programs were written with punch cards. This single file contains relevant information about the other files in a project's directory. Readmes are so common that you may have encountered one of your own in the past when installing something on your computer. Its name exists, usually written in all caps to stand out in a directory so that users would be more likely to read it. Check it out for yourself. I've included a link to three different readmes in the instructor notes. As you examine them, think to yourself, what information is being communicated in this file? And how is this information being structured? And do you notice any patterns across these readmes? This first read me belongs to factory_girl, which is an open source project maintained by a development shop called thoughtbot. Without knowing the specifics of what this project does we can see that this file is broken up into many small chunks. Each one of them is very clearly defined and readable. At the top we can see some links to more external documentation, some installation instructions, and then underneath we can find some essential additional information along with information for how we can contribute to the project. At the very bottom is a section that links out to the license and all the licensing information. So without knowing what factory_girl is or does we can assume that if we wanted to use it we'd have all the information we'd need to get started right here. Next we've got can.viewify, which is a personal project by my friend Kat. This one is considerably shorter, but it seems to be structured in a similar way with lots of short, clear sections. We've got our description, we've got our installation instructions, and this is a little different. We've got some usage examples here. This readme does not have contribution information, and instead has a little section on an issue that is known within this code, and down at the bottom we once again have some licensing information. Lastly, we've got a readme from Udacity's very own Create-Your-Own-Adventure game, which comes from our Git and GitHub course, which you should check out if you haven't already. This readme doesn't have too much code necessarily. Just that one line there, but it does have a very detailed explanation of how we're supposed to contribute to this repository. Like the other two readme's we've got some licensing information at the bottom as well. So, without knowing anything about the actual code within each of these projects we can see that all three of these readme's gives us a quick overview of the essential information we may need to get these projects up and running. In the next few sections we're going to be talking about each of these sections in more detail. Before you start building your own readme file, let's first take a closer look at the very sections that make a readme useful. For this example, we're going to be taking a look at Ledbetter, a project that's maintained by GitHub itself. Now, I don't really know what Ledbetter does, but that's not what we're looking at here. We're looking at the language that's being used in this readme and the parts that make it up. A readme should provide just enough context to get a user up and running with your code. Keep in mind, we are writing this for other humans. We'll start with a title and a description. A sentence or two will work just fine, but be sure to capture the spirit of your project clearly and concisely. This will help frame the reader's experience when going through your documentation. If you're feeling extra fancy, you can include your project's logo, if it has one. Next, include any information that is absolutely necessary for understanding your code. This may be dependencies on other software or libraries, installation instructions, common usage, or known bugs. It's worth mentioning, once again, that there's no formal standard for what a readme should look like. Don't feel pressured to make your readme any particular length. Some can be extremely short, while others will need to be much longer. It just depends on your project. The important part is that you communicate clearly and concisely any information that is essential for the user. And that you don't make any assumptions about what the end user already knows. It's up to you to decide what is and isn't essential information. A few good questions to ask yourself include, what are the exact steps that need to be taken to get this code base up and running? What should they already have installed or configured? What might they have a hard time understanding right away? Often, developers will include a, getting started, or installation section, to help with any initial setup that may need to happen before using your code. If it's helpful, include example code to better illustrate your end user's proper usage of your code. It's important to be mindful of the assumptions you make about what the user's expected to know. Remember, you're familiar with your code already. So think about it from the perspective of someone who's never seen this before. For instance, if I were making eggs Benedict and my recipe called for a poached egg, I might be alienating new chefs by not explaining what a poached egg is. Ultimately, the amount of detail that you choose to include is up to you. But for particularly difficult concepts, it might be a good idea to include some extra detail. As your code base grows, you may find yourself needing to re-evaluate what information is essential for your documentation. Deciding what goes into your readme is entirely up to you. But let's go over a few common sections and then use cases in a readme. Including copyright or licensing information, or at least a link to it, is always a good idea, no matter how large or small a project. By default, you retain full rights to your code even if you don't include a license, but it's a safer bet to be explicit about this. Often, what you really want to do though, is allow others to contribute to your project. In this case, it's super important to include a license. You can choose to include the full license in your readme itself, or you can link out to it from your readme. Choosing which license is a bit beyond the scope of this course, but I've included a link to a handy resource in the instructor notes, appropriately titled choosealicense.com to help you out with this. In the spirit of contribution, if you have a preferred way for others to contribute to your project, the readme is the right place for that, too. Briefly outlining simple steps, a style guide or whatever information you'd like others to know about contributing, is a great way to make your project more accessible for those wanting to help. Some services, like ones that check to see if all your tests are passing, will provide special graphics, known as shields, for your readme's. These shields are useful because they're provided by a third party, and let your users know helpful information about your code. If this seems a bit confusing for now, don't worry too much about it. I know when I started writing documentation these really confused me because I thought I needed to have them. Once you've written lots of tests in your code, these shields will become useful. But when you're just getting started, don't worry too much about it. A word of caution, don't make your life more complicated than it needs to be. Allow your documentation to grow with the code base and only add new information as needed. We've looked at just a few potential sections you might want to include in your readme as you document your code but don't limit yourself to just these. As your code base grows, which sections might also make sense to add to your readme? Known bugs, frequently asked questions, press that your project has received, a table of contents or pictures of your cat. Select as many as you think apply. >From a user's perspective, known bugs would be very useful to know. Otherwise, I might be banging my head against the wall for hours trying to figure out why the code isn't working, thinking it's me that's doing something wrong. If you're getting asked the same questions over and over, frequently asked questions section would be perfectly reasonable. Press that your project has received doesn't really help us actually use your code, so it's not a good fit for a README. This would be something more appropriate for your own website, or the project's website. A table of contents, while it doesn't explain anything useful about your code, is a great way to help users jump to important sections in your README. Since these are for humans, a table of contents would absolutely make sense in your documentation, and while I'm sure your two cats are the most adorable things on Earth, photos of them should probably go on Snapchat, not your README. A read me file can technically be written in any file format. You can make your read me web page, a simple text file or even a made up format if you wanted to. For this lesson, you'll be generating your read me using language known as markdown. Markdown let's you generate well formatted read mes by translating them into HTML. Sites that you may use often as a developer, such as GitHub, Stack Overflow, Slack, and even Reddit, all use versions of markdown for quick and easy formating of your content. One of the main advantages to using markdown is that we can make read-mes that are easy to skim through. Take a look at these two recipes. Both of these have the same information. But without even needing to read the contents of each, which one would you rather follow? The recipe on the right is formatted in a way that makes it easy to skim through. When writing read-mes, take advantage of the awesome features markdown gives you to make sure they are easily readable. You'll practice writing markdown in the next few nodes, but first I'll be giving you a quick guide to markdown syntax. Let's do a quick review of some of the syntax you've learned. In the spaces provided, take out the necessary mark-down to create each of these sentences. So in Markdown, we use a hash to indicate a header. We use a single hash to note that this is in each one. We use backticks around our text to indicate that this text is actually inline code. We use two asterisks around any text that we want to be bold. And we use a single underscore around any text that we want to be italicized. Markdown is useful for evenings, since you won't need to write quite as much code than if you'd written it with HTML. In this exercise, take the HTML we've provided for you and rewrite it as markdown. So this code over here gets the job done, this HTML translates to a nice looking read beam. But we can do this in less code if we do this in markdown. So let's start translating this so that we get the same results. Right off the bat, we can see that we've got an H1 and two H2s over here. These can be translated pretty easily using the hash syntax in markdown. Remember that the number of hashes indicates which H tag you're going to be using from H1 all the way to H6. Next we can see that we've got two paragraphs here. In markdown, these P tags for the paragraphs are not necessary so we can go ahead and take those out. Next we've got the strong tag along with the M tag which should look familiar from the last exercise. Strong makes our text bold, M makes our texts italics. So, we can go ahead and rewrite those and we've got now the last two sections, our list and our code blocks. This is going to be where mark down really going to come in handy And save us a lot of code. We've got our unordered list here. And you can see we have the UL tag and then an LI tag for each one of those list items. In mark down, we just need a single asterisk for each one of those list items, and it's going to automatically know that this is a list. And you can see that our read me still looks exactly the same. Next we can take this anchor tag here and shorten that a bit. We're going to use the bracket syntax to indict the text that we want in our link and then parenthesis to indicate our path. Here at the bottom we see the pre-code combination here which will generate this code block. This may not be code that you're super familiar with. But when you are writing code like this it comes in handy very often. But this can be rewritten easily using the three back ticks. So we'll use three back ticks to indicate the start of our code block, another three to indicate the end of our code block. So as you can see, this mark down translates to the same read me that the HTML we had written did. But it does it in a way that is much more readable. Even if we didn't have this mark down file being generated here on the right. We could still look through this mark down file and more or less understand what's going on and it took us considerably less code to get there. Now, you've got the skills to start documenting your code with simply readmes written in Markdown. If and when your code grows, you may want to explore other forms of documentation, but this is a great place to start. Writing great code isn't just about building something that works, but building something that's both easy to use and easy to maintain. If you're documenting your code, then you're writing code that's meant to be used by humans. Being conscious of this fact beforehand will make you a better developer. I'm going to leave you with a challenge. Go revisit some of the projects you've built and write a readme for them. Make documentation a priority for all your projects moving forward. You'll thank yourself later.