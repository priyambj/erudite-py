Hey Magnus, I was looking for you. Hi Jocelyn, how's your app coming along? It's doing okay but I want to run adds in it and I don't know how to do that. Have you come to the right person. I just finished a course on ad mob. Cool and how's your app doing? It's been out in the play store for a while now hasn't it? It's doing great, tons of people have downloaded it. And what parts of your app do they use the most? I don't know. Do they use it more on phones or tablets, Android TV? I don't know. Do they use it more in Africa, America, Iceland, Australia- Stop, stop, stop. How am I supposed to know the answer to all these questions? You could use Google Analytics. Google what? I don't how to use that. Have I got a deal for you. I'll teach you how to use Google Analytics if you'll teach me how to run ads in my app. That sounds like a great idea. Let's get started. Hi, I'm Jocelyn, and I'll be teaching you how to add code to your mobile app so you can track usage data, and Google Analytics. I'll also introduce you to Tag Manager. Using Tag Manager, you can make configuration changes to your app, without having to redeploy the binary. And you can also manage the tags to send data to analytics. This course assumes you know how to build an Android app and how to add the Google API client library to your project in build.gradle. The course uses a skeletal sample app that helps you figure out what's for dinner. This app is already built for you. Your task will be to add the code to send data to analytics and to use Tag Manager variables to dynamically update the app. This course focuses on how to add code to your mobile app to use Google Analytics and Tag Manager. It does not teach everything about the Google Analytics and Tag Manager dashboards. There are excellent alternative resources for learning about both of these. So Google Analytics provides a dashboard where you can see information about how people are using your app. So here in the overview page, we see how many users. How many new users we've had in the past month. 400 not too bad. Active users, 1,200, so that's the new users and the previous users. We can see where in the world people are using our app, and we can see what devices they're using to use the app. So we can drill down a little bit more into some of these details. So, for example, where in the world. We can, like, really drill down, we can see how many people, oh, we have 770 in New Zealand right now. Oh, one in Madagascar, and then we can get the actual data for it too. So, we get the numbers. And this app that we're using here was developed by my friend, Ian, Ian Lake, and you've probably seen him in the Android fundamentals two course. We can look into the language that people are using. In this case it's predominantly English, but we do have Portuguese, we do have some French users. So we can drill down more into the devices that people are using. So here we see all the different devices. And we can see the percentage of the popularity of the devices. So, the Galaxy S5 was the most popular recognized device. Some of the unrecognized devices include the emulator, as well as devices that Analytics didn't recognize. You can see the top network operators. We can even see the screen resolutions that people used. The branding. One of the really cool things I can show you is the real time data. You can actually see how many people are using your app right now. And actually I have to be honest. It's not really right now. It's close to right now. So it's close to real time. You can see the top locations where people are using the app. So somebody down here in Melbourne is actually using the app right now. We have people in Peru using it. We have people in the Philippines using it. We can see what they're looking at right now. And of course, you know, one of the main things you do want to know about your app is, what parts of the app are the users using. You get that through the screens. So this is not the real time data, this is overall in the last month. We can see all the screens, which screens the users went to, and a screen is equivalent to an activity. We see obviously, that the main screen is where people went the most. And then you can see, you know, where else they went in the app. You can also follow through the flow of how people navigated through the app. So, you can see where they started, where they went to next, and so on. So, I hope I've convinced you that Analytics can give you all kinds of awesome information about how and where you're apps being used. And now, I'm going to talk you through how you can update your apps, so that you can get all this awesome kind of information about how your app is being used. So I'm just going to start out by giving you a quick overview of the main steps that you need to do to enable Analytics to give you useful information about your Android app. The first thing you're going to need is an Analytics Account ID. And you get that in the Analytics dashboard UI. And I'll be showing you how to do that. Once you know your Analytics Account ID, you need to add code to your app so that your app knows to send the data to Analytics. The code's not very difficult, and we'll be walking through that. And once your app's started sending data to Analytics, of course, then you can use the Analytics dashboard to look at all the awesome data. First, you'll need to create an Analytics account ID. I'll walk you through this process, and in the next node you'll do it yourself. We start by going to analytics.google.com. If you're already logged in to Google, you'll see the Access Google Analytics button at the top right. If your not already logged in, you'll see a button for signing in. I'm going to assume you already have a Google account, but if not, go ahead and create one now I'm going to sign in. If you're new to Analytics, you'll see a welcome screen. Go ahead and sign up for Analytics. You're going to be tracking a mobile app. And you need to enter an account name. This can be whatever you like. It's for you to identify the count. It's a good practice to have the name be something that relates your app, then you need to setup the app name. Analytics doesn't check that it corresponds to a real app name, so again, enter something helpful to you. Go ahead and fill in the rest of the form. Choose an industry category. Our sample app is to do with dinner, I guess that would be food and drink. My reporting time zone is the United States. States GMT Pacific Time. Yours might be different. And then also choose the data sharing settings. The first data sharing option is that you can choose to share your data with other Google products only. And this means sharing the data with your other accounts. For example this lets you import your Analytics data into your AdWords account, if you have one. The next data sharing setting, is that you can choose to share your data anonymously with Google and others. This basically just means that your data will be shared completely anonymized with Google, all identifying information removed from it. And Google will use the data for marketing, educational purposes and to make customized communications. If you share your data with technical support, this helps us help you, if you have technical difficulties. The last sharing option is for account specialists. So if you share your data with account specialists, this means that the Google account specialist can look at your data and help you optimize your strategies. And you'll see at the bottom it tells you how many accounts you're using. For this user that I've logged in with, I'm using 0 out of 100 accounts, so this is going to be my first account. So now, I'm going to get my tracking ID. Accept the terms of service, assuming you do accept them, and look yay. I have a tracking ID. So, this tracking ID is going to be the link between your app and Analytics. You'll add the count ID to your mobile app code. And then, when people use your app the app will send usage data to Analytics at this ID. Now it's your turn to create an Analytics account. Go to analytics.google.com. Create a new account. And of course, make sure that it's for mobile. And when you've got your account, check this box to show us that you created your Analytics account. So this is how the Admin dashboard looks after you first get your tracking ID. We're going to close this window, just have some information, you can read it if you want, I'm going to close it. So we're currently in the Admin tab and if you click this button here. This arrow, left-pointing arrow, that expands the Admin dashboard for you. And you see up here these tabs tell you which dashboard you're in. Currently we're in the Admin dashboard. So the overall account is Whats for dinner, and within that account, we can have multiple properties. But right now we only have one property, DinnerApp. So basically, DinnerApp is our app. So if you click Property Settings, this pretty much takes you to the settings for the property. This is where you come if you want to find your tracking code. Here you see your Tracking ID. You can also go to tracking code down here. This is where you started out, remember. So Google Analytics was originally designed for websites. Before there ever were any Android apps. It's still a great tool for tracking website data, but it's become an equally amazing tool for tracking mobile app data too. But there are still parts of the Analytics dashboard that haven't yet let go of their origins as a tool for websites. The icon here, .js, is taken from the web usage of Analytics. Websites use JavaScript code to talk to Analytics, but for mobile apps, of course, JavaScript code is not needed. Don't worry, it's just an icon. So to get back to the overall Admin dashboard, you press this button here, the arrow I mean. Let's take a look at the views section. By default, you get a view called All Mobile App Data, which, you guessed it, tracks all the data from your mobile app. You can add more views if you like, and set up filters. But one view will serve us just fine for now. When you have some data to view you can use the Reporting tab here to explore the ways that Users are using your app. No Users yet, but that's not a surprise because we haven't hooked the app up to Analytics yet. To get back to the admin dashboard, go to the Admin tab. So, now it's your turn to explore the Analytics Dashboard. Feel free to explore the Admin Dashboard. Look at the different options, see what the things do. You'll find that there's really a lot of options here, Channel Settings for example, e-commerce settings, Adsense linking. Things like this you may not be ready to use, but don't worry about that. There's a lot of resources for learning how to use analytics. And this course is going to focus on how to add analytics to your mobile app. Okay, so take a look around the Admin Dashboard, switch to the reporting dashboard, investigate some of the options, go to the Home tab. What do you see there? Feel free to set your preferences, uncheck everything, check them all, as you like. What about the Customization tab? Again, I don't want you to necessarily understand everything you're seeing. I want you to learn how to navigate through the different tabs. And how to get back to the Admin Dashboard. When you've done some investigating, take this quiz. Which dashboard do you use to do what? So the Home screen is where you go to see a list of your Analytics accounts. For now, you've only got one Analytics account, but if you had more they'd show up here. And the Reportings dashboard is where you'd go to see where in the world people are using your app. You go to the Admin dashboard to see the Account Id. You go to the Reporting dashboard to see real-time data. Course, no users right now. And you go to the Customization dashboard to create custom reports. We won't be covering customized reports in this course, but it's helpful to have a high-level idea of what each of the tabs are for. And if you want to give permission to other people to use your account, you'd do that in the Admin dashboard in the User Management section, can add new users. So how did you do on that quiz? Now that you've got your analytics account ID, the next step is to use it in a mobile app. For this lesson we'll use an app that helps you decide what's for dinner. In my family, we often have a hard time deciding what to eat for dinner. And sometimes it's nice to just let fate decide. That's where this handy dandy app comes in. The app's very simple. You select your food preference, and the app picks a dinner for you. The app has activities for the user to view the recipe, or order a meal online, or try for another suggestion. Users can even hit a button to say they don't like it. For example, I don't like anything that has beets in it. Just a personal thing. As you work through the Analytics and Tag Manager lessons, you'll add code to use those services. The functionality of the sample app is deliberately limited, so that you can focus on the parts of the code that use Google Analytics and Tag Manager. Let's take a quick look at the layout of the app. Here are the Java classes. The Dinner class has methods for figuring out what dinner to suggest. The MainActivity shows the main screen. To start with the main screen only has this one button, What's for dinner? And when you press the button it fires off an intent to the show dinner activity. So the dinner shows here and then you get these buttons. And each of these buttons fires off an intent to start the appropriate activity. So for example, the Show Recipe button sends an intent to start the show recipe activity. And actually, Choose Again does not have a corresponding activity, it just has a method inside the class. Now this class here, the useInfoBoxFragment is a fragment that simply displays an info box and a heading. This lets you reuse the fragment wherever you need it, and helps simplify the code. And for example, the showRecipeActivity, the removeMealActivity, the orderDinnerActivity, all these activities use this fragment. And the app has a couple of menus. There's the main menu, which just shows the settings. But actually, we're not going to use the settings in this application. More interestingly, the food prefs menu, displays a list of food options. This pop-up is used whenever we want the user, choose the food preference. There's one other quick thing I want to mention. In the intro lesson to this course you learned how to implement the unconnected code to use the Google API Client Library. However, for both Google Analytics and Google Tag Manager, you do not need to implement any code to use the Google API Client Library. All the app needs is to specify the version of the client library in the android manifest, like this. And to specify the dependency on play-services in the build.gradle file. And these dependencies have already been set up for you in the What's For Dinner sample app. So take a moment now to download the app from Github and open it in Android Studio. See the instructor notes if you need help. Spend some time learning your way around the app, investigate the app code, look at the layout and the resources and the activities, and make sure you know what the app is doing and how it does it. And then, go ahead and run the app. You can use your own device, or you can use the emulator in Android Studio. What is for dinner? Not beet soup, I hope. Go ahead and check the boxes when you're done. To get the what's for dinner app, go to udacity's GitHub repo for analytics and tag manager. So we've provided Android Studio projects for the start of each lesson, and also for the very final project, which would be DinnerApp_FINAL. You can download everything by clicking the Download ZIP button, and then the zip file downloads with all the Android Studio projects in it. So then, find the downloaded zip file and move it to the folder where you have your Android Studio projects. Expand the zip, and inside you'll see the different directories for the different projects. So then, go to the Android Studio and open DinnerApp_BEGIN. And then compile it. So one handy hint is if the Gradle files get out of sync, you can force a resync by going to Tools > Android > Sync Project with Gradle Files. And as you work through the course, you can continue working in the same app, or you can get the Android Studio Project for the start of each lesson. Okay, let's go do some work in the app. Now that you've got an Analytics account ID and an app, the next step is to add the ID to the app. The steps for activating Analytics in your mobile app are, one, update the permissions for the app. And two, configure the tracker to use the account ID. And three, write the code to create the tracker, and then start auto tracking. Let's go write some code. For you app to be able to send analytics data, it needs to have permissions for INTERNET and ACCESS_NETWORK_STATE. So go ahead an update your AndroidManifest.xml file to give it permission for INTERNET and ACCESS_NETWORK_STATE. There are a couple of different ways to let your mobile app know which analytics account to use. You can do it programmatically, or you can use an xml configuration file. In this lesson, we're going to use an xml file to configure our analytics tracker. You'll need to create a new xml file in the res xml folder. Go to res choose New > Android Resource Directory. The name of the directory is xml. Now that you've got your xml folder, you create a new resource file. You can call the file what you like. I suggest something like track_app.xml You'll need to make sure that the root element is resources. The most important thing to put in the analytics config file is the analytics account id. Do that by adding a string resource that has the name ga_trackingId and the value is your analytics id. And remember that you can get your cam id from the analytics admin dashboard. But to start within our app, we're going to enable automatic tracking, so you'll need to add the string resource ga_autoActivityTracking to the config file. The autoActivityTracking needs to be set to true. This is the minimum you need in your tracking config file, but I strongly recommend you also configure screen names One of the main things you get out of using Analytics is that you can see which parts of your app your users are using. When auto-tracking is enabled, Analytics tracks usage of all activities that are ended on the screen. Analytics uses the term, screen to mean an activity that's displayed on the screen. So here, this activity is rendered as the Show Dinner screen. You can name the screen specifically, or you can let Analytics use the activity class name as the screen name. Here's what it looks like, if you use the class names as screen names. But here's how it looks, if you assign you own screen names. You specify screen names in the tracking config file by using, you guessed it, a screen name tag. The name attribute is actually the name of the class, complete with package. It's not the name that shows up in the Analytics dashboard. The value of the tag is the name that shows up in the dashboard. Here we've got, Show recipe. And here we've got, Show recipe. There are some other options you can configure in your tracker configuration file. For example, you could set the session timeout. And the session is a pretty integral concept to Analytics. And the session timeout indicates how long the app can be in the background before Analytics consider the current session to have ended. I'm not going to go over all these parameters now, but you can read about them at your leisure in the developer docs, and the link to that is in the instructor notes below. One quick thing I do want to say is that we already looked at the tracking ID, but if you want to stop sending data to Analytics, the easiest and quickest way to do it is just to take your analytics ID our of the tracking ID. Now it's your turn to create the tracking configuration file for your app. Create a new XML resource file called tracker_app.xml in the res > xml folder. Don't forget, you may need to create the xml folder if it doesn't already exist. And of course, you can call your config file whatever you like. It doesn't have to be tracker_app.xml. That's just a good name. And make sure that the root element is resources. Set your account ID, and you do that with the ga_trackingId parameter. And then enable auto tracking, and you do that with the ga_autoActivityTracking parameter. And don't forget to set it to true. And then finally, add the screen name tags for the activities in your app. And check off each of these boxes when you've completed the tasks. Hopefully you successfully created your tracker config file. It should be in the XML folder in the RES folder. A little hard to see, but this is RES/XML, and this is the file, this track_app.xml. And again, you could have called your config file whatever you wanted. So here's my tracking ID in the ga_trackingId. Here's where I set autoActivity to true. So I'll get the usage data any time a user goes to any activities in my app. And here are the different screen names that I've set. I've got the Main Screen, the Order Dinner screen, the Eradicate Dinner screen. And these are names that were going to appear in the Analytics dashboard. Great, now you've configured the analytics tracker for your app. The next thing is to programatically create the tracker. However, we want to make sure that we only have one tracker running each time our app is running. It's possible to have multiple tracker objects, all sending data to the same analytics account, which would result in inaccurate data. You might end up with the same hits being counted multiple times. For example, let's say the user goes to the main screen in your app and presses the What's for dinner button. The app will take them to the Show Dinner Screen. But let's say you've got three analytics trackers running. They'll each report a hit to analytics for the Show Dinner Screen, and you'll end up with three screen views being reported, when really you only had one. We don't need to say it's a tracker in between app invocations, but we do need to make sure that when the app is running we have only a single tracker instance. So to make sure that the tracker is created only once each app invocation, we're going to use the Application object. It's really very simple, and I'll show you how now. Every time an app starts up, it creates a singleton application object, even before it creates the main activity. Activities can get hold of the application object, by calling the method getApplication. We're going to save our tracker in the application object. If you want to add things to the application object, you need to create a subclass of application, but it's pretty simple. I'll show you how. If you already know how to do it, bear with me. It really won't take long. You need to extend the application and save it. And for now, that's really all you need to do. Next, you need to make sure that when the application starts, it creates an instance of your new subclass, instead of the default application class. To do that, go to Androidmanifest.xml and add a name attribute and specify the name of your new subclass. You'll need to enclose it in strings and put a dot in front of the name. That's all there is to it. Now when your application starts, it creates an instance of your new application class. Go ahead and define the new application subclass now. You're going to need to create a Java class that extends Application, then specify your new class as the name of the application in AndroidManifest.xml. All you need is the name, but remember to put a dot in front of it. And when you're done, enter the name of your application subclass here. So far, our shiny new application class does absolutely nothing. Let's fix that. We can give it a method called StartTracking to activate analytics tracking. You can use the Google Analytics class to get a Google Analytics instance, like this. When you've got the GoogleAnalytics instance, you can create a new tracker by calling newTracker in the config file for the tracker. It'll look like this. If you call your tracker config file something else, other than track_app, then be sure to use the name of your tracker config file here. And you can see here that I used mTracker as the global variable to store the newTracker. Next, you're going to need to initiate auto tracking and you do that by calling enableAutoActivityReports. It's your turn now. Try out a couple of methods in your new application class. First, define the global variable mTracker, and then implement startTracking. You're going to need to check if the tracker already exists and if it doesn't, then you can create it. While to implement the method getTracker to return the tracker, be sure to check that the tracker exists and has been activated before returning it, and check the boxes when you are done doing these things. So let's take a look at the implementation of the MyApplication class. So here's where I defined the mTracker variable to hold the tracker. Then I have the method startTracking. Just going to initialize the tracker. First of all, check if it already exists. Simple check for now. If it doesn't then create the Google Analytics instance by calling getInstance on the Google Analytics class. And then we create the tracker, newTracker, passing in the tracker configuration file right here. And then we enable autotracking, ga.enableAutoActivityReports. So that's all there is to start tracking, and getTracker is actually even simpler. ALl we have to do is call startTracking, and the startTracking method takes care of checking, does the tracker already exist or not? And then we return the tracker. Okay, I hope you all got that. So now, you've defined the code in your application class to start tracking. But so far, there's nothing that triggers the startTracking method. But, all you need to do to activate tracking is to call the start tracking method that you just wrote. You can call it in onCreate in MainActivity. And, Activity can call getApplication to get the application singleton for the running app. However, since you're using your own subclass of application, you need to cast the result to your subclass. Once you've got the application instance, it's a simple matter of calling startTracking to kick off tracking. And, you have to get your parens right. So, go ahead and add the code to onCreate in MainActivity to start analytics tracking. And, make sure your project compiles. And here's the code in onCreate with a call to startTracking. This'll make sure we have a single tracker instance for this app, and that autotracking has started. Now it's time to use your app and see the usage data show up in Google Analytics. You can use the emulator in Android Studio or your own Android device. It's okay to use the emulator, but it might not send data back what device it's emulating. I like to use a real device. Make sure your device is connected to Android Studio, and click the Run button to run your app. Make sure the app's running on your phone, or tablet, or whatever you're using. Then click through to a few different screens. Make sure to switch the phone between portrait and landscape, a few times too. Okay, as you do these tasks, go ahead and check the boxes. Make sure, of course, that your project compiles. Make sure you went to some different activities and check here when you're done. Then go ahead and try the app in both orientations. Do it in portrait and in landscape mode. We're doing this so that we can get the different orientations and screen sizes to show up in the dashboard. So when you use your app and it sends the hits to Analytics, it might take a while for the data to show up in the Analytics dashboard. If, like me, you need the instant gratification of seeing the hits being sent. You can check the logs in Android Studio. So you're going to need to enable verbose locking. Can do that in startTracking method in your application sub-class, like this. You get the GoogleAnalytics instance and then you set the logger level, and you set it to VERBOSE. You're also going to need to import the logger class. So when you've made these changes run the app again. Make sure your phone's connected to Android Studio, and run the app again. Now, down here in the logcat window, make sure you're showing the logcat window, set the logging level to Verbose. Make sure you have No Filters and search, for sending hit. If you have anything there already, go ahead and clear it all, so that you can start with a clean slate. This is what your logging settings will look like. Then grab your phone and use the app, and you should see the logging entries showing up here. And each time you go to a screen in your app, you'll get more entries showing up in the logcat. So eventually you're going to get a bunch of log entries for each hit that gets sent. So let's scroll down and look at one of the hits. So an is the application name. In my case, What's for Dinner? And cd is a screen name, so I went to the Show Recipe screen. And I think the cd is for content description, but here it is the screen name. Ul is the language. US English. And t is the hit type, which in this case is the screenview. And the tid, this down here, is the Analytics account ID. This gets taken directly from the config files. So if you've got the count ID wrong in the config file, it's going to be sent wrong in the hit. There's no actual verification done to make sure that this is a correct value. And down here, aid is the package name. So seeing these log entries tells us that hits are being sent. Now we can go look for the data in the Analytics Dashboard. Now it's time to look at our usage data in Analytics. Remember, to get to the Analytics dashboard, you go to analytics.google.com. Log in, if you need to, and choose your account. And the Analytics dashboard opens at the App Overview page. But first, I want to look at the realtime data. So, go to Real Time and Overview. Pause the video now while you go to the Real Time Overview, right now. When you go to a screen in your app, a tracking hit is generated. The Analytics service batches up tracking requests and sends them all together at regular intervals. I'll talk more about that soon. The point here is that you might need to wait a few minutes for the data to start showing up in your app. The data's going to show up while there are active users, and then when nobody is using your app, it's going to disappear. Now let's look at the accumulated data. To do that, go back to the App Overview. Get that by clicking here, App Overview. And the Overview page gives a summary of all the data for your app. Notice a default date range up here. And you'll see that it ends in not today's date, but yesterday's date. So this is April the 6th, today's actually April the 7th. So, since we want to see the data that we got for today while we're testing, we need to change the date range. So you click on it, you choose the start date and the end date. And I recommend while you're the only one using the app and working through the course, just set the date range to just be today. So go to today, whichever that is. For me, that's 7th of April. Set the start date, and then the end date will automatically be today, because you can't go beyond today. And you apply the date range. And don't worry if you don't see any data yet. It might take a while for the data to show up. While we're waiting for the data to arrive, I'm going to talk a bit about sessions. So you see up here, it says we're viewing data for all sessions. A session indicates a period of continuous use for your app, and it's a key concept in Google Analytics. So if you use your app for awhile, say for a few minutes, and then you put it down, let's say looking at dinner suggestions makes you hungry so you go get an ice cream. And then you eat your ice cream. It takes you about ten minutes. And then you go back to your app. And let's say you've been away from the app for ten minutes. So when you go back to the app, you're actually in the same session. It's all been considered one continuous session because it's been less than 30 minutes of continuous use. Even though you actually stopped using it for ten minutes. But let's suppose now that you take a longer break. And you go for a much bigger ice-cream. This is going to take you longer to eat. But, again, even though you ate the whole ice cream, you're still hungry so you're going to go back to your app. Now, let's say you were gone from your app this time for 31 minutes. In this case, when you go back to the app, you're going to be in a new session, because the default period of time for a session is 30 minutes. Even if you saw the activity show up in the real time screen, there's no guarantee, and when the accumulated data shows up from the other parts of the dashboard, see, I still have zero users. When there's very low usage of an app, then the data typically shows up for too long. While testing my app though, I found I sometimes needed to wait up to 20 minutes. Not always, but sometimes. How long does it take for your data to show up? Add a comment in the discussion forum. If you see the date is showing up in the analytics dashboard all is good, however if you feel you've waited too long, review this checklist. To make sure you set up everything correctly to send the data to analytics. And the one that gets me almost every time, is the date range. So make sure you set date range to include today's date, and then check these other things. Make sure you're using the correct account ID, that's pretty important. And make sure that you've enabled auto activity tracking. And of course, make sure you've wrapped, deployed, and ran and used the app on your device, where you're not going to get any data. You may find that the data shows up faster in some parts of the dashboard than others. So I just noticed that in my Screens page, which you get to by going to Behavior and then Screens, you see I do have some Screen Views. And I've got the data on which screens were visited. Finally, my app overview does have some data. You get to see how many new users there were. Only one, not surprising. I'm the only person who used my app. How many active users, and, in this case, the active users is the same as the new users. Could see the countries where the users were and the devices that they used. And the user engagement indicates how much the user was engaged with the app, how long the sessions lasted, and how many screens they visited per session. The screen section shows you an overview of the screens that were visited and how many views they each had. So when your data shows up, take a look at the sections in the app overview page. And remember, you may find that the data shows up faster in some other places, like the Behavior screens, the data may show up here before it shows up in the Overview. Anyway, when the data comes in take a look at the sections in the App Overview page, and then answer these questions. What was the most visited screen? Go ahead and write your answer in here. How many visits did it have? And where are the users? And then that's it for this short quiz. So every time a hit is sent from your app to Analytics, it includes certain kinds of information. You get to see which screens or activities your users went to. You get geo information, like their language and their location. You get device information. What brands, models, OS. And you get network info. So every time a hit goes to Analytics it carries all this information with it. So now that we've got some data in our dashboard, I'm going to drill down into the different parts just a bit. I'm not going to give an exhaustive tour of the dashboard. There is like week-long courses on how to understand everything in the dashboard, but I will take you to the key pages. Let's look at the audience and see the overview. And the overview page shows quite a bit of information. You can drill down here, see the country, the city. Now you all know where I was, probably no big surprise, the app name. So you can just drill down through these things and get the information. Notice the screen resolution and see that I went to 2.56 screens per session at nine sessions and the average session duration 27 seconds. That was the overview for the audience. You can look at the app versions. Another one that's cool, of course, is Geo, which gives you information about the languages. In this case only one language. The location. You can actually drill down into the location. You can just keep drilling down. At some point you won't be able to drill down any further. Another part of the dashboard that you should get really familiar with is the Behavior. Through the Overview gain a summary of things. The screens, there's all the screens the users went to. And remember this will be aggregated data for all your users. because in our cases just the one user, which is us. And you can drill down a bit more, get the average time on screen. Percent exit is how, what was the percentage of visits. This was the last visit to the app. So back in audiences too, of course, you can go down into the devices, Overview, my network operators, I don't know what they were. Anyway, you should drill down into your own data, see what you can see. So take some time to explore the different pages in the reporting section of the Analytics Dashboard, then take this quiz. What data do you get with auto activity tracking is enabled? Do you get to see users' locations, their devices, what buttons they clicked, who uses email addresses, and do you get to see what other apps they have on the devices, whether they were running your app. Check all that are true. So yes, you get the user's location, we already saw that. You get to see their devices. You don't actually get to see what buttons they clicked. Although, if clicking a button starts a new activity with a visible screen, you can track button clicks that way. But not all button clicks start a new activity. But to track button clicks, you need to send event hits to Analytics, and we're actually going to look into how to do that in the next lesson. Users email addresses, no absolutely not, never. And you never get to see what other apps users have. Hopefully, once your app is launched on the Google Play store, you will have lots of users who will use your app constantly. So if you've got Analytics enabled, then every time a user does anything with your app, a hit will be sent to Analytics. But now you might start worrying about impact on performance and battery drain from sending all these outbound requests over the network so frequently. Because every outbound request needs to wake up the battery. Relax, you don't need to worry about battery drain, because the engineers at Google already worried about it for you. They designed the Google analytics class to batch up requests, to reduce pings to the battery, which means adding analytics to your app has a minimal effect on performance and battery usage. Android devices have a central analytics service, that's shared by all apps. So when a user uses an app, that app sends a hit request to the analytic service. This is not an outbound request over the network, so the radio receiver and the battery are not involved. So the analytics services collects the hits from all the apps and batches them up, and sends them together in two minute intervals With the maximum hit of 20 per batch. It's only this batched request that goes out over the network. The analytics service takes care of sending the hit at intervals that don't have too much impact on the battery. That's the end of the first lesson about Google Analytics. You've got your Google Analytics account ID, and you've enabled auto tracking for all your activities. You started learning your way around the Dashboard, and you've seen the data show up for screen views. In the next lesson, we'll delve into how to code your app to track events, and how to get data about the way that users move through the shopping process. Enabling auto tracking on all activities is a quick way to get started with Google Analytics, but it's not always the best approach. You should think about what data you really want to track, and code your app to track the data that's important to you. In this lesson, we look at how to track data about what your users do by sending specific screen and event hits. We'll look into tracking goals to see if users are completing the app objectives. We'll delve into tracking Ecommerce there to see if users are spending money. And then we'll take a quick look at how to send timing data, and how to track crashes and exceptions. We'll finish the lesson with a discussion of tracking how users download your app. It's always good to know. You've already learned how to activate auto tracking so that every time any user goes to any screen in your app, a hit is recorded and sent to Google Analytics. While you're learning how to add analytics to your app, it's fine to have auto tracking enabled. It's gratifying to see the hits coming in the dashboard. But if your app gets wildly popular and if you've got auto tracking enabled, then that's going to be a lot of screen hits that get sent. In fact, it could be too many hits, and you might run into quota limits. If your app exceeds its quota limits, excess hits will not be counted. You can read about quota limits in the developer docs. The main point to understand is that it's often better to specifically track what you want to track rather than enabling auto tracking across all activities. It's easy enough to disable auto tracking for all activities. Simply set ga_autoActivityTracking to false in the config file for your tracker. And then, instead, to track when users go to a specific screen, you can send a screen view hit, like this. You add the code to onStart. Then you get the tracker. Hopefully you know how to do that now. You can set the screen name on the tracker with setScreenName. And then you send the hit, calling build on HitBuilders.ScreenViewBuilder. And you'll need to make sure that your app has the right imports. You're going to need the Tracker class. And you're going to need the HitBuilders class. For all hits that are sent, you still get the geo information, the device info, the engagement details, and all that other good stuff. Okay, go ahead and try it now. In the tracker config file, set ga_autoActivityTracking to false. Then pick an activity in your app, and add the code to the onStart() method to send a hit. So, here, I'm tracking hits to ShowRecipe. So I'm in the ShowRecipeActivity with my onStart method. And you can see I set my screen name to Show recipe screen. And here's the code to send the hit. And then, of course, run your app and try it out. You can look in the logs to see that your hit gets sent when you go to that screen. See there's my hit, but not when you do anything else in the app. And then of course, don't forget to check your analytics dashboard and then come here and check the boxes. You can use Analytics to get other kinds of data, not just screen views. I'll quickly show you the kinds of data you can get, and then you'll try it out for yourself. You can add code to your app to find out what your users are doing by sending data to Analytics to track events, like when a button is clicked. Or if you're building a game, say, you could send an event when a user unlocks a new level. Here's an example of the event screen in the Analytics dashboard. So you see the category of the event, and you see the actions. You can find out if your users are doing what you hoped they'll do by setting goals. For example, you might set a goal for the users to click the Buy Now button, or click on an ad, or reach a certain page. So here you see that one of the goals is for the users to rate the app. So you can track how users browse and buy. If your app lets users view products and buy them, you can track how the customers progress through the shopping flow. You can see which products get purchased in the product performance page. And you can track the steps throughout the purchase and checkout process. To track the way users view and buy things, your app needs to have the structure and code in place. For users to browse products, add them to the cart, checkout. And then to get the Analytics data, you need to add code to send a hit to Analytics at each stage of the process. You can also track how long it takes for things to happen in your app. You need to write the code to time the task that needs to be timed. And then you add the code to send the hit to Analytics to report the timing data. And you see the timing info in the App Speed page in the Behavior section in the dashboard. And you can track when things go wrong. You can send data to Analytics when your app throws an exception or, in the hopefully unlikely event, has a crash. So here are examples of a couple different exceptions. You can also track how users download your app. In this course we're not going to put our app on the Play Store, so I'll leave you to explore how to track down those sources in your own time with an app that you've published to the Play Store. So that was a roundup of the kinds of things you can track with Analytics. Now, let's go do some tracking. Let's look at how to track what users do in your app. First, you need to identify what's important to know about what your users are doing. Do you care if they set preferences? Maybe you want to know if they reach a certain level in your game. Perhaps you want to know if they ordered takeout, or if they clicked an ad. So here's a code to send an event hit to Analytics. You create the tracker. Should know how to do that by now. Then you use an event builder to build an event hit. You set the category, the action, and the label. And these three things, the category, the action, and the label, are going to show up in the Analytics Dashboard. And you put this code wherever you want to record the event. So I'd like to know which of the dinner options are unpopular, which ones people don't want to see again. So I'm going to add the code to track the event in the method that's called when the user presses this button. In this case, it's the removeMeal method. So this is the removeMeal method in the ShowDinnerActivity. This is the method that gets clicked when users press the button to say they don't like a meal. So this method creates an intent to start the RemoveMealActivity and here's where I've added the code to send a hit to Analytics. I get the tracker, I build the event. I've set the category to Dinner actions, set the action to, Dislike dinner choice, and here, I am passing in the selected dinner, so that I can keep track of actually which dinner it is that users don't like. So to see the report for the events in the Analytics Dashboard, you go to Behavior, Events, and Overview. While you're waiting for the data to show up in the Analytics Dashboard, you can check the log in Android Studio to make sure that the hits did in fact get sent. And in the Analytics Dashboard, in the Events Overview, make sure that the date range includes today's date. So I actually had to wait about a half an hour for these events to show up. But here they are. You see the event categories have only got one category. You see the actions and then again I've only got one action. And you see the labels. You can drill down into the events, drill down into the actions. So here, I can see that the tofu and coriander salad was the most disliked with three dislikes and you can see other data about the event. Now it's your turn to add code to your app to track when users do something. So add code to your app to track the remove meal event, or you can choose your own event to track. Then you're going to need to run the app on your device. Make sure it's connected to android studio, and use the app. And in particular, make sure that you do the event that's going to fire the event hit code. You can look in the logs to see the event being sent to the analytic service for dispatching. Then you need to review the events in the Analytics dashboard. It's a good idea to keep an eye on the real time data because then you'll see the hits showing up fairly soon after you actually send the event. And it's nice to have that feedback just in case it takes a while for the data to percolate to the rest of the dashboard. Then think about what events you might really want to track in this particular app. Is it helpful just to record what dinners people don't like? Go ahead and discuss it in the forum. Now I'm going to talk about setting goals. You probably have some personal goals for yourself like getting fit. Well, you can also set goals for your app. For example, you might set a goal for users to click the donate button or reach a certain level in the game. Or stay engaged with the app for a certain amount of time, hopefully not that long. To set goals for the app you go to the Admin interface. And then in the View, you click Goals. And then create New Goal. When you're setting up a goal you'll see a list of templates. If you choose a template, it fills in the name and the type for you, like this. But even if you choose a template, you can change the name and type anyway. So I'm going to start out by creating a custom goal. And you enter whatever name you want and then you choose a type of goal. So you can specify screen that you want the users to reach or duration how long you want them to stay engaged with your app. You can specify how many screens you want them to visit in a session. And you can also specify an event like view product or show recipe. So I'm going for five screens per session min. So after you set the name and the type, you can add more detail for the goals. The details you can set depend on the type of the goal. If the type is number of screens per session, well you choose how many you want. I want at least five, that would be greater than four. If the type is duration, then you could specify criteria for the duration. How many hours, minutes, seconds do you want the users to stay engaged as a minimum. If the goal type is destination, then you specify the screen name. And as you see, there' some flexibility around how you specify the screen name. You can give a regular expression if you want. And notice the funnel option. If you enable this, you can specify the progression through your app that you wont use to take to reach the destination. My advice is to start out with the simpler options and as you build your understanding of Analytics, to add in more complex tracking. For now, I'm not going to set a funnel. If the goal type is event, then you specify the category, the action, the label and the value of the event. And actually you can specify any or all of these starting with the category. You could just set the category. And leave the other values blank if you wanted. So I'm going to set up a goal called five screen for my users to visit five screens per session. So I've chosen the type Pages/Screens per session. And I want them to go to at least five. So that would be greater than four. Then, I create the goal. So now my goal is listed in the list of goals. Now you might be wondering, do you need to write code for the goals? Well, it depends, is order activity tracking enabled for your app? If it is, then you don't need to write any code for screen-related goals. Analytics will get hits for all screen views. But if the goal depends on other kinds of hits, such as event hits, then your app must include the code to send those hits. If auto activity tracking is not enabled, then your app must have the code to send the hits that Analytics needs to figure out if the goals are met, or not. And that includes screen view hits, because if auto activity tracking's not enabled, Analytics won't get screen view hits. Other than the ones that get explicitly sent by the app. So I've created one goal for my app so far. But each app has a limit to how many goals it can have. After you create a goal, you can't delete it. There's no point in hunting around for the delete button, because it isn't there. However, you can edit an existing goal and change it completely. So I'm going to change my goal. My new goal is for users to read the recipe for dinner suggestion. There are two ways to express this goal. Either I can set a goal for users to click the Show Recipe button, or I can set a goal for users to go to the show recipe activity or screen. So I'm going to set a goal for my users to go to show recipe as a destination. Now, my app sends a screen view hit through the code in the on start method of the show recipe activity. So I need to make sure that the screen name and the goal is the same as the one that gets set in the code. And see here how it says verify this goal, you can click on this to see what the conversion rate would have been for the date of the past seven days. So this is only going to be helpful if you actually have a bunch of data from the past seven days. And it has to be exactly the past seven days, but not including today. So now I'm going to save my goal, and there it is. Now my app already sends a screen view hit for the Show Recipe activity, so Idon't need to make any changes in my code. So I already have the app running on the phone, and I didn't even need to redeploy it. I'm just going to go ahead and show the recipe a few times. And then I'm going to need to wait a while for the goals to show up in the Analytics dashboard. The real-time view in Analytics doesn't show goal conversion, so you may need to wait a while for the goals to show up. Now it's your turn to set up a goal for your app. You do that in the admin dashboard. Go to Goals and then you create a new goal. Make sure your app is sending the hits Analytics needs. To figure out if the goal is being met. And use it in a way that you know that the goal is going to be satisfied. And you shouldn't need to re-deploy the app after you set up the goal. So I found in the real time screen of Analytics Dashboard, I did not see the goals being converted. So you're just going to have to be patient, and check back in your Analytics Dashboard after some amount of time, to see that the goals were met. And what kind of goal did you create? Did you create a destination goal? Duration goal? A screens per session goal? For an event goal. So, I want you to carry on going on through this course, and checking back periodically in your dashboard to see your goal conversion data when it comes in. I recommend that you don't wait for it. So now let's take a quick look at the report analytics gives for goals. So we want to go to the reporting tab, scroll down to conversions, and choose overview. And again, make sure that the date is either set to be today's date or include today's date. The default range is do to end at yesterday's date. Then you can see, click through goal screens. So I actually clicked on the show recipe screen a couple times, but it was all within one session. So I have one goal completion. I didn't assign any monetary value to it. I didn't set up my funnel visualization, so I don't have much here. And I don't have any goal flow data yet. In the next few sections, we'll look at how to track the way your users view products and buy things. This course does not teach how to implement the shopping cart functionality. What it does teach is how to add Analytics code to report data about the different steps in the shopping process. However, our dinner app needs a bit more functionality to be useful as a learning tool, in this case. You'll add an activity to the app to display all the dinners. This list will let your users see all the dinner choices and pick which ones they want to view. The dinner class already has a method, getAllDinners, that returns a list of all the dinners. So now we need to add an activity. To display all the dinners as a scrolling list. We also need to add a button on the home screen that starts the activity to display all the dinners. So you're going to need to add some code to your app. To start with, you're going to need to add the ShowAllDinnersActivity class. And then you'll need to add the method showDinnerList in the Main Activity. And the onClick action of the items in the list will be to go to the Order Dinner screen. So, currently the Order Dinner screen just displays an info box about ordering the dinner. But as you work through the next few sections, you'll be adding buttons to this screen to simulate steps in the purchase process. So you'll need to add the Show all the Dinners button to activity_main.xml. And then you're going to need the layout files for the scrolling list of dinners. So you'll add list_all_dinners.xml for the scrolling list itself. Then show_dinner_in_row.xml for each row in the list. If you're up for the challenge, write the code yourself, or if you want, you can just get the predefined code from GitHub, up to you. So now I'm going to look at the code that I added to implement the scrolling list of all the dinners. So the first thing I'm going to do is in the com.example.android.dinner package, I'm going to add a new Java class called ShowAllDinnersActivity. This class extends ListActivity. It knows how to get a list of all the dinners. It uses an adapter to display all the dinners in the list, and it defines the onListItemClick, so that when an item on the list is clicked we send an intent to start the OrderDinnerActivity, and passing in the selectedDinner. Now over, in Main Activity, we add the showDinnerList method, which is going to be invoked whenever somebody clicks on the show me all the dinners button. And all this method does, is it sends an intent to start the ShowAllDinnersActivity. So that's it for the code, but now we need to do the layouts. The first thing I'm going to do is add the button to the main screen, to list all the dinners. And there it is, show all the dinners. But I'm not done with the layout yet. I need to add the listalldinners.xml file, which is a list of all the dinners. So we need to add the showdinnerinrow.xml layout file, which is a layout for each dinner entry in the list. All right, that should do it. So, I'm going to redeploy my app and hopefully we'll see the changes in the UI. So of course, one more thing you need to do in the code is to update the AndroidManifest.xml to include your new class, ShowAllDinnersActivity. If you don't do this, it It won't work. So that's all there is to it. Now I'm going to run my app again, and let's see if it works. So, I press my Show All the Dinners, and let's see. Oh, and there's my list of dinners. Cool. If your app lets people buy things, you can use analytics to track how well your app is doing at getting them to view products, put things in the shopping cart, go through the checkout process, and close the deal with a purchase. The first step in tracking how users navigate to the shopping steps is to enable Enhanced Ecommerce in the Admin tab. So, in the Admin tab > View > Ecommerce Settings. You enable Ecommerce, just switch the status to on and then go to the Next step. And then you enable Enhanced Ecommerce, switch it on. For now don't worry about the Checkout Labeling or the FUNNEL STEPS, we'll come back to those later. And then you Submit. Oh look, it says Success. That's nice. So now it's your turn. In the Admin tab > Ecommerce settings. First, you enable Ecommerce, and then you enable Enhanced Ecommerce. And when you're done, check here and here. So you can add code to your app to track how users view products, add products to the cart, checkout, and finally purchase their products. You use two classes to label this kind of tracking, Product and ProductAction. The Product instances define a product, and ProductAction instances define what the user is doing with the product. For example, let's say the user adds a dinner to their cart. So they've selected their dinner, and now they're going to put it in the cart. You'd create product like this, new Product(). Set the name, set the price, set the variant, set the id, and set the quantity. And of course, you're app would actually calculate all these values at the point at which the user added the product to the cart. Then you'd create the ProductAction like this. You just create ProductAction and you specify the action. In this case, ACTION_ADD indicates that the user added the product to the cart. And after you create the Product and the ProductAction, you add them both to an event to send to analytics, like this. Get the tracker, create the event hit, set the category, set the label. And here, we add the product, and here we set the product action. So notice that you do these two things. You associate the product action with the product when you create the event hit, not when you create the product. So what are the different product actions? I'm going to leave you to figure that out for yourself. Go to the the reference for product action, and it's here in the android developer docs. Or you could just search for ProductAction.html in Google, see what you come up with. Anyway, the link's in the instructor notes. And read through the different kind of product actions, and then come and take this quiz. What are some of the actions of a product? ACTION_ADD is to add an item to the cart. But you figure out what these other actions are, and go ahead and enter them in these fields here. So ACTION_DETAIL is the action for when a user views the details of a product, so that's basically anytime they go to the view product page, or they select the product in a list. And you're going to be doing that with the dinners in a minute. When the user purchases the product, the action is somewhat unsurprisingly ACTION_PURCHASE. When the user removes the product from the cart, the action is ACTION_REMOVE. Okay, I'm guessing this is going to be ACTION_CHECKOUT. And in fact, it is. So all of these, I think, are very intuitive. The one that's perhaps not quite so obvious is ACTION_DETAIL, which is basically what you use whenever a user views the product or views the details. So maybe it should be ACTION_VIEW. But, no, it's not, it's ACTION_DETAIL. I just need to remind you that these actions are purely for information to send to Analytics. You'll still need to write the code to actually add the product to the cart, etc. Now that you know what the product actions are, you can add code to your app to track when users view products and add them to the cart. So for our app we are going to consider the activity Order Dinner as the first step in the viewing and shopping process. So when you create a product, you specify a product Id that uniquely identifies the product. But unfortunately for our dinners, we haven't actually given each dinner a unique Id, so you're going to need to do that now. So the dinner choices are all defined in the file, arrays.xml in values in the res folder. And each dinner is just a string. And they're grouped together according to whether they're vegetarian, vegan, and so on. So as a somewhat hacky, hack to quickly be able to get unique product IDs, we're going to add a product ID as the first two characters of each item. So we'll start with 01, 02, and so on. So your task is to add the prefixes to the dinners in arrays.xml. One consequence of our change though is the list of dinners is going to include the number for each of the dinner choices. It's kind of a cosmetic thing, and if you don't like it, I leave it to you to fix the code for that. So now each of the dinner options includes the Id as the first two characters. So it's going to make our life a lot easier if we just quickly add a utility method to get those first two characters to return as the Id. So go ahead and add getDinnerId to the utility class. Very simple method, it just gets the substring of the first two characters. Okay, so now we're really getting to the meat of thing, excuse the pun. You're going to write the code for the method that actually sends the ViewProductHit to analytics. So we're going to consider the Order Dinner screen as equivalent to the View Product. So when the user goes to the Order Dinner screen, they're indicating an interest in viewing and possibly purchasing the dinner. So, in the OrderDinnerActivity, go ahead and add a method sendViewProductHit. It's going to create the product action, which in this case is ACTION_DETAIL, because we want to indicate that we're viewing the product. Get the tracker, we all know how to do that. And send the hit as an event. The Category is Shopping steps, the Action, I mean these can be the things you like, but I used View Order Dinner screen. The Label is the selected dinner. We add the product, this is critical. And we set the ProductAction, and then we build the hit. Then you'll also need to make sure that you call sendViewProductHit() from the onStart method in OrderDinnerActivity. So I use a Toast also to double-check, but you don't have to if you don't want to. But so here's where I call sendViewProductHit in onStart. And you will need to make sure of course that you add all the imports you need. And that's Product, ProductAction, Tracker, and HitBuilders, and they're all in com.google.android.gms.analytics. Then make sure, of course, that your phone is connected to Android Studio, deploy the app, run the app, and use the app. And make sure you list all the dinners. And you go to the Order Dinner screen and look for the events to come in in the real time section of the Analytics dashboard. And now it's the quiz. So now your app have the code to send hits to Analytics when someone views a product. In this case, a dinner. And we're using the Order Dinner screen as equivalent of the view dinner screen. Let's take a look at the Analytics dashboard. Make sure that the date is set to today, or at least include today. I recommend just setting it to today. So, I'll start out by going to Behavior and looking at the events. So I have some events. Let's look at what they are. So, I have two event categories. You'll probably only have one, I kind of played ahead a little bit so I have my add to cart. Don't worry about that, focus on the shopping steps, so you should have the shopping steps event category and you can drill down. And you see we've got the view order dinner screen action. And then we see all the different event labels. So that's cool, but you already knew how to send event hits, right? So why did we do that extra work of creating a product and a product action? Well, it was so we could get some e-commerce data. Let's take a look at Ecommerce screen in the dashboard. Go down to Conversions, and Ecommerce. Let's look at product performance. So here we see the dinner product showing up. You can drill down into it. This is the product SKU, which is the product ID that you set. We haven't had any purchase transactions yet. So this product hasn't completed any revenue yet. But, hey, that's to be expected. Now let's take a look at the Shopping Analysis. Go to Shopping Analysis and then Shopping Behavior. So here, I see that my app has a total of three sessions, and one of those had a product view activity. Sessions with product views. By attaching the product and product action to the hit that got sent to Analytics, we were able to tell Analytics that users took part in the shopping process. So far, all our users have done is view products, but that's a good start. Gotta view them before I buy them! So go ahead and look at the product performance and the Shopping Behavior Analysis in your app in Analytics dashboard, and then come here and fill in these check boxes right here. So now our users can view dinners as a starting step in the shopping process. The next step is to let them put dinners in the cart. We're going to add a button to the Order Dinner screen to let users put the dinner in the cart. So far, the order dinner activity has used the generic show_info layout but now it needs its own layout file so we can add the buttons to it. We'll still use the show info fragment to show the information about the dinner. So you're going to add a new layout file called order_dinner.xml to the layout folder. This is a scroll view with a linear layout, and it uses the UseInfoBoxFragment to show the information about the selected dinner. And then it has some buttons. The first button is Add to cart, and there's some more buttons in here. And they're commented out for now, and you can add them in as you need them. So you're going to be adding the button to the Order Dinner screen. And first you're going to add order_dinner.xml. And then you're going to need to update order dinner activity to use the new layout. And you do that in the on create method and specify the new layout. So to send a hit to analytics when a user puts a product in the cart, you need to create the product and the product action as before. And set the product action to ACTION_ADD. So you're going to need to define some methods in the Order Dinner Activity class. To add the dinner to the cart and to send the Add to Cart hit. Now for the add dinner to cart, skeleton code only is enough. Since this is a course about analytics, not about implementing shopping carts, we can gloss over the code to actually add the dinner to the cart with a wave of our hand. But since this is a course about analytics, I do expect you to implement the method that sends the add to cart hit to analytics. So a full implementation here please. So a method that's used as the action of a button must take a single argument of a view. So you'll need to define a method, let's call it addDinnerToCart, that takes a view. And then it adds the dinner to the cart and sends it here to analytics. And for now, we don't need to implement the code to actually add the dinner to the cart, but it's nice to get the feedback that something happened. So I always like to Add a toast, so go ahead and show a toast so that when the user clicks a button they see that something happened. You're going to need to make some other changes in the code for the order dinner activity because you won't be able to pass the dinner and the dinner ID, from the method that's activated by clicking the button. And of course, you'll need to make sure that the button action of the Add to Cart button calls the add dinner to cart method. So go ahead and do this coding and then try out your app. So let's look at the code that we added. Let's look at the OrderDinnerActivity. See I added the inputs for the View class. I added variables for the selected Dinner and the DinnerId. I updated onStart() to store the selected dinner and the selected dinner's Id. I wrote a to-do note for myself, to re-factor sendViewProductHit, since it can now get the dinner and dinner Id out of class fields. I leave you to do that if you like, it won't change the functionality. It will just make your code a bit cleaner. Here's the definition for addDinnerToCart. It takes a single argument of the view which is passed automatically when the user clicks a view that activates the method. And I just pop up Toast as a placeholder code for actually putting the dinner in the cart. And then the method calls the sendAddToCartHit to send the hit to Analytics. This new method SendAddToCartHit, is very similar to the sendViewProductHit method we already defined. So we get the dinner and the dinner Id from the relevant global variables. Make sure you fix this code if you copy and paste it from the other method. So here I create the product action, which is ACTION_ADD. And again, if you copy and paste it from the other method, make sure you change this. Then we get the tracker. We use EventBuilder to build the hit. We set the category to Shopping steps. We set the action, we set the label to the selected Dinner, and we build and send the hit. Let's take a quick look at the layout file, order_dinner.xml, to make sure the Add to cart button calls the addDinnerToCart method. So this is the button, and yes it does, addDinnerToCart, excellent. To see the Ecommerce data, go to Conversions > Ecommerce > Overview. So far, nobody's actually bought anything in my app so I have no revenue. Let's look at shopping behavior. Shopping Analysis > Shopping Behavior, okay, that looks a bit more colorful. I had some sessions where some users, who are actually all me at this stage, viewed some products. Then there was another session where a user added the product to the cart. But I still haven't implemented the checkout code, so no checkouts, which is confirmed if I look at the Checkout Behavior page. Nobody started checkout. Let's look at Product Performance. I see the product dinner listed, but it hasn't brought any money in yet. This report includes products that got as far as at least being added to the cart. If I drill down into the product, I see a list of the SKUs, which is the same as product IDs for the products that were involved in the shopping process. If I set the Secondary dimension to Ecommerce > Product Variant, I can see the names of the dinners as well as the dinner ID. And feel free to explore what other Secondary dimensions you can view. So far, we've added a tracking code for when users view products and add them to the cart. The next step is to check checkout actions. You'll be adding a Start Checkout button to the Order Dinner screen. You'll need to add the button in a layout file. And there's no point checking out until you've put a dinner in the cart. So start with the button being invisible. In the Order Dinner Activity, add a method to start the checkout process and to send the checkout hit to Analytics. And for now, we're going to assume that the cart contains only and exactly the currently selected dinner. As before we're going to gloss over the implementation actually doing the checkout with a wave of our hands. And put our attention into implementing the code to send the hit to Analytics. You'll also need to update the addDinnerToCart method to hide the Add to Cart button and show the Start Checkout button. So when the user goes to the order online screen, they add the dinner to the cart, and then they can start checkout. So here in the order_dinner.xml layout file, you should have button, Start checkout. Notice that initially we set the visibility to "invisible," because we don't want the button to show up until after the user presses the Add to cart button. Now looking at the order_dinner_activity java file, we need to import the button, because we are going to be hiding and showing buttons. We added the startCheckout() method. We show a toast instead of actually implementing the checkout process, and then we call the sendStartCheckoutHit method. And then in the sendStartCheckoutHit method, we're going to send a hit to Analytics to report that the user started checkout. And for this we're going to fake the cart and just assume that the currently selected dinner is what's in the cart. So we create the product. We set the ProductAction to ACTION_CHECKOUT. Set the category. I'm setting mine to Shopping steps. We set the action, the label, we build a hit, and we send it. So one other thing we need to do is to update the addDinnerToCart method to show the button for checking out, and to hide the button for adding the dinner to the cart. Try out your updated app if you haven't already. You'll need to wait a while for the data to show up in the Analytics dashboard. But don't forget, you can always check the logs to see if the hits got sent, if your phone or tablet is connected to Android Studio. In the Analytics dashboard, go to Conversions > Ecommerce > Shopping Analysis > Shopping Behavior. And make sure the date range is set as you want it to be. So, now we see that some of the sessions include Check-Out, let's confirm in the Checkout Behavior page. Drum roll please. And we see that we had some sessions with step one of Check-Out. Step one implies maybe there's a step two and actually there can be, and I'm going to talk more about Check-Out steps soon. Also notice there are no transactions, and that's because a transaction involves money changing hands. Or more technically speaking, a transaction requires a product action to be action_purchase, or action_refund. We'll be getting to transactions next. Anything that involves actual money is considered a transaction. So in concrete terms, that means that the purchases and refunds are transactions. For purchases, the action is ACTION_PURCHASE, and you must set the quantity for product. After all, if the user's buying zero products, there's no purchase taking place. You also need to send the transaction ID. Each transaction ID must be unique. And you set the transaction ID calling setTransactionId on the productAction. So go ahead and add a purchase button to your app. You should know the drill by now. Add the purchase button to the layout file. Define the method to purchase the cart. Skeleton code only. And to send the analytics hit. Don't forget, we need the full implementation of the method that sends the purchase hit to Analytics. And this method is going to need to set the unique transaction ID. One way to make unique transaction id is to concatenate the product id with CurrentTime. We'll supply the code to do this if you want to use it. You'll need to add the code to the utility class. Course, you're welcome to invent your own way to generate unique transaction ID. Then you'll need to update the start checkout button so that it hides itself and shows the purchase button. And then run the app and buy some dinners. So let's take a look at the code for sending the purchase hits to Analytics. In order_dinner.xml you add the code for the purchase button. And the onClick is purchaseCart. And the initial visibility is invisible. It's not visible when we first go to this page. So over in the orderDinnerActivity class, we have the method purchaseCart, which gets invoked when somebody clicks the purchase button. And again for now we're glossing right over the actual implementation of the purchase and just popping up a toast, and then we call a method to send the hit to Analytics. So for learning purposes we're going to assume that the currently selected dinner is in the cart. And we're going to buy whatever's in the cart, which means we're going to buy the currently select dinner. So we create the product as before, set the variant to be the currently selected dinner. And of course in actual production code you wouldn't do this, what you would do is you'd iterate over the items in the cart and create a product object for each one. Then we create a unique transaction ID. And you need to have one transaction ID for each purchase transaction or each refund transaction. So it really does need to be unique to the actual transaction. Recreate the product action. We set the action to ACTION_PURCHASE and then also we set the transaction ID. And then we send the hit, remembering to change the action to be Purchase. We set product to product, and we set the product action to productAction. And then in the utility class, I just added some code to create a unique transaction based upon the current time and the product id. And if you came up with your own different way of creating a unique transaction, that's perfectly fine. Let's take a look at what the Analytics Dashboard reveals about the path that users take to buy products. You go to the Shopping Behavior page and you should now see some sessions with transactions. Now let's look at the checkout behavior. So this screen shows the sessions where users got as far as the checkout step. So we had seven sessions where they started checkout and two sessions that ended in a transaction. We'll look more into how you can track users' progress through the checkout process in a minute. Now let's look at the Product Performance Screen. Earlier, you saw that this screen shows all the products that have been included in analytics hits. But up until now, there was zero revenue associated with any of them. But you expect that to change now that some actual sales have occurred. Oh and it has $15.00 for dinner. So here we see the revenue for the products that were included in the purchase actions. You can drill down into the products to get more details. So we see that these three dinners here got bought. There's money associated with them. And these other dinners did not get bought. So again you can set a secondary dimension, if you want to see the labels for the products: Ecommerce > Product Variant. And now I can see which dinners were the ones that got bought. So the product SKU, also pronounced skew, is the ID for the product. SKU is a stock keeping unit. It's something that retailers use to uniquely identify each product they sell. So here it's called product SKU, but here in the code, we talk about the product ID, but actually it's just the ID. The method that sets it is setId. You can drill down into the Products. I didn't set any coupon code or affiliations. But you can see that this is where they would show up if you'd set them. You can also see other kinds of information, such as the quantity that got added to the cart, and the quantity that got removed from the cart. And, of course, for a remove cart hit to be registered, you'd actually have to write the code to send that hit in the method that implemented the remove from cart action. Another thing you can look at is the Sales Performance Report. You go to Conversions, e-commerce, Sales Performance. In this report, groups results by transaction. You can drill down into a transaction to see what the products included in the transaction. Here I've only got one product per transaction, because our app assumes that the current dinner is the only product in the cart. But here's an example from a different app with more transactions, so drill down into this transaction ID. And you see that the customer bought several things in a single purchase transaction. And the revenue for the transaction is the sum of the prices for the products included in the transaction. In this transaction, the customer bought several different shirts. So the total revenue is the sum of the cost of all of the shirts. That's a lot of shirts for one person. I hope they all fit. So far in our app, when the user hits the purchase button, they buy the currently selected dinner. And they pretty much have no choice about that. But usually customers like to buy things by the cartload, rather than selecting and paying for items one by one. So to tell analytics that the user bought multiple products in a single transaction, you just add whatever products you need to the hit to be sent to analytics. Create a product object for each product in the cart, set the name, set all the other details and so on. Then you create the product action, you set the action to ACTION_PURCHASE. Set the TransactionId and then you can optionally set a ProductActionList, if you want to group all the products into a list. You don't have to do that though. And then you get the tracker, as before. And you add each of the products to the tracker and then you build and send the hit. And this is pretty much the code that you've already learned how to write. The only difference, really, is that you can add multiple products. Now I know some people say it's not polite to talk about money in public, but I really do want to bring up a couple of matters to do with money. Every product has its own price. This shirt costs 10. And when you send an action purchase hit to analytics, the total price of the transaction is automatically calculated from the price and the quantity of the products in the transaction. That's cool, right? Kind of what you'd expect, sure is. But if you take a look at the API reference for product action, you'll see there are methods for setting the revenue, the tax and the shipping. If the tax and the shipping are relevant, you'll need to write the code to add them to the transaction. Remember I said that you can set the name of the list that's associated with a given set of products? If applicable, by setting the ProductActionList on the ProductAction. The list name shows up on the product list performance page. And in this case there is two product lists, one without a name, and the other one is all the things. And then if you drill down into all the things, you see the products that were in the product list, and you can find out what they contributed to the product revenue for the list. I don't have a coding exercise for you related to calculating taxes or setting product lists, but feel free to explore on your own. Up next though, you do have a quiz. All the different pages in the Analytics Dashboard can get a bit confusing, so let's do a quick quiz to check that you're understanding where to go to get what kind of information. Where do you go in the Analytics Dashboard to see the number of sessions where the user got as far as viewing a product? And there might be multiple pages that you can go to for this information. Where do you go to get the number of sessions where the user got as far starting the check out process? And where do you go to see which products were purchased? Okay, so let's look at the solution. So to see the number of sessions where the user got as far as viewing the product, you go to the Shopping Behavior Analysis page. So the Shopping Behavior Analysis page shows us all the sessions and here you see the sessions with product views. To see the number of sessions where the user got as far as starting the checkout process, you go to the Shopping Behavior Analysis page and you can also go to Checkout Behavior Analysis. So here in the Shopping Behavior Analysis we can also see the sessions with checkout. Additionally, we can actually go, the Checkout Behavior has it's own page. Go to Checkout Behavior and we see the number of sessions. Let's start at the checkout. And in this case, completed it. To see the products that were purchased, you go to the Product Performance page. Now, if you go to the Shopping Behavior Analysis or the Checkout Behavior Analysis, we see the number of sessions that had a transaction. But you don't actually see the products that were purchased. So here in the products performance page, you see the products and you can drill down into more detail on the products. If your app lets people buy things, it must also let them ask for a refund. Your app has to have the code for processing refunds. Sending a refund hit to analytics does not execute the refund. It simply reports it. You can read about sending refund hits in the developer guide. You can report either a partial or a full refund. When you send the hit for a refund, you must provide a transaction ID. See here it says in the Developer Guide, the matching transaction is not found, the refund will not be processed. Your app must keep track of the transaction IDs for itself. Analytics isn't going to do that for you. So it's important to note that Analytics has a six month limit for refunds. So that doesn't mean that your app can't issue refunds after six months, but refund hits to analytics won't take affect after six months of the original transaction. If you're up for the challenge, go ahead and add a refund button to your app. I leave it to you to do. Hopefully, your analytics dashboard is now showing some activity in the shopping behavior and checkout behavior dashboards. But so far, the checkout process has been very simple. The steps are, view product, add to cart, start checkout and purchase. But there are some steps missing. Where do we send the tasty dinner? And what are the payment details? The checkout process itself is a multi step process. You have to get the shipping address, get payment address, get payment details, confirm the details, review order, and then finally, do the purchase. So here's an example of a checkout process with a bunch of steps. Start the checkout. Get the customer info. Get the billing info. Let the customer review the cart. Confirm the checkout. And there would be one more step which is to complete the purchase. There are two things you have to do to display the checkout steps in analytics. You have to update your code to include the step number when your app sends a check out hit. And then the admin console, you can add funnel sections for the checkout process. This part's actually optional but if you don't name the check out steps then they appear as step one, step two, step three and so on which is not very helpful. So here's an example where we have step one, step two, step three, step four and we don't know what's going on at each of these steps. It's really very easy to add nice labels for these steps. So here's how to set a heading for the steps. You go to the admin console, choose Ecommerce settings down here for the view, and then just add some funnel steps. So you add the steps that you'll be tracking, and give them relevant names. And don't forget to press submit when you're done. Sometimes the submit button scrolls off the bottom of the screen and it's easy to forget it. Then, take a look at the Checkout report. So go to Reporting > Ecommerce Shopping Analysis. And checkout behavior and then you'll see the steps with the new labels. It's your turn now to add the checkout step to analytics account. Go to Ecommerce. And set up the funnel steps, right here. Then go back to the reporting tab to see the steps in the checkout behavior analysis screen. Check the boxes here when you've added the checkout steps. We'll be adding the code next. As your user progresses through the steps in the checkout process, your app needs to send an analytics hit for each step. However, you only need one checkout hit. So subsequent steps in the checkout process, send checkout option hits. So that you don't over report the number of checkouts. And use the setCheckoutStep method to set the step number. And you can set the number to whatever you want, but it only shows up in the checkout behavior analysis report in the google analytics dashboard if you set a funnel step for it. If i set the step in the code to 99, but I've only labeled 4 checkouts steps in the admin console, I will never see the 99th step in the dashboard, so that's just not a good idea. That's better. So go ahead and add a second step to the checkout process for the dinner app. For that you're going to need a payment button. So add another button to the order dinner screen labelled payment. And in the order dinner activity, add the method to get the payment info. Then send a step two hit to analytics. Make sure to set the action to an ACTION_CHECKOUT_OPTION. Show the payment button only when relevant and hide the other buttons when the payment button appears. Test your app and try it out. And in the analytics dashboard, look for the realtime activity. And in the realtime activity, check for the events. See, here's the Get payment step. It might take a good amount of time after you see the realtime hits for the checkout behavior analysis page to update. But when it does, you should see your new payment step. Oh, something went wrong. I got a hit for getting the address, but not forgetting the payment details. That's not what I wanted. Okay that happened because step one is starting checkout and step two is getting the address. Step three is getting the payment details. That's easy to fix for now. Go to Admin > Ecommerce, and I'm just going to remove the Get address final step. Yep, I'll delete this rule. And submit, and go back to Reporting, and look at that. The get address step is gone, and I've got my payment details. And I know that that is correct, in this case. An alternative would be to change the step number to three in the code. But then we would be skipping over step two. So we would have values here, nothing here, values here. So when you set your check out step in the code, you need to make sure that it mapped the correct final step in the analytic dashboard. So make sure step two is in fact the payment step, and if not, fix it. So go ahead and do these steps and check the boxes when you're done. Okay, let's take a look at the code. So, in order_dinner.xml, which is the layout file for the order dinner screen, I've added the button for the payment. So, text=Payment, given it it's unique ID and the onClick is getPaymentInfo. And it starts out being invisible. Up here, in order dinner activity, I've defined getPaymentInfo which glosses right over getting the payment and just shows us a toast. But then I call a method to send hit to Analytics and here's the code to show and hide the buttons appropriately. And then here's sendPaymentInfoHit. This is all very familiar. We create the product etc. Now down here in the productAction, the action is ACTION_CHECKOUT_OPTION and I've set the CheckoutStep to 2. Get the tracker. And when I create the EventBuilder, categorize shopping steps as before, change the action to Get payment, add the product, set the productAction and build the hit. [SOUND] Learning about all those e-commerce steps was a bit complicated. Now let's do something a little easier. Let's time something that happens in the app. You can send hits to Analytics to record timing information. To be clear, Analytics won't do the timing for you. You need to write the timing code yourself. Once you've recorded the timing, you can set that in hit to Analytics. The easiest way to time things is to record the timestamp before and the timestamp after the things you want to time. And you can use System.nanoTime to record elapsed time between the start and the stop time in nanoseconds. So to send a timing hit to Analytics, use TimingBuilder to build the hit and set the value to be the time that you recorded. The other parameters are the same as for the events that you've already sent hits for. There's the category, the value, the label, the variable. It's important to put the time value as the value. Now you may find that the developer documentation says that some of the parameters are optional. But I found that the hits didn't show up unless I supplied all the parameters. To see the timed values in the Google Analytics Dashboard, you go to Behavior > App Speed. And here you see I had some sessions with timing hits. And I timed how long it took to list all the dinners, and it was really fast. Now it's your turn to add timing hits to your app. Go ahead and add the code to time how long it takes to display the list of dinners and then enter that value here. And we want the value as reported from Google Analytics. No fair popping up a toast to get the data. So let's take a quick look at the code, I put my code in the ShowAllDinnersActivity and the first thing you're going to need to do is import these couple things. Tracker and the HitBuilders. And then I put my timing code in the OnCreate method. because that's where we display the list. I put my startTime down here, actually after I set the ContentView. You may have put it above, it doesn't matter. So I start recording the time here, I get all the dinners, I create the ArrayAdapter, I set the Adapter, and then down here I record the stop time. So now we've got the start and the stop time, we need to calculate the elapsed time. And I've converted from nanoseconds to milliseconds and then I have defined a new function to report the timing hit. So I have my method, send AnalyticsTimingHit, got the tracker. I use TimingBuilder to build the hit. I set the category to list all the dinners. I passed in the elapsed time, which is t and here I set the value to the elapsed time. Set the labels, set the variable and I build the tracker and that sends a hit. And that's all there is to it. You can use Google Analytics to answer questions like how do users download my app? So over here in the dashboard you see the Acquisition menu, expand it, New Users. We see the new users for the time period, and we can scroll down to see their locations. How the App Marketplace shows where users downloaded your app. And you can get a day-by-day breakdown. So com.androidvending is the Play Store, so here we see that most of the downloads came from the Play Store. And then you can scroll down this page to get the accumulated data. So the Sources reports provide different but similar views of the same data, showing where users got your app. So the All shows all the places they got the app. Google Play shows the sessions where the users downloaded the app from Google Play. And iTunes will show a similar thing for iTunes. We can look at the Google Play Referral report to see workflow representation of where people came from to get to the Play store to install the app. So, Google organic. We see here we had 111 Play Store Views, which resulted in 60 installs. So to be able to get reports like this, you need to do a couple of things. So the app must be in Google Play, or also, on iTunes, you can track conversion tracking from iTunes. You need to link your Google Analytics account to Google Play. So, to link your Analytics account to Google Play, go to the Google Play page in the dashboard. And you see this information telling you that report requires that you link your app to the Google Play. And you can just go ahead right from here and click Set up app linking. Enter all the data. And right here, Get Google Play Developer Console Data. And if you're doing iOS Campaign Tracking you would also enable that one there. And you save that. And now your Google Analytics account is linked to Google Play for this account ID. The steps for linking to iTunes are outlined in the dashboard, too. So you can go through those steps here if applicable to your app. And don't forget to add the code to your app to send the download hits. Oops, my bad. No code needed for Android Apps and that's all there is to it. Now you'll be able to use Google Analytics to track how people download your app from the Play Store. This course doesn't cover deploying apps to Google Play, so I'll leave you to investigate this aspect of Analytics on your own. You can track exceptions and crashes in Google Analytics. So in the dashboard, you would go to Behavior > Crashes and Exceptions. And the exceptions are grouped by the app version number. You could drill down with the different version numbers. And see, I had a NoSuchMethodException and a NumberFormatException. So you can track caught exceptions and uncaught exceptions. So to track exceptions that get caught, you need to send an exception hit. And you use ExceptionBuilder to build a hit, and you set the description and you setFatal, whether or not it's fatal, and that's boolean. And then you build the hit and send it. And for uncaught exceptions, you can't add code, obviously, because you don't know where in the code the exceptions occur. However, you can enable automatic tracking for uncaught exceptions. And to do this you set ga_reportUncaughtExceptions to true in the tracker config file. I just want to mention that there have been some issues about sending hits for uncaught exceptions. The issue tracker links in the instructor notes below and I leave it to you to setup tracking for exceptions if you want. We covered a lot in this lesson. Now you know how to send specific hits to Google Analytics for screen views, events, steps in the shopping process, and timing data. I also talked about tracking exceptions and crashes, as well as tracking how users download your app. But what if you want to send completely different kinds of data that the amazing engineers at Google Analytics hadn't thought of when they created the dashboard and API? Well, they're ahead of you. They knew they couldn't anticipate every possible use case, so they added the ability for you to add your own custom metadata when you send hits to Analytics. You'll need to configure custom metrics, or dimensions, in the Analytics admin dashboard and then attach the custom data when sending the hit in your code. I'll leave you to read about that in the developer documentation when you are ready to try it out. But, now, let's go learn about Tag Manager. So far, we've seen how you can use tag manager to dynamically update things like UI strings and configuration parameters in your app, without having to redeploy the app. Another compelling use of tag manager is to manage your tags. A tag is a piece of code that sends information to third parties for things like analytics, remarketing, affiliate programs, attribution, e-commerce tracking and more. The codes that sends the data to Google Analytics is fed throughout your app. It can be hard to keep track of which hits your app is sending. Using Tag Manager you can well, manage your tags. See what your app is tracking. And see what your app isn't tracking. The specific example of tag manager that we're going to explore in the rest of this lesson is how to manage the tags for Google analytics Let's take a look at the kind of tags that can be handled in Tag Manager. Click on Tags > New. You can use Tag Manager to send events from your app to Google Analytics, to Google AdWords, and to doubleclick. You can also have events by Function Calls and Custom Image Tags. And we're going to be focusing on sending events to Google Analytics. When you want to send data from your app to Analytics, you can send your tracking data to Tag Manager instead of directly to Analytics. Tag Manager will forward the tracking data to Analytics. The end result will be the same as if we'd send it direct to Analytics. The tracking data shows up in Analytics. But now, if you want to make changes to the way the data appears in the Analytics dashboard, you can implement these changes through the Tag Manager dashboard instead of having to code the changes in the app. While you're testing your app on your device, right there connected to your computer, it seems simple enough to compile the changes, and re-deploy. But once your app's in production, and available on the Play store, it's easier to change the description of the data that's collected, using the Tag Manager UI. Now that we've got the daily special working in our app, we can use Google Analytics to to see how people use it. For the Show Daily sSpecial activity, we'll send our tracking data to Tag Manager. And then Tag Manager will forward it to Google Analytics. You already saw that you can put data into the dataLayer using the push method, specifying the key and the value. When we used it, the push values into the dataLayer, keyed by food pref. In this case vegan is a value, food pref is the key. Put an event in the dataLayer is very similar. You can call dataLayer.push, specifying event as the key. And then you'll need to pass a bunch of other stuff to pass the parameters for the event. In this case the key absolutely must be exactly "event," however, it's easier to use the pushEvent method instead. This method makes it easier to pass parameters for the event. You need to pass the eventName, and you pass extra data using the mapOf method, specifying key value pairs. Now, each of these keys corresponds to a dataLayer variable in Tag Manager. Let's see what this means in practical terms. In the code for our app, in the main activity, in the method that gets called to show the daily special, we can add the code to put in an event in the dataLayer. Get the dataLayer and push an event onto it. In this case, we're pushing the event open screen and we're setting Show Daily Special as the value of the screen name key, and this means that the screen-name dataLayer variable will get the value, Show Daily Special. So, go ahead and add the code to your app to push an event into the dataLayer when the user clicks the Show Daily Special button. In Main Activity you're going to update the method startShowDailySpecialActivity to push the openScreen event into the dataLayer, and you need to set the value of the screen-name kry. You'll create the new screen-name dataLayer variable in tag manager in the next section. So, here's the code to push the event into the DataLayer. We get the DataLayer, and we push the Event, passing the value, Show Daily Special, to the screen-name key. That's it, really. So now we've added to code to push the event into the data layer, what next? In the tag manager dashboard you can define tags that send those events on to Analytics. So far you've created variables and triggers and now you're going to create tags. So just like data collection variables tags are fired by triggers. For the value collection variable, the trigger determines which value to use for keys in the variable. For tags the trigger initiates data forwarding, according to the rules setup in the tag. Before we create the tags, though, there's data layer variable that we need to create. We've already used it in our code. What is it? Go ahead and create the variable, enter the value here, and check this box when you're done. And if you're not sure what it is, look in the code. We need to define the screen-name variable, because we use it in the code. So, this is the code where we mapped the name of the screen to the screen-name. I used a hyphen, and it doesn't matter if you use a hyphen or an underscore. The key thing is that the key in the code is exactly the same as you configure the data layer variable name to.           .       .     .         .     .         openScreen     .      openScreen     openScreen.   mapOf   DataLayer      .    .      openScreen.             .   .        .              Show Daily Special.     .         .                .      [INAUDIBLE]         .  . .                .   Send Daily Special Screen.     .      Analytics.        analytics.       Admin  Google analytics   Tracking Code        Android Studio        ga_trackingId.      .            .         .               .                   .   .    .            .    My Tracking ID.         .           .        .      App View   .     App View .   App View     analytics.        .     More settings > Fields to Set > Add Field.            .   screenName.        screenName .    App   .         screenName.     .       .   Custom     .              .           Show Daily Special.    .    .       .    .         .      .        analytics           .                      analytics.          analytics      .           .     Android studio       .         .             cd   .     Show Daily Special.           .         .                           analytics.        Show Daily Special.                            . Okay, let's have a quick look at the triggers and the tags that you created. So the triggers, the new triggers are openScreen, which fires when the event equals openScreen and Daily Special Screen, which fires when the screen name equals Show Daily Special. So those were the triggers and then the tag that you created. We'll see, was a tag to send the Daily Special Screen Hit to Analytics. You created a variable for the Analytics account ID. The track type must be App View, App View. And you must set the screenName field, must be spelled exactly this way, to the value of the screen name that gets set in the code, which in our case is Show Daily Special. We only want it to fire when screen name equals, Show Daily Special, and when the event was open screen. In the process of doing that you have created the variable My Tracking ID, which is a constant who's value is your analytics account id. And if you did all that, you should see your hits coming into analytics when you run your app. So far, we've seen how to send data from Tag Manager to Analytics, so it shows up as a screen view. But what if you want to track specific events? In that case, create a tag, and set the tracking type to Event. Each of these fields corresponds to a parameter you can set in your code, when you send an event hit directly to Analytics. Here's an example of code from our app, where we sent an event hit to Analytics. You see that the code sets the Category, Action, Label. Now, the Value must be an int, and we didn't set a value in this case. So go ahead and add the code, to send an event, every time anyone clicks the Show Daily Special button. Previously, we just sent a screen view hit. This time, send an event hit and set the label to food preference. So you don't need to create new triggers or change your code. And then, as always, don't forget to publish your changes. Start and stop your app and try it out. If your phone's connected to Android Studio, you can look in the logs to see if the hits get sent. And for event hits, you should see the parameters ec and in our case, in my case, I set it to button clicks, but this is a category. A-n is the application name, language. And in this case, t, which is the hit type, is event. E-a is the action, I set mine to Show Daily Special. And el is the label, so when this got sent, the food preference was fish. And check for activity in the real time screen. So let's take a look at the new tag that you created to send an event hit. Click New to create the tag, you know that by now. I call mine Send Daily Special EVENT Hit, so I can tell it distinctly from the Screen View Hit. Configure the tag to get the Tracking ID for the analytics account, which is from the variable we configured earlier. Track type is event. I called my category, Button clicks. It doesn't matter what you called your category. I called my action, Show Daily Special. You can call it what you like. And then this one, the label, food pref, notice how we use the variable. Actually, the way you get the variable, you just click the button, and you go down to food prefs. It's in here somewhere. Go up to food pref and you insert it. And because it's a data layer variable it's available to us in that fashion. No value. If you do specify a value make sure it's an int. If you set the value and it's not an int, the hit will not show up in Analytics. And then the firing, it's actually going to fire the same as the Screen View hit did. I want it to fire when the event equals openScreen and when the screen name equals Show Daily Special. And save the tag. So far we added code to put one event into the data layer, just used by one trigger, and to trigger two hits to analytics as a result. And we did this because I wanted you to see that a trigger can be used to trigger more than one thing, but stop and think about whether it really makes sense to track the opening of an activity in multiple ways like this. On the one hand, we track the button clicks for the Show Daily Special button. But on the other hand, we track the Show Daily Special screen views. Really, we should only send one hit, when the user clicks the Show Daily Special button. Which tag do you think is the right one to use in this case? Go ahead and discuss in the forum. If you're up to the challenge, go ahead and add the code to your app to send another event to analytics using TagManager. In the ShowDinnerActivity, in the removeMeal() method, change the code that sends the event tracking data and update it to use TagManager. So here's the removeMeal method. It sends an intent to start the RemoveMealActivity, and currently it sends a hit to Analytics to report the event. So, you're going to comment all this out and instead add the code to send the data to TagManager. Notice in this case the label is not the food preference, because we don't actually have the food preference here. Instead we're sending the selected dinner, so you're going to need to correct a variable in TagManager for the selected dinner. After you've updated the code you'll need to go to TagManager and do what you need to do to send the data on to Analytics. You may find you need to create a new data layer variable, a new trigger, and I'm pretty sure you're going to need a new tag. This time, you will need to deploy your code to the app, because you've made changes to the code. Don't forget to publish in TagManager. Start and stop your app. And then look for the hits in the TagManager real time dashboard. Try out your app and look for the results in the real time screen. Okay, let's take a look at the code. I'm looking at the removeMeal method in the ShowDinner activity. I didn't make any changes to the way we start the activity. So here's the code to send the hit to tagManager, repeat. So here's the code to send the hit data to tagManager. You get the tagManager. We get the DataLayer and then we push the event. So we push the openScreen event. It's okay if you used a different name for your event, as long as you set up the appropriate trigger. And then we need to set the screen name, Dislike Dinner. You may have set something different. Then I use the key selected-dinner. Then I used the key selected-dinner to record the dinner. And again it's ok if you used a different key name here, so long as you set up the appropriate data collection variable and tag manager. You absolutely want to make sure you've commented out the analytics code, because you do not want to send this twice to analytics. Otherwise, you'll get over-reporting. Oh, and of course, one more thing you'll need is, make sure you have the right imports for the Data Layer and Tag Manager classes. Now let's take a look at what we needed to do in Tag Manager. I created a new data layer, current special, to hold the current special and again, this is a value that we set in the code. This is the value of the key, that we set in the code. And I created one new trigger, dislike dinner trigger. I set it to fire when the screen name equals Dislike Dinner, which is the screen name that I set in my code. So, we had one new variable, one new trigger, and one new tag. I called mine Send Dislike Dinner EVENT hit. You can call yours what you like. Its an analytics tag and in the tag I provided my tracking ID as a variable, the track type is event. I called my dinner actions and I just copied exactly what I had previously in the code, when we sent the data to analytics. I set the action to be Dislike dinner. For the label, I chose the selected dinner variable, which gets set in the code. And I set it to fire on the dislike dinner trigger, so when the screen name equals Dislike Dinner and on the openScreen trigger when the event equals openScreen. And you may have done yours differently, it doesn't really matter how you did it so long as you do see the hit going to analytics. So, then I started and stopped. We'll do that again. So then I started and stopped my app. This time go to the What's for Dinner button. I prefer vegetarian today. Oh that sounds disgusting. Okay, pick a few more things. Let's see what's for dinner. I prefer fish, yuck, it came up with that. And here we have some hits showing up in our real time report and we see the, actually let's go to events. Now we have the button click from before. Now we have our Dislike dinner actions. Hopefully you got your new tag manager tag to work. This exercise gave you practice at figuring out what variables, triggers, and tags you needed. We've covered how to send screen view hits and event hits from Tag Manager to Google Analytics. But as you learned previously, there are other kinds of hits that you can send. These include e-commerce, timing, and exception hits. Now that you understand how to use variables, triggers, and tags, you should be able to apply those same principles to sending other kinds of tracking hits. You can find resources to help in the instructor notes. You can also register functions that get invoked by Tag Manager triggers. Take a look at the documentation to learn more about that. This brings us to the end of the lessons about Google Analytics and Tag Manager. Hopefully now you know how to add the code to your app to send tracking data, whether you send it directly to Google Analytics, or send it via Tag Manager. I've barely scratched the surface in terms of the data insights you can get from Google Analytics. There's so much more to say about how to slice and dice the data, get custom segments, send reports, and get custom views. Our friends over at Google Analytics Academy have more courses you can take focused on to use your Analytics data to understand and improve the way your app is used. And that's what tracking your app's usage data is all about. You're probably familiar with many of the services that are offered by Google. And if you develop applications your users likely are too. Perhaps they need to find a location or see what's interesting nearby. They're using Google Maps. Maybe you want to monetize your apps so that app usage is rewarded and your users, they don't have to pay upfront. Google Ads is your friend. As well as these, we've got lots of great APIs for you, storing files in the cloud with Google Drive, accessing Goggle Analytics. Signing into your application, integrating with Google Fit and much, much more. In this course, you'll learn how to use these services in your apps. You'll see how easily you have the power of Google at your fingertips, allowing you to build better apps. Before you can get started, let's take a look at getting the tools that you need. You'll be building your apps using Android Studio, which is available at no cost to you and can be downloaded from developer.android.com. If you want some help in setting it up, check out the Android Fundamentals course at the url below. To build applications that use Google Play services, you need a development environment. And to install the development environment there's two main things that you'd need. First, is Android studio. You can download Android studio from the developer.google.com site. When you install Android studio, you get the ability to use the Android SDK Manager, that you can see here. And using the Android SDK Manager, you should install the Google Play Services SDK. You'll see it as an item on the list, under extras, near the bottom of the screen. Make sure that you install the most recent version of this. I would also recommend that you take a look at the Android Fundamentals courses offered by Udacity. There are two of them at the moment, and I strongly recommend that you at least take the first. And it's really not a bad idea to take the second as well. These will give you a head start in Android development and teach you many of the concepts that we'll be covering in this course. Here you can see that I'm running a very simple app that I've called LocationLesson1. You build this application using Location Services and the techniques that you'll use for building this application can be used across many of the different services that you'll learn in this course. So, how did we get here and how did we build this? Let's take a quick look. So, to build an app like this one for location services and many of the other services that you'll be encountering in this course, you're going to do the following steps. First of all, the easiest way to get started is to create a new app using a Blank Activity in Android Studio. Once you've done this, you'll edit the build.gradle to add the services libraries. You'll using something like this, but the version number may change. Then, you'll edit AndroidManifest.xml, to tell your application that you're using these services libraries, and the particular version that you're using. When you put this value, integer Google Play services version. When you do a gradle sync, the correct version number will be put in for you. So it's good just to use this string. And then finally, in AndroidManifest.xml you're probably going to be adding a bunch of permissions as well. In this case I was doing location so you see I set users permission for access_fine_location. Depending on the activity or depending on the type of application that you're building, you'll be putting different permissions in here. When building an app that uses the Google services, you'll generally use an Asynchronous Programing Model that looks a little bit like this. In the onCreate of your activity, you create a Google API client. And then in the onStart of your activity, you connect that Google API client to the relevant APIs. In this case Location Services. In order to use this, you're going to need to override a number of different methods. One is OnConnectionFailed, which the services will call whenever the connection drops and you need to handle what to do. Generally just reconnecting. One is OnConnectionSuspended, which is very similar to OnConnectionFailed and will be called if the connection gets suspended but not necessarily broken. And you might want to cache some information. When you succeed in making a connection to Location Services, Location services calls back to OnConnected, telling you that you're now connected to the services. And in the case of something like location, you'll then create a LocationRequest. They had passed to Location Services to get your location details back. And it would call you back with OnLocationChanged, letting you know that your location request details have changed, and there's new location information available to you. And you'll get a Location object, which you can then use to write to your screen. So in the application that we just saw, that location object included a latitude, and I was able to update my screen and write the latitude to it. Now this programming model isn't just limited to location services. As I've said, many of the services that you'll be using during this course follow a very similar programming model to this. You're going to have an OnCreate and an OnStart. You're going to have a GoogleApiClient that you connect to the services that you want to use. And then you have to handle certain overrides. Usually, they'll be OnConnectionFailed, OnConnectionSuspended, OnConnected, and then an override that's specific to the services that you're using. In this case, it's OnLocationChanged for location services. Don't worry if you don't know all of these by now. Take the best guess that you can and by the time you finish this course, this will hopefully be second nature to you. So first of all, you'll create a blank that uses your desired API. What do you think that would be? Secondly, you extend your activity with the blank call backs. Which call backs do you think they would be? Third, you also extend your activity with the blank listener in case the connection fails. And then, finally, after connecting the blank, you'll wait for the blank callback. What do you think these will be I'll give you a clue. The answer in one and the beginning of four are the same. And which callback do you think you'll be waiting for when you connect to the services? Once you've done all of this, you'd then follow the requirements of your specific API. Fill out the blanks and then continue. So the correct answers are here. First of all, you'll create a Google API client that uses your desired API. In the example I showed earlier, I was using the location services API with a Google API client. With others, you may be doing login, you may be doing maps, you may be doing other things, but you'll still be using a GoogleApiClient for that. You'll next extend your activity with the ConnectionCallbacks. These are the heart of the asynchronous programming model, where the services can call you back whenever something important happens. You'll also need to extend your activity with the OnConnectionFailedListener. In case the connection fails, so that you can handle it gracefully. And then, finally, after connecting the GoogleApiClient that you created earlier on, you wait for the onConnected callback. Once you get the onConnected callback, you know that your ApiClient is connected to the services. And you're able to make the calls on those services. And then once you've done that, you can follow the requirements of your specific API. Like for example, as you saw earlier on, I was doing location work, so I also had an on location changed method, that was firing whenever the location changed, as a result of the location request. You'll see all of this in much more detail in the location services module, as well as all of the other modules. This sequence will be used in every app that you build and you'll want to be sure that you know it as you move through the rest of the class. Since this sequence is so important, take some time to think of a good way to remember these steps and then maybe go post in the forum about it. Also take some time to read what other people have said. You might find a methodology that works for you. Some APIs will also require you to set up credentials and access using the Google Developers Console. For example, in the maps course, you'll need to enable your map to use the maps API. And if you look here on the left, there's APIs & auth. When I select that, and I select APIs, and then I select enabled APIs, you can see the APIs that I've enabled. And one of the map apps that I build, I'm using here the Google Maps Android API version 2. You'll also need credentials for some of your apps. So for sign in maps, and some of the others, the system needs to know which apps are using which resources, and as a result credentials need to be enabled. And here you can see I've selected credentials. And here you can see I've generated an API key for the apps that I've built that are using Maps. As you need them, you'll be stepped through everything that you need to do on the Google Developer's Console in the lessons, but it's good to have a look at it. Go to console.developers.google.com and have a play around. You've now gotten everything you need to get started with building Android apps that use Google Services. The API's that you've installed, give you access to all of this functionality. And they give it to you in a consistent way. Remember that Google API client that you saw for accessing your location? It's the same object, and very similar code to what you'd use to access Google+ or Maps or Wallet or Drive. You can learn these in any order you like. But the most important thing is to get started and to get coding. So, you'll see just how easily you can harness all this goodness. You should go and take the location module first, because many of the concepts you'll need for the others are covered there. Let's go. Now I'm going to talk about Tag Manager. I'll be covering two main uses of Tag Manager. First, I'll talk about how to use it to send dynamic configuration data to your app. For example, if your app's a game, you could offer different challenges for different levels, depending on the attack strength the player has left. If you ran a shopping app, you could use Tag Manager to change the daily discount offer. The second use of Tag Manager relates to organizing and managing tags. A tag is a fragment of code that performs some kind of tracking function. In the previous lesson, you added tags to your app to send tracking data to Google Analytics. Instead of sending data directly to Google Analytics, you could send it to Tag Manager, which can then send it on to Google Analytics. It's easy to change the way the data is reported to Google Analytics using the Tag Manager dashboard, without having to change your code. And Tag Manager helps you visualize and organize your tags. You'll learn how to create tags to forward hit data from your app to Google Analytics in the next lesson. In this lesson, you'll learn how to use Tag Manager to dynamically update values in your app. Your next task is to update the sample app to let users see the daily special. But of course, you'll need daily specials to suit all kinds of food preferences. Vegetarian, vegan, fish only and more. And you want diners of all nationalities to be able to read the daily special in their own language. How do you code your app to offer the right daily special and the right language for each person? According to their food preferences. Really? You want me to code like that? No, you don't have to write conditional code for every possibility. You can't, anyway because who knows what your chef is going to dream up for the daily special next month. Let alone tomorrow. The good news is that using TagManager you only have to write the code once, in a straightforward way and then you can use TagManager to set the special each day. You can update the value in the dashboard whenever your chef invents a new, creative concoction to offer to unsuspecting diners. You won't need to update your app code just because the chef switches to a gingerbread garnish instead of a honeycomb sauce. In this section, you'll add the files to your app to include functionality to display the daily special. And it'll update daily of course, being a daily special. These all sound so tasty. And you'll learn how to use container from Tag Manager to update the daily special. To get ready though, you need to add the daily special activity to your app. You'll add the Show Daily Special button to the main activity. Then you'll need to add the button in the main layout. And then you'll need to add the on click code in Main Activity, so that when the user presses the button, they see the daily special. So you'll need to add the Java class for ShowDailySpecialActivity. It's very similar to the other classes such as ShowRecipeActivity. It shows the info box, and also we're going to have it include an Order Online button. And you can hardwire the value of the daily special for now. Don't forget to update the Android manifest. I always forget that, and then I get an error. You'll need to add the layout file for the Show Daily Special activity screen. It's much like the other screens, such as, show recipe or show dinner suggestion. And in this case we just have this one button, Order Online. And of course, don't forget to run the app and try it out. I encourage you to write the code and create the config files yourself. But if you're not in the mood for it, we've provided predefined versions of ShowDailySpecialActivity and the new layout files that you're going to need to add to your code. So go ahead and do these steps, and check the boxes when you're done. Okay, let's take a look at the code. Over here, in activity_main.xml is the code for the new button. It's very similar to the other buttons, and the onClick is showDailySpecial. And see here. Just the third button. It just shows up as another button on the main screen. And here's the code in main activity that gets invoked when the user clicks show daily special button. Very simple, takes a view, because it's a button on click and it sends an intent to start the show daily special activity. Let's take a look at the Show Daily Special Activity itself. So here I hard wired the daily special. You can make that be whatever you want. This is the same code for putting information into the info box. This is for the other screens like show recipe. We get the TextView. We set the heading. And we put information into the info box in this case the DailySpecial. And then down here, the order online, this is just the method that gets invoked by the order online button, as before. We just send an intent to start the OrderDinnerActivity. Passing the dinner, in this case, the daily special. Now moving onto the layout file for show daily special. It's a scroll view with a linear layout. It uses the info box fragment to display the daily special. And it has a button for ordering online, and that's it. Let's get started using Tag Manager. The place to go is tagmanager.google.com. If you already have a Tag Manger account, you'll see a list of your accounts. But if you don't, you'll see a screen where you can create an account. This UI has tabs at the top, pretty much like the Analytics UI did. We're currently in the Admin UI. Enter your account name, whatever you want your Tag Manager account to be called. Choose whether you want to share benchmarking data anonymously. If you opt in, then the data that you collect through analytics and tag manager will be shared anonymously and used to create benchmarks, and you'll be able to see those benchmarks. During testing, I won't share my data, but later on, my apps when they go into productions, then I will. Anyway, continue. Set up your container. Choose Android, obviously. Give it a name. And we're using this container to contain our daily specials, so this name doesn't actually need to match anything in your code. It's helpful to name your container in a way that helps you remember what's in it. All right, then Create. Accept the terms and the container is ready to be used. Ok. Good with that. So now I notice that we're in the Container tab. And up here on the top left, next to the app name, you'll see your account ID. Okay, take a minute now to create your Google TagManager account. Okay, I'm going to redo the quiz. So go to tagmanager.google.com. Create an account for android obviously. Create a container. Check the boxes as you go and when you're done, tell us what your account ID is by entering it here. Now you have a Tag Manager account with its first container. Mine's called DailySpecialContainer. The next step is to put something into the container and then use it in your app. So the steps are like this. In Tag Manager, create a variable. And then, publish the container. Then in your app code, you write the code to get and use the variable. Then you update the variable, publish the container again. In your app code, well, you already wrote the code, so you don't need to do anything. Your app will automatically get the latest value. Now lets look at how to create the daily special variable in the Tag Manager dashboard. So make sure you're in the container tab and click Variables. You'll see that tag manager defines a bunch of pre-defined variables, and you can make use of these variables in your app. For example, you can use a device name, so that different devices use a different background image in your app. For now though we're going to define our own custom variable. To create custom variable, click New in the User-Defined Variables section. Whoa, there are a lot of variable types. You can read about what they each are in the online help for Tag Manager. For now, we want a Value Collection. Choose Type, Value Collection, that's what we want. But first, you need to name the variable, and this is going to be the DailySpecial, and now we need to configure it. So configuring the variable basically means specifying the value. And for a value collection, it's a key value pair. It's actually a list of key value pairs. You could put as many key value pairs as you want. But for now, let's just do one for the DailySpecial. So since it's a key value pair, let's have the key be daily-special and enter a daily special of your choice. And you need to begin and end the value with open and closed braces. We're going to save the advanced settings for later. We need to Continue, and we need to choose when to enable it. Well, we want to always enable it. So create variable, I now see in the User-Defined Variables section, I've got one variable. However, it's not enough to just define or update the variable. If you want your app to get the latest values, you need to publish the changes. So we press the Publish button, it double checks if we really want to publish and so I'll say Publish Now. Oh, I got an error. So this is one of the nice things, is that the publish process does catch errors in your key value pairs, in your value collection list variables. So let's go fix that. I fixed the key value pairs in my variable, press Continue, and I save it. Now that I saved it, I'll publish again, Publish Now, and yay, success my changes are now live. Of course I'm not actually doing anything with this variable, but we'll get to that in seconds. Go ahead and create the variable for the daily special. So make sure that you set your variable name, type is set to Value Collection, that you've configured the variable, and entered the key value pair for the Value Collection. Enable, Always and create the variable. Then when your variable's created, make sure you publish your container. And next, we're going to look at how to download the default container. So far we've defined the variable and published the container, but one other thing that's needed is to add a default version of the container to the app. The default container contains the initial values. You go to the Versions tab, up here, and you see the different versions that have been published. You go to the latest one that's actually published live, click the Actions menu to see the options, and choose Download. And you see it's downloaded. So, it's your turn now to download your container and then check here when you're done. So far, we've been working in the Tag Manager UI, but now it's time to code our app to use the daily special variable. So what we're going to do is add the default container to our Android Studio project. And the default container is the thing that you just downloaded. So the default container contains the initial values for the variables, but we're going to want our code to get the latest values. So we'll add code to download the latest container into our app, and we'll do that in the onCreate Method in the main activity. It's important to save a reference to the container so that you can get hold of the container from any other place in your app. And then throughout your app, wherever you need, you get the container and you get what you want out of it by retrieving the value of the relevant key. And that's a simple get call. Now then,all of these tasks, adding the default container to a project and writing this code, are one time only tasks. After you've done these steps, the only thing you need to do when the special of the day changes is to update the value in Tag Manager and publish the change. So the first thing is to find the file that you downloaded from Tag Manager. It likely starts with GTM and it will probably be in your downloaded folder. You're going to have to rename it. The name must only have lowercase letters and underscores, no hyphens allowed. For some reason the downloaded file has capital letters and hyphens so you definitely have to rename it. You need to copy a file into the raw folder in the res folder in Android Studio. And you'll need to create the raw folder. So the file that's now in the raw folder holds the initial default value for everything in the Tag Manager container. Usually, your app will get what it needs from the latest version of the container. But it's required to have a default container, even if it's just an empty file. Okay, go ahead and do these steps now. Next, in MainActivity, define a method to load the container. We're going to call that loadGTMContainer. It needs to get the TagManager instance and load the container using loadCondtainerPreferFresh and pass in the ID You pass in the TagManager account ID and the default container that you downloaded. And then you set the result callback. And you do that using setResultCallback on the result that was returned by loadContainerPreferFresh, and it takes a containerHolder. And this callback is called when the loading is finished, and it needs to refresh the holder to make sure we really have the latest container, and save the holder, and you would save it using the setContainerHolder method you defined on your application class. Then we actually have to make sure that loadGTMContainer gets called, so call it in onCreate in MainActivity. And check the boxes when you're done. Okay, let's take a look at the code. So now I'm looking at the my application class. I have a couple of extra imports for tag manager and container holder. The variables to hold the container holder and the tag manager. Method to get the tag manager, fairly simple. Check if it already exists. If not, get instance to create it and then return it. And then we have simple setter and getter methods to set and get the container holder. Now, over in main activity, again we have some imports. We need to import PendingResult, ResultCallback, ContainerHolder, TagManager. and Oncreate I call load GTM container and here in GTM container I get the TagManager instance. I load the container, I set the callback on the pending result. I deal with the failure or in this case I punt that to later. I refresh the container holder. I store the container holder, calling setContainerHolder. I set a timeout of two seconds for the container to load. Phew, now we've downloaded the container, we can go ahead and actually do something in our app that uses it. We can get things out and use them where we want. It's a simple matter of knowing the key and retrieving the value. First Get the ContainerHolder. Then retrieve the value by key. Obviously, you have to know the exact key. Here's how we get the daily special: we just call getString and pass the key daily-special. And that's all there is too it. Whenever the daily special updates, your app will automatically get the latest value without you having to make any changes to the code. Note, though, that the update only takes effect when the app is restarted, because the code to get the container is in the onCreate method. To try it out, update your app to show the latest daily special. In the ShowDailySpecial activity, define the method Update daily special that get's the daily special out of the container and updates the relevant text view so that your users can actually see it. And make sure that you actually call update daily special in the on create method. Run the app and show the daily special. And then In the Tag Manager dashboard, go ahead and change the daily special. Don't forget to publish your changes, and then restart your app and see if you get the new value. And hopefully the daily special will have changed. And go ahead and check all the boxes when you're done. Okay, let's see what my daily special is. Iceberg lettuce with lollipops. I'm going to go ahead and change it to gingerbread noodles with coconut sauce. Save. Don't forget to publish. Easy enough to forget that, but if you don't publish, the changes won't go through. All done. Now let's see what happens if I show my daily special again. It's still the same thing, and that's because I need to restart my app, because the code to get the container is in onCreate. So, I will close this app. Start it up. Show Daily Special, and there it is. It's got the new value of the daily special. Now let's have a look at the code. So, here we are in the show daily special activity class. We've imported the container holder. And then, in onCreate, I just make a call to updateDailySpecial(). And then, in updateDailySpecial, I get the container holder from the application. I get the daily-special out of it by calling getString on the container. I find the relevant text view. I set the value of the text view, and that's all there is to it. So far, we've used the loadContainerPreferFresh method to load the container. And this takes the containerID, which you get from the TagManager UI, and the defaultContainer. So this method checks if the app has a container that's been refreshed in the past 12 hours or so. And if it does, then we load the container. And if there isn't a fresh container, then load a new one over the network. And if there's a timeout or a network error before the container finishes loading, then the container holder status is set to unsuccessful. There are a couple of other methods for loading the container, loadContainerDefaultOnly, which will only get the default container, and then there's also loadContainerPreferNonDefault. So this one prefers to not use the default container but doesn't necessarily look for a fresh container. To get the freshest value, use loadContainerPreferFresh. But fresh is a relative term. If we look at the reference page for TagManager, it says that the mobile app refreshes a container from the network every 12 hours. So one of the benefits of TagManager is that non-developers cannot put changes to an app. And these will often be bulk uploads of many values. This mechanism is not really meant for second-by-second changes, but it's nice to see the changes when we're developing our app. And that's why we added the call to manually refresh the container. Here's the reference, the refresh method on the container. And it says, in order to limit the frequency of network communication, refresh method is throttled, and that you're supposed to wait at least 15 minutes before calling this method again. So even manual refreshes are not guaranteed to take effect more than about every 15 minutes. I've had good luck with my changes taking effect very quickly when I change variable values in TagManager, but it's not guaranteed. If you don't see the changes taking effect immediately, don't be too surprised. So now your app gets the data special out of the tag manager container. When you update the daily special variable in tag manager and republish the container your app picks up the changes. But what if your user doesn't speak English? Wouldn't it be nice for them to see the daily special in their own language? Why didn't you say so before? Now I'm going to have to update the code in my app. Don't worry. No code updates needed. Seriously, to make this change you don't need to update your code. We can handle it all in tag manager using a built-in variable. So come with me and we'll delve into the wonderful world of built-in variables. We can use Tag Manager to publish the daily special in different languages. Not everyone speaks English after all. I'll show you the process and then you will do it. Let's take a look at the built in variables in Tag Manager. Go to variables, and you see them grouped by application, utilities, and device. We'll be using the language variable. Make sure that it's selected, the little check box is green. We're going to use the language built in variable to define a trigger that determines which version of the daily special to show. [FOREIGN]. So next rename the daily special variable to daily-special-en, because it's going to have the English version. So the name of the variable is just for your use. The code doesn't refer to the name of variable. What the code refers to is the key in the value that you've configured for the variable. So, here it's daily-special, and we can't change that. Then create a custom trigger by clicking Custom. Click New. And we're going to call the trigger, english-trigger. So it's a custom event, and that's fine. Here in Fire On, in this first menu, you see a list of the built in variables that were enabled. So go ahead and choose Language, and then in this middle field, we don't want it to be contained. Just set it to equals. And over here, the last field enter en. If you wanted more rules for the trigger, you'd enter plus and add then but we're not going to do that right now. And then save the trigger. And down here, click the X to delete Always because we don't want to use this trigger Always any longer. We only want to use it when the user's device is set to English. And save the variable. So over here in the trigger screen, we see the english-trigger. Now make a copy of it, and rename the copy the french-trigger. And in this case we want it to fire when the language equals fr. And Save Trigger. Now we have two Triggers. Now back in the variables screen, make a copy of the daily-special-en variable. Copy it, call the copy daily-special-fr. This variable's going to hold the French Daily special, so we need a French translation. So copy the value. If you speak French, obviously just go ahead and translate it, but otherwise copy the value and go to Google Translate to translate it to French. I'm going to copy this and go back to Tag Manager. So, you have to leave the daily special as it is. Don't translate the key, just the value. The one thing to notice here is that my menu included the word d'epice. And it has a d'. These kind of apostrophes show a plush in French but here is the value of the variable. This apostrophe's actually going to be interpreted as the closing delimiter of this string. So we need to escape the apostrophe with a backslash. Oh, and there's another one, [FOREIGN]. Now see the innate, it says Enable When english-trigger, well we don't want that. We want the french-trigger, not the english-trigger. And now, Create Variable. So, to summarize, I've got two variables, one for English, one for French. And I've got two triggers, one for English and one for French. We have the English and French versions of the daily special. And we've defined triggers for each language. Got to publish the changes. Now it's your turn. Make sure that in the built in variables, that language is selected. Then go to the variables screen and rename the daily special variable to daily-special-en. And while you're editing the daily-special-en variable, create the english-trigger and delete the Always trigger. Create the french-trigger, create the daily-special-fr variable and get the french translation of your daily special. Don't forget to publish your changes. Strangely enough, that's an easy one to forget to do. So go ahead and do these steps. Check boxes as you go and then in the next video, we'll try it out. Let's see if these changes are effected in our app. We can go straight to the phone to test the app. There are no code changes to deploy. Not connected to Android Studio. Okay. Here's the app. I'll show the daily special, and there it is, gingerbread noodles with orange sauce. Now let's see what happens when I switch my language to French. I want you to pay close attention to the symbol next to Language & Input, and remember it. It's kind of a globe-y thing. And then Language is the top item in the Language & Input list. The reason I want you to notice those things is it can be very frustrating if you're messing around with a language you don't understand, and then you want to switch back to your own language, and you can't remember which of these options is Language. So pay attention to it. I'm actually going to try French now. There it is. See what happens in my app. And I've got the French. Now let's see what happens if I choose Spanish. I'll start my app up, show the daily special, and see we have no value. That's because we have rules when the language is English or French, but no catch-all for other languages. Let's go back to Tag Manager. So in the daily-special-en variable, add back the Always trigger. We need to add exceptions for the languages that we're explicitly handling, in which case this is French, save the variable and publish the changes. Now over here on the phone, we'll start the app again, show the daily special and it should come up in English because we've defined English to always fire unless the language is French. Feel free to add variables and triggers for whatever languages you like. What languages did you try? Go ahead and enter them here. Okay, it's time for quick quiz. Which of these are built-in variables? Does Android detect what language you use for voice searches, and make that available as a built-in variable in Tag Manager? Is the language the device is set to available as a built-in variable? What about the user's location, or their email? What about the SDK version? And, that would be the Android SDK version. Name of the application? Is there a random number built-in variable? And, is there a built-in variable for food preference? You know the drill. Check all that apply. So there is a language built-in variable, but it's not the language that you use when you do Google searches. Maybe that'll come in a future release. And it is the language that the device is set to. User's location is not one, user's email is not one. And yes, you can get the SDK version from built-in variable, also the application name. And I kind of like this one, random number, there's a random number built-in variable. And handy as it would be for our act, there is not in fact a food preference built-in variable. So now we know how to provide the daily special in different languages. But how do we take the user's food preference into account? That doesn't seem to be a predefined variable for food preference. They might be vegan, they might prefer fish. We want to show them a special that suits their taste. So we're going to use the tag manager's data layer. Your app can put values in the data layer by setting data layer variables. Then, tag manager can get the values from the data layer. And use them to figure out which variable values for your app to use. So now I'm going to look specifically at the daily special. So the user chooses a food preference, and the app can put that preference in the food preferable in the data lay out. And then, the triggers in the tag manager can use a data layer variable. To determine which variable value to use for your app to display the daily special. So if the food pref is to prefer meat, you get a meat special. If you prefer fish, you get a fish special. If you want vegetarian, you get a veggie special. And if you chose vegan, well, you get a vegan special. Let's go find out how to make our app do this. The steps of putting data in the data layer are, get the tag manager instance and you do that calling get instance on the tag manager. Then, get the data layer and you do that calling getDataLayer on your tag manager instance. And then you put a key/value pair in the Data Layer. And you do that calling push on the Data Layer, specifying the key and the value. For example, if the key is food_pref, And values "vegan", this is how you would do it. That's all fairly simple. And when the values in the data layer, you get it out using "dataLayer.get". For example, you just call "get", specifying "food_pref" as the key. When the values in the data layer can also be used in tag manager triggers. And we're going to look into how to do that. In lesson one, we use the what's for dinner button to display the users food preferences before suggesting a dinner. You're now going to use a similar menu to set the food preferences. The daily special. Your tasks are in main activity, to find a new method putFoodPref in Data Layer, which takes a menu item. And this method puts a value for food pref in the data layer. And this table shows the menu item value and the data layer value to put in. And the key is always food pref. And then update the existing show daily special method to display the food pref's pop up menu. And then you'll need to set the old click listener to call the putFoodPrefin DataLayer method and to start the ShowDailySpecialActivity. You can find the code for creating the PopupMenu in the showFoodPrefsMenu method in MainActivity. This method pops up the food preferences menu. And then uses the food preference to get dinner suggestion. However, we want to get the daily special, not the dinner suggestion. So you'll need to copy and modify the code to suit your needs. So go ahead and do these steps now and then deploy your app. You won't see any changes in the way the app behaves yet. Next we'll add triggers in tag manager to make use of the data layer variable, and that's when you'll see the changes in your app. Okay, let's take a look at the code. It's all in main activity. Here the imports that we need for the DataLayer, the TagManager, and here's the updated version of the showDailySpecial method. We get the pop-up menu, we use the food_prefs_menu, that's already defined, to Show the menu of food preferences. We set the on click action for the pop up menu to call the new method that puts the food preference in the data layer, and then it calls a method to start the ShowDailySpecial activity. And then we show the pop up menu. And then here's the method to get the food preference and save it in the data layer. We'll get the Tag Manager instance, we get the data layer, and then, depending on which menu item was selected, we push the appropriate value into the data layer, keyed by food_pref. There's vegan, vegetarian, fish, and so on. And then here's a method that simply starts the ShowDailySpecial activity. Notice that we don't pass the food preference here, because the activity's actually going to get it out of the data layer. Now that we've written the code to save the food preference in the data layer, we can create variables in tag manager to hold the special of the day for each kind of food preference. First, we need to create a data layer variable to hold the food preference. So you go to the variable screen, create a new variable. And this time, it's important to choose data layer variable. Name the variable, this name is for you to identify what's in the variable. And then you configure the variable. The only thing you can figure for Data Layer Variable is the name of the variable that you using in your code. This name must exactly match the key you set in your code. So in my case I used the key food_pref, so my variable must be configured for the variable name to be food_pref. You can set the default value if you like. I'm going to set it to unrestricted. Create the variable. Now we have the food pref variable. The next thing to do is to create the daily specials for the different food preferences. So, the easiest way to create a new variable is to copy an existing one. So, I'm going to copy daily-special-en, copy. Make sure to rename it. Notice that the type is a value collection. Configure the variable, set the value, choose a nice vegan special of the day, whatever sounds good to you. Since we copied an existing variable we've got the triggers that came with that variable. And we need to get rid of them. So delete all the existing triggers and create a new custom trigger. Now, this list of triggers doesn't include the trigger we want, so we create a new one. And it's going to be the vegan trigger. Custom is good. And then you want it to fire when the food preference is vegan. Look for the food preference contains, or even contained, equals vegan. Save the trigger, create the variable, and now we have the daily-special-vegan to the value collection variable. As well as the food pref which is a data layer variable. And don't forget to publish. Okay, it's your turn now. So you're going to create the food pref variable and the trigger and we'll start out showing a vegan daily special. To start with, create the food-pref DataLayer variable and then create a value collection variable for the vegan daily special. And the easiest way to do that is to copy and edit the daily-special-en that already exists. Choose a custom trigger for it and then create and use the vegan trigger. And what's the last step that you mustn't forget? Publish. Okay, go ahead and do these things. And then try it out on your app. So far, we've only set the vegan daily special. So, if you press the Daily Special button, press Vegan, choose Vegan, and you'll get the Vegan Daily Special that you set in Tag Manager. But, if you choose any of the other options like, Prefer Fish, you're actually going to get the daily special, N, EN, the english daily special that we set earlier. And we're going to be adding more variables and triggers for the different food preferences next. Now that we've created the food_pref variable we can use it in other triggers too. Your next task is to create specials of the day for each kind of food preference. For this you'll need triggers for each food preference. An easy way to create the triggers, is to go the Trigger screen, copy the existing trigger, and modify it to suit your needs. I'm going to create the fish trigger. And then don't forget to change what the food pref is. So for the fish trigger, obviously, the food pref equals fish. And save the trigger. After you create a new trigger, you can use it in a variable. So this is how I'd create the fish variable. Copy the existing vegan special variable, make sure you copy it, don't edit the existing one. Rename it. Make sure you set a value. It's got to be a fishy value. And you'll have to change the trigger. It's not vegan, obviously. And pick your new trigger. So if you've pre-created the triggers, then this list of triggers will be pre-populated. And then that makes it quick, and create the variable. Now I have my daily special fish variable. So go ahead and create specials of the day for each kind of food preference. Create the triggers that you need. And you already have the vegan trigger. And create variables. And again, you already have the vegan special variable. So go ahead and do these steps. Create the triggers, create the variables. Handle the case where users don't specify a food preference, and publish and check the boxes as you go. And then test out the app. So we'll need to start and stop your app, to make sure the latest container downloads. Go to, Show Daily Special, pick one of these, go Vegetarian, veggie pie with sauteed donut, sounds delicious. And all the other options should work as well. Okay, let's take a quick look at the triggers and the variables. You should also have variables for each kind of food preference, fish, meat, vegan, vegetarian. If we look at fish one, configure the variable value to be a relevant daily special for the food preference. And trigger it on the appropriate trigger, in this case the fish trigger. Now there's several ways to handle the situation where the user does not specify a food preference. You can let it default to the English special, since we already have it. Or you can create a new trigger, such as no food pref trigger, and set it to fire when the food pref contains unrestricted, because that's what we set in our code. Save Trigger. Now that you've got that trigger, you can either create a new variable, especially for People who don't specify a preference, if you want to give them their very own customized special. Or you could just pick one of the other specials, I'm going to o for the vegetarian special, and show that one to the people who don't specify a preference. And the way you do that is just edit the variable and add another custom trigger. So we want this to trigger, not only when the vegetarian trigger applies, but when the no food pref trigger applies. Save the variable, and there it is. And it really doesn't matter which way you decide to go. So now you're going to do a quiz to consolidate your knowledge of triggers and variables. So go ahead and read through each of these statements and mark whether they're true or false. So how did you do with this quiz? I know that the whole variables and triggers thing can be a bit confusing, with variables depending on triggers, which depend on variables, anyway. So the first one, the value of a data layer variable is set by code in your app, is true. So if you remember, we set the food_pref value in our code. The value of a value collection variable is set by you in the Tag Manager interface, and that is correct. So if we look at one of our variables, Value Collection variable, and this is where we set the value of that variable. And it takes a series of key and value combinations. We've only been using one key value combination per variable. A value collection variable cannot include a key that any other value collection variable uses. Well that's just wrong. We've been using the daily special key and a bunch of different variables, not just this one. The value of a key in a value collection variable can be triggered by the value of other variables. And that's true, but of course it's done through the use of triggers. Here again, in our daily-special-fish variable, we have the fish trigger, and the fish trigger depends on the value of the food pref variable. So here we have a variable influencing the value of another variable. A value collection variable can be triggered by at most, one trigger? Wrong. So we look at, for example, daily-special-vegetarian, you can add multiple triggers. I can add another one if I wanted. It's important to understand that any of these triggers will set the value of this variable. They don't have to all trigger. Just one of them has to trigger. And yes, you can create a trigger that fires when the data layer variable has a certain value. So, if you look to our vegetarian trigger, this here food pref is a data layer variable and when it has this value, vegetarian, then this trigger will fire. And you can create a trigger that fires when the app is running on a device with a specific screen resolution. You can create triggers that fire based on any of the built-in variables, of which screen resolution is one. And a trigger can have multiple criteria that determine when it fires. You can add multiple conditions to a trigger. Just keep pressing the plus button. It's important to notice though, that the trigger will only fire when all of the conditions are true. This is not an or thing, this is an and thing. So they must all be true for the trigger to fire. So how did you do with the quiz? Have you got your triggers and variables straight? This lesson covered how to use Tag Manager to dynamically update your app. You've learned how to download the container from Tag Manager into your app. You used built in variables to figure out the user's language. You used value collection variables with triggers to determine which daily special to show based on he user's language. And you use data layer variables to transport information back from the app to the tag manager container. In this case to push the user's food preference into the data layer. In the next lesson, you'll learn how to use tag manager to forward and manage hits from your app to Google analytics.