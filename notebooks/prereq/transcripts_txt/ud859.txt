Hi. I'm Magnus. And I'm Jocelyn. [SOUND] Welcome to the course Building Scalable Applications on Google Infrastructure. Jocelyn and I work at Google with Cloud Platform, and we will teach you how to build scalable systems that runs on Google infrastructure, and that can scale. And scale. And scale. And scale. And scale. Because here at Google, we know how to build scalable system. That's right, and now your applications can run on Google infrastructure, as well. I will be teaching you the theory around building scalable systems. And I'll be hacking right along with you. Let's get started. So we're sitting here with Urs HÃ¶lzle, Senior Vice President of Infrastructure here at Google. Urs, could you briefly describe your role here at Google and why Google has all of these data centers? I am responsible for technical infrastructure at Google and that's the team that builds all the data centers, network servers, software systems that runs our internal cloud and we built that a long time ago for our own needs. And we have very large scale applications and so we needed a very capable cloud. And now we're making that cloud available to everyone through App Engine, Compute Engine, and our Cloud Platform overall. Urs, so what excites you about Google Cloud Platform and App Engine in particular, which is the focus of this course? What's great about the Google Cloud Platform is, is really, one, that we can make our great internal infrastructure accessible to every developer out there. And then, in the Cloud Platform, App Engine is really the, that, that one system that makes it really easier for you to start very small. And then scale to a very large user base. So that if you have a game that suddenly becomes popular, our back-end and our front-end is going to scale with you. And you don't really have to change your application very much. And that's rare to see in infrastructure. Usually you have to do the hard work up front. Now, with App Engine, you kind of don't really have to do the hard work at all because we can do it for you. We're out here by the Computer History Museum in Mountain View, California. The Google headquarters is just around the corner. But before we start to build our applications on the Google cloud platform, let's look at the history of building server side applications. Fifty years ago this is where most server-side applications were born. On a physical computer sitting under the desk in some office. Yeah, seriously. A physical computer, you know, one that you can touch and smell. And the generated heat from the fan outlet, so you could warm your feet, if the office was cold. Well, it didn't take long until the server-side applications grew bigger. And it was no longer possible to run them on a computer like this. So the pizza box computer was created because it looked like a pizza box. And these were great because you could stack them on top of each other and on top of each other and on top of each other. And voila! The computer rack had just been born. And the entire shebang was put in a dedicated room called the data center, because all the fans made too much noise and stuff. But it was no longer possible to warm your feet against the fan outlet of course. Okay, let's continue our story on the history of server side computing. At this time we enter the race for scalability. Because once the computer rack was created, we could start to stack servers on top of each other to save space. And this was of course great. But now, another problem surfaced. Because even though these servers were great from a stacking perspective, it was still the case that one application could only run on one server. And this became a big problem, because as the internet grew, these applications got more and more popular. And more and more popular. And more and more popular! And since there is a limit to the performance of one server, this architecture was not sustainable and had to be abandoned. The one application, one server strategy was a dead end street and a radically new solution was required Let's do a quiz now and talk about increasing capacity. The question is what are the options to increase capacity? Is it, to buy more powerful hardware, to optimize your software, to copy and run the software on more servers or to change the software to run on more servers? Check all that apply. Let's see the answers. Buy more powerful hardware. Yes. That could certainly help, but it will not provide unlimited scalability. What about optimizing the software? Yes. That could certainly also help. But that, will not provide unlimited scalability either. Copy and run software on more servers. Well, normally, software cannot just be copied, and run on more servers. To be able to run on more servers, you typically have to change the software, so this option is also an alternative. In fact, if you can change your software to run on more servers, you are starting to work with the scalable architecture. This is because the capacity will not be limited by the hardware you use, or how much you can optimize your software. When you need to scale, you can add more servers. As we concluded, a radical change was needed a brave new world. A completely new approach to building applications needed to be developed that could scale to meet the demands of the rapidly growing internet. Not a key step to building a scalable system is you need to decouple it from executing on a single computer. You design a scale out architecture as your application scales outside the scope of a single computer and this distributed architecture needs to be a socalled, share nothing architecture. Meaning, that it must not depend on any shared resources that can become the bottleneck, this way if your application needs a scale, you can just provide more computers to provide the additional capacity required. That means, you can run your application on. All the things. And to get even more flexibility the concept of virtual machines was born which enables you to decouple a physical machine from the application execution machine. This had great flexibility gain since the infrastructure turned virtual you would now run your scale out application on several virtual machines instead of physical computers. Problem solved, right? You can now scale indefinitely by adding these standard building blocks of performance that your application can utilize and you have decomposed your application from the specific execution machine, great. Now only one question remains, how do you design your application to be able to scale like this? Let's take a closer look if we have solved the problem. First of all, virtual machines are nowadays a standard offering by any cloud service provider. You rent any number of virtual machines. And you pay by the hour, or minute or so. This is called IaaS, or Infrastructure as a Service. This is, because a computer and therefore also a virtual machine, can be considered infrastructure today. So getting back to our original picture. Problem solved, right? We could use standard virtual machines from any cloud service provider. And achieve unlimited scalability by distributing the execution of our application, across these virtual machines. On a high level, it may appear so. But let's look at what you need to do to actually realize this architecture. And as it turns out, creating this architecture for your application is a very complicated and resource intensive problem. Let's look at some of the things you need to think about and take care of. VM Management. Starting and stopping the virtual machine. Operating system images. Software management. Installing, patching and upgrading. A powerful web server. Installing it and configuring it for the correct settings. A distributed database where you can read and write data, from all of your virtual machines. A distributed file system, where you can read and write data which is accessible from all your virtual machines. Application monitoring, with a consolidated view of any problems occurring in your distributed execution environment. Availability including data replication, hardware software resilience, geographic disaster recovery strategies. Back ups, recovery, automatic fail overs, et cetera. Security set up and management in your distributed execution environment. And load balancing. How to spread the load across the VMs, including application level session management. And all of the other things that we did not have space to list here. As you can see, this is an extremely complex problem to solve in a scalable way. So even though our solution looked good on a high level. We have now created an architecture that requires a monumental engineering effort to realize. At the same time, as you have limited amount of time and resources. Remember that we started the service side history, by looking at the server sitting under the office desk. And sadly enough, for many projects we have reached a present day. These are the challenges many projects are facing today, when trying to build scalable systems. Now, let's do a reality check with a question for you. Since you have limited time and resources, select three of these problems you would prioritize over the others. Well that was not easy, was it? No it wasn't. And that was kind of a trick question, because all of these things are important to consider when building a scalable system. So let's be clear about this. Plain virtual machines are great in many ways. But if you have to do all of these things yourself, we could consider using them a dead end street. So let's look at a better solution. Because this should not be a problem that every single developer of server side applications need to think about. Fortunately the Google cloud platform has a product that takes care of most of these things. It's called App Engine, and that's what we will be using in this course. Let's take a closer look. App Engine is a development and deployment platform that takes care of many things for your application. For example, it performs all the scaling for you automatically. So when your application runs on App Engine, and there is more traffic it needs to manage. Then App Engine will increase the number of instances to use to take care of the load. This is called scaling up. And at other times, when your application is not so busy. App Engine will reduce the number of instances to save resources and cost. This is called scaling down. And this scaling is done automatically. You don't need to write a single line of application code to get this benefit. And it doesn't stop with automatic scaling. The App Engine platform has functionality to deal with all of the things we've previously looked at. So there is no need for you to do any design or coding to deal with that. And this is no coincidence. Google has been the leader in designing scalable systems and all that experience was built into App Engine when it was designed. As is everything runs on Google infrastructure. There are Google engineers watching over these systems day and night, to make sure everything is running smoothly. So that you, can focus on your application. In Cloud language, App Engine is classified as a PaaS solution. And this makes sense, because App Engine is a platform that takes care of a lot of the complexity of building scalable applications Now, when you have been introduced to some of the benefits of app engine, let's do a little quiz. For which of the following could app engine be used and benefit from its strengths? A news site like New York Times, a device driver testing system, a personal portfolio site, or a video game? Check all that apply. OK, so let's go through the solution. A news site like New York Times, absolutely. It's an internet service, it has lots of users and the load on the service probably varies so the scaling of app engine could be used a perfect match. What about a device driver testing system? Well, it of course depends on what kind of system this is but just the fact that device driver is part of the title, make you think that it needs access to low level resources within in a computer. Remember, app engines are generic platform to build scalable applications and from that perspective this does not sound like a match. What about a personal portfolio site? Just because it's a personal site and probably does not need massive scale, does not mean that app engine can not be of great use. App engine simplifies development of server-side applications greatly, so this is a good match. What about a video game? Well, if we just mean the user interface part then app engine is not a good match, app engine is used to develop server side applications. Okay. So by now, you've heard a lot of positive things about App Engine and how it can help you build scalable applications. But let's do a reality check here. Surely, there must also be trade offs involved when using App Engine. Let's start off with programming languages. Since App Engine provides services to control the execution environment, it also has to set up programming languages it supports. This list has been extended over time, but App Engine currently supports Python, Java, PHP, and Go. And since App Engine is an execution container, it also means that there are specific versions of these languages that are supported, so this is something to think about. Then moving over to low-level controls. Since App Engine was designed to create scalable application as easy as possible, it's execution environment also encapsulate many low-level controls. For example, operating system type and version, virtual machine configuration, or network controls, et cetera are not visible, and cannot be configured in App Engine. And that goes for other things, as well. App Engine strikes a great balance between providing the convenience you need to develop scalable applications without sacrificing the flexibility that you want. But with this in mind, don't be surprised later on when you see App Engine is not like a regular virtual machine, because it's not. All right. That's it for the reality check. Let's now look at some App Engine success stories. We will now look at three App Engine success stories that are representative, because they use the strengths of App Engine. The first one is a real-time earthquake monitoring system in japan. So in this picture, lots of data is collected by NIED, which is an institute in Japan. They look at the data and then send image files to App Engine, every second. Clients can then view these images files to see the activity. Well, as you can imagine, when there is no earthquake activity, there are not many clients that are interested in watching this system. But on the other hand, when there is earthquake activity, the system needs to serve a lot of data to many clients. And this is, of course, a great application for App Engine. Which can scale the number of instances up and down, depending on the activity and the number of clients accessing the system. Another great success story of App Engine is Song Pop, an app you may have used, which is a game where you guess the song or an artist. Well, Song Pop grew from zero to 10,000 queries per second in six months. And as of early 2013, it had more than 60 million users. Song Pop uses app engine, again, because of its ability to rapidly scale up and down based on the user load. And one that you've certainly heard about is Rovio, the creator of Angry Birds. When Rovio developed a web based version of Angry Birds, they used App Engine because of its automatic scaling. But also for many of the other functions it provides. And these things are exactly what you will learn when you take this course. So stay tuned. Okay. Let's involve you in a little survey here and ask you about sites that are running App Engine. Please feel free to search on the web. Please list the site that is running on App Engine, and also list the site you think should run on App Engine. And get involved, go and discuss and share your views with other people on the forum. So I'm setting here with the founding CTO of Udacity, Mike. Mike, how did you come to the decision Udacity? Because Udacity is running their courses own App Engine, in fact that's what this course is all about. How did you come to the decision of, of using App Engine? The very first website we built was built for AI classes, a single course. And it was built on a bunch of VPS servers, and we had underestimated the interest that we were going to get. Which was awesome, but we ended up with two orders of magnitude more users than we expected. And I was a relatively novice web developer. And so we hit every single problem you can hit, in terms of scaling up the infrastructure to meet the demand. And so the entire 14 weeks of the course we were just playing catch up the whole time. Fixing problems, and adding more bandwidth, and adding more machines and memory. And coming out of that, we were looking at launching a bunch more courses and we were really uncertain about how much traffic we'd be getting. We've seen a lot of peaks. And so one of the engineers, we're a very small team, but one of the engineers had some experience using App Engine. And, it sounded like a really great solution to the problem of uncertain amount of load, and took all of that headache. Because we were spending about half of our engineering hours doing sys admin and dev ops work, just trying to keep stuff running. And when you have a small team and you want to focus on getting new features out. And you want to focus on usually working on what your good at, then it is wonderful to have a platform that cushions you, for the spike and the loads. And pushes you in the right direction. That's fascinating, that's exactly hat we're trying to teach in this course. What would be your key messages to the students of this course, what would you tell them now? So I think the advice I'd give to the students is, it's important to remember there are trade-offs with any framework or platform you use. And one of th things, after using App Engine for a couple years, we found is. It seemed like there was a lot more work, at times, just to get started, to get something simple up and running. But, what we found with time is that it pushes you in the right direction. It pushes you to the best design practices, for building a scalable applications. Maybe, if you're trying to build something which will serve 200 people, you could do it. Quite a bit faster if you are just running it on a single machine. But the second you get up to 2,000, or 20,000, or 200,000 users, it's made you make decisions, which will really put you in a better place. And that is, that's it, I think the most absolutely valuable thing that it provides. That's great. Thank you so much, Mike for taking this time. I'm sure that the student will find this valuable. Thanks, and glad I could help. And I really hope that after taking this course, students have a little bit of an easier time than we did at the beginning. Are you excited yet? We hope you are. We think you should be. Just look at all of these pictures of Google data centers. All the Google services run on the infrastructure that you see. And with the Google cloud platform and app engine, this infrastructure is also available to you. That means that the code you create in this course will execute alongside all of the other Google services. And can leverage from the same scale security and performance that Google has built out over the years. We can't wait to get started and have you on your way to write and deploy your own code into these data centers on your journey to writing scalable applications in the Google Cloud. Hi, we hope you're now all excited to build scalable applications using App Engine and the Google Cloud platform. In this lesson, we'll get down to the nuts and bolts of everything, and have you deploy your first code to App Engine. This will involve an number of different steps, but don't worry, we'll all do it in a structured and orderly fashion to make sure you're on your way to become a rock star App Engine developer. So let's look at what we're going to do in this lesson. First, we're going to look at the App Engine development cycle and create an App Engine project where you can upload your code. Then we're going to look at cloud endpoints that allows you to create a backend that can work with any frontend device technology. After that, we'll get you started with a development environment where you develop code for App Engine. And then, we'll introduce Conference Central, the application that we will build out throughout this course. At the end of this lesson, you'll have a working application running in the Google Cloud. Isn't that exciting? Let's go, shall we? The first question you'll probably ask yourself at this point. How do I access App Engine in the first place? Well that is a pretty important question to answer. And we're happy to tell you that it's super easy. So first of all, here you are. A star developer. And you should already have a Google account, that you probably use for many different Google services. Such as Gmail, YouTube, Google Plus, et cetera. Well, guess what? Your standard Google account also allows you to create app engine applications that run on the Google cloud platform. So there is no additional account required. What you do is simply log on to the developers console that we will go through later. And register the App Engine applications you want to create. And once you've done that, the time has come for you to create those great cloud applications. So you need to sit down, and hack, and hack. And hack, and hack until you have something awesome that you want to test. And then you can fire up an instance of App Engine, which runs on your local development machine. And that is of course, great. Since it allows you to use all your standard tools. Such as debuggers and providers to get those bugs out. And once you've done that, it's time to run your applications on computers in the Google data centers. So, with just a click or two, you can deploy all of that great code to App Engine. And of course, you can have many applications running there. And when you and your front-end developer friend have finished your application. You tell all your users about how cool it is, and that they can start using it. And when you use App Engine, it's very easy to support any kind of device and operating system. Computers, smartphones, tablets. You name it. And hopefully, the users will think your application is so cool, that they will tell their friends about how cool it is. And hopefully they will tell their friends. And your application goes all viral. And you get all of these great ratings and recognitions. And awards and stuff. But you don't need to worry about your site going down because it has become so popular, since you built it on the Google cloud. It will scale and scale, and scale on the Google infrastructure. So you get to feel like a million bucks. And become a rock start developer that everyone wants to be with. This is exactly what we would like to happen. And that's really what this is all about. App Engine and Google cloud platform, allows you to create applications that run in Google data centers. And can be used by any device. So you can sit with your laptop and create apps that scale to serve billions of users worldwide. It's really, really cool when you think about it. Well, hang in there. Because you're just about to create your first App Engine project. Okay. So we now come to the part where we will create a new project for App Engine. You create new projects using the developer console, which can be accessed at this URL. This is a console that allows you to configure many different Google services. But in this course we will focus on the App Engine specific parts. Go there and create a new project. We will talk about installing the development environment a bit later on, so don't worry about that right now. While creating the project, you will be presented with the following dialog box. Pay special attention to the project ID. The project ID must be unique and it has certain naming restrictions. Having a project ID you're happy with, though, can be quite handy, since you can access your application through a URL containing it. After you've created your project, this is the URL that you can use to access it. So in this example, the final URL will become http://apt-octagon-533.appspot.com. See, that's the project ID was this. So it's now time for you to go and create your new project. So now that you registered a product, it's time for a quiz. Which of these project ID's are valid and are they available? First alternative is ud-859, hi_there, hi7 or cheesecake0123456789, please select which are valid and which are available. All right, so welcome back from the quiz. So these are the answers, first we have ud-859. Well the dash character can be used in project id's but it's not available. Then we have hi_there, well underscore cannot be used in project id's. So it's not a valid project id and therefore not available either. What about hi7? Well a project ID must be at least six characters, so it's not valid and it's not available. Then we have cheesecake 0123456789, well this is a valid project ID but it's not available Okay, so now we have registered an app engine project and we are almost ready to do some coding. But just before we do that, let's talk about supporting different devices for a while. One big challenge when designing service-side applications today is that there are so many different devices from so many different vendors that you need to support. Different browsers, smartphone, tablets and computer. All having different API's that should be used. Initially, we will be using the browser for our course project. But later we will be able to support a mobile phone without rewriting a single line of code. Having to consider this when you design your server-side application is a lot of work. So how can we solve this problem? Well, the Google Cloud platform has solved this problem for you with a product called Cloud Endpoints. When you use Cloud Endpoints you can create one single API for your server application called a Cloud Endpoint API. Cloud Endpoints can then generate a client side API for many different devices from many different vendors. This is great of course because it allows you to focus on just server side application and Cloud Endpoints will make sure that it supports many different devices. You will learn a lot more about Cloud Endpoints since we will use it when we build out the course project. Enough said, we have now created an app engine project using the developer's console and looked at the benefits of Cloud Endpoints. It's time for you to get a development environment up and running. Hi! I'm going to be guiding you through the coding portions of this course. You're going to start out by deploying a very simple app, engine application that uses Endpoint to expose its API to clients. Then you're going to learn how to define Endpoint functions and how to call them from the webpage, using JavaScript and the Google JavaScript Client Library. Then you'll learn about the Google APIs Explorer, which is a really cool tool. Not only lets you explore the Google public APIs, it let's you test out the APIs in your own application. As you work through this course you're going to be building up an application called Conference Central, which lets users schedule and query for conferences. And you're going to be focusing on implementing the back-end functionality. Just like on a cooking show, where they bake the cake for you ahead of time, and take it out of the oven ready baked, we've written some of the code for you. Particularly the boilerplate code, so that you can get straight to work writing the code that really matters. You're going to start out by downloading the starting version of Conference Central for this lesson. And building it up as you go from lesson to lesson. But, at any point, if you don't complete the exercises, you don't need to worry because we provide starting code for you, to help you out, every stage along the way. Come on, then. Let's go write some code. I'm going to help you get going with your code. And, the first thing you're going to need to do, is set up your development environment. Actually, that's the second thing you need to do. The first thing I'm going to have you do is download the code that you're going to be using in this course. So to get the code, all you have to do is click this Download ZIP button here in the bottom right corner. When you do that, it's going to download the ZIP of all the code in this repository to your computer. When you've downloaded it, expand the ZIP and you'll see all the folders for each of the lessons. Here's Lesson 2, Lesson 3, Lesson 4, and so on. Right now, go ahead and download the ZIP for all the code for the course Now we're going to set up our development environment. To get ready, you're going to need to install some things if you don't already have them installed. The first thing you're going to need is Java. And you're going to need the JDK 1.7, also known as Java 7. You probably already have it on your computer, but if you don't, you're going to need to download that now. And then the next thing you're going to need is Apache Maven. And then you're also going to want to use Eclipse. You don't have to use Eclipse when you're using Maven projects, but we strongly recommend it. And during this course, all the instructions are going to assume you are using Eclipse. Also recommend that you get Eclipse EE, because it comes with built in support for Maven. If you already have standard Eclipse installed, you can add the Maven m2e plugin to it. But really I think you're going to have a much better experience if you just use Eclipse EE. Some of the things in the Maven plugin for Eclipse don't quite work right. Now one thing you don't have to install is the App Engine SDK. And this is because when you have Maven projects, you specify all the dependencies in a configuration file called pom.xml. And it's in this pom.xml where you're going to specify the version of App Engine SDK that you want and then Maven will just download the App Engine SDK for you. So if you need help installing any of these components, we've written a document for you to help guide you through installing them. And you can find a link to that document in the instructor notes for this lesson. So go ahead and install each of these. And when you've done it, go ahead and check the box here, so that we know you're ready to continue. So now that you've got everything installed, it's ready to get going with an app Engine App. We've created a very simple Hello, World app engine application that uses M-points. You can find it in the lesson two folder that you downloaded from the [UNKNOWN] for this course. What we're going to do now, is import the project into Eclipse. To import a Maven project into Eclipse, you go up to the Eclipse menu, you choose file, and then you choose Import. And you open up the Maven folder and choose Existing Maven Projects, and then click Next. And then you can Browse to the folder that has the project that you want to import. I unzip my folder in Hello, World endpoints, we have to select the folder itself. And then if you want, in advanced, you can specify the name, or you can use the default name. Make sure that pom.xml's selected. Click Next. You may see you get some errors. Particularly, the endpoints get discovery doc. Don't worry about that, just leave it as resolve later, and say, Finish. It'll ask you, if you have the error, you'll get a little error message asking you if you really want to continue. Just say OK, you do. And then the project comes in. It's a little hard to see here, but my project is Hello, World. So this project that you imported, the Hello, World endpoints project, is a complete working app. It's very simple, but it's complete. It works, and you can run it out of the box. So I'm going to show you how to run it first, and then we're going to look into the code that makes up the project. So when you're ready to run your project. Go over here, you choose it. Right-click the project, choose Run As, and then go ahead and choose Run Configurations. You can create a new launch configuration, by clicking this New Launch Configuration button up here. And enter the Base directory, which is where you project is. But you can use is variable dollar open brace project underscore lock. That points the directory where your project is. The goal, you need to set it to appengin:def server. And down here in the Maven Runtime, you need to make sure that the external Maven Runtime is selected. So it must say external, not internal. If you need to configure it, then you click Configure, and make sure that the global settings from installation directory points to where your Maven is installed. If you can't remember where your Maven's installed, hop over to a terminal console window. And hopefully during the Maven installation process, you defined the variable M2_HOME. So you can go ahead and just echo that. So say, OK. And say, Apply. And then right here, I could go ahead and Run it or I could Close it. But I'll Run it now. And you see, it starts compiling. And you see here it's retrieving the Google App Engine Java SDK from Maven. And that's because in the pump.xml, we specified the Google App Engine SDK as one of the dependencies. First time you run it, it does take a while, because Maven has to go off and get all the libraries and everything that make up the dependencies in your project. And when it's finished, you'll see build success. So the build success means, its finished building. And now it's actually going to start running it. And when it, when the product is running, the Dev server on local host, you see this message info, Dev App Server is now running. So, let's make sure it really is. So open the browser and go to a new tab, and go to localhost:8080. And if for any reason your app is running on a different port, then just use a different port, but I expect it will be localhost 8080. And look, the app is running. We're not actually going to run the app, I mean, you're welcome to run it if you want to, but that's not what we're going to look at next. So now I just want to show you how to deploy to app spot. So, back here in the, in Eclipse, go ahead and select your project, right-click it. Again, choose Run As and Run Configurations. Click New to add a new configuration. Again, add the Base directory. And I can just copy that variable into that new configuration. Now, this time we want to deploy two app spots. So for that, you have to add the Goal appengine:update. So here's a goal appengine:update. Again, make sure the Maven Runtime is says external. Now you can Run it. Now the first time you run it, though, you're going to need to give permission to the App Engine cfg application, which is an App Engine application that will upload your App Engine application. And you'll see, that it's asking permission to view and manage your applications deployed on Google App Engine. You are going to need to Accept this. And after you accepted, you'll see that it shows you a code says, please copy this code, and paste it. So, go ahead and copy the entire code, and then go back to Eclipse. And enter the code. Hit Return. And it will keep going. Oh, no. Goodness. I got another error. 403 Forbidden. You do not have permission to modify this app. App_id=u'your-app-id'. Oh, no wait. Wait. That's not my app ID. I forgot to configure the app engine web.mxl. And you're going to need to do this too. So you go into the source directory, SRC Source and then into the main. Not looking at Java just now. You need to go into the web actor then you need to go into web in inph and you see app engine web.xml. And this file is where you can figure the properties are very specific to App Engine. And the most important one, for deploying to App Engine is you have to enter the app ID of your project. And this is the ID that you set in the developer console, over on console.developers.com. So go ahead and enter your app ID here, save the file, and try running again. Now this time, just go to Run As > Maven build. And pick the run configuration for App Engine update. I forgot to na, name mine, but here I see it, App Engine update. Okay, good. It's beginning the interaction, see it's initiating, it's cloning, it's uploading. Then it reaches a point where it's pretty much uploaded stuff, but it needs to ping the app to verify. You'll see these messages, will check again in one, two seconds and so on. And at this point, all it's really doing is just trying to ping the app. Can sometimes get hung here, but usually this doesn't take very long. Okay, good. So now then again, you see build success. Now this means, that my apps been deployed to app spot. Let's go check. So, to visit your app running on app spot, you go to your app ID, whatever that is. And then after you're app ID, you do .appspot.com and it should take you to your app. And this looks exactly the same as it did on local host, but actually we're now running in on app spot. So, one more thing I wanted to mention in your project, is that after you deploy it, whether you deployed it to local host or you deployed it to app spot, the target directory gets populated with all the compile code. So, you could actually delete the target directory, and then re-run your project and it will get recreated. Now the Hello World project here that you've got, it's a very simple, application that uses end points. What I want to do now is just talk you quickly through the code so that you understand how to define endpoints, so you see how to call them from a web page. So let's take a look at the files in the Hello World end points application. So here, you see here in src > main > java. In the com > google > training > helloworld package, you see the Java files. There are three Java files, Constants.java, HelloClass.java and HelloWorldEndpoints.java. So Constants.java defines some constants, as you might expect. HelloClass.java is a very simple class we'll look at in a minute. And then HelloWorldEndpoints.java defines the endpoints used in the application. So the source dir, contains the main folder, which contains the java and the webapp folders. We just looked at java, but now we're going to look at webapp. So the webapp folder contains the static files, the index.html, other HTML files if you have them, JavaScript files, any static content. It also contains the WEB-I-N-F, or WEB-INF folder. And this folder's common to all web applications, and it's where you configure your application. So for app engine apps, you have to have the appengine-web.xml file, which we already looked at, which is where you configure the things that are specific to your app engine app in, particular, you have to specify the app ID if you want to deploy it to Appspot. Another file in here is web.xml. And let's take a quick look at that. So web.xml is where you'd configure servers if you have them. In your web.xml you should see that you have the SystemsServiceServlet. And it's mapped to com.google.api.server.spi.SystemServiceServlet. And this spi, means end points. So this servlet is crucial to your application, if you want to use end points. Basically you must have com.google.api.server.spi.SystemServiceServlet in your app if you want to use endpoints. Also see we define the welcome file here which is index.html, which is pretty much the default. Another configuration I want to draw your attention to, is this one here for the security constraint, where we specified that all web pages must use HTTPS and this is how we specify it, by setting the transport guarantee confidential. So whenever you see this in your web.xml, it just means that when the app's running on app spot, if the user goes to it without using HTTPS, they'll be redirected to HTTPS. Okay, so back in the webapp dir, you see there's also hello.js. And there's index.html. And these are the two files that this app uses in the web UI, or in the web front-end. Hello.js contains the JavaScript functions used by the app, and index.html is the home page for the app, and it shows the two buttons, and the input field. And here you see the two buttons, and the input failed. So let's have a quick review of the config files in an App Engine Maven project. There are config files to set up the Maven dependencies. There's a configuration file to specify the configs specific to the Web application. And there are config files that are very specific to App Engine applications. So now, you're going to match the config file with it's purpose. So some of the config files that we're talked about include web.xml, pom.xml, and appengine-web.xml. So go ahead and match each of these XML files. To its purpose, by checking the box. So web.xml defines configurations for web apps. Lots of web apps use web.xml, not just App eEngine apps and not just Maven projects. So pom.xml is for your Maven dependencies in your Maven project. In pom.xml you can list all the dependencies for your project, like which version of JUnit, which version of App Engine SDK you want. And when you compile your project, Maven will automatically get all the dependencies for it. And appengine-web.xml is where you configure things specific to App Engine. So App Engine configs here. And there are more XML files specific to App Engine such as q.xml, cron.xml and you're going to be learning about those as you work through the course. The Java back-end part of the app is independent of the front-end or the UI. In this case, the back-end defines endpoint functions and the UI calls those functions. So we're going to start our explanation of the code by looking at the definition of the endpoint functions. So I've opened up HelloWorldEndpoints. It's in, this is the package and then we've imported the classes that we need from the spi.config package. SPI basically means endpoint. So here are the imports that we need to use endpoints. Now here at the top of the file, it says @Api [UNKNOWN] and its name equals helloworldendpoints, version equals v1. This is where we're saying, hey, this file contains endpoint functions. The description's pretty obvious and then the client IDs specify which clients are allowed to use these endpoint functions. Here we specified Constants.WEB_CLIENT_ID, but actually for now, we don't really care which client uses us. But this one is important, the API_Explorer. So we've specified that the API_EXPLORER_CLIENT_ID is allowed to use our endpoint functions. And if we look at Constants.java, see here, the WEB_CLIENT_ID, we didn't really set it. But here we did set the API_EXPLORER_CLIENT_ID. You get this from Constant.API_EXPLORER_CLIENT_ID. And we get this from the SPI.Constant package. So if you want API Explorer to be able to access your back-end functions, you do need to enable the client ID to use API Explorer. Okay, so back here in HelloWorldEndpoints, we've defined just a couple different endpoints. They're very, very simple. The first method is sayHello and we've declared it as an @ApiMethod or an @ApiMethod. By default, every method inside a file that's been declared as an @Api is exposed through endpoints. But you can set the name if you want and the path. And then the method. So here the sayHello method simply returns a new instance of the HelloClass object. We'll look at that in just a second. And then the next method, sayHelloByName takes an argument, name, and we've declared it must be named, the argument must be named name, and we return a new instance of the HelloClass created with the name string. That's all these methods do. Basically, they say hello and they say hello by name. So both of these methods return an instance of HelloClass. So let's quickly take a look at HelloClass. And you see this is a really simple class. Doesn't import anything. It's just a POJO, plain old Java object. It has one field message. Has a default constructor. And it has a constructor that takes the name and generates a message based on the name and sets a message. And that's all it does. Now the reason we need this class is because endpoint functions can't return string objects. They have to return objects with fields. Otherwise, we could probably just define our endpoint functions to return a string of the message. But since we need a real object, we're using HelloClass for it. Okay, now I'm going to run my app. I'm going to run it on the dev server, on localhost. So this time since I've already got the configuration, the run configuration setup, I just go to Run As, and then I choose Maven build. And I choose the configuration that I set up earlier and then I choose OK. Now it going to run it on localhost. Again, you can go to localhost and see your app. See the homepage for your app. But actually, I don't want to do that right now. I want to go straight to the API Explorer. To get there, you just add a /_ah/api/explorer. It's localhost:8080/_ah/api/explorer. So you see this when you go to the API explorer. You can click on Services to show the services, and then you can click on the available API to drill down to see what functions are available. And we have sayHello and we have sayHelloByName. And if you recall, these are the two functions that were defined in HelloWorldEndpoints.java. And you can actually execute these functions right here in the API Explorer. So we click sayHello, we say Execute and then you scroll down and you'll see the request, which shows the requests that got sent. And you see the response and you see our response is messages Hello World. Kind of what we expected. Now let's go up and try the next one, sayHelloByName. Now, see here it says name. Remember how we have @name in our API? Well, this is going to show the name here, a bit confusing because we have @name and name, but this is the name argument right here. So let's enter a name and then we'll execute it. And again, here is the request, but here is the response. Hello Lauren. It took the name that we supplied. Okay. Cool. So now you know how to use the APIs Explorer. So now let's take a look at the code that makes up the home page for this app. So here's the home page. It has a couple of buttons, it has the field where you can enter your name. You can click the buttons and you get the greeting, and in this case, the greetings are shown just inside an alert box. Now one thing I want to emphasize is that you can have the Endpoint APIs and you can use the APIs Explorer even if your application doesn't have a front end, if it doesn't have a webpage or anything. If you're just running complete back end service, you can use API's explorer to test your API's, but now, onto the front end. So let's look at the code for index.html. So first of all, we include the file hello.js, which includes the JavaScript functions that our web app's going to use in its front end, and then, and this is really important, we include this file, apis.google.com/js/client.js. This is a file that includes a JavaScript client library. If you don't include this file, you won't be able to use end points in your front end. The client libraries provide the glue that lets your app use end points. So you will also notice so after we bring it in when onload successful we call the init function and this init function actually defined in hello.js. We'll look at that just a minute. The rest of this page is not so exciting, we have a heading, then we have to fill for the buttons, so this one here is the input_greet_generically and this one here is input_greet_by_name. We also have the field where we let the user enter their name, and that's the name_field, and that's pretty much all this file has. One thing to note, though, is the onclick of the button doesn't have a real value. This is actually a fake value. So when we load the page the first time, these buttons. Don't have any on-click action set, and the reason for that is when these actions are loaded, they're going to need to use endpoints. They're going to use your endpoint functions, and your endpoint functions can't be loaded 'til after the google client library is loaded. So you want to load the google client library first, and then you need to initialize some things, and then you can set the action field buttons. Okay, let's take a look at hello.js. So up here these are just some good resources to read, after the Google Javascript client library has loaded, then this init function is going to be called, and really all these does is it loads your hello world end points APIs. See here this gapi.client.load? This is calling functions in the Google JavaScript Client Library to load your endpoint function. So when you call gapi.client to load your endpoint functions, you specify the endpoint functions to load, specify the version, you specify a callback to call. After your endpoint functions have loaded, and then you must specify the rootpath, which is the path to your endpoints API, and you can construct that rootpath like this. Just basically, wherever your app's running, add /_ah/api. Now if you leave off the rootpath. The load function will work or it will seem to work but when you go to call your endpoint APIs the execution calls won't work and that's because the Google client library will be looking in the Google public APIs instead of looking at the endpoint APIs for your app. So do make sure you specify the root path. Okay, so after we load the hello world endpoints API, we're going to call the load call back function. Here's the load call back, very simple, it just enables the buttons. It might do other things in other apps, but here all we do is enable the buttons. The enable buttons function uses straight up Java script to set the actions on the buttons. So we get the button that you clicked, greet generically, and we set the on click action to be the greet generically function, and we change the value of the button, the label of the button so that the user knows that it's ready for action, and then similarly, we get the greet by name button and we set the action, when it's clicked, to be greet by name, and again we change the label, and just a reminder that we enable the buttons here instead of setting them in index.html because these functions, greetGenerically and greetByName, won't be active until after the hello world end point's API's been loaded and you can't load that till after you've loaded the JavaScript client library. So you don't want the user to be clicking on the buttons before everything's ready. Okay, so more interestingly the greatGenerically function illustrates how to issue a call to an, to one of your own endpoint API. So you construct the request. You need to start with gapi.client. You specify the endpoints API to call, which in this case is helloworldendpoints, and then the actual functional method, which is sayHello. So you construct the request, and then you execute the request, and that's all you have to do to issue the call. You also need to specify a callback to call to process the response when the request is executed, and similarly, greetByName. Does the same thing. Only here we get the name out of the name field. We issue the request, gapi.client.helloworldendpoints.sayHello, and here we do pass the name to the request, and this is how you construct parameters to endpoint functions. Specify the parameter and then the value, and you can add, if we had more, you can add more here. So, for example you can add a second arg, arg2 and specify the value to be value two, and then you execute the request. We're going to the same callback when our request is successful. Okay so here's the call back that gets called when our request is executed successfully and we process the response and the response is always passed to the call back. In this case all we do is throw up a dialogue box, use the alert function, throw up a dialogue box and get the message field out of the response, and going back real quick to the Java. To the hello class, recall that the hello class has a message field. The hello will a point API so we defined so far or return a hello class object, so our responses is going to have a message field. So, now you know how to defined a point functions in java and how to call them from java script in your UI. So now it's your turn to run the Hello World Endpoints application. Go ahead and import the Hello World Endpoints project into Eclipse. And then you run your app on localhost. Then try your app in the web UI. And remember, you get to it by going to localhost: and then your port number. Also go ahead and try your app in the APIs Explorer. And remember, you get to that by going to localhost:8080 or whatever your port number is, _ah/api/explorer. We've tested it out on localhost, then go ahead and run it on appspot. Go to your app on appspot you go to your-app-id.appspot.com. When you've done all those things and your app's running on appspot, go ahead and enter your app ID here so that you can check that it's running. When you've got it all working, then go ahead and extend the code. Add a function greet by period that takes the name and a period or a period's a time of day like morning, afternoon, evening. And return a HelloClass object whose greeting field includes a greeting using the name and the period. For example, if the name is the name is Kippy and the period is morning, the message in the Hello Class would be: Good morning Kippy! And if the name was Ken and the period was evening, the message would be: Good evening, Ken! Add this Endpoints API function to your app, try it out in the API's explorer, and update index with html to allow people to call this function from the UI. So just to remind it to go to the API Explorer. Go to /_ah/api/explorer and when you've got your app working and it's got this new function. This function must have this exact name because we're going to test it and if you use a different name our test won't work. Go ahead and enter your app id here So let's take a look at the code at this new method, greetByPeriod to application. So, here I'm in Hello world and poin.java, I've defined my new function greetByPeriod. Still got the name argument, and it's got a named period argument, period. And just for variety, although the name is @Named period. I'm calling the argument time of day, just to show that whatever the @Named is what is required to be specified in the request. And I'm all doing here is returning new HelloClass name, time of day. HelloClass class, didn't actually have this constructor, so I added it, it's pretty simple. Here's the new construction HelloClass. Pass the name, the period, construct a new message, good, this would be morning, let's say, good morning Lauren. Good morning Lauren. Okay, so let's see if it works. I'm going to run it on the dev server, save my changes, it's always a good thing to do. Mkay, let's go over to the local host in the browser. And I'm going to go straight to the API's explorer. Oh goodness, got an error, that never happens. Failed to retrieve API configs with status: 500. All right, first instinct panic, second instinct go back and check the code. And you see I got the error showing up here too, Failed to retrieve API configs. That means there is something wrong with my end point function. Let's look at hello world end points greetByPeriod all looks good, what's the problem? Aha, it's a copy and paste error. See here, I copy and pasted this from the previous method sayHelloByName. And I forgot to update the function name. So I'll just fix that real quick. You can't have two functions exposed with the same name. Actually greet by period. Save it. And actually when you make changes in the Java code and you save it. You'll usually find that the changes get automatically propagated out to localhost. See it says, reloading the web application, a file has changed. So I don't need to run it again. I'll just go straight to local host, reload the APIs Explorer. Okay good. This time it worked. Now drill down into my API. Here's my new one, greet by period. Enter a name. And it's the afternoon now. And then let's look at the response. There it is. Good afternoon. And then Good afternoon Buttercup, because Buttercup's the name I gave. So one other thing to look at is the code for index.html and hello.js. Take a quick look at those, index.html. Really what we had to do was add the, the new imput field for period is called Period_Field and the new button for the greeting and in Hello.js. And enable buttons that we needed to enable to function for the new button. Here's the new button, input greetByPeriod. We're going to call the function greetByPeriod. We're going to update the button label. Now we have to define greet by period and here it is, it's very similar to greet by name. But we get the name field, we get the value of the name out of the HTML, we get the period out of the period field element. You construct the request. And here we're calling the greetByPeriod function. And then we're specifying the argument. The arguments are name and period. Now because we've called the period, we've named the period argument, at period. This must exactly match. And then we execute it and we call the sayHelloCallBack as before. And again, it throws up an alert dialog box showing us the message in the response. So, that's all there is to it. So, now you've learned the layout of simple AppEngine app that uses endpoints. You started out by getting the project from your udacity's GitHub repository. However, there are various other templates for you to use when you create a Maven project. And these are called archetypes. To create a new Maven project using an archetype, open a console terminal window and change to a directory where you want to build your project. >From the command line invoke Maven by typing mvn archetype:generate. Hit return. If this is the first time you're doing this, Maven needs to actually download some things to show you the available archetypes. Now, we see all the different archetypes that you could use. It's kind of a overwhelming list and you can filter it. So let's see what archetypes we've got for appengine. So I'll enter appengine here. And we've got three here, three appengine archetypes. So let's see what we've got for endpoints. Okay, we've got two. And you can do other filtering if you want. And the archetypes can change over time. But I'm going to go ahead and create a archetype using the hello-endpoints-archetype. So this is similar to the Hello World endpoints project that you got from udacity, but it has a little more functionality and a little more pizzazz to it. So here we want two. So I'm going to enter two and the take the default number 3. And then the group identity is really the package name. So, I'm going to call mine com.google.training, that'll do. And then, I'm going to call mine the artifact can be training. Take the default snapshot. The package is com.google.training. Then it's a quick summary of what we're going to do. Just press Yes and Yes. Okay, build success. So now, if I explore my directory, I have all the files for my project. So now I can go into Eclipse and import this project that I just created from the archetype. Existing Project,and there it is. That's my project. Training's a bit generic so I'm going to change the name. New Hello World. Don't worry about the errors, we'll solve those later. Finish, Continue, and you see over here I have my new Hello World project. And I could just go ahead and deploy that right away to local host. Let's do it. Oh no. Launching dev server has encountered a problem, can't find Maven installation embedded. All right, I forgot about that. You always have to remember this when you get a new project, say okay, then you go to run as run configurations. Then we need to find the one that we just used and we need to make sure that the Maven run time is external, not embedded. Dev App server is now running. Let's go to local host. Okay, I needed to refresh the browser. And you see I've got the new, the UI for the new project. Could also go look at the endpoint APIs that are available here in the API Explorer. This is also called the Hello World API. Or a slightly different greeting. So we'll call, let's call get greeting. Oops, don't know what the ID is. List greetings, and here are the greetings. So, it's up to you if you'd like to go ahead and create that archetype and explore the project. I leave that to you, but I do want you to know that there's lots of different templates available for creating Maven projects. You've learned that the API's explorer lets you try out the API that your application exposes through endpoints. Google uses the API's explorer in the same way, to let you investigate the API that are publicly available for the service that it provides. For example let's consider Google's translation service. You can go to translate.google.com to translate text from one language to another, right in the browser. Hm, wonder what lemon cake is in Spanish? Pastel de limon. I wonder if I said that right? You can use the browser like this to do translations. But you can also write applications that do translations, using the translate API. You can try out the translate API using the APIs explorer. It's easy to find the API explore for Google's public APIs. Just search for it. Here it is, first result. When you go to the APIs Explorer. You see the list of all the APIs that Google provides for developers to use. You can search, or scroll down to the translate API, and click it. Then you see the functions that the translate API exposes. These are functions that you, the developer, can use in your own applications. 'Kay now it's your turn to try at the translate API, using the APIs Explorer. So go to the APIs Explorer for the translation service. To find out the meaning of the name Gundega in English. Gundega is our instructional designer for this course. You could use the language.traslations.list function to translate text. Set the target language to en, which stands for English. When you figured out what Gundega means in English, write it in this text field here. When you submit a translation, you can tell the translation service what the source language is. Or you can let it try to figure out the source language for itself. So, one more thing for you to figure out, is what is a source language for Gundega. When you've figured that out, go ahead and check the appropriate check box. Hopefully, here's how you found out what gundega's name means in English. You'd go to the API's explorer and search or scroll to the translate API. You list the translate API functions, and choose language.translations.list. Enter the text to translate, which in this case is gundega and enter the target language, in this case, en. Then you press the Execute button. And here's the response from that execution. See the request, but more importantly the response. We see that the translated text, is buttercup. What a lovely name. And the detected source language is LV, which is Latvia. Let me check if that's correct. Gundega, where are you from? That is correct, I am indeed from Latvia Alright. Let's have something more concrete to work on. If you've organized events, you've probably used sites like [UNKNOWN] or eventbrite.com. Well, let's say you wanted to create an app to organize conferences. That type of application would need to support at least the following. A user can register, a user can create conferences. Users can attend conferences. And of course, it needs to be accessible both from the browser and the mobile device. Well, we're going to create such an application. And it's going to be called Conference Central. And you're tasked to build it. And since it needs to support multiple backends, you will use Cloud Endpoints to create this application. Let's get started with Conference Central, by having you download the skeleton code. Now, let's take a quick tour of the completed Conference Central application that you will build. But before we do that, let's do a quick demo of the finished application. As you can see, you're presented with a very nice landing page for Conference Central. And if we scroll down, you can see options to view conferences. Create conferences and update your profile. But, before that, let's sign into the application. Sign in, we'll use Google Plus sign in. Once we are signed into the application, we can start to explore the functionality. I can, for example, go to my profile where my personal information is stored. I can also show the registered conferences. So here you can see the name of the conference. The city where it will be in. The start date, organizer, how many people are registered to conference. And how many tickets are available to the conference. You can also query for different conferences. For example, the ones you've created. Or the ones that you will attend. You can also query by other types of properties. And you can view the details for a conference. You can also of course, create new conferences. Well that's an overview of Conference Central. The application that you will build and run in the Google Cloud. Now it's time for you to do some work and get you started building Conference Central. Good luck. I'm sure you're raring to get to work on the conference central application. You've already downloaded the code from GitHub. Let's take a look at the layout of the folders in the downloaded code. So here's where I downloaded the code. You see there's a folder for each lesson, lesson two, lesson three, and so on. Inside each folder, you see folders containing the code to import into Eclipse. You already imported this one, the Hello endpoints project. And then next, you're going to be importing the first of the central Conference Central projects, which is this one here. Some folders like Lesson four include partial code. These folders contain classes or fragments of code that you'll be adding to your project in that lesson. For the Conference Central application, we provide starting code for each lesson. You can start working on it with a starting code in the Lesson two folder and keep working on it throughout the course. At any point if you need, you can import the starting project for that lesson. You might want to do that for example, if you didn't finish all the coding exercises in the previous lesson. So now, it's time to import the Conference Central project from the lesson two folder into Eclipse. [BLANK_AUDIO] And down here in the advanced section if you want, you can enter a name for your project. Every Maven project has an artifact which is used as its name, but you didn't create the artifact for this project, so feel free to add your own name if you want. So see up here, I have my Conference Central project and the Java code is inside the SLC folder, inside Con > Google > Deverel > Training > Conference. And you'll see the different packages in the conference package. So go ahead and import the project into Eclipse, and then answer a couple of questions. The two files you're going to be working with in this lesson are profile.java and conferenceapi.java. When you've figured out what packages they're in, come enter the values here. Where is profile.java, and which package is conferenceapi.java are in? The profile class is in the package com.google.devrel.training.conference.domain and the conference API class is in com.google.devre.training.conference.spi. Now the conference API class contains functions that are exposed through endpoints and you'll see that the package it's in is spi. A convention has developed to use SPI to indicate endpoints. I think it's got something to do with the original internal name for the endpoints project at Google but don't quote me on that but just remember when you see spi it usually means endpoints. Let's take a look at the conference API class. This class defines the API that are exposed through endpoints. See this API annotation right here? This is what indicates it. This class contains functions to be exposed through endpoints. There are rules around how you can name the API and one of the rules is that the API name must start with a lowercase letter. So far this class contains a few methods. The one that we're going to be looking at in this lesson is save profile. Let's take a look at it. Here's the Save Profile Method. You can see up here that we've defined the @Api Method which indicates that this method is going to be exposed through end points. So let's look in to the saved profile method. You see it defines a bunch of fields user ID, main email, display name, t-shirt size. For the display name and the t-shirt size we've set some default values. And when you're working with your code you can change these default values as you like. You'll see that the code contains a bunch of to do's. You're going to be filling in these to do's, and the numbers indicate the order in which to do them. So obviously, you do to do one before you do to do two. So the other thing that this method does is it creates a new profile object, passing in the user ID, the display name, main email, the t-shirt size. And then it returns a profile. So at this point, it doesn't really do a whole lot except create and return a Profile object. So let's take a quick look at the Profile class. Here's the Profile class in an editor. And not surprisingly, it takes displayName, mainEmail, teeShirtSize. These are the fields that get passed in to it. When it's constructed and the constructor just takes the values that are passed in and puts them into appropriate fields. The class also contains getter methods for these fields, it doesn't contain setter methods, because we only want the values to be set at construction time. So now let's run the app and see what happens. So, we're going to deploy to local host. Okay and while the deployment is going on, you'll see a bunch of messages. And at the end you should see this INFO: Dev App Server is now running. So, now let's go to the browser and see what we can see. So we want to look at the app in the APIs explorer. So you go to the local host colon, what ever your port number is, in my case is 8080 and then is _ah/api/explorer. And then, you see the API explorer, and you see the conference API, so we can drill down into it, couple methods. We haven't done anything with the other method. We'll just look at save profile. Let's see what happens if we execute save profile function. Just go ahead and execute it. And we didn't provide any input parameters so we just go the default response. So, which is a profile object containing the display name, that the default that we set and the t-shirt size. Doesn't know what the t-shirt size is yet because you haven't told it. So go ahead and post a video if you like and try this out for yourself now. Now lets take a look at the profile form class in the form package. You see it finds fields display name, and t-shirt size. It also defines enum's limit the t-shirt size, because there is only a certain range of values for t-shirt size. We're going to update the safe profile method in conference API, to restrict the input data to display name and tee shirt size. it's easy to do that simply by specifying profile form as the input data argument. So here I'm looking at the save profile method in the conference API class, and you'll see I've passed in profile form as an argument. So, now that we pass a profile form into the save profile method, we need to use it. So, I've added the code to get the display name out of the profile form, and also to get the t-shirt size out of the profile form. For the T shirt size, we only want to set it if the profile form actually sent it, so we added the conditional check that it's not now. For the display name, I'm not adding that extra check because later on, we'll be setting a default display name based on the user's email, but we don't know that just yet. Now we can try out our changes. So now we'll take a look and see if our changes got propagated to the API's Explorer. You may find that you need to refresh the API's Explorer to get the latest changes. So you drill down to the conference API and again with the safe profile, look at the safe profile and here you'll see now, here you'll see now, that we have the request body property showing up or the request property field showing up. If you click in it, and this is really cool, you'll see the add a property menu. You go ahead and click that to bring the menu up, and it'll show you the properties that you're allowed to add. So we're going to add a display name. Let's say we'll se it to Lauren. Now we're going to go ahead and add another property, we'll add a T-shirt size. Set that to M for medium and we execute it and you see the request that got sent? The display name was Lauren, T-shirt size M and we also see the response. Which is the profile that got created. The display name is Lauren, T-shirt size is M. So these are the same fields that are defined in the profile form class. Which is the input of the parameter to the save profile method. So hopefully you've learned how you can restrict the input to the, API by passing the argument in the API function. Now it's your turn to update the save profile function in conference API to take the profile form param as an input argument. You'll be implementing the code marked with TODO1, look for the one. The method has a couple different places where you'll need to be adding code, but this time we're just doing the places marked TODO1. Go ahead and add the profile form argument to the save profile method in the conference API class. And go ahead and do the other sections marked TODO1 to get the arguments out of the profile form argument that gets passed in. When you've made your changes, run your app on localhost and visit it in API's Explorer, and then go ahead and explore. See what happens when you execute the save conference function. Try executing it with and without providing the display name and the T-shirt size parameters. When you've tested it out on localhost and it's working like you think it should, go ahead and deploy your app to app spot. And when you're ready you can enter your app ID here and press submit so Udacity can test your code. Okay, let's take a quick look at the code. So this is where you would have passed the ProfileForm argument in to save profile. And then the other changed you'll have made is that you get the display name out from of the profile form. And you also get the TeeShirtSize out of the pathed in profile form but if the TeeShirtSize is not set by profile form then don't get it out of the profile form. Basically just use a default that we're already using, this is where we set the default up here. Congratulations, you just did a lot of stuff. Let's do a recap. You've wrote your first lines of code and deployed it to App Engine. You got Conference Central up and running. And you've tried out the API Explorer. Don't underestimate the API Explorer. It's a great tool to use to try out the APIs. And it's not limited to your own APIs, you can use it for any Google API. So, all good stuff. But let's now talk about user authentication. Many applications require that a user is registered and signed in before using the application. We will also require this for Conference Central, so let's look at how we do that. It used to be the case that almost every application had to create their own user management system. That would mean that you would have to write all the code from scratch in order for your users to use your applications. Well, good for us. That is not needed anymore. With App Engine, you can use third party authentication with Cloud Endpoints, such as Google Plus sign-in. But also other ones can be used. In Conference Central, we will require a Google account for sign-in. So, how do we know that the user is signed into their Google account when they use Conference Central? That is actually taking care of by Cloud Endpoints. A Cloud Endpoint's API method can optionally take a user object as its first argument and if the user object is not null then the user is signed in, but if it's null then we throw in exception which decline should receive and redirect for sign in. Could it be more easy? Hm, you might say now. But what about security and privacy? Well, that is all taken care of by Google Sign in or a third party authentication provider. So this mechanism is the best of two worlds combined. A simple way to add user authentication to your app, combined with the strong security and privacy standards of Google, all right, that's enough talking, time for you do some coding again by adding user authentication to your Conference Central. Good luck. So your app's now in the state that the saveProfile method knows that when it's called, it should be passed data that conforms to the fields to find in the profile form class, which in practical terms means that the input data can include display name and t-shirt size. If it includes anything else, those fields will be ignored. However, our app wants to use the email. And so we'll need to get the email and we'll do that by getting the email of the logged in user. This of course means the user must be logged in. So next we need to update saveProfile to take a user input argument and to throw an exception if the user isn't logged in. In the saveProfile method you'll be adding a user argument as the first argument. This means that when the saveProfile method is called, the user will be passed to it automatically. If the user isn't locked in, then the user argument's going to be null. It's really easy to get the user, all you have to do is to add this argument to your endpoints method. So even though the user gets passed in, there's no automatic check that the user's logged in. So we need to do that check ourselves. So you can add the code to check if the user is null and if it is, to throw an UnauthorizedException. We also need to update our code to use the email and the user ID. We can get the email and the user ID by calling methods on the user. The user ID uniquely identifies the user, and the email of course is their email which is going to be very handy when the app wants to send emails to them. The method for getting the user ID and the email are fairly intuitive. Get email. Get user ID. Wouldn't be too hard to guess those. We already have the code for getting the display name out of the profile form. But what if the user doesn't provide a display name? We can write code to set a default display name based on their email. The ConferenceAPI class already provides a function extractDefaultDisplayNameFromEmail, which basically gets your name from your email but leaves off the @domain part. So for example, if your email is lemoncake@example.com then the display name simply becomes lemoncake. The server's pretty easy to just add the code to check if the displayName is null, and if it is to call this function, we already wrote the function for you. Obviously, need to save all your changes, then redeploy, and see what happens. Now, let's see what happens when we try out our app in the APIs Explorer. Just to be sure you're not logged in, go to the APIs Explorer in an incognito window in Chrome. Okay, let's see. Save profile and execute. Oh, now, look. This method requires you to be authenticated. You may need to activate the Toggle Bar to authorize your request using OAuth 2.0. So the API's Explorer knows that we're not logged and that it requires a user. So we have to activate it. The only thing our app's doing right now with user information is getting their email. So it's asking the user to give permission for the app to get their email. Now, let's resubmit. Maybe I'll add some properties. That's teeShirtSize small and we execute. Now you see that the request went through. The request, the display name is Knikki and the t-shirt size is S, which is what I input. And you'll see the response includes the display name, the main email, the t-shirt size, and the user ID. One thing to notice about running your app on localhost is that no matter what your real email is, your email is going to be interpreted as example@example.com. And if your API doesn't throw an exception, if the user's not logged in, then the user's going to be set to test@example.com. And you can if you like, run this again without providing the display name. Let's execute it. And this time you see in the response that the display name is inferred from the email. Now you're going to write the code to make sure that the user's logged in, if they try to use the saveProfile function. Look for the places marked TODO 2 in the saveProfile method in the Conference API class. You're going to want to go ahead and add final User user as the first argument to saveProfile. The user argument has to be the first argument and the argument that defines the data structure of the input fields is the second argument and in our case, that's profile form. Then go ahead and add the check to make sure that the user is logged in. If the user is null, throw an UnauthorizedException exception. You'll also want to get the userid. And the users email out of the user object that gets passed in. And then use the user id and email to set the appropriate fields. Test your app by using the API's Explorer on local host. You should find, that when you try to use the saveProfile method. You must be logged in and you can use that simulation button in the top right of the API's Explorer to simulate logging in. When you've made your code changes and verified they work on local host, go ahead and deploy to appspot. Then go ahead and enter your APP Id here, so that Udacity can test your app Okay, let's take a quick look at the code. Here's where we entered the user argument, passed the user argument. Here's where we check if the user is now and if it is throw unauthorized exception. Here's where we set the default display name if the user doesn't submit it in the form. Yup and that's all there is to it, so we've defined a wonderful safe profile method except it doesn't actually save anything. The next lesson you are going to learn to use the data store to save your data. Congratulations, we're at the end of Lesson 2. In this lesson, we looked at the App Engine development cycle and how to create an App Engine project. We also looked at Cloud Endpoints that allows you to build a single backend that can work with many different frontend device technologies. Together with Cloud Endpoints, we explore the API explorer, that allows you to test your backend and also other Google services. And finally, we got conference central up and running in your App Engine project, which is great, you've got a real application running in the Google Cloud now. In Lesson 3 we have a look at storage. It'll be fun. Join us. So now when you're up and running with conference central you have a pretty good idea of how to write and deploy app engine applications. In the last lesson we also covered usage management and we added it to conference central so only authenticated users can access the application. When you write applications you very often need to store data. And as you know, there are a number of ways you can do this. App Engine is no exception. It can work with a number of different storage technologies. But there is one that is particularly important, it's called Datastore. [BLANK_AUDIO] This is the Big Table restaurant here at Google. You may have heard of Big Table. It's a technology Google created and published a famous paper about in 2006. Big Table allows unlimited amount of data to be stored and searched effectively. And many of the huge services being run here at Google chose Big Table to store data. You know what? App Engine Datastore also uses Big Table. That means that your applications ge the same massive scale. Isn't that great? Hm, but I'm starting to feel a little bit hungry. Hey! I think I'll go in, and get a big bite in the Big Table restaurant! See you in class! [NOISE] Datastore is a database that runs in the Google Cloud, and it's available to any App Engine application. As you already heard, it is built on big table, which is used by many of the huge services being run at Google. So, that also gives datastore unlimited scalability. Please see the instructor comments for more information on big table. Datastore is a no sequel database and to be more specific, it is a key-value, column-oriented store. It is key-value because the way you get and put the information, is very similar to that of hash tables or associative arrays in programming languages. And it's column-oriented which means that columns, not rows, are stored together, which means better performance and scalability for certain operations. This also means that Datastore is not like a traditional relational database system using SQL. The design of Datastore allows you to create applications operating at Google scale. And by that, we mean that your application can scale indefinitely, using distribution in the same way as many of the very big Google services do. This means that your data is not only stored on one computer or file system, but on multiple ones. Even in separate data centers, these type of distribution increases performance as you can retrieve data from these locations in parallel. Your application does not need to do anything extra to get all of this value. This is one of the great benefits using Datastore. You don't have to think about it, because Datastore automatically manages the scalability. However, this also means that you need to design your data model to take advantage of this. And when the data is stored in multiple locations, you also replicate the data. This means, you can always rely on that data being available. Because even if there is a failure somewhere, for example, a disk fails or lightning strikes and destroys a data center. That data is always available from another location. So with the design of data storage, you get both scalability and availability without having to do anything. It's quite amazing. But now it's your turn. Please tell us a little bit about what storage technologies you are familiar with. Select the ones you have used when creating applications. Have you used local file system, shared file system, such as nas or san? Cloud file storage, such as Google Drive, Dropbox, etc. Relational databases, such as Oracle, MS SQL Server, MySQL. NoSQL databases, such as Couch DB, Redis, MongoDB. Or even the Google App Engine Datastore. Or if you use something else, please specify it here. So if I was to answer this quiz, I would have to cross local filesystem, shared filesystem, cloud file storage, relational databases, NoSQL databases, and the Google App Engine datastore. Wow, is that good or bad? So now it's time to cover the building blocks to use when doing datestore modelling. They are kind, entity, and property. Let's start with kind shall we? A kind is a name that defines a particular structure. For our conference central application, two different kinds are, for example, profile and conference. A kind is similar to the concept of classes in object oriented programming. Given a kind you can create many entities of that kind, so in this picture we can do three entities, one for the profile kind and two for the conference kind. And as you can see entities are very similar to the concept of objects in object oriented programming, and each entity holds a set of properties which are highlighted by the red sections in this picture, and by now you can see that properties are very similar to the concept of fields, members, or attributes in object oriented programming. In fact, you can also find similarities with the relational of database modeling. Let's look at the table that summarizes these things. So the kind in app engine datastore can be thought of as a class in object oriented programming and as a table in relational database model, and an entity in app engine datastore can be thought of as an object in object oriented programming or as a row in relational database modeling. And finally, a property in Datastore can be thought of as a field or attribute in object oriented programming, and that's a colomn, in relational database modeling. But, this is on a very high level. Since there are many things that differ in Datastore compared to the other technologies, you shouldn't consider these as direct technology. It could help you out in the beginning, but as we dig deeper into how data store works, you will start to see more and more differences All right, let's do a quiz. Imagine that we are modeling sports league in data store. Which of the following would be best represented at a kind, entity or property? A team, a game, the winning team, a player, a player name. A Team is probably best modeled as a Kind. It's a concrete structure that can have many entities. A Game is also best modeled as a Kind, for the same reasons as for Team. The Winning Team is probably best modeled as an Entity. But, this answer is not so straightforward. It could, for example, be a Property Value in an Entity. A Player is probably best modeled as a Kind for the same reasons as Team and Game. And, the Player Name sounds like it's modeled through a Property Value. I hope you did well on the quiz. All right, that's an introduction to DataStore. Now, it's about time to check out some code, don't you think? Let's do that. Good luck. Welcome to the coding portions of lesson three. In this lesson, we're going to learn how to use Objectify to save entities in the datastore. We're going to use entities of kind profile to save user profile information. And we're going to learn how to get the user ID of a logged in user to use it to generate a unique ID for the entity's key. Once we've created some data and saved it in the datastore, we're going to use the Datastore Viewer in the Admin Console to look at the data that we've saved. Make sure that it saved like we thought it would. And there's no point putting data into the datastore if you can't get it back out. So then we're going to learn how to get an entity out of the datastore if you know its key. Let's go create some profiles. Now we're going to go ahead and look at the code for defining an entity. Let's imagine that you want to store entities of kind recipe. Maybe you like chocolate cake, especially chocolate cake covered in strawberries and sprinkles or maybe you prefer pavlova. This one looks really good with kiwis and strawberries. For whatever kind of cake you like, your recipe needs some properties. Obviously it has to have a name, a list of ingredients, some instructions, perhaps indicate the number of servings. And you can say whether it's vegetarian or not. This might not be quite so important for cakes but could be really important for like, say, lasagna. If you use the native App Engine data store low level Java API. You need to create entities with instances of the entity class. However, the entity class is final so you can't subclass it and you can't add fields to it. Fortunately for us, there's an open source library called Objectify. Objectify makes it easier to work with entities by allowing you to define classes that represent entities of a particular kind. Then you simply add fields to the class for each property that you want your entities to have. So, here's the code for the Recipe entity class. Notice the imports, these packages provide the objectify functionality for defining entities. Okay, next, notice this @Entity annotation. This annotation indicates that class represents an entity. The class name is the kind of the entity. So here we define the entities of kind recipe. This entity class has the properties recipe ID, name, vegetarian, servings, and so on. When you use objectify, every entity class must have one, and only one property, marked with the @ID annotation. This is the entity's ID and it's used to help uniquely identify the entity. You see that the rest of this class is just a regular old Java class. It could have more constructors and methods if you wanted. As we saw in the previous code example, properties can have different types. These are called property types. For the recipe kind, some of the property names and types were name, which was a string. Vegetarian, a boolean indicator. And the number of servings, an integer. But these are just a few property types. In fact, Datastore supports a lot more property types. And we mean, a lot. The official documentation on developers.google.com lists around 20 of them. In this class, we're only going to use a small subset of these. And the ones you can see listed here are some of the most common properties. Integers. Floating-point numbers. Strings. Dates and binary data. Okay, time for you to do some work. That's right, it's quiz time again. In the instructors column you have a link, go to this link and explore the supported property types. Then answer the following question, which are property types? String, geographical point, name, rating and zip code. Good luck. The correct answer is string. That's a property type. Geographical point is also a property type. And rating is a property type. Call to discuss some forums why there is a type rating. Now the time has come for you to do some coding. So happy coding. You've already taken a look at the profile class, but so far it doesn't define an entity. What you're going to be doing now is going in and adding the annotations to make it an entity. You can look for the places marked to do in profile.java, it's just a couple things you need to do. You need to add the annotation to indicate that the class is an entity, and when you've done that go ahead and write the annotation here. You also need to add the annotation to indicate that the user ID is a property that's going to be used as a unique identifier for profile entities. When you're done just go ahead and add the annotation for identifying the unique ID field here. Okay, so here we're looking at the profile.java class. You can see the @Entity annotation marks this as an entity and the @Id annotation indicates that the user ID is to be used as the ID of this entity. That's all you needed to do in this class, now your profile is an entity. Welcome back. I hope that exercise went great. Now, let's talk about another important Datastore concept, keys. When you store an entity in the Datastore, the Datastore will assign a key to it. This key uniquely identifies the entity and it's used for many different purposes. They are two ways a key can be generated. Let's take a look. The first one is when Datastore automatically generates this key. Let's say we define the profile kind with these properties. And inserted it for the first time. In this case, the Datastore will automatically assign a key value to it. The other way is that you specify what is called a key name or ID. In this case, Datastore will use that value to generate the key. This is a good alternative when you have something that is unique for each entity. Because it can clearly take us to our front entity based on this value so it's easier to find. But observe that statement. The Keyname/ID must be unique for all entities of that kind. For our profile kind that is exactly the case because we have decided to use the user ID to to uniquely identify each profile identity. The value of having user ID as the key name is that we can retrieve the profile entity directly using this value. And remember, since the user object is the first parameter to cloud endpoints API methods. It will become a convenient way to get the profile, but we'll look more into this later. If you are familiar with relational database modeling, you probably see that this is very similar to the concept of a primary key. There, as well as with Datastore, you have the option of letting the database generate the primary key or use the value of your choice. But now, it's for you to do some work All right so the question is, which of the following properties is a good keyname/ID? Select all that apply, bank account number, date, price, or an email address. Let's look at the answer. A bank account number, that sounds pretty unique. So that could be a good candidate to have as a keyname/ID. A date, is probably not a good keyname/ID, because it's most likely not unique across the entities. But it could be. It all depends on the modeling, of course. The price, does not sound like a good keyname/ID either for the same reasons I stated. An email address. Yeah, that could be a good keyname/ID. Because it's very likely, it's unique across entities. All right. I hope you did well. So far, you've defined the profile entity class in your application. We don't actually yet do anything with it. The next step is to add the code to saveProfiles in the datastore. But you've already been working in the conference api.java class and remember that it defines a saveProfle method, which doesn't actually yet do any saving. But it will, when we're done with it. The next step is to actually write the code, that saves the entity in the datastore. And it's marked in the file for you as TODO 3. But before I set you loose to do that, I just want to review how to save entities in the datastore using objectify. Okay. So, we're going to look at how to save entities in the datastore using objectify. You use your objectify service. The, the ofy method, you call the save method, call the entity method passing the entity to actually save and then, now. The now means, go ahead and do it right now. It's usual practice to define a static ofy method, so you can simplify the code like this. Just call ofy. So, if you remember we talked about recipes a little while ago. Here's how you might save a recipe. So, this assumes that we've created a recipe entity bound with variable recipe one, so we just pass in recipe one as the entity to save, and there it is. Now it's time for you to add the functionality to save entities to your app. Let's see how you can achieve that. Okay. So here I'm looking at the saveProfile method in the ConferenceAPI class. If you recall, we already have the code to create a new profile. We just call new on the profile, and pass in the arguments that we need. Creating a new profile entity is as simple as calling new on the profile class. If we weren't using objectify, the code would be more complicated. You already have the code to create a new profile object, but you don't need to make any changes now that the profile has been identified as an entity. However, creating an entity doesn't automatically save it in the data store. You have to explicitly save it if you want it saved. Okay, I'm going to go ahead and add the code to save the profile entity in the data store. You're going to be writing this code yourself in your own app in just a minute. Now, I'll run the app again on local host, and go to the APIs Explorer. So here I am in the APIs Explorer and I'm going to go into the Save Profile method again. And, execute it. And have Lemon Cake as my display name. Set my TeeShirtSize to M, and execute it. Oops, I forgot to authorize. Let's try that again because that's not authorized. Authorize. Now I can execute the function again, I don't need to enter the values, just press Execute. And there it goes. It's creating my profile. And you see here, the request set the display name to Lemon Cake, T shirt size to medium to M. Response returned profile with these fields. So the response shows that the profile was created. But this time, hopefully it was more than created, it was actually saved in the data store. And we can use the data store admin to check that. So now I'm going to go to the admin console on local host. To get to the admin console, you go to the port where your app is running, which is for me that's localhost:8080. And then it's /_ah/admin and this takes us to the Datastore view. The Datastore admin for local host opens. You can see here that it doesn't know what my app ID is. Says your app ID, and that's okay, because local host doesn't care what the app ID is. Course when I when actually want to deploy to appspot I will need to provide a real app ID. The admin console opens by default showing the Datastore Viewer. But if you're somewhere else and you want to get back to the Datastore Viewer, or for some reason it doesn't open there by default, you just click this Datastore Viewer and there you are in the Datastore Viewer. This entity kind menu shows the different kinds of entities that are stored in your Datastore. Right now, the only one we've got is Profile. You'll click List Entities, to seal the entities of that kind that have already been saved. There'll probably be only one entity now, which is the profile that we just saved. So the data store viewer shows you the entities, it shows you the properties. We've got displayName, mainEmail, teeShirtSize. Okay, so that was just a quick review of how to save the entity in the data store, and how to go to the admin console on local host to look at your entities. You're going to be doing that now. Go ahead and update the save profile method in conference API to save the profile entity in the data store. You can look for the place marked TODO 3 in the save profile method and that's where you add the code to save the entity. When you've added the code, go ahead and run your app on localhost and then go to the API's explorer and execute the save profile method. Use the API's explorer to try out the updated save profile function. You'll see the responses you did before but you'll need to go to the admin console to check that the profile entity was saved in the data store. And just a reminder, to get to the admin console on localhost, you go to localhost colon port number like localhost colon ADAT and then you type underscore Slash ADMIN. What properties does your profile entity show in the admin console? Check each one that applies. How did it go writing the code to save the profile in the datastore? Let's take a quick look at the code. Here I am, the saveProfile method. And we'll scroll down to where we create the profile and save it. So we already have this line of code to create the profile and then saving it in the entity was this simple, ofy.save.entity(profile).now. Okay, now let's see what properties show up in the datastore admin. So here we are in the Datastore Viewer looking at the profile entity for my profile Lemon Cake. See here, we have to display name and the other properties that we see are the mainEmail and the teeShirtSize. The property that's missing is User ID. The User ID was specified as the ID for the entity and it's used in the entity key. The ID field isn't saved as a separated property on the entity. Okay, let's go back and hear what Magnus has to say next. [SOUND]. Wow. Your code just inserted a piece of data into Google's data center. Isn't that exciting? Well keep moving along. [SOUND] If you'd play your application to App Spot, you can explore the entities in the data store using the Admin Console. Let's take a quick demo of how to get there. So to get to the Admin Console, you go to console.developers.google.com. And it will list your projects. This is one project here, and then you click on that. You click on the project that you want to investigate. And it will take you to the dashboard for your project. So you see there's a, an App Engine section that let's you get to various. Things about App Engine, I think you already looked at that. So if you click down here, you see the cloud data store option. And this will take you to the dashboard for your data store. Dashboard shows you various kinds of information about your project. You can get statistics of all your entities, you get breakdown by property type. You can get the total size of the entities that are stored in the data store. See this here, the indexes? You'll be learning about indexes really soon. So, go ahead, you can go ahead and explore the, the dashboard, see what kind of information is in there. What I really want to talk about is the query. So, if you click query, it takes you to the page where you can find out information about the entities that have been saved. This kind of menu, just like in the local host. Admin Console lists the kinds of entities that are stored. Right now I only have profile, and these other two things are internal to App Engine. I'm looking at the entities of kind profile, I've only got one, that's the profile that I just created. You can see the display name, the main email, the tee shirt size. Can drill down into it if you want. You can even change the values here. Obviously you'd really only want to do that during development. This is where you would come to check your entities. And it can be a really useful tool. Letâ€™s turn to key conflicts. Remember we talked about two different ways to assign a key. The first where datastore automatically assigns a key value for you. And the second was you can provide a key name ID that generates the key. And when you provide a keyname ID, you're responsible for ensuring that they are unique for all entities of that kind. This is important, because otherwise you will generate a key conflict. That's right, we do not want to cause a datastore key conflict. That's for sure. Let's see what they are and how we can avoid them. Let's go back to recipes for a moment. Say, for example, that we have the recipe kind that we worked with before. And we want to insert a vegetarian lasagna entity and a meat lasagna entity into the datastore. Well, if I let datastore generate the keys then it will make sure to create two unique keys. One for the vegetarian lasagna entity. And one for the meat lasagna entity. So two unique keys. But let's say that I instead want to generate a key from a keyname ID that I specify. Then it is very important that I can guarantee that those are unique. In this example, it is very bad to choose lasagna as a keyname ID if both vegetarian lasagna and meat lasagna would have lasagna as the key name. The reason is that when you insert the first entity, it will get it's key based on the key name ID lasagna. But when you later insert the meat lasagna, it will override the vegetarian lasagna, because it also has the key name/ID lasagna. So again, remember this, when you are explicitly setting a key name ID. You have to ensure that they will be unique and in our application, it is safe to use user ID, because the uniqueness of it is ensured by the user authentication system. As it turns out, this is actually quite convenient since it makes it easy to retrieve the profile from the data store. That's exactly the code we will add in the coming exercise. Have fun. Now let's look at the code for getting an entity out of the datastore. Since you know the key for a profile entity, as Mark has explained, you can use the key to easily yank the, the entity out of the datastore. You've already learned how to save entities and how to view them in the admin console. The obvious next step is to extend the conference center application to get the profile entities back out of the datastore. With objectify, you use the ofy.load function to load an entity. You can get an entity by key or you can query for entities that match search criteria. You'll be learning how to retrieve entities by key first. Then in the next lesson you'll learn how to query for entities that satisfy certain criteria. Let's take a look at the code to get an entity out of the data store. Ofy gets the objectify service. Load, loads the entity. Key, is the key of the entity to load. And now means, do it now, don't wait, in other words, do it synchronously. That's all well and good, but how do you get the key? You need to know the unique ID that was used to generate the key. Remember how you used the [UNKNOWN] annotation to identify user ID as the ID when creating a profile entity. The ID is used to generate the key. The ID isn't the key by itself but its essential to generating the key. So, for any user who's logged in, your app can retrieve the user ID, which means you can generate the key and consequently get the profile entity directly from the datastore. As you've already learned, the user is parsed in the call to the end points method and you can simply get the user ID like this, getUserId. To get a key, you call the create method on the key class and you need to specify the kind of entity that you want to retrieve. Here entity's actually a variable, so let's say we were creating a key for recipe, this would be recipe.class. Then you need to pass the ID that was used to generate the key, in this case we're using user ID. So now we know the ID and we know the key, we can get the entity from the data store using the key. Now it's your turn to work on your conference central app. You need to complete the getProfile method by filling in the TODO to load and return the profile entity. You'll need to get the userID, you'll need to create the key, and you get the profile, and then you return the profile. When you've implemented getProfile, you can try it out in the APIs Explorer Okay. So I went ahead and added the code to get the profile, and you'll be doing that yourself in just a minute. Before we run getProfile, gotta quickly run saveProfile, to make sure we actually have a profile to get. I'll save the profile. And you see that the response shows that the profile was created, hopefully saved. So now let's try out getProfile. So I will execute this. And yes, we got the profile. That means the getProfile method is working great. Now it's your turn to implement getProfile in conference API. Look for where it says TODO and then you're going to need to add the code to get the profile from the datastore. When you've written the code, go ahead and run the app on local host and use the APIs Explorer to try out the getProfile function. When you're done, go ahead and finish the code statements here. Enter the code to get the user ID, enter the code to get the key, enter the code to get the profile entity out of the datastore. So let's take a look at the code for getting the profile out of the data store. So here's the getProfile method. Throws an exception if the user is not authorized. We get the key, get the user ID to use as the ID for the key. We create the key, and then we get the profile. Now ofy.load returns an object. So, in this case, we want it to be kind profile, class profile. So, we have to cast it as a profile When you save an entity with a key, it creates a new entity in the data store with that key. As you found out earlier, this creates a key conflict. If an entity with that key already exists, it is out of luck and it gets chucked out. It's overwritten in the data store. So if you want to update an existing entity, first you need to get it out of the data store, then you make your updates and then you save it back into the data store again. So back here in the save profile method of that conference API, whenever we've been saving our profile the first thing we do is create a new profile with the user ID. That means that actually every time you update your profile, you're not really updating it, you'll create a new profile entity which overrides the existing profile entity. You can see how that plays out in the API Explorer. Now that we've implemented get profile, we can just call get profile to get the existing profile for the current user. So lets do that. Okay. Lets see, so my display name is "Chocolate Cake" and my t-shirt size is XL. Now, lets say I want to change that, I want to change my t-shirt size, so I go to saveProfile and the only thing I want to do is to change my t-shirt size from XL to XS, extra small, this time. Now we'll execute. And what would be really nice, would be that the only thing that changes it the t-shirt size. So let's see if it will happen. But, no, that's not what happens. You see how the display name gets set back to the default, which is example and my t-shirt size did change. What should really happen, the saveProfile method should get the existing profile and only update the fields that have changed. So that's going to be your next task. So you're going to need to update the save profile method in the Conference API class so that, see here where we get the profile, every time we get the profile we create new one. Instead of doing that what we need to do is check if the profile's already in the data store if it is, get it out, if it isn't create a new one and then set the values all passed in by the form. The values that the form doesn't pass in for new entity, use the default values and if the entity already existed, then leave the existing values in the properties. You're also going to need to add a method in the profile class called update profile that takes a display name and the t-shirt size and updates them. If they haven't changed. That is if they aren't now. This method is also cleaned up a bit got rid of some of the variable that we don't really need anymore. So the first thing we do is if the user is null we throw an unauthorized exception. The next thing to do is to get the main email as the user's email and get the user ID. Then we get the display name sent by the request and the TeeShirtSize, sent by the request. Then, this is new. We load the profile. Might not be there, but we go ahead and load it anyway. Then we need to check, that it actually existed. So, check if it's now, then if it is now, that means it didn't already exist. We need to set the display name, either to the value passed in the profile form or otherwise if the display name wasn't parsed, get the default name. And again, similarly with the tee shirt, get the value passed by the form. And it fits null, set it to default which is not specified. In this case, not specified. And then we need to create, actually create the profile. So this was our call, it's our call to create the new profile. However, the profile already exists. Just call, update method, parsing the displayName, and the teeShirtSize. Which remember, one or either of these could in fact be null. And then we save it in the data store as we did before. Here the code has been made more concise, and we return the profile. Now let's take a look at profile.java to look at the update method, which is pretty simple. Takes a displayName and the TeeShirtSize, checks each one if they're null. If they are null, doesn't do anything with that property. If they're not null, that means the user updated that value. So, update the appropriate property, that's all it does. This doesn't do the saving, because remember, we do the saving back here in save profile. All right, let's see if it actually works. So I deployed to local host and came over to the, our old friend API's explorer. We have some profiles, so let's see what they are. So get existing profile, and you see that the name is Apple Turnover, and the tee shirt size is XS. So remember that, Apple Turnover, XS. Now let's save the profile. And we're just going to update one of the properties. Let's change the display name to Icecream Cake. So we'll save that, and the exist, remember that the existing tee shirt size is XS, so lets see what happens. Okay, good. So the display name was set to Icecream name, but the tee shirt size was left as XS. So now we know that we didn't get a new profile, we just updated the existing profile. So far, you've used the APIs Explorer to investigate and test the functions in your applications. You've got the getProfile, the safeProfile. However, Conference Center application includes a full web UI. Each of the pages in the web UI, send calls to the endpoints API on the back end. As you implement the back end functionality, the web pages in the app will start to work. Right now, they don't all work. For example, if you go to Show Conferences, it's not going to find any conferences. It's because the implementation, because you haven't written the code to find conferences. But in this lesson we implemented the code to get and set profiles. So the My Profile page now works. So let's see what happens, if I change my profile. Let me change my t-shirt size to, very small, extra small. Change my display name to Jocelyn B. I'll Update my profile. And the profile has been updated, excellent. When I click the Update Profile button, what happens is that this web page in behind the scenes is sending a call off to the saveProfile endpoint function that you just implemented. The goal of this course is to help you learn how to develop App Engine applications, not to teach you JavaScript. However, I do want to point out the code that makes the call to getProfile and to saveProfile. So, now here we are in Eclipse. And you'll find the code for the webpages or the web UI under SRC, Web app, and you'll see there's the CSS folder, the fonts folder, the IMG, there's index.html, and there's a JavaScript folder JS. And then there's this thing called partials, which is the HTML pages. What I want to look at first is controllers.js, because this has the code that calls the getProfile and the saveProfile methods. So let's look at getProfile. So here's the code that send the call to the getProfile endpoint function. And you see here, it's gapi.client to invoke the client library. And then, conference is the name of the API. And then, getProfile is the method name. And again, we execute. And then, here's the code to call when the request is successfully executed. And in this case, you can see that the code's just right here in line. It's not in a separate function. That this is the callback to call when the call to getProfile succeeds. Let's look at saveProfile. I'll search for it. And here it is. And again, I just wanted to point out, here's the call to gapi.client, or gapi.client. And then conference is the name of the endpoints. Then saveProfile is the method to call. And in this case we're passing at one argument. And then we call the execute, to execute the request. And again, here's the call. Here's. The code to execute in the call back that's called, when saveProfile completes successfully. If saveProfile completes successfully. So that's all I really wanted to point out here. I'm not going to go into the rest of the UI code in detail. I just wanted to show you the hook where the JavaScript issues the call to the endpoint functions. As you go through the course, you're going to be implementing the endpoint functions. And I wanted you to know how they get called from the UI. The conference central application includes both a back-end application that defines the end point function and front-end application that has the web page users functions. So I'm going to call the back-end application, basically I'm going to refer to it as the back-end API and the part of the application that has the web pages I'm going to refer to as the web UI. In our case, they're all in one single application. Got one app ID, we deploy the app, takes the back-end API and takes web the web UI with it. However, the web UI and the back-end API don't have to be in the same application. They could be in completely separate applications, or you could even have multiple applications, that provide different front-end interfaces to the conference back-end API. So here we've got several different applications, each with a different kind of Web UI and we have our conference API running here on the back-end API. However in our case the web UI and the back-end API are in the same application. But our opinion doesn't really care that they're in the same application. You still have to authorize a front-end UI to access the back-end API. So, those are a few things that you need to do before you can start using the web pages in the Conference Central application and these are all around authorizing the web UI for login and giving the web UI permission to use the back-end API So you're going to need to tell the back-end API which client apps are allowed to use it. So here I am in the ConferenceAPI.java class, up where I'm specifying the, the endpoints API. And you'll notice that it has the client IDs. And this one here, the Constants.API.EXPLORER_CLIENT_ID is the client ID for the APIs Explorer and then this one here, Constants.WEB_CLIENT_ID, this is where we're specifying the client IDs of other apps, not the APIs Explorer, but other web apps that are allowed to use this application. And if you knew the client ID, you could just write it out here if you wanted, but we're using this Constants class to hold our, our WEB_CLIENT_ID. So, lets take a look at the constants class. And you'll see here in the Constants class that we define the client ID and to start with, there's no value, so lets replace this with your client ID. So, yeah, it is a value, but it's not a real value. So you're going to need to go ahead and put your client ID in here. And just a reminder that you get your client ID in the developers console. And the client ID includes everything. It's not just the number. It's the whole thing that you see in the developers console up to the .com part, if you see that on yours. And you can just copy and paste the client ID from the developers console. What we've done is that we've set that the applications with web client ID as specified are allowed to access our endpoints APIs, so we basically granted permission to the UI to use our endpoints. But another thing you have to do is that on the client side, on the JavaScript side, on the web, the web app UI side, you have to, when the, when the user logs in, you need to run the authentication process, so you need to identify yourself. So you'll need to go into the web app folder and then into the js folder and this time you're going to have to go to app.js. One of the things that this file does is that it runs your authentication process when, when a user logs in. And you're going to need to set the appropriate client ID in here, so you can go ahead and search for CLIENT-ID. And it's uppercase CLIENT-ID. And you'll see here again that the CLIENT-ID is just a, a placeholder. So you're going to need to put your client ID right here. And again, that's a client ID that you get from the developers console. Here it's being used for the client ID to identify itself during the authentication process. So, here's my client ID and then of course, save it. And it hasn't mattered until now that the client ID wasn't set here because we haven't been using the webpages in the Conference Central application to test our functions. I think if you try to log in using the webpages, you will have found that it didn't work because it didn't have its CLIENT_ID set. Another thing you need to make sure is that your consent screen has a product name. So again, you'd go to your project in the developers console, go to APIs & auth. Then you click Consent screen here, down here. And then first thing you see is it shows you what your consent screen would look like. And this is the screen that gets shown to users when they go to use your application. And you do need to scroll down. Don't be put off that it's a little bit faded. Just go ahead and scroll down. The email address does need to have a value. And then specify a product name for your application, basically your application name. Okay, one last thing you need to do is to add the JavaScript Cross-Origin in the client application. So for this, you're going to go back to the credentials screen in the developer console, and your client ID for web application. You're going to add your JavaScript origins. So click Edit Settings. Make sure you're in the right box for JavaScript Origins and then you need to add two here. You need to add the URL for where your app is when it's running on appspot and you need to add the URL for localhost. You'd go ahead and add those. If your app running on appspot, you do need to specify HTTPS for secure connection. For the app running on localhost, it's just HTTP, because the dev server running on localhost doesn't support HTTPS. So you go ahead and you add those and you say Update, and basically what this is doing is it's giving permission to these URLs to run JavaScript to access your app. And you need to do this even though this is the app itself, right? I'm in here. My app is cake-hut and I'm giving permission to cake-hut to run JavaScript to access cake-hut. And after you've done all of these things, you should find that the My Profile page works for you. Now it's your turn to setup the client ID's, so that you can use the My Profile page in your Conference Central application. After you get everything hooked up, you'll find that more and more of the web pages start to work, as you add more functionality in the coming exercises. So I'm just going to go over the things that you need to do to hook up the web UI to the backend API. going to need to get the client ID. To do that, just go to the developer's console and in your web, in your client ID for web application, you can get your client ID. And then you're going to set the web client ID in Constants.java so that your end points API knows which client IDs are allowed to access it. Then you're also going to add the client ID in app.js so that your web UI can identify itself properly when it goes through the authentication process. Then you're going to need to make sure that the developer email and the product name are set in the consent screen. And then also in the developers console, you're going to need to set the JavaScript cross origin so that the client application knows which URL's are allowed to access it when they run JavaScript. So this you do in the developer's console. These two are in code. And these again, you do back in the Developer Console. So after you've gone through these steps, then deploy your app. And you could do it on localhost or on appspot. And then go to, to My Profile page, and test it. And as you go through each of these steps, come here and just check off the step, as you do them. Suppose you wrote an application called chocolate chooser, that implements the chocolate back in API using endpoints. The app ID for chocolate chooser is choc-appID, the client ID is 123choc. Now let's suppose someone else writes an application called, let's say, devastating desserts that uses JavaScript to access the chocolate API. The app ID is dev-desserts, and the client ID is 123devdes. And this devastating desserts application is all about the UI, so it doesn't have any back end API. So now let's think about the API definition for chocolate API in the chocolate chooser application. So here we've got the API definition. The name is chocolate API version V1. The scopes is email. This basically mean, that we're going to be using the user's email. It's up to you to tell us what would the client ID be here. And go ahead and just enter a specific value. So what did you put for client ID here? What we want is a client ID of the application that wanted to us the backend API. And the app that wants to use the backend API is dev-desserts and its client ID is 123devdes. So hopefully that's what you put. The main thing I want to get across is that in this course, our client, web UI and our backend API are all in the same application. But they don't have to be. But you do have to always authorize the client to use the backend API. Now that you've got significant functionality working in your application, this would be a good time to add some unit tests. In the lesson three folder, of the code that you downloaded from Udacity's GitHub, you'll find the test folder. This folder contains tests that are applicable up to the end of lesson three. Basically, tests for the profile functionality. Probably can't see, but we've got ProfileTest.java, we've got ConferenceApiTest.java. So go ahead and copy the test folder into the SRC source folder where you have your projects, the Conference Central. So you can just drag and drop it. There it is. Now I just want you to go ahead and delete the target directory in this folder. Whenever you run your project, or you run it on Dev Server or you deploy it to appspot, the output from the build all goes into the target directory. And it gets, it'll get recreated if you delete it. And sometimes the old build and the old output files and the new output files don't work well together. So, when in doubt, delete the target directory. Since we're adding test, we want to make sure we're starting with a clean slate. So I'm going to delete it, and there it is. Looks like it's gone, won't stay gone for long, but it's gone for now. Okay. Now let's go to Eclipse. Going to refresh the project, since we've added the test directory. And deleted the target directory. Okay. So target on, target's still there. So whenever you do delete the target directory, it actually pretty much automatically gets recreated right away with a couple of things in it. But it doesn't have everything that's needed. Here down in the source directory, you'll see the test folder now, and it has two tests. It has ProfileTest.java in the domain package, and it has ConferenceApiTest.java in the SPI packet. So let's take a look at the tests. First, I'm going to look at ProfileTest.java. Here we have our class ProfileTest. So I'll start by defining some values that we're going to need in our tasks. And we do the setup, and all we're doing this set, for setup here is we create a new profile and we supply some values. Then we have to tear down method, which one we need. And then here's our first test. We're testing the Getters. Very simple. Just checking, that the values in the profile are in fact values we put in the profile. Then we check what happens when we update the profile. So what we're going to do, is update the display name and the t-shirt size. And then we want to check that the display name is updated, and the t-shirt size is updated. But in fact, the user ID and the email, don't get updated. They need to remain as they were. And then this other function here is commented out, because it tests some functionality that you haven't implemented yet, so the test wouldn't work. Now let's look at ConferenceApiTest.java. So here we are, ConferenceApiTest, and again, the first thing we do is set up some values for testing on. Have our service helper. Do the setup. And in this case, the main thing we're doing is creating a new user with an email, and a user ID. We have the tearDown method. And then we stop testing. So the first thing we do is testing getting the profile first time. Now we test saving the profile. Now we test saving the profile with null values and, so on. Have a look at the different tests that we do, and then you get to a point where it's commented out, and that's because they're testing functionality you haven't implemented. Like, you can't test creating a conference, because we haven't written function to create a conference here. And as you go through the lesson, you can come back into ConferenceApiTest.java. And comment the testing functions, as the functions are ready for testing. Okay. Now we're going to look at running the project when we've got tests. So if we go up to Conference Central, this time I'm going to choose Run As and then Run Configurations. And this is my configuration to run the, run the Dev Server on localhost. And you see here, there is Skip Tests check box. So by default, tests are not skipped. It hasn't mattered up until now, because we haven't had any tests in there. So it didn't matter whether they were skipped or not. But now, the tests will be run. If, if at any point you find that the tests are blocking you or you want to deploy without the test, you can come and click this Skip Tests, but let's not do that. Okay. So I'm going to run. Now I'm running as per normally see the tests? Okay. My Dev Server is running. Let me scroll back up and see what the results of the tests were. Okay. So it run seven tests. There were zero failures. Zero errors, zero skipped, and it took 0.415 seconds, and then here's the summary. Okay, good. Okay. We'll that's all fine. But what happens if you actually do have an error? So to test that, to test the tests. Let's introduce an error. So since we're testing the profile functionality, I'm going to make one of the functions to do with profiles return an unexpected result. Okay. So we have the getProfile method, and this gets the profile associated with the logged in user. And to get the profile entity out of the datastore, we have to first create a key. And we specify the class, which is profile.class. And then the see it's the key, user ID. But let's say we made a mistake, and we put the user ID inside a string. Which is something that does happen. Now, there's no error here. This is a valid kind of value here, so. It doesn't show me an error. Now lets' see what happens when we run our tests. Now I'm going to run the project, on localhost. Okay. This time we've got an, an error. Failed to execute, and we got an error in the test. And we got the error in testGetProfile. No huge surprise there. So, you see we have the stack trace. But at the bottom, we have a nice summary where it shows the tests, the gave in error, and how many failures. And now, the other thing I want to show you, it's over in your target directory. May need to refresh your project here. In the target directory, you see a folder called surefire-reports. And this directory contains results of the report. So if we look at ProfileTest.txt, this is not where we had our errors. Zero failures, zero errors. If we look at ConferenceApiTest.txt, whoo, lots of errors. But here, failures. There was, there's actually only one error, but this is stack trace. But now, if we come down, I want you to look at the, the, see what happens with the XML files. If I click on ConferenceApiTest.xml, it'll show me the functions that got called, and the ones with the error, or the failures. In this case here, it takes me straight to where I had the error. The problem I can see right here is that, is that the user ID did not match what was expected. So, I'm going to go ahead now actually and just fix my code before I forget. Okay. There's my code we'll fix. Now when I run it, I won't get any errors. As you continue through the lesson, be sure to add the test for the new functionality as you implement it. In some cases, you'll need to get the test file from the appropriate lesson folders. As you implement new endpoint functions, you can simply uncommon the tests that are already in Conference API Tests. And if you deviate from the code that we have you write, like if you add your own functions or you change what the functions do, then you're going to need to update the tests and add your own tests to make sure that you're testing the functionality that's in your application. Congratulations. We're now at the end of lesson three. In this lesson, we got introduced to Data Store, and kinds, entities, properties, and keys. We also looked at the profile kind and saved it to the data store and retrieved it from the data store. In the next lesson, we will cover data store in a lot more detail. Let's go. Hi, and welcome to lesson four. Conference central is starting to look like an interesting application. In addition to user management that we introduced in lesson two, we also added data store in lesson three. Now it's time to look at data relationships and how to retrieve data and make no mistake about it. There's a lot of moving parts with respect to this. So you better keep your eye on the ball. [SOUND] In addition to data relationships and queries, we will be looking at datastore consistency rules and transactions in this lesson. Now is probably a good time to seriously start to checkout the documentation on the internet as well to become a master of building scalable applications. Let's get started, shall we? Let's start off by looking at two important data relationships when you do modeling in data store. They are ancestor relationships and has-a relationships. Starting off with the ancestor relationship in data store it is possible to specify that an entity has an ancestor entity. There are two important rules for ancestor relationships. First of all, it needs to be assigned when the entity is created. And secondly it can never be changed so those are things to think about when you model an ancestor relationship. And given those rules, please note that the ancestor relationship is not the same as the is-a relationship in object oriented modeling. In conference central, we will use the ancestor relationship for the conference kind that you will create shortly. Where the ancestor will be the user who created the conference. Technically speaking though since the users are identified through their profile entities, so in this case the conferences will have the key of the profile entity as their ancestor key. The other relationship we will be using is the has-a relationship. We will be using this relationship to model conferences which users are attending. To do this we will add a property to the profile entity which specifies the attended conferences. So each profile will have a property that contains the conferences that they are attending, observe that this relationship can easily change. We can deregister from conferences and register to new ones, so it is not bounded by the strict rules of the ancestor relationship. So those are the basics of these relationships and that's also enough theory for now. Time to do some coding. Hi. Welcome to the coding portion of lesson 4. Now we're going to create some conferences. A conference management application really needs to be able to create and save conferences. After we've created some conferences, we're going to learn how to run queries and use filters to query those conferences. For example, suppose you've got a trip planned to San Francisco in June and you want to find out if there's any conferences going on then. I'll show you how to write the code to find out. Then we're going to delve deeper into indexes. We're going to look at the index configuration file and then we're going to use the index viewer in the admin console to explore our indexes, to make sure that they're serving so that our users don't get index non existent errors. Another thing our application really needs to be able to do is to allow users to register for conference, and the registration process needs to take place inside a transaction. Suppose you give us your credit card number, you want to make sure you've really got a seat before the payment goes through. So, we're going to use the registration process to practice writing transactions. Let's go create some conferences. The first thing we'll do is add functionality to create conferences. Here's the Create a Conference page in the UI for the web app. Where you see enter the name, the city, the description. If we were to go ahead and enter these values now the conference wouldn't get created because this page sends a call to the Create Conference function. And it's going to be your job to implement that function but it's not implemented yet. We're going to create conference entities in such a way that each one has a parent and that parent is a profile of the user who created it. The reason for doing this is it makes it very easy to quickly find all the conferences that are particularly user created. For example, you'll be able to very quickly find all the conferences that you created. Now let's take a look at the code. So here I have the class conference. And you'll see that it has this @Parent property. Using objectify, the way you create an entity with a parent is that you use the annotation @Parent to annotate one property as the parent. So in this case, we've annotated profileKey as the property that's going to hold the parent, so profileKey is going to be the key of the profile entity that's the parent of this conference. Now when you created profile entities, you specified user ID as a property to use as the ID. For conference entities, we don't have any specific thing that we can use as the key that uniquely identifies the conference. So we're going to let App Engine allocate the key for off. However, using objectify, you still need to identify one property as the property to hold the ID. So in this case, we're going to use the cunningly named property ID and mark it as @ID. So this is the property that uses the ID for the key. If you remember for profile entities the ID property was a string and here for conference it's a long. That's long with an L, there's three kinds of types that your property annotated by @Id can be. It can be a long, capital L long, little L or string capital S. So one more annotation that we didn't use in the profile class is @Index. You'll notice that some of the fields in the conference have this @index annotation and what that means is we want to index property. And the reason we do this is that later on we're going to be searching on that property. We're going to be searching on the name, for example, we won't be searching on the description. So what I'm going to do is just quickly scroll through this code and explain what it does. We already talked about the @Parent. The profile key is the key of the parent of this entity, topics, every conference can optionally have one or more topics that it's about. For example, your conference might be about medical innovations or web technologies or maybe it's about both web technologies and programming languages. So, this is a multi-valued property, it's a list of strings. We have the city, we have the start date of the conference, the end date. We're also going to keep track of the month so that we can issue queries such as show me all the conferences in December. So max attendees is the maximum capacity of the conference. We're also going to have the seats available, which keeps track of how many seats are still available. Obviously at the very beginning, the seats available is the same as the capacity but as people sign up to attend the conference. The seats available is going to go down. For entities in general, the default constructor is private and here we have the constructor for the conference and what this constructor does is it sets the Id to then pass to Id and it also figures out the profile key by calling Key.create on Profile. It also figures out the profileKey of the parent profile and sets it and then it just sets the organizerUserId and then it calls this updateWithConferenceForm to set the other values in the conference. Here we've got some getter method. We get the profileKey here. This getWebsafeKey just basically returns a string of the conference's key. So that it can be passed around through forms and through the browser, if necessary. And this one here, the getOrganizerDisplayName. The display name's calculated on the fly when we need it. Just in case the organizer updates their display name. Okay. Just some more getters, getTopics, we get a defensive copy of the list, getCity, you need to get the start date, the end date, getMonth and so on. The updateWithConferenceForm method takes value send in the conference form and update the conference entity with those values. For example, here you see how we calculate which month conference is occurring in and set the value of the month field. There's a couple more methods that we'll be using later, there's bookSeats so that when the user registers to attend the conference, we need to keep track of how many seats are available. So we decrease the number of seats available by the number booked. And then give back seats if someone registers for a conference and changes their mind and unregisters then we need to reset the seats available. And then this toString is just a function so that you can get a string of the entire conference. Now, we actually wrote all the code for conference.java for you. I want you to make sure that you take a look and read it and understand it. Now let's take a quick look at the ConferenceForm class. Again, we've written this class for you. This class defines the input parameters to the createConference function just like ProfileForm defined the input parameters to the function saveProfile. So basically contains the fields that are going to be passed in the form or whatever input method to the create conference function. And if you're getting worried that we wrote too much for you, don't worry, you're going to be writing the create conference method yourself Okay. Now, we need to do some work in the OfyService class, which is in the service package. When you use Objectify to define an entity class, you need to register the entity class. You do this in the static method in OfyService. See here, this is where we registered the profile class. But you're going to need to go ahead, and add the code to register the conference class. You'll probably find that when you do that, you get an error. But the error is quite simply because we don't have the right import, so go ahead and import the conference class. And that's all you have to do to register your entity. Go ahead and pause the video for a minute, while you register the conference class. Now it's your turn to add the functionality to create conferences, to your application. First though, you need to copy over some files into your project. In the lesson four folder, you'll find Conference.java, and you're going to need to copy it into the domain package, in your project. And you can just drag and drop it from wherever you downloaded it, right into the domain package in Eclipse. Also, go ahead and copy over the ConferenceForm.java file and put it in the form package. Conference.java and ConferenceForm.java files contain completed code, but don't worry, we haven't done everything for you. You're going to need to copy the skeleton version of createConferences into the conference API class, and it's going to be your job to finish implementing, the createConference function. After you drag and drop your files into Eclipse, you're going to need to refresh your project. Go ahead and right-click on the project name and then you choose Refresh, and then your project will refresh, and it'll show the files that you just copied over. If you forget to refresh it, you might not see the files, and then you might be in a panic where they are. So, remember to refresh. When you've copied the files and the function into your project, go ahead and have a look at the Conference.java file and the ConferenceForm.java. So now, here's a quick question for you. Does ConferenceForm have properties that map to these properties in Conference? Does ConferenceForm have a property, that maps to the name property in Conference? Does it have a property that maps to the topics property in Conference? And so on. So, just check all that apply. So the question was, does ConferenceForm have properties that map to these properties in conference? Yes, the conference form has a name property. The user's going to enter the name of the conference when they create a conference. And again, it has a topics property, because the user's going to enter the topics when they create the conference. But no, ConferenceForm doesn't have a property for profile key. The profile key's going to be calculated based on the profile that's the ancestor of the conference. And also no, it doesn't have a month property, because the user doesn't enter the month, they just enter a start date. And then the conference constructor actually calculates the month, based on the start date. You're going to write the code to make the create conference method, Creat and Save Conference Entities. But first I want to point out how Creating Conference Entities is different in a way than creating profile entities. For profile entities we specifically use the unique user ID as the ID for the identity key. For conferences though, we really don't care what the key is. So we're going to let App Engine allocate it for us. So here's the code to let apengent allocate the key. You used the factory.allocateId method, and in the simplest case you just provide the entity class. So that would be raspy conference profile whatever. So for example, to allocate an ID to a conference entity, you specify the key type and conference. And you specify conference.class. But this isn't quite right actually, though. One more thing we need to do, is to take account of the fact that the conference has a parent. Which is a profile entity of the user who created it. So when you want to allocate an ID to an entity that has a parent when you call the allocate ID method. You need to specify the parentKey as the first argument. So here's the code you need to write to allocate an ID to a conference entity. You need to specify the profile key for the ancestor and specify the conference class. Another thing to mention is that you've already learned how to save an entity by calling ofy.save. But in this case, when you save your conferences, you also need to save the profile entity. You can just use the entities function, IES, the pluralized version, and specify the list of comma separated entities to save. You should have already copied the skeleton version of the create conference method into the conference API class. But if you haven't, go ahead and do it now. You see that it's full of to dos. You're going to go ahead and implement each of these to dos. First of all, you need to get the user ID of the logged in user. Then you're going to get the key of the user's profile. Then you're going to allocate a key for the conference. And don't forget the conference has a parent so you need to take that into consideration when allocating the ID for the key. You're going to get the ID for the conference entity. Then you actually need to see if the profile entity corresponding to the profile, that's the parent of the conference actually exists. If it does get it out of the datastore, if it doesn't go ahead and create a new one using the default values for the profile properties. And then finally, you actually create the conference. Then you need to save both the conference and the profile entities, and return the profile. The reason you need to save both the conference and the profile entities. Is even though if you've got the existing profile out of the data store, you haven't made any changes to it. If the profile didn't already exist, you will have created a new one, so you will need to save it. So, go ahead and fill in the ToDos in createConference. You already copied over the skeleton version of it, and now you can write the code in the ToDos. When you've implemented createConference. You can run your app on local host. And then go ahead and create a conference or two. And you can use API's explorer or you can use the create conference page in the WebUI. Then check you conference entities in the data store viewer in the admin console. To make sure that they go created as you expected. Now at this point you actually can use the create a conference page. In the WebUI for the app because when you submit this form, it sends a call to the create conference function. And you've actually implemented that now. So using this form should let you create conferences. And it's kind of a nice, easy thing to do. What you need to do is specify the name, and all the other values will default. However, at this point you can't use the show conferences to check that the conference got created. Because you haven't yet implemented the function that provides the behavior of the show Conference page. So, no matter whether you create a conference in the APIs Explorer, or the create conference page in the WebUI. You'll need to use the data store view in the Admin Console, to check that the conference got created. After you've created some conferences. Go ahead and look at them in the Datastore view of the Admin Console, and see if you can figure out which properties are indexed. Check all that apply. So let's quickly review which properties I indexed. The name property's indexed. We're very likely going to want to search for conferences by name. The description property is not indexed. We're not going to query for the conferences by description. And it's actually fairly typical, that if a property is going to have possibly a long text string as its value, that you're not going to index it. And city is indexed. We're going to want to query the conferences by city. For example, which conference is taking in place in Tokyo? Which ones in San Francisco? In our case, the start date is not going to be indexed. It's not that unlikely that you might want to query conferences by start date. It's just that in our case, we're not going to do that. Now you could have figured out which properties are indexed, by looking in the source code for conference. For example, we see that name is indexed. Description doesn't have the @index annotation. So it's not indexed. And so on, for the rest of the fields. But an easier way to check once you've actually created some conferences, is just to look in the Data Store Viewer. And the Data Store Viewer shows you which properties are not indexed, by this little unindexed annotation. You've probably already seen this. And that just means that the property's not going to be indexed. You don't have to be Sherlock Holmes to figure out that the converse is true. If you don't see that @index mark here, then the property is going to be indexed. So here we can tell that max attendees is going to be indexed. Now that we've got some conferences, we can go ahead and learn how to query on them. And Magnusson's going to talk to you about the different types of queries. And then I'll talk you through how to write the code to write the queries. See you in a minute. Okay. So now we turn to a big topic when you use Datastore, queries. And we will start by giving you an overview of the types of queries that we will run. Let's do that by looking at Conference Central, where we will build out the show conferences function. In the first tab here, we can see all the conferences. This query is called query by kind, because we will search for all entities that are of the conference kind. In the second tab, we can see all the conferences created by the user. This query is called query by kind, filter by ancestor, because we will search for all conferences that have the user as their ancestor. Remember, this is the ancestor relationship we established between the conference, and the profile that created the conference. And finally, in the third tab we will see all conferences the user has registered to attend. This query is called query by kind filter by property, because we will display all conferences that are in the attended conference property of the profile entity. Remember, this is to has a relationship we created between a profile and the conferences they registered to attend. And one more thing. In this part, you can further restrict the search result by applying filters. And as you can see from the drop down menu, these are properties in the conference kind. So therefore, these will also be a query by kind, filtered by property. Okay. So these are the query types we will look at now. Query by kind, query by kind filtered by ancestor, query by kind filtered by property. The query by kind filtered by property, is a little bit advanced stuff. The other ones are pretty straight forward though, so you'll start off by adding them to Conference Central. So now it's time to learn about how to query for conferences. But for our queries to be useful we actually need to have some conferences to query over. So go ahead and create a couple conferences, maybe more if you like. You can use the create conference page in your app to do that or you can use the API's explorer, whichever you like. The Create Conference page is a little nicer because it limits the choices of the topics to valid topics and it uses this nice date picker for selecting the start date and the end date. So the only property that's really required is the name. All the other properties will default to the default values. But for our queries to be useful, you're going to need to set a couple of these properties. So go ahead and create a conference. So you have to be sure to specify the conference name. Can choose a city. You are going to need some conferences in London. Going to skip the description, and you are going to need some conferences in London that are not about medical innovation so let's make this one, this would be Health and Nutrition right? Because it's about chocolate. I'll pick a start date in June. End date, probably should be after the start date. And then we'll create the conference. So go ahead and create some conferences. You're going to need a conference where the city is London, and the topic doesn't include medical innovations. Create another one where the city is London. The topic includes medical innovations. And the start date is in June. And the max attendees is greater than ten. And you feel free to create some other ones as well. If you didn't get all that, don't worry. When you need these particular conferences, I will remind you to create them, if you didn't already. And again, we already talked about this, but you're going to need to use the datastore viewer in the Admin Console to review your entities. To make sure your conferences actually got created and saved. Now that we've got some conferences, it's time to write the Query Conferences function. We've already learned that using Objectify to get an entity by key, you use the load method. So here's the code to load the entity if we know its key. Call the load method on ofy, call the key method passing the key and then now so it happens right away. This works if you know the key of the entity that you want to get, but for conferences, we don't know what the key is, because we let app engine create the key for us with an auto allocated ID. So we actually don't know what the keys are for the conferences, but actually it turns out that doesn't matter. We're just going to query for them. So here's how you create a query to get all entities of a given kind, ofy().load(), as we did before, but this time we specify type. And then in our case since what we want to do is get all entities of a given kind, we need to pass Kind.class to type, so here's the query to get all entities of a kind recipe, so you see we just specify Recipe.class here. You can also sort the results based on a property value. So here's how you'd sort the recipe entities according to their name. You just call the order method and you specify the property to sort on, and we're going to sort on the name. So try to go ahead and execute the query, you call the list method. So here's what you'll do to add the functionality to query for all conferences. In the conference API class, you're going to add a method called queryConferences. There we are, queryConferences. You're going to have to write this one for yourself. See here I define the @ApiMethod to expose the function as an end point and to specify the name, the path, and the httpMethod. In this case this needs to be POST. And for now it takes no arguments. See that? No arguments. You're going to fix that later on, but for now it takes no arguments. You're going to add the code to query for all conferences sorted by name. And then you're going to return the query list. So see here we have the error for query, so you're going to need to fix that. And you actually need to import the objectify query and that's in com.googlecode.objectify.cmd.Wuery. So make sure that you import the query that goes with objectify, not the one for the native data store. So after you've read your query conferences method, you can try it out in the API's explorer. You go to the API's explorer on localhost and you see the services, you're probably going to need to refresh the page here, otherwise you won't see the queryConferences method, but here now, here we have queryConferences. You click on it. Now, if you recall we didn't provide any input arguments, so there's no request body to fill in, so just press Execute and let's see if we've got any conferences. Yes. I only have one conference called App Engine for All, and here we see it in the response. You can also use a Show Conferences page in the UI, because this page also sends a call to queryConferences. So this is an example of what you might see in the Show Conferences page. Got a list of all the conferences that have been created. There's no point adding filters because the current implementation of queryConferences doesn't know anything about filters. Now it's your turn to write the code to query for all conferences. You're going to need to add the query conferences method, in the conference API class. You're going to need to identify the function as an endpoint method that uses HTTP post. And, now, if you can't remember how to do that, just look at some of the other functions in the file. An implement queryConferences to return all conferences sorted by name. And when you've written your function, go ahead and test it on localhost. And that is important. It's really important that you test it on localhost first. Don't cheat. Don't deploy direct to appspot. You'll find, if you do that, it probably won't work. After you run it on localhost, go ahead and try out the query, you can either do that in the API Explorer, or you can go to the show conferences page. Doesn't matter which way you do it, but make sure that you run it on localhost first. And then, after you test it on the localhost, I do want you to deploy it to appspot. Now we're going to check that your application actually works, and that it does create conferences and queries conferences. I want you to go ahead and create a conference called Udacity that's going to take place in London. It's important that you get these right, that the name is actually Udacity, spelled right, and that the city is in London. Otherwise, our testing script might not work. And then go ahead and enter your app ID here. This needs to be the app ID, the app that's running on appspot. So let's take a quick look at the code query for the conference entities. So here I am in the conference api.javafile or conferenceapifile and the queryConferences method. So you'll notice it's declared has a at APIMethod annotation. Name queryConferences. Path queryConferences. And the httpMethod is HttpMethod.POST. So the query for the conference is, you create the query of type conference. Then you call ofy.load.type specifying the entity class, which in this case is conference class. And then we want to order by name. To actually execute the query, we call the list method on the query. And we're going to return the results of running the query, which is going to be all the conferences, ordered by name. And that's all there is to it. Now you'll learn how to run queries to find conferences that were created by a specific user. Remember that each conference has an ancestor, and that the ancestor is the profile entity of the user who created it. Here's how you creat a query to get all the entities that have a particular ancestor. You just add the ancestor function to the end of the query creation. You need to specify the key of the parent. That is the key of the ancestor whose descendants you want to query for. This kind of query is called an ancestor query, but you could also think of it as a descendant query that is because it gets all the descendants of a particular entity. So conferences for example. You can get all the conferences that were created by a certain user. So go ahead and add a new function in ConferenceAPI called getConfrencesCreated that returns conferences created by the logged in user. So again, the HTTP method is going to be post. And this time, the user must be logged in because you're trying to get the conferences created by the logged in user and define the function to return all the conferences that the user created. And again test on localhost before you deploy to app spot and run your query on local host first, because if you deploy direct to app spot the first, and then try to run the query for the first time, you're going to find it doesn't work. So after you've defined and tested your get conferences created method take a look at the code and come and answer this quiz. What I want you to do is figure out which is the right code here to complete this statement to get all the conferences created by the user. So let's take a look, is this statement correct? No, because here we're passing the userId, and that's not correct. We have to pass the key of the ancestor. So here, is this code correct? We are passing the userKey, so that's right, but, oh, something's missing here, it needs to be conference.class not just conference. And here, this is right. We're loading type Conference.class, and we're passing the ancestor key. Correct. And over here in the conferenceapi.java file, have a quick look at the definition for getConferencesCreated. Again, we annotate it as @ApiMethod,. Specify the name, the path, and the HTTPMethod post. So this time because we need the user to be locked in, we do pass the user argument and we have to throw an UnauthorizedException in case that user is not logged in. So here's the code, should be very familiar by now. For throwing the exception if the user's not logged in. We get the user ID, getUserId, we get the key of the user from their ID, because remember, we use the userId to generate the key and here we do the query. We load ofy.load.type Conference.class, specify the userKey as the ancestor. To order by name, and then finally, we execute the list to actually run the query. After you deploy your app to localhost, you can test it in the API's explorer. So here's the conference API. Here you see the getConferencesCreated method that you just defined. You are going to need to make sure that you refresh your browser, or you won't see it. Drill down into it, I'm going to execute it. Oh look, forgot to authorize maps because we required the user argument. If I authorize, now I'll try again, and here I see in the response, the conferences that I've created. So the UI calls the same function. It calls the getConferencesCreated. You could also use the Conferences Created page in the UI. Because when you go to that tab, it actually calls the same method that you've just created. You can use whichever you prefer, the tab in the UI or the API's explorer, to check that the function works. All right, I hope that went well. We will now talk about the most flexible query mechanism in Datastore. Query by kind, filter by property. Let's say you would like to query for all conferences that are in a particular city, for example Halloween, and with a specific topic like movie making, and then sort the matching entries by conference name. For example, if we were to write this out it could look like this. Retrieve all conferences that are in the city Halloween, and has moving making in the topic. Sort the result by name. This is an example of query by kind, filter by property, since we are using property values in the search and the sort. Let's look at this a little bit closer. We want to have an exact match for the city since we are only interested in conferences in Halloween. This is called an equality filter. Then, we want to further restrict the queries so that only entities which has movie making in the topic are displayed. This is called a member of filter. We are combining these with the and operator, meaning that both of these conditions must be true. And finally, we are sorting the result by name. Let's look at filters and how you can use them to construct a query in more detail. The first filter is the equality filter, that we used for city in our example. Then, we have the member of filter, which has the same symbol as the equality filter. This filter, we use to sort by topic. Then we have a set of inequality filters, not equal to, less than, less than or equal to, greater than, greater than or equal to. And all of these can be combined using the Boolean operators and, and or. That's enough theory to get started. So now it's time for you to add query by kind, filter by property, to conference central. In the previous exercise, you practiced querying for all entities of a kind. Magnus has talked to you about querying by kind and by property. So the next step is for you to write the code and fill the search results by property values. For example, you could find all the conferences whose city property has a value London. To add a filer to a query, you either call up the filter method specifying the property and operate a filter on and the value of the filter on. So, for example, if you need to fill from the city property and the value London. But let's suppose you already created the query and now you want to add filters. After you create a query object you can't change it. In other words, it's immutable. So to make changes to your query you need to reassign the variable and this is how you build up your query. So let's say this is my original query where I'm getting all the conferences ordered by name. So now to add my filter, I just reassign query back to itself really but that makes a copy of it and, in this way, you can keep adding filters. And that's what you're going to be doing now To practice filtering queries by property you're going to add a new function to the conference API class. You can all the function whatever you like maybe something like Filter Playground. The name doesn't matter because this function isn't going to be called by the UI. You'll be using this function to experiment with filters. You can think of it as a playground method for exploring queries. This time you can leave off the @Api Method annotation. You don't have to but it's a good chance to see what happens if you do. The method will still be exposed as an endpoint function but it'll use default values for the publish function name, the path and the http method. Since we won't be using a form to post values to this method we don't need to set the http method to post. It'll work fine to use the default http method. Define a function to create a query to get all conferences where the city property has the value London, sort the query results by conference name. Run the app on the local host and use the API's explorer to test it. Look for the new function name in the list of functions. I called mine filter playground and you see it shows up here as, conference.conferenceAPI.filterPlayground. You won't be able to test your new function in the conference central UI because nothing in the UI calls your function. I want to emphasize again that you must run the query first on local host, before you deploy the App, Appspot and run the query there. If you deploy it to Appspot first, you'll get an error when you run the query. Let's execute it and yes, I have some conferences in London. Obviously, you need to make sure that you have some conferences in London or else you won't get any results in this query. After you got your query to work come back to the code for your playground method and add another filter. This time run a filter to check if the topic includes Medical Innovations. Pay attention the fact that the topics property has a plural, it's topics. And make sure you spell medical innovations right. The topics property can have multiple values but you can create a filter for topics just as you would for property with a single value. The results will include applicable conferences, whose topics include the value, medical innovations. After you've made the changes to your code run the app on local host and try out the function in the API explorer. You'll need to make sure you have some conferences in London and that the topics include medical innovations. If you don't get any results check that you really do have some conferences that meet all those criteria. Oops, I don't, I'm going to have to go add another conference. You just wait to create conferences is to use the create conference page in the UI. So I added another conference has very good name, chocolate for health and the topics includes medical innovations, you see that its not medical innovations is not the only topic, its just one of the topics and the city is London. So my filters do work. So when you've got your filters to work go ahead and check the box yes that they're working. So here's my version of the filterPlayground method. You might have called your method something different, that's perfectly fine it doesn't matter what you called it. So I return, list of type conference. And here I create the initial query where I'm loading all the conferences sorted by name. And then I add the filter. To filter on city equals London. And I add the second filter, to filter on topics equals medical innovations. Then I call list on the query and I return the results. You can also string everything together into one long statement like this, but I prefer the code to be broken up into smaller chunks for readability. Now you know how to filter queries by property. Obviously this function we just wrote is very hard wired, and you would more typically let user pick which values to filter on. And you'll learn how to do that soon. All right. So we covered a lot of material now on queries. Let's do a quick recap. First, we used a query by kind to get all the conferences. Then we combined the query by kind with an ancestor filter. And finally, we applied property filters. Remember, property filters gives you a lot of flexibilities when doing queries. Now, the time has come to look under the hood of Vapor Store, and see how these queries are actually run. The time has come to look at indexes. All data store queries are performed using indexes, and knowing how they work is important when you design and build your applications. If you have worked with a relational database management system, and SQL. You should be aware that those indexes are not the same as data store indexes. Indexes in RDBMS are a query optimization used to retrieve your result faster. While indexes in Datastore are, in fact, required to perform a query on that data at all. So you if you want to query for Datastore data, there has to be an index for that data. Be sure to remember this. So let's look at Datastore indexes by going back to conferences. And look at what happens when we perform a search on the property city. In fact, let's even talk about what happens before the query. When storing entities, Datastore also updates index tables, which are later used to find entities when the query is made. These index tables consist of an index value, that maps to a matching entity key. Taking the city Berlin as an example, the index value would be constructed using the kind, conference. Then the property, city, and finally the value of the property, Berlin. Here are the index values for the cities Halloween, London, and Paris. So again, the index value is a combination of the kind, property, and value of the property. Each index value then points to the entity key where the value resides. So a matching entity where city is Berlin has the following key. And one with London has the following key, and so on. So let's say your favorite city is, Paris. And you would like to get all conferences that are in Paris. Then Datastore would look at the index table where city is Paris, and find all matching entities. Since data store require index tables to perform queries, every property that you query for will need an index table. By default, Datastore creates these automatically. But we will also see how you can control this later on. So now when we have introduced indexes, let's talk about the size of these index tables, since this is important to be aware of when you build datastore applications. Using the developer console, you can see the index sizes under the datastore dashboard page. Here, we display the dashboard for a very simple application. And as you can see, the entities themselves do take up 6.75 kilobytes. However, the built-in indexes for those entities, they take up 57.12 kilobytes. This is actually a common scenario. Indexes very often take up more space than the storage required just to store the entities. The built-in indexes are the indexes that are generated for each of the individual properties, as we talked about for the conference city property. There's also something called composite indexes, but we'll talk about those shortly. As you can see, if you let data store maintain an index for each individual property, it can take up a lot of space. Therefore, it's important to think about which properties you need to query on. So you only generate indexes for those. Let's look at how you can control that in your code. In the native Java Datastore API, all property values are indexed by default. If you forget to think carefully about which properties really need to be indexed, you could end up with index bloat. However, objectify helps you out and by default property values are not indexed when you use objectify. So, if you want a property to be indexed, you need to add the @Index annotation to the property. However, if you prefer that by default all the properties of a class are indexed, then you add the @Index annotation to the class and then you can add @UnIndex to each property that you don't want to be indexed. You can also add conditions so that a property's only indexed if it meets certain criteria. For example, only index a property if the value is greater than 100. There's good documentation about conditional indexing in the Objectify Developer's Guide. So what I'm going to want you to do next, is actually go read the developer's guide. It's at this link, or actually an easier way to find it is just to search on Google for objectify. This brings you down into the open-source project for objectify. Then you click on the wiki. And then, expand the users guide and you go to the queries and indexes page. So go ahead and take a look at the documentation and objectify for custom indexes. I want you to figure out what's the code to index the city property of a conference, only if it's not in the default city. So, when you've figured out the code to index the city, only if it's not the default value, come and enter the value here. So, here's what the @Index annotation looks like if we only want the city to be indexed, but it's not the default city. So @Index, and then we add, if not default.class, then the index, the property name, which is city, and then here we just specify the default value which is default city. And if the city Is created without a value, it's going to get the default city as its value and it's not going to be indexed. We can actually also see that in the admin console on local host. Here's two conferences that I created, and you can see it tells us that they're not indexed, even though these two are indexed because they have values. These two conferences are not indexed. So, I encourage you to explore the documentation in Objectify to learn about different ways to conditionalize how you can index your properties. Okay, that's a good introduction to indexes, but there is more and in the section we will cover composite indexes. Remember the single property index we looked at, that had the city as to value. A single property index is also called a built-in index. Data store can in many cases combine results from different built in indexes to provide a response to a query, but there are cases where this is not possible. That's when we need a composite index. In fact we have already used composite indexes in conference central for this query. Retrieve all conferences, filter by city and topic. And sort by name. This is a composite index, because the built in indexes for city, topic, and name, cannot be combined to generate the result. For this to work, an index table consisting of multiple values and combination must be created. This is exactly what a composite index is. So how are composite indexes built? There are two different ways. The first way is to add an index to an index file. [UNKNOWN] a little bit differently depending on which language you use, so you will see how to do this in one of the exercises. The other way is to actually run your application locally on your development server. In this case, if App Engine encounters a query that requires the composite index, it will automatically update the index file. When you later deploy App Engine, this index file will be uploaded as well. So it will also exist when executing on App Engine. All right, it's time for an exercise where you will explore composite indexes So now, let's just talk to you about Indexes, and how every query needs to have an Index. So let's see what happens, if you deploy an application to app spot, that requires a new index. So what we're going to do, is update our Filter Playground Method. You may have called this method something else, but this is the method where you've been adding your hardwired filters. Anyway, we're going to update it to filter for another thing. So for example, let's filter it for conferences in June. So we just filter on month equals six, because the month is recorded by an integer and six is June. After you've added this filter, go ahead and deploy your application directly to app spot. In this case, do not run the query on local host first. I know I've been telling you always run it on local host first, but now I want you to see what happens if you don't. So, don't run it on local host, just run it directly on app spot. Try running your query in the API's explorer. What happens? So what did happen after you added the filter for the month of June and then you ran your query on Appsbot? Did you get an error, or did everything work just fine? Go ahead and check whichever of these applies to you Did you get an error? If you did, don't worry. That's what I would have expected. The thing is that you created a new query and you deployed it straight to app spot without the index. So, since the index doesn't exist, the app really can't serve the query, so you will get an error. Or did everything work just fine. Hm. It's hard to say that's wrong if it did, but it's not what I would have expected. You were trying to execute a query for which an index doesn't exist. So, unless you ran it on local host first, I really wouldn't have expected the query to work. So let's take a quick look at the filter playground method where you've been adding your filters. And here you see I've added the filter for month equals six which basically says, give me the conferences in June then I deployed that to AppSpot. And I went to the API's explorer for my project, actually out on AppSpot this is not in local host. Chose my method, my playground method, executed it and you see I get an error and it's a backend error. So one thing we can do at this point is to go look at the index viewer in the admin console. To get there, you go to the console.developers.google.com, you select your project and then over here you choose cloud data store and then you choose indexes. You see the indexes that have already been created. And these are what we'd expect, we already searched for this ancestor query, which basically give me all conferences for a user, where the user was the ancestor of the conference. And then we have this other one where we search for city topics and name and if you've never actually deployed your app with this filter to Appspot. You won't see this filter, but that's okay, that's fine. Now what I want you to do is to go back to Eclipse and I want you to look at the automatically generated index configuration file. So to get to that, sorry this is a little hard to see but you go into the Target directory. You drill down into Conference-1.0. Then into Web-inf, then into app engine generated and you see data store-indexes-auto. Now exactly what you see might be different to what I've got here but it's perfectly fine if it's blank. It may already have some index configurations in it. Now what I'm going to do is run Conference Central on Local Host. Okay my Dev App Server's now running. So, I'm going to go to the API's Explorer on Local Host. Make sure you're at, in the API's Explorer on Local Host not back in your App on App spot. Again, we drill down, we got to our filter playground method. I get a response, I don't actually have any items that match that query but this doesn't matter at this point. So now I go back to Eclipse. I'm going to look at my index configuration file again and you see that this index configuration entry has been automatically added for me. I didn't write this, app engine routed when it run the query on local host. So, I'm searching for kind Conference, no ancestor. I'm searching for filtering by city, filtering by month, filtering by topics, filtering by name. I should not filtering by name, I'm sorting by name but to all intents and purposes a sort order is a filter. So now, I'm going to go run my app again on App Spot. When you deploy your application to App Spot, the updated index configuration file will be deployed with it and App Engine will start to build your new index. Back in the index viewer page in the admin console for my app running on App Spot, I see that my new index is preparing. Now if I actually run this query again I'll still get an error and I'll keep getting an error until it's finished preparing. It needs to be ready to serve before I can run the query. So to get ready for the query I'm just going to go ahead and make sure I've got some conferences that will satisfy the query. So I'm searching for conferences, in London about medical innovations happening in June. If you made any changes in your query property you'll need to create a conference that satisfies your query criteria. [BLANK_AUDIO] Okay, let's go and see how our index is doing, see if it's built yet. Okay, good, it has. It's no longer preparing, so it's ready to serve. So, over here in the API's Explorer for my app on App Spot, I will run my query again. Execute it. Oh good and it found the conference I just created. Which matches all the filters on the query. Good. One thing to mention is that when you deploy an app that needs a new index, the request to update the index actually goes into a queue along with other similar requests, so your index may not get updated immediately. And that could be why it may take a little bit longer to prepare than you think if might need to. It's not because it take a long time to build the index, although sometimes it can but generally the wait time is just waiting for your request to get to the top of the queue. So another thing that you could do instead of running your query on local host is that you can create your own index configuration, called datastore/indexes.xml so whatever indexes are defined in either the datastore/index. Says file that you created or in the order generated, datastore dash indexes dash auto. When you deploy your app to App Spot both those index configuration files will go up and any indexes defined in either of those files will be created and you'll be able to serve queries that use the filters defined in those index configuration files So now you're going to go ahead and create the new composite indexes. So first of all, open datastore-indexes-auto.xml. You may find it's blank. You may find it's got some content in it already. Either way, it's fine. Then, run the query on localhost. Then go back to Eclipse and check the datastore-indexes-auto.xml file and you should find that the new composite index has been automatically added to it. Now that you've updated the index file, go ahead and deploy your app to appspot. In the developers console, go ahead and look in the Index Viewer. Is your new composite index preparing? You might find that it's already ready and that's just fine if it is. When your index is ready, run the query and make sure that it works. And how do you make sure that your queries work on appspot? Do you manually edit the index configuration file? Do you run the queries on localhost first, before you update your app to appspot? Do you annotate the properties that you want to be auto indexed as at auto index in the entity file? And do you just not worry about the single property queries? And by that I mean you don't worry about creating indexes for queries that only use a single property. Go ahead and check all that apply. So yes, one way to create the index configuration file is to actually manually edit it. And another way to get the indexes correct is to run the queries on local host before you update the app to appspot. This one here, annotate the property at AutoIndex is incorrect. I just made this up this at AutoIndex, however you do have to annotate your properties as @Index, if you want them to be indexed at all. And actually yes, you don't have to worry about single property queries because index are automatically created for ever property that is marked with at Index. So the only thing you have to worry about for your single property queries is to make sure that the property itself has got the @Index annotation. So far, we have described how data store uses indexes to execute queries. Now is the time to look at some query restrictions that exist. As you know by now, data store was designed to be massively scalable. Therefore the performance of queries should only depend on the size of the result set, in other words the amount of data returned in the query and not on the overall amount of data stored in data storage. To meet this objective, data store always uses the indexes to find the matching data. And this leads to two restrictions you should be aware of when you design your applications. The first one is an inequality filter can be applied to at most one property within the query. The following filter is not valid because we are applying an inequality filter for two different properties. The second rule is that a property with an equality filter must be sorted first. The following query is for example not valid. Since the property max attendees is used with an inequality filter, it must be the first property after Sort By, not name. The best way to avoid these restrictions is to think and plan which queries you need during the design phase. That way, you can design around them. So now we'll do an exercise where you will explore these query restrictions. So to understand query world a bit more, you going to add another filter to the query in your query playground method. So now here we get all the conferences, sorted by name, filter on the city is London, e filter on topics is medical innovations, filter on month is six. But now I'm going to add one more filter, I want to filter on max attendees greater than ten. Now I'm going to run this query on localhost. I'm going to try it out in the APIs Explorer. Oops. Got an error. How did that happen? But look, it's got some good information in here. If you get an error, read it carefully. Remember, you can copy and paste it into an editor that renders HTML to make it easier to read. So it's now your turn to add an inequality filter. Add a filter for max attendees greater than ten, and then go ahead and try the query on localhost. And test it out using the APIs Explorer. I'm guessing that you're going to get an error. But what caused the error? Is it because the first sort order is a name, but the inequality filter is on max attendees? Or is it because the composite index does not exist? Or is it because you have too many inequality filters in one query? So did you figure out what caused the error? Hopefully you discovered that it was this one. The first query orders by name. And then you added the inequality filter from max attendees. So the first sort order is name, but it should really be max attendees, because that's where we have the inequality filter. Composite index not existing might be a problem that you run into, but it isn't the problem this time. Unless you deploy straight to app spot, in which case you've got a couple of different errors going on. And again, this is a problem you might run into. If you try to filter, say, on max attendees greater than 100, and seats available less than ten. Because then you'd be using inequality filters on two different properties in a single query. But in this case, this particular error should not be the problem. We're only using an inequality filter on a single property. So, here's the arrow in the API's explorer, and you see it tells us exactly what the problem is. First sort property must be the same as property to which the inequality filter is applied. In your query, the first sort property is main. But the inequality filter is on max attendees. So when you get these kinds of errors or any errors, don't be frightened by them, just go ahead and read them. There's valuable information in the errors that will pinpoint the problems and help you fix them. So go ahead and fix a problem that calls the error. So here's my query to get the conferences right, order by name, so let's just take that off. We don't want to order by name right there, instead, we want to order by max attendees, we put that right after we add the filter for it. But we still want to order by name, so let's just add that second sort order in here. Then you can go ahead and test the function. Just make sure that you actually have some conferences that satisfy all these criteria, otherwise you won't get any results. So let's say you've got this query, to get all the conferences. How would you update it to filter for conferences in Tokyo, where there's at least one but less than ten seats available? And the results are sorted by the number seats available, the name of the conference, and the month. So when you figured it out, go ahead and enter the code here. So let's take a look at the code for the updated query. So here's the query I had from before, I just comment it out, so we can keep it parked. But, here's the query where we get all the conferences, and then we filter by city equals Tokyo. To get conferences where there are more than zero, but less than ten seats available, we need to add two inequality filters for seats available. It's okay to do that. You can't have inequality filters for more than one property in a single query. But you can have multiple inequality filters for the same property. So first we filter for seats available greater than zero. And then we filter again for seats available, less than ten. Since we to add sort orders we must first sort on seats available, because that's a property with the inequality filters. Then we can add other sort orders for name, and for month. If we weren't doing any sorting at all, we could just leave off all the calls to order. You only need to make sure the sort order for the property with the inequality filter comes first, if you're sorting results at all. And again, if you wanted to go ahead and actually test this, you're going to need to make sure that you've got some conferences that are in Tokyo with between zero and nine seats available inclusive. Actually I guess that's not that difficult a criteria. Conferences in Tokyo with five seats available. So we've been working in this playground method, I called mine FilterPlayground where weve been creating queries and adding filters so that we can learn how to build up queries. Now this method has very hard wide values in it. So for example City equals Tokyo and in general you want to have a bit more flexibility. We want to allow users to specify the property values that they want to search on. That's okay though because we've only been using this method for our own purposes for learning. The real method that gets invoked by the show conferences page is query conferences. So, we already defined one implementation for query conferences, it's very simple. All it does is get all the conferences. So if we go over to the Show conferences page, we see all of the conferences that have been created. We could add a filter here in the page for example, search for city is Chicago. And then search but actually, our filter's going to be ignored, even though up here it tells us that it used the filters, because on the back end it's calling query Conferences. And the implementation of query Conferences gets all the conferences and doesn't care about filters. So what you're going to be doing next is updating query conferences so that it does respond to the filters. So there's a few things that you're going to need to do. One is that you need to copy in the conferencequery.java file. And put it in the form package. And then you're going to need to change the signature of query conferences, so that it takes the conference query form. You're also going to have to import the conference query form. Then you need to update the implementation of query conferences to return the result of ConferenceQueryForm.getQuery. So you return conferenceQueryForm.getQuery.list. This will actually work. There's actually a fair amount of code going on behind the scenes in ConferenceQueryForm, but if you make these changes, your filters will start to work. But let's take a look at ConferenceQueryForm.getQuery so you understand what's going on there. After you copy conferenceQueryform over, you may find you need to refresh your project before it actually shows up. Oh there it is. Good. So, conferenceQueryform has already been implemented in full. You don't need to implement anything, but I really encourage you to read through it and understand what it does. It checks for inequality filters. Make sure that there's only one inequality filter in it. It also checks if you have an inequality filter to make sure that the sort order's in the right order. And add each filter in turn. Constructs the query and returns the query. Another thing I want to bring to your attention is the enum here that defines the operators. You see EQ is defined to be equal to equals and we're going to see how that is used in the API's explorer. So, here we are in the API's explorer. We'll go to query conferences, now you see we have the request body where we can add a property and the property is filters. And then we add a filter, you keep clicking and adding these things, so let's add a property filter on field. But now, we want to filter on city, equals something. So we need to specify the operator. Remember the enum listing operators, where eq was set to equals? And now we add the value that we want to check against. I will do London just cause we know I have some conferences in London. So this is how you specify the filters here, unless executed and save its going to work. Oops! City is not right, I think may be its supposed to be capital C at this point. So this is to find in the conference query forms taking a quick look. Actually I should have entered all capitals for the city so I'll go back and do that again. City with a capital, the operator defined as EQ and the value London. This time we find all the conferences whose city is London. There isn't that much code that you need to change to get the show conferences page to respect the filters. But there is actually quite a lot of code going on in the conference query form class that it would be good for you to read through and understand. Now let's take a look at what happens in the show conferences page after we deploy the app to app spot. So here I went to the all tab and we see all the conferences. Now I'm going to add a filter. And I want to filter on max attendees, greater than 100. Add another filter, I just want to get the conferences in February. The search, let me run this query. I failed to get the conferences. Now if we run the same query in the API's explorer and it's max [INAUDIBLE] greater than 100, start month is two. It's cold and dark in February so want to find a nice conference to go to. Then we execute. And again we've got an error. You see again, it's the back end error. And this is because we actually don't have a composite index to satisfy this query. So this is one danger of giving the users a free hand in adding filters in any way they want. You need to be really careful to make sure that all the necessary composite indexes have been created. So now the query conferences method can handle multiple filters. But there's still an optimization that you could make to it. See here that the query results shows the organizer's display name. Well the display name must be dynamically calculated for each conference. Because the organizer's display name is not something we store in the conference, we dynamically calculate it. So let's look again at the query conferences method. So, now I've changed it a bit. So that I get the, a call conference query form dot get query, which returns me a list of the conferences, and then what I'm going to do is iterate over reach of the conferences, figure out the organizer for that conference, and then I'm going to preload all the organizers. And this is going to avoid separate data store gets for each conference. Because for each conference, we have to get the profile of the organizer and then get the display name after the profile. So this is what the final implementation of queryConferences would look like. And you can find this in the Lesson Four folder. So go ahead and update the query conferences function to use filters. This time make sure you're editing the query conferences method. Not the playground method that you were using before. So things you're going to need to do. You're going to need to get the conference query form out of the Lesson 4 folder, and put it in the form package of your project. You're going to need to update the signature of query conferences and conference API. To take an input parameter of conferenceQueryForm, and then just Call conferenceQueryForm.getQuery to actually run the query. And then optionally, if you want the optimization to pre-load the organizers' profile entities. So what are some of the things that you need to be aware of? We're including a UI like the show conferences page, that lets users add multiple filters in any order. You have to consider whether the deployed app has to have composite indexes for every filter combination. You have to think about the fact that multiple filters per query, increase the data store rights. And you need to think about whether multiple index entries take up more space in the data store. So let's have a look at some of the implications of using multiple filters. This one is a concern. Deployed apps must have composite indexes for all filter combinations. If you try to run a query for which the composite index does not exist, you will get an error. Your users will see the error on the deployed app, so be very careful about that. Do the multiple filters per query increase data store writes? Definitely they do, so for the conference for every time you write an index entry, you have multiple writes every time you save the conference. And again, the more index entries you have the more space they take up in the data store. So let's take a look at what the index configuration file might look like. We have a lot of different index entries in here. I'm not going to read through them all but you can see that, know we have one for conference, filter by city, sorting by name, conference, filtering by top pick, sorting by name, and so on and so on. So, for every possible combination that you going to allow the user to filter on, you need to add that combination to your index configuration file. And here we're looking at the indexes in the data store viewer and the admin console. I just uploaded my app with all the indexes. And you see they're busy preparing. But you see how many of them there are. You need to be aware of the need for indexes. Every query that your users are going to make has to have an index. And if it requires a composite index, you're going to need to make sure that the composite index exists on your application. And although this combination of filters uses many indexes, the results of the queries are fast because every search is pre-indexed so the query performance scales with the size of the result set, not the input data set. It's one of the great things about App Engine. This is a sandwich. It's not a regular sandwich. It's a little bit bigger than the regular sandwich, but it looks delicious. So why am I telling you this? Well, datastore is like a sandwich. It has layers, each layer built on top of the other for support. We have covered a lot of layers in lesson four and we only have two more layers to cover. So, keep the good work up. As for me, I'm eating a sandwich. We will now turn our attention to the Datastore Commit Process. This process describes to consistency rules for storing data. Datastore has two consistency models, Eventual Consistency and Strong Consistency. Let's look at these in more detail. In this use case diagram we have three things. Your Application, the datastore API that your application calls and the datastore backend, which performs work that your application is not involved in. When your application wants to store an entity, it performs a put operation towards the datastore API. The datastore backend then writes this entity to a log. When the write is completed, control is turned back to your application. At this point the Datastore backend has promised to write the entity to Datastore. Observe however that the entity has not been written yet. It has only been written to a log. The Datastore backend now goes through to work to make everything consistent. It does this by using the login information to update the entity storage and then it updates all the indexes. So observe that when control is returned to your application, datastore may not have done all the work required for the data to be updated. Is this good or bad? Well it's good, because this means that you have less latency in your application. But the question now becomes, what happens if a query is issued that would retrieve the data your application just requested to put into data store? Well, with eventual consistency the data store API will not wait for this to happen. So it only considers matching data that already exists. That is data, that was already in data store prior to your put call. And then it returns that result. That's why it's called eventual consistency. Queries will be eventually consistent with put operations performed to what's the data store API. So let's now look at what happens when in the case of strong consistency. In strong consistency, you're always guaranteed to get the data that has returned from a put operation towards the data store API. So when the query is received by the data story API, it will see that there are pending updates for the data that you are querying for. It will then wait and then get the data once the datastore backend has finished. And then it returns that result. That's why it's called strong consistency. The result from queries will always be consistent with put operations performed earlier toward the datastore API. So which is better, eventual consistency or strong consistency? Well that depends on your application. Let's look at two examples. The first one Posting a Blog Comment. In this case eventual consistency's probably best to use. This is because to update, it probably does not need to be immediate. And there is no operation dependency, in other words there are no subsequent operations that relies on data being completely up to date. What about this one? An atm money withdrawal. Well that's certainly candidate for strong consistency because even though you may not like it, the new balance should be reflected immediately and there may be operation dependency. For example, there may be purchases coming in on that account that depends on an up to date balance. You may now say, so why don't I use strong consistency all the time? Well, remember the use case. Strong consistency causes a lot of wait and locks in your application. So if you want to build applications that scale. You should use eventual consistency as often as possible. Luckily, datastore supports both of these models. You can use the default fast and scalable eventual consistency when required. And when you need to ensure strong consistency, that is also supported. Let's see how, because it's quite simple. You enforce strong consistency when you have an ancestor relationship and your query use filter by this ancestor. If those two conditions are met all children will be queried using strong consistency, in all other cases data will be retrieved using eventual consistency. As we already discussed, strong consistency has a performance and scalability penalty compared to eventual consistency. So you need to look at your application to determine the best option for every query situation. All right, enough theory for now. Time for a quiz. Good luck. All right, let's do a quiz. Deciding on data model. Imagine you want to expand conference central with new functionality, for example adding social components allowing attendees to allow comments, photos, etc. Or adding the ability to purchase tickets to conferences rr add the ability to create conference venues where conferences take place. Which of the following three functions should strongly consider an ancestor relationship? Check the one that applies The answer is, purchase tickets. The reason for this, is that when you purchase tickets, you probably want to immediately see the confirmation that you are registered. To guarantee this, we need to have strong consistency. And in order to have the term strong consistency, we need to establish an ancestor relationship. The other two, add social components and conference venus. Are probably not so sensitive to be up to date. So there may not be, any need for strong consistency. So eventual consistency is probably a better choice for those. Now we're going to cover another area important to use when you're writing data, we're going to talk about transactions. Let's go back and look at a user registering to attend a conference for example. As you may recall, we previously introduced an ancestor relationship between a profile and conference where the profile that created a conference was the ancestor to the conference. We will now introduce a "has-a" relationship between profile and conference where each profile entity will have a list of conferences they will attend. We will call this property "conferences to attend". In addition, we will have a numeric counter in each conference entity which specifies how many seats are still available, we will call this property "seats available". So when a user registers to attend a conference, the conference gets added to conferences to attend and seats available gets decremented by one. So going back to transactions, in this case your application will perform two update operations on two separate entities. So far, every data store update operation we used have been independent of the other. For example, the success or failure of put entity 1 and put entity 2 has been independent of the success and failure of the other. This may be okay in many situations but in many situations it may also be completely unacceptable. So going back to transactions, in this case your application will perform two update operations on two separate entities. On the profile entity, you will add the conference to the conferences to attend property and on the conference entity it will decrement the seats available counter. All of these operations are performed independently in these diagram right now, you may see that they are highly dependent on each other. Imagine, for example, that you have successfully added the conference to the profile entity and then the unthinkable happens. Your application needs to terminate for some reason. For example, it runs out of memory and is faced with a critical termination condition. In this case, when your application restarts the profile entity will have the conference registered to attend but the seats available counter has not be decremented. This means that there will be more users attending than there are seats available. That is not good, we solve this problem by using transactions. This is done by telling data store to begin a transaction. Then you perform your operations and finally, you commit your transaction. If everything goes well, you have successfully performed both update operations and the state of both account have been updated. In transaction language, we call this a commit forward. But if the unthinkable happens and something goes wrong before we have successfully executed the commit transaction statement then anything that has been updated starting from the begin statement will be undone, like it has never happened. For our case that means that the seats available counter was not decremented but it also means that the conference was not added to the profile entity. As you can see we have created a mutual dependency between these statements. They are either executed as a complete group or none of it gets done. Now the time has come for you to add transactions to conference central with a new exercise. One piece of functionality that's still missing from our Conference Central app is that so far there's no way for users to register to attend a conference. Although we see the register button in the UI, it doesn't do any good to click it because we haven't implemented the function that it calls. You're going to be adding that feature next. The process of registering for a conference involves several separate tasks, including updating the users profile. To know which conferences they have registered to attend, as well as decreasing the number of seats available for the conference. Also, what happens if there's only one seat left for the conference and several people try to register for it at the same time? Who gets it? How do we handle those potential conflicts? We're going to use transactions to ensure that all relevant entities get updated, or none of them do, and to make sure that only person can get the very last seat at a conference. We're going to use a property called conferences to attend to keep track of which conferences a user will attend, and this property is going to be on the profile entity. So in the profile class you'll need to add some things. You'll add the conference keys to attend field. This property contains the list of the keys for all the conferences that the user has registered to attend, and note that it's a list of strings. You're also going to need. Most likely to fix the import. You'll also need to define the get a method for this property to return a copy of the list, and rather than a regular get a method. What you'll need instead is a method that takes conference key and adds it to the existing list. So we're going to call that, add to conference key to attend, and this how you'll define it. You'll add the new conference key to the existing values. You'll also need to add a method to remove a value from conference keys to attend, in case the user decides to unregister from a conference. So basically the unregister from conference method simply removes the conference key from the existing values but it needs to check first that the conference key is already in the property and if not, throw an invalid conference key exception. I mean, basically you can't unregister from a conference that you haven't actually registered for, and in the conference api class, you're going to need to write the method. Register for conference. You can start out by copying the skeletal code for register for conference from the lesson four folder and copy it into the conference API class. Here it is, register for conference. We want this method to return true or false to indicate whether the registration was successful or not. The endpoint functions must return objects. They can't return simple data type objects such as string or long or Boolean. These are classical wrapped Boolean instead of Boolean as a return type of the method. So the file that contains a skeleton for register for conference also contains a full-length commentation of the wrapped Boolean class. So here's a wrapped Boolean class, it basically has a couple of fields: results, and reason, and the result is going to be the true or false, and the reason is going to be the reason for the result, and typically, you'll set the reason if the result is false. We just have a constructor that takes result and the reason. We have a constructor that just takes a result and then we have getters for the result and the reason. That same file also includes the definition for the function get conference which returns a conference give a string of its key. This method is used by the UI for the app to get the details to show on the page where you can register for a conference. You won't be using it in your transaction, but you'll need to have it if you want to use the UI to register for a conference, and you're going to need to fix a couple of the imports. The named class comes from javax.inject and the not found exception comes from the server.spi.response package. So let's import that, and you get conferences provided fully implemented for you, you should be able to understand the code that it implements. So back to the code for register for conference. We need to import a couple more exceptions, and they're all in SPRM response. So you're going to be implementing this code. So what you're going to do is obviously check if the user is null, and if it is, throw an unauthorized exception. Exception, then you're going to start a transaction and then you're going to write the code to get the conference key, get the conference entity and if there's no conference with the given conference ID, you're going to, instead of just throwing an exception, you're going to create a new wrapped Boolean. That's false and your going to need to set the reason to explain why it's false, and your going to get the user's profile. Your going to check if the user already registered to attend this conference and if they did, your going to need to create a new rappedBoolean. Set it to false, and explain why. You're also going to need to take account of whether is any seats left and if not you're again going to have to create new WrappedBoolean and explain that there is no seats left. Then if all the conditions are met and if it's okay for the user to register for the conference, go ahead and do the registration. So you need to add the conference key to the user's conference keys to tend property. You need to decrease the number of seats available. You need to save the conference and the profile entities and then you need to return a WrappedBoolean whose value is true because this transaction requires a WrappedBoolean result and then if there were reasons why it didn't succeed, you're going to need to turn around and throw the appropriate exceptions, and then finally return the result. So one more thing to mention is that when you do go ahead and book the seats, the conference class already has a method book seats that just decreases the number of seats available in the conference. It's already implemented in the conference class. So you can go ahead and look at that. So all this code takes place inside of a transaction. So you're going to need to know how to write the code for a transaction in Objectify. So the way that you run a transaction in Objectify, is equal ofy().transact, at the start of the transaction and you specify new work and if you don't want the transaction to return anything, then you would use new void work instead of work. And then you call the run method, and then inside the run method you do the stuff you want done inside the transaction, and if your transaction expects a return result. Don't forget to return it. There are some things that are different in transactions in Objectify and in the raw Java store API. For example, Objectify does not use snapshot isolation. This can affect the outcome of queries and gets inside a transactions. My advice is to try to limit your use of transactions. So that you only do updates inside a transaction because it can be confusing to know exactly, what the outcome of queries will be. Anyway, I encourage you to read about transactions in the Objectify developer guide. So go ahead and implement the to do's in register for conference. And when you've implemented the function, run the app on local host and try registering for conference. You could use the API's explorer to test out the new functionality to register for conference. I find it's easiest to query conferences and then to copy one of the website's key strings of the conference that I'm going to want to attend. Now I can go and register for the conference. You have to have the web safe key string. So, I'm going to enter it here and I'm going to execute function and we'll see what got back. Result, true. So, hopefully that means I am in fact registered for that conference. Let's take a look in the datastore admin. I'm on local hosts, I'm going to go to the admin console on local hosts, and list the profiles and there I am, and I'm registered for conference. You can see that I can't tell from here what the name of the conference is. But programmatically, you can take the conference key and from that, you can define the conference name, if you wanted to. You should also find that the UI works, for registering for a conference. And you see that it says that you can unregister from a conference. Well actually, it won't work to unregister from a conference because you haven't yet, implemented the functionality to do that. So now its your turn to go ahead and write the code for implement register for a conference. For the profile class need to have the conference keys to attend property and your also going to need to write the methods to get add and remove values. Then you're going to need to copy the skeleton code for register for conference into conference API. And then fill in the ToDo's in registerForConference in the Conference API class. Don't forget when you copy over the registerForConference skeleton, you're going to need to make sure you also copy over the wrapped boolean class. When you implement registerForConference, you'll notice that the method is defined to throw some exceptions, and you need to honor that. If you change the way the method behaves, for example, you change the exceptions that it throws, or it throws different exceptions, or it doesn't throw them in the right place, the UI for registering for conferences won't work properly. And then to check what happens when you try to register for a conference that has no seats available. Just create a conference with zero seats left. The easiest way to create a conference with zero seats left is that when you create the conference just set max attendees to zero. If you want to see what happens if you try to register for a conference that you've already registered for you'll need to use the API's Explorer. Because the conference page in the UI will know if you've already registered and won't offer you the option to register again. So how did you check that your code worked? Did you check that the conference keys to attend property of the profile entity, contains a string of the conference key? Or did you look to see if the conference keys to attend property of the profile, contains the conference name? Did you check, if the seats available of the conference? Is one less than the max of the attendees of the conference. And did you try registering for a conference that you had created? So how did you check that your code worked? Hopefully, you did check that the conference keys to attend contains conference key string. And you shouldn't have found the conference keys to attend contained conference name, because it doesn't. So another good thing to check is that after you register for a conference, the seats available goes down by one. So the first time you register the seats available, it's going to down by one less than the max attendees. Of course, if you log out and log in as a different user and then register for the same conference again, seats available is going to go down by even more than one less the max attendees. And yes, in our application you can register for a conference you created. Okay. So let's take a quick look at the finished code for register for conference. And we're in the conference API class here. You already know if the user's null through an unauthorized exception. Here we start the transaction ofy.transact and then here, we do the public wrapped Boolean run, wrapped Boolean is what we're going to return. We get the conference key. We just load the conference from the datastore, should be familiar with doing that by now. If there's no conference found, take the appropriate action. Get the user's profile from the data store. Check the various conditions before we allow the user to register, and if all looks good, go ahead and book the seat. So we add the conference key to the conference keys to attend property of the profile, we book the seat on the conference. And then, very importantly, we save the profile and the conference and we return the wrapped Boolean. Now, if we didn't get a success throw the exceptions. We already talked about that. Okay, the time has come to wrap up transactions where we will cover transaction rules. And the two things we will start with are snapshot isolation which defines the read consistency and optimistic concurrency which governs concurrent updates. We'll start off with snapshot isolation. And please observe that this behavior may differ between languages, so be sure to check out the documentation. The first rule is that all read operations in a transaction will return the values datastore had when the transaction started. And the second rule for snapshot isolation is. Updates will not be reflected while in the transaction. So, if an entity is modified or deleted in the transaction, a query will get the original version of the entity, or nothing if the entity did not exit then. That's snapshot isolation, but please be sure to check out the documentation as this behavior is somewhat language specific. So let's turn to optimistic concurrency. This rule is that a commit transaction would only be successful if the values updated by this transaction have not changed since the begin transaction. If the values that you're trying to update has changed since begin, the transaction will fail. Then there are two additional rules you should be aware of. The first is that one transaction can modify at most five ancestor groups. The second rule is that a transaction must complete within 60 seconds, but the general rule is, of course, to keep the execution of transactions short. As short as possible, unless in extremely rare cases, they should be finished within a couple of seconds and in most cases, less than a second. That completes this section So one you still can't do in the Conference Central application is that you can't get the conferences that you have registered to attend. So now you're going to go ahead and add that functionality. You're going to be implementing the getConferencesToAttend method, which is going to return a collection. Of all the conferences that the user has registered to attend. This list will continue to include conferences that they've actually already attended, so it's not just the ones that they will attend but the ones that they registered to attend. You're going to work with the skeleton implementation of get conferences to attend. You can find this skeleton definition in the same file where you found the skeleton definition for register for conference. So you're going to go ahead and add the getConferencesToAttend method to Conference API and then you can implement the to do's. So as usual if the users null throw an authorization exception because we do need to know the user if we don't know who the person is then how can we find the Conferences that they want to go to. And then you're going to get the profile for the user. And again if the profile doesn't exist, got to throw another error. And then here's where you're going to do the real work. You're going to get a lit of the strings of the keys to attend, then you're going to have to iterate over that list and turn every keyString into an actual key, and then, you're going to have to load conferences for the keys and of course return the list of conferences. All right. So the first thing to do is to add the skeleton implementation of get conferences to attend to the conference API. And then, go ahead and fill in the to do's, to implement the function. So one more thing you might need to know, is that you can use ofy().load().keys, pass in a keysList, and then call a .values() to load the entities once you have a list of their keys. So go ahead and implement the getConferencesToAttend() method now. Then I have a question for you: why can't you just return the value of the profile's conference keys to attend property? After all, we have this property, conference keys to attend, so why can't get conferences to attend? Just simply return conference keys to attend. Is it because the profile stores conferences names, not keys? Or is it because the profile stores conference keys as strings? Or in fact you actually could do it, it's just a less efficient way to do it. This answer here, that the profile stores conference names not keys, is wrong. We do store the conference keys. However, we store them as strings. So, this answer is correct. The profile stores the conference keys as strings. So because they're strings, we have to convert them into keys, before we can use the key to load the entity from the data store. The reason that we use strings for the keys, is that you can't parse actual key entities around inside of JSON. So we create a web safe version of the key as a string. And this answer is wrong. Yeah, I know, it would be, it would be nice just to simply return the value of the property, but it's not going to work. So you can find the finished code for getConferencesToAttend in the lesson four folder, if you need a bit of help writing the code. So go take a look if you need to. So there's still one more feature that you could add to your project to round out functionality for registering for a conference. Once you've registered, you can't actually unregister. So even though the UI shows us the Unregister button, users can't actually click it to unregister, because you haven't written the functionality to unregister the user from a conference. It's up to you if you'd like to go ahead and implement the unregister functionality. Feel free to add the function unregisterFromConference and put it in conference API if you'd like. I'm going to leave you to do this on your own if you want to. Couple things, though, I do need to point out, is that the UI is expecting the function to be called unregisterFromConference and it is expecting it to throw these exceptions. One other thing here is we have an @Name("websafeConferenceKey"), so this function knows to expect the web safe conference key to be passed to the function, and if you go to the API's explorer, you'll see that it offers the websafeConferenceKey field for you to enter the value if you want. Anyway, it's up to you if you'd like to go ahead and implement this function. But it does tie together a lot of the concepts that you've learned such as using transactions and getting an entity by key and changing property values. So one last thing to do before we go on to the next lesson is to add the tests for the functionality that we added in this lesson. The end of the profile lesson you added the test for profile. So now you need to add the test for conference. That'll be the conference test class, and you can find that in the lesson four folder. And also go back into your conference API class and, uncomment the tests, that should work now that you've added conferences. So, let's have a quick look at conference test. Now we set up the values that you're going to need to test on. Create the service test helper which is needed, the setup method which just gets everything ready for the tests, the tear down method cleans up. And then there's just a bunch of different functions to test the different things that we've added. So test creating of conference without an A, that's not allowed. Test creating of conference, anyway, so on. You can read through the test files and see what all the things are tested. Feel free to add tests, and then when you run your project with Maven, it will automatically include the test, or run the test. And it actually won't let you run your project, untill the tests are successful. If you really get stuck with the tests, and you do want to deploy without running the tests. You can choose run as and then run configurations and then you can create a configuration and actually enable the skip tests. I don't recommend this. It's a good idea to always test what your doing, but it is good to know that if you, you know, that you can do that if you need to. Anyway, go ahead and add the test, to your application. And then it's time for the next lesson. Congratulations, we're at the end of lesson four. [SOUND] Wow. That was a lot of stuff we covered. Well, lesson four is also the most content-heavy lesson in this course, so we're really happy to see you here. We covered data relationships, specifically the ancestor and that has a relationship. We also looked at queries, query by kind and then filtered by ancestor and then filtered by different properties. Datastore indexes, we took an in depth tour of datastore indexes, it allows you to do queries in datastore and we've wrapped it up with different consistency modelsa and transactions in datastore. In the next lesson, we will look at heavy duty stuff. You want to know what heavy duty is? Well, be here to join us. I'm standing here by the Google Corkboard Server Rack. This server rack was built in 1999 by Google employees simply because you could not buy the computers required to achieve the scale, reliability, and performance that Google required. Each row here, has eight hard drives on it, and four complete PCs. And there is a cork mat, to shield the electronics from the metal frame that carries the row up. That's why it was called the Google Corkboard Server Rack. When your application runs on the Google Cloud platform, you can be sure it runs on the latest and best hardware. Well, perhaps not this version from 1999. But the latest version that we built. So, in this lesson we're going to cover the heavy duty stuff. We'll start it off by looking at memcash, a great way to optimize the performance of your application, then we'll look at background jobs. In the form of push queues, pull queues, and cron jobs and we'll wrap it up by looking at some of the scaling and tuning parameters for appendium. Let's get started, shall we? So data store is a great way to store and retrieve massive amounts of data. So therefore, it is very scalable. But it would still be faster if the data was served from memory. As we know, we want our application to have as small latency as possible. So whatever we can do to reduce this, the better. This is exactly where Memcache comes in handy. As the name suggests, Memcache is a memory cache which sits next to your app engine instances. Any data you store here can be immediately retrieved without having to read from data store. So when you store data in data store, you can also store a copy of Memcache. That means you can retrieve it from Memcache later, and therefore deliver response really, really fast. This is great, since you don't want your users to wait. Both Datastore and Memcache are shared across any number of instances of your application that app NU starts. This means that they can all access the same data provided that your application updates Memcache when it updates Datastore. The difference between Memcache and Datastore however, is that Memcache is a cache. This means that the app engine platform can decide to free memory at any time, in which case the retrieve operation will fail. So your application code needs to be prepared if this happens, and in that case retrieve the data from Datastore. Let's look at a summary of Memcache. Memcache is of course, not limited to cache Datastore information. You can put any data you want in Memcache. Since the data is retrieved directly from memory, the latency is very low. This help it build applications that can scale to extreme levels. But since it's a memory cache, it also means that the memory could be freed and the data be evicted from the cache. So your code can not rely on it always residing in the memcache. All right, that's the overview of Memcache, it's now time for you to hack in by adding Memcache functionality to the comfort central app. Hi, welcome to the coding portion of lesson five. Your Conference Central application is now in full swing, you can save conference and profile entities all day and all night long if you want to. However, every hit to the data store counts against your application's daily quota. The good thing is that you can use Memcache to save your entity data to reduce the hits to the data store. In this lesson you're going to find out just how easy it is to save your entities data in memcache using objectify. In fact, it's so easy that you're going to do another exercise to use underlying Java data store API to put values into Memcache and to get them back out. We're going to create announcements about conferences that are nearly sold out, and store those announcements in Memcache. There's no need to save the announcements in the datastore, because they're so transient in nature. Another thing your going to do is use task cues. So that your application can so work in the background. You're going to use task queues to send conformation email anytime anybody creates a new conference. To wrap it all up, we'll set up a cron job to periodically check for conference that have nearly sold out and update the announcement in Memcache. Let's get to it. In this lesson we're going to learn how to use memcache in App Engine applications. One good thing about using Objectify is that you can configure it to automatically use Memcahce to cache your entity data. All you have to do is add @cache annotation to your entity class. Then Objectify is going to do its best to use Memcache whenever possible when you try to get entity data, to reduce hits to the data store. It's really easy to use Objectify with Memcache, but there's a few things that you should know about how Objectify uses Memcache. For one thing, it only uses Memcache when you get an entity by key, you save it or you delete it. And query results are not cached. Objectify puts the property values into memcache. It doesn't put the entire entity into memcache. Another thing that is really helpful to be aware of is that objectify has its own session cache. So often when you do a get by key, objectify is going to get the results from the session cache without even going to memcache, let along going to the data store. So here's what the profile class looks like with the @Cache annotation. All I did was add @Cache to the entity class definition and now objectify is going to use memcache to cache property values whenever possible. I don't even have to write a single line of code to do it. So when you're applications been deployed to app spot, you can use the memcache viewer to view the memcache entries. I'm going to flush Memcache, to make sure, that I have no Memcache entries to start with. So now I have no entries in Memcache, I'm going to go and do some things in my application, to see if I can get some Memcache entries. When you go to the profile page, it gets your profile entity out of the data store if you already have a profile. That's how it knows what your display name and tee shirt size are. Here on the profile page, I'm going to make a change. Change my tee shirt size, and update my profile. I'm also going to go to the Show Conferences page and show all the conferences. The list of conferences is retrieved as a Query and as I already mentioned, objectify doesn't use Memcache for Query results. However, we do actually get the profile entity by key so we can figure out the display name of the organizer. I can also drill down into conference details. Which does a get by key. So now I've done a few things that involve getting entities by key from the data store. Let's see if any of the results got cached in Memcache. So you need to be sure to refresh the Memcache viewer to get the latest data. And here you see there are some Memcache entries. I've actually only got one item. And I thought maybe I would've had a few more than that. The reason there might not be as many items in Memcache as you expect, is because Objectify has its own session cache. So it's going to save data in the session cache, which will reduce the use not only of Memcache, but of the data store. So anyway, you end up seeing less items that you mark with the Memcache viewer, because of the session cache. So go ahead and update the conference and profile empty classes to use Memcache. It's a good practice to always check any changes to your app on localhost first. So feel free to do that. And you're going to need to deploy to appspot, because we want to use Memcache viewer. And for that, your app has to be running on appspot. After you've deployed your app to appspot, go to the Memcache viewer, and if you have any items in Memcache, you might or you might not. But if you do, go ahead and flush Memcache. Then in your application, go ahead and do some things to put some data into Memcache, so create some conferences, show conferences, view details, maybe create or change a profile. And then go back to the Memcache viewer and see if you've got any entries in Memcache. You might need to do a few things in your application to get some entries to show up. And you'll probably less items in the Memcache. Fewer than you might expect because Objectify uses it's own session cache. So how do you tell Objectify to use Memcache? Do you configure Objectify by enabling Memcache in web.xml? Do you need to at @cache to each property? Do you need to add @cache just to the class and do you need to write code to save the entity in memcache? Check all that apply So you don't need to enable memcache in web.xml. You don't need to do any configuration like that. And you don't need to add @Cache to each property, but you do need to add the @Cache annotation to the class. So, this is the correct answer. And you don't have to write any code to save your property values in memcache. Objectify will do it all for you. That's one of the really cool things about memcache There's really not much you need to do to get your application to use Memcache to save and get entity data, if you're using Objectify. But it's still useful to know how to write code to use Memcache. So we're going to use Memcache to save and get announcements, about conferences that are nearly sold out. You can imagine, for example, that your web app might display a banner ad to encourage people to sign up. For conferences that are nearly sold out. There might be other things you want to announce on your website, too. Maybe if you get a special speaker for a particular conference. Or you want to announce a special promotion. But for the sake of simplicity, we're just going to create announcements that conferences are nearly sold out. Because the goal here is to learn how to use Memcache. Announcements though, are a good example of the kind of thing that you might want to save in Memcache, without saving them to the Datastore. If the announcement gets evicted from Memcache, there's no loss of real data, and it doesn't really matter. No business transactions are affected, no one loses their place at a conference. And the next announcement will likely come along very soon anyway. Announcements are very transient, and don't need to be saved for the long term and they don't need to be backed up. So, they're perfect candidates to be saved in Memcache, and only in Memcache. They don't need to into the Datastore, that way you get all your announcements without using any quota. So, you're going to adding the announcement class to your project. It's a very simple class, we need it because n point functions can't return string objects. So they're going to put the text for the announcement, in the message field. Note that this class is not annotated as our entity. We don't want to save the announcements in the data store. To use Memcache using the Java native API, first you get the Memcache service. You'll need to import the Memcache service and the Memcache service factory into your project and then you just use the getMemcacheService method on the factory to get the Memcache service. Then to put an entry into Memcache, you need a key. And of course, a value to put and you just call the put method. And to get the value out of memcache, you need to know the key and you just call the get method on memcacheService. If there is no value in memcache with that key then null is returned. Setting the announcement is something that we don't want to expose through end points. We don't want other people to be able to set the announcements for our application. So we'll use a servlet in this case and protect the URL for the servlet so that the app itself can set the announcement but no one else can. Actually developers for the application will be able to set the announcement but no one else will. So you see here I implemented set announcement as a serve let. Extends HttpServlet and I implements the doGet method. So here's where I imported the MemcacheService and the MemcacheServiceFactory. Here's where I get the MemcacheService and here's where I put the value into memcache. Notice that this method doesn't set the response so we set the response status to 204 which means that no response is expected. So if you come here in the browser just stay on the same page where you are. All this method does is generate the announcement and save it in the memcache, it doesn't return it. When you use servlets in an app engine application you need to configure them in web.xml. So here's some mapping I added to web.xml for the get announcement servlet. So here the servlet name is set announcement servlet. And then here is the class that implements the servlet and notice that I put it in the servlet package. And then you map the servlet name to the URL where it gets called. So in this case, we're going to call the servlet by going to crons/setannouncement. I also defined a security constraint for my servlet because I want to make sure that no body except developers for this application can trigger the servlet. How to find the resource name and then the URL pattern that I'm protecting. Here I've specifically protected /crons/setannouncement or I could just protect everything under the slash crons path and to specify the only admin that is developers of the application can trigger this url. I set the role name to be admin. Right, wanted it so that any logged in user could trigger it and all I would do is specify the role name as asterisks but I don't. I definitely want to restrict access to admins. So I'm running my app now on localhost. And you'll see, if you look in the APIs Explorer, and drill down in to the functions in the conference API, that the set announcement method is not here. That's because we didn't expose it as an endpoints function. Instead, we defined it as a servlet on purpose, to keep it internal to the application. So the APIs Explorer let's you explore endpoint functions, but it doesn't let you explore your servlets. Since we're going to put things into memcache, I've deployed my app to app spot so I can use the memcache viewer. First, I'll make sure I have some conferences that are nearly sold out. Okay, this one's pretty close to being sold out. Only three seats left. This one's only got one seat left. Okay, so I've got a couple of conferences that only have a couple of seats left. To test the new set announcement function, you can use the browser to go to the URL mapped to the servlet. However, you do have to be logged in as a developer on the application or you'll get an error that you're not in the required role. And that's because we don't want just any old person coming along, setting the announcements by going to the URL in the browser. So to trigger the set announcement function, we go to the URL that we mapped it to in the servlet, in this case which is crons/set_announcment. So we go to the URL. Crons_\set announcement. Nothing seems to happen. But actually that's expected. Remember that the servlet doesn't set a response so nothing happens in the page, and if you've got to the place where it asks you to log in and you go ahead and log in you're going to remain on the log in page even when the URL executes. However, we can use a memcache viewer to check that the announcement got set. So here in the memcache viewer we do see that we have one item. We can use the content lookup section to look to see if it is our announcement. The key we use with recent announcements is a Java String, so let's display it, see if we have an announcement. And yes, we do. So the announcement about the conferences that have been nearly sold out has been created and saved in memcache. So now, we can save values in memcache and we can use a memcache viewer to get those values back. We're going to want to show this announcement to other people, not to the developers of the application. Let's go ahead and create an endpoint function to get the announcement out of Memcache so we can show it to other people. So another thing I want to mention is that in the constants class, constants.java, we define the key for the announcements, and this is where we get the recent announcements key from. So in the conference API class you can define the get announcement function. This is going to be an end points function so this is a fairly simple function. Basically get some memcache service, and then calls the get method on the memcache service, passing in the announcement key. We check if the value is null. So long as it's not null, we create a new announcement object, and we set the message property to the announcement that we got out of memcache. And again, we have to return an announcement, rather than just a string, because this is an endpoint function. And end point functions can't return just strings. Now it's your turn to implement the functionality to set and get announcements. So first you're going to need to define the announcement class. This is a very simple class. It just basically has one field, message and the constructor needs to take the message and put it in the message field. We need this class, only because the end point functions must return an object with a field, rather than a string. And you're going to need to implement the SetAnnouncementServelet, you'll have to implement the doGet method, you'll need to get the memcache service. You'll actually have to write the logic to construct the announcement. And then you are going to need to put the announcement in memcache, keyed off the recent announcements key. And then do not forget to configure your sever in web.xml. There is a skeleton implementation of SetAnnouncementServer available to you. If you'd like to use it, and you can find that in the Lesson 5 folder. You're also welcome to create it from scratch if you want. And then in the ConferenceAPI class, you need to add the getAnnouncement function, which is an endpoint function, which gets the announcement out of Memcache, and returns it, as an announcement object. And after you've tested it and it's working on localhost, go ahead and deploy it to appspot. And then you go to cron/set_announcement to actually run the setAnnouncement function and again, the web browser is not going to change. Whatever it's showing when you go to this URL, it'll continue to show after it executes the function. And in the APIs explorer, you can test the getAnnouncement function to get the values of the announcement out of memcache. And then use memcache viewer to check that your announcements are in memcache. Obviously they will be if getAnnouncement works but it's good to practice using the memcache viewer. And you can actually get the value of the entry that's keyed by recent announcements. So go ahead and do that. And then when everything's working, on your app, deployed on appspot, go ahead and enter your app ID here. As you're testing the get and setAnnouncement functionm you're going to obviously need to make sure that you have some conferences where the seats available is between 0 and 5. Otherwise, you won't get any results and you won't get any announcement saved. So let's take a look at the code for the set announcement servlet. You'll need to have imported the memcache service and the memcache service factory. Obviously import all the things you need for attp servlet, and you'll have to import the conference and the constants. The set announcement servlet extends http servlet, and then basically we write the logic to find out the conferences that are nearly sold out. So this is just a query. So we do the ofy.load. We're loading entities of kind conference. We're filtering first on seats available less than five, but there's no point in telling us about conferences that have no seats left at all. So obviously we need to filter on seat available at least one, ie, which is greater than, greater than zero. And then we create an array, and basically just add each of the conference names to the array. And then, if we do have some conferences, we're going to build a string that we're going to use as the announcement. We get the announcement key, which is stored in the Constants file. Obviously, we have to get the Memcache service, so we use the MemcacheServiceFactory to get the Memcache Service. We use announcement key, and we save our announcement in Memcache. We set the status of the response to 204. So let's look at another feature that is needed to build scalable applications, task queues. So why do we need task queues? Well at this time this picture should be no surprise to you. Our dear users accessing our application from various devices. And our application for turning the response. Technically this response must be returned within 60 seconds from the request. But that's a long time. We've talked about the importance about returning a response as quickly as possible to our dear users. And we don't want them to wait, even for seconds, right? And certainly not 60 seconds. You want to deliver that response as quickly as possible. But let's say that the user activity triggers something big to happen. For example, the user adds a new conference and as a consequence of that 10,000 emails should be sent out to notify other users about this conference. First of all, that's not possible within 60 seconds. And secondly, you certainly don't want the poor user that just registered the conference to wait for this to happen. Remember, the screen update depends on your response so even seconds are crucial to keep your application responsive. Come to the rescue are task queues. This is exactly the problem task queues solve. And it may not be emails triggering the need for this, it could be something else. For example, an image needs to be analyzed or a video needs to be re-encoded. Many things that are not needed to complete the request for the user, could use task queues Task queues allows you to take the job offline, so you can create the task queue and then add a hundred task that each has the job to send a hundred emails. Tasks can be created for many user activity, and be put on this queue. And as we will see later, these tasks are not executed in the user request strip. So you can immediately return a response to the user, but one question remains then. How will these mails be sent? That actually depends on the type of queue you use. But before we go into that, it's time for you to answer a question. So the question is which is best to use, the HTTP request thread or task queues? When you want to generate the report, or register a new user, checking out the shopping cart, or do photo face recognition? The answers are, when generating a report, probably a task queue makes sense. Because that sounds like it could take awhile. When registering a new user, the user probably immediately want to see that the operation was successful. So the http thread makes sense. When checking out a shopping cart, probably the http thread as well. Doing photo face recognition, a task queue. That may take a long time to do. And the user probably, doesn't need to see the result immediately. All right, let's talk about the different task queues and start off with the push queue which is the most common one. The execution of push queues are managed by App Engine itself. This means that App Engine has worker threads that scan these queues and pick up tasks. These threads then call a URL that you have specified when you insert the task in the queue. This means that the execution is broken out from the HTTP request response flow since App Engine provide the threads to execute the tasks. But the code used to process each task is still provided by you, since you provide the URL that the worker threads call. The best of two worlds, a generic execution methodology,. That works with code that you write. So the worker thread picks up task by task and calls your url for each of them. And this behavior continues for all the tasks in the queue until the queue is empty. By default, the maximum execution duration for a task is ten minutes. It is of course up to you when you develop the application to split up the work into tasks that can be completed within this time, for example 100 mails each. There are many different configuration options for queues in the following screen, we will look at some of them. First to note is that the queues of the find in the queue configuration file when you do development. All queues have a queue name. For all applications, half engine order provides a default queue with the name default. This queue can be used without adding anything to the queue configuration file but you may want to change its default options, in which case you need to define it in the file. Other things you can configure are the performance parameters such as, the rate of processing, the maximum rate in case of traffic peaks. The bucket size and the maximum number of concurrent tasks that can be executed. There are also a lot of parameters surrounding error management. So now we've talked about how to define a queue. Let's finish this part by looking at how to create a task and assign it to a queue for execution. The first thing you do is get the queue by the queue name then you create the task and set options such as the task name, the url to process the task, another parameter such as performance and retry options and finally you add the task to the queue for execution. Finally, it is important that you to protect the URL so only administrators can access them through the permission settings. You don't want external users to be able to execute your task logic should they get ahold of these URL's. That was a lot of theory, but that's it for now. Now the time is come for you to do some work because we have an exercise coming up where you will use push queues. Good luck. I'm going to show you how to run background tasks in App Engine applications using queues. When a conference is created, you can imagine that there might be a variety of tasks that need to be executed. Such as starting the process to book the venue, creating the agenda, organizing the catering. And sending a confirmation email to the organizer. You'd want to do all of these tasks in the background rather than trying to complete everything before the create conference function returns. In this exercise we're going to use the default task queue to send a confirmation email, like this one. When someone creates a conference. The learning goal is to understand how to use task cues. But you can understand that there are many other tasks that needed to be completed, when a new conference is created. To execute a task in the background using the task cue. The first thing you need to do is to find the work to be done. It's up to you to write the code to execute the task. This can be in a servlet or in an endpoints function. It just needs to be somewhere that can be accessed by a URL. Another thing you're going to need to do is to configure the queue. And you do that in queue.xml. If you're using the default queue, you actually don't have to do any configuration. But if you're using anything other than all the defaults, you're going to need to configure your queue in queue.xml. So here's an example of the content of queue.xml. You have the queue-entries element, that contains. A queue element for every queue that you want to configure. Specify the name of the queue and the rate that it operates at. And there's a bunch of other parameters you can specify as well. And then you're going to need to write the code to add the task to the queue. You need to start by getting the queue. And you use the QueueFactory to get a queue. If you want the default queue, then you just call getDefaultQueue on it. If you've configured a queue in queue.xml and you want to use that queue. Then you call the getQueue method on QueueFactory and passing the queueName. Where the queueName is a name from q.xml. Many need to specify the options for the tasks. The options include the parameters for the task and the URL that's going to execute the task. And the easiest way to build up the task options, is to use TaskOptions.Builder. You must provide the URL that's going to execute the task. When you use TaskOptions.Builder you just call the withURL method and you pass the URL. That's going to execute the task. Then to add params to the task and just call the .param method. I'm passing the params you can have as many as you want here I've just got two. If your task doesn't have any params and obviously you don't need to do that. You can write the code that adds the task to the queue, inside of the transaction if you want. And to do that, you specify the transaction as a very first argument to queue.add. When you're using objectify. You can just call the ofy.getTransaction method to get the current transaction. It's important to understand that you can put the task on the queue during the transaction. So the task only gets put on the queue if the transaction is committed. But the execution of the task takes places outside the transaction. The task going to be executed whenever the task gets to the top of the queue, whenever that happens to be. So long of course, that the transaction has already been committed. So let's take a look at the send confirmation email servlet. This servlet has a doPost method that sends an email whenever anybody creates a conference. We're implementing as a servlet rather than as an endpoint function. Because this functionality needs to be completely internal to the application. We absolutely don't want anybody else to trigger the sending of these emails. We've written this servlet for you. You can find the servlet in the lesson five folder if you want to. We've already defined it for you completely because our goal here is not to teach you how to use email but to, how to add a task to a task queue. However if you prefer you can write it from scratch yourself. And actually I do recommend that you read through this code because it does help you learn how to send emails from App Engine. Which is a cool thing to know how to do. So, basically what we do is, we get the email out of the request. We get the information about the conference out of the request. Then we create the body for the email, and include the information about the conference that just got created. We set the from field, we add the recipient, we set the subject, we set the text. And then here we send the email, and then we catch the exception in the case email didn't get sent. One thing to be aware of it is there errors in your code and the email doesn't get sent, your going to get an error in the last. However if the email doesn't get sent because you have exceeded your email closure for the day you not going to get an error here. So if you're email doesn't get sent, you might want to come and check your quota for sending emails. And you can see the quota page shows you exactly how many emails you've sent. Oh good, I've only sent one so far today. So, you can add the same confirmation email servlet as a done deal if you want. But then you do need to write the code to schedule the task, to add the task to the task queue. And to do that, you're going to need to update the createConference function, to add the send confirmation email task to the default task queue. And you're going to be doing that yourself. First though, I want to show you that you can use the admin console. To explore your task queues. So here in the task queues page you see the quota of your task queues. Iâ€™ve had one API call go out for task queues so far. And you can see the individual queues get listed. Iâ€™m only using the default queue. So, we only see the default queue here. So I drill down into it and I have nothing in my queue. So we go to my application though and create a conference. See here, Iâ€™ve created this conference task queues everybody. Now very quickly, I'm going to go to the Admin console, and update my Task Queues page. Okay, I wasn't quick enough to see it running. You can see that one task ran in the last minute. If I check my email, I see that I've got an email confirming the conference I just created. So we see that my task ran, and it ran successfully. But I wonder what happens if the task isn't successful. So over here in the create conference function in conference API, this is the code where I add the task to the queue. What I'm going to do now is, I'm going to change the URL for the task to be a non existent URL. So, I've redeployed my app. It has an incorrect URL for the task that's going to be executed when I create a conference. So let's just see. Okay, my conference got created. Now let's go look at the task queues in the admin console. So now let's see what happens when I refresh the task queues viewer in the admin console. Okay. So now looking down into the default queue I see there's one task in the queue, two were run in the last minute. It's running five per second. Scroll down, see over here there has been three retries so far. We are going to leave that running just for a little bit. So far we have had nine retries, that's probably enough. So I am going to purge the queue, to get the task off the queue, because it is never going to complete. It is important to understand that when a task gets onto the push queue and reaches the top of the queue it is going to. App Engine is going to keep trying to run it, until it actually succeeds, if you use all the default options. So it's really important to test your queues, so that you don't get some task wedged in there that's never going to finish. One other thing we can do here is we can look in the logs. And you can see that we do have this report, that the tasks/send_confirmation_email_x. That no handlers matched this URL. So whenever you see that kind of error, no handlers matched this url, that means your app's trying to do something. With a URL that doesn't exist and that often just means you've got a typo in your code. Yeah, and of course, that never happens. You could actually choose a different lock level to show so here if we just show warnings, we very quickly see the problem. No handlers matches this URL. No handlers matches this URL. It's pretty easy here to see what the problem was. So I've shown you how to use the task keys viewer and admin console. And talked about how to schedule the task. Now it's your turn to write the code, to send the confirmation email whenever anybody creates a new conference. So it's going to be your task, to add a task to send a confirmation email. The first thing you need to do is add the sendConfirmationEmail servlet to your project. And it goes in the servlet package. You can get the servlet completely fully coded from the Lesson 5 folder, or you can write it yourself as you like. And then you need to make sure you configure your send confirmation email servlet in web.xml. Then you need to update the create conference function in conference API. You need to add the functionality to add the task, to the task queue when ever anybody creates a conference. And if you like you can also update this function to use transactions so that the profile and the conference entities get saved together and the task gets added to the Task queue, and that all happens inside a transaction or none of it happens. And you can get the template code, to add to create conference from the lesson five folder, if you want or you can try writing it yourself from scratch. So you can optionally put the code, to create the conference inside a transaction. When you add the task to the queue in createConference() function, you can use the default queue or you can use a named queue, it's up to you. But if you use a named queue, you need to make sure to configure the queue in queue.xml. You can also use the default queue that configure it to use other options like change the rate, or change the retry options. And again, if you want to do that, you need to configure it in queue.xml. In that case you would just add a queue name default to queue.xml. So the development server running on local hosts does not send emails, it does add tasks to queues and actually has it's own simple task queue viewer, but it won't actually send an email. So if you to test the sending of emails you're going to need to deploy your application to appspot. So when you've done testing it on local host as much as you can, go ahead and deploy it to app spot. And then to test it of course you're going to need to create a new conference, and then check your e-mail to make sure that the e-mail arrived. Did you get an e-mail? And then go ahead and explore your test queues in the admin console. So check off each of these steps as you do them So let's take a look at the code, that adds a task to the default task queue. So it's createConference in Conference API, and then this is the code that we already looked at to get the profile. Get the conference key, get an ID for the conference key. And here is the code to get the default queue. And you're going to need, of course, when you did this you would've needed to import queue and queue factory. So, to get the default queue we just call queuefactory.getdefaultqueue. I updated my code to use a transaction, so here's the code for starting the transaction, ofy.transact, and then we run it, we run the transaction. Then we get the profile entity from the data store, we create a new conference subject. We save the conference in the profile, entities in the data store, this is all code from before. This is a new code to add the task. You see here that the first argument is ofy, don't get transaction. This is how you get the current transaction when you're using Objectify. And then we add, we call queue.add. And then the rest of the arguments to add are TaskOptions.Builder. Basically, building up the task options with URL, tasks, send confirmation email. Good job. I fixed the URL there, and then the parameter you want to send the email and we want to send the information about the conference. Then we return the conference from the transaction. And we finally, return the conference from the function. Okay. So let's talk about another type of queue called pull queues. This queue solves another kind of problem. Let's say that you implemented a site that requires humans to review comments. So the users of the site generate comments and these comments need to be reviewed before they are published. Similarly to push queues, you could create a queue. And then insert comments to be reviewed into this queue as tasks. And external people, well in our case robots, could review the comments, perhaps working from home in their spare time. So you have your queue where you add comments as review tasks. Then the different people would pull a review task from the queue and work on it. So let's look at the difference with push queues. Well in this case, App Engine is not executing the tasks. They are instead executed by the external workers. You can say that the task is pulled from the queue by the external worker. That's why they are called pull queues. The tasks that are pulled from the queue are leased by the external workers. The worker must complete the task within the lease time in which case it can be deleted. But if the task is not completed within the lease time, it is automatically returned to the queue. If we compare a pull queues to push queues, the differences are. So pull queues do not have a URL, since your code is not completing the task. Each task is leased by a worker for a certain amount of time. A worker must delete the task when it's completed, otherwise it is returned when the lease expires. External workers pull the queue using a REST interface. And there is no default queue for pull queues, so you need to explicitly create them. That's it for pull queues. Let's have a quiz. For the following examples, which queue would you use, Push or Pull? Select the best option for a Package Delivery Service, a Flight Check In, a Code Review, or Batch Processing of Images. So here are the answers. A package delivery service sounds like a pull queue because each package is probably delivered by independent workers that can pull tasks from the queue. What about checking in for a flight? Well I would like to know that I'm checked in, and in that case it's neither a push queue nor a pull queue. Then the confirmation would be delivered as part of the http response, even if it takes a little bit of time. This is a situation very similar to when you buy things using a credit card on the internet, where you also often wait for the response. What about code review? Well a code review sounds like a pull queue, because you probably have many people that can review the code, so the first one that's available can pull the code review from the queue. And then batch processing of images, which sounds like a push queue. This is because your code is probably doing the processing of the images. Therefore you want to have control over the execution. So we've talked about push and pull queues now. But what if you just want to do something at regular intervals? For example, perform a backup, remove temporary files or send a daily report at midnight every day. That's exactly what a Cron job does. It's a scheduler. An app engine cron job is very similar to a cron job in Unix, if you have worked with that. So, cron is a scheduler within app engine that allows you to specify tasks that are executed regularly. Cron is perfect to use to perform background tasks, which are not directly initiated from user activity. For example, to run batch or synchronization jobs of different kinds and back ups, etc. The cron job is very easy to configure and there are two things you need to specify. First of all, the URL that should be called. This is where you place the code you want to execute and then you also need to specify the schedule which controls when the task URL is called and as with the Queues there is a ten minute limit for dynamic instances. If you want more time than that, you can use resident instances. In this exercise, you're going to set up a cron job to periodically update the announcement about the conferences that are almost sold out. You've already written the function to create the announcement, so pretty much all you're going to need to do is to configure the cron job. So, you configure cron jobs in cron.XML, and this is an example for what cron.XML might look like; has a top level cron entries element and then each cron job is specified within a cron element. You must specify the path, and this is the URL that's going to run the task invoked by the cron job. You can optionally specify a description, and you must specify a schedule. The schedule indicates how often to run the task. There's a variety of ways to set the schedule, but you must strictly follow the syntax or the current job won't run. I recommend checking the formats for the schedule. The developer documentation does a really nice job of describing the syntax for the schedule, and giving examples. For example, you can specify it to go every 12 hours. You can specify it to go once a year, first Monday of, let's say December. And then there's other ways of specifying it. Anyway, I really recommend you take a look at the develop documentation for the schedule. But do bear in mind, although there's lots of flexibility in how you specify the schedule, you actually do have to get the syntax exactly right. So, you can't say every one hour. You actually have to say every one hours. The admin console on appspot for your application has a cron jobs page that shows you what cron jobs you've got running. I've got my cron slash set announcement cron job running already, and it's scheduled to go every one minute, and the last time it ran it had a success. If you recall, the set announcement function queries for all conferences that are almost sold out. So if we look at the quota details, you can see that my query ops number is going up. It'll go up every minute. The other thing that's going to go up every minute is the Datastore API calls. So let's see. So that's 162 and that's 143. Let's refresh, see what happens. If I refresh the browser, and you see that now my Datastore Query Ops has gone up to 144, and my Datastore API Calls have gone up to 163. So every minute these numbers are going to go up. It's actually not a big deal because this cron job doesn't do a whole lot, but if you have a cron job that does a lot of Reads and Writes to the Datastore, It is going to use up your quota. Another thing that running a cron job every minute does is that it means you're, it means you're app engine application is always in use, so it never has any idle time. Which, you know, if your application is in constant use by users anyway, it goes viral, you're hugely successful, not a problem. But when your developing and testing, it does mean that if you keep your cron job running frequently, it's going to keep your front end up, and you're going to use up your instance hours. So you can see here, I've already used 4.64 of my 28 instance hours. Not a big deal, but it's something to keep an eye on. Off shot load cron.xml two app engine. It stays there until you overwrite it with a new cron dot XML. So if you want to disable your cron job, it's not good enough to just delete cron.XML completely from your app and re-upload your app. You actually have to send up a new cron.XML with no cron entries. So just delete the cron entries for the jobs that you want to delete and reupload your cron.xml. And another thing you could do is just specify the schedule so that it only runs like once a year then you're not going to have to worry about Quotro or anything, but you know, why not just go ahead and delete it anyway So remember that set announcement servelet that you created earlier? Now you're going to set up cron job to run it regularly, say every minute, every ten minutes, whatever, to update the announcement. So to set up your cron job, you're going to need to create a cron.xml file and configure it to run /cron/set_announcement because that's the path that we set up for our set, set announcement function. And then specify the schedule, let's say once per minute. The development server on localhost doesn't run cron jobs, so when you're ready, go ahead and deploy your app to appspot. Then add one or more conferences that have between zero and five seats available. And the easiest way to do that is just to create a new conference with max attendees less than five. And then use the cron viewer in the Admin Console to make sure that your cron job's running. And then of course go ahead and get the latest announcement to check that the latest announcement did get updated. And you can do this either, you can use either the mem-cache viewer or the API's console to get the latest announcement. So now your cron job is humming along, it'll keep going by itself. That means it's going to run a query to look for conferences every minute, or however often you scheduled it to run. It's helpful for learning purposes to see the cron job running frequently, but it's not a good practice to leave cron jobs running more frequently than you really need them. This cron job does a fairly simple query, and then puts a value in mem cache, for which there's no daily quota. But if your cron job did something that intensively hit the data store it could easily use up much more quota. So you need to think about what your cron jobs do and how often they need to run. I've accidentally used up my entire daily quota running a cron job that searched all the conferences and saved results in the data store, so I learned my lesson the hard way. So go ahead and change the frequency to once an hour and when you've done that come over here and check this box. Alternatively, you could disable the cron job completely by uploading an empty cron job config, but remember if you just delete the cron config file completely then the one that's already up on app spot stays running. So one more quick quiz. How do you schedule your cron job to run once every two hours? Go ahead and enter that value in here. And that's it for cron jobs. So let's quickly look at the crondon xml configuration file, where we set up the cron job, to run the set announcement function. So the URL, it's /crons/set_announcement, basically just the task to the servlet that runs the task. And a description, it's kind of optional, but very helpful. And the schedule is every one hours. It's not every one hour, it must be every one hours. And then if you had more cron jobs you would just add more cron entries and fill them in, etc. And that really is it for cron jobs. So now when we have written all this code, let's look at how to scale your application, using modules. Modules are a serious heavy-duty function within App Engine and they allow you to partition your code, have better control over scalability, and do version control and online upgrades. For simplicity, we did not use modules when building Conference Central, but it is something we strongly suggest you start exploring on your own. By looking at the online documentation. All right, let's get started. When you create an App Engine application using modules, it will conceptually be structured like a tree. At the very top, we have the root, which is your application, and your application is made up of a number of modules, in this example two. A module groups three concepts. Code related to the module. The instance class that should be used to execute the code, this is the speed of the CPU, and the amount of memory that should be used. The scalability parameters including the number of instances to start and their life cycle. So a module groups code to be executed, the performance resources and the scalability and instance life cycle you want to have. Each module can then have a number of different versions associated with it. A version is essentially a version of your code being maintained in the module. So, after you have deployed your application into production you can deploy new versions of your code and you can have multiple versions running in parallel, and gradually migrate traffic from the old version to the new. This capability allows you to do version upgrades without having to bring down your application. Something that is extremely difficult to do without App Engine. And finally, there are instances. An instance is what actually executes the application code. And if you want to scale your application, App Engine can fire up more instances to manage the additional load. And since the instance class and the number of instances define the performance and scalability of a module. The capacity of your application depends on the instances class and the number of instances you run. This is configured on the module level, and that is exactly what we will look at now. How to configure a module. Lets start looking at two scaling options for modules. Manual Scaling and Automatic Scaling. These specify different scale up and scale down characteristics of instances. Manual scaling allows you to create instances that are always up and running and that never terminates. Because of this, they don't have the ten minute execution limit with they process tasks or cron jobs. Since they are always up and running, they can work for any amount of time. And that means that they are great to use if you have long running background tasks or cron jobs. The only thing you need to configure for manual scaling is the number of instances you want the module to start. That's manual scaling. Let's now talk about automatic scaling. Automatic scaling is the option that allows App Engine to automatically scale your application up and down depending on the load. The first two options you can specify for automatic scaling is the minimum and maximum number of idle instances you want. What does this mean? Why would you want to have idle instances? Well, instances have a startup time and if you don't want your users to wait for the response while your application needs to scale up by starting new instances, and it could be good to have idle instances available if your application needs to scale up. So your users don't have to wait for more instances to start. Let's now look at latency. Where you can specify the minimum and maximum pending latency allowed for requests. These parameters work as follows. So let's say a request comes into your application right here, and there's no instance available to process it. Then it is put in a wait queue. App Engine now has a decision to make. When to scale up your application using more instances. Well, to begin with, it will wait for some time to see if any of the existing instances become available to process their request. This is called a minimum pending latency, if this time passes, App Engine is considering starting a new instance to manage the request. And if the next pending latency time expires, then a new instance would be started for sure to manage the load. This is how App Engine performs a scale up of your application. Rather than specifying a number for these four parameters, you can all set them to automatic. In such case, App Engine will set them according to the dynamic analysis it performs. Finally, both manual and automatic scaling have a common configuration element. Which is the Instance Class. The instance class specifies the speed of the CPU and the amount of memory to use for each of the instances started. Check out the developer documentation for more details on the options available. As you probably see by now, modules is heavy-duty stuff. And in addition to the scaling options we looked at, it also has versions that we briefly touched on. Versions allow you to perform online upgrades on part of your system without any service disruption. Without App Engine, doing automatic scaling and dynamic upgrades are extremely difficult problems to solve. So make sure that you use this great functionality. Okay. Let's look at more heavy duty stuff, Appstats. Appstats is a function that allows you to get extensive information on how API functions are called by your applications. This is used to profile your application. You do this by inspecting the API calls made by your application to, for example, Datastore in Memcache. And then you could use the information to optimize your application. For example, you can find opportunities to minimize latency by caching data. It can also be used to reduce or bundle API calls. Appstats can also help you reduce cost if you go beyond the free tier, as it can display the cost associated with different API calls. So let's see how you can use Appstats. But first of all, you can enable the eight I tracing through configuration. So there is no need to make any modifications to your application. And when you have run your application, it is possible to access the profiling information using a URL. You can see how to do both of those things in the instructor notes. So lets look at the information that apps will provide you with. First of all, Appstats has a dashboard screen where you will see all the different data available. So, let's look at each section separately. The RPC stats table shows statistics information for each remote procedure call made by your application. So, here you can see, for example, Datastore get operations. You can see the number of calls, the cost for the calls. And the percentage cost for the calls. This page also displays other calls, for example Memcache Get or Datastore RunQuery. That's the RPC stats table, very useful information. The path stats table shows similar information but it is grouped from the perspective of your code instead. So here we can see that our query conference makes calls to Datastore Get, and Datastore RunQuery. The request history table shows information about a specific request that was made. Here, for example, query conference was executed at this time and made call to these API functions. This table also has statistics for register for conference, and get profile. The RPC timeline graph shows when specific RPC calls were made and how long the request took to process. So here you can see that get OAuth_user took six milliseconds, followed by Datastore begin transaction. Four milliseconds, then two GET operations towards Datastore, followed by a PUT operation. And then finally, the transaction commit. So this graph shows you the sequence of API calls, and how long each took to execute. And of course, you can also see your complete request latency. That's appstats, a great way to understand your application behavior and optimize it. Another heavy-duty topic which is good to know about is edge caching. To describe this, let's look at the information flow for your App Engine application. First of all, users that want to use your application are connected to their internet service provider. This provider connects to Google data center. After the DNS lookup has determined that your application is hosted by Google, Google then identifies the data center where your App Engine application run, and starts talking to the App Engine front end. If the content is dynamic, the App Engine front end determines the instance that should manage the request. So these are your App Engine instances that run your application code. But if the request is for static content, for example images or static HTML, the front end can retrieve it directly from the static servers. And in both cases, the response is returned back to the user. So this is a good architecture. But as it looks right now, all the requests have to be sent to the data center, which hosts your App Engine application. It would be much better if more content could be served directly by this data center. First of all, it would ease the load on this data center, but more importantly, since it's closer to the users, the response would be delivered faster. This is exactly what edge caching is all about. Edge caching is a cache that sits in the data center closest to the user. So whenever there is a request, the result can be served directly from the cache if it's available there, rather than going through data center 2. That means less load on data center 2 in your application, and faster responses to your users. A win-win. So the question is, then, what do you need to think about to use edge caching? Well, there are two ways. The first one is to set the cache-control header, in the HTTP response. This should only be done if a subsequent request of this kind would return the same result. The second option is to define as much content as possible as static. Since static content does not change, it's great for edge caching. You can define which content is static through configuration files. A good opportunity for you to look at the online documentation. And remember, as most of the time with caching, there are no guarantees that the content will be cached, but when it is, it will be good for both your application as well as your users. Okay, let's do a little quiz called, how to optimize? So as rows here, we have objectives. Optimize application code, reduce latency for static content, make app more responsive, reduce data store reads and improve performance as user base grows. And as columns, we have different optimization techniques. Edge caching, mem cache, automatic scaling, app stats, and queues. Please select the appropriate optimization strategy for the different objectives. There could be more optimization techniques for a single objective. Good luck. Okay, let's look at the solution. What about optimized app code? Well that's about making the code actually run faster. App stats is the best option for that. What about reduced latency for static content? Well doing this would involve reducing the latency to the user. A perfect example of edge caching. What about making your app more responsive? Well, certainly queues could be an option here to reduce the amount of time spent when you process the request. But that could also achieved using automatic scaling parameters, and of course mem cache to serve content from memory instead of datastore. What about reducing datastore reads? Well certainly, mem cache would help out here, but edge caching could also be an option if the content is suitable for that. What about improving performance as user base grows? Well, that's a clear cut scaling out problem, so automatic scaling. All right, I hope you did well. And this quiz has no exact answers. So be sure to discuss this in the forums as well. Congratulations. We're now at the end of lesson five. In this lesson we covered the big heavy stuff. Such as mem cache, push queues, pull queues and cron jobs. All essential components to build a big application. We also looked at scaling options for your App Engine application. In the next lesson, we will wrap it up by building a mobile front end using cloud end points. Come join us. Welcome to Lesson 6. We're at Android Land here at Google. Why are we at Android Land? Since this course is about building server applications. Well, since we use Cloud Endpoints when we built Conference Central, we now build clients for any kind of device, Androids, IOS tablets, whatever. And we don't have to change our server application. Hey, this is Confer Central running on my Android device. I can browse conferences. I can register to attend them. That's super cool. This is exactly what we will cover in this lesson. All right. So before we start to look at the Conference Center Mobile App, lets do a little poll. Which device do you use? Is it an Android device? An IOS device? A Windows phone? Or some other device? Or perhaps, you're a very rare person today, and you use no device at all. Select all that apply. The time has come to check out the mobile app for conference central. We pre-built one for android, and if you have an android device you can also try it out on that device. Please see the instructor notes. This app will work towards a conference central instance hosted by Udacity. But remember, since you used cloud end points when you develop Conference Central. You could also make this app work if you recompile it towards fewer Conference Central instance. So, here is the Udacity Conference Central app and when I select it I need to select a user account. So, I select one here. After that, I immediately get to the main screen, which displays all the conferences that have been registered. So here you can see all the conferences created, in the conference central instance, hosted by Udacity. Should a user add a conference using the web browser interface, for example. They would also show up here, since the Android device, and the web browser. Using the Cloud Endpoints API to talk to the conference central server. When I select a conference, for example, the power of chron jobs, I can also see the details for the conference. I can also see the max attendees, and that there are two seats left that are available. If I click register, I get registered to the conference. And I can see which conferences I am registered in, by this check mark on the right. And if I go back to the conference details, you can now see that the seats available have been decremented to one. Now, I have the option to unregister from a conference. And as you can see, when I do that, this mark disappears and, again, the available seats are two. And that's the power of cloud endpoints. When you create your API in this way you can access your server application from any device. Let's look in a little more detail on how it works. Okay, so let's go into some more details on Cloud Endpoints. You probably remember this picture from lesson two, where we introduced Cloud Endpoints, and where we described this capability to create one API that you could use to create client applications for many different devices. Well you may wonder now, why is Cloud Endpoints any different from a pure HTTP protocol? For example, a REST API. Well, let's look at that. When using Cloud Endpoints, it allows the development environment to inspect and be aware of your API. This has multiple values. First of all, application design. When designing your backend application, you can focus on the high level application design and you don't need to think about low level communication syntax and semantics. Cloud endpoints also performs native client library generation for a number of different languages. This helps out greatly, with a number of different things. For example, communication and establishing connectivity and error management, so you don't have to deal with low level communication errors. But also, higher level functions such as user authentication that we use for Conference Central. And also, since your API can be expected, Google can provide many tools around it. The API Explorer is just one example of such a tool, which is extremely useful. So Cloud Endpoints is a great way to develop APIs that are rock solid, easy to use, portable across devices and languages. And can be used with tools, such as the API explorer. Great value here in other words, since it lets you focus on your app and let Google take care of all the low level details. Let's now look at cloud endpoints in your development environment. We've come to the last coding exercise in this course. Now that you've got your conference central application up and running, I'm going to show you a couple of things you'll need to do if you want to write a mobile application to use your conference API. You're going to need to give your mobile app a client ID. Regardless of whether you're building an Android app or an IOS app, you need a client ID. And just like with the web application, you create the client ID in the developer console. We're also going to generate the client libraries for your conference API so that you can include those libraries in your mobile application. But what your mobile application chooses to do with the Conference API, well, that's up to you. Come on then! So let's talk about, how to enable a mobile applications, to access the end point functions that you've defined, in your Conference Central application. So, here's the Android app that we have, that will access the Conference Central app, running on Udacity. So you've already learned about setting the client Ids, to specify the clients that are allowed to access your backend API. Well, to allow a mobile application to access the backend API. You have to add the client ID for your mobile app as well. So here we're looking at the @api definition at api definition in the conference api class. And here we've specified the clientIDs. We've got the web client ID. And here you see we've specified the Android client ID. And if we had an iOS ID, we would specify that here as well. We have the API explorer client ID. And we've been using the Constants.Java class to hold our client IDs, as well as other constants. So this is my client ID, my web client ID. And then here is where I would put the Android client ID when I have it. So one other thing that you need to set for Android apps, is you need to specify the Android audience. So the client IDs list protects the backend API list from unauthorized clients. But further protection is needed to protect the client, so that their [INAUDIBLE] can work only for the intended backend API. And for Android clients we use the audiences attribute to specify which backend API's they can connect to. So the value of the audience's attribute needs to be, the web client ID of the apps that the Android app will connect to. So, looking again at constance.java, in this case we set the android audience to be the Web Client ID of this conference central application. So, when you create your Android Client ID, you're going to need to know a couple of things. You got to need to know the package name of the classes in your Android application and you're also going to need to have to show one fingerprint of your application. When you build your Android app in debug mode, the STK automatically creates the debug key inside the application with it. You can also generate a new key. To do this, you'll need to specify the key's full name and the key store alias. So I'm going to go ahead and generate a new key. So I call the keytool passings dash genkey and then I specify the keystore name, which I've very kindly called keystore dash name.keystore. Need to specify an alias for the keystore, which I've cunningly named keystore dash alias. Then I'm going to need to enter a password. And you can pick whatever password you want, just remember it. Then it's going to ask some questions. Go ahead and answer the questions. Then at the end, make sure you say yes to actually go ahead and do it. And then it's going to ask you to enter the password for the keystore alias. And if you want to use the same password as you just entered before, then just press Return. Now I've created my new key. To create the Android client ID, I'm actually going to need the SHA1 fingerprint of the new key. And to get that, I'm going to call keytool, and you specify the ex, -exportcert. You need to provide the alias. My case it was just keystore-alias. And the keystore name under my case it was just keystore-name.keystore. So now I need to enter the password. And you see here it gives us the certificate fingerprint. And here is is actually the SHA1 value. So I'm going to need to copy this whole thing here. You don't include the SHA1 colon, but you include all the value of the SHA1. You're going to need to copy that. You'll need that when you create your Android client id. Okay, so now I'm going to create my Android client id. And just as you did with your client id for web application, you create your Android client id in the developer's console over at console.developers.google.com. So to do that, you choose the Credentials screen and the app is in auth. Choose create new client ID. And then this time, make sure you choose install application. Select Android. Then you're going to need to provide the package name, and this is the package name of the classes in your android app. And in our case the package is com.google.devrel.training.conference.android. going to need to copy over the shell one finger print. Hope I got that right, you can leave deep linking disabled and you create your client ID. Okay now you say, I have the client ID for web application and the client ID for android application and I am going to need to take this client ID here and copy it. And over here, in my source code, I need to enter the android client ID. So one more thing you're going to need to do is to generate the client library containing your endpoints API. Once you've got the client library, your mobile app will be able to include it so that it can make calls to the endpoints API. For Android apps generating the client library is very straight forward. In the terminal window go to the directory containing your projects pom.xml file. Here's my pom.xml. Then you need to run the command to get the client live. MVN appgengine:endpoints_get_client_lib. Now the process runs. â€˜Kay. Build success. I always like the sound of that. Now whenever you do a build the results go into a target directory. So hereâ€™s our target directory. Letâ€™s go into it. And here you see the endpoints dash client dash libs. So go into endpoints dash client dash libs and youâ€™ll see a folder with the name of your project. Go into that folder. Now go ahead and invoke maven to build the client library. This is very simple. You just do MVN. Install. Now it's building. Now it's done. This builds the required class files and it creates the jar files that you're going to need to add your client project. So now we're done and we've got the target folder. And you see, in the target folder we have this snapshot jar. So this is the name of the project. This is the version. Snapshot.jar. This is the client library jar. You'll need to add this client library jar to your Android app. The process of adding the client library jar to your Android app and also how to call the endpoints API inside your Android client. It's very documented in the developer docs. So we have, it explains how to generate the client library, actually we already did that. So the docs explain how to add the client library to the project. There's a couple other things you need to do, you need to create a service object and then there's a discussion of how to call the backend API. And as well as the information in the developer docs, so we've written a document that takes you through the steps that you're going to need to do to get an Android application to use the conference central end points API. You'll also need to remember that if you do change your backend API, you're going to regenerate your client libraries and readd them to your clients. You can also access your backend API from IOS apps. But since these don't use Java, the process to generate the client library is slightly different, and it's well documented in the developer docs as well. So, you can read about it in the developer documentation. Now that you've got the client library for your mobile device, it's up to you how to use the conference API in your mobile app. So the Android app that comes with this course, the conf, the Udacity Conference Central app, you can get it from Play store, is very simple. And it's really only meant to be a demo, so it's not fully functional. Basically, all it will do, if it will query for the conferences, it will let you register, and it'll let you unregister. But it doesn't do very much else. Feel free to get the source code for the Android app and to hook it up to work with your own conference central application. You may need to make some small changes to your backend API code, so be sure to check the instruction notes for this video. These changes will make your backend API code more [UNKNOWN] for all client apps. So we'll continue to work with your WebUI clients as well as with Android apps. So also feel free to extend the source code from the Android app to call more of the back end API, as you like. Wow, we just looked at the mobile app and how its connects to conference central. Be sure to watch this space, because combining the power of the data center with mobile technology is an area that's growing a lot. Let's do a quick recap on what we did in this lesson. First, we took a look at the Android mobile app that works with Conference Central. Then we took a deep dive into Cloud Endpoints, and how it can help you create any kind of client that works with your server application. Finally, we looked at how to generate client libraries and create client IDs. And remember, watch this space- Congratulations, we're now at the end of this course. We're so proud of you. It's been great to have you with us all this time. You're well on your way to building great applications that run in the Google Cloud. But guess what? We're going to be launching more courses about the Google Cloud Platform so make sure you look out for those. But in this course, you also saw how to build a mobile app that can talk to your Google Cloud applications. Talking of mobile apps, we're going to be launching a course soon on how to build an Android application. So make sure you look out for that one. But before we leave you, just one final thing you have now seen what you can do with App Engine today. Let's have Urs HÃ¶lzle a senior VP of the infrastructure Google tell you about the future of the Google Cloud platform. So we're back here with Urs. In this course, we learned a lot about App Engine. Urs, what can we expect from Google Cloud platform and app engine in the future? A lot of innovation because what I'm really most excited about is that we're just at the beginning of something that I think is going to be really big. You know, we're proud of what we have today but what we're really aiming for is getting to something that five years from now is so much better. I think the rate of innovation that we're going to see in NetCloud is going to pick up and we hope to be a big part of that. But our goal really is to take what we have and make it so much easier to scale, so much easier to program, so much easier to be on mobile, so much easier to analyze data. And then really get a platform for you that is everything that it is today but much much better. Really to the point where, if you remember what you thought was great today, we really have a great product that you know five years from now you'll kind of remember and say wow, you know, I'm kind of, I was naive to think that this was great because if I look at today's product. You know, was really just the beginning of it that's what I'm most excited about. Do you have any final words to the students that have now learned a lot about App Engine? Now that you know App Engine, you're actually in a great position to try out other parts of our platform and one of the things that we're really going to work on is make it very easy to combine App Engine with VM's or would be Query or with storage. So that you can mix and match and implement your application not just in pure app engine but really combine in with any other part that we have in our infrastructure and still have it be very easy for you to both write and run that's the path we're on and I hope you enjoyed app engine and you'll enjoy the other parts even more. That's right. We've barely started on this great journey to build Google Cloud applications. So keep your coding fingers up to date and stay on top of what's possible in cloud computing because day by day the Google Cloud platform gets better and better. So you can be sure that you'll always. Build the best applications when you run them on Google Infrastructure. See you. [NOISE]