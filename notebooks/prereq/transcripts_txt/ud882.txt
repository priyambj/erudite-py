We all love images on the web. Images can be beautiful, fun, and informative. Now the web started life as a, a text only medium. Check out these early versions of well known websites. Thefacebook.com looks pretty cool, huh? But the ability to embed images was the innovation that really made the web take off. And now we have an incredible wealth of images on the web. Here's one of millions of pictures from the Google Art Project. You can probably get closer to the picture here than you can in the actual museum. Now, given the huge and increasing variety of devices and contexts for consuming web content now, we need to think again about how we use images. I'm Sam Dutton, a developer advocate at Google. And I'm Cameron Pittman, a course developer at Udacity. And we'll be teaching you how to use images responsively so they work really well across a variety of devices, display sizes, and connectivity scenarios. Throughout this class you'll be building a webpage design for a blog site that uses several kinds of images. And by the end you'll be confident that you can incorporate images responsively in your own work. Let's get started. Yeah, let's do it. And on mobile, we need to be extra careful, images consume a lot of bandwidth, more than 60% of the bytes that cross the web. That's bandwidth we can't always rely on or might not want to use, and images don't always work so well on different screen sizes. This photo from the Tower of London looks great on my new high DPI display, but when I resize the window, the fixed size image gets cropped. With the same image on my phone, I need to scroll horizontally and vertically, and that's a terrible experience. The web was actually invented with responsiveness in mind to enable us to publish content to a variety of devices. We need to think like that again, and make sure our images work well, wherever they're seen. So we can avoid this. Check out the pixelation around the eyes on the horse. And this, not really seeing the surfer anymore. And worst of all, this. I'll leave you with a quote. Create a product, don't re-imagine one for small screens. Great mobile products are created, never ported. That's from Brian Fling. So great designers don't optimize for mobile, they think responsively, to build sites that work across a range of devices. As the course continues, you'll have a chance to practice by working on this blog. Which right now is pretty ugly and pretty slow. You'll turn it into something that looks a little bit like this, which is a much more reasonable blog. There's some aspects of art that go into this. So, your finished version may look slightly different than ours. But regardless, it's our goal that working on this blog will help you easily deliver the highest quality images with the fewest bytes possible. In this course, you'll be using Google Chrome and Chrome's developer tools, which we call Devtools for short. If you haven't used Chrome Devtools before, check out the link in the instructor notes for some information and instructions for getting started. You can use Devtools to quickly get an idea of how your site performs on a rage of different devices. However, emulators and simulators can never really replace the experience of using a real phone or tablet. To test your work on a phone or tablet, you'll need to make sure you're set up to use remote debugging. For the remainder of this lesson, you will be getting some instructions from Peter Lovers on how to get started with mobile DevTools and debugging on your mobile devices. If you're already familiar with mobile debugging, feel free to skip ahead to the video called Lesson One Wrapup. The set up is simple. All you need is an Android device, a USB cable, and your development machine. Let's take a look. Before you get started you need to turn on the Developer Mode in your Android device. This may be different on any given device and you can check your device's manual on how to do this. In many cases though, you need to go to your device's settings, click on About Device and then click on Build Number seven times. Seriously. Next you'll want to turn on USB debugging Again, this varies slightly on your given device, but this is usually located in the developer options. We also need to make sure we have the right tools [UNKNOWN]. On my laptop, I have Chrome Canary and on my mobile device, I have Chrome Beta installed. Now that we have everything set up the way we need, open Chrome on your development machine and go to Chrome inspect. Make sure the site you want to debug is open on your mobile device and then connect your laptop to your mobile device via USB. Then confirm that you want to allow USB debugging. Back in our development machine, we can see a list of the attached devices and the Chrome tabs that are open on the devices. You can even open other tabs. We can also focus on specific tabs, you can reload them And you can even close a tab. The best part of course is that you can inspect the pages that are running on your mobile device, from your development machine let's take a look. One of my favorite new features is the new screen cast mode. This allows you to drive the experience on your mobile device from your development machine. You can click on links, and see them update simultaneously on the device. As well as on your desktop. As you can see, you have all the familiar features from the development tools available for mobile now. Now, that was really easy and it's also possible to do this on mobile Safari with the web inspector using the iOS web kit debug proxy. Now, that's a little bit harder to set up, so check out the link below for more information. Now that you've got your environment set up, you're ready to get started developing with the responsive images in mind. In the next lesson, you'll start experimenting with image sizing, compression, and formats. And by the end, you'll be ready to intelligently reduce the number of bytes required for your images. See you around. Like a. [LAUGH] Welcome back. By the end of this lesson, you will be prepared with the workflow that will make it easy for you to optimize your images so that they take up as little bandwidth as possible while still looking great. You'll be thinking about image quality and size. And with images on the web, it all comes down to size, but what does that actually mean? Here's a question for you. Can you spot the differences between these three images? To be honest, I can't tell the difference with my eye. These three look the same to me. For this quiz, check out the site in the instructor notes. Then use DevTools to work out the difference between the three images. Are the differences caused by compression level, display resolution, the natural resolution, or the file type? Check all that apply. I've opened up DevTools, and I've navigated to the Network tab. I'm ready to record so I will refresh the page. You can see the three requests for the three different images, horse1, horse2, and horse3. It looks like their sizes are really different. Notice how horse2 is almost ten times bigger than horse1, and horse3 is also bigger than horse1. Given that the images look identical, it seems like there could be some wasted bytes here. Inside the Elements pane, I can find out the actual dimensions of these three images. There are a couple of ways doing it. I'm going to show you a hard way and then an easy way. DevTools has this awesome feature where you can manipulate an element in the dom by clicking on it up here. So I've clicked on the first horse. And then inside the console, I can access it by typing $0. When I press Enter, you see that, hey, its the horse. To find out the horse's actual width, I'll simply access the property naturalWidth. All right, so looks like that one is 426. I'll select horse2. And now, because horse2 is selected, I can actually run the exact same command. It looks like that one is also 426 pixels wide. So I'll try the third one. And ah-ha that one is twice as large at 852 pixels. So it looks like these three images have different sizes. Okay, now here's the easy way of figuring that out. Simply hover over the image, and you can see it right here. There is the natural width and height. Horse2 is the same just like we saw a second ago. And then horse3 is twice as large. So then what could be different about horse1 and horse2? As it turns out, their compression levels are different. So at this point it's clear that horse3 is definitely a larger image. But then what's different about horse1 and horse2? If they have the same resolution but different sizes, well then, it's pretty clear that they have different compression levels. So, the answer to this quiz is that they have different compression levels and different resolutions. With images like photos, the total file size depends on the number of pixels multiplied by the number of bits it takes to store each pixel. So, to improve performance, you need to keep images as small as possible and compression as high as possible. It's a common mistake to save images with dimensions too large, and quality too high. It might sound counter-intuitive, but the first rule for saving images to a range of devices is to save images with the lowest possible quality, and the smallest size as possible. But, how do you reduce file size while maintaining quality? Throughout this course, you'll learn how to use responsive techniques to do just that. What's more, the average webpage makes a whopping 56 requests for images. Every one of those image requests has a cost in terms of page load. And studies by Google, Amazon, and others have shown that even very small delays in loading pages can result in a significant loss of traffic and revenue. Here we see from Google that a 0.4 to 0.9 second increase resulted in traffic and ad revenues down by 20%. And for Amazon, every 100 millisecond increase in page load time means a loss of sales of 1%. So let's have a deeper look at CSS sizing. I've given this image a fixed size. 640 by 360 pixels, which is the natural size of the image. It looks great. But of course, when I resize the window, the image gets cropped and remember the problem we had earlier? On a phone, the image is larger than the view port. Which means that to see the whole image, you have to scroll horizontally. Let's try relative sizing. I set the image width to 100%. It looks good in the smaller browser window and looks good on the phone. But, when I resize the image larger by resizing the browser window. It starts to get pixelated and blurry. Let's do something about that. If we set the max-width of the image to 100%, the image will expand nicely, but only ever as wide as its natural width. Two simple things you can learn from this. For devices such as laptops and desktop monitors, don't assume the window size is the same as the screen size. And don't assume the window size will always stay the same. Using max-width can be a good way to respond gracefully to a change to a larger view port. When you're thinking responsibly, consider large displays as well as small. So what if you want two images to fit side by side, no matter the size of the view port? Well, that's easy. Just use relative sizing, 50% width. But what if you want to add a ten pixel margin between the images? You can just add margin-right, 10 pixels, right? You can get around this with our old friend calc. Calc allows you to do simple calculations in CSS values. And that's a great way to combine absolute and relative values. For example, combining a percentage width with a fixed margin. Now the calculation here looks a little complex. But all we're saying is to give each image a half of the width available. I've also used the last-of-type selector to ensure there's only a margin between the images and none to the right of the second image. And here's the finished product. I'll open up devtools and take a look. Inside the style tag, you can see that I just simply did exactly what you learned a minute ago. Only this time, I'm dividing by three, instead of two. To break this down, I set a margin rate of ten pixels, so that each image has a margin to the right of it of ten pixels. And I set the last-of-type selector on the image to margin-right 0. This make sure that there's no margin after the last one. Then to calculate the width I simply took the whole viewport, 100%, subtracted the 20 pixels taken up by the two margins, and divided it by 3. Calc is really awesome. I hope you realize just how awesome this is. You're mixing and matching units and it's giving you something useful. Make sure you take advantage of calc whenever you can. Let's think some more about the size and the shape of the view point. Think about the way you use devices. Phones and tablets are often used in portrait orientation whereas a full screen browser window on a laptop is landscape. Now, even though you can't change the window size on a phone or tablet, these devices. Have another rather tricky feature when it comes to responsive resizing. Orientation can change, and when it comes to landscape and portrait, you need to think about content as well as size. Tola square images can work well in portrait mode on a phone but wide images can be a real problem. Again for responsive design the golden rule is don't assume the viewport size will always stay the same. You'll learn the impact of image choice and art direction later in the course when you find out how to use the picture element. And later in this lesson, we'll look at ways to work with orientation using media queries. On the subject of sizing, there are some CSS units that you may not have heard of, but which are now really widely supported. How about if you want an image to responsively cover the whole height of the viewport? Now, you can always do that by setting the height of the image to 100%. But that only works if the height of the HTML and the body elements are also set to 100%. A simple way is to use the VH unit, which stands for viewport height. One VH unit corresponds to 1% of the viewport height, and so 100 VH means 100% height. You can do the same with VW for viewport width. Here you can see we've set the width of the image to be 100vw, 100% of the viewport width. And you can see that it resizes responsibly. Another common responsive use case is when you want an image to resize to fit the smaller of the height or the width of the viewport. The vmin unit, viewport minimum, corresponds to 1% of the viewport width or height, whichever is smaller. If you set both the width and the height to 100vmin, you'll get the effect you're after. How about if you want an image to cover the whole viewport but without stretching or squashing? For this you can use the vmax unit, which corresponds to 1% of the viewport width or height, whichever is greater. So, if you set both the height and the width to 100vmax, the image responsively resizes to cover the viewport. There are two fundamentally different ways to create and store images and this affects how you deploy images responsibly. Raster and vector. Raster images, photographs and other images represented as a grid of individual dots of color. Raster images might come from a camera or a scanner, or be created with the HTML canvas element. Vector images, images such as logos and line art, which can be defined as a set of curves, lines, shapes, fill colors and gradients. Vector images can be created with programs like Adobe Illustrator or Inkscape, or from using a vector format such as SVG. SVG makes it possible to include responsive vector graphics in a web page, and we'll talk more about this format later. The advantage of vector file formats over raster file formats is that the browser can render a vector image at any size. After all, vector formats describe the geometry of the image. How it's constructed from lines, curves, and colors and so on, not individual dots of color. Let's see what happens when we resize this page. Now, that's an SVG image on the right and a PNG on the left, and you can see as the size increases, the PNG is looking to start a little blurry, whereas the SVG is perfect at any size. For this quiz, I want you to imagine that you're a graphic designer. A friend asks you to to make a 50 meter, or a 165 foot banner, made for a skyscraper. The banner will have some kind of company logo here and then some text next to it. So should you give your friend a vector or a raster image? And why? Should it be a vector because the file size is smaller? Should it be a vector because it will scale without quality degradation? Should it be a raster image because the file size will be smaller? Or should it be a raster image because it will scale without quality degradation? Pick one of these four. The correct answer is, a vector image, the reason being that vector images scale without quality degradation. This means that no matter how big they are, they will always look the same. This is definitely useful if you're trying to make something that's 50 meters wide. So there are, obviously, tons of images on the Internet. In the instructor notes you can find a link to a site with a Chrome logo, a picture of Sam's kittens, the flag of Mexico, a div with a background that is repeated and a div with a background that is a gradient. That is to say one color transitions into another. For each of the images identify whether they are a raster image or a vector image. Starting at the top with the Chrome logo, it's pretty clear that it's a set of colors, set of lines, set of gradients, and some pretty regular shapes. In fact, if you open it up in DevTools, you'll see that this is in SVG, making it a vector image. Sam's cute kittens are a photo, which means that is by default a raster image. That is to say, it's a grid of colored dots. The Mexican flag is pretty complex, but believe it or not, this is an SVG, making it a vector graphic. This middle part here is obviously the tough part. And while it does look complex, you can make it with an SVG. If you don't believe me, check out in DevTools this file's source. And for this last gradient, it can be defined as some geometric rules governing how the color should change, so this one is also a vector image. So the final tally is that the Chrome logo is a vector, the kitten is a raster. And then the Mexican flag, repeat background, and gradient backgrounds are all vector images. This image combining line art and a photo was saved as a JPEG and it looks fine on a phone at small display sizes. But on a desktop monitor, resizing the browser window, the JPEG format begins to show its weaknesses. With JPEG, edges can lead to artifacts. For this example, SVG for the logo would have scaled better. Here's the same with SVG for the logo over a JPEG of the photograph. The photo and the logo both look good small or large. You can see those crisp edges there. Both look great. File sizes are down too. Here's the version with the logo over the image as a, one single JPEG. And here we have the version with the SVG over the JPEG. And you can see that even though we need an extra file request, we're actually only using about half as many bytes. Take a look at these three logos. They look identical, right? But if you check with the dev tools, you'll see that we've used three different file formats and there's a massive difference in file sizes. The chrome.svg there is, well, it's about a 25th the size of the PNG. There are some good general rules for improving cross-platform image performance. Use JPEG for photographic images, and browsers such as Chrome also support other formats, such as WebP, which can deliver better compression and features. WebP supports alpha transparency animation along with lossy and lossless compression. Now, if you can, use SVG for vector images, and we'll show you how to do that later. And for vector art and solid color graphics, such as logo and line art, if you're unable to use SVG, use PNG. And do use PNG rather than GIF. More colors, better compression and no licensing issues. For more information about image formats, take a look at the links below the video. There's a link in the instructor notes that'll take you to a website that looks like this. Take a look at these two images. Both of them look the same, but can you spot the problem? Pop open dev tools and see if you can find out. What's different between them? Is it their compression level, their display size, their actual or natural size, or their file type? Check all that apply. So I've got the website open and I've opened dev tools to the Network tab. I've hit refresh and all of the network requests are showing. Here's one image and here's the other. Notice that their size definitely isn't the same. One is 123 kilobytes while the other is only 63 kilobytes. It looks like udacity_large has different dimensions than udacity_small. $0 refers to whatever element you have selected, up in the Elements pane, which, in this case, is the image. When you do .naturalWidth on the image, you see that its original width is 601 pixels. Now, I want to take a look at the other image. Running the same command gives us 1202 pixels. So large is twice as big as small. The thing is though that both of these images look, well, pretty much identical. So there's a lot of wasted bytes when you deliver an image with dimensions that are just too large. Well yes, some high dpi displays do need images that have larger dimensions than what's displayed, that's going to be a topic later on in this course. For now, just remember that images only need to be as large as they will be displayed. And what happens to your users on mobile? In devtools, I've set network throttling to 3G, so I want to see what it's like for somebody on a bad connection. Let's refresh and watch. Ooh. Notice how the image on the right took a little bit longer to show up? That's just unnecessary. On a mobile device with limited connectivity, it's a big problem. One of the best known tools for batch processing raster and vector images is ImageMagick. ImageMagick is a free and open source tool that enables you to automate just about anything you might normally do with a GUI based image editor. Such as converting formats or cropping or applying filters. Now for responsive images, this means you can automate the process of creating multiple versions of the same image with different sizes or formats. In this example I'm using the ImageMagick convert command to create a webp goanna. Let's open those in Chrome. Identical. Cool thing is, the webp goanna is about 10% smaller than the jpg. That could make quite a difference on a flaky connection. In this example, I've written a shell script that uses ImageMagick to create small and large versions of my original photographic images, saving in webp and JPEG formats. Note that massive reduction in file sizes. There's my originally goanna. And these are the versions that I created. You can incorporate ImageMagick in your build process via a Grunt task. In this example, I'm using Grunt responsive images to automate production of images, just like I did with the shell script. And then you can see the output. I've got a bunch of images saved at 50% width and 30% width in JPEG format at different quality sizes. There are a couple of really useful apps that combine other tools for image optimization. For example, ImageOptim enables lossless image optimization using a number of open source tools. Pngout, pngcrush, jpegoptim Giftical and so on. Now look at the file sizes of our images before and after. ImageAlpha uses pngquant and other tools for compression. ImageAlpha can reduce 24-bit PNG files by applying lossy compression and converting to PNG-8 plus alpha format. Look at our PNG sizes before and after. But looking at that, it went down from about 330 kilobytes to around about 118. That's like, around half the size. As well as the GUI versions you've just seen, tools like ImageOptim and ImageAlpha can also be run from the command line. And incorporated with your build process. In this example I'm running ImageOptum as a Grunt task. That means you can incorporate automated image optimization in your work flow. To learn more about Grunt, along with Imageoptum and other command line tools, follow the links below the video. The only way to not go crazy trying to handle responsive images is to set up an image pipeline that makes it easy for you to create multiple versions of your images automatically. And to do that you're going to need the right software. For your own sanity, I want you to take a step back and install Grunt, ImageOptim, and ImageMagick. Seriously, Grunt is super useful. I use it all the time to automate tasks for my projects. ImageOptim and ImageMagick are also awesome, because it makes it so easy to convert images to different sizes, formats, and compression levels. You're going to want their help when you start working on the project for this course and in your future projects. You'll find links in the instructor notes for some how-to guides. Once you've got everything installed, check this box to continue. I've got another spot the difference challenge for you with some pictures that I took on my most recent trip to Paris. Both of these images pretty much look the same, but can you spot the difference? Once again, DevTools are definitely going to help you out. You can find a link to that site in the instructor notes. What's the difference between them? Is it their compression level, their display size, their natural size, or their type? Check all that apply. I've opened dev tools, and I'll start my investigation by taking a look at their actual sizes. Looks like the first image is 1000 x 667 pixels, and the second image is also 1000 x 667 pixels. So at least their resolutions are the same. In the network tab, it becomes pretty clear that they have different compression levels, because the first image has a size of about 60 KB. While the second is only around 40 KB. And both images pretty much look the same so that's a lot of wasted bytes. Saving with quality set to high can be even more of a problem on mobile where bandwidth is scarce and the screens are small. Later in the course, you'll learn how to serve different images for displays of different sizes and different resolutions. How can we check if all the images on a site have been optimized? Remember that in order to serve the smallest possible image file on your site, you need to make sure you've run images through optimization tools. Now, one great tool for checking this is PageSpeed Insights. Let's use that to check a page from our website. One image that needs some help. We can also use PageSpeed Insights from the dev tools. Just click Analyze. Best of all, there's a PageSpeed Insights API that lets you incorporate checking within your workflow. Here I'm running a kill command to make an HTTP request from a terminal. Key here holds the value of my API key for PageSpeed Insights. And I'm redirecting the response of that request to psi.jason. Let's open up that file and take a look at the output. Looks like psi found one image that needs to be optimized, same as it did from the website. You could easily incorporate this into build tests when pushing code to a repository, for example using a task runner such as grunt. In fact there's even a grunt plug-in for PageSpeed Insights. For more information about using PageSpeed to check images with grunt take a look at the link below the video. Alrighty! It is time to get started on The Responsive Blog Project. You can find a link to a zip file with the project in it in the downloadable section. Note that the zip file is pretty large because of all the images inside it. So this is what the blog looks like right now. And you should be asking yourself, ugh, what the heck is this ugly thing? The good news is that, by the end of the course, you'll be turning it into something that looks a little bit like this, which is definitely a lot nicer. Now, responsive images can be as much of an art as it is a science. The way you make your images responsive will totally depend on how you want to use them in your sites. When all is said and done, your blog may look very different than this, but that doesn't make it any less correct. It's up to you to decide how you want to beautify this blog and make its images responsive. To start working on this project, which is really zoomed out here by the way, I'm going to give you a few changes. Some will be mandatory and some will be optional. Your goal is to make these images look sane. Right now, they're massive, both in their visual size on the page, and this is zoomed out to 25% here so they're really, really big. And they're also big in a number of bytes that they include, in that they're simply way too large. Back at 100%, it's pretty clear these images aren't fitting inside their containers. The images in the website need some kind of width applied to them so that they stay inside their container, which in this case is an article. Once you've done that, set a maximum width on the article element to give the blog a little bit better structure. I recommend starting with a width of something around 50em's. Remember an em refers to the font size. So a 50em element with font sizes of 16 pixels means that we are talking about a width of 800 pixels. By the way, notice how these images are coming from images source we will come back to that in a second. Next up, check out this Volt. You see how its natural width is almost 3300 pixels? That's just massive. What's the point of so many pixels when it's going to be displayed at about 800 pixels wide? Even on a 2x display, you only need 1600 pixels across. So there are so many wasted bytes here. These images need to be a lot smaller. I want you to use the tools and techniques that you've been learning. To reduce the resolutions and compress the images. See how low you can get the resolution you can use and how much compression you can use while still keeping really crisp images. To do so, you have Grunt, Image Magick and Image Optim on your side. And you definitely don't have use these, but it will make you life a lot easier if you do, especially Grunt. If you've got Grunt up and running, you should be able to use the Grunt file in the project directory after you run the command in the instructor notes. The command will make sure the grunt-responsive -images package is installed. Notice that Grunt is going to run against images in the images_src/ directory. and put them in the images directory. Right now the html all the images can be found in the images source directory. But once you've optimized them, make sure you change their directory to images. There are links to lots of documentation in the instructor notes if you need help. Right now, the page is coming in around 3.1 megabytes, which will take forever to load on mobile. Seriously, try loading this site using the network throttling options set to 3G. You may want to grab a cup of coffee while you wait a few minutes for the page to load. You can probably reasonably drop the total bytes from the images below to 1.5 megabytes or even further. In terms of optional changes, the images are looking pretty lonely right now. They need some captions. So we'll add some. In this solution video, you'll see me add some captions using the semantic figure tag, but you can use whatever technique you'd like. See the instructor notes for more documentation on figure. So, to summarize, first things first, make sure the images fit within their containers. Then once you've done that, make the containers a reasonable width. And I recommend about 50em. Once the images are actually being displayed properly, it's time to resize and compress them. They should stay sharp but the page should drop below 1.5 megabytes total. In fact, I'd be willing to bet you could do even better than 1.5 megabytes. Make sure to use automation tools. Otherwise, your life is going to be much more difficult than it needs to be. But to be fair, it can be difficult installing Grunt, so make sure you use the instructor notes. And as an optional challenge, add some captions. Of course, make sure you're testing on different devices and network settings. And once you've done the first, second, and third parts of this challenge, a code will appear on the screen. Type that code in here to continue. I'll be going over my solution in a second. But, if you want to inspect it for yourself, you can find a link to it in the downloadable section. First things first, I want my images to fit. I set the max width on the image tag to 100%. And look at that. Now the images are actually fitting inside the view port. You can see the whole thing instead of some massive, stretched out monster. Then I set the width on the article tag to 50m. You can immediately see that the content is actually fitting. The blog's starting to look a lot more reasonable but the browser is still downloading images that are way too large. I need some smaller images. I could use a tool like OS10 Preview to resize and compress each image individually, but that really isn't scalable. So, I used this grunt task to create new images that were scaled and compressed. I set a width of 1600 pixels for 2x displays. At a width of 50 m on a 1x display an image is going to be 800 pixels across. But, on a 2x display, it's going to be 1600 pixels so, I went with the large one. I thought 30% still looked good while keeping the bites to a minimum. Additionally I'm appending large_2x to the end of each file for reasons that will make sense later in the course. With all that done all I have to do is change the image sources to images/whatever-600_large_2x and bam. My page just got a lot smaller. Check it out. After the changes, my page is down to 1.3 megabytes, which I'm feeling really good about. And lastly, I used the figure tag, because it includes the awesome figcaption tag. Simply fill in the caption in figcaption, and it shows up on the page. So the blog is looking a lot better overall, but it's still not perfect. At the end of the next lesson, you'll have another chance to improve the blog. Congratulations on getting your hands dirty with responsive images. You're on your way to a workflow, that allows you to easily create websites with high quality images with as few bites as possible. And in the next lesson, you'll actually approach responsive images using techniques that, well, allow you to avoid using images at all. You might be surprised by the number of options available for situations where images no longer seem necessary. You'll explore some image alternatives using simple mark-up techniques. See you then. Yeah. The reality of mobile networking means that the number of file requests can be just as significant as the size of requests. In other words, aim to reduce the number of image requests, not just the size of image files. We call this problem latency, which is the delay between request and response. Yeah. Every time your browser attempts to retrieve an image from a website there are potential delays at every step of the way between your device and the website's servers. And every one of those delays can vary significantly and unpredictably. Behind all that is the fundamental problem that data can't travel any faster than the speed of light. Yeah, I mean surely Google or someone else could do something about that. The speed of light, you know, it's so last century. Cameron, like, you're a physicist, right. Stop, stop, stop, stop. No. All right. Definitely not. At least, not any time this millennium. All right, whatever, whatever. Anyway, optical fiber can only achieve a bit better than half the speed of light. So, at best, London to California, return trip times for example, are around a hundred milliseconds. And performance expert, Ilya Grigorik, calls latency the new bottleneck. Thanks Sam. Indeed, it turns out that for many modern web pages, bandwidth doesn't matter as much as latency does. If you find that surprising, check the instructor notes for an explanation of why that is the case. The bottom line is that performance is a fundamental part of a truly responsive design. In practice, that means you need to reduce the file sizes and reduce the number of file requests. And one great way to reduce the number of image bytes is to compress them or reduce the number of images. Thanks Eliott. In this lesson, we show you lots of ways to achieve graphical effects without image files. In the old days, it was commonplace to save text as a graphic. As you can see here, that doesn't scale well visually and adds to the page weight and latency. Text as graphic can also cause conflicts with format choice. Now in theory you might want to save text in a PNG format because text has solid color and hard edges. But in this example we've saved as a JPEG because we're using text over a photo. Scale that up, and you start to see artifacts. Using text as a graphic also means the text can't be found by search engines, and isn't accessible by screen readers and other assistive technologies. You can see what the current page looks like in the text only browser Lynx, that gives a good idea of what screen readers and search engine web crawlers see. All you can see here is the alt text on the image, which says koala and nothing else. And you can't copy text as graphic either. If you do need to incorporate text in graphics, overlay real text over the top. Simple. Both the photo and the text display and scale much better, and you can select the text. And it's really easy to add effects with CSS. I'm using the Lovely Lobster font, which is one of the many free web fonts available. File size is smaller too because we can save the photo as a nice small JPEG for the photo, rather than having to use PNG to cope with text. On the subject of text and images, one way to ensure your site is really responsive is not to have any images at all. Maybe some of the pages on your website don't need images. These sites use beautiful topography CSS effects and great layout to achieve really striking graphical effects, with responsive layouts and stonkingly fast load times. Likewise, these sites, which use images really sparingly. When you're designing a responsive site, every time you add a placeholder for an image, think about whether you really need it. Sometimes the best image is no image at all. In the past, typography on the web was extremely limited by the number and quality of fonts available. With web fonts and modern CSS implementations, that's all changed. Web fonts and CSS enable beautiful typography on the web without having to resort to using text as graphics. As well as adjusting type attributes. CSS can also be used for other graphical effects, in particular using CSS for shadows is supported by all modern browsers and much better than using image hacks. Likewise for rounded corners, gradient, and animations. Do be aware, however, that there is a processing and rendering cost to using CSS shadows, rounded corners, and so on. And this is especially significant on mobile. So, if you really want these effects, use CSS, but use them sparingly. CSS also supports background images and this feature can be used to achieve a number of responsive effects. You can use CSS to add a background pattern to an element or the page itself. And you can combine that with gradients and other CSS effects. It's possible to get some incredible effects with pure CSS. Check out the examples on the website linked to below the video. With the background size cover property, CSS can also be used to add a background image that resizes without squashing or stretching. And again, this can be really handy for using images when you don't know the size of the viewport. The details in a photo can get lost when it's shrunk, so this example displays the whole image if the viewport is more than 500 pixels wide, or a smaller crop otherwise. I've added a CSS transition, so there's not too much of a jolt if you resize the window. You'll see that in the DefTools, the smaller koala crop is displayed, downloaded when the window is small. And then, if you resize the window larger, the larger crop is downloaded and displayed. CSS background images can be used for conditional display of images depending on the viewport size, using CSS like this. As you can see from the dev tools, the background image file is not downloaded if the viewpoint width is less than 500 pixels. Now, you'll find out more about media queries later. And a much less hacky and, and a much more efficient way to accomplish alternative image loading when we look at the source set attribute and the picture element in lesson three. With background images, you can also use the CSS Image Set function to choose a background image depending on screen resolution. This example displays a 2x color image on a high resolution display, like my phone, and a 1x monochrome image, otherwise. For the devices that don't support Image Set, the CSS falls back to the 1x version. If you check the dev tools, you'll see that only the appropriate image is downloaded. You'll learn a lot more about responding to screen resolution in lesson three. These two cute koalas are a background image inside a div. And right now, the background size it set to cover. I want you to compare the difference between background size cover and background size contain. It might help if you resize the page a bit, to figure out the difference between the two. Once you think you know the difference between cover and contain, I have two statements for you. The first one says that the image is sized so that it is as small as possible while still completely filling its container. Is that describing contain or cover? Pick one of the two. And the second statement says, the image is sized so that it is as large as possible while still being completely visible inside its container. Is this statement describing contain or cover? Pick one of these two. I'll start by comparing the image's x dimension, or its horizontal dimension here, and on the original image. Notice how on the site, the whole horizontal dimension is fitting. However, the y dimension, or the vertical dimension, does not entirely fit on the page. Notice how on the original, the image goes down far enough to see a bit more of the tree trunk. While on the site that part's cut off. So for cover, the image kept just as small as possible, so that its smallest dimension matches its container's smallest dimension. However, its largest dimension actually overflows the container. Compare that to Contain, in this case the y matches its container dimensions but the x is now smaller. Back to the statements, the first one is going to be describing cover. Cover ensures that the container is completely filled, even if that means one of the dimensions is a little bit too large. The second statement describes contain. With contain, the image will be completely visible, but in order to do so, that means that one of its dimensions might be smaller than the containers dimensions. Is another way to avoid image files and to keep your site responsive. If you need to use a graphical symbol like an arrow, a star or a heart, check whether it's available as a character in a font you might be surprised what's available. When symbols and icons are achieved using fonts, they have all the response of advantages of text. They're infinitely scalable, amenable to texts, CSS effects, and don't incur extra download. The graphics on this page are built without image files. The body has a CSS gradient and the star is just a text character with a CSS shadow applied. All responsibly sized. The Unicode standard defines the universal character set. Over 100,000 characters have been defined so far. Some fonts support many thousands of these. Get to know your glyphs. Unicode characters are just plain awesome. As you just learned, there are more than 110,000 characters. That is insane. In a moment, I want you to explore some of them, because, well they can certainly come in handy. Why would you ever force the browser to download an image when there's already a Unicode character that you can get for free? To explore them yourself, I recommend checking out this drop-down menu which gives you the chance to look through all of the different categories. You can find things like emoticons. Holy cow, look at all those cute little emoticons that you get for free, which you can use on any website. It's worth pointing out that in order to use Unicode characters, you need to make sure that you set your character set to utf-8 inside your meta tag. See the instructor notes for more details on this. For this quiz, I want you to pretend that you are making a music website. Check out the link to the Unicode character set that you can find in the instructor notes. Look through it and see if you can find the symbol for the treble clef. Once you've found it, try it out for yourself and see if it works. Once you're done, paste the HTML code here to continue To find the treble clef, I started by going to the musical symbols section because well, that just makes sense. Looking through all the characters, it looks like there is a treble clef right there. And, wallah. There is its HTML-code, right here for easy copy and pasting. I'm testing out the treble clef by pasting its HTML code here. And then observing what happens on the site over here, and notice there's the treble clef. So, clearly this HTML code is working. By the way, this is just the same koala website you saw a few minutes ago. This looks good. But, I wonder what would happen if I just simply pasted the treble clef itself into the html, remember it's just a normal character. So I will copy it and I will paste it right here. Now look, I've got the treble cleft over here in the the HTML. And I've got the treble cleft in the site. This is nice because these two match. In fact, it's actually recommended to copy and paste the actual Unicode character into your HTML. It's easier to read and maintain. So, the correct answer is, ampersand pound sign and then the number that you see here. That's the HTML code for treble clef. Do you remember Wingdings? [LAUGH]. That weird font that was oddly popular in the 90's? Have you ever wondered why a font like that would even exist? Well, as it turns out, it's possible to build a font family made of images and icons rather than letters. Now, icon fonts provide a fantastic option for the little images and icons that often decorate websites. There's an icon font I like called Zocial. Now, this font is free and open source, so I could download it and serve it from my site. However, the font is publicly available from the font site itself so, I'll use that instead. Let's see it in action. Notice that I've added some shadow to the font icons. This file looks a bit complex so, bear with me. Here's what's going on. The icon font characters are added using the CSS before selector. I've added some formatting to that as well including CSS text shadow. Now that rule is applied to every element whose class name begins with zocial. And you can see that each of the list items has a class with a name made up of zocial and a brand name. Now, at the top, you'll see an @import url, that points to an external CSS file. Let's look at that now, the @font-face url, at the top of this gives the source of the actual font files and there's some variations available there. And what you see below that are selectors based on class names like the ones we've used, zocial-flickr, zocial-laughter and so on. For example, set the class zocial-flickr on an element and the character F will be displayed before it. Which in the zocial font is the flickr logo. Clever, huh? Icon fonts have a number of advantages, over plain old images. They're vector graphics that can be infinitely scaled and an entire set of images can be downloaded in one font. And this makes them a great potential solution for responsive designs where you require minimum downloads and maximum scalability. Now, if you look at the resources required for the weloveiconfonts site, you can see that the total wait for that hundred of images from all the fonts on the page is less than 300k. Icon fonts have a number of advantages over plain old images. They're vectorgraphics that can be infinitely scaled. An entire set of images can be downloaded in one font. This makes them a great potential solution for responsive designs where you require minimum downloads and maximum scalability. The example here shows lots of different options for icon fonts. And of course the characters in icon fonts behave just like letters in other fonts. So you can resize and color them and use other CSS effects, just like you would with text. There are lots of tools for creating icon fonts and lots of pre-built icon fonts. Check out the links below the video. There's also a link to information about improving accessibility by using Aria attributes Talking about text, if you really want to reduce the number of file requests your page makes, you can inline images using code. Two ways to do that, SVG and DataURIs. Now here's a vector graphic you may have seen before. Both versions look identical, and here they are in emulation mode. And here on a real phone. Looking at the page source, you'll see that the logos are declared inline. There's an SVG and an image element with a data URI source. Inline SVG has great support on mobile and desktop browsers, and optimization tools can significantly reduce SVG size. Spot the difference, these two inline SVG logos look identical, but one is around 3 kilobytes and the other only about 2k. SVG is incredibly powerful. Check out this interactive version of Trajan's Column, works on mobile too. And the best thing, all that responsive interactivity for less that 160 kilobytes. For more amazing SVG examples, check out the link below the video. Data URIs provide a way to include a file such as an image inline as a base64 encoded string using the following format. The full version is around 5,000 characters. Just like SVG, Data URIs are well supported on mobile and desktop browsers. That's around well, nearly 97% of browsers. So you can inline images in your HTML, but Data URIs and SVGs can also be inlined in CSS. Works on desktop and on mobile. Here we have two identical looking images implemented as background images in CSS, one data URI and one SVG. Now the code looks a bit crazy so why would you want to do this? Well, to reduce HTTP requests. At this point in the course you've learned about a few different techniques for handling images on the web. For instance, you can use external files and just link to them in your html or you can inline images and put all the data you need for an image right there on your page. You can use Raster images like this picture of the star called Electra. Or you can use Vector images like this star from the Material Design icon set. And then of course you can issue images altogether and use font icons like font awesome and then use CSS techniques for styling them. Funny thing is that any and all of these techniques can lead to pretty much the same result on the page. The so called, right strategy. Notice the air quotes there, for including an image, almost completely depends on the images place in your app, as a whole. For the next few quizzes, I want you to think through some of the scenarios, and decide the best course of action. Here's the first scenario. You're developing a mobile app that displays an ever changing catalog of bikes for sale. You need an image for this start right here, to indicate which bikes have just gone on sale within the last 24 hours. You want to scale the star image with the rest of the app, in order to fit mobile phones and tablets proportionally. So should you use a vector graphic or a raster graphic and should you inline the icon or should you set its source to external file. Think it through and pick the best answer for both the questions. So, should you use a vector graphic or a raster graphic? Well in this case, the star is pretty simple and pretty regular shape. So I think it's safe to say a vector graphic is the way to go, especially if you want to scale it with your app. And then should you inline it or set its source to an external file? For this question, I'm actually accepting both answers, because you could argue either way. For inline, it's safe to say a star is a pretty simple shape. You could pretty easily create it with an SVG file and just simply inline that without adding too many bytes. If you're reusing an image, it does make sense to make it external, which means you'll be able to cache it and then not reload it every time a user visits a new page. So in this case, it really depends, and if this were a real app, you'd just test it to find out which method is faster. In this scenario, you're developing a self-publishing, mobile photojournalism site which will have single use photos. This site is designed for big events, and people will be creating unique sites where they'll post a single image alongside some description of it. Should you convert them to vector graphics or just keep the photos as .jpgs? And should you inline the images or should you set their srcs to external files? Pick the best answer for these two questions. First off, keep their graphics as jpegs. These are raster images they're taking, so keep them saved in a raster format. For the second question, considering your users are accessing your site on mobile. It's actually a good idea to inline these images if you can. Inlining reduces the number of requests the browser has to make. And requests are one of the major contributors to laggy or unperformant websites on mobile. Requests add round trips. And round trips are one of the biggest factors for slow websites on mobile. But, with that being said in the next lesson, you'll see how inlining images can limit your responsive options. So, in the end an external file still might be the way to go. Either answer is correct. In this scenario you're creating a corporate website for a data analytic startup called sample analytics, and the corporation wants its logo in the top left hand corner of every page. There's also a good chance that they'll want a larger version of their logo to show off on an SEM landing page. It's fair to say that users will be coming from either mobile or desktop. So should you use a vector graphic or a raster graphic for the logo, and should you inline the logo or set its src to an external file? Think about these questions and then answer them. For the first question, I said that you should use a vector graphic. And there are two reasons. One is that this logo's pretty simple. As it relies on text, it shouldn't be too hard to make as a vector graphic. And two, because you want to it in small and large formats. Vector graphics scale nicely, so small and large versions of the logo can use the same source file. And then for the second question I said that it should be an external file. The reason I said it's external is because if could be use on multiple pages, and if it's going to be used on multiple pages, it probably makes sense through the browser to cache it. In this last scenario, you're creating a mobile web app called vicarious concerts for people who like to compare concert videos shot by random people in the audience. Each video takes a few seconds to load, so you decide to show a spinning record icon, like this one. In place of each video while it's loading. Should you use an animated .gif or an animated SVG for this record icon? And should you inline the spinner, or should you set its srcs to an external file? Answer both questions to continue. For the first question, I said that you should us an svg. First off, vector graphics are nicer because they can be scaled infinitely unlike gifs, which are rasters. And also, .svgs are actually smaller than .gifs because you're using the same image, and just animating its rotation. Instead of delivering multiple images for the record at each point throughout its rotation. And for the second question, it makes sense to keep it external, with multiple videos all using this same spinning record icon, it makes sense that the browser should be able to cache it and then use it on multiple pages. All right, that's it for the four scenarios, it's time to jump back into the project. It's time to apply what you've learned about markup techniques to the blog. You can use the same blog you were working on in lesson one, or if you want, you can find a fresh copy in the downloadable section. At this point in the project, your images are looking pretty good, but there are a few opportunities to use some markup techniques. First of, check out this random smiley face. It's a PNG. Just go ahead and replace it with Unicode. There's really no reason for this to be a PNG. And of course, what's a blog without social media links? Use Zocial to add some social media links to the bottom of the page. I'll be adding them to a footer tag, but feel free to add them however you'd like. Also notice this weird flourish here? It separates the main content from the footer below it. It's a PNG, which is obviously pretty unnecessary, so replace it with something that does make sense. In the solution, you'll see me just totally remove it and replace it with some more subtle CSS. Here's an option for you. Add a responsive logo. Check the instructor notes if you want some inspiration. Once you have replaced this smiley face with a unicode smiley face, and once you've replaced the flourish with something else using markup, and once you've added some social media icons, a code will appear on the page. Type that code in here to continue. I started with the smiley face. I added the meta tag with a character set of utf-8 to the head of the page. This is so that Unicode characters get recognized. Then all I had to do was go to the Unicode site and copy and paste this smiley face here. To add the social media icons, I added a link to Zocial in the head using the weloveiconfonts website. At the bottom of the page, I added a footer tag with a div inside with an id of social. Inside, there are four a tags, each of which has a different class. Notice how all the classes start with zocial, and then a dash, and then the Zocial icon that I wanted. So I've got Twitter, Facebook, Google+, and Digg. I thought the logos looked just a little bland on their own, so I wound up using some CSS to give them some shadows. And in the end, I thought the flourish was just a little silly. So I added a slight border using border-bottom to the end of the article. I think this is a little bit classier and it avoids some extra bytes for the flourish. You could have also used some kind of svg here, but I decided to go with a little bit more subtle approach. Oh, and here's my svg logo. It's pretty simple, so I just simply inlined it here inside the header. All right. This blog is looking much more reasonable. We've dropped some unnecessary bytes in, added some social media icons. At the end of the next lesson, you'll have one more opportunity to really make this blog's images shine. In this lesson, you learned that images aren't always necessary. Which is actually kind of a funny thing to learn for a class called responsive images. Right. I mean, mark up alternatives like CSS and icon fonts provide performant options for design techniques normally implemented with images. And so far, you've simply exlpored ways to deliver images more effectively. But in the next lesson, you'll explore a concept called art direction, which pushes developers to match image content to different devices as well. Yeah, see you then. You know by now that serving one single file for every context is not a good idea. Yeah, I mean, the image file you would want to serve for a large display size on a big high definition TV is totally inappropriate for a watch, for example. So how do you serve the right image for every combination of device capability and display size? In the last lesson, you learned some techniques that use CSS background images in media queries to display different images for different viewport sizes. That kind of works, but it was pretty messy and difficult to debug. To do it properly, you potentially needed to write CSS to handle umpteen different use cases. And what about the future? What if all your fancy media queries don't support some future platform? Yeah, I mean, using media queries like this is an attempt to guess at build time what image file will be best at run time. You're forcing image choice on the browser rather than giving the browser information to make the best choice possible. The other problem with media queries is that they only refer to the viewport dimensions, not the actual display size of the image. What if you give your image a percentage width, say I don't know, 50% of the viewport width. Media queries won't help. You may have images that work fine on a low-resolution desktop monitor but look terrible on a high DPI display. Not a problem, we'll just save an image with larger dimensions. That wallaby's a lot happier now. Trouble is, we're now serving a bigger image file to everyone, whether they need it or not. And that's going to result in a terrible experience on a slow network, especially you know, on a smaller screen with lower resolution. The problem with the plain old image source attribute is that it only gives one URL for one image. What if you want to provide alternative files for the same image? So the browser can choose the best option for the view port size and device capabilities. Source set to the rescue. Here we added a source set attribute to our image element. The syntax here simply means that the browser should choose the high resolution of wallaby_2x.jpg for a higher DPI display, or the lower resolution of wallaby_1x.jpg otherwise. The 1x, 2x syntax is called a Pixel Density Descriptor. And if we check from the dev tools using emulation mode for a 1x device, you'll see that only the 1x image has been loaded. Nice wallaby. By the way, I've added a 1x descriptor after the 1x image source, but that's the default. Different screens have different pixel densities, more or less dots of color per square inch, the, the physical pixels. And the more dots per inch, the higher resolution the display and the greater the pixel density. But Standard laptop and desktop monitors are regarded as being 1x displays, whereas devices such has high spec laptops and phones can be 2x or more. Everyday, there are more and more new screens with different pixel densities. You can check this from the dev tools console, by looking at the device pixel ratio for your display. Here, the device pixel ratio is 1.75 for my monitor. And, now I'm using remote debugging for my phone with the dev tools, and you can see our device picks our ratio there, is three. You can find out more about pixel density, by following the link below the video. What if the browser doesn't support the source set attribute? That's not a problem, the source set attribute is ignored, and the image is loaded in the usual way using the source attribute. Here I'm opening the page in Firefox, where the source set attribute is still behind the flag and you'll see the 1x version is downloaded to default from the source attribute. Turn on the flag, reload and press that. You can see the source set attribute in action. Source set can also be used with width units. For a browser, there's a catch-22 when it comes to choosing which image to download. The browser needs to know the dimensions of each image, but it can't know that without downloading each image to check. Until the mighty W unit. The W unit tells the browser the width of each image. Thereby enabling the browser to choose the right image to retrieve depending on the screen pixel density and the viewport size. Think about it. If you have a browser window sized at say 500 pixels wide on a 2x display and image 1000 pixels wide, that's 2 times 500 would be adequate for any display size in that window. The point is that we're enabling the browser to make the right choice of image since at runtime, the browser knows the screen size and pixel density, but not the image size. Later, you'll see how to work with image display sizes that are less then the full width of the viewport. Now, you might be wondering, why width and not height? Well, width covers most use cases. But there has been some discussion of introducing an H unit. And for the responsive obsessives among you, follow the link below the video. The w unit tells the browser the dimensions of an image file so it can make a sensible choice about which image to retrieve. But what if the image isn't displayed at 100% width of the viewport? Well the browser parses the HTML and starts image pre loading before the CSS is parsed. And at that point, it knows nothing about image display sizes. Here's where the sizes attribute comes into play. The sizes attribute tells the browser the sizes at which an imageswill be displayed. So while parsing the HTML, the browser can work out which image file to request. In theory, the browser cou'd get this data from CSS, but CSS parsing comes later. Adding the sizes values to HTML ensures the browser can fetch images as soon as possible, the right image for the right image display size and device capabilities. And just to be clear, the sizes attribute does not actually resize your image, you still need to do that in CSS. Okay. Remember our source set example for w units. Well let's resize our wallaby. Now she's 50% of viewport width. Let's take a look at the network request for that. You'll see that even at the smaller window size, the browser is still getting the medium image, which is larger than you need. So let's work it out. The window is 400 pixels wide, so the image will be displayed at half that width, 200 pixels wide. We're on a 2x display. so we need an image at least 400 pixels wide to look okay. Now our small image, which is 500 pixels wide, should be fine, got that? Okay, so at the time the browser fetches the image, it doesn't know anything about the display size of the image. So it defaults to assuming the image will be the full width of the viewport. So, let's add a sizes attribute, reload, and see what happens. The small image is downloaded. The sizes attribute here is telling the browser, this wallaby will always be displayed at 50% viewport width, and, given the files available, please choose appropriately. What if you want different image display sizes at different viewport sizes? Well, the sizes attribute really comes into its own with media queries. That wallaby was getting a bit too big, so let's put a limit on the width. Now, in this example, we've set our wallaby to display at 100% viewport width, at viewport widths of 250 pixels and less. And 50% viewport width above that. Notice how the sizes attribute corresponds to the CSS. Just to reiterate, the sizes attribute tells the browser at HTML parse time, what the image display width will be. It doesn't actually affect the display size of the image. And by the way, I've added a CSS transition, so the size change isn't too jarring. Just because I felt like it. You can get the actual source chosen for an image using the image's currentSrc property. Make the window bigger and ta-da, you can see that the image has a different source. So let's dive in. Here are our kittens again. By the way, that's Lyes, the boy kitten on the right. We don't have a name for the girl yet. Anyway here's what a picture element looks like. You'll notice that this picture element contains two source elements. You might have seen those used for video or audio elements. Source elements do what you'd expect. They provide optional file sources. If the browser can use the first source it will. Otherwise, it keeps looking down the list. The picture element is a great way to provide alternative sources for image files. So the browser can choose depending on device capabilities. We've used the source element here to specify webp for for browsers that support the webp with a JPEG fallback. This is a great way to make use of the high performance webp format on platforms that support it, while providing an alternative for platforms that don't. You can find out more about webp from the article linked to below the video. By the way, that webp file is massive, looks like I should have saved it with lossy compression. Talking about fall backs again, what about browsers that don't support the picture element? Well, that's easy. We just include a plain old image element. In fact, the image element is non optional, because that's the element that actually displays the image. The picture element scaffolding, so to speak. Simply tells the image what source to choose. In fact, we can rewrite the example like this. Because the browser defaults to the image element if it can't use any of the sources, earlier on you learned about art direction. One of the core problems you have when serving images to a variety of screen sizes and display sizes is that although some images scale quite nicely from large to small, other images don't work so well. They may have too much detail to work well on a small screen or be too wide to work on a view port with a portrait orientation. In the responsive world, choosing images to suit the viewing context, art direction can be accomplished pretty easily with the picture element to enable display of a crop of an image or even a different image depending on image display size. Now in this example, we're using media queries to specify the source. Full sized kitten for a large view port, and medium kitten for a medium view port, and a small kitten for a small view port. Cute. This is doing art direction. Choosing a different image with just a few lines of HTML. Okay, hold onto your hat, here's the full monty. We've combined media queries and source set to specify images for smaller and larger view ports with different images for different pixel densities. Here we get the same effect in Safari, which doesn't yet support the picture element. Well how did we do that? Well, it's the same markup but this time we've made use of the picture fill polyfill. That's a small JavaScript file that enables you to use source set and the other new responsive image elements and attributes on browsers that don't yet support them. You can find out more about picture fill from the link below the video. The web is visual. Well, obviously, otherwise this course wouldn't exist. But not all people surfing the web have the ability to see images like this one. For the visually impaired, screen readers are essential to make sense of the web. This is Lynx. It's an all text browser and this is what Reddit looks like on Lynx. Without images, this is all a user has to decipher your website and they usually won't even be reading it. They'll be hearing it through a screen reader like ChromeVox. The good news is that you can still make images meaningful by using alt attributes responsibly. Here, let me show you what I mean. I've enabled ChromeVox, which is a screen reader that will be reading this page to you. Here, let's see what it has to say. The internet thanks you for being responsible with your alt tags. To replicate the experience of being visually impaired, I'm giving you some information using images that don't make any sense on their own, or at all, really. Don't leave your visually impaired visitors out in the cold. Here are some tips about alt tags. Alt tags should be descriptive for important images, like this body surfer because body surfing is important, I guess. Alt tags should be empty for images that are just decorations, like this boiler image. Do you get the joke? It's a boiler to represent boilerplate code, which is sometimes empty of content. Alt tags should be set on every image just like this pig is set on being so darn cute. So there you have it. Check the instructor notes if you want to see the tips that ChromeVox just read to you. Oh, and by the way, to get ChromeVox, it's just a Chrome extension, so it's really easy to install. For this quiz, I want you to experience the web without images. Install Lynx and ChromeVox. You can find some links in the instructor notes. Once you do, visit an image heavy website. Ask yourself, what is it like experiencing the web without images, and try listening to a site with ChromeVox. If all you had was ChromeVox, could you figure out what the images were trying to tell you? Making your website accessible to everybody is incredibly important, because not only does it make you a good person, it means that more people can experience your website. So, when you check this check box down here, it means that you are promising to use all attributes responsibly. Thank you for being responsible with alt attributes! [SOUND] All ready, it is time for the third and final opportunity to make this blog look awesome. Feel free to use the blog that you've been working on. Or if you want a fresh start, you can download a clean version in the downloadable section. And just like before, I'm going to give you some mandatory changes and some optional changes for the blog. As you set up in the first iteration of the blog, the images right now are basically just big enough so they look good on large high DPI displays. The good news is that you're guaranteed to deliver high quality images to everyone. But the bad news is that these images are probably too big for most devices. There's also the added issue of artwork. In that, when the view port is small, users are seeing a wide image, and they may miss some of the most important elements. Like for instance here on a phone with a wide image of the horses, they just look like dots. You can't really make out any detail. Enter the picture element. For this part of the project, I want you to use the picture element to deliver different images based on view port widths. And for some images, like the horses, I want you to display a different crop of the image based on browser width. So if the window gets small, crop it in so we can actually see the horses. It usually makes sense to show tighter and tighter crops of an image as the browser gets smaller. And remember, you can use the source set attribute to change which image is displayed based on device pixel ratio. Take advantage of this. In this solution, you'll see me set breakpoints at 500 and 750 pixels for my picture elements. I'll also set up images for 1x and 2x displays when the browser is larger than 750 pixels. And just like the first time you worked on the project, I'm giving you a boilerplate gruntfile to help you get started. And once you're delivering fully responsive images with picture element, make sure to add some descriptive alt tags if the images need them. As an optional challenge, you can make this blog look a little bit nicer. In the solution, you'll see me use the section tag to separate pieces of content. I'll add a new font from Google Fonts as well, and there might be a few other aesthetic changes to the text. So once you've used the picture tag with srcset to deliver images based on different browser widths and display densities, and you've added alt attributes to all of your images, a code will appear on the screen. Type that code in here to continue. But hey, don't forget, this is your baby and this is an art. So try a new font and maybe style the text just a little bit better. Okay. It's time to finish the project. If you want to follow along with my solution, you can download a copy of my source code in the downloadable section. I started by creating new crops of the images. Some of the images were fine, but for most of them, I went with different crops for different browser widths. For instance, with the horses on medium sized displays, I zoomed in just a little bit. And then on small displays, I zoomed in quite a bit. Now, you can actually see the horses. Back in the HTML, your picture element has two types of children, source and image. Source is optional but image is not. The image here acts like a fallback, meaning, that if none of the sources get hit, the images will be displayed. Also for browsers that don't support picture, the image will be displayed by default. For each image, I set two sources alongside the image, the first source has a media query of min width 750 pixels, and the second has a media query of 500 pixels. For each image, I set two sources alongside the image tag. The first source has a media query of min-width 750 pixels, and the second has a media query of min-width 500 pixels. This means that for any browser with a view port greater than 750 pixels, the images in this source stack will be shown. If the browser has a view port width greater than 500 pixels, but not greater than 750. This source tag will be shown. And then, for any others, the last image tag will be shown. Which means that, basically, any browser smaller than 500 pixels will be seeing this image. For the first source, I decided to take advantage of the source set attribute. Source set allows you to change which image is displayed, based on a device pixel ratio. So for a 2x display, I am showing a 2x image which is at 1600 pixels wide. But for 1x displays I am just showing a 1x image. And 1x is default, it doesn't need to come at the end with the picture element set up like so the browser is being told to decide which image to download based on its width and its device pixel ratio. This is really awesome because you know that the browser is only going to download the image that meets its needs perfectly. Talk about responsible. And hey, all of this still works within the figure tag that I was using before, so here's a figure caption because, why not. And, of course, I made sure to set all of my alt attributes. The only image that didn't get an alt attribute is the SVG logo at the top because it doesn't really mean anything here. So, how does all this look? I'll go ahead and test. First things first, I'll test whether or not these images are changing based on browser width. So here's the large image of the horses. At less than 750 pixels, I see a much tighter crop of them, which looks good. And then, once the browser drops below 500 pixels, there's the tightest crop of the horses. So it looks like the picture element is working. To test whether or not SourceSet is working, I've gone ahead and refreshed the page while emulating an iPad. With a width of 1,024 pixels and a device pixel ratio of 1, you would expect that only 1 x images are being downloaded. In fact, that's what you see. Check out how in the network tab, only 1 x images are being downloaded. As a test, I'll change the device pixel ratio to 2 and hit Refresh and check it out. 2x images are being downloaded. That's a pretty clear sign that the picture element is working awesome. And then, for the fun of it, I can even emulate what the experience would be like on mobile. I set the network throttling to 3G, and hit Refresh. And it looks like the page loads in just under four seconds, which all things considered isn't too bad. And then, and so, wallah. There's the blog. I made a few other changes like making the top image a full image. And you can check out those changes if you check out the source code in the downloadable section. You did awesome. Is that your American accent? Oh, I don't know. All right, anyway, in this course, you learned that your options for images go well beyond a simple image tag. In fact, you can use the browser's properties to not only change the source of the image to ease, you know, bandwidth requirements, but you can also change the content of the image using the picture element. And you learn that images aren't always necessary. There are markup alternatives like icon fonts and CSS styles that give you low bandwidth options for images. But most importantly, you learned that images are an integral part of your development workflow for modern sites. Images constitute an enormous percentage of page load, and screen sizes and form factors vary so widely. Responsive design requires preparing your images for any device. Now, you can develop images for all of these devices. Beauty. [LAUGH] Heck, yeah. What? What? I don't know. [LAUGH] See yeah. Bye.