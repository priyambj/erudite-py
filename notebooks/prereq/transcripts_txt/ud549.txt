Hi, I'm Mike Wales, the web curriculum manager here at Udacity. In a past life, I built web applications for three-letter intelligence agencies you've probably heard of. There was no room for error with these applications. They had to function as intended all the time, every time. More importantly, we needed a way to add new features to these applications, while making sure we didn't break anything. You're probably already doing this in your own web apps. You refresh the browser, click around and just watch to make sure everything is working correctly. Although this works, it's a pretty slow and inaccurate process. What if I told you there was a way you could programmatically check your application's functionality? In this course I'll show you how to do just that. You'll learn how to write your very own unit tests which are suites of functions that check if parts of your application are functioning as you expect. In fact, I'll even show you a whole new way to go about application development called test-driven development where you write tests for your features before you even write the feature itself. So what is a test anyway? The word test may bring back memories of school. I remember staying up much too late the night before a final exam, trying to cram in as much information as I could. These were stressful high pressure situations because I wanted to perform well. There was a lot riding on the results. Namely passing the class. In these situations, I sometimes felt as if the teacher was testing me. But here's a different way to think about it. What if the teacher was actually testing themselves. I'll come back to this example in a moment, but first, let's discuss another kind of test. A test that cannot be passed because the test only gives results when the subject fails. Did you know each Boeing 747 has more than 170 miles of wiring? These are extremely complex machines with a variety of redundant systems. Navigation, pressurization, air quality, and so much more. All of these systems go through a number of tests. But did you know, that there are some test that no airplane has ever passed? When airplane manufacturers design a plane, they design the structure of the wings to flex. The manufacturer expects that a particular design will flex enough to withstand any turbulence the plane may experience. But when they test this design, do you think they only flex the wings enough to pass the test? Nope, they continue to put pressure on the wings, flexing them until the wing break right off. It's a test that cannot be passed, failure is the only option. The important part is they defined an expectation and they validated it. That's all a test is, validating an expectation about something. During this course, I want you to think about testing in this way. Failing a test is not bad, test failure tells you something, and will help you build bug free apps with confidence. So how does airplane testing relate to your final exams? Remember how I said your teacher wasn't testing you, but they were actually testing themselves. And we know a test is nothing more than validating an expectation. Think about this for a moment and tell me what expectation you think the teacher was actually testing. That students were studying for the test. That the teacher taught the material sufficiently. Or that students attended class each day. Although studying for an exam is probably a good idea. The teacher can't really test against this without visiting each student's house that night before and spying on them. This test also doesn't give the teacher any data about student attendance. The correct answer is the teacher was testing whether they had taught the material sufficiently So now that you know a test is based around expectations, you'll need to start identifying areas in our code in which you're setting expectations. By doing this, you'll know exactly what kind of test you need to run. Imagine I have this function in one of my applications. It's pretty simple. It just adds two numbers together. And it would be called like this. The result of 2 plus 3 is 5. Pretty simple. But despite the simplicity of this function, I've already set a whole lot of expectations about how this function will be used. Right off the bat, when calling this function, the first expectation I have is that the add function has been defined and it actually exists. In this example, it's pretty obvious. But what if I had this function defined in another file, like a library? This function wouldn't be so obvious anymore. Secondly, I had the expectation that the function is actually accomplishing our intended task. If this call were to return a different number, like 6, it would be a clear indicator I've messed up the actual implementation of the function somehow. Finally, I'm expecting this function will always be called as I intended, with numbers as the parameter. But what if I were to call this function with strings being passed in instead of numbers? I'd get the result 23, which you'll notice is also a string, since the plus operator can catonate strings together. It's important to identify each of these expectations as early as possible so you can write tests against them, from whether the function even exists to the output that is expected. This certainly isn't a comprehensive list of every expectation, but as you continue to identify other expectations, or opportunities for a test. You can always go back and update your test suite. I've identified a number of expectations with this function, but it's now time to clearly define them, actually see them written out. Select all of the expectations you believe would apply to my add function. You would expect 2 plus 3 to equal 5. You would expect an error if non-numbers were used. And you would expect 0.1 plus 0.2 to equal 0.3. I'd expect all three of these conditions to be true. Unfortunately, one of them is not with our current implementation. This third option 0.1 plus 0.2 equals 0.3 would actually equal 0.300 more zeros, 4. The reason behind this weird math isn't that important to this discussion, but it relates to how computers perform floating point math. If you'd like to understand this problem a bit more, check out the link in the instructor notes. What is important is that we've defined test and we've noticed one of these tests isn't currently failing. Something as easy as adding two numbers together. And we've already encountered an error. That's the value of testing. We now have definitive proof our function is not working correctly, and we can start fixing that error. I'm now going to start refactoring this function based on the expectations we've identified. I've placed all the expectations in the top right corner here and notice how I've placed a green check mark next to the one we are passing and red Xs next to the ones we currently are not. I can now safely refactor this function because I have these tests here to tell me if I inadvertently break something. This process is called the Red Green Refactor cycle. I'll add a check to make sure the parameters being passed to the function are both of the type, number. If they aren't, I'll throw a new error. This changes the results of our test. This function now passes the first and second test, and I just need to pass the third test. Now I'll be the first to admit, this solution s pretty naive. It only applies to a very small set of use cases. But that's okay. Writing a perfect add function is not the point of this exercise. I just want to be confident I can safely refactor my function, without breaking anything, and that's exactly what we've done here. If I check my test again, I'll see that they're all green. So assuming my tests are comprehensive, I can be confident that this function behaves the same way as it did before, but without the errors we initially discovered. We essentially ran through the red green refractor process in our heads. I had some tests that were red. I turned those tests green by fixing my code and I'm confident I could continue refactoring my function without breaking anything. But having these tests in our head doesn't do us a lot of good. Let's get these down into code. I went ahead and wrote the first two tests. Now I would like you to try and figure out the final one. Don't focus much on these functions, or what they do. Just try and take your best educated guess, at how you would write, the final test. Expect add 0.1, 0.2 to equal 0.3. Use my examples as references to get yourself started. We pass the code we want to test into the expect function. And we chain a rule set function, which is called a matcher, onto the end. We pass what we know to be the correct value to our matcher. We know that 0.3 is the result we want when we call our add function with 0.1 and 0.2 as its parameters. Congratulations. You just wrote your very first test suite. Sure, it was a pretty simple one but you've seen firsthand the importance of testing. We identified a number of problems with the first version of our ad function and we refactored our code to fix those issues. More importantly, now that we have tests, we can be confident we don't break anything during our refactoring because our tests will always be there to tell us when everything is okay. And more importantly, when things break. In the next lesson, I'll introduce you to a testing framework called Jasmine and we'll start writing some more real world tests. In the previous lesson you wrote your very first unit test. Congratulations. If you recall, your test looked something like this. You were calling an expect function and then chaining a matcher like to be on to the end. In this lesson, you'll be writing tests against a variety of synchronous and asynchronous functionality. You'll predict and write the code required to pass these tests and confirm the suite of tests pass. Unfortunately JavaScript doesn't have these testing functions defined by default, so we'll need to use a library that will provide this functionality for us. There are a few different testing libraries available. But in this course we'll be using one called Jasmine. It's a popular and easy to use library in use at companies like Pivotal Labs and Helpful. For this course, you'll want to use the 2.2 branch of Jasmine. I've included all of the sample code and Jasmine 2.2 and a get help repository for you. You'll find the link in the instructor notes below. Go ahead and clone that repository and let's get started. We can make sure everything is running correctly by loading the SpecRunner, HTML file in our browser. If we review this page, called the SpecRunner, we can see some stuff is already happening by default. It says the Player should be able to play a Song, or, when song has been paused. These lines are also styled differently. These are black and these are green and indented a little more. Since this is just an HTML page, let's load this file into our text editor, and try to figure out exactly what SpecRunner is doing? So we see this is just a normal HTML file. We're including some jasmine library files here. And there's a section called include source files here. And another that says include spec files here. The source files are all of your application's files. And the spec files are our tests. Let's look at PlayerSpec.js. Here we go. Some of these lines should look pretty familiar to you. Look at this line, expect(player.currentlyPlayingSong).toE- qual(song);. This looks very similar to the test you wrote in the previous lesson, but these lines are wrapped up in parent functions. We see this it function here, it should be able to play a Song. And if we go higher, we even see another, describe Player. Hey, these terms look familiar. We saw these on the SpecRunner page as well. If we compare the code within player spec.js specifically the describe and the it functions, with the content in the spec runner page we'll start to see a pattern. Which of these statements are true about the relationship between the code and the page? That describe calls are colored black. That there's no difference between describe and it calls, or that it calls are colored green. The correct answer is all describe calls are colored black and it calls are colored green. As we saw in the spec runner page, the use of describe and it, are to create sort of an outline, as if they are just used to organize information. In fact, that's exactly what they are for. It, is used to identify a specification, or a spec, for short. A spec is just a container for a test. A way to identify the exact feature we're testing. For example, it should be able to play a song. If all of the expectations within a spec return true, then that spec passes. If any of these expectations were to return false, the spec would fail. You could think of it as defining the boundary around this test. Describe is used to identify a suite, which is a group of related specs. In this case, the suite is called "Player", which tells us that everything contained within this block is related to the player. There's no right or wrong way to organize your tests. It's up to you and your preference. Describe is just there to provide an organizational tool, a level of indentation. Now that we know how to organize our tests, let's start writing our own. You already wrote your first test in a previous lesson, but we'll now break that test down and explain each part. Each test starts with a call to expect. You can think of this as the launching point of any test. It's what starts the process. The expect function accepts a single value called the actual that we want to test. In this example, the actual is add 0.1, 0.2. We then need to tell the testing framework what kind of comparison we want to use against the actual. The comparison method is called the matcher and is a method chained after the call to expect. Jasmine includes a lot of matcher functions and you can even add your own. In this example our matcher is toBe which is the equivalent of a strict equals comparison. Finally, we pass the expected value to our matcher, in this case the value 0.3 which is what we would expect the add 0.1, 0.2 to return. All in all, you can think of this test to look something like this once it has been evaluated by the framework. Add 0.1, 0.2 equal, equals, equals 0.3. If that expression returns true, this test passes. Otherwise, it fails. You can also negate a test by chaining the word not, before the matcher. For example, this test would evaluate to true, since add 0.1, 0.2 does not equal 0.1. Consider this spec and determine whether it would pass or fail. Remember, a spec can contain multiple tests, but each test must return true for the spec to pass. This spec would not pass because one of our tests returns false. The second test is expecting false not to be false. In the previous lesson, we were given a function, the sum function, and we later added our tests, identified some bugs and started refactoring our code. This approach works, but the real power behind testing shows itself when you write your test first. This is called the red, green refactor cycle. It's called this because you write your test first and they all fail since there's no code to make them pass. You then write the code required to make your test pass. Once that's complete you can safely refactor your code as continue to add new features. Let's put the red, green refactor cycle into practice by writing our very own address book application. Let's start by creating two new files, spec/AddressBookSpec.js and src/AddressBook.js. We'll then need to update our SpecRunner.html to run these two files. I included my source file here, src/AddressBook.js. And my spec file here, spec/AddressBookspec. Notice I removed the player and song entries that were already there. Now, let's start to think of what functionality would be useful for an address book. I think being able to add a contact is a pretty useful feature, don't you? So, lets start writing a test for this. I'll describe a new suite called Address Book, and within it I'll have a spec called it should be able to add a contact. I think I'll take the object ordinate approach to this problem. So, let's instantiate a new AddressBook object in our spec. Now, to add a contact, I'm going to need some sort of addContact method in my address book. What would I pass to addContact? I'm going to need some sort of object. So, we created a new contact object here, and instantiated as this contact. And I'm just passing it in here. Now, I need to think of what is a good way for me to test that this contact was actually added to my address book? I should expect that if I were to get the first contact in my address book, that this would be the same as this contact. So, I wrote a test that does that. In doing this, I can see that I'm also going to need to add a getContact method in my address book that accepts an integer index. Now if I run specrunner.html, I'll see that I'm failing one of my tests. It reads address book should be able to add a contact. And address book is not defined. We've hit the red portion of our red, green refactor life cycle. We need to start writing our implementation of our address book. In what file would we write our address book implementation? In spec/AddressBookSc.js? In src/Contact.js? Or in src/AddressBook.js? We would write our implementation within the SRC/Address Book file. The address book spec file is where we're writing all of our tests. And in contact.js file would correspond to an implementation of tests that were in a contact spec.js file. Now that we know our test is failing, let's start iterating on our implementation and get this test turned green. We'll need to first edit our source/AddressBook.js file and start writing our implementation in there. If we look back at our spec runner we'll see the error AddressBook is not defined, and that error resides on line 3 of our AddressBook spec where we were instantiating our object. This is an easy error to fix, we'll just write a constructor function. If we refresh our spec runner, we'll see a new error; Contact is not defined. To resolve this error, we also need to write a contact constructor. To keep everything organized, I created a new file called Contact.js, in my source directory. And once again, I wrote a quick constructor function. I also had to add this file to my spec runner, so that it gets run. I'm going to continue this process of refreshing this SpecRunner, identifying the error, going back and fixing that error. For instance, now I have an error that says undefined is not a function. And I see that, that error is on line six of my AddressBookSpec. If I look at AddressBookSpec, I see that it's probably this call to addContact. That I haven't added to my class yet. I'd like you to go ahead and do this process yourself. Refresh your SpecRunner, identify the error, make the change in your AddressBook file and then save it. Refresh SpecRunner and continue. When you're done, check this box, Green For go! Here's how I completed my implementation. My next error was undefined is not a function, and that's not a terribly useful error, but if I look at the line number, it tells me, it was line six, in AddressBookSpec. If I look at that line, I can see it's referring to this addContact method of my addressBook class. So I just need to write this addContact. I did this by adding a new property to the class called contacts which is an array. I then wrote a new function called addContact that accepts a contact as a parameter and just pushes that contact on to this array. My next error is on line eight of AddressBookSpec. And it's related to my use of this getContact method here. That method doesn't exist. So, I need to go write that. So, I wrote a getContact function, which just accepts an index, and returns the element of the array with that index. If I reload my spec runner, I now see that all my specs are passing. My address book should be able to add a contact. Another useful feature of an address book, would be to delete a contact. So let's start working on specing out that feature. Just like before, all, to find a new spec with the it method, I'll accentuate my addressBook and thisContact variables just like before and then I'll add the contact to my address book so that I can delete it. Now, we haven't written a deleteContact method yet. So we know we're going to get a failure. But what should our expectation or our test for this spec be? My test for this spec is if I get the first contact from my address book, I expect that object not to be defined. If I deleted it, it shouldn't exist. After refreshing my spec runner, I now see an error again. I have two specs, with one of them failing. One of them passed, and one's failing. It says undefined is not a function. And, it's on line 16 of AddressBookSpec. This is in reference to my deleteContact method. So I need to go write that function. I can use the splice method of an array to remove an element. I then rerun my test and see that my implementation was successful. My address book can add a contact, and it can delete a contact. As we look through AddressBookSpec.js file, we can start identifying some redundant code. We're having to set up our addressBook and Contact in each of our specs. On the one hand, this is a good thing because we're getting a nice clean slate for each and every test. On the other hand, we're doing this manually. Thankfully, Jasmine offers a way for us to define a function that should be run before each and every one of our tests. It's called the beforeEach function. Let's refactor our spec real quick, so we don't have to keep repeating ourselves. I've moved the addressBook and thisContact, variable declarations, up to the suite itself. Remember, in JavaScript, inner scopes have access to variables declared in outer scopes. So I know all of my specs will have access to these variables. Now all I need to do is place my instantiation within this beforeEach function. Now, these two lines we'll run beforeEach of my test, contained within this test suite. You may ask yourself, why didn't I move the addContact line into beforeEach as well. With just these two specs, I could have done that. It would have been fine, but I'm not completely sure that adding a contact is required functionality for any future specs I may write within this suite. For now I'm just going to keep those lines right where they are, and if I decide otherwise in the future I can always move it up Testing asynchronous functions is a bit different, because we need some way to inform the testing framework that our asynchronous function has completed. Let's imagine our application needs to make an API call to a server to retrieve a list of initial contacts to put back into our application. Let's write a new test suite to work on our new asynchronous functionality. We're just going to fake our asynchronous functionality. So, in this case, we'll have to write our implementation first. Normally, you'd be given an asynchronous method from an API provider, like this push method from Firebase. We'll write a getInitialContacts function, and to make it asynchronous, we'll just use setTimeout. You can ignore most of this. A lot of it's just boilerplate to make this function act as if it's asynchronous. The important part is the self.intialComplete=true within the callback. This is what our fake API call will do when the asynchronous function is complete. You can also see I set an initial value of false within the constructor. We'll write a new test suite called Async Address Book and within that test suite, we'll have a new spec, it should grab initial contacts. I've instantiated my variable again, new address book, and then I call my getInitialContacts method. Now remember this is an asynchronous function. After I call that, I have an expectation here, that, I expect addressBook.initialComplete to be true. Now I want you to try and use that spec as you've been doing all of your other tests, without considering that it's asynchronous. Go back to your SpecRunner. Run the test again and let me know what you're results were. Did all of your tests pass? Did all of your tests fail? Or did only 1 of the your tests failed? The correct answer is that one of your tests should have failed. If we look at our spec runner, we'll see that we have three specs and one of them failed. It says expected faults to be true. This is the value of our initial complete variable and we wanted that to be true. The reason this is failing is because our test, or our expectation, is running before the asynchronous function can complete its tasks. Let's go back and fix that test, so we can properly test this asynchronous function. You might think to just put our test, or our expectation here in the call back of our asynchronous function, but that won't work either because then this expectation will be run within the scope of our application, and not within the scope of the testing framework. We can solve this problem by using beforeEach, like we did before. And we'll also use a new special function, called done, that signals to the framework when an asynchronous function has completed, and we're ready to go run our tests. We've refactored our test a little. First we moved addressBook up into the suite level scope. We then added a beforeEach function, and you can see that we passed done to the callback here. We call addressBook.getInitialContacts, just as normal, but within its callback we then call the done function. This will signal to the framework that our asynchronous function is done doing what we needed it to do. And we can continue testing. The only other thing we need to do is signal to the framework which of our tests rely upon that asynchronous execution. Again, we use done to signal this. We passed done to our function within our spec. We then just called done after our tests. If we go back and run our spec runner, we'll see that everything's green. 3 specs, 0 failures including our asynchronous function. See testings easy. The red green refactor process of writing an application may feel like a lot of extra work, but just look at everything you've already accomplished. If you wanted to continue working on this address book application you could do so with confidence your new features would not break what currently exists and that's what testing in great application design is all about, confidence