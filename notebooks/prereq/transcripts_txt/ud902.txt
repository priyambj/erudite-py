Hi, I'm Gabrielle and I'm going to be your instructor for this short course on Swift Syntax. Swift is already having a huge impact on iOS development. It's fast, concise, easy to read, and comes with tools like playgrounds that make it easier than ever to visualize your code. A welcoming language for beginner and intermediate programmers, Swift makes the road to building your own iOS apps considerably less steep. Fantastic resources for learning Swift are easy to find. Not least among them is Apple's guide, The Swift Programming Language which we hope you'll come to rely on as a reference. This course hopes to offer something that is less common among other Swift resources, practice. Throughout the course, we'll be working through examples together, and each lesson will end with a set of exercises to get you more comfortable with Swift's idiosyncrasies. We'll start out with some basics of types and operators and practice manipulating strings and declaring variables and constants. Then we'll move on to what is arguably Swifts most unique and confounding feature. Optional types. We'll talk about collections and control flow, including lots of practice with switch statements. Functions and classes. Enumerations and structs. Which are considerably more powerful in Swift than in other languages. Protocols. And will wrap things up by exploring closure expressions. Which can be tricky at first, but wonderfully convenient once you get the hang of them. This course is designed for programmers who have some prior object oriented experience. For students who, through work with other languages are already familiar with most of the concepts I've just listed. So let's get started with Swift types. At the beginning of each module all I ask you to open up a playground file like this one. That file will contain the examples I will walk through so you can follow along. A second file will contain exercises for you to do on your own. You can download all the files for the course from the link in the instructors notes at the beginning of each lesson. Go ahead and download the playground files for lesson one now. Then open up the file entitled Lesson One, Types and Operators. If your playground doesn't look like this, but instead has a bunch of green comments. You'll want to change one of the settings up here in the editor menu. Go down to here where where my menu says show ROM mark up. Yours might say show rendered markup. So you want to click on it if it says show rendered markup. Then it should look like this. I'm going to start by quickly running through the definitions of Swift's primitive types. Swift's primitive types don't have too many surprises. Here in this light switch class the on property is a bool. Swift booleans always have a value of true or false. They can't be assigned to zero or one as in C, or yes or no as in Objective C. If you don't recognize any of this syntax, don't worry. That's to be expected. I'll explain class and property definitions soon, along with this dot syntax. For now just focus on the data types. For properties that need to hold continuous values, we might want to use the int type, which holds an integer. For example if our light switch had a dimmer. I'll give our light switch a dimmer property. And then I'll set that dimmer property to be of type int. What if we wanted to set our dimmer to pi. If we want this dimmer property to be able to represent decimals, we can try using a float instead of an int. Of course if we use a double then we can get a more precise representation of pi. Here I've carried it out to eleven digits. Between float and double, you can decide which type to use based on the level of precision you need. Strings and characters in Swift are pretty much as you would expect. Naturally the character type holds a single character, and the string type represents an ordered collection of characters. The Swift string type comes with a handy bag of tricks, that makes string manipulations nice and concise. Like this simple string concatenation. Here in the playground sidebar you can see the concatenated string. We'll have more fun with strings and the exercises at the end of the lesson. There are two other Swift types that require a deeper dive. The first is the optional type, which is the focus of the next lesson. And the second is tuples, which we'll talk about in the collections lesson. For now, just know of their existence. Before we finish, there's a secret I haven't revealed. See how I've indicated the type for each of these variables? I can actually take all of these type indicators out. But the compiler is having no problem inferring the correct type. And we can even test that by taking a look at the type of these variables. Let's try this concatenated string. This dynamic type property can be used to investigate any objects type. And we can see over here in the sidebar that the type of concatenated string is a Swift string. And the compiler was able to infer that, even though we didn't indicate it directly in the definition. In the upcoming quiz, you get to play the role of compiler and do some type inference of your own. When defining constants and variables in Swift it's generally not necessary to indicate type because it can be inferred by the compiler. Imagine you are the compiler and match the constant to its inferred type. Type your answers in the text boxes. The answers are pretty straightforward. I'm sure you all inferred that kitchenSwitch's type is LightSwitch, ticketPrice is a double, swiftIsFast is a bool, and encouragement is a string. Notice that even though ticket price could technically be a float, the Swift compiler defaults to double. Now that you've seen some SWF types let's move on to simple operations. We'll start with comparison operators. Let's say my little cousin Chloe gets an allowance every week. With her allowance she likes to get ice cream and go to the movies. By the way, I'm going to use a lot of if statements and these operations. For now just become accustomed to how the if statements look. And stay tuned for more practice writing if statements in the lesson on control flow. If she gets soft serve for $1.50 everything is all good. She can get ice cream and go to the movies. But if Chloe goes to the fancy ice cream place, the calculation changes. If we wanted to condition on the case that she has just enough allowance, we could use the equals operator. But of course, it makes more sense to condition on her having greater than or equal to the combined price. Now, let's look at the logical operators. Here, I've defined some variables as bulls and allowed the compiler to infer their type. When conditioning on a bull, you just type the variable name. And more for both languages you might have to type something like equals true. But that's not necessary in swift. So here if hungriest true, let's eat. Otherwise, we can wait until later. If we want to reverse the condition, we just throw in an exclamation point indicating not before hungry. Here, you can see the and operator. If hungry is true and vegetarian is false, let's eat steak. I must admit, I have a hard time passing up a juicy rib-eye. But if hungry is true and vegetarian is also true, let's go for a pumpkin curry. If neither is true, then never mind. Now there are a few cases in which hunger is not a necessary condition for eating. And for me, that would be when there is pie. Here you can see the or operator. So here, if hungry is true or thereIsPie is true Let's see. Now I'm sure comparison operators and logical operators are a piece of cake for most of you. The ternary conditional operator is a little less intuitive. But it can be super convenient once you get the hang of it. Apple summarizes turn airy conditionals nicely in the book Swift programming language, using this theoretical example. Here if question is true then the result is answer one. Otherwise, there result is answer two. So the previous examples could be written as follows. If hungry is true, let's eat. Otherwise, let's wait. If hungry is true, or there is pie, let's eat. Otherwise, let's wait. As you can imagine, this syntax is really convenient with short, simple conditions but can become a come hard to read as your conditions become longer or more complex. This syntax is especially handy for calculations with conditions, like this one. There is one thing that a ternary operator can do that in if else statement cannot. The entire ternary statement is an expression. It evaluates to a single value. So we can insinuate it right into another expression like this. So the lunch price is now calculated using the sandwich price. And if tax is true, we'll add an additional $.50. Otherwise we'll add nothing. For this module, you'll want to open up the playground file entitled Lesson1_Strings. And then of course, you'll want to check in your editor's menu that down here at the second to the last item says, Show Raw Markup. If you see a bunch of green comments, you're going to want to click Show rendered markup. There's a lot of fun to be had playing the strings and Swift strings are no exception. Earlier, you saw strings defined as string literals. And you also saw Swift style string concatenation. Because Swift string class is built from Unicode scalar values, one can type emoji directly into string literals, like this. Oh yeah, to bring up the emoji keyboard like that, I do control, command, space bar. And then I can choose the heart. Another time saving feature of Swift strings is support for string interpolation. In other words, inserting values of variables and expressions directly into string literals. Let's say we have a statement about how much a particular dog eats per month. And remember you can always see the result of the executed code over here in the sidebar. Now let's say instead of Lou Lou we want to know how much Ferris the Springerdoodle eats per month. Here I've declared dogName as a variable and then I've inserted it into my string. And over here on the right you can see that the string evaluates to Ferris eats 25 pounds of dog food per month. We can add expressions to our string as well. Let's say we're really only paying attention to how much Ferris eats per day. This monthly consumption rate can actually be evaluated as the string is built. And of course, I do that by typing backslash, and then parentheses. And then between the parentheses, I put the expression I want to evaluate. So pounds per day, Times days per month. And again, you can see the output hasn't changed much. Now our doggie diet string is much more customizable. For example if we want to calculate the pounds per month eaten by little Frankie here, all we have to do is change the value of pounds per day. Reassigned the dog named variable and then re-evaluate our doggie diet string. And then over here we can see that little Frankie eats 7.5 pounds of dog food per month. Okay, we're still in the file in titled Lone_strings, and I say a string isn't just a string for a couple of reasons. Number one through the .characters property of the string strut, we also have access to an array of characters. And number two, a string can be treated as an NSString which is a class from Objective-C. Let's say we wanted to identify all of the e's in this string. Let's say it's a password. Here, I'm using Swift's for in loop, which we'll discuss in detail on the lesson on control flow. By using the string's struck's .character's property, which is itself an array, I'm able to iterate through the password, looking at each character. Let's say I wanted to replace all the e's in my password with 3s. For this kind of operation, the methods in Objective-C's NSString class can be really helpful. Swift automatically bridges between the string struct and Objective-C's NSString class, which means Swift's strings have access to NSString methods, like stringByReplacingOccurrencesOfString. To see more methods available from the NSString class, follow the link in the instructor's notes. For this module you're going to want to open the file. Lesson one, Constants and Variables. It's another playground file. In Swift there are two different ways to assign a name to a value. Values can be assigned to constants, or variables. Constants are declared using the keyword let and variables are declared using the keyword var. Not surprisingly, once the value of a constant is set, it can't be reassigned. The value remains constant. So one should use let, when assigning a value that's not expected to change. Here, the encouragement string stays the same. So it's declared as a constant. The personalized encouragement string changes. So it's declared as a variable. Here's another example. Birth year doesn't change, but time keeps progressing forward, so current year does change, as does age, if age is defined as current year minus birth year. But it's important to keep in mind that context matters, as well. The previous example assumes that the variable, age, is going to be calculated multiple times. If age was only intended to be calculated once, then we'd go ahead and declare age and current year as constants. When in doubt, declare a constant over a variable. Any time a value is altered it should be explicit. This protects our code from inadvertently changing values that we don't want changed. Let's do one more example for good measure. Here, birthweight isn't going to change, so we'll declare that as a constant. But currentWeight is going to change, so we declare that as a variable. Here's another example. Let's say, I am a bouncer at a club, or in events going on, right now. Why do we use let, instead of var here for building capacity? Why do we use var, for attendance? Write your answer in the box, and then, move on to the explanation. Building capacity is constant. It's not going to change. Unless we bulldoze the building or something. So we declare building capacity with the keyword, let. Attendance on the other hand, will increase and decrease over time. So we declare attendance with the key word var. For this module we're still in the lesson one constants and variables playground file. You've seen that the values of constants remain well, constant, and the values of variables can vary. There are actually a couple of different ways in which a constant is immutable and a variable is mutable. The first way has to do with assignment and reassignment. Once a constant has been assigned a value, it can't be reassigned, even when reassignment wouldn't change the value, as in this case. Let's take a look at this error, cannot assign to let value, years of the goat. Notice that even though the values of the years of the goat and years of the sheep arrays are identical, these constants can't be reassigned. The second way of being immutable has to do with changing values. If we try to change the value of the array by appending a value to the end of it, the compiler complains, but for a different reason this time. Let's take a look at this error. Immutable value of type int only has mutating members named append. The problem here does not lie with the assignment per say, but with mutating the constant's current value. Now is a good time to go back and tackle this lesson's exercise set on string manipulation and when to use let and var. Next up, the infamous optional type. There's no denying that Swift's optional types are both unusual and tricky. But if you're going to become confident using Swift, it's essential that you understand optionals inside and out. And beyond practical use, optionals are sure to be a common target among interview questions for iOS developers. So let's start at the very beginning. Why does Swift need this data type that no other languages have? The need for optional types arises because Swift disallows nil values in all other types. As always, in the instructor's notes please find the playground file to follow along with the lesson and the exercises file for practice. For this module you're going to want to open up the playground file in title lesson two optional. Here's an example of what I mean when I say nil is disallowed in most Swift types. If I declare an int variable x and try to assign it a nill value, I get the following error message. Cannot assign a value of type nill to a value of type int. Ints can't store nil values and neither can any of the other primitive types. This isn't all that surprising. It's more surprising to see that object references can't store nil values. Here's a reference to a UI color object. It can store a UI color, UIcolor.redcolor, but not nil. That's unusual. This isn't true in Java, C++, Ruby, Python, C#, Objective C, they all have nil or null or some special value that stands in for null. Notice that even if we change the variable c to be an object of type any object. The data type for a general object reference, we can see that it still can't store nil. In a way this is cool. This means null pointer exceptions are impossible. But what about situations for which we need nil values? Let's think. Under what conditions would a value need to be no? Let's explore the two most common scenarios. The first has to do with values returned from methods. There are some cases in which it wouldn't make sense for a method to return a value. A good example is this init method. This method is used to initialize an int from a string. But not all strings can be converted to ints. What should happen when s2 is converted to an int? It definitely can't return an integer value. But throwing a fatal error isn't a much better alternative. We can see that the compiler agrees. Something is wrong here. It's important that a method like this int initializer can return something that represents no value or none. Declaring y as a type Int isn't enough. We need a type that has two options, either an Int value or no value. We can't pretend that nil values don't exist. Another common scenario that we'll see, especially when working with UIKit, has to do with properties of instances. Often classes of properties that can't be initialized until after an instance is constructed. Consider the simple ViewController. Notice that the compiler won't allow me to add this button property. Why is that? The problem is that the button is a regular Swift variable, and Swift variables can't store nil values. So what value should this button member store when a view controller is created? Just like the method return types before, in this situation we need options. We often need to instantiate a ViewController first, and then initialize its properties later. This is especially true when we're using storyboard. Swift needs a way for this button variable to either have a button value or to be nil. So as we just saw, plain, old variables in Swift do not allow nils. But in some situations, we want to allow for nil values. For situations like these, Swift has a special data type. It's called the optional type. What is this optional data type? An optional is like a wrapped box that might be empty. That's the option. It might have a value or it might be nll. Whenever you specify the optional data type, you also give the type of the value that might be inside. So we make a distinction between Int optionals, and String optionals, UIButton optionals, and AnyObject optionals. But it's really only one generic data type, the optional. We can't use optionals without unwrapping them. In this equation, the box represents an int optional. It might have a value or it might not. We can't tell until it's unwrapped. So now we come to the real challenge with optionals. How do we use question marks and exclamation points to declare and process optionals? [SOUND] Let's revisit the string to int conversion problem. Remember that this invocation should return an int value or nil if the string can't be converted. But of course, z is a plain old int. It can't store nil. That's why the compiler's complaining. It's time to make an optional. Z shouldn't be an int. It should be an optional that can store either of two things, an int or nil. We change the data type of z, and the compiler is happy. Let's look at our other example, a property that should be able to be nil. Here's our simple View Controller subclass, and we want it to have a button property, but it won't have a value right away. The value will be assigned after it's constructed, perhaps by Storyboard. But the compiler won't accept it, because this is not an optional, it can't store nil. So the class can't ever be created. There's no button value set in the constructor. We need this property to be a conditional, so that its value can be nil until it gets set up. So we redeclare it with a question mark, and the compiler is happy Now that we've declared z to be an optional, let's try to use z in an operation. Let's take a look at this error. Here the compiler is telling us that z needs to be unwrapped. You can't use a present that's still wrapped. Now to unwrap z, we could just follow the suggestion from the compiler and place an exclamation mark after z like this. But when unwrapping optionals, we want to be as careful as possible, so we're going to learn the safest way to unwrap a variable. Here we can see that this 123 string will convert to an int with no problem. But what if we weren't so sure? Here is a scenario in which z might actually evaluate to nil. I've created an array with two items and an index that is randomly either 0 or 1. When I get this string from the array, I can't be sure whether it can be converted to an end value. I don't know whether z will be nil or not. How do we unwrap z safely so that we can use it in further operations? Swift uses the, if let, construction to carefully unwrap optionals. Take the time to really study this expression. It'll come up frequently in your Swift projects. This is the expression that unwraps z and places the int into a plain old int variable. In this case, we named it int value, but there's not a strict naming convention. This unwrapping and initializing of int value is also a Boolean expression controlling this if. It serves two purposes, and it will only evaluate to true if the optional has an int value. If the optional stores nil, then the whole expression will evaluate to false. Inside the block, the variable intValue has been initialized as an int and can safely be used. And we can use an else block for the nil case. To see both cases, you can rerun the Playground. Just go up to the Editor's menu > Execute Playground. You can see the results over here on the sidebar. Just click on this little eyeball,. And I'll run it again. And again. [LAUGH] Sometimes I get a value and sometimes I don't. In this example, I chose variable names to make the code easier to read. But a convention adopted by many developers is to name the unwrapped variable to match the wrapped variable, like this. This can be a little confusing at first, but you'll get used to it after you see it a few times. You don't have to adopt to this convention, but you may find that it saves time. This way you don't have to come up with a new name for every unwrapped variable. Safely unwrapping optionals like this is a fundamental Swift skill, and one can't have too much practice. Let's walk through another example with UIImageView. Here I've created a UIImageView which has a UIImage property. This UIImage property is a UIImage optional. In this example, we'd like to access the size property of this UIImage optional. If I try to access the image property directly to get the size, the compiler complains. Since there's no guarantee that this image property contains a value, we'll need to unwrap it carefully. So we use if let to declare a variable and initialize it with the unwrapped image property. If the image has a value, we can access its size. If the image is nil, we're still covered. Let's say we hadn't set the image yet. In that case, the else block gets executed. And here we can see the image hasn't been set. And if we do go ahead and set the image to something, here we can see its size. And now that it's unwrapped, we can also expand the image from within Playground. Here we are back in our playground file, entitled, Lesson Two, Optionals. In the previous example, we accessed the size property of an image in two steps. First, we unwrapped the image, and then we accessed its size property. A more concise way to accomplish the same goal is to access the properties of optional types using optional chaining. You'll find that optional chaining is used widely to access properties in UI kit. Here the question mark unwraps the image optional, allowing access to its size property. This is optional chaining. If we check the type of the size that's returned, we see that optional chaining returns a variable that's also an optional. Because this size variable is itself an optional, even if this image property is nil there's no risk of a compiler error. But then, of course, to use the image size variable we need to safely unwrap it as well. So when you see Optional Chaining in action, it looks like this. This statement is actually unwrapping two Optionals. The question mark is unwrapping the image Optional. And the if let construction is unwrapping the size Optional. When you look at the two methods together, you can see that optional chaining is slightly more concise. Let's go through one more example together. Let's say we have a class called animal. And that animal class has a property called tail. The tail property is an optional. Not all animals have tails. Here will instantiate an animal, Lenny. He's a lemur. With a 12 centimeter tail. Just like with UI image view. We can use optional chaining to access a property of an optional type, like so. Over here in the sidebar we can see that Lenny's tail is twelve centimeters long. But if we encounter an animal with no tail like Gilbert the gorilla, the program won't crash. We've safely unwrapped our optionals and handled the nil case. So far we've learned to declare optionals using question marks, and we focused on safe ways to unwrap optionals using question marks and if let statements. Now it's time to get a little reckless and start working with exclamation points. Unwrapping optionals with exclamation points requires a lot more confidence in your code. If you try to unwrap a nil value with an exclamation point, yikes. To unwrap an optional in this carefree manner, place an exclamation point after the variable. But if the value inside is nil, it explodes. [LAUGH] Okay, nothing explodes, but it does throw a fatal error. There is no safe way to unwrap with an exclamation point. When you choose to unwrap with an exclamation point, you're saying that you want the program to crash if the value inside is nil. It communicates to your code readers that you're confident there will not be a nil value in the optional. We can also declare optionals with an exclamation point, much the way we did with question marks. But this optional is different. It's implicitly unwrapped. That means that when this optional is used in an expression, it will automatically unwrap. It is an optional, so it can store a value or nil, but it's as if it's a very fragile wrapped package that immediately falls open when it's picked up. Because we don't unwrap it carefully, if there's a nil value inside, bad things can happen. A fatal error could be thrown. So in what scenarios would it be appropriate to use such a volatile optional? Let's look at a couple examples. Let's say we're using our old friend the Int initializer method and invoking it on a variable that we're confident can be converted to an int. We know this method is going to return the int 123, so in this case, unwrapping with an exclamation point is appropriate. We know there's little risk of an error being thrown, so we can place the exclamation point after w like this, or we could unwrap the return value directly, like this. In the second case, the value assigned to w will be a plain old int. What about declaring implicitly unwrapped optionals? When is an appropriate time to be so bold? Well, remember the button property in our view controller? We know that this button property will be nil when the view controller's created, so we know it needs to have an optional type. We can also be confident that this button property will be set by storyboard. In that case, it should be okay to unwrap this property automatically and declare it with an exclamation point. It is possible for this to backfire. Here's what it looks like in an x code project if we try to use the button but it hasn't been initialized. Again, the problem here is that we're accessing the button in order to get the title for state but the button doesn't exist yet. You can get a fatal error. This is why one has to be careful and only try to access an implicitly unwrapped optional in a case like this when you know the button will be there. Optionals are also necessary for downcasting in swift. Here's what I mean by downcasting. Occasionally objects are labeled as members of a particular class. But can also act as a member of a subclass, to downcast is to cast such an object as an instance of its subclass. You'll see a lot of downcasting with optionals when you start interacting with classes like UI storyboard and the app delegate. But let's start with a simpler example. Here we have a beverage class with two subclasses, hot drink and cold drink. We also have an array of beverages. Because there are both hot drinks and cold drinks in this array, the array must be of class beverage. There are no mixed type arrays in Swift. Let's say we wanted to loop through the array of beverages, And generate a message that will offer each of the drink choices. When we loop through the array, each item will be treated as a beverage. But we really want our message to be more specific than that. It would be better if we could cast a beverage as a hot drink or a cold drink. Before offering a drink to a guest. Now, there are two points here I'd like you to remember. First focus on this piece of code here. When we grab a drink from the array we don't know whether it can be cast to a cold drink or not. So we use an optional cast with an as question mark. Also known as a type cast operator. By casting the item from the array as an optional ColdDrink, we're saying this item could be a ColdDrink or it could be nil. Here's the second point I'd like you to remember. As we know, optionals can't be used until they're unwrapped. So if you use the as question mark typecast operator, you also have some unwrapping to do. Just like we've done previously with other optionals we can use a flat. Remember that the if let construction checks to see if an optional has a value. If it does have a value this code gets executed and we can use cold drink in our message. If it doesn't have a value the ELSE block is executed, and the beverages cast as a hot drink. And here in the sidebar we can see those custom messages. But let's not forget about the exclamation points. Although they are risky they can also be convenient in cases where we're confident about the identity of the object being downcast. Let's say we're a coffee shop. We only serve hot coffee. But for some reason a method from an Apple library is returning in array of items of class beverage. If we never deal in cold drinks, we might boldly downcast beverages to hot drinks using as!. As we know, optionals with exclamation points automatically unwrap. So our downcasting work is done. No if let required. That does it for optionals. Again, be sure to work through the exercise set. Mastering optionals now is well worth your while and sure to cut down on debugging in the future. [MUSIC] In this lesson we're going to be talking about SWIFT collections, which include arrays, dictionaries, and sets. Just as a quick refresher, an array is an ordered list of items, a dictionary is a collection of key value pairs, and a set is an unordered list of distinct values. Of the three, arrays are the only collection that has a defined order. And also the only one that may have repeated values. As an iOS developer you're sure to use arrays in dictionaries on a daily basis. You're undoubtedly already familiar with these data structures, but it will pay to really internalize their Swift implementations. For example, when we get to the networking course you'll be using dictionaries a lot in parsing JSON. We'll also briefly talk about sets. For this module you'll want to open up the Playground file and titled Lesson3_Collections. Let's start with arrays. Arrays can be initialized in three ways. Here's the first option. By now you've seen these parentheses a few times. They represent a call to a constructor and init method where the word init has been omitted. Here I've typed array to specify the type of the object we're initializing. Just like you saw earlier with the light switch class, with collections we also need to specify the type of the item that the collection holds. So we type double here in between angle brackets. And in the end the statement will initialize an empty array of doubles. You actual will rarely see that first option used. More often you'll see shorthand that looks like this. Again, I'm initializing an empty array. The square brackets let the compiler know that it's an array, so I don't need to type out array anymore. And then I indicate the type, double, between square brackets. Like before, the parentheses at the end signify the constructor. And then I can add items to my more numbers array, like this. The third and most concise option for initialization is to use array literal syntax. Here I just create a list of the contained items, separated by commas and enclose them in square brackets. The same way I did to add items to the previous array. This array also holds items of type double. But as we've seen before the arrays type can be inferred by the compiler. It's super easy to combine these two arrays by concatenating them with the plus operator. Or to be even more concise I can use the compound assignment operator. Notice that the compiler doesn't allow me to add values to an array that's been defined as a constant using LET. If I've defined an array as a constant I need to define a new constant in order to concatenate the two. An array can hold any type of object, including custom classes. For example, here I'll define an array called circuit which holds objects of type LightSwitch. And then I'll add some light switches I want the circuit array to keep track of. Or I could just define the array's components from the get-go. Once you've initialized your array, chances are you're going to want to add or remove items. To add an item to the end of an array, I can use the append method like this. Or to add an item to a specific place in an array, I can use the method, insert at index. To remove an item, you use the method, remove it index. So for example, to take out Flo Rida, we need to specify that he's at index three. But I don't think this playlist has enough country music, so we'll insert Keith Urban, and we'll put him at index three. And then if we look over here in our sidebar, we can see that Keith Urban has been added to the array. If I want to know how many items are in my array, I can use the count method. If I want to retrieve an item, I can do so using sub script syntax. I just write the name of the array, and at the end, add the items index as a sub script between square brackets. And here in the sidebar we can see that the value Dej Loaf has been assigned to the constant musician. We've written exercises to give you plenty of practice working with arrays. I think you'll find the syntax to be fairly intuitive. For now, let's continue on to dictionaries in the next section. A dictionary is a collection of key value pairs. Dictionaries in Swift can be initialized in a couple ways. As with arrays, you can use initializer syntax or you can use a dictionary literal, a list of values separated by commas. Here between the brackets, we have the key and value type separated by a colon, and then a pair of parentheses to signify the constructor. You'll notice in the dictionary literal the relationship between key in value is also indicated with the colon. And many key-value pairs are separated by commas. Let's see another example. Here's my very short dictionary of animal life spans, which I can initialize with initializer syntax or with a dictionary literal. And here, you can see the type of the lifespan value is a range of ints. By the way, these three dots here represent the closed range operator. For example, this range represents the range from 20 to 30, including 20 and 30. The average lifespan of a ball nosed dolphin in the wild is 20 to 30 years. We'll see these range operators again when we get to flow of control. Naturally, once you've initialized a dictionary you're going to want to add items to it. To add a key value pair to a dictionary, set the value for the key using subscript syntax. So here we'll add a couple of entries to our animal groups dictionary. A group of crows is called a murder. I always thought that was a strange one. And a group of monkeys is called a troop. If we use the count method, which has the same syntax of the array classes count method, we can see that before we had three entries, but now we have five. And if we print out the dictionary, we can see the two new entries. Removing a value from a dictionary looks very similar to adding a value. But in this case, the value for the key is assigned to nil. And after we assign the value for crows to nil. We can see that the crows murder pair has been removed from the dictionary. What if we want to change the value associated with a key? For this we have a couple options. We can keep using the same versatile subscript syntax like this. Here, let's change troop to barrel, or we could use the method update value for key. This method is interesting because it returns an optional value. This is good because if you try to update a value that's not in your dictionary. Your program will crash. The update value method will just return nil And go ahead and add the new key-value pair to the dictionary. And here you can see we've added a crash of rhinoceros to our dictionary. No pun intended, I swear. If the dictionary does indeed contain the value you tried to update, the update value for key method returns the former value. The old value. Like we saw here when the method returned flock. If you want to retrieve the value for a particular key you can use, you guessed it. Sub script syntax. In other words, the dictionary name followed by the key in square brackets. Let's scroll this up and make a little more room. One has to be careful when retrieving values from dictionaries. Because retrieving a value for a given key from a dictionary returns an optional. Why would a dictionary return an optional? I'm just going to pause for a few seconds and let you think. It returns an optional because there's always a chance that the key value pair you're looking for isn't in the dictionary. There are many cases in which a program might ask for a value from a dictionary, not knowing whether it will be there or not, so it returns an optional. And naturally, that optional needs to be unwrapped. We unwrap a value returned from a dictionary using if let, just like we'd unwrap any other optional. In this example we want to retrieve the value for a group of whales and use that value in this print statement. So we unwrap it like so. And here the optional has a value, pod. So what happens if the key isn't found? No problem, we're covered. Like in this example. Sasquatches are not in our dictionary, so the optional has a nil value. But that's okay because we've specified exactly what we want the program to do in case of a nil value. A set is an unordered collection of distinct values. Like arrays and dictionaries, sets can be initialized with literal syntax or initializer syntax. Notice that if I add two identical values to my set, the compiler doesn't complain, but it doesn't add that repeated item either because, of course, sets have no repeats. You'll find that inserting, removing, and counting items from sets is similar to working with arrays and dictionaries. Here I'm adding all of the emoji trees to the trees set. Oops, except a cactus isn't really a tree, so let's remove that one. And remember you can get to the emoji keyboard by pressing Ctrl/Cmd+Spacebar. So we can remove the cactus using the remove method. And as always if you want to know how many items are in the set, you can use the count method which is available to all collections. And that should be enough to get you started with sets. You'll find they aren't used as frequently as arrays and dictionaries. But for more on operations for defining, manipulating, and comparing sets, follow the link in the instructor's notes. Well that wraps up collections. Make sure you download the exercises to get some practice initializing arrays, dictionaries, and sets and manipulating their contents. All right. So far we've seen a lot of short statements defining and manipulating data types and data structures. Now it's time for control flow, the syntax of telling your program which statements to execute when. For this module you want to be following along in the playground file entitled l four control flow. Let's start with for loops. Swift supports traditional C style for loops like this one. Note that there are no parentheses around the condition. If you're used to C style languages, you might miss the parentheses at first but they'll soon fade from your heart and you'll realize you're better off without them. C style for loops might work well for bar songs. But I think you'll really come to appreciate the efficiency of Swift's fast enumeration with for-in loops, which you've got a glimpse of earlier when we talked about in strings. For-in loops take the general form, for item in Collection. And then between curly braces, the statements you want to execute on each item in the collection. To iterate through this string for example, we just write for character in demostring.characters, which is a collection of characters. And then this print statement will be executed on every item in the collection. In this case, every character in the string. It's super convenient. And then, here's what it prints to the console. Let's see another example. Let's find the sum of all the ints in this array. To do that, we just type for value in intArray. And this statement adding it to the sum will be executed for each member of the collection. You can see here in the playground sidebar that it's being executed five times. And then if we want to see our sum, we can just type some and that will appear in the playground sidebar as well. We can use for-in to iterate through dictionaries as well. Here we have a dictionary of movies and their directors. And here's a for loop that prints out a statement about who directed each of the movies in movie dict. You can see that the syntax is similar to iterate it through an array. In this case the key value pair is placed in parentheses after for. And then both key and value can be referred to in the body of the loop. And if we want to see that output in the console, we just go down to the bottom of the screen and click on this button that shows the rectangle with the triangle inside. And here's the output we're looking for. But for the most part we're going to stick to looking at our results in the playground sidebar. So let's close the console for now. Let's do one more. Let's try something with the animal group's dictionary. Here the plural animal name is the key and the animal group name is the value. And we can iterate through each pair to print out a statement about each group. So if we open up the console again, we can see that many whales form a pod, many lions form a pride, many geese form a flock. What do many auditions form? While loops in Swift aren't particularly surprising. They take the form, while, condition, and then in between curly braces, the statement that you want to execute. Here's a while loop that's counting down a timer. While the timer's greater than zero, Decker meant the timer. In here you can see the loop gets executed ten times. Here's another while loop, simulating having a beer with friends. A beer with a lot of toasting as it turns out, so while beer volume is greater than zero, cheers. And then subtract the amount you set from the volume, and here you can see in the sidebar that it's being executed 40 times. Notice that here and in the previous while loop, there are no parentheses around the conditions, just like with for loops. Let's move on to repeat while loops. Repeat while loops take the form repeat, then the statements you want to execute in between curly braces, while a certain condition is true. And as you can see, unlike while loops, repeat while loops execute one time before the condition is evaluated. So I went ahead and commented out the previous two while loops, and you can see that we can write each of those while loops as repeat while loops like so. On to if else statements. You saw several if else statements in Swift when we talked about operators. If else statements take the form, if, a condition to evaluate, a statement to execute if the condition is met. Else, a statement to execute if the condition is not met. Notice again that it's not necessary to place the condition within parentheses as you might do in C or Java. It is necessary to place the statements between curly braces. Now let's revisit some of the statements from lesson one. Here we've got a bole called Hungry. If hungry is true, let's eat. Otherwise, let's wait. We can use logical operators to build more complicated conditions. Here we're adding a second bole, Vegetarian. If hungry is true and vegetarian is false let's eat steak. If hungry is true and vegetarian is true let's eat pumpkin curry. Otherwise forget about it. We can go for coffee or margaritas. Similarly, in example three. If hungry is true or if there is pie is true, let's eat, otherwise, nevermind. And that's it for now. If else statements and Swift are pretty intuitive. Most of you have probably seen switch statements before. They're used in Java, C based languages, Ruby. But they are arguably less intuitive than if else statements. You'll be seeing a lot of them in Swift though, and hopefully come to appreciate their conciseness. Switch statements are great when you're trying to assess multiple conditions. Especially when you're conditioning on multiple values of a given variable. Here's an example of an if else statement, that might be better written as a switch statement. It's a statement about the years of the Chinese Zodiac. You can see that even though I'm just looking at a few values that match the years of the monkey and the years of the goat, my statement is already getting a bit cumbersome. If we write this as a switch statement it's easier to manage. Switch statements take the form switch, then a type name, the type whose value you're conditioning on, case, the first value possible for this type, colon, then the statement that'll be executed if this case is true. Note that you can combine two or more values into the same case, as in this third case. At the end of the statement comes a default case. This last statement is executed if none of the other cases are true. It's important to include this default case, because a switch statement must account for every possible value of a given type. Every value must match at least one case. So for our Chinese zodiac example, you can see that the statement switches on the value of the variable birth year. If birth year has a value of 1992, 1980, or 1968, this print statement is executed. You were born in the year of the monkey. If birth year has a value of 1991, 1979, or 1967, the second print statement is executed. So let's change birth year to 1991. And we can see you were born in the year of the goat. And if the value of birth year doesn't match any of these six values, the default statement is executed. So if this was 1993, the default would be executed. Let's scroll down and look at another example. Here's a program that depicts the visible spectrum. It sets a variable, called color, based on the value of a variable representing light wavelength. Here we can see the ellipsis again. Remember that in Swift this is the range operator. So these values represent ranges of wavelength within which certain colors fall. If we alter the value of the wavelength variable, we can see different values being assigned to the color variable in the sidebar. Notice that the value of wavelength doesn't have to match the specified range, it just has to fall within it. One aspect that distinguishes switch statements in Swift, from switch statements in C for example, is that the flow of control does not fall through from one case to the next. What do I mean by fall through? Well, imagine moving through the switch statement, and checking each case in turn. What should happen when a condition is met? Should execution of the statement stop, or move on to evaluate the rest of the cases? To fall through is to continue to evaluate the remaining cases. In Swift, if the conditions of one case are met, the statement is done. Let's look a little closer at what happens when switch statements don't fall through. This example switch is on temperature. I live in California, so I'm pretty much a wimp when it comes to the cold. Here you can see that 55 degrees appears in both the first and the second case. So what will be the output? When the temperature's 55 the console prints out brrr, and then it's finished evaluating the statement. It's done. The second case is never evaluated, the console never prints out comfortable. Even though 55 does match that second case. So what if I left a statement out? What would happen? Let's find out. What if I left out this statement? Okay, we get an error. What does it say? Case label in a switch should have at least one executable statement. Every case needs an accompanying statement, because with no fall through, if a case matches, the program needs to be able to execute a statement and then be done. That's all for now on control flow. Be sure to complete the exercises to get lots of practice with for in loops and switch statements. And stay tuned for the next lesson on functions. Apple defined Swift functions as self-contained to chunks of code that perform a specific task. There are three main types of functions and swift. Global functions, Nested functions, and methods. Nested functions are slightly more advanced. So we're going to focus on global functions and methods for the moment. Global functions are functions that can be called from anywhere in an app. Global function syntax is easy to recognize because global functions are called by a particular object. They're just called sort of floating in thin air. One global function that you're sure to be intimately familiar with by now is print. Global functions like print can be called from anywhere within a class. On the other hand, when a function is defined in an associated with a particular class, we call that function a method. The vast majority of Swift functions that you write and call will be methods. Here we have a method called sum of strings which you may remember from your exercises. It's defined within the arithmetic class. And is also called by an instance of the arithmetic class. Let's take a closer look at that some of strings function definition. Function definitions take the general form. We start with the func [MUSIC] Oops not that funk. So func followed by the function name then a pair of parenthesis, inside the parentheses, you'll find the parameters. Taking the form, parameter name, colon, parameter type. Then an arrow pointing to the return type. Followed by the executable statements between curly braces. So if we look at our sum of strings method, we see that it takes in a parameter called a bunch of strings. That parameter's of type array, holding items of type string, and this function returns an object of type int. Let's look at another example. You've also seen this code before. The name of this function is reversedString. It takes in the string as a parameter, a parameter named a stringToReverse and it returns an object of type string. Keep in mind that not every function returns an object. For example, if reversedString printed out its result instead of returning it, the function signature would look like this no return type, and since there's no return type, no arrow either. I could also write the function reverseString like this. Here forwardString is a second name for the parameter being passed in. Undoubtedly you're wondering, as i was, why does this parameter need two names? stringToReverse is the local parameter name. You can see here that it's used locally, inside the function itself. This other parameter name forwardString is the external parameter name, and it's used externally, in other words when the function is called. We'll see more external parameters in a minute, when we talk about how to call functions. So to update our model, functions can take this general form. When you see a name on the left with no colon, that's the external parameter name, and the local parameter name is here. Now, if you think this is weird, you're right. This syntax is very peculiar and particular to Swift. And if you think two parameter names seems excessive, you would have a good argument. I won't go into why it's like this, but it has to do with Swift's ancestry in Objective C. Now that we've had a little practice dissecting functions, let's try interpreting some function signatures. Try to identify each function's return type from the choices given here. Indicate your answer in the text boxes provided. Identify the parameter type of each function from among the choices provided. Type your answers in the text boxes. Now that you've seen all the parts of a function, let's put those pieces together. We'll write a few function definitions together and then call those functions. We'll start with a description of the task the function should accomplish, and go from there. Here's one you may have seen before. Write a function that takes in the string and returns the first character of that string. Again we start with the func, and then we need a name. I'm going to call this one firstCharacterOf. I'll add my parentheses and my curly braces. In general, don't shy away from long names, especially in the age of code completion, it's more important to be descriptive than it is to save yourself a few milliseconds of typing. It also would have been fine to call this function firstCharacter, but I want to emphasize that the naming convention in Objective C in Swift is to use prepositions and function names to refer to the first parameter. In this case, a string. Here this function is returning the first character of the string being passed in. So we have our name. Next comes the parameter between parentheses. Let's call the string we're going to pass in, word. That'll be its local parameter name. And then we specify its type, string. And next comes an arrow and the return type. Our return type in this case is going to be character. And I'm just going to write return "x" here so that we can quiet that error for the time being. And finally we get to the meat of the function. In between curly braces here we'll put the statements we want to execute. There are a number of ways to get the first character of a string in Swift. I'm going to use subscript syntax with the index start index. And of course once we get that value, we want to return it. Okay, now it's time to call it. firstCharacterOf is a global function, so in order to call it, we just write its name and then pass in a parameter between parentheses. And over here in the sidebar, we can see that the first character of Mom is being returned. Now, notice that we didn't give our parameter an external name, we only gave it the local name, word. Thus when we called it, we just passed it in the parameter itself. Let's go ahead and add an external name to our parameter. It's kind of hard to come up with another word for word, so I'm just going to use word again. And now that we've specified an external parameter name, we need to use that external parameter name in the function call. Now you've probably noticed that the compiler is complaining about something. Let's see what it has to say. Word word can be expressed more succinctly as #word. It wants us to use the shortcut for external parameter names that are the same as local parameter names. If we just place a hash mark in front of the local parameter name, we let the compiler know that the external and the local parameter names are the same. Let's try another example, follow along with me. This time we're going to write a function that takes in a string and returns a string with the first letter removed from the beginning of the string, and instead placed at the end. We've got the func let's give it a name. Let's call it a placeFirstLetterLast. It's going to take in a string as a parameter. Let's call that parameter myString and it will return a string as well. And now comes the meat of the function. Just going to put a placeholder string here to quiet the compiler. Let's start out by adding the first letter to the end of myString. We can do that using the append function. Append is a method, a function that's part of the String class. So we call the method append on an instance of the String class using dot syntax. We just type the name of the string, a dot, and the name of the method followed by parentheses. We place any input parameters between the parentheses. In this case the parameter is a character to append to myString. So how will we get the first character of myString? Well, we just wrote a function that returns the first character of a string. Let's use that and put it here is the argument to append. Hm, okay the compiler's upset about something. Let's see what this error says. Immutable value of type String only has mutating members named depend. See, because myString is a parameter, it defaults to being a constant, as if it were declared with let. If we declare it with var, the error should go away. Sweet, so far we've appended the first letter to the end of the string. Now we need to also remove it from the beginning of the string. For that we can use the function, removeAtIndex. RemoveAtIndex takes an index as a parameter. The index we want to remove is the startIndex. And of course instead of returning placeholder, we want to return myString. And that ought to do it. So let's test it out by calling the function, and we'll call it on the string Mom. Over here in the sidebar you can see that Mom becomes omM, and we're ready for yoga. But before we move on, I'd like you to notice the difference between how we call global functions, and how we call methods. For example, append is called on an instance of the string class using dot syntax, it's a method. Global functions, on the other hand, like placeFirstLetterLast, are not called by any object in particular. I know you guys are getting to be pros by now. But let's do one more example for good measure. This time the challenge is to write a method. Inside the class. Movie archive. And this method should take in a year and a dictionary of movies, and return an array of strings listing the movies that were released that year. To start us off I've written the shell of our movie archive class and this dictionary of AI themed movies. Here in between the parentheses defining the movie archive class we'll write our function. Let's call it filter by year. Filter by year is going to take in a year as a parameter which will be of type Int and it'll also take in a dictionary of movies. Which will be of type dictionary and that dictionary will hold keys of type string, the movie titles and values of type Int. The release here. It will return an array of movie titles. So here we'll type our arrow and then the return type is an array of strings. Since we're going to return an array of strings, we'll need to initialize an array of strings to put our filtered movie titles into. I will go ahead and return that array so we can quiet this compiler error. The next step is to loop through the dictionary that's passed in and check each key value pair to see if the release year matches the year passed in as a parameter. To loop through the dictionary we can use a for in loop. We'll call the value release year. Then if the year parameter is equal to the value of release year, we add that movie title to our filtered array. Now our filterByYear method should be good to go. To call it will need an instance of the MovieArchive class. So here I'll initialize a MovieArchive and call it myArchive. Then I can call filterByYear using dot syntax. And of course the dictionary we want to filter is AI themed movies. And let's see what AI themed movies came out in 1982. And over here in the sidebar we can see Blade Runner. And if we try 2013 we get her. That ought to give you a good start on functions. Be sure to complete the exercises for more practice defining and calling functions. As always you can find a link to them in the instructor's notes. Next up, we'll talk about classes and their properties and methods. Did you play the game Mousetrap? Or see a Rube Goldberg machine at the science fair? If our app were a Rube Goldberg machine, then an instance of a class would be one of its moving parts. A class is a unit that we use to package together related data and functionality. A class is made up of properties and methods, as you can see here in this simple Movie class. The properties are title, director and release year. And it only has one method, an init method. We'll talk about the specifics of initialization shortly. For now, just know that every class needs an initialization method. Notice that the properties are generally defined at the top of the class, followed by the methods. Here's another class you've seen before, the Moviearchive class. This one has a property that's an array of movie objects. And in addition to its init method, it has a familiar method, filter by year. You can see that, apart from the placement of the code between these curly braces, defining properties in a class is no different from defining any other variable or constant. And defining methods in a class is no different from defining global functions. We're going to switch gears for just a minute and focus on what a Swift file looks like in context. Here's a very simple Xcode project from the UI Kit Fundamentals course. Ignore the code for now. I just want you to notice the files over here in the project navigator. You can see here that there's a .swift file for the AppDelegate, there's a .swift file for the ViewController, and here in the center you see the ViewController.swift file opened. Now, if you're accustomed to writing code in Java or C, you might be wondering where is the header file? The implementation files and interface files are not separated in Swift. There's just one .swift file in which a class is defined. You might be wondering, if there's not a separate interface file, then how do you know which objects are public and which are private? In Swift the default access control is internal. Which is similar to protected in Java. In general, with simple apps, you can use an object with internal access from anywhere in the app, but not outside the app. Practically speaking, this means that sometimes we'll need to specify a class as private, but rarely will we need to specify a class as public. As a member of a class, an object can be associated with variables and constants. Variables and constants that are associated with a particular class are known as properties. We're going to talk about three types of properties. Stored properties, type properties, and computed properties. Let's start with stored properties. In Swift, there's a strong emphasis on immutability. So you'll see a lot more properties defined as constants than in other languages. Let's talk about how those constants are initialized. Stored properties must be set when an instance of a class is initialized. Here we're setting the title director and release year to strings being passed into the init method. In this case the parameters have the same name as the properties. To distinguish the properties from the parameters, you can use self to represent the object being initialized. Initialization would look like this. To call the initializer instead of using the name init, we use the name of the class. And then if we want to access the properties that we just set, we use dot syntax. So that's the name of the object.the name of the property and here in the sidebar we can see that the title of Thursday night movie is Point Break. Notice that I 've used external parameter names here, external parameter names are required for init methods. There is another option for setting an object stored properties. You can give them a default value, off course in this case that wouldn't work out so well because the director property is a constant. So it can't be changed. But let's say we were only interested in movies directed by Rob Reiner. We could set the default value of director in the property definition and then not bother setting it in our init-method. You're more likely to want a default value for type properties, also called class properties. You can think of class properties as belonging more to the class itself than to any one instance of a class because they don't vary across objects. A type property has the same value for every instance of a class. We use type properties mostly for data we want every instance of a class to have easy access to. For example, if we had a class called kids movie, we might want to type property called permitted ratings to keep track of which ratings are permissible for children. To indicate the permitted ratings as a type property, we place the word static or class in front of its definition. Type properties are also referred to as static properties in languages like C and Java. The value of this property won't change across movies, but it's nice to have these ratings at our fingertips. It'd also be nice if we had some information about the reviews for these movies. Let's add an array of reviews from different media outlets. But then, of course, it'd be really convenient if we could see the average of the reviewer scores. Let's call it a metascore, like the app Metacritic. Such a metascore is known as a computed property, a property that's computed based on existing data in the class. Computed properties have custom getters and optionally custom setters. This one doesn't really need a setter though. Here's our custom getter. You probably haven't seen this reduce function before. It's a handy method for reducing the values of an array to one value. For a fun challenge, see if you can figure out exactly what this code is doing and post what you find on the discussion forum. For now, I'll just tell you that it's returning the average of all the scores in this array. Let's test out our getter. We'll initialize a movie with some reviewer scores and then access the metascore using dot syntax. Sweet! This one ought to be a crowd-pleaser. Now, in looking at the custom getter for our metascore, it may have occurred to you, wait a second. What about the getters and setters for the other properties? Guess what? We don't have to write them. They're automatically created when you declare a property. Now that you're experts on properties, let's go back to methods for a moment and think a little more carefully about the syntax of how methods are called. I've initialized the movies here, so we can have a movie archive object devoted to Rob Reiner movies. You've already seen a call to filterByYear. Here it is one more time. We just use .syntax on an instance of the MovieArchive class, and then we call filterByYear and pass in the year we want to filter by. Let's go with 1986. And then, we'll want to grab the first item from our movies array, Print out the title and we can see that it's Stand By Me. filterByYear is an instance method. You may also have occasion to call type methods or class methods. Type methods, like type properties, belong to the class, not to any particular instance of the class. And so, they're called on the class instead of being called on an instance of the class. You're going to run into a number of type methods when you start working with the iOs user interface library. UIKit. For example, here's a class method that you'll use when you build the second portfolio app. Me me. This method belongs to the UIImagePickerController class. It's called is SourceTypeAvailable. It takes in a source type as an argument and returns a bool indicating whether that source type is available on the current device. A source type, in this case, is the source of an image, like a camera or a photo album. In the playground, there's no camera available. So in the playground environment, if you pass in source type camera, this method returns false. The playground does have access to the photo library, so if you pass in source type photo library, the method returns true. If you are running this code on a phone with a camera, this method would return true for both source types. Let's take a look at the class definition for UIImagePickerController. I can access it from the playground by command clicking on the class name. Now, this might look intimidating. But all it is a list of properties and methods. Right here is the method isSourceTypeAvailable. Notice that it has the word class before func. Just like type properties. Type method definitions begin with the word class or static. Otherwise, they're defined just like instance methods. And if you use the word class instead of static, subclasses will be able to override the method. Now that you've seen how classes are built in Swift, so many new possibilities will open up to you. These are the moving parts that will make your application tick. This is a turning point. So be sure to take the time to master these concepts and complete the exercises on classes, properties and methods. Next up enum's and structs. You're probably familiar with enumerations and structs from other languages. Enumerations define a set of related values, and a struct is a convenient way to bundle properties together. In Swift, enumerations and structs are more powerful than in other languages because they can have their own methods and are able to conform to protocols. In other words, in Swift, it's easy to give an enum or a struct its own suite of functionalities. Let's start with enumerations. Enums are usually used for a finite set of values. An enum of the primary colors would look like this. You start with the word enum, followed by the name of the group, and in between curly braces you have a list of members preceded by the word case. Here's another example. This is an enum my aunties. Notice that you don't have to write the word case for every member. You can use this shorthand in which members are separated by commas. You might be used to enums having integer values like they do in C. In Swift, enum members can take on a value of any primitive type. For example, I have this enum of the American League West Division. Let's say I wanted each member to hold the value of their home city as a string. I just indicate string up here next to the name of the enum, and then I can define those values in the enum definition like so. You can access those string values like this, with the built-in property rawValue. Enums and switch statements work really well together. Here's a statement that switches on the value of the variable destination. Destination is an enum of type California park, which you can see has four members. This statement prints out different warnings based on which enum member matches the value of destination. Notice that if I leave out one of the parks, the compiler gives me a warning. This can be especially helpful if I add a value to an enum after I've already used it in a switch statement. The compiler helps me make sure all my switch statements are exhaustive. As you saw up here, initialization of an enum type is really simple. They're just defined with a specific member of the enum. Alternatively, they can also be designed with raw values like these city strings we used for the American League West, or they can be defined with what are called failable initializers. For more on those options, follow the link in the Instructor's Notes. In Swift, structs are much more powerful than in other languages. Their capabilities approach those of classes. In addition to their own properties, they can also have their own methods, and can expand functionality through extensions and protocols. Let's take a look at a couple of examples. Here's a struct called picture frame. It has three stored properties. Width, height and thickness, and one computed property, area. As with enumerations structs can have customized emit methods. But they also come with automatically generated member wise initializers, like this one here. In this line of code, I'm initializing a ten by eight picture frame with a thickness of 1.5. And this is how I access the computed property, area, and up here you can see the area properties custom getter. Here's another example, this beer struct has three stored properties, style, percent alcohol, and an international cheers dictionary. Cheers dict is a type property, it also has a computed property, suggested volume per serving. The volume per serving goes down, as the alcohol percentage goes up. Some of the Belgian beers at the pub around the corner from my house are super strong. If I was drinking whole pints of those, I might be in trouble. The beer struct also has its own type method called Cheers. It takes in a language and prints out a phrase to toast with in that language. And this is what initialization looks like for the beer struct. Again, I'm using the automatically generated member y's initializer to set our style and percentAlcohol properties. And here in the sidebar, you can see that a lager with 6% alcohol has been instantiated. As usual, we can access the computed property, suggestedVolumePerServing with dot syntax. Now I want to open up the console for a second, so we can see our results. Remember that because Cheers is a type method, we call it on the struct itself, so we call it on beer. And then, let's pick a language we want to toast in, let's toast in Japanese. And then we can look over in our console and see kompai. Structs and enumeration are value types. And classes are reference types. This is in fact the principal difference between these complex objects. Okay, so what are value types and reference types? When a value type is assigned to a variable or a constant, it's copied. An entirely new instance is created. When a reference type is assigned to a variable or a constant, there is no copy. A new reference to the original instance is created. This is definitely challenging to wrap one's brain around. But a couple examples should clear things up. Let's go back to our picture frame struct. We'll declare an instance of the picture frame struct and call it frame. Creative, I know. Here I'm initializing a frame as a 3 by 5 picture frame with a half inch thickness. Now we'll assign another variable, frameForMom. My mom always needs more picture frames. We'll assign frameForMom to be equal to frame. But mom needs a 5 by 7 frame. So we'll need to reset the dimensions of frameForMom. Now my question for you is what is the width and height of frame? I'll give you a few seconds to think about it. We can see in the sidebar that the dimensions of frame are still 3 by 5. When the frame was assigned to frameForMom, an entirely new copy was made. The values 5 and 7 are held by the copy represented by frameForMom. The values 3 and 5 are held by the copy represented by frame. What if picture frame were a class? Here's a nearly identical class, I'm calling it classy picture frame. Down here I'm instantiating a classy picture frame called classy frame. And setting its width and height to 3 by 5. And like I did before, I'm creating another variable called classyFrameForMom. And assigning it to be equal to classy frame. But of course, mom needs 5 by 7 frames. And again we ask ourselves, what will be the width and height of ClassyFrame. And over here in the sidebar, we see 5 by 7. But we never change the dimensions of ClassyFrame. How did that happen? Classes are reference types. So when ClassyFrame was assigned to ClassyFrameForMom, no copy was made. Instead, a new reference was made. This means that classyFrame and classyFrameForMom both refer to the same instance. Here we're changing the value of the underlying instance to 5 by 7, and both references are affected. In the code snippet you see here, what would be the value of darkColors.speed if laundry were implemented as a class? What about if laundry were implemented as a struct? Choose from the choices provided, and indicate your answers in the text boxes. If laundry were implemented as a class, darkColors.speed would be low. darkDelicates and darkColors both refer to the same instance of the laundry class. darkDelicates.speed being set to low changes the value of that underlying instance. If laundry were implemented as a struct, the value of darkColours.speed would be medium. In this case, darkDelicates.speed being set to low does not affect the value of darkColors.speed. Because darkDelicates and darkColors are structs, they're distinct copies. Now that you know a little more about enumerations, structs, and classes in Swift, I want to play a game I'm calling enum, class, or struct? Choose the right type for the job. So for each type I describe, we're going to choose whether we should use an enum, a class, or a struct. The first one is a triangle. It has two properties, an array of angles and an array of sides. And I think we should choose, struct. This is a simple type, just a couple collections with few values each. And one might imagine that each time we make a triangle we want a distinct copy to be made. Also, there's no need for inheritance. If we did want inheritance, for example for an isosceles triangle and a right triangle the subclass from triangle. In that case we'd choose class. Number two, UIImagePickerControllerSourceType. This is the type that indicates where images should be chosen from, when they're being attached to a text message, for example. Our biggest clue here is that the source type has three distinct values, photo library, camera and saved photos album. So we should choose, enum. The UIImagePickerControllerSourceType is indeed an enumeration. Enums are convenient for types that can be described as one property with a finite number of values. Here's another one. We need a type for a name object which holds two strings, a first name and a last name. Again, I would choose struct because we're dealing with few relatively simple values. And we're probably going to want every instance of a name to have its own copy. Let's go through just a couple more. Lets say we need a type to represent a subject in secondary school. This is a very traditional school at which there are only four subjects. Math, English, Spanish and Science. What would you choose? For this one again with a finite number of values an enumeration would work well. This last one is a little more complex. Here we need a type to represent a student. It will have a grades property to hold an array of grades, a name property to hold a name, a favorite subject property which holds a subject, and a computed property to hold the grade point average. Additionally there are a few different types of students. High school, elementary school, and middle school. So we want those subtypes to be able to inherit from the more generally defined student type. So what kind of type should we choose? For this one, we'll want a class. Between classes, enums, and structs, only classes have inheritance. On top of that, the structure of this type is a little more complex than you see in most structs. A struct could hold the data, but it would be unusual. That ought to give you a good start on structs and enumerations. Be sure of complete the exercises to deepen your understanding of value types and reference types, and for more practice choosing the right type for your needs. Stay tuned to learn about how to expand and customize the functionality of all of these type's with protocols and extensions. Protocols and extensions are both tools Swift uses to package modules of functionality that expand upon classes, enumerations and structs. Protocols can be shared across classes and extensions are used to customize existing classes. They both provide ways to reuse code and adhere to the principle of dry programming. That is to say, don't repeat yourself. Let's focus on protocols for the moment. If you're familiar with Java or C#, you may have heard of interfaces before. A protocol, much like an interface, is a list of related method signatures. When a Swift class enumeration or struct adopts a protocol, they're signing a contract to implement every method belonging to said protocol. This provides us a very powerful high level abstraction. For example, we can reason. Anything that conforms to Apple's built-in comparable protocol can be compared. And iOS development, protocols are an essential component of the delegate pattern, the pattern by which one type calls upon another type to perform some operation. For a deeper dive into the delegate pattern, follow the links in the instructor's notes. Here, we're going to focus on the syntax of defining, adopting, and implementing protocols. We'll start with protocol definitions. Here's a protocol I'm calling Souschef. Much like a class or struct definition, it begins with the word protocol, followed by the protocol name, and then in between curly braces we define its properties and methods. This protocol has no properties and two methods. You can see that the methods aren't implemented here, that's left up to the conforming type. Here, we just have a list of method signatures indicating parameters and return types. The next step is for a class, struct, or enum to adopt the protocol. And the code looks like this. Here, we have a class called Roommate. We want the Roommate class to adopt the Souschef protocol, so an instance of the Roommate class can help make dinner. To adopt the protocol, we just type a colon after the class name and then the name of the protocol. And what does the compiler have to say here? Type Roommate does not conform to protocol Souschef. This message is letting us know that we still need to implement the methods in the protocol. Remember, placing the name Souschef here is akin to the class signing a contract to implement the methods listed by the Souschef protocol. We still need to fulfill our contract. So here in the Roommate class, we need to conform to the Souschef protocol, meaning we need to write implementations for the chop and rinse methods. They will each take in a vegetable string and return a string indicating that their sous chef duties have been fulfilled. Soon enough, you'll be writing protocols for your own custom classes. Still, more often than not, you'll be implementing protocols written by Apple. Let's practice the syntax we just learned on a protocol from the Swift standard library. This protocol is called Equitable. We can Cmd+click on the protocol name to see its definition. There's a lot of commenting here, but the protocol actually only has this one method. It takes in two values, the left-hand side in the right-hand side of an equality and returns a bool indicating whether the two values are equal. In other words, with this method in the equitable protocol we can define what it takes for two instances of a class to be equal. As you just saw, to adopt the protocol, we just type equitable here after the class name. To conform to the protocol, we need to implement this function which is named with just the equal operator. And we'll say that two instances of the class Roommate are only equal if they have the same name and the same bool value for hungry. You'll notice that I've implemented this function outside of the class. That's because operators are global functions. And now, we can test whether two instances of the Roommate class are equal. A protocol is also a type. You can use a protocol name in all of the places you would normally use any other type. To describe variables, constants, and properties, to indicate parameter and return types, and to indicate the item types in a collection. Here's a class called DinnerCrew. This DinnerCrew is very egalitarian and inclusive. All of its members need to implement the Sous Chef protocol, but otherwise they could be of any class, enum, or struct. So we specify the members array property like this. We write Souschef where we would otherwise write the type of the items in the array. And we do the same for the parameters in the init method. But Sous Chef is in the class itself or a struct. How can it be capable of making dinner? Sous Chef has no logic of its own. To specify Sous Chef as a type is to say, I don't care what type goes here as long as it adopts a Sous Chef protocol. Here, you can see that it doesn't matter if I initialize a DinnerCrew with a random passer by or a roommate. As long as each member implements the Sous Chef protocol. For this module, you'll need to open up the file entitled lesson eight, Calm the compiler. And now we're going to play a few rounds of Calm the compiler. You'll see a series of compiler errors and quiet them by using the correct protocols syntax. In this first error, the Minion class has adopted the dirty deeds protocol. But the compiler is complaining. Type minion does not conform to protocol dirty deeds. Pause the video. Take a minute to fix this error. And then, continue on. To conform to the dirty deeds protocol, the Minion class needs to implement the methods cheat and steal. So if we add those implementations, the compiler is happy again. Let's try another one. Here we have our DinnerCrew class again, along with the Souschef protocol. The goal here is to initialize a deviousDinnerCrew with an array of minions. But we get the following error. Cannot invoke initializer for type DinnerCrew with an argument list of type [members: [Minion]. How can we fix this? What could be wrong with the argument list? Right now, the Minion class does not adopt the Souschef protocol. So minions can't be a part of the deviousDinnerCrew. If we add the Souschef protocol to the Minion class definition, and then implement the methods in the Souschef protocol, chopped and rinse, this error goes away. Let's do one more. Here, we have the DogWalker protocol. And the class Neighbor is adopting this protocol. We've seen this error before. Type neighbor does not conform to protocol DogWalker. Last time we got this error it was because we hadn't implemented the protocol methods yet. But here you can see that the methods have been implemented. What's going on? Here's what's going on. The throwBall method signature in the protocol definition indicates that throwBall should return an int. The throwBall method in the Neighbor class, on the other hand, is not returning anything. If we add the return type int to neighbor's implementation of throwBall, and then add the line return count, the compiler is satisfied. If you're familiar with C#, you may have seen extensions before. Or if you've done any work with Objective-C, you may have seen its analog to extensions, categories. But for many of you, extensions could be a brand new concept. Kind of like adding an extension to a house, extensions offer a way to add computed properties and methods to an existing class, struct, or enum. They're often used to extend types for which you don't have access to the code, like Apple Frameworks, or third party libraries. I want to walk through an example that I adapted from an example I found on Andrew Bancroft's blog. Which by the way you should definitely check out if you haven't yet. You can find a link to it in the instructor's notes. This example extends the UIView class to enable a view to fade out and fade back in. For this demo, we'll be looking at a really simple Xcode project. Go ahead and download it from the link in the instructor's notes, and then open the project in Xcode. It's called FadeExtensionDemo. In this left panel, the project navigator, click on the ViewController file. And then, look for the sunrise and set method. Here inside sunrise and set, you can see that I'm using the method, animateWithDuration, to fade out an image view. This animation changes the view's alpha value from one to zero over the duration that I pass in as a parameter here. This one is one second. There's also a delay parameter, so we could pass in a delay if we wanted. Under the options parameter you'll see we've passed in CurveEaseIn. This makes it so that the animation starts out slow and speeds up towards the end. For the completion parameter, I'm passing in some code that changes the image. And then, fades the view back in. Here's the code that changes the image. After the image is changed, we're using animateWithDuration again to fade the view back in. You can see that this code for fading the view back in is identical to the code that phased it out. Apart from the alpha value and the completion parameter. The syntax around this completion parameter is pretty tricky. So don't worry if it doesn't make sense right now. We'll talk more about completion blocks in the next lesson on closures. I want to focus on another problem with this code. Soon I'll have another view that I'd like to fade out and fade back in. And I know I'd have to rewrite this code. That goes against my dry programming principles. But if I put this code in an extension, I can reuse it. So let's do that, since I can't add an extension directly to the UIView Swift file, I'll make a new Swift file and call it UIViewExtensions. To add a file to the project, I just Ctrl+click on one of these folders, over here in the project navigator, and then I go to New File. Then I want a Swift file. And again, I'm going to call it UIViewExtensions. Here we are in the UIViewExtensions.swift file. And the first thing you'll need to do is import UIKit. To define an extension, you just write the word extension followed by the name of the type you're extending. And in between curly braces, the methods you'd like to add. The methods we'd like to add are called fadeOut and fadeIn. Here in the fadeOut method, we just want to copy and paste some of the code from that sunrise and set method. So to do that we go back to our ViewController.swift file. And then, we want to copy this fade out code, this animateWithDuration code, up to but not including the completion block. Once you've got animateWithDuration pasted in, there are a couple snippets of code we need to edit. Here where it says self.imageView.alpha, we want to replace that with self.alpha. Because the object that's calling this code, self is the object whose alpha needs to change. Next, we need to make sure we're passing in the necessary parameters. So we'll pass the parameters duration delay, and the completion closure into the fade out method. And then, we'll pass those parameters again to the animate with duration method. So here, instead of one second we'll put duration. Here, instead of a delay of zero seconds we'll put delay. And then, under completion, we'll put completion. Notice that the animation option, CurveEaseIn is the same every time fade out is called. And so, is the animation changing the alpha to zero. Next we're going to apply similar edits to the code that animates the views alpha to one. First, go into the ViewController.swift file and copy this fade in code. Next, go back to the UIViewExtensions file and paste that code into the fade in function. Now, just like before we'll replace imageview.alpha with self.alpha. Whatever view is calling this method is represented by self. And that is the object we want to fade in. The next step is the same as well. We need to pass in the parameters for duration, delay, and completion. And then we pass each of those three parameters to the animate with duration method. Last but not least, we need to alter the code in our view controller to make it simpler. Now that we have access to the fade out and fade in methods from this extension. So go back to the viewcontroller.swift file. And we're going to delete this call to animate with duration. Everything up to the completion block. Let's keep that. Instead of calling animate with duration, we're just going to call fade out. We'll call it on the property image view. The fade out method takes in three parameters. Duration, let's do one second for that. Delay, we don't want to delay, so we'll put zero seconds. And then the mysterious completion closure, which we kept there from last time. The first part of the completion closure can stay in its original form. But after the image is swapped, we want to use the method fade in. Like we did above with fade out, we'll delete this animateWithDuration code. Just go ahead and delete the whole thing. And in its place we'll put a call to self.imageView.fadeIn. Again we'll put a duration of one second with no delay. Before we put in the completion parameter, let's pause for a second and look at the method signature that Xcode's code completion brings up. See how the type of this completion has a question mark at the end? This closure has an optional type, and it's a good thing, too, because in this case, we don't actually want anything in particular to happen when the fade in method is finished. We want to be able to pass in null. And it's fine for the completion closure to be null, because it's an optional type. We want to test this out. But first we should check in our storyboard file to make sure that all of our outlets are connected. So let's take a look at the image view, that one's connected. Let's take a look at the button. That one's connected. We should be good to go. The moment of truth. We'll go up here to Run. Press the play button. Here's our image in the simulator. And then when we press next. The image fades out, and when it fades back in it's change from sunrise to sunset. That does it for protocols and extensions. These skills are really going to come in handy as you get deeper into building apps with UIkit. Next up, our last lesson is all about closures. Closures are serious business, a real challenge for every iOS developer the first time around. So rest up and get ready to learn an entirely new approach to using functions. For the grand finale, we finally come to closures. Closures are similar to blocks in Objective C, or lambdas as in Python, Java and Ruby. Closures, like functions, are self-contained blocks of code. So what's the difference between a closure and a function? Well, global functions and nested functions, which we didn't have a chance to talk about, but if you're curious, follow the link in the instructor's notes. Anyway, global functions and nested functions are closures. But most of the time when a person refers to a closure in Swift, they're referring to a closure expression. In this lesson, we'll be focusing on closure expressions. So what's a closure expression? A closure expression is an unnamed self-contained block of code that can be passed as an argument to a function. Closure expressions are unique in that they're unnamed. Okay, but what are closure expressions good for? Well, this ability to pass a block of code to a function makes it easy to specify an action to be executed sometime in the future. Let's look at a couple examples. The Swift standard library has a function called sort, which is a part of the sequence type protocol. This function can be called by any type that conforms to the sequence type protocol, often an array or a dictionary. The sort function takes one argument, a closure expression indicating how the items in a collection should be sorted. In the end, the function returns a sorted array. For example, let's imagine we're at a silent auction and we have an array of bids that we'd like to sort from lowest to highest. Here's our array of bids along with an array for the return value called orderedBids. The bids array will call the sort method, and that's where the closure expression comes in. Closure expressions typically take the form in between curly braces, first you'll see the parameters being passed in, followed by an arrow pointing to the return type, similar to what you'd see in a function signature. Then the return type is followed by the word, in, and then the statements to be executed. Back up here in the closure we're passing into the sort function, notice that there's no name. We skip straight to the curly braces. In between curly braces, first we write the parameters being passed in, which are Ints. We're passing in two Ints from the array each time. Sort always takes two parameters that match the type of the array calling the function. After the parameters we see an arrow pointing to the return type. The return type here is a bool indicating whether bid1 should be placed before bid2 or not. Next comes the word, in, signaling the beginning of the executable statements. And then the executable statement in this case is very short. It's just bid2 > bid1. If bid2 is greater than bid1, then bid1 should go first in the sorted array. If we print out the results, the orderedBids array, we can see that the bids are in order from lowest to highest. Let's alter the example just a bit and say that the auction goers put in more exact bids. They put in their bids in as doubles. How would our closure expression change? In this case, since the parameters are now doubles, we'll need to change the parameter types of bid1 and bid2. But notice that the return type and the sorting statement both remain the same. Let's do one more example for good measure. Let's say we're sorting an array of birthYears and we want to put the years in reverse chronological order. What should our closure expression look like? What should we place between curly braces here? Like before, we're sorting an array of Ints, which means that the two parameters passed into the closure expression will also be Ints. Let's call those parameters year1 and year2. Next comes an arrow pointing to the return type. And remember that sort always takes a closure with the same return type, and that return type is a bool. Next comes the word, in, to signal the beginning of the closure's executable statements. And since we want the birth years in or verse chronological order that means the bool should return true if year1 is greater than year2. And over here in the sidebar, we can see our sorted array. Even though in this case the array is sorted essentially instantaneously, you can see that the closure represents a passing of the flow of control. It's as if we're saying, here, sort, take this chunk of code and use it when you need it. When you start building more complicated user interactions, you'll come to rely on animate with duration, a method used to specify the timing of a change in the appearance of a view. Animate with duration belongs to the class UI view. UI kits generic view class. You saw this method earlier when we discussed extensions. As promised, I want to return to the fate extension demo Xcode project, and dissect the closure expression syntax. Open the View Controller.swift file and take a look at the sunrise and set method. Focus on the completion parameter. Do you recognize the closure expression syntax? Here you can see that the method fadeout takes in a closure expression as a parameter, the parameter named completion. And that closure expression takes in a bool as a parameter, and returns void or nothing. The word, in, lets us know that the body of the closure is coming up. In the body of the closure we find the code that is intended to be executed after the animation is complete. That's why this closure expression is called completion. The body of the closure says. If the image is set to sunset, change it to sunrise. If the image is set to sunrise, change to sunset. This call to fade in is also part of the completion closure. So what's going on here with the completion parameter for fade in? You might think we'd see another closure expression here, but all we see is nil. That nil is standing in for the closure expression. It's saying, this is what I want to happen after the image fades in. I want nothing to happen. Now let's switch over to the UI view extensions file for a second. I know I already pointed this out, but I want to reiterate that this completion parameter actually has an optional type. You can see the type of the closure expression here. As we just saw, it takes in a bool and returns void, but then notice this question mark. That question mark makes it possible to pass in nil as the completion parameter. So far you've seen several examples of closure expressions being passed as arguments to functions. Just like any other variable that's passed as an argument to a function, a closure expression has a type. This closure expression we pass to the sort function had this type. You can see it takes in two Ints and returns a Bool. This other closure expression we pass to the sort function had this type. You can see it takes in two doubles and also returns a bool. Here's another example. Here, we have an array of soup names, and we want to put them in alphabetical order. The code to do that looks like this. What is the type of the closure expression being passed into the sorted function? Indicate your choice in the text box. This closure expression takes in two strings as parameters and returns a Bool. So, b was the correct choice. Here's another one. You know this code well. What is the type of the completion closure being passed into the fade out function? Indicate your choice in the text box. This closure expression takes in a pool and returns void, so C was the correct choice. There are several syntactical tricks available to make closure expressions super concise. In fact, this is one of the coolest aspects of closure expressions in Swift and at times, one of the most confounding. I want to walk you through some of these tricks using the filter method from the array class. The filter method is called by an instance of the array class. As an argument, It takes in a condition and returns an array that's been filtered based on that condition. The condition is passed in as a closure. Here i have an array of exam grades. I'm going to filter this array for all the grades above 70. We'll call those grades, passing grades. So I call the filter method with the object, exam grades and I pass in a closure representing the filter condition. The closure takes in a grade and it and returns a bull representing whether the condition is true. At this point, this looks a lot like the syntax we saw for sorted. Here's the first trick. The compiler can infer a closure expression types based on what parameter type a given function expects. In this case, the compiler can infer that the closure expression for filter will take in a parameter that matches the type of the array being filtered. And the compiler can also infer that this closure will return a bull. That means we can leave out the words int and bull and still get the same result. Here in the sidebar you can see what the result is if we filter for failing grades. On to the next trick. If a closure is a single expression like this one. It can be inferred that the result of that expression should be returned. So we can remove the word return, again in the sidebar, you can see that our filter still works. And now for the trick that's been known to make some code readers head spin. Shorthand argument names. Swift provides default argument names for closure expressions. So instead of specifying a first argument, the first argument is known as $0. The second argument is known as $1 and so on. So here, for example, the compiler can infer that this closure expression takes one argument and that its type, int, matches the type of the elements in the array. So we don't have to give it a name, grade. We just use the default name for the first argument, $0. And since we're not giving grade a name anymore we can omit the word grade along with the word in. Let's see all those short cuts again one more time. We'll go back to the alphabetical soup example from your quiz. The closure expression parameter and return types can be inferred. So we can take out String, String and Bool. Since this is a single expression closure. It can be inferred that it returns the result of that single expression. So we can also leave out return. We can use the shorthand argument names for soup one and soup two. And we're left with a statement that truly is amazingly concise. That's all I have for closures, and we've come to the end of the course. You have a solid start now on Swift, and the tools you need to make your dream app. So, go build stuff, make animations, filter arrays, and don't forget to finish your exercises. I can't wait to see the apps you'll make with your newfound understanding of Swift syntax.