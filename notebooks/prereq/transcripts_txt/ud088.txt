Hi, my name is Lorenzo, and I'll be your instructor as we explore the foundations of full stack web development. In this course you will learn to build your own data-driven web application, but what does that actually mean? Well, when I say web application I'm referring to a web page or collection of pages that allows your browser to respond to user input, similar to an offline software application. And by data-driven, I mean an application that can store and retrieve information from a database to deliver customized content to the user. Almost all of the popular websites you interact with on a daily basis are data-driven web applications. Soon you will create a similar website of your own. In addition to creating web pages, you will also learn to send data from your server in other forms, like JSON requests. So that the data from your application can be shared with other machines that process JSON, like a data aggregator or a mobile device. Your mission in this course is to help me create a menu app. You'll be building an interactive web application that presents a user a variety of menu items they can view, create, modify, and delete. In the first lesson of this course you will extract data from a database using Python. We'll also be using a tool called an object-relational mapping, or ORM to manipulate queries as objects in Python. If you've never heard of an ORM, don't worry. You'll be very familiar with it in just a few minutes. In the second lesson you will build your first data-driven web application using only the libraries that come installed with Python. In the third lesson we will talk about frameworks and create an application using the lightweight web framework, Flask. You will understand how frameworks help developers write code more efficiently. Once you complete this course you will easily be able to compare and contrast frameworks, and choose one of your own for future projects. Finally, you'll use what you learned from lessons one, two, and three to iteratively write code until you have a polished menu application, complete with API endpoints for JSON requests. Let's get started. Before we get started, let's discuss some of the necessary technologies you should be familiar with in order to get the most out of this course. Most importantly, you should have a basic understanding of Python coding. If you're comfortable creating classes, writing methods, and understand inheritance, you are in good shape for this course. Knowledge of SQL statements such as insert into, select, update, and delete will also be a useful skill in this course. I will also assume you're very comfortable reading and writing HTML code. CSS and JavaScript won't be necessary to complete the activities, but are helpful for creating a polished, presentable final project. Knowing your way around the Unix command line and being able to navigate through the file system is also going to come in handy. If you are unfamiliar or would like to brush up on any of these topics, please refer to the instructor notes for some helpful links to classes and other references. For ease of configuration, and installation, I strongly recommend using a Vagrant machine for this course. Vagrant allows you to create a virtual machine on your computer so that you can program without worrying about affecting your computer's current configuration. I have provided you a Vagrant file with all of the necessary software already installed. A link to installing this Vagrant file is provided in the instructor notes. Once you successfully run vagrant up and vagrant ssh, you're ready to keep going. Let's create a web application that allows us to create multiple restaurant menus without having to change the source code. We want to be able to create menu items, read the items we've created, update our menu items, and delete items from time to time. Hm, sounds like we need to make some CRUD. What's so special about CRUD, you ask? Well, this four letter acronym encapsulates all of the actions a user does on a data-driven website. Each time we make a new profile, post a new status, write a new blog entry, upload a new pic, or add a new item to a menu, we are creating new data to be stored in our database. Whenever we look through a friend's latest tweets and pics, or skim through our news feed, we are reading data that was already stored in an application's database. When we correct the typo on a blog post we already made, modify the item quantity in our shopping cart, or change our profile information, we are performing an update on existing information in the database. And when it's time to erase that embarrassing baby pic from our profile or get rid of those items in our shopping cart, we're deleting information in the database. Virtually everything we do on the web can be summarized with one little acronym, CRUD. I want you to take a look at a few common website actions and then decide what the CRUD is going on. Okay, let's do a few exercises just for fun. Would the following actions from a user cause a create, read, update or delete on a database? Select your answer below and continue to the next video to see my solution. Browsing articles on an online newspaper. Well, since with an online newspaper, we're only viewing things that are already existing on the server, so this is definitely a read. Is clearing out your junk mail a create, read, update, or delete on a database? Clearing out your junk mail probably involves erasing something off of a server. So let's just say that's a delete. What about making a new profile on a blog? Is this a create, read, update, or delete? Making a new profile means we're putting new information on to our server. That means we have to do a create. Let's say a user orders a t-shirt online, and later on decided that they actually want to order two more for two of their friends. Before checking out, they update their shopping cart from one t-shirt to three. Would this be a create, read, update, or delete? By changing the number of items in the shopping cart, we're creating an update on the database. The shopping cart already existed, and so did the item that was inside it. We're only changing the quantity of items that we wanted to order. So we know that web application code gets the information that it needs to create websites by performing CRUD operations on the database. But how do we get an application and a database to communicate with each other? You already know that SQL is the popular language for communicating with databases. >From our application code, we can create SQL commands and decipher the results to integrate back into our application. With SQL, we're seeing almost one-to-one comparison between CRUD and a few SQL commands. In these next four challenges, match up the SQL command displayed with the CRUD operation that it executes. The SELECT command retrieves rows from our database and presents them to our application. So this is definitely a read. Insert Into adds a new row to our table, so this is a create. The Update command updates an existing row in our table, so these two words actually match up. The Delete command in SQL deletes a row from our table, so it also executes a CRUD delete. So for this menu project, I want to create an application where I can make various restaurant menus with various items, often within one application. All restaurant menus in the general sense contain the same thing. Some have a few appetizers, some entrees, a few desserts, and of course some beverages. To keep things simple, let's call all of these things menu items. And all of my menu items belong to a specific restaurant menu. It also would be helpful to have a price and brief description for each of our menu items. An important early design decision to make is how to model my database. There is more than one correct way to structure a database, but there is no need to make things too complicated. Let's walk through the process of making a database layout together. We have a restaurant table to represent all of the restaurants in our database, along with a corresponding name and ID number. Then we have a table of menu items. Each menu item will have a name, an ID, a description, a price, and a course to categorize whether it is an appetizer, entree, dessert or beverage. We will also provide a restaurant ID to assign a foreign key relationship with our restaurant table. Okay. So we've planned out how we will design our database. Now let's get to coding it up. If you've used SQL before you might be used to writing something like this. If you're not an SQL expert it might be a little hard to understand though. Now there is nothing wrong with this code, but let's take a look at it for a second. Using raw SQL we have this inquiries to the database as strings. This works, but our Python compiler has no way of helping me if I make a typo or reference a table that doesn't exist. Every other data structure we use in Python is some type of object. So why not treat our database queries, tables, and rows as objects as well. Well this concern isn't a unique one, and developers have created tools for this very problem. Object-Relational Mappers, or ORM's, can be thought of like a translator. Converting our code from one form to another. If we send off code written in Python or any other preferred programming language, it is transformed by the ORM into SQL and sent off to our database. The ORM also gets results from an SQL statement and allows us to use it as an object from within our Python code. When I Google search ORM for Python I get over 14 million results with several different ORM options we could use. The first result that showed up when I searched was for an application called SQL Alchemy. SQL Alchemy is an open source ORM for Python with a slew of features. Not to mention this awesome Getting Started tutorial. There's a lot of information on this page. But let's just focus on setting up our database and tables for now. If you're using the Vagrantfile, SQLAlchemy is already installed on your virtual machine. If you are not using Vagrant, you can install SQLAlchemy from the link below to follow along. With SQLAlchemy, we can write a single Python file to set up and configure our database. I will call this file database_setup.py. Creating a database with SQLAlchemy has four major coding components. The configuration code, which is what we use to import all the necessary modules. The class code that we use to represent our data in Python. The table that represents the specific table in our database. And the mapper that connects the columns of our table to the class that represents it. Our configuration code sets up all of the dependencies needed for my database and binds my code to the SQLAlchemy engine. For most cases, this code doesn't change much from project to project. We also have to create an instance of a class called declarative base, in order for our class to inherit all the features of SQLAlchemy. In addition, we need to add some configuration code at the end of our Python file to connect to an existing database. Or in this case, create a new one. This might not make much sense right now, so let's jump into writing the configuration code. Open a text editor like Sublime and follow along. You may have seen this import if you've worked on a few Python projects before. The sys module provides a number of functions and variables that can be used to manipulate different parts of the Python run-time environment. Next, we're going to import the column. ForeignKey, Integer, and String classes from SQLAlchemy. These will come in handy when we are writing our mapper code. >From the sqlalchemy.ext.declarative library, we need to import our declarative_base, which we will use in the configuration and class code. After that, we import relationship from sqalchemy.orm in order to create our foreign key relationships. This, too, will be used when we write up our mapper. Let's also import the create_engine class, which we will use in our configuration code at the end of the file. This last piece of code isn't an import, but will help us get set up when we begin to write our class code. Let's make an instance of the declarative_base class we just imported and call it Base, for short. The declarative_base will let SQLAlchemy know that our classes are special SQLAlchemy classes that correspond to tables in our database. At the end of our file, we need to add two more lines of code. We create an instance of our create_engine class and point to the database we will use. Since we are using SQLite 3 for this lesson, the create_engine will create a new file that we can use similarly to a more robust database like MySQL or The last piece we need is Base.metadata.create_all(engine), which goes into the database and adds the classes we will soon create as new tables in our database. Our class code is the object-oriented representation of a table in our database. The only thing we need to do is create a class name, and make it extend from the Base class we just created. For conventional purposes, let's make all of our classes start with a capital letter with no spaces in between, also called camo casing. Inside of this class declaration, we will add all of the code for our table and mapper code. For this project, we will need to create two classes to correspond with the two tables we want to create in our database, restaurant and menu item. Be sure to write this class code between your beginning and ending configuration code. Inside each of our classes, we must create a table representation, we use the special variable, double underscore table name double underscore. To let SQLAlchemy know the variable that we will use to refer to our table. For conventional purposes, let's make our table names lowercase, with underscores for spaces. Inside our restaurant class, we will set double underscore tablename double underscore equal to restaurant, and inside the MenuItem class we will set it equal to menu underscore item, as seen here. Our mapper code creates variables that we will use to create columns within our database. When we create a column, we must also pass an attribute to that column. Here are some column attributes that we will be using in the activities in lesson one. We can specify a string, with a specified maximum string length and we can specify integers which are handy for storing whole number values. Relationships tell SQLAlchemy the type of relationship one table has to another. Nullable is an attribute that if set to false indicates that a column entry must have a value in order for the row to be created. Setting primary key to true indicates a value that we can use to uniquely identify each row of our database table. And foreign key we can use to reference a row in a different table provided that a relation exists between the two of them. Inside each restaurant class, for now we're just going to specify a name and an ID number to reference each restaurant. We create a variable and name it name, specify it as a column, say that this column has a string with a maximum length of 80 characters, and set nullable equal to false. Indicating that if name is not filled out we can not create a new restaurant row in this database. Similarly, we'll create a variable called id, which we'll also specify as a column. But this time we'll say it's an integer instead of a string, and set primary key to true. Our menu items are going to have a little bit more information. Just like each restaurant, each menu item needs to have a name. We'll set nullable equal to false again, to make sure that no one can create a menu item without a name. We'll create an id for each menu item which is set to the primary key. We'll create course, description and price variables and specify them all as strings. I'm now going to create a variable called restaurant_ID and specify this as a foreign key integer. This will create the foreign key relationship between my menu item class and my restaurant class. Inside the foreign key I specify restaurant.id. This will say look inside the restaurant table and retrieve the ID number whenever I ask for restaurant_id. In this last line I'm creating a variable called lowercase restaurant which I'm saying is the relationship between my class restaurant. So we've gone through a fair amount of code. Let's go ahead, and put it all together in our database_setup.py file. Let me start with this configuration code that goes at the beginning of our file, and put it where it belongs. I can also take this code at the end, and put it at the end of the file. Next, let's put our two class definitions, right where they belong. Next, we need to add our table information. And finally, our mappers. Putting all this code together, should give us a Python file that looks something like this. So, if we navigate to the directory, where our database_setup.py file live, and run it using the Python command, we should get something like this. Looking in the same folder, where we have our code, we see a newrestaurantmenu.db file. This is our empty database. Now that we have an empty database, let's figure out how to populate it with some information. In the quiz portions of this lesson, we're going to create another database that stores employees and their addresses. Using the provided code, and this diagram, fill in the blank with the class that will make an object with this base variable. So we write declarative base here, in order to create a base class that our class code will inherit. Now fill in the blanks in our mapper code. We specified id as an integer. So, in our mapper we should also specify the same thing. So, we have this ForeignKey relationship between our address and our employee. So here, in this lower case employee variable, we set its relationship to the actual employee class we created. Now that we have an empty database, let's populate it with some information. With SQL, we would need to execute an insert command with all of the information we want it to populate into our database. Using SQLAlchemy, creating a new database is as easy as creating a new object in Python. I will be executing these operations from the Python show, but they could also be done from within a Python script. We must first import the following dependencies from SQLAlchemy, and the empty database we created, into our environment. We will see what they do in just a second. >From our database_setup.py file that we created, let's import our base restaurant, and menu classes. The create_engine function lets our program know which database engine we want to communicate with. Then let's bind the engine to the base class with the following command. This command just makes the connections between our class definitions and the corresponding tables within our database. The next thing I'm going to do is create a sessionmaker object. This establishes a link of communication between our code executions and the engine we just created. In order to create, read, update or delete information on our database, SQLAlchemy executes database operations via an interface. It's called a session. A session allows us to write down all the commands we want to execute, but not send them to the database until we call a commit. Here, I'll show you what I mean. I'm going to create an instance of a DBSession and call it session for short. >From now on, when I want to make a change to my database, I can do it just by calling a method from within session. The DBSession object gives me a staging zone for all of the objects loaded into a database session object. Any change made to the objects in the session won't be persisted into the database until I call session.commit. Now as I promised, making a new entry in our database is as easy as making a new object in Python. Take a look at these three lines of example code and watch as I implement them to create a new restaurant in my database. Following this example, I'll make my first restaurant like so. As you can see, it's just an instance of my restaurant class with a name attribute that I decided to give it, Pizza Palace. To persist my new restaurant into the database, I must do two more session operations. First by calling session.add my first restaurant, my restaurant object is in the staging zone to be added to the database. Then with session.commit it's now stored to my database. But how do I know it worked? Well, I can also use the session to interact with my database and see what's inside of it. If I execute session.query(Restaurant).all, I'm asking my session to go into the database, find the table that corresponds to the restaurant class and find all the entires in that table and return them in a list. When I run this, I get a response with something like, database_setup.Restaurant object at and some hexadecimal number. This just lets us know that Python found a restaurant in our database and represents it as an object at this location in memory. I'm sure you're thinking, well that's great but how's it useful to me? We'll go into more detail about the query method when we focus on reading data out of our database. So now, let's add a MenuItem to our Pizza Palace menu. Since our MenuItems all belong to a Restaurant, and have a few more attributes, we have to provide a bit more information in our declaration. I can create a Cheese Pizza by executing the following command. Notice that I provided all of the fields of information for a MenuItem here and specify the foreign key relationship to the object name of my restaurant. In order for this operation to work, I didn't have to fill out every entry unless I specified it as nullable equal to false in our database_setup.py file. Now let's run session.query MenuItem .all to see that an object now exists for our cheese pizza item, as well. Now that you know how to add data to a database, it's your turn to get some practice at it. In the last quiz, you created an empty database. Let's add our first employee to it. Fill in the blanks below to add a new employee named Rebecca Allen to the database. Then fill in the blank here to add Rebecca's address as well. So in order to create the new entry in our database, we have to specify the name variable as Rebecca Allen. We also need to create the ForeignKey relationship between Rebecca's address and the new employee variable that we created in the previous line. Now that we have a database that's not empty, let's start reading from it. In the last video, you saw me call session.query(Restaurant).all. If I create a variable called firstResult and set it equal to session.query(Restaurant) and use .first this time, I now have a variable that corresponds to a single row in my database. These single row references allow me to extract column entries as method names. So if I were to write firstResult.name, I'm given the name of my restaurant object as it is stored in the database. Currently, I only have one restaurant and one menu item stored in my database. Well that's kind of boring, but with the help from some fellow Udations I've created a Python script that will populate my database with several different restaurants and menu items popular amongst the Udasity team. Download the lotsofmenus.py script into your working directory and execute it from the command line as so. Now when we perform executions like session.query(Restaurant).all, we get back a whole list of results. So what happens when I have a query that returns a collection of results and we want to display column information for each item? For this, we can use a python for loop to return the data that we want to see. Here, let's do an example. I will make a variable called items and set it equal to a query that retrieves all of my menu items. Now, I can say for item in items, print item.name. Now I get back a printed line of each item name in our database. SQL Alchemy has an extensive collection of queries we can perform on our database. Take some time to explore the query documentation here and play around with the database for a while. When you're ready, move on to some of the challenge problems in the next section. Going back to our employee example, fill in the blanks to make a variable called employees, which stores all the employees in our database. And then, iterate over this collection to print the name of every employee. Whenever we want to find some information in our database using SQLAlchemy, we use the query command followed by the name of the table that we want to search through. Using this enhanced for loop, we declared employee as the variable that we're going to iterate through. So, printing employee.name will print out the name of every employee in our database. So, we know how to create and read from our database entries, but how do we update existing data within our database? It seems we have a situation on our hands that calls for this. Veggie burgers across town have been all the rage, causing rapid price competition amongst our restaurants. Urban Burger wants to cut the price of their veggie burger to $2.99. With SQLAlchemy, performing an update like this is a pretty simple, four-step process. First, we execute a query to find the veggie burger we want and store it in a variable. Second, we declare the new price of the variable. Next, we add the variable to our session. And, finally, we commit the session to the database. Follow along as I do this from the Python shell. So, the first step in our update process is to find the exact item we want to update. Looking at the SQLAlchemy documentation for queries, I see we have a filter_by feature that lets us filter queries based on attribute entries, like name. Let's go to our Python shell and give it a try. So, let's use the filter_by function to find all the veggie burgers in our restaurant menu database. Following the syntax from the documentation, I append .filter_by to my query on MenuItems and set the Veggie Burger as the name of the menu item I want to search for. Then, I store it in the variable named veggieBurgers. The filter_by function always returns a collection of objects. So, let's create a for loop to iterate over each object and retrieve the information about each of these veggie burgers. Inside our for loop, let's print out the ID of each veggie burger, its current price, and the restaurant it belongs to. I'm also going to print a new line character to make our results a little bit easier to read. When I close my for loop in execute, I get back a list of all the veggie burgers in my database. The first one here is from Urban Burger and has an ID of eight. Now, I will create another query where I only return the menu item with an ID of eight. I will store it as UrbanVeggieBurger. If I append the .one function to the end of my query, I make sure SQLalchemy only gives me the one object I want, instead of a list that I would have it iterate over. Just to double check we have the right burger, let me go ahead and check its price. Yep, the veggie burger costs $5.99, just like it did in our first query. Now, let's reset the price of the Urban Veggie Burger to $2.99. We can then add the UrbanVeggieBurger object to our session and commit it to the database. So now, if we execute the same original query to see all the veggie burgers in our database, we see that Urban Burger's veggie burger now has a price of $2.99. Now, let's assume all the other restaurants have reacted to Urban Burger's audacious price drop and want to set their burger prices to $2.99 as well. Let's use our same for loop and modify it a bit to change the price of all the veggie burgers in our database to $2.99. I'm going to use this if statement to avoid unnecessary database updates to an entry that already has a price of $2.99, and just update the other veggie burger menu items. Now, querying a third time, I see all the veggie burgers in our menu have the same price. Let's get a little more practice with updates by answering the following quiz questions. Rebecca just moved to a new house so let's update her address in the database. Here, we find Rebecca in the employee database, assuming she's the only Rebecca Allen in our employee table. Next, we find her address by matching rebecca.id to the employee id in the address database. Then, we set the street property of her address to 281 Summer Circle. We also update her zipcode to 00189. Now, what do we add to our session before we commit so that this update takes place? The variable we used to refer to Rebecca's address we titled RebeccasAddress with a capital R and capital A. So this is the same variable that we used to update the address here and the ZIP code here. So that's what we need to add to the session and then commit. Most of the times, having data in our database is a good idea. But sometimes, we make a few bad ideas that we may want to delete, later. Auntie Anne's Diner just realized, that their spinach ice cream wasn't a hit, and wants to remove it from their menu. Deleting an item is a three step process similar to updating. First, we want to execute the query to find the spinach ice cream, and store it in a variable. Then we want to call session delete on that item. And finally, we'll commit the session. Let's go back to the Python shell, and walk through this together. Let's assume, Auntie Anne's was the only restaurant with spinach ice cream, and use the .dot one function, to grab this entry in the database. To double check, I will print out the name of the restaurant, this menu item belongs to. And see that it is indeed, Auntie Ann's creation. We will call session.delete to stage this item for removal from the database, and then call session.commit to persist this change. If we search for spinach now, the sqlalchemy gives us, a no row was found error, letting us know that this data is no longer in our database. After 35 years with the company, Mark has retired and is to be removed from the employee database. Fill in the blank here with the necessary code to remove Mark from our employee database. In order to remove an item from our database, we must call session.delete on that item. Calling session.delete(mark) will remove him from the employee database as soon as we execute session.commit. Congratulations, you have reached the end of lesson one. You've learned how to use an ORM to create a database, and execute cred operations on it, setting the foundation for your interactive menu application. Next, in lesson two, you'll build a web server that will be able to perform these cred operations based on requests from the user. Now that we have a working database, let's create our first web server in Python. Once our web server is up and running, let's use the CRUD commands from lesson one to access, our data from a Web page. There will be some opportunities in this lesson for you to try coding a few things on your own. Set aside, some extra time to work through these challenges. But before we get started coding, let's review some of the basics of client/server communications across the Internet. Clients and servers can be most simply understood as computers communicating across the Internet. We define the client as the computer that wants information, and the server as the computer that has information that can be shared with clients. This means that a client has to initiate communication to request information, while the server constantly stays listening for any clients to communicate with it, and responds with the data that the client requested. Let's briefly discuss some of the important concepts in order to better understand how this actually happens. So we know that clients and servers can communicate with each other, but how do we know that they're all speaking the same language? Well, protocols are like the grammatical rules that we use to make sure all machines on the Internet are communicating in the same way. There are several protocols that computers on the Internet adhere to. The most common three are the Transmission Protocol, or TCP, the Internet Protocol, IP, and the HyperText Transfer Protocol or HTTP. The Transmission Control Protocol or TCP enables information to be broken into small packets and sent between clients and servers. If a packet is lost somewhere along the way the sender and receiver have a way of figuring out which of the packets is missing and request that they be resent. The counterpart to TCP is UDP, User Datagram Protocol, which is good for streaming content like music or video. Similar to postal addresses, IP addresses allow messages to be properly routed to all participants on the Internet. For simplicity's sake, we can assume that every device on the Internet gets an IP address that is either statically or dynamically assigned by the Internet service provider. Here's the IP address of my laptop, and here is the IP address for Google. When I type google.com into my browser, my computer first figures out the IP address of Google by looking it up in a Domain Name Server, or DNS. Think of DNS as a big online phonebook that finds theIP address of web URLs. Once DNS gives my computer the IP address, it uses that address to initiate communication with the server for Google. Since multiple applications using the Internet can run on one machine, operating systems use ports to designate channels of communication on the same IP address. Placing a colon after an IP address, with another number indicates that we want to communicate on a specific port on the device using that IP address. On most machines, port numbers can range from 0 to 65,536. The first 10,000 ports are often times reserved by the operating system for a specific use. Port 80 is the most common port for web servers. So most websites we use every day are hitting port 80 when they reach a server. 8080 is also a common port for web communications. When client and server applications are on the same machine we indicate this with the term localhost. Localhost also has a special IP address of 127.0.0.1. Whenever we type localhost, or this special IP address into a browser or web application, the operating system knows to look for this resource locally and not go out to the Internet. The main concept of HTTP is that clients tell servers what they want by using an HTTP verb, also know as an HTTP method. There are nine HTTP verbs in the current HTTP specification. The two most commonly used methods for websites though, are GET and POST. A GET request can be thought of as the client telling the server, get me some information that you have. Or, a POST can be thought of as the client saying, I want to modify some information that you have. GETs are sometimes called safe methods, since they are only used to retrieve existing data from the database, whereas POSTs call for data to be added, removed, or changed on a server. We know that the client prefixes requests to the server with HTTP verbs. So, how does the server reply? Status codes are the server's reply to a client as to what happened after a specific request. In addition to a status code, a server can also supply any requested resources the client requested, such as HTML, CSS and JavaScript, and media files such as images and audio. Some common response codes are 200, which indicates a successful GET request, 301, which is a successful post request, and 404, which indicates that we were looking for a file on the server, and the server couldn't find it. In the next section, we'll put all of these concepts together as we create our own web server in Python. In the previous video, I introduced a lot of new concepts that may or may not be familiar to you. To see all of these concepts in action, in this section we're going to build our own web server in Python that not only renders web pages in a browser, but by processing data submitted by the user, can create a unique web page each time a user modifies the input. To get started let's create a new Python file called webserver.py and save it in the same directory as your restaurantmenu.db. And databasesetup.py files so we can access it from our vagrant machine. Follow along with me using Sublime or your favorite text editor. One of the cool things about Python is that it comes with a large collection of libraries we can use right out of the box. We will be using the HTTP base server library extensively to create this project. Take a minute to skim over the HTTP base server documentation on the official Python documentation website. I will add from BaseHTTPServer import BaseHTTPRequestHandler and HTTPServer to the first line of my webserver.py file to be able to take advantage of this BaseHTTPServer functionality. Our web server code will have two main sections, the main method and the handler class. In main we instantiate our server and specify what port it will listen on. Our handler code indicates what code to execute based on the type of HTTP request that is sent to the server. I will start by coding a main method as the entry point of my code. I'll add this block of code at the end of my file to immediately run the main method when the Python interpreter executes my script. Inside this main method, I will add a try except block. The Python interpreter will try to attempt the code inside the try block. And if a defined event occurs, we can exit out of the code with an exception. The exception I want to handle is KeyboardInterrupt. This is a built-in exception in Python that can be triggered when the user holds Ctrl+C on the keyboard. Going back inside my try block, I will create an instance of an HTTP server class. Looking at the documentation for HTTPServer, I see that I can create a web server like so. In the documentation we also see that HTTPServer is built off of a TCPServer class, indicating the transmission protocol that this server will use. Server address is a tuple that contains the host and port number for our server. I will leave host as an empty string and specify our port number with an integer. I will define port in a separate variable, and create my server instance as so. Notice that I just made up a name, webserverHandler, for the request handler class. I will define my webserverHandler in the next section of code. But first, let me add some finishing code to the main method. After I create the server I'll add a print statement to know that my server is running. Then I will use this serve_forever function built into my HTTPServer to keep it constantly listening until I call Ctrl+C or exit the application. Inside my KeyboardInterrupt exception I will shut down the server by calling server.socket.close. And I have another print statement, just letting me know that the server was properly stopped. Above my main method, I will now define the webserverHandler class that I called in my HTTPServer, and have it extend from a class called BaseHTTPRequestHandler. The do_GET function handles all get requests our web server receives. In order to figure out which resource we are trying to access, we will use a simple pattern matching plan that only looks for the ending of our URL path. Let's create another try except block for our do_GET method. The BaseHTTPRequestHandler provides us a variable called path that contains the URL sent by the client to the server as a string. I will make an if statement that looks for the URL that ends with /hello. I will tell my web server to send a response code of 200 indicating a successful get request. I will use the send_header function to indicate that I'm replying with text in the form of HTML to my client along with this end_headers command which just sends a blank line indicating the end of our HTTP headers in the response. Now that I've created the response I can include some content to send back to the client. I'll create an empty string for now and name it output. In the next line I will add a message with some HTML and body tags to my output stream. I can use the self.wfile.write function to send a message back to the client. So I'll go ahead and put my output string there. I'm going to add a print statement for now, just so I can see my output string in the terminal. This might come in handy for debugging. Then I can exit my if statement with the return command. I will also write an exception for IOErrors, and use the following line of code to notify me of a 404 or file not found error. Now, I think I'm ready to test and see what I've written thus far in the browser. I will save the webserver.py file, navigate to it from within my Vagrant machine, and execute it writing python webserver.py. The Vagrant environment for this course is already configured to forward port 8080 requests from the host machine to port 8080 on the Vagrant machine. So if we open up a browser and visit the URL localhost8080/hello look, our server recognized the GET request and responded with the code that we wrote. >From the Vagrant machine, we can also see the GET request it received from the browser and the code we sent as a reply. Try and create this code on your own. If you run in to any problems, a functioning version of this python code, can be found in the instructor notes. We have a server that can say hello, so now let's add some more functionality to it. Most modern websites have more than just one page, so let's figure out how to add this feature to our web server. In this section we will see that our server can handle different types of GET requests, and respond with different types of messages. Instead of replying with hello, let's make a page that also replies in Spanish when we visit the hola URL. I'm going to copy my if block from before and paste it below. I will change the message that said hello in English, to hola in Spanish, using this special entity code that HTML will render as an upside-down exclamation point. I will also add an anchor tag to link back to my original hello page, just so we can see how that's done here. Now, I'm ready to try and run this and see what happens. I will stop my server with Ctrl+C and start it again to reflect my code changes. Now, I have two URLs I can visit, each rendering a unique page to my browser. Add the hola functionality into the web server. The Python code for this section is also available in the instructor notes. So now that I have a good understanding of do_GET, let's take this web server to the next level with some post functionality. Gets are good for viewing information all ready on the server, but posts are what allow the user to customize their web experience. Get requests happen simply by visiting the URL in a browser, but post requests from a browser require data to be submitted, like with a form. I'm going to add a post method such that our server doesn't just say hello or hola, but whatever the user prompts as a salutation. On the same level as my do_GET method, I will create another method called do_POST, which overrides the method in the base http request handler superclass, just like doGet. I'll make another try except block, similar to my do_GET method. When I receive a post request, I'll send off the response code that indicates a successful post. Next, I need to decipher the message that was sent from the server. In order to do this, I'm going to use some message from the CGI, or common gateway interface, library in Python. So I'll add import cgi to the top of my file. Let's take a look at the following chunk of code I'm going to add. This cgi.parse_header function parses an HTML form header, such as content type, into a main value and dictionary of parameters. After that, we check and see if this is form data being received. I then make a variable called fields, which we use the cgi.parse_multipart to collect all of the fields in a form. Then I will make a variable called messagecontent to get out the value of a specific field or set of fields and store them in an array. I will call this field message here, and when I create my HTML form. So now that I've received a post request, I can decide what to tell the client with the new information I've received. I will create an empty string named output again and then add some opening HTML tags to it. I'll have my server respond with, okay, how about this. And then return the first value of the array that was created when I submitted the form. Hm? Well you might be thinking, hey, you haven't even created an HTML form, but keep talking about it in the post handler. And you'd be right. So I'll go ahead and do that now. In this line of HTML code, I'm adding a post request along with the header tag, to prompt the user to input some data. Here, I wrote the name of my input field as message, to coincide with the message field I'm extracting data from in the post request. I'm going to copy this line of code and paste it into my hello and hola get requests, so this form will be present on their pages as well. I will also separate out my opening and closing HTML tags on their own line of code. Let me not forget to close the body and html tags in my post handler. Send the output out to the server and print out the output for debugging. In my exception block, I will just leave it as pass for now. Let's see these new changes in action from the web browser. I save my code, stop and start my server again, and visit the slash hello page. And look. Now my server responds to my input, so I can make it say hello in any language I'd like. Get this server up and running on your machine. Feel free to use the code in the instructor notes as reference. Great job on creating your hello server. Now that we have a working web server, let's see if we can add some CRUD operations to our site. This will be a fun activity, where you'll finally bring together all of the major aspects you've learned about creating data-driven websites. In this next section, you are going to modify our web server code, such that we can create, read, update, and delete restaurants from our restaurant menu database. I will be adding these features in the next five sections, divided up into objectives. I highly encourage you to read through the objective's descriptions that I'll be presenting in a moment, and attempt to solve them before seeing the solution videos. Up until now, we've been moving pretty quickly. But this is an opportunity to slow down, and get messy, figuring out these challenges. I'll be sharing my answers with you, but through this process you might even create more elegant solutions than my own. Before we get started coding, let me list off the objectives I want to complete for this project. Listing objectives helps me to understand the scope of my project and create identifiable milestones along the way. These objectives should also serve as guidelines you should follow to complete this project. The goal of objective one is to modify the webserver.py file, so that opening local hosts or 8080/restaurants, the user sees a list of all the restaurant names in the database. To complete objective two, after the name of each restaurant, there should be a link to edit and delete each restaurant. These links don't have to work for now. They should just be visible. The third objective goal is to add code such that there is a page to create new restaurants, with a form for writing the new restaurant name. The form should create a post request that creates a new restaurant menu item in the database. To complete objective four, we enhance the web server such that users can rename a restaurant and persist this edit to the database via post. And the last objective creates a feature, such that by clicking Delete, takes the user to a confirmation page. That then sends a post command to the database to delete the selected restaurant. If you don't get it on the first attempt or have to spend some time debugging or looking things up online, that's okay. Even the best of programmers have to debug code. Try to spend about three hours working on each of the objectives before viewing the solutions if you're still relatively new to programming. Don't forget to use your resources like the Python documentation, and tools like the source code inspector in Chrome to help you debug your program, and don't hesitate to ask questions in the forum. I'll be going over the solution to this challenge piece by piece, solving each objective in order, once you're finished with an object, continue to the next video to see my implementation of the solution. I want to provide you some hints as to how to go about restructuring this code. You have already seen all the code necessary to complete this challenge. All of the CRUD operations from lesson one will come in handy here. You will have to import the modules you used to do your CRUD commands in lesson one. Alll of the code for these objectives can be written within your web server.pi file. You'll need to reconstruct your do_GET and do_POST methods, such that they perform the necessary CRUD operations to create the desired functionality. Print statements are simple ways to see if our code is flowing the way we expect. Feel free to use print statements to see what blocks your code is in, and the value of variables, like I did with the output variable that showed our HTML code. Within your browser, you can view source code, as well as inspect DOM elements, to see if you are outputting the HTML you expect to see from your server code. In this next video, I will implement objective one, creating a web page that lists all the restaurants in the database when the user visits localhost port 8080/restaurants. Once you've attempted this challenge, proceed to the solution video. In order to complete this first challenge, I must first import the classes I used to execute my CRUD operations from lesson one. I will import Base, Restaurant, and MenuItem from my database_setup file, as well as create_engine and sessionmaker from my sqlalchemy and sqlalchemy.orm libraries. Along with my imports, I must also add these four lines of code to connect to my database. Once again, just copying code written in Lesson One. Now I will add another if statement to my do_GET method such that landing on /restaurants lists out all of the restaurants in my database. Let's look at this new if statement, where I once looked for /hello or /hola, I'm now looking for the /restaurants path. I then execute a query to get all of the restaurants in the database. My response codes are the same as with my previous do_GET if statements. But here I execute a for loop and that all of the restaurant menu items to my output string separated with brake lines and enclose in my HTML body tags. I write the output to my wfile and send it off to the client. When I save and restart my web server I get an output like this. When I visit local host port 8080/restaurants, it lists out all of the restaurants in my database. Objective one complete. See the instructor notes if you'd like to see my code for objective one. In this next solution video, I will tackle the second challenge by adding a link to edit and delete each restaurant entry. Once you've attempted this objective, proceed to the next video. In order to complete this challenge, I will take advantage of the for loop I've already created. Within it, I will add an anchor tag to edit and delete each restaurant like so. I will leave the hrefs empty with hashtags for now, since I'll be adding the edit and delete functionality in later objectives. I rerun my server again, and get a restaurants page with Edit and Delete options for each restaurant. Objective two is in the bag. The source code for objective two is available in the instructor notes. I will solve objective three in this next video, by creating a webpage when the user visits localhost:/8080/restaurants/new. This page will contain a form that a user can fill out to create a new restaurant. The form will then send a post request to the server, and create a new restaurant entry in the database. Once you've attempted this challenge, proceed to the solution video. Okay. So now let's tackle objective three together. This objective really has three parts. First we need to create a link to make a new restaurant. Then create a page to handle the get request when we click on that link. And finally, a get post method to persist the data to the database. Well the first part doesn't seem too hard. Let's add another anchor tag to our restaurants page that prompts the user to create a new restaurant, followed by a few break lines. We can go ahead and fill out this href to /restaurants/new as stated in the objective. Next, I will create another page to handle this new restaurant request. Inside my do_GET block, I will add another if statement that looks for the /restaurants/new URL. Looking at this code, we can see a lot of similarities with our previous do_GET if statements. I have added here a field where the user can input the name of a new restaurant. So now that the layout is in place, the magic really happens with our post request. Unlike get requests, post requests cannot be executed by simply typing a URL in the browser and hitting enter. However, do_POST is going to look for the /restaurants /newpath, passed along from my forum, in order to know what action to perform. Inside my do_POST, I will comment out the previous code inside the try block for now. I then add an if statement, looking for /restaurants/new. Then I extract the information from the form similarly to the way I did it in the first web server we wrote. But this time I incorporate that data into my declaration of a new restaurant class. Also differently now, instead of printing my results to the current webpage, I create a redirect here that will take me back to my original restaurant's homepage. Let's save and restart our server again. If we can create a new restaurant, and see it added to our page, objective three is over and out. The source code for objective three is available in the instructor notes. The fourth objective is to create a page to edit the name of a specific restaurant. I will do this by passing a URL to my server with the ID number of the specific restaurant, followed by /edit. Once you've attempted this challenge, proceed to the solution video. When we created the main restaurant's page, we executed a query to get all of the restaurants in the database. I will use the ID number of each restaurant entry in order to find a specific restaurant to update. Let's go ahead and replace that hash tag with the ID number and then a slash and the word edit to indicate a new path where we will edit our menu entries. I will now create another if statement that looks for slash edit in the URL. Since i chose to edit restaurants by their ID, I need to find a way to grab that ID number out of the URL. The split command in Python comes in handy here and returns an array of strings separated by a slash. I figured out the third value of this array contains my ID number. So with this two here, I'm grabbing the third element of this zero indexed array. I then do a restaurant query to grab the restaurant entry equal to the ID in the URL. If I find that query then I generate a response and begin to render the page. I create a form with one field for the new restaurant name. Let's create a POST method and pass in the path for the /restaurants/id/edit, passing in the id of the restaurant I want to edit. I also prefilled this field with the current name of the restaurant. I close all my tags, and add this output string to the wfile. Now let's write up the post response for our edit form. Some of this code might be starting to look pretty familiar. After making another if statement, we grab the input from our form again. Then we perform the query to find the object with the matching ID. We reset the name field to the entry we created in the form, then add to the session and commit. I then added a redirect to bring us back to our restaurants page after the code has been executed. This was a lot of code to write, so let's save and rerun our server again to see if it worked. If I renamed Panda Garden to The New Panda Garden look, it's been updated in the database and on our restaurant's page. The source code for objective four is also available in the instructor notes. Now, we'll be addressing the final challenge, which will allow me to delete a restaurant from my database, by taking me to a confirmation page with a POST command to remove my restaurant menu item. Once you have attempted this challenge, go ahead and move on to the solution video. To get started let's replace the hash tag in our delete link with the password /restaurant/ id number / delete. Here inside my do get block. I'm going to make a confirmation page to call to the user's attention in the restaurant they were about to delete. Within it I create a post form that only contains the button element, to confirm the delete. Then I use w file to write my output back out to the client. Similarly to my edit post, I grab the ID part of my URL and create a query to find that restaurant object. I then call session.delete on the object and commit the delete to the database. I redirect once again to the main restaurants page. Let's save our code and fire up the server one more time. And we see that we can now create, read, update and delete via our webpage. All objectives complete. And of course, the source code for objective five can also be found in the instructor notes. Great job on finishing lesson two. At this rate, you'll be a professional in no time. In this lesson, you created a web server in Python, learned what GET and POST requests are and how to create code to handle them, and implemented all CRUD operations via web pages and forms. So, now you've learned the basic underlying concepts of creating a data-driven web app using just Python. In lesson three, you'll be developing a new web server, but this time, using a framework to help you code more efficiently. So up to this point, we've created our code almost purely from scratch, using a few internal libraries like HTTP Base Server and external libraries like SQL Alchemy. Creating a website from scratch really shows that you have a good grasp of underlying programming concepts and are able to utilize the power of Python. But as we make our website more and more complex, the code becomes repetitive and difficult to maintain. Frameworks are collections of code that simplify the web development process. They take care of repetitive tasks and allow us to focus on the more unique features of our project. At the moment, some of the most popular frameworks out there are RubyonRails.net and Django. But if we take a look at this Wikipedia article, we see that there are hundreds of frameworks developers have created to code web applications more efficiently. Frameworks may rise and fall in popularity but the same underlying concepts for developing web pages applies for all of these technologies. Think of a framework as a box of prepared cake mix. We could make a cake using all of these items from scratch and would probably have a better understanding of how to make cakes. But if we have several cakes to make in a short period of time, finding a good cake mix simplifies the preparation process and helps us focus on other things. Like frosting. In lesson two you built a website with the raw ingredients of web development. Now it's time to see how we can use frameworks to improve our development process. In this lesson, you'll create a menu app, using the Flask framework. I will start by showing you the basic components of a Flask application, with a simple hello world program, which you will then create on your own. Then we will connect to our database via SQL Alchemy to view all of the items in each restaurant menu. Next, you will learn about templates, and how they allow you to write HTML code, separately from Python code. Keeping your application more organized. After that, I will introduce a special function in Flask called url_for, which builds the URLs that you will use to navigate through your new Flask application. We will then create forms to capture data from users, and use message flashing to notify the user each time they successfully change information in the database. I will discuss a way to use flash to add the option to send JSON messages instead of HTML. And finally, take some time to style our app with some CSS. Let's go ahead and create our first application in Flask. Create a file named project.py in the same directory as the database setup.py file. A minimal Flask application looks something like this. Let's take a look at this code together and see what's going on. First, I imported this Flask class from the Flask library. Next, I create an instance of this class with the name of the running application as the argument. Anytime we run an application in Python, a special variable called name gets defined for the application and all of the imports it uses. The application run by the Python interpreter gets a name variable set to __main__ whereas all the other imported Python files get a double underscore, name double underscore variable set to the actual name of the Python file. Next, I have this thing that looks like a function, but starts with an @ symbol. This is called a decorator in Python. This decorator essentially wraps our function inside the app.route function that Flask has already created. So if either of these routes get sent from the browser, the function that we define here gets executed. If this is difficult to follow, it's okay. I'll provide a link in the instructor notes if you're interested in learning more about decorator functions. Just know that this @app.route piece of code will call the function that follows it whenever the web server receives a request with a URL that matches its argument. So in this case, if we visit the root of my site at local host port 5000 or local host port 5000/hello, this HelloWorld function will be invoked. Inside my HelloWorld function, I return the message I want to display to the user's browser. Jumping to the last line of our code, I use the run function to run the local server with our application. The if statement here makes sure the server only runs if the script is executed directly from the Python interpreter, and not used as an imported module. So basically, this line of code says, if you're executing me with the Python interpreter, then do this. But if you're importing me into another Python file don't do this, but you still have access to the rest of the code. By default, the server is only accessible from the host machine and not from any other computer. This is the default because in debugging mode, a user of the application can execute arbitrary Python code on your computer. Since we're using a vagrant environment for this course, we must make our server publicly available by changing the call of the run method to look like this. This tells the web server on my vagrant machine to listen on all public IP addresses. Restarting our server each time we make a modification to our code can get pretty annoying but Flask can take care of this for us. If you enable debug support the server will reload itself each time it notices a code change. It will also provide you a helpful debugger in the browser if things go wrong. I'll save this code as project.py in the same directory as my restaurant menu db file and execute it with the Python interpreter. Visiting localhost port 500, or localhost port 5000/hello, I see the output of my code. To stop the server, I hit Ctrl+C. So we see that with much fewer lines of code, I executed a similar version of our Hello World from lesson two. Notice that with Flask we don't have to explicitly write out response codes anymore. You will soon see that this is just one of the several features frameworks take care of automatically for the developer. Take a look again at these routing functions. Notice that I have two of them here. What happens if I were to get rid of this @app.route/? Test this out on your machine and see if you notice any differences. Why do you think this app.route/ is useful to have in our application? The app.route / line takes you to the same page as visiting the app.route /hello. If this is not present, we get a file not found error in our browser. If we just visit the root of the site, at localhost port 5000, making it appear to the user that a site does not exist at this address. Decorators in python can be stacked one on top of the other, so the app.route/, will call the app./hello which will call the HelloWorld function. This is useful for having different URLs all route to the same place. Try visiting amazon.com and amazon.com/index to see how their server also handles routing different URLs to the same home page. So now that we have a functioning Flask application, let's bring our CRUD functionality into it. I will import the code for SQLAlchemy and the database engine in sessionmaker like in Lessons 1 and 2. Now I'm going to change my HelloWorld function such that it performs this following query to grab the first restaurant out of my database. And list out all of the menu items and stored in a string called output. I'll also add a break line tag to make my output a bit easier to read. I will return this output string so that my user sees it from the browser. When I save my Python file my flask server instantly refreshes itself. So when I refresh the page I now see all of my menu items listed Try this thing out the menu items with Flask on your own machine and modify the code to list out the price and description for each menu item. You may want to add a few line breaks to make your output easy to read from within your browser In order to solve this problem, all I had to do was add i.price, a break and i.description, followed by two more breaks to my output stream. The solution code for this is available within the instructor notes. Most modern web applications have elegant URLs. This helps people remember links which then can be easily bookmarked or shared with others. As we saw in previous videos, the route decorator is used to bind a function to a URL, but there is more to it than just static paths. We can make certain paths of the URL dynamic and attach multiple rules to a function. To add variables to a URL, I can specify a rule with type: variable_name, where type can be an integer, string, or another path. I will make a new route for my menu app as so, and use the restaurant id to specify which menu I want to see. Note that it's handy to leave in this trailing slash, and Flask will render the page, even when it's not there in the URL. I will now save my changes and visit localhost port 5000/restaurants/1/menu and see my first restaurant menu there. If I change the integer after restaurants, I can see other restaurants in my database as well. Download the stutter template for this code in the instructor notes. Note that there are functions for newMenuItem, editMenuItem, and deleteMenuItem, all with the parameters that they take in. Write up the appropriate route decorations to properly execute these functions. When you can open the URLs to create, edit, and delete menu items, you have successfully completed this challenge. Don't hesitate to view the Flask documentation or ask for help from your fellow students if you have any questions. Let's construct the route for our new menu item. Now when i visit slash restaurant and pass in an integer and then slash new. This integer will get passed in as the restaurant ID for the new menu item function and successfully return that task one is complete. The edit menu item takes in two parameters, so we need to make sure that our route also has two parameters. The restaurant ID and the menu ID. And then slash at it. Now we'll see that this page also works. Similarly to the edit route the delete route looks just about the same. Except that it has slash delete. Now our final route is also working. The solutions for this challenge are available in the instructor notes. Generating HTML from within Python isn't all that fun. I am sure you're getting pretty tired of having to create these strings we've called output over and over and over. This can get pretty cumbersome as our application gets more and more complex. Because of that, Flask configures a template engine for you to store your HTML code. To render a template you can use this cleverly named method called render_template. All you have to do is provide the name of the template and the variables you want to pass to the template engine as keyword arguments. Here I will render a template for my menu items page. Flask will look for my templates in a folder named templates. So I'll make a directory called templates in the same folder as my Flask application, and from within it I'll create an HTML document and call it menu.html. But what about when we need to get information from our database or Python code into our HTML? This retrieval of data is called HTML escaping. Templates in Flask are already pre-configured to handle escape code. That is, the code that we are retrieving from our application and database, and putting it into our html. With HTML escaping we have access to python variables and functions, and can even get the results added directly into our HTML code. I've created a simple template here, and called it menu.html. A copy of it, is available in the instructor notes. Take a look at it, and see if you can figure out, how Flask accommodates for escape code? You should see a few symbols here, that don't look like HTML. Try and see if you can figure out, what each one of them does. All right, so we see that the code with the single bracket and a percent sign on either side is the logical code that we want to execute in our HTML, like a for loop. The double brackets indicate the code that we want it's results printed into the html document itself. Since, from within HTML codes, we cannot use indentations to mark the beginning and ending of statements and loops, we must use keywords, like endfor, and endif, to indicate the end of a loop, or statement. Going back to my menu.html, I can see how I'm obtaining the result of a query and executing the output here in my HTML page. I will also need to substitute the code I had in my restaurant menu method, so that instead of returning a string, we will return a rendered template with the new menu.html file. Since I'm querying on my restaurant and menu items table, I will path my queries into the template, so that my escape code has access to these variables. I will also need to import the render_template function from my Flask library. By saving and refreshing the page, I see the same code with a few stylistic modifications I added inside of my template. You'll be building your own templates very soon. I just want to talk about two more topics to help you get the most out of them first. URL building is a helpful feature in Flask to create URLs based on the functions they execute. This is really helpful when you want to create links to other pages inside your application. To build a URL to a specific function, we can use this url_for() method. This is one of the many helper functions that Flask makes available to us. The documentation for url_for() can be found on the Flask documentation page here. I want you to open up the menu.html template and add some new hyperlinks to edit and delete each menu item. Remember that this URL for helper method returns a complete URL stream, so place it where it belongs inside of an anchor tag. If your code works you should have edit and delete links now on every menu item. Read through the documentation for reference. Consult your fellow students if you have any questions. Url_for accepts the name of the function as the first argument, and a number of keyword arguments each corresponding to the variable part of the URL rule. So if my URL needs a variable for a restaurant ID and a menu item ID, my url_for statement needs to look something like this, taking in three arguments for the function it will call and the variables to pass into that function. So back in my template I can add this code inside my anchor tags right after the href equals. Since this is a method in Python and I want the output printed on to my HTML document, I will enclose it with a double brackets. When I save my code now, I see that there are edit and delete links for each menu item below. So you may be wondering why you would ever want to build URLs instead of hard coding them into your templates. Well, now if you ever need to change a URL path, with URL building, you can change your URLs all in one place without having to remember to change URLs all over the place from within your application. We know that with HTTP, there are various types of requests that we can send along with URL. By default a route in Flask only answers to get requests. But that can be changed by providing the methods argument inside the route decorator. I will change my route to create a new menu item. Such as a response to GET and POST requests like so. Now that I can respond to POST requests, I can make forms for creating and updating menu items. I will make a new template called newMenuItem.html like so. Take a second to look over the code. Here, I'm making a small form with only one entry to create a new menu item name. In order to get data from a form, I will input requests from my Flask package like so, inside my project.py file. Inside my new menu item function, I will create an if statement that looks for a POST request. I can create a new menu item like so. And extract the name field from my form using the request.form. After I create the menu item, I can then add it to my session and commit the session to the database. To redirect the user back to the main user page I can use a helper function called redirect like so. I should remember to import redirect, and url_for, in order to enable this functionality in my project. Now, I need to properly handle the get request, for creating a new menu item. If my server didn't receive a POST request, it's going to go ahead and render the template, for the new HTML template that I created, to create a new menu item, passing in the restaurant_id as well. Now when I click create new item it takes me to the New Menu Item page and I have successfully created a new menu item Now, it's your turn to make a form and Flask. Create a template called, editMenuItem.html that allows me to edit the name, of a specific menu item. A major difference between this form, and the new menu form is that now you should find the menu item, you want to edit, and pass that in with the render template function. Use the placeholder tag in HTML, so that the user sees the information that they're about to modify. Also, add a link called, Cancel that will take me back to the main menu page, if I decide I don't want to modify a menu item. In the instructor notes, you'll find a project.py file that already has the editMenuItem function filled out, so you just need to create the form that will communicate with it. Inside my editMenuItem function, I see that in my render_template, I'm passing in three variables that my editmenuitem.html file is going to have access to. The restaurant_id, the menu_id, and i, which is going to represent the item we want to edit. So to edit a new menu item, I'm going to create a form, just like I did when I created a new menu item. Inside the form I'm going to call my edit menu item function with the appropriate parameters. Here I'll prompt for the name of the new menu item and create an input field. Using the placeholder attribute of HTML I can have that field already filled out with the name of the item I'm going to edit. I'll then add a button called Edit. And here I create another link to cancel just in case I realize I actually don't want to edit my menu item. When I save and run, I see that I can now change the name of my menu items. The solution code for this video is available in the instructor notes In this next quiz, you're going to write code to remove an item from our restaurant menu. But this time I'll provide you the template code. Delete menu item dot HTML is available in the instructor notes. Your challenge is to refactor the code and project dot pi such that we can effectively delete an item from the database. The first thing I'll modify in my project.py file is this app.route, such that we can respond to GET and POST requests. Similarly to when I edited a menu item the next thing I'll do is find the item I want to delete. In my if statement I'll check again to see if it's a POST request, delete the item, and redirect back to my main menu. And if it's a GET request, I'll go ahead and render that deleteMenuItem.html file with the item I want to delete. Solutions for this challenge are available in the Instructor Notes. Good applications and user interfaces, incorporate feedback throughout the user experience. If the user does not get enough feedback they'll probably, end up hating the application. We should add a feature, that explicitly notifies the user that the system has responded to their input. Flask provides a really simple way to give feedback to a user. Message Flashing is a feature that will prompt a message to the user immediately, after a certain action has taken place, and then disappear the next time the page is requested. We can use our templates to reveal a flash message, wherever and however we want, from within the application. To get started, let's import flash from our Flask module. Flashing works in Flask by using a concept, called sessions. This course does not go too, in depth with sessions. But just know that sessions are a way, a server can store information across multiple Web pages, to create a more personalized user experience. In the bottom of our project.pi file, let's first add a secret key, which flask will use to create sessions for our users. Normally, this should be a very secure password, if our application was live on the Internet but for development purposes, let's just set our key to super_secret_key. To flash the message within our application, we simply use the flash function like this. To get a hold of all of the flash messages, we can use get_flash_messages, which will also work from within our templates. So, from within my new menu item method, I will create a flash message, right after I call, session.commit. I will add the message, ("new" menu item created!") now, in my newmenuitem.html template, I will add the following code. If you are not familiar, with this with construct in Python, don't worry. It's just a block that does some automatic clean-up, when the block is exited, that we don't really have to concern ourselves with. If you are curious about the with method in Python, I will provide some resources in the instructor notes. The get_flashed_messages, is returning an array of messages, that's going to get stored in this variable, called messages. We then loop through the array of message, if it's not empty, and print it out to our HTML document inside an Unordered List. Now, when I save my code, and try making a new item, and flashed with a new confirmation message on my main menu screen. Now I want you to add flash messages for when an item is edited or deleted. Right after I call session.commit( ), I'll go ahead and add a flash message to let my user know that a item has successfully been edited. Likewise, in my deleteMenuItem function I'll add another flash message to let the user know that a item has been deleted. Solutions for this challenge are available in the instructor notes. So we have a working application now, but we should probably add some style to it, if we want it to be appealing to users. Flask can automatically look for CSS, JavaScript, and media files, if we put them in a folder named static. So I will create a folder called static, in the same directory as my project.py file, as so. I will create a CSS file, and name it styles.css, and store it inside of this directory. By adding this following link to my template files, I will tell Flask to use this styles.css file when it renders this template. When I refresh my browser, I turn my old unstyled menu page into one that looks like this. Take some time to add some styles to your menu app. My CSS file and templates can be found in the instructor notes for reference. Responding with web pages is great, but sometimes all that needs to be communicated is information. For example, let's say that there's a web application out there called Yum that wants to collect our restaurant menus and advertise them to mobile clients based on their location. Free advertising, all right! This app wants to see the restaurants and menus available in our database but doesn't really need to parse through HTML or waste bandwidth receiving CSS files. It just wants the data. For this reason, developers have created APIs, or Application Programming Interfaces, that allow external applications to use public information our apps want to share, without all the bells and whistles. When an API is communicated over the Internet, following the rules of HTTP, we call this a restful API. One of the most popular ways of sending data with a restful architecture is with a format called JSON, which stands for JavaScript object notation. JSON uses attribute value pairings which are delimited by a colon. Brackets are used to encapsulate individual objects. Let's start coding to add this JSON feature to our application. Before we write the JSON function in our Flask menu app, let's first open up the database setup.pi and add a decorator method. This serializable function will help define what data we want to send across, and put it in a format that Flask can easily use. Flask has a built-in package, called jsonify, that will allow us to easily configure an API endpoint for our application. I will go ahead and import this package now in my project.py file. For this lesson we are only going to focus on using a get request to get a collection of restaurant menu items. But know that other types of requests can be implemented as well. I will now create a route similar to my restaurant menu page with /JSON at the end. I then create a function and name it restaurant menu JSON and then perform the same query as in my restaurant menu class. But instead of returning a template, I will return this jsonify class and use this loop to serialize all of my database entries. Now, if I save and go to local host port 5000/restaurants/1/menu/json, I return with the pure data form of my menu in a format that can easily be read by humans and easily parsed by other computers In this challenge, I want you to add another JSON method that will get a specific menu item like this, when we visit a route that looks like this. Template code and the example from the previous JSON request are available in the instructor notes. So, in order to add our second JSON endpoint, we should add a route, just like specified in the question. Then we create a new function. I decided to call it menuItemJSON, that passes in the restaurant_id and menu_id, since both of them are specified in the URL. I'll then perform a query to get the one menu ID that I want to get the information about. I will JSONify that menu item, but serializing it first. You can see a copy of this code in the instructor notes. Awesome job reaching the end of lesson three. Getting over the learning curve takes some time, but the benefits of using a framework reveals themselves rather quickly. At this point you have learned all the essential tools for creating a web application, and are ready to take on the final project. Now that you have practiced using so many new tools and concepts, it's time to embark on your final project. You will create a menu app with Flask that lists out all the restaurants in your database and allows you to view the menu for each of those restaurants. Users should also be able to create, read, update and delete restaurants and their menu items. You will be the technical lead on this project and I will not be telling you line by line how to write your code. Note that the code presented in these next challenges will help you make a basic final project. But I strongly encourage you to go above and beyond by making a unique creation that you can call your own and share with others. But before we get started, how do we go about building our web application? For many people, the most natural way of going about a project is to just dive into it head first, writing as much code as possible before falling asleep. While this method feels fast, many times we end up spending more time fixing bugs and examining code than actually developing our application. Another option is to code in pieces, working on one page here, another feature there, and putting everything together at the end. While this approach is a little more organized, we may stumble across several bugs when it's time to integrate all of our code together. Also, we won't have a working prototype until we're finished with the entire project. But what if we took another approach, starting out really simple and layering on complexity as we go? Not adding a new feature until we finish the one before. With each feature, we stop, test, debug, and share to make sure we always have a working application even if it's very basic in the initial stages. This way, anyone involved in the creation of our product, such as clients, managers, and team members, always know what the project status is, and what enhancements are soon to follow. This process is called iterative development. Iterative development allows developers to code in an agile way. What agile means is that since there is always a working prototype, if a client or teammate asks for changes, as a developer, you can react to that feedback quickly without tripping up the entire process. In this last lesson, you will plan, organize, and execute development iteratively to create a final polished restaurant menu application The first step to having an awesome web application is having an awesome game plan. Let's define what our prototype should do after completing each iteration. Let's do some brainstorming to make a checklist of deliverables that we want to achieve with each iteration of development, by breaking down the project into smaller, easier to manage mini-projects. In the first pass at this project, we'll create mock-ups for every page in the restaurant menu app, and design URLs for each page as well. When I finish this iteration, I can show my designs to my friends or colleagues for feedback, and that's enough work for our first iteration. In the second iteration, you'll set up all of the routings for your application in Flask, making sure you can navigate to all of the URLs you want to create for your application. At the end of this iteration, you should be able to navigate to all of your URLs, even if the pages are not yet created. After that, you will build on top of what you made in the previous iteration by creating all of your templates and forms, and making sure that they are properly functioning within your application. Once you have created and filled out all of your HTML templates and see them rendering in your application, we can move on to the next iteration. Now that you have a good grasp of how your front-end code should look, you will add the back-end functionality, making sure all of the actions on the web page are retrieving data from your database. When all of the code operations work on all of your web pages, you'll be finished with this iteration. You will then add some endpoints that allow the data to be sent if the client requests a menu or specific menu item in JSON form. You will test these API calls from within your browser to know you have successfully finished this step. Finally, you will add some styling with CSS, JavaScript, and a few static images, to give your application an appealing layout. In this step, you will also incorporate message flashing into your application. I chose these steps to create our application because I feel they naturally build on top of each other, and have a clear deliverable at the end of each iteration. By keeping this in mind, when you plan future projects, you'll be better prepared for all kinds of new challenges. So before we start getting coded, let's take a second to draft up our page designs. There are a ton of good mock-up and wireframing applications, that you can download and use to design webpages, but for me, pencil and paper is perfect for the first draft. So the first question that comes to mind is, how many types of pages this app will have. So when the user lands on the root of my site, they should see a list of all the restaurants stored in my database. >From here, they can click on a specific restaurant that will show the menu for that restaurant. I also want them to be able to add new restaurants, and edit or delete existing restaurants from the list. On a specific menu page, the user can view the menu for each restaurant. Similarly, they will have the option to add, edit, and delete menu items from a specific menu. So it looks like we need to create eight different webpages for our web app. I will go ahead and specify what I want the URL for each webpage to look like as well. Draw markup pages for these eight URLs using pencil and paper or your own favorite markup application. It doesn't have to be anything fancy, just a sketch to communicate how you want your webpages to look. Share you markups, get feedback from a friend or colleague, and then continue on to the next step of our project. Now it's time to set up the routing for application. In the mock-ups, we specify routes for the following pages. Note that landing on the root page of our site will now route us to the page that shows all of the restaurants. And, visiting /restaurant/menu ID will automatically take us to the menu page. Create a new Python file called, finalproject.py in the same directory as all of our other files. Import the Flask module and the app.run code, like in the previous lesson. Add the routing for all pages into finalproject.py and create the following methods that return the appropriate messages in the browser. When you save and fire up your browser, you should be able to visit all of the URLs like so. At the end of this iteration, you have shown that you can get a Flask application up and running, accounting for all the necessary pages your app will have. In this section, you're going to go ahead and replace those strings in your return statements with templates. In your templates directory, make eight new files with the following names. Replace the previous return statements such that they now return render templates for each of your methods in final project.py. But wait a second, if we design our templates before connecting to a database, Python will throw an error message when we try to refer to restaurants and menu items that don't yet exist in our application. To get around this problem, we can temporarily make a fake database out of dictionaries inside of our final-project.py file. I have made some dictionaries which will serve as dummy variables for one restaurant, a collection of restaurants, one menu item, and a collection of menu items. The source code for these dictionaries is available in the instructor notes. Go ahead and leave hashtags in the form action and href path, since we are focusing more on the structure of our pages in this step, and not so much their functionality. Now, when a user revisits these links in a browser, they should see something like this. The functionality isn't going to be in place just yet, but we've just created another prototype that we can use to present our progress thus far. Your template should also return a different message to the user if there's an empty menu, or empty list of restaurants, maybe something like this. Try and see if you can accommodate for this corner case in your templates as well. With our routes and database in place, we can now add the actual CRUD Functionality to our page. Write in the appropriate SQLAlchemy statements for the following methods. We also need to add url_for and redirects to our application, when necessary. Some of our routes need to be able to respond to get, and post requests. Be sure to add this functionality, as well. When you are done with this step, you should have a prototype, where all the CRUD operations are fully functional. This might be a time consuming iteration to get everything working, but I encourage you to stick with it, and not give up. Use the documentation on the Python Flask in SQLAlchemy websites if needed, as well. Also do not hesitate to reach out to your fellow students. Now that we have a functioning application, let's add some API endpoints to it. The API request should return a JSON object for a list of all restaurants, the menu of a specific restaurant, and a specific menu item, when a client sends a GET request to one of these three URLs. Remember to import jsonify into your project and add a serializable property to your database set up file where needed. Your JSON request should return pages like these when you're finished. In this last section let's put our focus on styling and improving the user experience. Make a static folder and add some CSS files, JavaScript, or images to your application to make it more aesthetically pleasing. Also, add message flashing to your app with the following six messages. In the instructor notes, I've provided a CSS file for reference but I strongly encourage you to establish project on your own and give it a more personal touch. Congratulations. You've finished the final project, and reached the end of this course. You've created a data-driven web application, and have a beautiful restaurant menu app to show for it. However, we've only scratched the surface of web development, so keep going from here. If you're interested in learning more about the Flask framework, the Flask documentation is a great place to start. Add more features to the restaurant menu application, or create a new application of your own, using some of the more advanced features of Flask. I will also provide some links in the instruction notes, on deploying a Flask application, to be shared with the outside world. If you're interested in adding more HTML, CSS, and JavaScript features to your website, take some time to check out some of Udacity's awesome frontend classes. Wherever you decide to go next from here, I strongly encourage you to immerse yourself in the web development community. Read blogs, experiment, and share your work with other web developers and enthusiasts like yourself. [SOUND]. Well, sounds like it's dinner time for me over here. Thanks for helping me show what's on the menu.