There are a lot of essential topics that you'll need to cover to become an iOS developer. Building interfaces with the ui kit, accessing the world content with networking. But right now it's time for us to figure out what happens when the app is turned off? When the phone is turned off, or even when just the app is turned off, there's app state that should be persistent. You need to get some of the state out of the RAM and onto the hard drive. We're going to want Apple's four main persistence techniques, listed here in increasing complexity. There's a good chance that you haven't heard some of these, or all of these. That's okay. We'll cover the material in five lessons. This is lesson one, and you can see that we cover the two straightforward techniques right away. By the end of the five lessons you'll be able to start the virtual tourist app, the fourth portfolio project in the iOS nano degree, to let you collect travel pictures without leaving home. The app stores travel locations on a map and lets you download and store Flicker images for locations. If we select a location we can download images from Flicker associated with the latitude and longitude. We can remove pictures that we don't want and then save the collection. Now, if the app is turned off, the location and images are saved. There are a number of different ways that apps can be turned off. The easiest way is to double click on the home button. This displays the app switcher, we can turn apps off by sliding them up. The virtual tourist app will use core data for its persistence. But in this first lesson let's start with some simpler technologies. I want to help you master these two simple persistence technologies that all iOS developers need to have in their tool kit: user defaults, and saving files in the documents directory. To give us something concrete to work on, we'll revisit the app from Kunal's course, the pitch perfect app. One more note on this course: the format will be different than courses one, two, and three. The content is mostly going to be presented to you in written form. We think that at this stage, this is the most efficient way to guide you through the material, but it's all the more reason to keep in contact with your fellow students as you try it out. All right, let's start out by seeing what it means for an app to be turned off. The user defaults in the document directory are valuable tools, but they're not very inspiring. A complex app has a lot of state while it's running. I live in San Fransisco and I use an app to keep track of the bus schedule. While it's running, it's full of objects that represent bus lines, bus stops and schedules. It even keeps a list of my favorite lines. These model objects are allocated in the device's RAM while the app is running, but I expect it to keep track of them when the app is turned off as well. That wouldn't be very good if it couldn't persist some of the state. If you have a sense that NSUserDefault isn't a sophisticated enough system for adding persistence to these apps, you're right. The next two technologies we're going to look at provide a more complete sense of state. In this lesson, we'll look at NSCoder, and after that we'll be ready for Core Data. First, let's take a minute to consider what state really looks like in a running app. For the techniques we're going to learn in this course, we need a sample app with a little more state than Pitch Perfect. So we return to the movie DB API that Jared used in the networking course. We made an app that's called My Favorite Actors. It lets you keep track of a list of actors that you like. We're going to persist the state of the app in two ways. In this lesson, you'll see NSCoding. In the next lessons, we'll use Core Data. You'll find the app in the repository if you check out step 2.1. We didn't choose this app completely at random. The app is meant to have a really similar state to the Virtual Tourist app, the portfolio app for this course. If you can learn how to make this app persistent, you'll be really set up for the Virtual Tourist app. The list of actors corresponds to the pins in the Virtual Tourist app. If we select an actor, we can see the actor's movie poster images. These correspond to the Flickr images in the Virtual Tourist app. We can add actors, which is similar to dropping pins in the map and then we can go and download their movie posters as well. In the code available in step 2.1, the app has no persistent state. Every time we turn it off, we have to start over. Now I'm going to turn it back on and everything's gone. It's terrible really. We need to fix this. So let's pause for a second and imagine this app while it's running. How does it organize the data that it's displaying? Does it keep an internal table, like a spreadsheet with rows and columns? Does it use arrays to hold struct instances? Or does it use key value pairs like user defaults? Check the answer that seems best to you. Absolutely. Inside the object oriented world of an app, the data's going to be stored as a graph of objects. In the favorite actor app, we keep an array of actor objects. But, then each actor will keep a list of movie objects. We call these object graphs. Consider then how nice it would be if we could just save an entire object graph onto the devices persistent memory. And then later, pull the whole structure back out intact. Well, naturally it turns out that we can. Both with the key to Archiver and with Core data. Read on to see how. So NS arrays and NS dictionaries can be persisted using an NS keyed archiver. But what about custom structs and classes? Let's say we have an array filled with three person structs. Can we still persist it with a keyed archiver? Turns out we can, but not for free. If we want a custom structs to work in the system, we'll need to add a little bit of machinery to each one of them, two methods to be exact. We need them to conform to the protocol that will let them work with the keyed archiver. To see why the person structs need these two methods, let's think through the mechanism from the beginning. In this orange color, let's follow an invocation of encode root object to file. That's the invocation on the keyed archiver that asks it to save this array as data. And this keyed archiver begins its recording at the start of this array. As it does its work, it's recording the data into the array. Let's represent the data with some lines over here. This will represent the data that'll eventually be written to the hard drive. When the invocation is done with the array, it comes down into the person object. When the invocation flows into the person object, the person object needs to be able to give its data to the keyed archiver. That data will be added to the accumulating data over here. The invocation will return to the array, so we'll add some more data for the array. After that, the persistence will continue. The keyed archiver will go into the second person object and return. And so the keyed archiver will accumulate data for the second person object. Finally, the invocation will flow into the last person object, and the red and black lines over here will represent the last person object, and the end of the array. The question for us is, what method is being invoked on this person object? How is receiving the keyed archiver in this invocation? The person object needs to implement the encodeWithCoder method. This NSCoder property is in fact, the keyed archiver. When the keyed archiver gets passed in, it's received by the person with this method, will write the method and inside, will encode our person object. You'll see more during the lesson. The parameter type might be confusing. NSCoder is a protocol that the NS keyed archiver implements. We've seen now how the contents of the data file get put together. This data will be persisted on the hard drive. Let's imagine that the app is turned off, so all the objects in the app's active memory go away. The data is still persistent on the hard drive. The app may stay off for days, who knows, but someday the app will start back up and we'll want to extract our array of actors. When that day comes we'll be up and running again so we can create objects in memory. We'll start out with the Keyed Unarchiver, it's the companion to the Keyed Archiver. The Keyed Archiver made the data. Now, the keyed unarchiver is going to turn the data back into the objects. You might be able to imagine how this is going to work. It'll start with the data in the file. It will consume the beginning of the array and create the array in memory. Then it will consume the first person object and reconstruct it in memory. As it works through the rest of the data, it will recreate the other person objects. Finally, it'll consume the last bit of the array and the array objects will be complete. This is our persistent object graph. To participate in this decoding project a persons structs need to implement a special init method. Which receives the NS Unarchiver as an argument. Again, this is a protocol name. The Keyed Unarchiver implements the NSDecoder protocol. The interesting thing about this is that we don't need to control the whole process. That's the Archiver and the Unarchiver's job, and they've already been written for us. We just need to take care of our custom types. The key is to have our person and movie classes implement the two methods in the NS coding protocol. Read on for the details. Well, we made it to Core Data at last. Core Data is Apple's favorite framework for the model layer. Learning to use it is an important step but not necessarily an easy one. The goal of Core Data is to persist runtime state just like NSCoding but it's a bigger, more comprehensive approach as you'll see. When you learn the framework, you need to learn how to get all of these Core Data components snapped together correctly. We call them the Core Data stack. Learning the stack turns a lot of people off to the topic. It seems complicated but in truth, the set up work is usually the same every time that you write an app. S we're going to try something a little different. Here in lesson three, we're going to work on an app in which the Core Data is already set up. That's how you spend most of your development time anyways. After that, in lesson four, we'll come back and look at the steps involved in adding Core Data to an app from scratch. So we hope that you're feeling brave. We're going to try to make this into a tool that you'll really like. We just learned how to implement the NSCoding protocol in our model objects. Now we're going to learn Core Data. Let's start out with a brief comparison of these two techniques by Mattt Thompson, the author of the NSHipster blog. The link to this particular post is in the instructor notes. I love the joke that this blog makes about the two persistence technologies. It's a joke made with two tables. It's not easy to get a laugh out of tables comparing NSCoding within Core Data. The first table compares Core Data and the NSKeyedArchiver. Things come out looking pretty good for Core Data. Core Data allows us to make formal model of our data objects. We'll look at that in lesson four. It allows us to pull out select pieces of upper system model. Notice that in lesson two, we had to pull out our entire data structure. NSKeyedArchiver pulls out everything or nothing. Core Data will let us pull out portions of our data based on query predicates. That's nice. Core Data is fast. We'll see that Core Data lets us choose the format on the hard drive, very cool. And there are other things like data migrations and undo. All looking good for Core Data. As Mattt Thompson says, it seems like the comparison is one sided. But then there's table two. Although both strategies persist state, one is almost universally regarded as, let's just say one is more frustrating and that goes on to discuss NSCoding, but we've already covered that. Let's move on instead and see what all this fuss about Core Data is about Cudit has a lot of moving parts, and we'll see them all in lesson four. But for now we're pairing things down to their essentials. When objects are persistent, they live on the hard drive, often in SQL light. We need to be able to pull them up out of the Core Data stack and into our working memory. When we use Core Data to bring these objects into memory, we can't use plain old Swift objects anymore. Our classes need to be a special subclass that fits into the Core Data system. It'll have to be subclasses of NSManagedObject. It's not such a terrible price to pay. We can work this into an inheritance hierarchy if we need to. When we write the first lines of the class definitions here, this is our movie class, we can see the inherits from NSManagedObject. It's not a terrible price, but I think that it begins to capture the feeling of working with Core Data. The system owns our objects in a new way. We're still going to have movie objects and person objects, but each of these objects will be closely monitored by the Core Data system. Core Data is going to keep a reference to every single NSManagedObject. In a way it's really nice. Let's say we make a change to one of our objects inside our code. At any time, we could tell Core Data to save. When we do, it'll capture the state of our real live objects, persist them on the hard drive. That's what we mean when we say that they're managed objects. Even though we use them in our code, we tell Core Data to save and they're all saved. Notice that I'm referring to this object quite a bit at the top of the stack. We call this a managed object context, often we will refer to it just as a context. We're going to start our exploration of Core Data by working with a context that's all set up. It's the object that'll keep track of all our managed objects, it's the object that will handle the save method. We'll also see that when we want to get our objects up and into memory, we also used a context. We'll accomplish this by invoking a fetch method. In fact, let's jump into our favorite actor's app and see this in action. The app is already fitted out with a Core Data stack as you'll see, and it's pre-configured with a few actors. Let's jump right into the action. We'll use fetch to get to managed objects from the context. Well, that wasn't so bad, was it? In truth, once you're familiar with Core Data, it can become a trusted tool and a great way to structure your model. In Lesson Four, we're going to take a look at the code that we took for granted on this first pass. It should be fun. Here in lesson four, we're going to go back and take a close look at the core data stack. I mentioned before we usually just set the stack up once, at the beginning of a project. But it's important to know these components. Maybe the most important thing is to be able to speak about them with confidence in an interview. We'll continue to work with managed object contexts, the top of the stack, and with managed objects and their relationships. When you're done, you'll be able to read through a whole core data project without finding anything that you don't recognize. Our favorite actor app is up and working. But it's time for us to tackle the class that we took for granted in lesson three, the Core Data stack manager. We've been using a convenient singleton method to get a hold of this stack manager. The class method named sharedInstance. It gives us a handle to an object that represents the whole stack. Let's consider this whole diagram to be that very shared object. What does it consist of? What kind of objects does it hold inside? One thing that we know for sure is that it holds context. An instance of NSManagedObjectContext. We've been accessing this context through the managed object context property. We've insinuated that this context sits on top of a Core Data stack. What is this stack? Well, quite a bit as it turns out. Let's take a look deeper. One of the things that this stack contains is an object that describes the movie and person entities. This object is called the manage object model or the model. And it's created using a special Xcode tool. We're going to learn to use that tool in this lesson. Any time that you use Core Data, you will make one of these models. Your virtual tour staff will have a similar model that describes the pins and pictures. After that, we get into the standard machinery of Core Data. The machinery that actually persists the objects into the hard drive. At the very bottom of the stack is the file that actually holds the data. Our manager starts out with a handle to the familiar documents directory where the files live. And what is this file? Core Data is capable of using an XML file or bites from an NSData, but usually Core Data uses a database file in the SQLite format. Our Core Data stack manager has code to help it find this file. In our case, it's called FavoriteActors.sqlite. Rest easy. You don't need to know how to uses relational databases to use Core Data. Xcode makes this file for us, and we never interact with it, directly. Instead, our stack manager has an object named the persistent store coordinator. Again, we won't need to work with this object directly, either. But in order to write the Core Data stack manager class, we'll need to know the steps required to make one. When we invoke save or fetch on the context, it works with this persistent store coordinator to interact with the SQLite file. In this lesson, we're going to go line by line through the whole coredatamanager.swift file and make sure that there's nothing mysterious about how this class gets built. As we said, it's good to have that kind of confidence in an interview. But first, we're going to focus on this managed object model, or model. The tool that we use to configure this object is one of the more interesting Xcode features. It's a little bit like storyboard, but for data. It's called the model editor. We'll use it to define the person and movie entities, purely logically. In a second, we'll take a look. You'll see that once we know the properties and relationships of the entities we want to create, the Model Editor is extremely easy to use. To open Story Board we click on Story Board file. To open the Model Editor we click on the Model file. Let's get some screen room and we can see how it works. You'll see that inside the modelling tool we have our entities here in the left column. And then we have the area for editing the entities over here in this center. We want to learn how to use this tool so let's just be bold here. Let's completely recreate our entities. To delete the entities, we just click on the entities and press Delete. It's kind of risky but not anything to be too nervous about. They're easy to re-create. We'll create two entities and then we'll give them their attributes and relationships. We add entities with this Add Entity button down here. It can be a little bit hard to find because it's so low on the screen. Let's click it twice to add two entities. Now we click the entities once, wait, and then click them again to change the name, and we can do this for both of our entities. Now that we have our entities, let's click on Movie and add its attributes. Let's add four attributes to the movie. Let's set their names to ID, poster path, release date, and title. Then all we have to do is select the right data types. ID is an Int, and in general we'll use Int 64 for Int values. Poster path is a String. Release date is a Date. And title as a String. It's really as straight forward as that. Person is similar. We click Person, and then add three properties. After we add them we have to give their data types. ID is Int 64. Image path is a String. And name Is a String. Hopefully you're getting the impression that you'll not need to spend a lot of time inside this Model Editor tool. Once you know what it is you want to build, it's pretty easy to build them. There's one last thing we need to do. We still need to make our Relationships. This is a topic we should cover in more detail. We'll visit this again later in the lesson. But, let's start by setting them up here in the modeller. Let's start with the movie entity. In this app, each movie object is tied to a single person. To add a Relationship, we click on this plus. Movies have a property named actor that point to a person. That's the name of the Relationship. The person class is the Destination. We'll talk about these Destinations more. In the person entity, we have a Relationship named Movies. Again we add a Relationship and we set it to Movies. We'll set the Destination for this Relationship to the Movie object. Remember that we discussed that Relationships have inverses. If a movie is tied to a person, then that person is tied to the movie. We set these inverses in the third column. This is kind of cool. Notice that once we set the inverse actor, the inverse is automatically set for person's movies property. We're almost done, but there's one more step. We said before that the Relationship between a person and movies is a too many relationship. That means that one person can have many movies. We need to set that here in the Model Editor. To do that, we open up the left panel. We click on the Relationship and we come over here to the Entity Inspector. Here we can set the Relationship to Too Many. But what is this? That opens up some additional options. What are the Arrangement and Count Bounds? What is this Delete Rule? There are a lot of things we need to learn about these Relationships. Let's look into these in more detail Excellent. You've seen the whole Core Data stack, now. It may seem like strange advice, but it's worth taking some time to memorize the components in that stack. Being really confident about those items is really nice in an interview. In the next lesson, we're going to look into a smart architecture that'll tie together your Core Data model, your networking code, and your user interface. One of the interesting things about learning to use Core Data is the chance to see an entire NBC architecture, as envisioned by some of Apple's developers. In this last Core Data lesson we want to look at a particular issue for NBC. How should the view code be notified when the model is updated? Core Data encourages two techniques, NSNotificationCenter and NSFetchResultsController. You may recall NSNotificationCenter from the networking course, but this FetchResultsController is new and pretty cool, we think you'll like it. We recommend that you use the FetchResultsController in the Virtual Tourist app. In this lesson we'll show you how it works in a similar app, and at the end of the lesson, we think that you'll be ready to tackle the fourth portfolio project. The other app is, of course, the favorite actor's app. It's up and running now, and in truth, it's pretty nice. I don't think we'd be wrong to congratulate ourselves, but if we think about the relationship between our view controllers and our Core Data, I think you'll see that there is room for us to do something even cooler. Think for a second about the ActorPickerViewController. That's the view controller where we type actors' names into the search bar and then it continuously pings the movie database API to get the corresponding actors. Then it places those actors into a scratch Core Data context. Let's go through that interaction again one step at a time. First the view controller initiates a task, contact in the movie database. And the result come back to the view controller. The result is some actor objects. Then the view controller inserts the movies into the scratch database, and also holds on to them. That's perfectly fine as far as things go. It works like a charm in fact. So, what's the problem? The problem is that our view controller is a little bit over burdened. One way to think about this is to consider what it would be like if there were other entities changing the Core Data state. Notice that the way things stand now, there's no way for our view controller to know about it. Another way to think about it is think of this view controller as a window into the data. It's job is to reflect the state of the data. It would be really cool if we could set it up so that it would always be able to change its table anytime the data changed. That would simplify its role. In that case, the view controller could begin the task with the movie database to download the data. But it could ask the task to communicate directly with Core Data. Then it could just sit back and be content to show the data in Core Data. Whatever that happens to be. As the state changes, it would like to be notified with method and location, so that it could respond by adding and removing and updating table rows. Well, Apple likes this idea a lot, and if you take the time to get comfortable with it, we think that you'll learn to like it a lot too. What would be better than being automatically notified of a data change? To pull this off, we need an assistant object, an object that's part of the Core Data library. An object that's closely tied to the context, so they can know when it changes. An object that's willing to share that information with our view controller. That object is not just a fantasy. It's real. It's the NSFetchResultsController. Read on to learn its secrets. Well you did it again. You made it to the end of a course. We hope that you have a new confidence in your tool set for persisting data. It seems pretty likely that you feel good about NSUserDefaults and NSCoding. We hope that you have a new affection for Core Data as well. See you soon. [BLANK_AUDIO] Almost done, almost done. That's it, that's the whole thing and send. [SOUND] Whoa, pizza. [BLANK_AUDIO] Large pepperoni and crazy sticks for Marty McCapp. Micky P.I., that's me. Cool, here you go. Thank goodness you're here. I'm so hungry, I've been writing this algorithm for hours. I solved the flux photon algorithm. Yeah, cool. Okay. You know this algorithm's going to change the world, right? [LAUGH] Yeah, yeah. [BLANK_AUDIO] And, send. No, no, no, no, no, wait, wait, wait, wait. You can't die, you can't die. Just turn back on, come on. Open up messages. Where is it? Where's the algorithm? No, what am I going to do? Doc, Doc will know. [BLANK_AUDIO] Hello? [SOUND] Hello, who's this? Doc, it's me, Marty. I solved the flux photon algorithm. I had it written down. I was going to send it to you and then my phone died and I don't know what to do. We have to go back Marty, back to the past and then both in. We're sisters. [MUSIC] We have to go back, Marty, back to the past. I mean one that persists. Hold it. Let's pause for a second and talk about what persistence and persisting data actually means. [SOUND] Persistence is saving data to a place where it can be re-accessed and retrieved upon restart of the device or app. This can mean nonvolatile memory on your device or saving data to remote servers. Persistence is necessary for any app that wants to store data long term. That is longer than a life cycle that running app and keep it available to the user. In this course we Fernando, me and you will go over how persistence works, why it's needed, what options are available for creating persistent iOS apps and what the most important ones are. We'll also add simple persistence to a recording app, and work in a completely new app to level up our persistence skills. You'll see a lot of Eden at the start and more of me Fernando later on. As course developers here at Udacity we are here to guide you through the learning process of iOS app persistence. We'll start with NS user defaults. One of the available options for persistence. Then in lesson two we'll discuss the iOS file system and sandboxing. In lesson three, we'll move on to our second and most important option for persistence, core data. Where we'll talk about pieces of the core data stack, how to create a data model and how to make objects from that data model. Lesson four will finish implementing core data, and see how it actually persists our changes, will see what happens behind the scenes, and most importantly, what core data provides beyond persistence. We'll also learn how to display core data objects in tables, and collection views. And in lesson five will dive deeper, and find out how to search and filter objects. And how to migrate our data model, which is vital to know before uploading an app to the App Store. So let's get started by finding out how the Doc plans to save Marty's algorithm by using NS user defaults. [BLANK_AUDIO] Okay, Marty, NSUserDefaults is by far the easiest way to persist data to your device. How does it work? It's actually it's like a dictionary that every now and then automagically saves its contents. And it can save my algorithm? Yes, it saves data into a plist, this stands for property list. And even though it can only take certain types such as data, string, number, date, array or dictionary, that's not a problem. We're sending your message a string. So if we go back to the past and implement and NSUserDefaults on the text input section of my phone's messaging app, then when my phone dies and the app turns off, it will have saved the album I wrote out? Yes, though. What? It's nothing. What is it, Doc? NSUserDefaults reads and writes all in one go. So that's why we try to keep the size below 1 MB. If it's bigger, it would be taxing for the device. But that should only a problem if the file is tremendous. Your algorithm can't be that big. I wish I could remember. Nah, I think that's impossible. Actually, I'm certain it is. NSUserDefaults will suffice. Come Marty, we have no time to waste. To the DeLorean! While Marty and Doc go back in time to fix Marty's messaging app, see if you have a good understanding of what integers or defaults can be used for by taking this quiz. To answer question 1, no. Thousands of notes, images, and whatever else a user might store would be way too much information for NSUserDefaults to handle. The performance of your app would be terrible. The answer to question 2 would also be, no way. Even though NSUserDefaults could store videos as NS data, it would be a horrible idea. Videos are way too big for poor NSUserDefaults. These would both be great jobs for core data. We'll learn more about core data in lesson three. To answer question 3, yes. It would be a perfect match for NSUserDefaults. This class was designed for saving precisely this type of simple user preferences. Go NSUserDefaults. Now that you have the general idea down, let's go over an example. Say there's a part of your app that presents use with a preferences page and allows them to choose between two app themes, daytime and midnight. If you set your preference to the midnight theme, you probably want the app to remember that so you don't have to reset it every time upon app launch. So this would be a good place to use NS user default. Your device has a default database where it stores everything from system wide defaults to language defaults to app-specific defaults and more. App-specific defaults is what we'll be focusing on. To access the values from this database, we'll need to call standardUserDefaults from an NSUserDefaults object which will return the shared defaults object that we need. Notice I said shared object, that means the NSUserDefaults class has a class method that will return a reference to the same UserDefaults object regardless of where we invoke it in our program. This is called the singleton design pattern. Once we have the shared user defaults object, we can then use keys to get values for this default object, just like a dictionary. In this example, we'll use the method value for key. But there are other methods available as well, such as string for key, bool for key, float for key and others. In this example want to keep a value that lets us know whether the midnight theme is off or on. So it makes sense to use a Boolean here. So we'll first check to see if a Boolean value already exists for the string midnight theme on using the if let syntax in case, doesn't. So let's first suppose that has no idea what we're talking about it's never heard of midnight theme on and this is our first time launching the app. So here's where we'll set it. Setting a value and its user defaults is very similar to checking for value and the syntax is set value with a value And then the key string we'll want to use to retrieve it. So in our case this would be a bool. So we'll say false because no one has flipped the midnight theme on yet. And for key we'll put in that midnight theme on string. So we know that if this else statement is being executed. It's because our call to value for key up here return nil meaning no value had been set for that keystring. So this also shows us that the app has never been launched before because if it had, it have a value for midnight theme on. So let's just add a print that shows us that this is the apps very first launch. And we know that after this first launch, we will now have a value for NSUserDefaults for that midnightThemeOn key. So let's go back up here and deal with this case, that is the case where value for midnightThemeOn returns a value. So we know that since we're using value for key it's returning any object. So the first thing we need to do is cast this to a bool then we can check its value. If it is true we'll call a method called switch to midnight. Which makes all the UI changes necessary to show the midnight theme. If it's false we don't really need to do anything because the UI is set to load with daytime theme, in general. But let's just add some print statement in here so we can see what's happening when. Okay, so now I just need to set up an action for when the switch gets flipped. Let me do that now. So when this action gets executed. I check my switch outlet to see whether it's turned off or on. And then I call the appropriate UI configuration method and it's here that I want to update my new preference in my user defaults. So I hadn't a set value here to true for midnight them on and if the theme switch is set to off I'll put in a set value here to false for midnight theme on. So this should work to save our preference, let's try it out. Now let's switch to midnight theme. And let's see what happens when we close the app. On a device you can view all your open apps by pressing the home button twice in rapid succession. And then you can close an app from there. We can simulate this action on your simulator by holding Cmd+Shift and rapidly pressing the H key twice. So Cmd+Shift+H+H and just like on a device I can swipe up to close it. Now let's relaunch our app and great we see that our preference is saved. Let's switch back to daylight and close it again. [BLANK_AUDIO] Awesome, it saved our daylight preference. But how come it didn't print this is the first launch ever when we first ran it? Well because I had run this app with the NSUserDefaults already implemented when I showed you the demo. So how do we simulate running this app as if it was the first time it's ever been launched on our device? What we need to do is reset the content and settings of our simulator. We'll end up doing this a lot throughout the course so we've included the directions for the step in the accompanying text as well. It's pretty simple though. We just click simulator and then reset content and settings and that's it. Now we can launch the app as if it's the first time it's on our device. And now we get this output that says this is the first launch ever. So it switched the midnight theme on, let's close the app. Let's relaunch and we see our preferences saved. So awesome but there's actually an even better place to put all this code. And that's in our app delegate. So I made this method called check you first launch which does a similar thing to what our code in our view did load method did. Except for the primary focus is not whether the theme has been set or not but in a more general sense whether the app has ever launched before. So similar to the code in our view did load method we have bool for key has launched before to check if the app has ever launched. And if it hasn't we know that this is the first launch in this L section. We can set the ball for has launched before to true. And here will also set the default value for midnight theme so that we know it's taken care for the rest of the app and then we can go back here and delete some of this section and see that the app still works. We no longer need to check if there's a value for weWantMidnight because we know that there is because we set it in the app delegate which launches first. And you can see how this would be preferred because then you can make sure things are set up at launch rather than a view load and let's run it one more time. But first let's reset the content in settings and launch. And switch to midnight, let's close our app. Relaunch, and we see that our preferences saved, awesome. All right, so it's time for you to try flying solo with NSUserDefaults by implementing them on this recording app called Pick Your Pitch. We can see that the first page allows us to record a sound file. Testing, testing. And that the second page allows us to play back that sound file as well as adjust the pitch with the slider. Testing, testing. Testing, testing. But we can see that when we close the app and restart it, the pitch information that we set is gone. Test again. Instead of the slider being off to the left where we left it, it's now back in the middle in its default position. Your challenge is to make the position of the slider persistent. Think of it as a simple version of a user preference. If you are making an app for playing podcasts, you might have a settings page where the user sets the preferred playback speed, and users often expect apps to remember that kind of preference. So check out the following instructions and see if you can make this recording at persistent. He could have implemented NSUserDefaults in a number of ways. Here's how I did it first I added a method to the app delegate to check if this is the first time this app is run before. This is pretty much the same code to use in the example app. The only thing I've changed is what I said to be the default value here I set a float to be the default value for slider value key. Remember this is important so that you can check this UserDefault throughout the rest of your code without wondering whether the value was set or not. Next after looking around the place onViewController, I thought it made sense to check for the slider value in viewDidLoad. And using NSUserDefaults float for key method, I set the sliderView.value equal to NSUserDefaults.standardUserDefaults().f- loatForKey(SliderValueKey). (SliderValueKey) is just a constant that I used to store the key string I'll be using again and again. For saving the slider state there are a few methods that would work. If you save it in slider.didMove you will always be storing the most up to date slider value. If you stored it in playAudio you will see the last value that the user chose to listen to. I choose to save it in playAudio, and they used NSUserDefaults.standardUserDefaults().s- etFloat(sliderView.value, forKey: SliderValueKey) to set the user default to the current slider of use value then let's run it is this app persistent yet? [BLANK_AUDIO] I hope so. I hope so. And we see that the slider position is in the same place. [BLANK_AUDIO] [SOUND] [COUGH] We did it, Marty. We're back. That's you, only seconds before you turn your phone back on and find your algorithm is gone. Only this time, your algorithms should still be there. Come. [BLANK_AUDIO] Great Scott, Marty! I was still in the app. Your algorithm's too big and it takes up too much memory. We need to find out another way of saving. But first, we need to find more about your iPhone file system. I was reading something recently. Something about a sandbox? We'll see Marty, we'll see. [BLANK_AUDIO] One topic we didn't talk about in the last lesson. Was where exactly NSUserDefault exists? Where is it being saved? Where is anything being saved for that matter? To answer this, you have to take a look at our devices file system. In this lesson, we'll talk about the iOS file system and the concept of the sandbox. We'll then look at the basics of where and how to access these files with code. For clarity, a file system is essentially the system by which the permanent storage space of a device is organized and divided up to hold files. The type of file system a machine has is determined by the operating system running on that machine. For iPhones and iPads this operating system is called iOS. And similar to the operating system running on Macs, it dictates a UNIX based file system made up of a hierarchy of directories. With the primary goals of security and simplicity in mind, the file system for iOS was conceived with the notion of treating all apps as self-contained independent islands. Each app when it's installed, is placed in what's called a sandbox, or self-contained area of the file system in which to keep all of its stuff. You can imagine a new app on your device as a new student at a school. Let's call her Appigail. The new student is given a locker to keep books, papers, personal items, and whatever else. The lockers locked so only this student has access to her own things. Likewise, the student doesn't have access to any fellow student’s lockers. The only thing is, imagine that this is a magical school and that the lockers maintain magical properties. There's an overall finite amount of space that all the walkers combined can take up, but until that space limit is reached, each student's locker will expand to fit whatever is put into it or new lockers can be created. Whereas if a student has to store gym bag and large textbooks, as long as the overall locker system has extra space this student's personal locker will expand to fit his items. Likewise, you, the device's owner, get to decide how you want the space allocated. Whether you want to keep 12 gigabytes of photos, and 6 gigs of music, and 6 gigs of small apps, the choice is up to you. So now that we have a basic understanding of how the overall file system works, why don't we take a look at what one of these AppLockers or Sandboxes looks like on the inside. When an app is installed, its Sandbox is created with several pre-made containers. The Bundle Container contains the application itself, or more specifically, a directory that holds the executable code and resources, like images and sound files or whatever else is used by that code. The Data Container, like its name might suggest, holds all the user and app data. Within it are three sub-containers. The documents, library, and temp directories. Temp is used for storing very temporary data that doesn't need to be persisted across launches. So we're not going to be talking about this directory in this course. Documents and library are the directories you want to focus on. Documents is where user data should go, and library is for non-user data files or files that you don't want to expose to the user. Both of these directories contain a few standard sub-directories, such as Documents/Inbox, Library/Applications Support, Library/Caches, and several others. The caches directory is important, and we'll revisit it along with the documents and library directories later in this lesson. Note that you can also create sub-directories of your own to better organize your files. At app runtime, an app may also request access to additional containers, such as the iCloud container. So now that we have an idea of how the file system works and what the Sandboxes inside the file system look like, we can probably revisit our initial question. Where does NS user defaults live? If you guessed within the data container, you'd be right. It lives right here within the data container inside of library. Its actual path looks something like this. The file, info.myapp.mobile.plist, is the file that contains the saved and its user defaults. Okay, so the sandbox is where we are allowed to save information. Let's look at those three subfolders we mentioned earlier. Documents, this is where you save important information. iTunes will make backups of this folder, and the OS will never delete its contents. Caches, this is for temporary info. iTunes and iCloud will never make a backup of its content. Library is generally for any files you don't want exposed to the user. We don't need to worry about this folder for now, but in case you were curious, that's what it is there for. The rule of thumb is, important stuff goes into Documents. Things that won't be necessary in the future or are easy to recreate should go into Caches. In order to save something in the sandbox, we need to do two things. First, find where the folder is within the sandbox and then write to a file within that folder. To achieve this, we will use the following classes, NSFileManager to get the path to the folder within the sandbox, and then String to write or read text files, or NSData to write or read by binary files. Enough talk, let's move to Xcode and write some code. As we go through the following steps I'll give you intervals in which to pause the video and implement the steps on your own project. Feel free to do this or to follow the whole video to the end and try it all at once. I'll start by creating an empty project and then adding a method called SandboxPlayground. You can pause here to do this step now. Now within this method we need to create an instance of NSFileManager. This class allows us to find folders, copy files, remove files etc. We'll use this to get the path to the documents folder within our sandbox. Oddly enough, instead of a URL we're going to get an array of URLs. What's going on? Well, if we think about it, there is actually more than one documents folder, right. Remember, there is one for each app installed. This method works by returning all of them, but since we are only asking for one right now, we'll add in the second parameter to filter out the ones that we don't need. Now we have an array with just the one URL we need. So let's grab it. This is a URL to the documents folder, but I want a URL to the new file I'm going to create. That's pretty easy, we only have to add the name of the file. I'll do this now and then you can pause the video and edit your own code. Okay, so now we're ready to save something. We could use NSData or NSString, both work in a very similar way. Let's write the text inside a string into a file. There's nothing wrong with being a little paranoid when it comes to code. So let's make sure we wrote that correctly. How can we find that out? Let's read it and see if it's the same content. So did you try it on your end? Works? Perfect. Doesn't work, check out the companion text and see if that helps. So right now we've just saved some data to disk and retrieved it back, but this doesn't exactly seem practical for saving and retrieving tons of data, many different types of objects, several versions of the data or showing it in views and handling it with controllers, and it isn't. But what we just did is just the base concept. There are frameworks that build on top of this. Let's see if Marty and Doug have some ideas. Marty we need a framework, provide us with a general structure and help us save data in a more practical way. The way we're doing it right now is about to cause us trouble and we lack a general structure to help us save and search. Butt. What Doc? [BLANK_AUDIO] I have to be quiet seeing someone from the future is always dangerous. [BLANK_AUDIO] Wait a minute, Doc. What's this one? [BLANK_AUDIO] Great Scott, Core Data. In this lesson, we're going to talk about another and probably the most commonly use option for persistence Core Data. Will flesh out the architecture of Core Data create a model manage objects and set up the framework for our own Persistent App. So what exactly is Core Data? Core data is essentially a framework to help you manage the model part of your app. You recall that the model view controller design patterns splits your app up into three parts. And that the model part is what deals with the important tangible essential pieces of the app. Core data gives us a way to manage these important pieces and gives them the title managed objects. What does managing these objects entail? It includes everything from changing them, tracking them, persisting them, to managing their relationships and more. Let's look at an overview of the core data architecture to see how this works. There are several main components to become familiar with, and we've already somewhat touched on two of them. The managed object model, also referred to as the data model, is basically the physical representation of the model we just spoke of. It exists in XCode as a special kind of graphic file, similar to a storyboard file, but with different purpose and capabilities. The managed object model is what is used to specify the classes and relationships that will be managed within your app and is therefore also what the tables and rows of your app's SQL-like database will be generated from. Much like how interface builder automates a storyboard file, core data automates a managed object model file. Managed objects are those important fundamental pieces we spoke of earlier. A character in a game app and event in a calendar app. There would specified by your object model and what are actually responsible for most of core data's magic, see while they look like regular swift objects they have a substantial twist. Unlike any object we've seen thus far, they save the contents of their properties to a database file. Core data actually hides this complexity from us, so we don't have to worry about it, which is why we refer to it as magic. Every single object of your model will be a subclass of NSManagedObject. The managed object context or the context is where most of the action happens. This object, an instance of NSManagedObjectContext is helpful to imagine as a place. The context is where your managed objects live until they're saved to disk and when nearly every core data operation takes place. Want to create an object you need a context in which it will live. Want to delete an object? Ask the context. Want to save? Again ask the context. To find out who and what is living inside the context, a fetch request is needed. A fetch request is a search of the context for a certain type of managed object. It can specify the type of managed object, a filter, and how the resulting objects should be sorted. All of the pieces of core today that we've discussed thus far, have belonged to the model layer. This next piece, the fetch results controller works in part to control how the data from the fetch requests will be displayed in the view and is thus part of the controller layer. A fetch results controller takes fetch request runs the search and helps display the results in a table view, or with a little extra work on our part a collection view. The most basic task a controller must perform is to keep the model and view in sync. An NS Fetch results controller does precisely this. If the objects returned by the fetch request ever change, the fetch results controller automatically updates the table view. At the lower level, Core Data relies on what's called persistent stores, or stores for short. Stores like the name implies are were managed objects actually get stored when saved to disk. They can be thought of as database data files and can exist in several types namely XML, binary format and SQLite. The latter being the most common and also the one will be using. Note that you can have more than one store or type of store in a given app. Also at the lower level is the last piece we're going to talk about for now. The persistent Store Coordinator. This object allows you to have multiple stores and keep the rest of your app from knowing it. But for the most part, persistence stores and their coordinators are not something you have to worry about too much. These classes when put together make up what's called the Core Data Stack. Let's go ahead and create our application. Start with a single view application, we'll change this later, Next. And make sure you don't select Use Cored Data. Even though we are going to use Core Data, if you select this Xcode will add a lot of code to your application delegate. And that's not the place where it belongs, so don't select that and we'll add this code manually later. We'll call our application coolnotesswift. iPhone. We're all set. Now let's create a model for our notes app. The first step is to add data model file to our project. The default name is model, but you can name it whatever you see fit. Now, go ahead and create your own. There seems to be three things we can create here. Entities, Fetch Requests, and Configurations. Let's start with entities. Entities are a way of describing the classes of your model. Entities will be turn into Swift classes by Xcode. And this is actually the only thing that we will create in here. Fetch requests can also be added to the data model. However, I prefer to keep my model as simple as possible, so we'll create them for code. Last but not least, we have this configuration thing. This is an extremely cool and powerful tool in Core Data. It allows us to save several different stores at the same time. For instance, a common combination is to have a SQL store and then in-memory store. The latter behaves as a cache for objects that might live in the cloud. A configuration specifies to which store each entity belongs to. As you probably already guessed, configurations are advanced Core Data. So, let's set them aside for the time being. In the next video will start creating some entities. Since our app will have notes and notebooks, we'll probably need those two entities. Let's start with the notebook. We will need the following attributes, name and creation date. Name will be a string. And creation date will be a date. Once Xcode turns notebook into a class, it will also turn each of these attributes into properties. We can also configure the attributes over here. Optional specifies if this property must always be present or not. Should a notebook always have a creation date? I'd say yes. Validation rules allow you to provide Core Data with constraints for a value. For example, if you have an attribute called salary, it should always be greater than 0. Therefore, you should set salary to have a minimum value of 0. Core Data will make sure that you never save a value that is less than 0. Now, go ahead and create your own entity notebook. Now, let's move to the note entity. It will have the following attributes, creation, date and text. Should a note always have a creation date? Yes, so we'll set it as optional. Text, should it always have a text? Well, it might be empty. So, I'll leave it as optional. This transient checkbox, here, means that the property will not be saved in Core Data. I wouldn't use this. So, we'll forget about it. Now, go ahead and create your own note. There's one thing missing here. One notebook will have several notes, and a note will have only one notebook. It's important to make sure that our data model includes this information. We'll do this in the next video with relationships. We're going to create two relationships. One that goes from notebook to note and another one which goes from note to notebook. In order for Core Data to work its magic, it's vital that we always set both relationships. One way and then back. There's a big difference between both relationships. Notebook, which we will create here is one-to-one, which means that one note can only be in one notebook. Notes is one-to-many, which means that one notebook can have several notes. Let's stop for a moment and think how these relationships will be mapped once the entity is turned into a class. A one-to-one relationship, such as a notebook, will become a property of type notebook. So far so good. What will happen to notes? It will become a property of type set. A set similar to an array but it with a few limitations. There's no order and no object can be repeated. Now that we have both relationships created, let's make sure that we have both, the direct relationship and the inverse. This is a very important step. [BLANK_AUDIO] And back to notebook. [BLANK_AUDIO] We need to make sure that the relationship goes from note to notebook. [BLANK_AUDIO] And now [BLANK_AUDIO] We have the two relationships correct. Now, move on to the next video once you've added the relationships to your data model. [BLANK_AUDIO] We're almost there. If you know beforehand that you're going to search or sort objects by a certain property, you should mark those attributes as indexed in the data model. This will make it easier for the database to improve the performance of your app. So, let's go ahead and index name and creation date in both entities. Now, go ahead and do this in your app as well. Now there's just one last thing we need to take care of in our data model, deletion rules. What are deletion rules? Well, let me ask you this, what happens to all the notes in a notebook when this notebook is deleted? And what happens to the notebook when a note inside it is deleted? These questions can be resolved setting deletion rules. Let's start with the Notes property. The deletion rules are over here, and we have several options. No Action, which is usually not something that you want to use, Nullify, Cascade, and Deny. Deny is also something that you usually don't use. So, our common options are Nullify and Cascade. When we delete a notebook, what should we do to the notes? They should be deleted also. That's what cascade means. When notebook is deleted, all the linked notes will go away. So this should be Cascade. And we need to do the same thing for the inverse relationship. What happens to the notebook when one note is deleted? Should we delete the notebook? Obviously not. What we should do is remove the reference that that notebook had to this note. That is what Nullify does. One last warning before we move on. Getting your deletion rules wrong is one of the most common beginner mistakes. If you set Cascade on both relationships your app will crash. We'll talk about that later. So pause this video now, and set up your deletion rules now as well. And that's it, we're done setting up the model. And from now on it's going to be pretty smooth sailing. Great, we understand the data model or managed object model. Now on to the rest of these. It's important to remember that these seven classes always work together as a team called the CoreDataStack. As such, it's very useful to treat them as a team as opposed to individuals. We can therefore keep the whole team in one class, oddly enough called CoreDataStack. Even though in our day to day, we will use this class without thinking too much about what's inside, it's worth taking a look at the code to see what makes it tick. Note that this class is pretty much what Apple provides you with, so don't feel bad for using it as is. It's the boilerplate class from the Apple developers' site on CoreData. Let's start with the initializer, it's job is as follows. It reads a model file, and this is the extension of the model file once it has been compiled by X code, momd. Then it creates a sqlite store for it inside the documents folder. And it will call it model.sqlite. Once it's done, it initializes a context and connects all these necessary parts into a persistent store coordinator. The coordinator will also perform migrations. That's something that we'll deal with later. And if everything goes okay, we get no errors. We exit, and we have all the core data stack ready to work. There are several utility methods that are available here, so just drop all data. This will delete all the objects inside of your sqlite store. But it won't delete the files, so it just empties the tables. This is useful while you're developing. And we also have the save context method, which builds on top of the method save from the context in the following way. Whenever you call save context, it will first check if there is any changes that have to be saved,and then will save. So this will make our stack a little bit more performing. There are other features that we will need such as migrating data models or implementing an auto save. We'll add them along the way when they become necessary. Let's get started. Now that we have those two classes in place, the last step to getting the core data structure set up is creating our managed objects. Creating our managed objects is actually easier than you might think. Because, in fact, we did most of the work already when we created our model file. Now, all we need to do in order to generate our managed object files is click on our data model, click editor and then click Create NSManagedObject Subclass. >From here we select the model file we'd like to create entity classes from and then the entities or objects we would like to be managed. Here will select both Note and Notebook because we want to manage both of them. And then we'll click Next. And then Create, cool, and here they are taddah. But wait a minute, how come there are four files here? So when you generate these managed classes two files are actually created for each entity. You have a class file and you have an extension. The extension file contains code that matches up with your object model. You never ever want to write anything into these extensions because Xcode will overwrite them and recreate the class if you modify the model. So, it's good to write any code inside of the managed object class itself. Now let's just move these down to the model folder where they belong and feel free to pause the video here and go ahead and generate these managed object classes on your own. Great, so, this Note class is looking pretty bare. What we need to do now is that add an init method to this class can create usable instances of itself. We'll add in a convenience init which takes text, a string with the words new Note init and an NSManagedObject context called, Context. Then, what we need to do is create an NSEntityDescription. An entity description is an object that has access to all the information we provided in the entity part of the model. And it's needed in order to instantiate any managed object class. >From the entity description, we call entity for name. Which takes in the name of the entity, so in this case, Note, and the context in which we want the Note to live, in managed object context context. Then we can call the designated initializer, which is the initializer for NSManagedObject, the superclass, which takes in the entity description and the context in order to create a new instance. And you can see the parameter name says, insertIntoManagedObjectContext, which is where the instance will live. Remember that every single core data object needs to know its context. Lastly, we just initialize some properties, text will equal text which we can remember is the new note. And creation date will get initialized to NSDate object which is just the current date. We'll put in this fatal error in case no entity exists and the entity name we're passing in. And we're done. I'm also just going to add in this variable which is just a formatted version of that CreationDate property we initialized up there. It just makes the date more human readable. And that's it. We can now just do the same thing for the Notebook class. Awesome, why don't you give it a try? Before moving ahead to the next video make sure you have both inits and get no warnings. At this point, we've seen how to create a data model, data model objects, how to instantiate those objects, and how to search through them. But there's still a lot more to be done. Such yeah, like actually save them. Continue on to the next lesson to implement core data persistence. In this lesson we're going to finish our implementation of core data and see how it works its magic. We'll also look at how our table knows what to display. How a user can add a new note, and most importantly how we actually save and persist these changes. We'll also see the important role core data plays in memory management, and we may even hear from a few time traveling friends. At this point, you've probably already successfully displayed objects in the tableView in previous apps that you've built. Thanks to the tableView data source protocol, it's pretty easy. Just answer the questions that the tableView throws at you, such as how many sections, rows per section, etc., and you're done. We've done this before, so what is new about using CoreData objects? Well, the advancement is that NSFetchedResultsController can answer all those questions posed by the data source. We're going to use a subclass of UITableViewController that receives an NSFetchedResultsController and then lets it handle almost all of the questions from the tableView. Let's first take a look at CoreDataTableViewController. This is the class that all our TableViewControllers will inherit from. It takes an NSFetchedResultsController and lets it do all, or almost all, the talking. The only method from the data source protocol that it can not implement for us is cellForRowAtIndexPath. The reason for this is that it cannot know what type of cell you want. So this is the only method that you will have to always implement. This is a good place for you to pause and check out the code for this class, which is linked in the containing text. We'll be using it in the next video. In this video we will create a notebook table view controller that displays all existing notebooks. Sorted by name and creation date in a table view. First, let's create a new subclass of CoreDataTableViewController. Now, we need to implement a single method, cellForRowAtIndexPath. In this method, we need to find out what notebook we need, create a cell and display the information of the notebook in the cell. Only the first part seems new. How can we figure out which is the correct notebook from the index path? And as fetch results is your friend here, it has a method called object for index path. The rest of the code is per usual. Let's implement it. Now, it might be a good idea for you to pause the video and try writing this code on your own. Feel free to press the pause button, I'm not going anywhere. Now, let's create an NSFetchedResultsController in view did load. We will need three things here. An initialized stack, a fetched request and finally, the NSFetchedResultsController. Let's implement this. Lastly, let's make sure we edit this class to our storyboard. Okay, great. Now, finish implementing the code for the NSFetchedResultsController in view that load. And at the class to the storyboard and then take it for a spin. So far, whenever we make a search, we'll retrieve all the objects of that type. For example, when we search for notebooks we'll want all of them. However, if we want to display the notes within a notebook, we must filter out all the notes that belong to other notebooks. How can we do this filter trick? With one of the crown jewels of cocoa, NSPredicate. NSPredicate is a class from back in the old Objective-C days when blocks, which are Objective-C's version of closures, were not available. NSPredicate's still have their place, notably in core data. Predicates allows us to define filters to select specific elements of an array using a very simple language called predicate language. Let's see an example. Now, we're going to display the notes. We have a storyboard, and our storyboard has been updated with a table VC, a table view controller. Also, we have a nodes view controller class that inherits from core data table view controller, and has a pretty standard cell forRowIndexPath. We get the note, we get the cell and we sync note and sell and return the sell. The interesting part really isn't that prepare for say on notebooks VC. Let's take a look at it the first thing we need is a fetch request for the notes. Next, we need to specify how we'd like them to be sorted, so we going to do that by creationDate and also by the text. The next step would be to create the NSFetchedResultsController and we inject it into the notes view controller and we can display it. Let's take a look at how this displays. So have the notebooks and I'll select these notes, the ones in Coding Notes, and we get them all. Instead of two, we get three. So what is missing here? What's missing is a way to filter only those notes that we are interested in in this case those that belong to the specific notebook. And the way to filter the circuit result by adding an instance of an NS predicate to our fetch request NS predicate is a class that filters the search results. It can be configured with a special micro language called predicate query language. Don't worry about that. It's extremely simple. So let's add one to a fetched request. The easiest way to create an NS predicate is with the format string. So in order to create the predicate first of all we need to find what's the exact notebook that we're selecting at this point because we will need that information in order to filter. So first thing we get the indexPathForSelectedRow and then with objectAtIndexPath we obtain the Notebook. Always remember to cast it to Notebook. Once we have this you can go ahead and create the predicate. The easiest way is using this initialize and this predicate. And then, a format which is simply a string, a kind of a template string, and an array of arguments of objects that will be substituted or inserted into the template. So the template simply states notebook, that means the property notebook, of the note must be equal to. And this is a marker that says that we're going to substitute here an object. What object? The notebook. So it's that easy. We're just saying the notebook. Must be equal to this one and you're done add it to the fetch request and if you run. You have two notes and once we click here. We only get it. So yeah it's that simple, check it out for yourself. And I also recommend you take a look at the NSPredicate documentation as you can create very complex filters with it. We barely scratched the surface and it's an extremely powerful class. Definitely a tool worth having under your belt. Now we're going to allow the user to create new notes by tapping a button. When we have to add a new cell for the table, notify the table so it reloads. The beauty of core data is that it takes care of all of that. So let's create the new method. Try it out and see what's actually happening. First let's add an add button and link it to an IB action. Now, we get to implement this action. And you might want to think a little bit about what should go in here. Creating a new note seems like the obvious thing so let's start there. Okay, so we have our new note, but now do we have to do anything else? Should we update the table view? Well you think about it. I'll go ahead and run the app. So we have a storyboard which is updated with an add button which is linked to an IB action. Now, we get to implement this action and you might want to think a little bit about what should go in here. Creating a new note seems like the obvious thing so let's start there. Now do we have to do anything else? Should we update the table view? While you think about it, I'll go ahead and run the app. Tada magic. Well, I don't know about you, but I usually want to see how a magic trick actually works. So who's actually getting the job done here? It's the MVC, the notifications, and the delegate at work. The first thing that happens when we create a new notebook is that the context realizes something has changed in the objects within it namely, there's a new object. The context therefore sends the NSManagedObjectContextObjectsDidChangeN- otification with a new object as a payload. And as FetchedResultsController receives the notification and sends a delegate message to CoreDataTableViewController, which in turn tells the TableView to update. So, there's no magic. It's just the MVC, delegate, and notifications doing their job. Make sure you understand this, and then if you haven't already, add a similar button to the node's controller. It's exactly the same thing. [BLANK_AUDIO] So let me make sure I have this straight, Doc. Once we have correctly set up the model notifications and delegates, whenever we modify any managed objects, the views just sync up? That's it, Marty. The delegate, the NSFetchResultsController, and the notifications do all the work for us. That's fantastic, Doc! So now that we've implemented all this for the Messages app, we can go back to the future and recover my last algorithm. Hold it, Marty. We're forgetting one thing. What's that, Doc? Aren't we creating new objects and letting everything sync up? Yes, Marty but that's all in volatile memory! All this setting and managing our object models is nice, but if we're not saving to disk, we're not persisting, Marty. Come on Marty, let's go to XCode. It's time to begin adding the methods that actually save changes that the user makes. Remember that up until this point we could change the text of our default note. But that whenever the app relaunched, the same text for that note would appear and any changes added by the user would be lost. We can persist the user's changes to the note by adding just a few lines. Let's take another look at our core data stack struct. If we scroll down to the bottom we can see that we have this extension here that already contains what looks to be a save function, save context. If context.hasChanges try context.save. So, it looks at this is a wrapper function for this context.save function. So what is this .save function? It looks like it's a function of an estimated object context and it attempts to commit unsaved changes to registered objects to the receiver's parent store. Okay so perfect. It looks like all we need to do is call this save contexts function for instance of core data stack when we want to save or changes. But I guess the question is then where and when do we want to call this. Several things happen when the save function is called on context. All properties and relationships are validated. All new and modified objects are saved to disk, and all deleted objects are removed from the database. These three steps, depending on how much data we're dealing with, could actually take a human perceivable amount of time. Because of this, it's really important to think about and carefully choose when to call this function. If we call it after every change the user makes, the app will become sluggish and possibly timeout. But if we call it too seldomly, we risk the user potentially losing data. So when is the right time to save? Let's look through some of the methods in our app delegate that represent the different states of the app's life cycle and see if maybe one of those methods is a good place to save the app's state. The first thing we see in the app delegate is application did finish launching with options. This happens immediately after your app launches, this might be a good time to set up your core data stack but not to save. After all there is nothing new worth saving at this point. Next we have application will resign active. This happens when the app's still in the background but is no longer active. Not being active means user input, such as taps, don't reach the app anymore. This happens when you're using the app and you get a phone call, for example. This is a good moment to save. Next, we have application did enter background. This means your app has been sent to the background because the user switched to another app. This is also a good time to save. Later on we have application will enter foreground and application did become active. These mean that your app is back from the background, it wouldn't make much sense to save in here. And last but not least, we have application will terminate. Your app is about to be killed by the OS. Either the user closed the app or iOS decided to shut it down, this sounds like a good time to save but actually isn't. You don't have much time left at this point. You may want to do a print goodbye cruel world, but anything else is risky. Why not saving immediately after creating a new note? In this case it would be okay, as our data model is very simple. However, in a more complex app, it's better not to overdo it and save too often, unless you know how to do it in the background. We'll look at how to do that later. So this was all very informative but we still don't have a concrete answer. If saving every time we change something is too much saving and saving only when the app goes to the background or becomes inactive, it's too little. What's the best solution? The answer is the auto save method. It will save every few seconds. But, how can we call a method with a delay? Grand Central Dispatch is your friend. If we look at the save method in our core data class, the first thing you'll notice is that it doesn't necessarily save. It will always check the context and see if there is anything to save, and if there is, then it saves. This means we only perform the save operation with all its dependencies, validating, deleting, etc if it makes sense. Now we're going to add a new method called autosave. We still have no idea how to implement it, but who cares? When you don't know what to do, just do something and see what happens. A good method to organize your thoughts is to break down the complex task into smaller ones, then write them down as a series of comments. We'll find out the code we need along the way. So let's get started. The first part is easy, it's just calling the save method. The second part seems more complex, but doc gave me a tip. He told me to use GCD. Check out the documentation and see if you can find a function in GCD that allows us to delay something. Go on, I'll wait. Yes, there is a function called dispatch after. It takes a closure and runs it after a certain amount of milliseconds. If we call AutoSave inside that closure, we have what we're looking for. A loop that saves, waits for a certain time, and then saves again. Just keep in mind that we're not really saving every say five seconds. It's even better. We check every five seconds if there is anything worth saving, and only then we save. Let's get the code for this one. Before moving on, please make sure to check out the documentation for dispatch_after and dispatch_time, then make sure you understand this code, and then call autoSave, while passing 60, that would be one minute when your app launches. This way you'll be auto saving every one minute. Now that we know how to save, we're pretty much set. One thing to keep in mind though as we mentioned before is that when you save this is where what you're saving is validated against the data model you've created. So this means if the object you're saving doesn't have everything the model says it should or it doesn't fit the model's description of what it should be, you'll be looking at an app crash. This is where it's important to recheck your model and make sure things match up. One of the most common places for this issue to arise is with deletion. Let's take a look at our model again. The deletion rule for our notebooks notes relationship is cascade. This means it will delete all the associated notes. That sounds reasonable. If we look at the inverse relationship that notebook relationship with a note the deletion rule is nullified. This means that when a note is deleted, all the references to it are removed or made no. The notebook just forgets about that note. This also sounds reasonable. But what if by mistake, we set the note deletion rule to cascade also? Then if we delete a notebook, core data it will try to delete the notes. However, if the note deletion rule is cascade, core data will then try to delete the notebook again. Trying to delete an object twice is a sure recipe for an app crash. This is a very common beginner mistake, so make sure your deletion rules make sense. Whenever you're working with core data, a mysterious words start showing up every now and then. Fault if you see log messages about fault. Set your worries aside it's not your fault and everything is okay, before we explain what a fault is and why it makes core data such a useful tool for iOS development. Let's go back to table views for a second. A table view never loads all the cells at once, that would be incredibly wasteful. Think of a fetch request that returns one million objects and you tried to display them in a table view. Would one million cells be created at once? Of course not. A table view is smarter than that. The table view by using its data source will only load the cells that are visible in a given moment. This means that cells are created on a per need basis which optimizes performance and memory usage. This is such a brilliant idea that it's used in many other places in Coco, such as collection views. Let's take a look at one. When I scroll up and a cell disappears it gets removed from memory. This is only the view but wouldn't it be great to have the model object being displayed in the cell, to be removed from memory once it's not needed anymore? That's exactly what core data does by using folds. So hang on there and we'll explain it in the next video. Think about an object, just any object. What part of it takes up the most space in memory? The inside. It's all the properties it carries that consume memory. Is there a way to reduce the amount of memory an object requires? Yes, by emptying it. Core data objects can actually be emptied as their properties aren't saved inside the object, but in a database file. And that's exactly what core data does. Every core data object starts empty. That's called a fault. Whenever the user asks for the contents of a certain property, that's when core data fetch the value from the database, and it becomes a regular object. It's just like those old sea monkey ads. Just add water. Later on, if that value goes unused for a certain time, the object becomes emptied again and becomes a fault. This is how core data helps keep your memory footprint as low as possible and without any intervention on your part. This is absolutely vital in an environment with limited memory, such as an iOS device. [COUGH] This is it, Marty, the moment of truth. Gosh, Doc, I hope it works. Look, I'm dancing, it's still there. [MUSIC] In this last lesson, we're going to discuss some final pieces of information needed to implement persistence in the most effective way. Namely, Saving images or BLOBs, that's binary large objects, and Dealing with migrations. This is also the lesson where we'll provide some extra information on persistence and some optional features for your cool notes app. If you ask a database expert what's the best way to save images in a database, you'll likely hear this rule of thumb. If the image is really, really small, then save it into the database. If it's bigger, save it in a file and save the name or path of that file into the database itself. Guess what? With Core Data, you don't have to bother with that either. It will do it for you just by selecting an option in the data model. Let's go ahead and modify our model by adding a new photo entity. First of all, let's run our app once so we can call the preload data method that deletes all the previous contents of the database, and then populates it with notebooks and nodes. And here we have our preloaded data. So let's go to app delegate. And let's comment it out. As we don't need this anymore, we can create objects using the app's UI. So let's comment out pre-load data. And now, let's go back to the model and make some modifications. Let's create a new entity for photo frame with an image data attribute. We can't save the image as an instance of UI image because core data has no idea what a UI image is. So we have to save it as a binary type which means [INAUDIBLE]. It's a bit inconvenient but we'll deal with it later. Every single note will have a photo frame and each photo frame might have a single image data. This property is going to be optional as it could be empty but every note will have an image data. So now we have to create the relationships between note and photo free. It can't be optional because every note must have a photo so off it goes. And the deletion rule should be when we delete a node, we delete the PhotoFrame. So it should be Cascade. Now let's go back to PhotoFrame and create the inverse relationship. This should not be optional because a photo frame should not exist if it's not connected to a note. And when we delete a photo frame, what should we do to the note? Nothing so nullify. Okay so let's save and run our app and see what happens and it looks like we have an error and this is the reason. The model used to open the store is incompatible with the one used to create this store. Well we got this error because we already have saved objects that match the previous data model, the one that didn't have a photo frame. Now we changed this model but we forgot to tell core data how to migrate the older data to the new form. Fortunately, this is quite easy. So think about it and make sure you can't reproduce this on your own project and we'll fix it. Let's start by undoing our latest change and delete the photo frame entity. So the model is as it was before. [BLANK_AUDIO] Now we must create a new version of our model. Add model version. You can call it however you want. Model two seems reasonable and it's based on our current model. Now you can see that we have two different model versions. However, the previous one is still marked as the current one. We need to change that. To change the current version of your model, select your model. And then, in the file inspector, look for model version. And current should be Model 2. So now we have our new version marked as the current one. We should make all the changes back to this new version. So let's go ahead and add the photo frame entity back. [BLANK_AUDIO] The last step, is to make a minor change in our core data stack, to make sure that it does the migration from version one to version two. We do this by adding two simple options to the persistent coordinator. Let's get it done. We create a dictionary of options and one is NSMigratePersistentStoreAutomaticallyOp- tion which is pretty obvious what it's doing. And we're setting it to true. We want to migrate. And we're also telling the persistent store to infer the mapping model. So we're telling you, find out how you should migrate from version one to version two, and we simply pass these options when we add a store coordinator and that's it. Now it's your turn. Grab your x code and create a new version of your model. [SOUND] And now the award for most innovative technology goes to Dr. Emmet Brown and Marty McAppy. [APPLAUSE] Looks like Marty and Doc saved the day. And now, it's your turn to implement Core Data all on your own for the final project, the virtual tourist app. While we've gone over what you need to know in order to create a Persistence App, know that Core Data is a huge framework and we've only scratched the surface. We do hope, however, that you realize how useful it can be. If you want to learn more, we'll be waiting for you in the senior iOS nanodegree. So thanks. Good luck. And we hope to see you in the future. [BLANK_AUDIO]