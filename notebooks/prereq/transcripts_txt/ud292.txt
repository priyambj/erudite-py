Hi, I'm James. Welcome to this course on Canvas 2D. We're going to teach you how to use the canvas API using memes with my co-instructor, Cameron. Cameron. Cameron. Oh. Hey, sorry. Am I late? My bad. So much for coordinating what we're going to wear beforehand. Let's fix that. Huh. Doge. I like it. So, what's with the box? Well, you said we'd be painting with canvas, right? So, I brought some acrylics, I brought some brushes, I brought a palette. Hold, hold up. I'm going to give you an A for effort, but I actually was talking about the canvas API inside the browser. So, we're going to do all our painting with JavaScript code. Oh, oh, that kind of Canvas. My bad. Well, anyways, the Canvas is a powerful API which you can use to edit, resize and otherwise change images, animations, and interactions. Though we won't cover it any detail, you can even use the Canvas to create games that run inside the browser. Okay. Let's get started. We can create a canvas and web page by using the canvas tag. Canvas is a 2D surface that takes instructions and immediately renders them. It's not that different from a real world canvas. Hey, do you want to try painting for a little bit? [SOUND] When we make a mistake or want to change something, we can't just hit an undo button. We have to paint over the portion of the painting that needs to be redrawn. But unlike a real world canvas, one coat will do. Before we dive into the canvas let's take a look at what we'll be building. Huh. You know, it looks like there's a lot going on there. Shouldn't we start with something a little simpler? How about this one? Oh, this is a lot better. We can totally build this within a lesson or two. But I've got one question. Why exactly are we building a meme generator? That's a good question. Let's say you have a website that you want to add some sort of chart or maps to, like the resume project we did in JavaScript Basics. It is possible to do that with some artful positioning of HTML tags in CSS or even Flash, but it's much easier to do with Canvas. Right, Canvas has a set of functions that allow us to draw shapes, images, text, and patterns. And instead of working through a bunch of examples with charts and data, we thought it'd be fun to make some memes. At Udacity sometimes we have a little bit too much fun making memes. In fact I just searched for meme and all of these plus a lot more showed up in my inbox. We apparently send these out all the time. In fact one time James even sent out an entire email about the programming language Swift using Taylor Swift memes. So we, yeah, probably have too much fun. I hear this one came out of web performance because I'm making kind of a funny face. No idea where this one came from but that's Jared who makes classes at Georgia Tech. This is Ben who's favorite thing in the world is to make Chrome extensions. In fact, it comes up in almost every conversation about some type of new technology. Ben'll be like, hey, I could make a Chrome extension for that. So of course, I had to make a meme about him. But I think my all-time favorite meme in my inbox is this one. To give you a little bit of background we have Fancy Friday every other Friday, where instead of trying to dress up like normal tech workers, who are always wearing jeans and T-shirts, we try to put on something different, you know? Wear something nice. And this is David in the background here. And I don't know what's going on here. Apparently this is fancy. But who knows? So I've gone ahead and shown you some of our favorite memes. But now we want to know what your favorite meme is. Go ahead hop on the forums and post your favorite safe for work memes. When you're done check this box to keep going. Enough talk about canvases and memes, let's go ahead and start making one. Right here I've got an HTML document which we'll be using to create the canvas. In order to have a canvas, we need to use the canvas tag, which looks like so. The canvas tag takes optional width and height parameters to allocate some space on the web page for the canvas. Like you had canvas in the real world, this canvas tag alone is only going to give us the physical space on the website to work with. We actually need to take a few more steps to get an object that we can use for drawing. To use a canvas, we need to access it from our JavaScript code which I've included between these two script tags after the canvas. We'll start by grabbing the canvas using this selector to get the canvas with the idea of C from the body. And then from the canvas, we need to grab its context. So to do that we'll simply call the method; get context, on the canvas that we've created, and we have to pass in this perimeter for 2D. You might wonder here if we can grab the 2D canvas, could we also grab a 3D canvas? In fact we can, but that's not what this course is about. So we're going to focus on 2D canvases. >From here, we can actually start calling methods on this context to start drawing on our canvas We've got our canvas and now we need to start thinking about how we're going to draw on it. To draw on the canvas, we're going to need to use coordinates. Otherwise, how will the computer know where we want our awesome drawings to end up? In geometry class we use the cartesian coordinates system, which looks like this. The cartesian system has the X axis going from left to right, and the Y axis going from bottom to top. 0, 0's right in the middle and any numbers below 0, 0 are negative on the Y axis. And any numbers to the left of 0, 0 are negative on the X axis. The canvas's coordinate system is a little bit different. Here 0, 0 is in the top left, and our x numbers just get bigger as you go to the right and our y numbers get bigger as you go down. This is different than geometry class where number got more positive as you go up. So, they're opposites in a way. Keep that in mind. Let's take a look at a couple examples. On this grid, I'm counting ten lines as one, because these lines are too close together. We've gone over ten lines, which we're counting as one, so we have x1. And, we haven't gone down at all so y is still 0. Looking at this one, we haven't gone anywhere on the x axis, so x is still 0. But we've gone down ten lines or one line in this example. So the y is 1. For this last point, we've gone over ten lines. So our x is 1. And we've also gone down ten lines. So our y is 1. It's important that you get used to the canvas coordinate system, because you're going to be using it quite a bit. To get you started I've marked off three points. A, B, and C. See if you can figure out their coordinates. I've also gone ahead and marked off the next whole numbers on the y axis and the next whole numbers on the x axis to make your life a little bit easier. Type your answers in here. Let's start with A. Going up we can see that we're at 2 on the x axis. And we're at the same level as this point over here. So we're at 1 on the y axis. So we've got 2, 1. Next up looking at B. We are one line over. So we know that the x has to be 3. And we've gone down one, so our y is 2. Last but not least with C, we're at 1 on the x axis and we're at now 3 on the y axis. So we've got 1, 3. Important to note, these are not negative numbers, these are positive numbers on the y axis. The y axis gets more positive the farther down you go. if there's one thing that any good meme needs, it is an awesome picture. If we were doing this in HTML, we could make an image appear on the screen by using the img tag and setting a source to something this fake image. But we're doing this with canvas, so let's get rid of this line. So, we'll start by creating a new image, which we'll call image. because why not? And we'll set it equal to a new Image object. Down here, we'll set this source property of the image object to this file, which I've got saved to my local machine. This is part of the power of using the canvas to draw on the screen. We can use a local file as well as any file on the Internet, so if you've found a cool image online, you could put that URL right here or just use a link to the file on your local machine. Images in JavaScript get loaded asynchronously, which means that we need to do work after it's loaded, so we'll set the onload function on the image object to what we've got here. In this case we'll console.log Loaded image, and then we'll doSomethingElse. Let's be a little bit more specific about what we want to happen after the image is loaded. We'll go ahead and grab the ctx again that we created up here and call the drawImage method on the ctx of the canvas. Into the drawImage method, we'll pass the image itself along with its starting coordinates, x and y, and its width and height, which in this case we're setting to the same width and height as the canvas itself inside the DOM. Let's go ahead and see if this works. So we've got the file saved over here. And inside my browser, I'll go ahead and open up this HTML file. And we can see it's saved right here on my local machine in the same directory as that fry_fixed image that we set the source of the image to right here. So let's go ahead and open it up. And voil√†! We see the image appear. To learn more about other ways of calling this drawImage method, check the link in the instructor notes. You might be wondering how we're going to save the awesome images that we're creating inside the canvas. Let's go ahead and do that right now. I'v opened up the HTML document that we've been building, with this script inside that we're using to control the canvas. And I've added these two lines here. In this one, I've created a new variable called saved image, and I've used this new method, toDataURL. I'm calling toDataURL on c, which, as you may recall, is the canvas object that we grabbed earlier. toDataURL, creates a text string that represents the photo. It can output a couple different image formats, but we're only going to use the default for now. So I've created this new text string representing the image. And now I'll call window.open on the new save savedimage that we just created. This should open the new image in a different window. Let's go ahead, and see if it works. I will save this and come over to the browser, and refresh, and OK. It doesn't look like a new window is opening. Okay, that's kind of weird. Let's see if we can figure out what's going on here. Uh-huh. Okay. So we're getting an error, which says that tainted canvases may not be exported. This is an interesting problem. There are a number of different ways to get around it but basically what it's saying is that we need to figure out a way of safely hosting and serving these images in order to save them. Depending on your browser, you've got a few different options for getting around it. First off in Chrome you can actually just simply right click and hit Save image as on whatever you want to save it, which is a really easy way of saving images. Or you can take an even simpler out which is to simply take a screenshot, and save your image that way. But that isn't necessarily what we're going for here. If you want to actually be able to export these and to save them later without right-clicking on them you actually have to create your own server, running probably on your local machine or online. And the steps to do so are definitely outside the scope of this course, but you can check out some of the links in the instructor notes for more details on how to do that yourself. But for now if you want to save an image using chrome you can just simply right-click on the image and that should work, or you can take a screenshot or, you know, if you're feeling ambitious check out the instructor notes to learn how to get around this error message here. Now that we know how to load images into the canvas, let's start thinking about how we're actually going to start drawing on that. To do so, I've gone ahead and changed out the code over here. And instead of the image, I've switched in the methods fill rectangle and stroke rectangle. I've also made the canvas a little bit bigger if you're following along. Fill rectangle and stroke rectangle work fairly, similarly. Got their starting x and y coordinates and then their widths and heights all patched in a parameters. So let's go ahead and see what these two look like. I will come over here and open up this document. Cmd+O > Stroke Canvas > Open. And we see that this code creates two different rectangles. The filled rectangle starts at 100, 100 and has a width of 100, 100 and that's this big black rectangle right here. And the stroke rectangle starts at 50, 50 and is 50 by 50 pixels wide. And that's this gray rectangle right here. Or I guess you could call them squares, because they have the same widths and heights. But either way, this demo is to show that filled rectangles are filled in with colors while stroke rectangles are not. There are other ways of drawing with the canvas as well and I'm going to go ahead and demonstrate one right here. It begins with this command, BeginPath which we're calling on the context of the campus. BeginPath tells the canvas that we're about to draw a new shape. Then we use this command MoveTo. Now with moveTo and LineTo it makes actually a lot of sense to think about a pen actually moving on page. MoveTo moves a pen to a specific location on the canvas which is designated by the x and y coordinate here. So this command moves the pen to 10, 10 which is going to be about right here. You can think of move to as just moving the pen but the pen isn't making a mark yet. We're just deciding where we want to put it down on the page. But then when we call LineTo we actually put the pen down. And make his mark or in this case align to this position. So this line here with MoveTo 10,10. Moves the pen or hovers it over 10,10. Then when we call LineTo, we put the pen down and then move it to the position of 50, 50. Then we move it again and move it again. If we refresh the page we'll see that there's nothing there despite the fact that it looks like we made a shape that eventually goes back to where we started at 10, 10. That's because we need to call either a fill or a stroke command to finish up this path. Let's start by doing fill. I will go ahead and uncomment this line and save, come over here and hit Refresh. And we see that we create a filled shape. This made a triangle, so now we see a filled in triangle. If we comment in fill and then un-comment stroke, let's see what happens. We'll save. Come over here and hit Refresh and now we see a stroke triangle that's not filled in. There are many other drawing commands that you can use in the canvas and check out the link in the instructor notes if you want to learn more about them. But most of them behave similarly to what we see here. For this quiz we want you to recreate the shape that you see here with the canvas. I've gone ahead and marked a few points on the outside square and the inside triangle. This should make your life a little bit easier as you try to recreate it. After you've finished it, check this box to continue. So this is what I came up with. Remember, this is the shape that we're going for. I started off by drawing the outer rectangle by using strokeRect. We wanted it to start at 50, 50 and then it needs to be 100 by 100 pixels wide. Then we began the path. The path starts at 75, 75. So that just takes the pen and moves it here. Then we move it to 125, 125, but we create a line there. So the pen goes down and moves over. Then we create a line up to 125, 75 which takes the pen back up, and then actually we can stop there. With that shape, with that drawing, we can actually start to fill in. So, then we call fill and we'll get this. Let's go ahead and see if this code works. Okay. I've saved the file let's come over here and hit refresh, and low and behold we see the shape that we were going for. At this point you got the basics down for drawing. I recommend having some fun with it. See what kind of cool, crazy drawings you can make and post them in the forums. You know, it's really hard to make a drawing stand out, if it's only in black and white. We can change the colors of fills and strokes by using these two, fillStyle and strokeStyle. We can call fillStyle on the canvas context and in this case, we're going to set it to blue. You can use a name color. There are a 140 name colors, according to the HTML specification. And you can learn more about them in the instructor notes. Or you can use a hexadecimal color. So in this case we're setting the stroke style color to 33CC33. And we're calling it on the canvas. Hopefully these two should add some color to our drawing over here. Let's find out. I will save it. I will come over here and hit Refresh. And we see that in fact the fill actually did become blue. Our triangle is now blue, which is pretty cool, but it looks like strokeStyle here didn't have an effect. This hexadecimal color should be a shade of green, but we don't see any green over. And that's because, fillStyle and strokeStyle. Only applied to the fills and strokes that come after them, inside your script. So in this case because we're calling fill, after we set fillStyle, we have a nice blue triangle. But because we drew our stroke rectangle, well before we set the strokeStyle it didn't get affected. Let's go ahead and change that. So now we set the strokeStyle to this color before the rectangle. And we should see green rectangle instead. So let's save our script, come over to the browser and hit Refresh, and now the rectangle has a nice, light green outline. Okay, so I've gone ahead and pulled up a meme of myself. And let's analyze the way this text is drawn. Memes tend to use white text that is outlined in black. This makes it easy to read the text no matter what background it's over. So in this case, the like here is on top of a light background, but we can read it really easily because of the black outline. And then down here, over my dark shirt because the letters have white fills inside they're easily legible there too. So this is a nice strategy for making sure that text is always legible. The way this is accomplished is with a mix of fill and stroke text. To the scripts I've added this method, stroke text. Which is going to draw the string hello udacity. And it's going to put it at the point 50, 10. Now, note here that this 50 is going to be, in the case of this text, the lower left-hand corner of the text. So, if this were 0, 0 we wouldn't be able to see the text because the lower left-hand corner would be at zero and the rest of the text wouldn't be above the page. So that's just something to know. Let's go ahead and see what happens when we call this method. Come over here and hit Refresh. And we can see that we now have a hello udacity written in the same green color that we set earlier drawn at the position 50, 10. This string here could be any string and we can use JavaScript to set it. We could also use fillText instead. I'll go ahead and save that. Now we've got fillText. I'll come over here and hit refresh, and we've got hello udacity written in the same blue color that we set here. In addition to letting us decide what strings to draw on the page and where to draw them, the Canvas 2D context allows us to set a lot of other options, like for instance, font size, font style, and line width. Check the instructor notes for more information. Now that we've seen a little bit about what goes into making text on the canvas, let's see if you can recreate that classic name text. For this quiz, I want you to draw the phrase canvas memes with that iconic meme typography. Your text must use letters that have a black outline and a white file. You should use the Impact font, size 36 point, and the black outline around the text should have a width of 3 pixels. To learn more about how to set the font size and get the outlines right, check the links in the instructor notes. After you have recreated the text, check this box to continue. So this is what I've come up with. I've used the font method on the context and set it to 36 point impact and I've set the textAlign property on the context to center. You didn't have to do this, but you'll see why this is cool in a second. For the internal fillText, I set it to white. Then I set the fillText to CANVAS MEMES!, with an x position starting at half the width of the canvas and a y position of 40. This x position plus this text alignment of center makes sure that our text is centered on the page. Then for the strokes, I set the style to black, I set the line width to 3, then I finish up with the strokeText method, which takes in the same parameters as the fillText method from before. Let's go ahead and save this and see how it looks. Coming over to the browser, we see our Canvas Memes!, with white text and a black outline. Looks like we're ready to start making some memes. Now that you've learned the basics about drawing texts let's combine it all and make a simple mean generator. We've given you a head start with some basic HTML. Inside this HTML, you'll find a few things but let me point out what's important. Here in this section of HTML we're creating the top line and bottom line entries, which you can see right here. This is where a user will be able to type in text that they want to appear on the image. Inside the script tag, we'll find all the necessary components to start building the meme generator. We can see here, in this if statement, we're getting the text that was made in the top and bottom lines, and then we have this function called redraw meme where we get the canvas and select the context like we did before. After that we can see a place where your code goes. Then we've got this save file function which is going to let us use the toDataURL method to hopefully save our images. Then we've got this handleFileSelect method which will help us load a file from the disk as an image for the background. But the most important thing is that your code goes within this redraw mean function. So put together everything that you've learned so far. Use the background image and put some text over it to create this meme generator. So, now that you've got the starter code for a simple meme maker, can you use the canvas to load images with that iconic meme text? When you're done, check this box to continue. Let's take a look at what we've done inside a redraw meme. First things first, we need to draw the image. We check to see if the image exists by making sure it's not null, and then we use context.draw image to draw the image inside the canvas. Then we start creating our text attributes. Just like before, we set a font, we align it to center, we set the strokes to black with a width of three, and then set the fills to white. At this point, we could start drawing text, which is exactly what we start doing here. We want to make sure we have a top line and if we do, we draw the fill text first and then the stroke text. Notice that we're using the same canvas.width over two trick that we did before. This makes sure that the text shows up at the center of the Then we do the same thing with the bottom text. The only difference between the top text and the bottom text is the y position. Here we have y position at 40 pixels which is towards the top. And then for the y position at the bottom, we're going to select the canvas height and then just subtract 20 pixels from it. Remember, the canvas height here is going to be a big number, but the y coordinates get bigger the farther down you go. So this makes sense. This makes us 20 pixels above the bottom of the canvas. And with that, we should be good to go. Let's take a look. Okay, I've got the meme generator over here. Let's go ahead and open a file. And I've got myself as the background. I'll set the top text to CAM BE LIKE. And let's say the bottom text is going to say, I don't know, CANVAS IS AWESOME. Let's go ahead and hit save, and see if that works. And yeah, we've got our image to save. I will right click, save image as, and put it on the desktop. And with that, we've got our simple meme maker. In this lesson, we explored the basics of Canvas 2D while creating memes and drawing pictures. And we hope you had some fun creating some memes of your own. We'll see you in the next lesson where we'll be creating image filters by manipulating pixels. See you then. [MUSIC] As fun as that clip was to watch, it was ten times more fun to make. We did a silent film because the Canvas is a visual-only medium that doesn't provide sound. When we were brainstorming this project, we had to figure out how to do things typically done in video editing software, in the Canvas. We accomplished this by using a combination of tutorials we found online, source code, sometimes in other programming languages, that we converted to JavaScript, and other times, a description of the thing that we wanted to do. We don't have the time to teach you all of the effects we did, but we'll give you some pointers in this lesson. Check the instructor's notes for more details. Pixels make up the data of a photo. Every color imaginable can be represented with a combination of red, green and blue. If you're like me, before you knew it was a bad thing, you sat way too close to the TV screen while watching Saturday morning cartoons. Sitting so close, you could see the red, green and blue bands that made up a color. Depending on the type of image you're storing in the computer, you might also have an additional alpha channel that stores how solid or transparent the final color will be Image editing software like Photoshop and apps like Instagram or Snapchat allow you to apply visual effects to images. You might be thinking why would I want to edit images in a browser? It's a good question. For one thing, most photos only exist in digital formats. The computing power needed to process a single image is well, pretty much negligible. And doing things locally allows the user to make changes without a full round trip to the server and back. And most importantly, it's actually a lot of fun. Yeah. We might make an image black and white by averaging the red, green and blue values. Or we could invert the colors by assigning the pixels to the compliments of their current values. Or maybe we wanted to turn down the lights and turn on night vision mode. We'll be working without the help of an external library. But check the instructor notes for software packages and applications to make advance photo editing easy inside the canvas. The image backing a canvas is represented in Javascript with an Image Data object. It contains values for the width, and height of the source image in pixels, along with the data array containing the red, green, blue and alpha values for each pixel. The data property is usually represented by a U int eight clamped array. Now I know that sounds a little bit confusing. Let's break it down a bit. The U means that their rate is unsigned or contains only positive values. Int eight indicates that it will store 8-bit numbers. 8-bit positive numbers range from zero to 255. If JavaScript was making it easy for us, the data for one pixel would be separated from all the others like this. Instead, it's one giant list you have to parse when you apply effects. We can retrieve or modify the image data by calling one of these functions. Create image data initializes a blank image data object that you can modify. Getimagedata and putimagedata will retrieve or store data to a backing canvas. So let's start with something simple. Let's say we wanted to create an image and make every tenth pixel a solid green color. What code will we have to write to do that? After you're finished, click here when you're done. I mentioned a bit earlier that our pixel data is stored in one large list without any real separation between pixels. If we know how many components are in each pixel, we can use that data to figure out the number of pixels stored in the array. Once we have that number we can change the appropriate pixel component. The tricky part is you can't just set the green element. You also have to set the alpha channel to a non zero value as well. One of the effects we applied in the silent movie was converting images to grayscale. Write a function to convert an image to grayscale. Click here when you're done. This makeGreyScale function is fairly similar to what we did before. After retrieving the data from the imageData object, we call makePixelGrayScale on it, and then we store that information back into imageData. I used a slightly more optimized formula to calculate the grayscale of the pixel. It takes 30% of the red value, 59% of the green value and 11% of the blue value. So when we go over here and refresh our page, we'll see that it's gone to a grayscale. There's some interesting science that explains how and why we perceive color the way we do. See the instructor's notes for links if you'd like to learn more about it and also for a link to the image that we used in this example. These kinds of effects get more interesting when your source material is a set of moving pictures. The effects that we're doing on single images can be done in real time while showing a movie. Let's begin with a simple HTML page containing a video that we want to use with the canvas. We can see that it has a very empty script tag. Our video can be any given size, so hard coating dimensions is not optimal. Luckily for us, the video tag has a loaded metadata event that we can subscribe to and set the width and the height. Like loaded metadata, the play event tells us when the user has started playing the video. If the video isn't paused or ended, it's going to execute this draw function, which tells it to draw the image to the canvas. Before we refresh this page, let's see if you can predict what happens. What will this code do? It shows the video in sync with the source video. Or does it show a single frame of the video? The correct answer is it shows a single frame of the video. If we look a little bit closer at this code, we have a function that gets executed when a play event happens. We can only count on the play event to be fired when the video's started, either for the first time or if the video was previously paused. If the video is already playing, it doesn't get fired again. And therefore, this draw image only happens once. While we could solve our problem by calling our draw function with setInterval or setTimeout, the better way is to use requestAnimationFrame. requestAnimationFrame, only sends a request if the last frame is already finished drawing, or the window is actively being viewed. setInterval and setTimeout, execute no matter what. So if your drawing takes a really long time to finish a single frame, and your interval is really small, it can cause your browser to slow down or crash. So when I add a call to requestAnimationFrame, after this drawImage call here. It makes sure the canvas gets updated. So when we hit Play, it should keep it in sync. Good job. You're almost there. On to the final project. Is there anything else we should tell them? Yeah. You know, there is a lot more about Canvas to learn. It's built on JavaScript so you can create whatever you want with it. For example, if you wanted to explore gaming, we've left some links in the instructor notes to get you started.