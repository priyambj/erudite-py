You should get out and network. My parents must have told me this 100 times when I started looking for jobs. For the same reason of getting a job, your apps should get out and network, too. Because networking is such a key feature in so many iOS apps. Now the networking over here, this really isn't my forte. But you're in luck. I'm good at iOS networking, and I'm going to show you how to do it. If you've never heard about networks before, that's okay. In this course, the main prerequisite is that you're comfortable with UIkit, you've built a few apps, and that you're ready to learn. Throughout this course we're going to build four small apps that use networking. These apps will prepare you to build a portfolio app called, On The Map. Among other things, On The Map will allow you the Udacity student, to share your location and something awesome about you on a map with other Udacity students from around the world. To build On The Map, we'll need to learn how networking works, how to send and receive data over the network, and how to display that data that we receive. My name is Jared Parks and I'm going to be the instructor for this course. For now let's get to the point. You should go out and network. This course has five lessons that are depicted in this course map. But, before we dive into them, it's important to have a firm understanding of network basics. So, we're going to start with what I'm calling lesson zero. In this lesson, we're going to talk about how apps send and receive data over the network. Then, we'll show you how to implement this concept in iOS, using Swift. We'll do this by building a very simple app that downloads an image over the network and displays it to users. Also as we go through the lesson, we'll be keeping track of terms and concepts in a concept list to help us keep everything straight. You'll see it in just a minute. Let's get started by inspecting some popular apps. To get started I want to show you something really cool. This is a list of the top iOS apps for December 2014. And they're ranked by monthly active users. So if we take a look here, you can see USA Canada, Mexico. It's broken down this way. There are a lot of popular social apps. Facebook. There's Twitter over here. Instagram. FaceTime. What I'm going to do is, I'm going to take a subset of the USA list from apps one through ten and I want you to indicate which of these apps that you use. And, I'll tell you in a minute why we're doing this. So here you can see that same list, and I want you to put a check mark next to each of the apps that you use. If you haven't used any of these apps, you can check, I have used none of these apps. I imagine that most everyone checks something off this list. These are the apps that I've used, but there's one really important point that I want to make about these. Each one of these apps is using the network and your app should too. I mean, if you look at this list or any of the other list mobidia maintains, you'll see that every single app on those lists is using the network. So this has to be something that we add to our tool set. >From the list of apps that we just saw, I want to focus on one in particular, Facebook. And I want to use it as an example of how apps use the network. Facebook, for those of you who have not used it, is an app that allows people to share social data over the network. Users can share thoughts, photos, and videos of everything from cute kittens to current news items. Each of these features, uses the Network. More specifically, each of these features uses the network to send and receive data. Data can be text, images, video, or any media that's sent and received over the network. But in order to make use of data, apps have to be able to send and receive it. So, how does this happen? One of the most common ways, is by HTTP or Hyper Text Transfer Protocol You're actually using HTTP right now. If you take a look at your browser, there's probably something in the web address bar that looks like https://udacity.com. We're not going to worry about the s right now, but we'll focus on the http part. So, what exactly is HTTP? Or more importantly, what is a protocol? A protocol is a way of communicating, a standard operating procedure or the rules for communication. All these definitions work. For instance, think about shaking hands. In certain places around the world, it's customary to shake hands when you first meet someone. We might call this a protocol or following protocol. But sometimes even when people should shake hands, they don't. When this happens, the protocol isn't followed and for humans this is okay. If I forgot to shake your hand, then our conversation may start awkwardly but will probably keep chatting. This is very different from how computers use protocol. Computers must follow protocol, in order to communicate. If computers don't follow protocol, then they don't know what's going on. And this is where HTTP comes into the picture. HTTP is a protocol built specifically for communicating hypertext data between computers. This could consist of images, text, video. But for now, we can just think of all this as data. But how does HTTP work? As developers we don't really need to know the low-level details. And instead we can just look at a high-level abstraction. And we'll show that to you next. Imagine Jarred here. He represents the client, and he wants to make a request for the Udacity homepage. But to do so, he has to make an http request. The request itself can get pretty complex. But all Jarred really needs to know is the uniform resource locator or URL. For Jarred, he writes the URL for Udacity homepage. Once he's written that request, he places it on his desk to be handled. This request gets picked up by Jason, who then travels over the network to Jessica because she has the Udacity homepage. Jessica represents the server. Jessica analyzes the request to make sure that it's valid, and then she looks for the Udacity homepage. If she can't find it, she'll send an error code back to Jarred. But as we can see, Jessica's found the resource, and she prepares it to be sent back to Jarred. She gives the response to Jason, who then carries it back to Jarred. Finally, once Jason's brought the response back, the http request is finished. This specific example is an http get request. And we'll learn about the other types of requests later, also called methods. Of course, there are many complexities that I'm not mentioning right now. But all you really need to remember is to send and receive data via http, a client makes a request to a server. If you'd like to take a deeper look into http, check out our awesome video on http in the instructor notes. We just saw what a request to a server looks like, and we mentioned that the request used was a GET request, but what does it mean for a request to be a GET request. A GET request is a type of HTTP request where a client requests a specified resource from a server. For example, the client could make a GET request for an image on a server and then the server could return it back. A GET request is just one of several kinds of HTTP requests, also called HTTP methods, and it's the most common. Now you'll note, in this course I'm going to avoid using the term HTTP method to much because I don't want to confuse the term with what we know as methods in Swift. Let's look more closely at GET request by reusing or example of Udacity's homepage. When you visit Udacity's homepage in a web browser, you're making a GET request. By typing in the URL udacity.com in the address bar, you're specify a resource, in this case you'd ask the homepage from a server somewhere in the network. And you're saying, hey, get this for me. And when we hit enter, the request is made and we can see that it's a success because the server's responded with Udacity's homepage. But there's so much more happening than meets the eye when you make this request on a web browser. To show you what's really happening under the hood, I'm going to use the Chrome app called Postman. If you want to follow along I'll post the download link in the instructor notes, but you'll need to already have installed Google Chrome in order to use it. Okay, so here's the Postman app. At the top bar, you can make a request, much like we did in the web browser. But here to the left, we can also specify the type of request. For this request, we'll leave it as the default, which is GET. Now let's type in the URL for Udacity's homepage, and hit Send. Wow, okay, so there's a lot to observer here. Let's go step by step. For now, I'm going to hide this side panel, which shows a history of the request that we've made. Here at the top we have some tabs for Authorization, Headers, Pre-request script, and Tests. We're going to skip these for now and come back to them later. Lets focus our attention here on the Body. This is the response that the server returned when we made a GET request for you Udacity's homepage. But it doesn't look anything like the homepage we're used to seeing. It's just a bunch of html, CSS and JavaScript code. That's because all of this code is normally loaded, interpreted, and rendered by our web browser. If we click on the Preview option, we can see a low fidelity version of what this would look like if it was loaded by Chrome. Next, I want to look at the Status section where it says, 200 OK. This is what is know as a status code. A status code gives us a quick indication of whether the HTTP request succeeded, failed, or something else. There are many different possible status codes that can be returned for an HTTP request. I'll post a link in the instructor notes if you want to read about them more. The most important thing to note is that anytime we get a status code that begins with a 2, it means the request was successful. Let's hover over the status code so we can see a little bit of information about what it means. It says that a 200 status code is the standard response for a successful HTTP request, and that the actual response depends on the type of request that was used. Because we used a GET request up here, we're seeing the entity that corresponds to the requested resource, which in this case was the Udacity homepage and all of it's code. Also, at the bottom of this description, it mentions a new type of request, called a POST request, which we'll talk about later in this course. The next thing we see is the time it took to execute our request in milliseconds, which was 1,350 milliseconds. This is important to keep in mind. When we make requests over the network it does take some amount of time for us to get a response. It's not always instantaneous. So when we start making these requests in code, we'll have to consider what we want our app to do while it's waiting on a response. Now let's try a different URL. This time I'm going to use a URL that I know doesn't refer to a page on Udacity's website. I'll go ahead and hit Send. And this time we get a response, but notice the new status code, which is 404. If we hover over the status code it says the requested resource can't be found. Anytime we see a status code that begins with a 4 or 5, it indicates some kind of error. Bu, even though we have an error, we still get a response. If you look at the the response in Preview mode, we see that it's a page that says, we're sorry, what you're looking for doesn't exist. This is commonly referred to as a 404 page. Not all websites have these, but the awesome engineers at Udacity have created this 404 page so in case you request a page that doesn't exist, you still see something that feels like Udacity's normal website. Okay, I have one more example. This time let's request an image instead of a webpage. This is the kind of request we'll make when we build the app for this lesson. I'll type in my request and hit Send. This time we get a image as a response instead of HTML code. And that's the last point I want to make here, when we make HTTP requests the data that we get back can be images, text, HTML code and various other types of media. If you have some time I highly recommend that you download Postman yourself and experiment. I'll also post some links in the instructor notes for other similar tools in case you don't use Google Chrome as your normal browser. We've covered a handful of new concepts related to networks, so let's take a second to make sure we remember what's what. For each term listed here, I want you to match it with the correct description. The description's are an HTTP request where a client requests a specified resource from a server, another term for the type of HTTP request specifies a location for retrieving data over the network, a number returned in response to a HTTP request that indicates the results of the request, and finally, the role that an iPhone plays is accessing data from the network. For example, it's downloading images from Facebook. Now for each description, match the number for the term that correctly describes it. Hopefully this was pretty straight forward. If not, these terms will become more familiar with practice. The first description should be matched with 3 for a GET request. A get request is where a client requests a specified resource from a server. Next, you should have marked 5 for HTTP method. An HTTP method is another word for the type or kind of HTTP request that's being made. For example, a GET request is one type of HTTP method. Then for specifies a location for retrieving data over the network, we should have marked 2 for URL. As we'll come to see, URL's can be much more complex than something like www.udacity.com. The next answer is 1, for status code. A status code is a number returned by an HTTP response that indicates the result of the request. They can be values like 200 or success, or 401 for unauthorized. Finally, the last answer is 4 for client. If we're downloading images from Facebook to an iPhone, then the iPhone is the client and the computer that's providing the images from Facebook is the server. All right, enough of the terms. It's time to start making requests in Swift. Let's see what all this looks like in SWF. To begin, you'll want to download the starter project for the ImageRequest app. A download link's posted in the instructor notes. I've downloaded the project already, so let's run it and see what we have. The interface is extremely simple. There's just a single label in the center and it says that an image will load over this label. If we stop the app and go to the Main.storyboard, we can see there's actually an image view too, but it currently doesn't have an image. It'll be our job to get an image from the Internet and display it within this image view. Now, let's open the ViewController.swiftfall. We're going to be doing all our networking code right within its viewDidLoad method. The first class I want to introduce you to is NSURL. As you might have guessed, this class lets us represent a URL. I'll create an instance of it called imageURL and initialize it using a URL string that I copied beforehand. This is a URL for a cat image that I like. Feel free to use your own URL, but make sure that it's HTTPS. We haven't talked about HTTPS yet, but we'll see why it's important later in this lesson. Now that we have a URL, the next step is making a request. The class that we'll use for this is called NSURLSession. NSURLSession is a class that can manage network request on our behalf. We can create our own NSURLSessions with custom settings or we can use the shared NSURLSession, which comes preloaded with default settings. The shared NSURLSession is what is known as a singleton. If you've never heard of a singleton before, it's a special kind of object that can only be instantiated once. So if I use the shared NSURLSession in this SWF file and then in another file I use the shared NSURLSession, I'm actually still referring to the same object in both files, because it's a singleton and there can only ever be one. The use of singletons is common when it makes sense to only have one instance of an object. Now this distinctions may not be incredibly important to you now, but I wanted you to know what the term meant in case you see it again. Anyways, we don't need to make custom NSURLSessions, so we'll just use the shared NSURLSession for now. If you are interested in creating your own custom NSURLSessions, then you can look at the NSURLSession configuration class. It allows you to change things like the amount you're willing to wait for a network request before cancelling it. Let's move ahead. The next thing I want to do is supply out NSURL session with a request. But first, there are a few important things that I want to point out. What we've been calling requests, the NSURL session refers to as tasks. Also, any task used by NSURL session is a sub class of NSURL session tasks. Let's break that down. There are three main tasks that we can work with, data task, download task, and upload task. A data task, or an NSURLSession data task, returns data from the network directly into memory as one or more NS data objects. The key word for remembering this type of task is data. Data tasks are good for short lived requests, and we'll be using them exclusively in this course. A download task, or NSURL session download task, returns data from the network into a temporary file. Think of these tasks like downloading a file from the Internet, when the task completes you have a file to work with. And finally, the upload task, or NSURL upload session task. These kinds of tasks are specialized for uploading content. Like I said, in this course we're just going to focus on data task. To recap, in the code we have the image URL and we have the shared NSURL session. So, now we're ready to make our request, or a task in this case. To create an NSURL session data task, we need to use the NSURL sessions method called data task with URL. We'll be using the version of this method that takes the URL and a closure called a completionHandler and it returns a NSURLSession data task. So I'll go ahead and capture the return value, which is the task, and then I'll specify our imageURL. And now let's talk about the completionHandler. The completionHandler is just like any other closure. It's named completionHandler because it's executed after the data task completes and we can't really be sure when that will happen. The task might complete in a few milliseconds, or it might take a whole minute. But that's the real power of this closure. It's like us saying I don't really know when this task is going to complete, but when it does run this block of code. Now instead of using this closure, we could use NSURL session's family of delegates to handle running code after the task completes but we won't be doing that in this course. If you're interested, I'll post links in the instructor notes that cover the NSURL session delegates in more detail. Now this completion handler takes three parameters. The types of those parameters are NS data, NS URL response, and NS error. Now if you haven't seen those types before, don't worry. We'll slowly introduce them. For their local parameter names I'll call them data, response, and error. For now let's ignore all of them and try printing task finish when the task completes. And we'll build and run this. Hm, well, it doesn't appear to be working because our print statement isn't showing up. Let's talk about why this is next. We created our data task, but print statement is not executing. What's going on? Well, the problem is the NSURL session doesn't directly run tasks for us. Instead it gives us methods to create tasks, but then we're responsible for starting them ourselves. Now, this may seem tedious, but it actually gives us much more flexibility for starting, stopping, and resuming tasks. To start the task, we just need to call the resume method on the task itself. Now let's run this. There we go, now that's the print statement we were expecting. The next step will be to take the data that's Its a completion handler and create an image that we can display to the user. Let's look at Apple's documentation for the data task with URL completion handler method. In the discussion section, there's this one really important blur that I want to focus on. It says, If the request completes successfully, the data parameter of the completion handler block contains the resource data. And the air parameter's nil, but if the request fails the data parameter is nil, and air parameter contains information about the failure. So back in the code we can use this information to our advantage and check first to see if the air is nil. As long as the air is nill then our data should be good to use. Now, how can we take our data, which is in the form of an NS data object, and turn it into an image that we can display? Actually, it's quite easy. The UI image class has a handy initializer that can construct an image directly from NS data. So we'll use it to create an image. And then we'll set the image views image property to our downloaded image. This looks great, let's run it and see if it works. Well, somethings wrong again, we're not getting our image. Let me try something else, since I have a little experience dealing with these kind of problems. In the simulator, I'm going to simulate hitting the home button. The hot key for this is command shift h, there we go. Or you can select it from the simulator's toolbar here at the top. There it is, home button. This takes us out of the app. Now, let's reopen it. There's our image. How come it didn't show up at first? Let's investigate this problem next. The reason our image is not showing up immediately has to do with the fact that our code is being executed in the background. Now, I know what you may be thinking, what's the background? Why's our code there, and how does this affect my app? Don't panic. Without getting into the details, we're going to use a method that fixes this problem. The method we'll use will take any updates that we're making to the UI, like displaying our image, and then run them in the foreground, or the main executing environment. Let's see this now. Back in our project, we've been provided with a special function called performUIUpdatesOnMain. This function is defined on the GCDBlackBox Swift file. Now the reason we use the term blackbox in the name of that Swift file is because a blackbox refers to something you can use without knowing the internal details. So for the purposes of this course, you can use the function to performUIUpdatesOnMain without knowing how it's implemented. You should just call this function anytime you need to make updates to the UI inside of the completion handler of a network task. Now, looking at this method, we can see that it takes a closure that has no parameters, and returns void or nothing. And since the closure is the only parameter, we can use the trailing closure syntax. All we need to do is just relocate any code responsible for updating the UI, and place it inside this closure. So in our case it's just this line of code here. Now let's run the project. Nice, there we go. That's what we want. At this point, you should have successfully made your first network request, but let's say, I want to load a different image. Specifically, let's say I want to load an image that uses HTTP instead of HTTPS. Let's switch the URL and rerun our project. Now when we launch the app, we see this error. It says, App Transport Security has blocked cleartext HTTP resource load since it's insecure. Temporary exceptions can be configured in your app's Info.plist file. What's this all about? Well, it has to do with Apple's new security feature called App Transport Security or ATS. ATS helps our apps be more secure by forcing them to abide by certain security standards and as we can see in this little documentation, one such standard is the recommendation to use HTTPS exclusively, but what's HTTPS? Well, it's like HTTP, but with an added layer of security. We'll talk about it more later in this course, but for now, just know that HTTPS helps ensure that the data we send back and forth across the network is more secure. So, does this mean that we can't use things that use HTTP? Not exactly. We can actually enable the use of HTTP in our apps by changing some settings in the Info.plist file. This is what was recommended in the debugger. So, let's go to the Info.plist file. Here at the top, let's click the plus sign and add a new key value pair. Start typing app transport and select App Transport Security Settings. This should automatically default to a dictionary value and we can add additional settings to allow HTTP. Click the arrow to expand the ATS settings and then click the plus and the setting we'll want to use is called Allow Arbitrary Loads. This is a Boolean value and we'll set it to YES. Setting this to YES is like saying, yes, I want to allow any HTTP request for my app. Now we can actually be more specific and configure settings that are like saying, I want HTTP request, but only for a specific domain. For instance, .com and I won't show that now, but I'll post a how to link in the instructor notes, if you're interested. With these settings changed, let's try running our project, nice. There we go. Our request works and there's no error. There's one more thing that I want to say about ATS. As app developers, we may run into situations where the data we want to access over the network only uses HTTP. So, how do we follow Apple's guidelines and try to move to HTTPS? Is there anything that we can do? Well, if you find yourself in that situation, it's somewhat out of your hands. The switch from HTTP to HTTPS is something that the individual or company running the server where you access the data is responsible for. So I'd recommend getting in touch with them, encouraging them to upgrade their security standards. If they're unable to upgrade to HTTPS, you may also consider using a different server or resource all together. Whatever the case, the security of data should always be top priority. Otherwise, users may not be willing to download your apps. As an exercise, try and make the same changes to your version of the image request app. Your app should be able to download and display an image using HTTP or HTTPS. When you've made these changes and successfully tested the app, check this box. In our app, we just finished using what we call a black box for handling UI updates. We're going to continue to use that code for the remainder of the course. I'm going to give you two choices, if you want to continue the course without knowing how the black box works, then take this blue pill. But if you want to see how deep the rabbit hole goes, the black box goes, then take this red pill. The choice is yours. If you're like me, you're taking the blue pill. I've got plenty to worry about already. Let's keep using the black box and we can learn more about how it works later. Also, my name's Eden. I'll be popping in every now and then to explain certain concepts and see how you're getting along. See you in the next lesson. At the end of each lesson, there'll be an exercise called networking with you. In networking with you, I want you to synthesize and organize what you've learned in this lesson. I also want to provide you the opportunity to give us feedback on how we can improve the lesson. So what did you learn in this lesson? Let us know in the box below. In lesson one we'll build an app called sleeping in the library that uses the flicker API to retrieve and display images of people sleeping in the library. This will be our first exposure to a web service, a core concept in this course. To build this we're going to learn all about networks. In lesson two we'll create flick finder an app that uses the flicker API to retrieve and display images except this time you can search with a phrase or location. Here we'll learn how to parse data from the network and then display it to our users. Next in lesson three we'll build the my favorite movies app, by using the movie data base API. In this lesson we'll learn the difference between user and anonymously access data. Then, in lesson four, we'll build on the app from lesson three to create the movie manager. This will require us to clean up our networking code by using good MVC design. Then, in lesson five, we'll get started on the course project called on the map. This will let you showcase your skills on the map with other udacity students from around the world. For instance, you can share a recent blog post, your LinkedIn profile or any of the projects that you've created. So let's get started. So far we've seen that HTTP can be used to request content like what's in a web page, images, text, video. But for the apps that we'll be writing, we'll use HTTP in a slightly different way. Instead of using URL's like Udacity.com, we'll use special URL's that correspond to methods like getImageData, that are made available by web services. Web services sometimes are also referred to as APIs but don't get confused, they mean the same thing. I'm going to take a look at an example from the Flickr API. We're going to look at flicker.people.getPublicPhotos. This method returns some kind of image data back to our client or an app. We're going to look at flickr's documentation for this method now. I posted a link in the instructor notes. So this is the documentation for get public photos and there's something I want to draw to your attention first, and that is the use of arguments. So the arguments listed here are a lot like the arguments that you'd see for a swift function call. And you'll also notice that some of them are required like APIK while others are not like safe search. Now, this is really cool here at the bottom, this is the API explorer. Not all API's have this, but flicker does and it's extremely useful. The API explorer allows us to test the API's methods before using them in our apps. For this method, it shows the only required argument is the user ID. This is only a half truth, the API key is also required but in the API explorer, it automatically includes a test API key for us. For the user ID argument, I'll go ahead and use my user ID that I've copied ahead of time. And then under the extras argument, I'll type url_m. If you read the documentation, the url_m option specifies that we want the result of this method to include URL's for medium images. You'll see that in just a second. And last, we want to change the output to JSON, our JavaScript object notation which we'll talk about more later in this lesson. And let's call the method. And after it's called, we can see the results below. In the results we see this information about photos and then within photos it looks like there's a group of individual photos. And judging by the total value we see here of 13, it appears there's probably 13 total photos. For each photo we can see this owner ID which is the same as my user ID. And we also see an ID for the image. If we keep scrolling to the right there's more values, and here is the URL underscore in value that we specified in the extras argument. If we copy one of these, we can paste it into the browser to see the image. The URL seems to be not working. And I think it's because these extra slash characters that have been added before each of the forward slashes. So let me remove these. And I'm removing them manually now, but normally, these slash characters will get removed when we create an NS URL in code. And let's try this. Nice! This is a picture of Eloise, this is my wife's cat. I actually didn't really like Eloise very much at first, but she's kind of grown on me over time. Back in the API explorer, let's recap on what's happening. The results being returned by this, get public photos method is this Jayson data representing the photos in my public photo stream. And, they're being returned as Jayson because that's what we specified here, in the output. If we scroll all the way to the bottom, we see this really long and ugly URL. I'll copy this and paste it back into our browser. If we visit this link, we get the exact same thing that we saw in the API explorer. In fact, the URL that we're using here is extremely similar to the URL our app will use to receive data from Flickr. Now if we look more closely at the URL itself, we can see the arguments that we passed in. We didn't pass in the method argument that was implicit in the explorer. But if we keep scrolling here to the right past the API key, we can see my user ID here. And then we can see the extras argument and the url_m. There are also these ampersands that seem to separate the different argument values. So there's one there, there's one there, and you can see them continuing on. Now the ampersands themselves are part of a standard for how arguments are sent in an URL. Speaking of standards, I should note that URL's can only be sent over the Internet using the ASCII character set. The ASCII character set is a simple way of representing characters on a computer, where character values can also be represented using a number. Here are some example ASCII characters and their corresponding values. I've posted a link in the instructor notes if you want to read more about them. In some cases we may want to use URL that contains characters that are considered unsafe asking characters such as the plus sign. When this happens we have to encode or escape these unsafe characters into valid ASCII characters in the URL. The escape version of a plus sign is percent sign, two B, and each of those characters, the percent sign, the two and the B are valid, safe ASCII characters Here's another example. This is a URL that uses Flickr's flickr.photos.search method. One of the arguments in this message is called text, which is a string representing a text search. In this URL the text is equal to red percent, two, B blue. This is the escaped or encoded version of the actual text which is red plus blue. Since the plus sign is considered unsafe ASCII it's escaped with the characters percent, two B. We've gotten our first taste of web services with Flickr, and what I want to do is expose you to some of the other data that's out there, because there's a ton. So I'm going to give you a description for some data that a developer might want to use and I want you to match that with a web service that best fits the description. So for developer A, let's say I want to access information about American legislators, districts, committees, bills, and votes. For developer B, I want to build an app that displays player stats and game results from the game League of Legends. And that's a good one. I play that one, actually, a lot. For Developer C, I want to display the locations of restaurants in a city or town. For Developer D, I want to access information about the economies of countries from around the world. And Developer E, I want to display information about sales and products at top designer labels. For options, we have the OpenMenu API, the World Bank API, Sunlight APIs, the Gilt API, and Riot Games API. So to answer these questions, I want you to put the number of the web service in the text box for the developer it best helps over here on the left. So if you went searching through these APIs, which I hope you did. You'll find that each one of them is made for very special kinds of data. For Developer A, the Sunlight APIs actually work really well. They have all kinds of information about legislators, districts, and everything mentioned. For Developer B, number five, Riot Games API works the best, and that makes sense. Riot Games makes League of Legends, so they have an API for it. For Developer C, the OpenMenu API works. It gives them the ability to display the locations of restaurants that they want. For Developer D, the World Bank API works well. This gives them information about GDP and other economic statistics for countries around the world. And then last, Developer E, number four, the Gilt API. So Gilt maintains all kinds of information about top designer labels. And that's what you'd want to use. So, these five examples are really only scratching the surface of the kind of data that's out there. You know, this is something as a developer that you'll do a lot. If you want to build an app, and you know what kind of data you need, the first thing you do is go search about it, and see if there's an API available. If there isn't one, you can actually build one yourself. And, I'm not going to cover that in this class, but I'll put some links in the instructor notes if you're interested. For now let's go ahead and move on and start building our first app. It's time to build our first networking app, Sleeping in the Library. This app makes use of the Flickr API to display images from a gallery of images called Sleeping in the Library. Here's the final product. You open the app, and then you press this button, and voila, there's a picture of somebody sleeping in the library. By building this app, we'll learn to make use of our first API call. Let's get started. So to use an API, you generally have to go through a couple of steps. Typically, you have to sign up for an account with the service, if you don't have one already. You have to register the app you're making. And later on, in order to make requests, there's usually some sort of authentication process involved. In order to keep this setup simple for now, our Sleeping in the Library app is going to use the Flickr API. Unlike other similar services, Flickr's API allows us to bypass a few of the normal set up steps, requiring us to only sign up and register. We'll cover the parts skipped, namely the authentication flow, later in the course. Signing up for a service like Flickr or Yahoo is pretty straightforward, so let's talk about registration. When you register an app, you're usually given what's called an API key and sometimes additional keys as well. That are used to uniquely identify your app. The reason for a service to want to uniquely identify your app is so that they can detect requests coming from your app and protect against apps that are making too many requests. This allows the service to ensure apps don't do harmful stuff, like say, flood the network with so many requests that their server shuts down. So you can see why these identification keys would come in handy. So let's get started using our API. You'll want to sign up for a Yahoo account if you don't have one already. I know this part may be a little bit annoying, but trust me this does make our lives simpler. Click create an app, then you'll want to get your API key. You want to click non-commercial, since we don't plan on making any money off on pictures of people sleeping in the library. You'll then fill out these two fields, and upon submitting, you'll receive a key and secret. I'm going to call this Sleeping in the library. Copy these two values and paste them somewhere safe. You'll need them soon. Lastly, you'll want to take some time and look around the Flickr API Documentation. This will give you an idea of some of the methods that you could potentially use. If you've gone through the instructions for the app, the first thing you'll need to do is get setup with Flickr. So once you've joined Flickr and gotten a Yahoo account, and you've gotten a Flickr API key, check this box. If you look around the flickr documentation you'll see there's a bunch of different methods. And looking around the documentation to see what methods are available is actually a really good practice. This is something that developers do all the time once they've picked an API. You know once you know that the API has for instance image information you want to know how can I access it. So as an exercise I'm going to give you a couple different things that you might want to do with the flickr API and then I want you to tell me which method I should use. So which method should I use if I want to get a list of photos for a gallery? What if I want to get a list of public photos for the given user, how about the number of views comments and favorites on a photo for a given date? And finally, to get the URL for a user's photos? For each of these questions, I want you to write the name of the method in the text box next to it. So the answer to the first one is Flicker.galleries.getphotos. The second one is flicker.people.getpublicphotos. The third one is flicker.stats.getphotostats and the last one is flicker.urls.getuserphotos. So each of these methods is pretty intuitively named. This is a good job on Flickr. And not all APIs name theirs so clearly, so sometimes you got to do a little bit more digging. For the Sleeping in the Library app, we're going to use the flickr.galleries.getPhotos method. Let's play around with this method in the Flickr's API explorer before we start coding. Aside from the API key, this method only has one required argument, the gallery_id. I've gone ahead and copy the gallery_id you'll use in this project and pasted it in. Like before, we need to provide url_m in the extras argument. Otherwise theirs responsible had URLs for the images we want to display. Now let's call the method. This is strange. This doesn't quite look like what we had with my public photo stream when we were testing earlier. And that's because we forgot to change the response format to JSON, and we're currently looking at an XML response. Now you'll notice the XML looks quite similar to JSON, and I'm showing this on purpose to again reinforce the idea that data can be sent and received in many different formats over the network. Let's switch this back to JSON and then call the method again. Now this is what we expected. These results are almost identical to what we saw with my public photo stream. But how are we going to get this data loaded into our app? Well, my recommendation is that we start with the URL itself, the one that we see here on the bottom. Let's copy it and look at it piece by piece. Everything leading up to the question mark specifies the API. Then after the question mark, we have a series of argument names followed by equal signs and their value. Each argument value pair is separated also by an ampersand. I'm going to fix this URL by removing the last argument value because it's only necessary in the API explorer. For the Sleeping In The Library app we just need these argument value pairs. And remember, when you build your version of the app, you'll need to use your own API key because the one provided here is just a temporary one given by the API explorer. Now let's test a URL like this using the Postman tool that we saw earlier. And the results look good. These are essentially the same results that we had in the API explorer, except they're formatted a little bit nicer. And with that I think we're ready to get started doing this in code. To get started with SleepingInTheLibrary, you'll want to download the starter project for the app. The download link is posted in the instructor notes. The UI is already built for this app, so we can focus on just the networking aspects. If we run the app, we have a title label at the top, and then we have a button at the bottom that'll grab a new image from Flickr. Right now, if we tap the button, it just disables the UI and it waits for an image to be loaded from Flickr. Back in our Story Board, we can see that there's an image view for our image, as well as a label, this photo title label that we can use to display any text associated with the image. Then in the viewController.swift file, we have a single action, grabNewImage, that's called when the button is pressed. In the action, we disabled the UI so that we can't ask for a new image while waiting for another image to load. And then we call the getImageFromFlickr method. This is where we'll start writing our networking code. First, we'll create the NSURL. We can do this directly just by copying the URL like we saw in the API Explorer. But from a design standpoint something doesn't really feel right about this. It's not very maintainable. What if the names for the arguments change, or we want to change the URL and use different arguments? It'd be much better if we broke this URL to pieces. The good news is, is we're going to help you out a little bit. If you've been poking around, you may have noticed that we've created a separate Swift file, Constants.swift, where we've defined all the constants for doing just that, breaking the URL into pieces. Here in this file there are structs that contain constants for the different parameter keys and values that we want to use in our URL. So what's with the static keyword and also what are the structs that are contained within the constant struct? First, the static keyword, it's similar to the class keyword. And what it's doing here is it's saying, this Method property, it doesn't belong to FlickrParameterKeys struct instances, but instead it belongs to the whole struct itself. Now, that may sound a little confusing, but the benefit of this approach is that we can refer to these constant values using a really nice dot notation, and it's very intuitive. So let me show you what I'm talking about. And this is also going to help explain the structs within structs that we saw in the constants file. So if we want to specify the method, let me make sure which one that is, so FlickrPrameterKeys, and then the method value, we can do this. And just like that, we're referring to a constant in this very nice dot notation that kind of goes left to right and it reads in a very intuitive way. Similarly, we could specify the API key by going Constants.Flickr. Nope it's in Flickr, I think values, ParameterValues, here we go. API key. Like so. And because of each of these properties, the method and the API key are declared as static, we never have to make instants of the constant struct to use them. Now you don't have to do it this way but we've chosen it because it's a nice way to maintain all the constant values in one place, where we can easily change them. Now, back in the view controller, we can use these constants to build the URL. And I'll add a print statement for good measure. So let's build and run, and test if our URL is what we want. And this is not bad. You'll notice that in the API key argument here I have the YOUR API KEY value. You want to substitute your API key in there. But I think we can do a lot better than this. This might be harder to see than the first one was. I propose that we optimize the building of our URL by creating a method that formats all of the arguments. And this will be more reusable obviously, and it'll also give us an opportunity to escape any of the characters in the arguments that might include unsafe ASCII characters. Let's do this next. We'll start by writing a new method called escapedParameters. We're going to want this method to take a dictionary of the argument value, aka keyvalue pairs in the URL, so that's what this is. And then we want to return a string where they're correctly formatted and don't have unsafe ASCII characters. And also, each pair should be separated by an ampersand. I think this will start to make more sense as we start building this method. The first thing we'll do is check if any parameters are provided. If none are provided we can just return the empty string. Otherwise, let's create an array to store each key value pair as we format it. Then let's loop through the dictionary looking at the key value pairs. For the keys, I don't think we really need to do anything to them, they're the argument names themselves. And we can assume that they're always safe ASCII characters. And this is probably a safe assumption for this simple app and just knowing that the Flickr API hasn't used key values or argument names that are unsafe ASCII. Then for the values, we need to convert them into strings. Because if we look at the method itself, we're taking a string, AnyObject dictionary, so it could be that we pass in a value that's a number, and we need to convert that number to a string. So we'll add this line of code to convert the value into a string. And then once it's a string, we need to convert the string itself into an ASCII compliant version of a string. And we can do that by using this nice stringByAddingPercentEncodingWith all characters allowed, method. And that's definitely a mouthful for a method name, but at least we know exactly what it does. It takes one argument, a character set, and that character set specifies which characters are going to be allowed in the string that it returns. And in our case, there's a nice character set that we can use called NSCharacterSet.URLQueryAllowedCharacter- Set. And this is going to return characters that are only considered safe ASCII. Then once we have the key and value as safe ASCII strings, we can add the equal sign in the middle like this, and we can append it to our keyValuePairs array. And once we've converted all the keyValuePairs, we can join them into one string with the joinWithSeparator method. And the separator that we want to use is the ampersand. And we also can't forget to add the question mark to the beginning, that's what's going to set off all of our argument value, or key value pairs. Now once you've implemented this method yourself, you should be able to call it using a dictionary like this. So if you were to use these lines of code and a correct version of the escape parameters that you've implemented, what would the output be? So take some time and write this method yourself, and then test your implementation using this code, and enter your answer in this text box. If you correctly implemented the escapeP arameters method, then you should have returned some variation of the string. And the reason I'm saying variation is because the argument name pairs could show up in a different order. Right now, the quiz argument is the first one to show up in this particular answer. But because we can't be sure how our escapeParameters method is going to iterate through the dictionary the argument key pairs could show up in any particular order. If you correctly implemented the escape parameters method then you should have returned some variation of this string. And the reason I'm saying variation is because the parameter name value pairs could show up in a different order. Right now, the quiz parameter is the first one to show up in this particular answer. But because we can't be sure how escape parameters is going to iterate through the dictionary of parameters, the parameter name value pairs could show up in any particular order. We can now use our escapedParameters method and concatenate its result with the rest of the URL for the Flickr API and I'll go ahead and turn this string into an NSURL object. But unlike before, we're not going to make a request using an NSURL. Instead we're going to use an NSURL request object, which is a class that we can wrap around an NSURL and we can do it like so. By wrap, I mean that we can create an NSURLRequest from an NSURL and then it allows us to have access to more of the request options. For instance, we have access to the request.HTTPMethod. Now I haven't mentioned HTTP methods in awhile, but remember, this is a term for the type of request that's being made. And for this request, we're going to use the HTTPGet method. But since get is the default method, we don't actually have to do anything with this particular property, we don't need to change it. I should also mention that when we're using NSURLRequest, we actually can't change it. But there is a different class called NSMutableURLRequests that gives us more configurability for the request itself and allow us to change the HTTP method, for instance, but we're not going to use that until later in this course. Now with our request object, we can use the shared NSURLSession and the data task with request method to make our data task and it takes that same trailing closure with the data response and error parameters. And I'll say, if there's no errors than let's just print the data and also we'll need to remember to resume the task for the task to actually start. Now, let's run the project. Grab an image. What's up with this output. It doesn't look like the JSON we've seen before in the API Explorer. There's a reason for this and let's tackle it next. This doesn't look like the JSON we're used to. Well, the truth is this data is JSON. It's just JSON in it's raw byte form. That's what all these hex numbers are. In order to actually understand and use it, we'll need to convert it from raw JSON into an object we can use in Swift. And guess what? Swift has just the class for us. It's called NSJSONSerialization, and it allows us to convert JSON into objects like arrays or dictionaries and vice versa. Since we want to go from JSON data to an object, we'll use a method called JSON object with data. This take our raw JSON data and returns either an NS dictionary or an NS array, which are both usable in Swift. Okay, let's go use it in our code. We can start back in this little spot where we're printing the raw data. Now, instead of printing it, let's convert it. We should start by using optional binding to get our data out of optional form and make sure that it exists. Then, let's create an object that will eventually contain our parsed dictionary result. We can call it parsed result. And now, let's add in that method NSJSONSerialization.JSONObjectWithData with data as our first parameter, and AllowFragments as the second parameter. And save that result to our parsedResult. What's this? Can call throw, but it's not marked with try and the error is not handled. It looks like this method can throw an error. Let's use Swift's do catch block and the try keyword to handle it. If you haven't seen this error handling syntax before, or would like a refresher, feel free to check out the Swift syntax course. But overall, this will be pretty straightforward. Let's add the do catch block like so. And then, put in the try keyword in front of the potentially problematic method call. And that looks like that was it. Should we try and print? First, we should probably change this data to parsedResult. Let's try and print it. Grab new image. Cool. This looks more like it. For the record, serialization means converting an object into a stream of bytes, and deserialization usually means the opposite, converting a stream of bytes into an object. But for simplicity, Apple groups these both under MSJSON serialization. Let's break down the process of parsing JSON. JSON, or JavaScript Object Notation, is a popular way of describing a collection of key value pairs. The keys could be represented as strings, and the values can be other strings, numbers, arrays, or even dictionaries. For the web services that we'll interact with in this course, as well as many others, we can use JSON to pass data to and from our apps. For now, I just want you to focus on getting JSON data and then parsing it. We can break this process down into three steps. First get the raw JSON data. Second, parse the JSON data into a usable foundation object, such as an NS dictionary or an NS array. And third, grab the data from the foundation object. These steps will make more sense in code, so let's demonstrate them now. With our JSON data converted into a foundation object, how do we use it? Let's go back to the postman tool to see where to start. In our JSON response, if you look at the very beginning we can see that it starts with the curly brace. And if we scroll down to the bottom, the very bottom on line 251, we can see that it ends in a curly brace as well. This is indicative of a JSON Object, which in SWF is comparable to a dictionary. This means that when we call the JSONObjectWithData method, that we should be getting some kind of dictionary back. It's actually an NSDictionary and we can interact with it just like a SWF dictionary. So the next thing we need to do if we know that we have a dictionary is that we need to identify the key value pairs that we're interested in. Ultimately we know that we want to get one of the url_m values and then also the title value. We need the URL in order to display the image to the user and we'll need the title for the title label in the U.I., but, to get at these values, we have to take a top down approach. Because at the highest level, we have this photos key value pair that contains everything. And we can see that the photos value starts with the curly brace and ends with a curly brace, so this is just another JSON object and it can be represented in SWF as a dictionary. So back in our code let's create a photos dictionary and we'll want to populate this dictionary with the values stored at the photos key. So this constant is the same thing as photos like this. But I'll leave it as a constant for now. And then we want to try to convert it to a string AnyObject dictionary. And we'll use this if let syntax in case somehow our response doesn't have this key value pair, then it won't crash. Also, know that the reason that we're using the String and any object dictionary is because we know that the JSON keys themselves are strings, but then the values, they could be any other object. They could be a JSON object, which is another dictionary. It could be a number. It could be a string. We don't know. And we'll just print the photosDictionary. Awesome, our output looks similar and we're starting to get closer to the values that we want. Now, back in Postman, the next key value pair that we want to target is for the key, photo. This value starts with a bracket and it ends with a bracket. And that's indicative of a JSON array, which is comparable to a SWF array. But then the question becomes, what type of array? Well, if we look closely it looks like each element here in the array is itself another JSON object, and each item is separated by a comma. So we have a JSON object here, and actually I'll just collapse it, and we have a comma, then we have another JSON object. Another JSON object, and so forth. This means in SWF, we can use an array of dictionaries. So back in our code, let's get the array of dictionaries, and we're going to call this the photo array. That's stored at the photo key, and this is critical, of the photos dictionary. Remember it's contained within the photos dictionary. And then we'll create an array of dictionaries. Notice the outer brackets denote the array itself. And within the brackets we have the array's type, which are string any object dictionaries. And to make sure this works, let's try printing the first photo dictionary in the array. Nice it works. We're almost there. But before we continue forward I want to make sure you can follow my steps. That is, get the photos dictionary at the photos key. Then in the photos dictionary, get the array of photo dictionaries at the "photo" key. I know, this sounds confusing, but this is the way the results are returned. And finally, print the first photo dictionary. When you're done, check this box and continue. All right, so now we have this array of dictionaries for each photo in the results. We could use the first photo dictionary in the array and populate the image view and the label and call it done. But to get the user the best experience, we should pick a random photo from these dictionaries so that a user has a chance to see a different image each time they press the button in the app. Let's start by generating a random index that we can use to select a random photo dictionary. We can do this by using the arc4random_uniform function and this returns a number from zero to the argument that we specify. In this case we want a number from 0 to the highest possible index of the photoArray. And you'll notice that we've done this casting to a UInt32 type because that's what this function expects. We'll do this in the same way that we access the other values, but we want to make sure that we use the randomly chosen photo dictionary here and here. And we convert both of the values to strings. So we're converting the MediumURL to a string, and we're converting the title here to a string. Then to check that everything works properly, let's add some print statements and run the app. Awesome, now we're getting the URL and the title. And I know this is a really long bad title, but it is a title. We're so close to being done. Now we just need to use the URL in the title to populate our UI. For the image we need to create some image data using the URL and then use that data to create the UI image like we saw in lesson zero. So I'll create the url for the image and then I'll create the image data from the url, and then from the image data, we can create our image. For the title we can just set the text directly. But we have to remember that we need to make these UIUpdatesOnMain. So we can pull out our trust black box called performUIUpdatesOnMain, and we'll add our UI updates inside the closure that we pass it. And we'll also need to remember to re-enable our UI, if want to grab another image. Let's build and run it. Nice! We did it. This was quite a task to get everything working. And because the code you've written is the crux of the rest of this class I want to make sure that you've been able to implement it yourself too. So take some time and ensure that you're selecting and displaying a random image from the sleeping in the library gallery and then check this box. Up until this point, we've simply been checking if the error coming back is nil. But we can actually do more informative robust checks to handle errors we may not have considered, and to give ourselves better debug info. Let's start by looking at this function here at the top. This function, display error, we've created to print out the errors that we find, and to re-enable the UI. So this looks like something we can use in all of our other error checks, awesome. Now let's go back to the first error we check. It's this, the error value that gets returned from our network request. Previously, we were checking if this value equals no by using an if statement. We're now going to use a guard statement to use this check, and we'll do this as well with the other checks we're making, in addition to some new errors we're checking for. We'll explain guard statements a little bit, but if you're completely unfamiliar with them you should definitely check out the guard statement swift syntax lesson. To explain guard statements let's look at what we're doing with this data that get's returned. If you recall from before, we were using optional binding. That's the if let's it syntax to get our data out of optional form and make sure it exists. We're actually still checking that but in a slightly different way. By using the guard statement we're actually now only checking if the data doesn't exist. And using our display error function to display an error if that's the case. If the data does exist, we get to move on and the data is no longer an optional form. This is nice because it's quick and it allows us to avoid those large nested if statements. You can see that down here we have made the same small adjustment for photos dictionary and image URL string. It's a neat, effective alternative to the if statements we have there previously. Now back up here let's put back in the check to see if error equals nill, this time using a guard statement. Now you'll notice with all of these the guard statement keeps the conditions and associative errors to display in one place. Which ends up making our code a lot cleaner. Lastly, let's just add in a few more error checks, did we get a successful HTTP response? This statement checks to make sure our status code is in the 200s range or the success range. Now let's check down here after we've used NSJSONSerialization to see what we're saving in parse result is actually okay and usable. Great, we're responsibly checking for errors. Note that we can actually combine many of these guard statements together, but we've separated each into its own statement to make it more clear what their purposes are. If you feel comfortable with what each of these statements does, you can feel free to combine them yourself. By now, you should be done with the sleeping in the library app but what I want you to do is see if you can explain it in your own words to someone else. The reason I'm asking you this question is because it's a very common interview type of question. The question has many answers and there's probably no single right answer, that's the point. Depending on how you answer the question, and how much detail you provide, an interviewer can get a good quick idea of your technical understanding of the problem. So, in your own words, I want you to describe the interactions between the client and the server in the sleeping in the library app. Write your description in the box below Here's my answer. First, the client sends an HTTP request to the server using the method flickr.galleries.getPhotos. The server responds with the JSON containing information about photos in the gallery. Then the client stores the JSON, and it randomly picks the URL of an image in the gallery. Then the client requests an image and its data using the URL. Next, once the URL returns, the client displays the image. And if the button's pressed, will go back to step one. I may have left out some of the in-betweens, but this is a good picture of what's happening. Before we wrap this lesson, let us know what you've learned. Also, is there something we can do to improve? Type your answer in the box below. Now that we know a little bit about networking, it's time to start writing some real code. In lesson two, we'll build the flick finder app. For this app, we'll make use of the flicker API again but this time, we'll retrieve and display images based on a search string or a location. For example, I just got back from a ski trip in Tahoe, so I'd like to search an image on snow skiing. So, let's search that. And there we go. There's some people skiing right there. Let's build it. In this lesson we're going to dive straight into networking and build the Flick Finder app. In the Flickr universe, images are also called flicks. So as that name suggests, Flick Finder will let users search to find images. To build the app, we're going to work together step by step, going from simple specification to a fully functional app. Normally, the first step is to envision the goal. Fortunately, for you, I built the app ahead of time. Let's take a look. So this is the Foot Finder in action. We have the title up here, a placeholder for where the image will go, and then the fields for searching by phrase, latitude, and longitude. And there are search buttons here on the right. So I'm going to start with a phrase search. I want to see an image for my favorite baseball team, which are the Atlanta Braves. And here's a shot against the San Diego Padres of the stadium. So that's nice. Pretty good seats. And there is I'm not even going to pronounce his name. That's probably one of our minor league players. So now, let's search by longitude and latitude. I'm going to use 37 for the latitude. And negative 119 for the longitude. Those are roughly the coordinates of Yosemite National Park. I looked those up ahead of time. So I'm going to play around with this. See if we can't get, looks like a squirrel here. See if we can get a picture of the mountain range and all the other pretty scenery out there. Just something big, kind of landscape shot. Hm, so it does say Yosemite. I'm not sure how that's related. There we go. So, upper Yosemite Falls trail, Yosemite National Park, California, June 2014. So, as you can see our fray search and our latitude and longitude search appear to be working well, so this is flip finder and this is simple, compact, fun, you know. So let's build it. For Flick Finder, we'll be utilizing the flickr.photos.search method of the Flickr API. This method allows us to search for images using a text string, or for images that are geo-tagged near a certain latitude and longitude, amongst other things. Of all the methods in the Flickr API, this one probably has the most possibly arguments. But luckily for us, we'll only need a few. Let's start with the arguments we'll need for a text search. The only required argument of course is the API key, but the next argument of interest is called, text. The text argument is used to find images that have a title, a description or tags containing a text value that we provide. If we continue down, the next argument that we're going to use is called safe_search. What safe_ search will allow us to do is to filter results to show only images containing content that's deemed safe. The remaining arguments are ones that we've previously used in the Sleeping In The L ibrary app, and I'll show them all in the API explorer now. So for text I'm going to enter the Atlanta Braves, which is my favorite baseball team. And then for safe_search, I'll enter 1. And the last argument I'm going to specify is for extras. Again, we need to use the url_m value in extras so that we get urls for medium images in the results. And before we call this method, let's change the output type to JSON. And it looks like there are thousands of photos for the Braves. Let's just pick one. I'll copy the URL into the address bar and remove the backslash characters that were added by Flickr. Remember these backslashes will get removed when we create NS URLs. And there we go, this is a picture actually of the Brave's new baseball stadium that's being built in Cobb County, Georgia. In the previous lesson, we built a method for escaping the characters in the parameters of our URL, to make sure that none of the characters were unsafe ASCII. Now, our method worked, but Apple actually provides a set of classes that we can use to accomplish the exact same thing. The first of these classes that we're going to talk about is NSURLComponents. NSURLComponents is a class designed to help us build URLs in a piecewise fashion. That is to say that a URL can be built from individual pieces or components. If we look at URLs more closely we can start to see some of these common components. Here's a URL for a web page that has information about Udacity's nano degree programs. We can actually omit the www portion. It isn't required, and we can focus on the rest. The first part of the URL called the scheme specifies the protocol that we're using. In this case, the scheme we're using is https. Next, the part many refer to as the website name, here it's udacity.com, is called the host name, or host for short. The host is used to determine the location of the server. The final part of this URL is called the path. It specifies the location on the server where the resource that we want is located. In this case, we want the resource located at the path nanodegree. And like we said before, the resource at this location is a webpage that has information about Udacity's nano degree programs. Using NSURL components, we can create this URL in just a few lines of code. And you can see here in this code example that I've had to use these slash character in the path, that is required, so it may not look the exact same on the previous screen that we saw, but you'll need to provide the slash here. But what about a more complex URL like the ones we'll be using in FlickFinder? Here's another example. This URL uses the Flickr APIs flickr.photos.search method. And just so you know, I've omitted some of the parameters in this particular example for brevity. We can go ahead and label the scheme, the host and the path, but what do we call everything else? Well the question mark separates the path from the next component in this URL that's called the query. The query is composed of name value pairs that a server can use to determine its response. You'll notice that each pair is separated by an ampersand. To add the query component to a URL using NSURLComponents, we need to introduce a new class called NSURLQueryItem. The NSURLQueryItem represents a single name value pair in the query component of a URL. To create an NSURLQueryItem is pretty straightforward. We just need to specify the name and the value. Then, NSURLComponents has a property called queryItems, which is an array of NSURLQueryItem. So we can just add any queryItems that we make to this array. In code, it might look something like this. If we go over here we might see the resulting URL. And I know this might seem like a lot of work just to create a URL. But the big trade off is that NSURL components takes care of insuring that our URLs are properly escaped and only contains safe ASCII characters. And that's a nice reinsurance for us. Let's take a look at one final example. This URL is taken from Matt Thompson's post on NSURL components on NSHipster. I posted a link to the article in the instructor notes. Now, on first glance this URL is a lot to take in, but it just contains some extra optional components of the URL. They're already labeled here and if you're interested I encourage you to check out the article to learn more. Here's a URL from the GeoNames web service. And here's a list of names of different URL components. As an exercise, I'd like you to match each component with its correct name. [BLANK_AUDIO] We're ready to start building Flick Finder. Here, I have the starter code project, which you can download from the link in the instructor notes. Let's run it to see what we have. The UI's fairly simple, we have a title, a place where our image will go here in the middle, and then we have UI to support the different text search, and a latitude and longitude search. There's also some space left below the text fields so we can display the image's title or error information. If we open up the ViewController.swift file, we can see that actions have already been connected for both of our search buttons. We have the searchByPhrase action and the searchByLatLon action. We also have this method called displayImageFromFlickrBySearch that takes a dictionary of parameters, and this is where we'll make our search request to Flickr. We left some comments in the search actions that say we need to add the necessary parameters for the methodParameters dictionary. So there's one there and one here. And this is similar to the approach we took in Sleeping In The Library, where we're going to build our methodParameters dictionary and then we'll pass it to displayImageFromFlickrBySearch. And there we'll construct our URL and make our request. Now the rest of the code in this view controller is primarily for the showing and hiding of the keyboards that come up when we have our text field selected. And also it has some code for the checking of, did we enter a valid latitude or longitude? Is the string empty when we're trying to search for? I'm sorry. Is the text empty when we're trying to do the text search? And all those little edge cases. But there is one more method that I want to show that we provided for your convenience. It's called flickerURLFromParameters. This method uses the classes we just discussed. NSURLComponents and NSURLQueryItem. And what this method does is it takes in parameters that you pass it, and then it constructs a URL for the Flickr request. So, no more escapeParameters method. Just pass this method, a dictionary of the name value parameter pairs, and it'll construct a URL for the Flickr API. Now let's take a peek at the constant.swift file. Here, like before in the Sleeping In The Library app, we've defined some useful constants that you can use as you're writing the networking code for this app. Okay, now to the exercise. What I want you to do is correctly add the parameters for the methodParameters dictionary so that it contains all the arguments needed to perform a text search using the flicker.photos.search method. Now remember, at your disposal, you have the constants that we've defined in constants.swift, and you'll also need to adjust your API key, make sure you do that. And then the only other odd ball parameter is that you'll need to include the text that's provided by the user. And then, when displayImageFromFlickrBySearch is called, print the URL that's constructed by our flickrURLFromParameters method into the debug area. And if you do everything correctly you should end up with a URL that looks like this one, assuming of course that the user inputs the text oranges in their search. And you'll also want to have your api_key and not this little placeholder. So take some time to code this up. And when you're done, check this box. Alright, let's take a look at the parameters you'll need to provide. Going from top to bottom, we need the method. We need the APIKey. We need the text, which is provided from the phrase Textfield. We need a SafeSearch. One is the SafeSearch option that we're using. We need extras to specify our url_m We need Format, which is JSON, and then the no JSONCallback and if I build and run this. Let's type in oranges, and we'll search. And there's the URL that we want. All right, for this exercise we want to do the same thing, but for the latitude and longitude search. One caveat to the search, is that we need to convert the values from the latitude and longitude text fields, into the bbox parameter that Flickr expects. Remember from our demonstration using the Eiffel Tower's coordinates that the bounding box string needs to be a list of four values in the order from minimum longitude to minimum latitude, maximum longitude and then finally maximum latitude. So I'm going to help you get started. First, I'm going to copy over the parameters from the text search while making sure to remove the text parameter. Then, we'll add a B box parameter and I'm going to recommend that we populate this value using a method called bboxString. So that method doesn't exist yet, so we should be getting an error. And then, we can just put this anywhere. We'll say private func bboxString ( ) --> String. Now it's going to be your job to implement this method. Before you get started, I want to point our four useful constants in the constants.swiftall that can help you. The first two are called SearchBBoxHalfWidth and SearchBBoxHalfHeight. What these constants represent is the amount that you want to vary the latitude up and down and the longitude left to right. Now feel free to adjust these constants if you want to vary the overall size of your bounding box, but the one default value should be fine. The other two constants are the SearchLatRange and SearchLonRange tuples, notice these are tuples. And you should try to use these two constants to ensure the bounding box you create, does not use latitude or longitude values that fall outside of the accepted range. For example, if a user enters the latitude of negative 89.5, and then you use this half, I guess that would be half Height, to vary it by one up and one down, it would result in negative 90.5 and negative 88.5. Now the negative 88.5 value is fine. It falls within this range. However, the negative 90.5 value falls outside of the accepted range because it is lower than negative 90. So you can use these constants and perhaps combine them with Swift's max or min functions to ensure that this kind of error doesn't happen. If you never used Swift's max or min functions before, I've posted a link to a stack overflow post that describes them in the instructor notes. Now I'll leave the implementation of the bbox method up to you. If you correctly implement the method you should see a URL like this one assuming the half width and half height constants are set to their default values of one, and the user does a Lat/Lon search with a latitude of 48.85 and a longitude of 2.29. Check this box when you're done. Good luck. All right for our implementation, I'll start by attempting to set latitude and longitude constants using their corresponding text fields. Technically, this if let statement should always pass because if we scroll up here, there's this isTextFieldValid method that's being called on both of them and it's going to ensure that we actually have valid, double, or floating point numbers. But this extra check that we're making in the if let statement is nice in case we want to call this method without assuming any prior checks were made, but if the check does fail, let's return a valid string, but with all zeros. Now, after the latitude and longitude constants are created, we need to create a value for each item that shows up in the list. For the minimum longitude, let's take the longitude and subtract away half the width, the SearchBBoxHalfWidth. Now normally this statement would work fine, but what if I try to subtract beyond a negative 180 degree minimum for longitude? Well, if that happens, maybe it would be best to just return negative 180 instead because there could be the case where a user puts in, say, negative 179.6, and we set our HalfWidth here to ones. So if we were to subtract that away we would be at, what, negative 180.6, which is outside of the accepted range but, to the user, they wouldn't know that. They'd be entering valid longitude, so, yeah, returning negative 180 in that particular edge case would be nice. So, what I'm going to use is the max function and we want to return the maximum of this value. Or we'll need our constant. Very good, okay. So if we subtract beyond negative 180 then just return negative 180. Similarly, for the minimum latitude, we'll subtract away HalfHeight of the BBox which we have here in this constant. And we're using max again and in this case we're using the minimum for latitude which is -90. Then for the maximum longitude and latitude we just do the reverse. We add HalfWidth and HalfHeight and then we use the minimum function to ensure that we don't go over the maximum value in our LonRange and our LatRange. With these created, we can use a little string interpolation and we're done. And let's build and run to check. And there we go. There's our URL. At this point, you should be getting a correctly formatted URL for text and lat-long searches. Let's go ahead and complete the next steps to make the request. We'll create a constant for the shared NSURLSession, and then we need to create an NSURLRequest from our URL that's being created by that flickrURLFromParameters method. There we go. After this, let's create a data task using NSURL sessions data task with request method. Remember, this method lets us provide a closer called a completion handler that'll be executed when the task completes. For now let's just print the raw data if no error occurs, otherwise let's print some information about the error. And then the last step is to start this task by calling its resume method. Now let's make sure everything works. And we see the raw JSON data's being printed, and there's no error. That's a good start. I want to take a step back to the http skit from lesson one. If you recall, in the skit I played the role of the client and Jessica played the role of the server. But there are a few other roles that I left out, specifically the NSURLSession, the NSURLRequest. And the NSURLSessionDataTask. So you can see these three images here. What I want you to do is to match these images with the Swift class they best represent. To do that, just for the number of the swift class so 1, put it in the box that you think best represents one. And so on for the rest. We'll start with the image of the envelope. In the skit I place the request inside of the envelope and this is indicative of what an NSURL request is doing. The NSURLRequest encapsulates the URL that the client is requesting. The second image is of Jason and the container that was on my desk in the skit. In the skit, Jason takes the request from the container and then he handles the rest of the HTTP request on my behalf. This is the same behavior as the NSURL session for our apps. It too handles the sending and receiving of HTTP data. Here on this third image we have something that's a little bit more abstract. We have Jason and we have pictures of arrows indicating his path that are shown in color. These serve as a representation of the data tasks that's being accomplished by Jason and therefore it's mashed with the NSURL session data task. The data task is specifically used for retrieving data and then bringing it back to the client or app. All right, so we're currently printing the raw JSON data return from Flickr. Now we need to deserialize it, parse it, and display an image and it's title to the user. This process should almost be identical to what you did earlier in the Sleeping In The Library app. But before you dive in, I'm going to provide you with a handy trick. In the completion handler, I'm going to go ahead and define a function for printing and displaying an error in case something goes wrong. Now this function only exists within the completion handler. But it can save you a lot of time and duplicate code for displaying errors. Feel free to use it in your implementation. Now I'm going to leave the rest up to you. I know this might seem daunting, but you should have all the tools to piece together a solution for this. To complete this exercise, you need to take the steps necessary to finish implementing the displayImageFromFlickrBySearch method. First, check if an error was returned to the completion handler. If no error is returned, then check for successful response by looking for code that begins with a 200. Of course, if an error did occur, you'll need to handle it accordingly. Next you'll want to deserialize the JSON data and extract the values needed to select a random photo, its URL and it's title. If all goes well, your final step will be to update the UI. Remember to use the performUIUpdatesOnMain black box that we've given you. If you get stuck at any point along the way, you can always go back and reference the code you wrote in the sleeping in the library app, or ask others for help on the forums. When you're done, check this box. Let me show you the solution that we came up with. We start by using this series of guard statements. First we check that no error's been returned. And then we check to see if we have a status code that begins with 200 here. And then we check if the data is not nil here. Now I know some of these guard statements are a little redundant. If we remember the documentation it says that if the error is nil, then we're guaranteed to have the data, or if the data is nil then we're guaranteed to have an error. But we decided to put each of these guard statements in here just to be extra clear about what's going on. So if we pass all these guard statements, then we use the NSJSONSerialization class to convert the data into a dictionary that we can use. Next, we start checking for those key value pairs that we're interested in. Remember, the response that we expect looks something like this. We have this top level photos dictionary, and within photos we have the photo, which is the array of photo dictionaries. And we also have this stack key that gives us some indication of how the response went. And what we want to do is select a random photo out of this array, and then we want to get its title and the url_m values. So back in the code, the first thing we actually check for is that stat key value pair. We want to make sure that the status, stat, is okay. And you don't have to do this, this is just an implementation detail that we like for extra security I guess. Then we get the top level photosDictionary and we also get the photosArray, which remember, is the array of individual photo dictionaries. We also make one more check here. We want to see if the number of photo dictionaries, the account of the photos array, is equal to 0, because then we know that the search returned no images. And we account for that here. Otherwise we go ahead and generate a random index, so our randomPhotoIndex. And then we can use that to select a random photoDictionary, here. With our random photoDictionary chosen, we get the title, and then we get the url_m, that string. And then we can use them to make our UI updates inside of this performUIUpdatesOnMain. So this all looks pretty good. And we'll give it a shot. And let's search for something sweet, I'm going to search for my wife's favorite, French macaroon. Yummy. This is quite the search image. We have have a macaroon and we have typography, how fancy. Now at this point we're almost done with Flick Finder, but there's one more optimization that we can make. We'll look at this next. Flick Finder is starting to look pretty good, but some of you may have noticed the same problem that I have. We're not truly doing a search of Flickr's photos if we only select a random image from the first page of results. We can see this pretty quickly by playing around in Flickr's API Explorer, so as an example I'll use the search term baseball. Now I've searched this term before and I know that it's going to return a large number of results. And as we can see, this search returns 264,506 images. And currently we're looking at page 1. So with a query like this, our current implementation only grabs a random image from this first page, which contains 100 images. That's not bad, but it's not a true search. So how do we accomplish a more random, a more true search? If you read through the documentation you might have this idea, we could perform a first search like this one here and we could look at this pages value. And then we could randomly select a page number, and make a second request, using that page number as a parameter. So, here at the bottom we have this page number. So, we could use something like 36. So now we're getting results for the 36th page. Now in theory, this should work, but when I tried implementing this myself, I ran into a problem because I did not read all of the documentation carefully. So let's go to the documentation. Here in the documentation it specifies that, at most, only the first 4,000 results will be returned for any given search query. So if I try to pick a random page number that request images beyond the 4,000 result, then Flickr automatically returns results for the last possible page that does not exceed that 4,000 limit. If you don't believe me, you can try it. Now this implementation detail took me about an hour or so of banging my head into a wall until I figured it out. But really, these kinds of setbacks are pretty common in development. We're often required to take a deeper look into documentation to solve problems. So as an exercise, I really want you to dig into the documentation to understand the problem of making our results more random. Take a close look at the documentation for the flickr.photos.search method and answer the following questions. First, what is the maximum number of images Flickr will return for any given search query? I just mentioned the answer to this question, so this one should be pretty easy. Second, if the per page argument is not specified, then how many images are returned per page? And finally, if we have a query that requests images beyond that 4,000 limit, then the results of what page number are returned? And you can assume that the per page argument is not specified in this case. Mark your answers in these boxes. If you paid attention and read carefully, the maximum number of images Flickr will return for any given search query is 4,000. Then if we do not specify the per_page option, Flickr defaults to returning 100 images per page. Finally, if we do the math, assuming the per_page option has not been specified, page 40 will contain the 4,000th result. Therefore any search request that goes beyond that 4,000th limit will still return the results for page 40. So for searches with this many results, the best we can do is select a random image from those first 4,000 results. But before we implement this, let's talk about the steps required. So let's outline what we want to do and in the next segment we'll execute it. We'll need to make our first request to see how many results we get, then parse the JSON that returns, then determine how many pages of results that ends up being. We can then generate a random number in that range then use that number to make a second request for a random page. And finally, repeat what we did previously and get a random photo from that random page of results. In this chart, the steps are defined in a way that suggests that each step happens one after the other without delay. But remember, when we're working with networking requests, the requests don't complete immediately. That's why we use a completion handler to define what we want to happen once a network request finishes. It's like saying, I don't know when the request will complete, but run this code when it does. Another added benefit is that while the network request is being processed, our app can continue running. We describe this kind of request as an asynchronous request, or asynchronous task, because it gives us the ability to define the behavior we want and to defer its execution until after something happens. In this case, after the request completes. You can think of an asynchronous request like putting a cake in an oven and setting a timer to indicate when the cake will finish baking. While the cake is baking we can go do other things like make frosting, but as soon as the timer goes off, we need to pull the cake out of the oven. Pulling the cake out of the oven is like our completion handler, it's what we do as soon as the timer goes off. In the same way, we want to make the second request only after the first request finishes and we've gotten a random page number. In the second request we'll define another completion handler to handle getting a random photo from the random page of results. So you can see how to achieve this flow of steps, we're chaining together asynchronous requests. When one request finishes, we'll move on to the next and so forth. This kind of chaining of asynchronous network tasks is a common occurrence and there's some popular frameworks out there for dealing with this. We won't go into detail about them in this course though but if you're curious, you should check out the links in the instructor notes. All right, so let's implement the first four steps of our flowchart. We've already made a request that sort of works, so let's start from there. See if you can remove the part where we're selecting the image, and instead, write code to select a random page. Once you've successfully done that, print out the randomly selected page number. Check the box when you're done. Your solution should look something like this. If you did it a bit differently, but still got a working answer, that's okay too. Now that we're selecting a random page number, we need to make a second request, get a random image from that page. This request is going to look a lot like our first request, but just have that added page parameter. So let's reuse some of our existing code to create a new method called displayImageFromFlickerbySearch that takes the method parameters again, but an additional parameter called withPageNumber. Now most of the code in this method is going to be the same as when we made our first request, so while I normally don't recommend this, I'll start by copying and pasting over the code from our first request. Gone ahead and copied it and we'll paste it there. And then, let's back this up to here. Let me finish parsing the data. So all that's the same. Let's collapse this and reopen our, oops. Reopen our other one. There we go. There's our random page number. Now there are definitely more elegant ways to do this and to avoid this duplication of similar code, but we're going to get to them later in this course. So let's go ahead and call this method. There we go and we can reuse our method parameters. And then we'll use our random page number. Now with this method, we need to add the page parameter to the method parameters before we create our URL. One quick way to do this, is to make the method parameters a variable parameter, so that we can modify it in the body of this method. So let's do that and then let's add the page parameter to the dictionary. Now the rest of the code in this completion handler should be fine up until the point where we need to parse the result. Remember, we need to get the array of photo dictionaries, select a random photo dictionary, grab it's URL and title, and then display those to the user. I've gone ahead and copied the code that we'll need, and I've pasted it here now. Now, don't be alarmed, you've seen this code already where you checked the status to make sure it's okay, then we get the photos dictionary, and then we get the array of our individual photo dictionaries, and then we make sure that we at least have have one photo in the array and we randomly generate our photo index, or the index I should say for the photo dictionary that we need. Select our photo dictionary, get its title, and also get the url_m, the url that we need for the image, and then with all that in place we use our perform ui updates on main and we make our changes to the ui. I've also added a little extra code that displays untitled if we somehow select an image without a title, I think this has happened to me once. That's it, let's run this. I'll use the search term baseball and it looks like it works. For good measure, let's do a latitude and longitude search as well. I'll use the latitude 37.86, and the longitude -119.53, and these are the coordinates for the Yosemite National Park. And there we go, this looks great. Now I want you to follow the steps I just showed to complete Flick Finder by selecting a random image from a random page. When you are done, check this box. To build Flick Finder, we had to take some extra steps to get everything working correctly. We discussed URL components, spent time formatting parameters and even chained two asynchronous network requests together. Keep all these concepts organized, take a moment to fill out the box below with the things you've learned this lesson, as well as any feedback on how we can improve the course. You're now ready for lesson three. In lesson three we're going to use a new API called The Movie Database to build the My Favorite Movies app. This app will let users select and mark their favorite movies from a few popular movie genres. To build the app we're going to cover a topic of growing importance, authentication and security. Well let's see how it works first. When I launch the app, I log in and then I select from one of the movie genres here below. Then I can select a movie, and I can add it to my favorites list. And if I go to Favorites, there it is. So join me in lesson three as we build the My Favorite Movies app. In this lesson, we'll build the My Favorite Movies app that uses The Movie Database API. And to build it, we're going to learn how to authenticate and secure our request so that we can protect our users' data. Every API is different on how it deals with authentication, but by the end of this lesson, you'll have a foundation for dealing with it, no matter the API. Before we get started, we're in for a real treat. We're going to sit down with Travis Bell, the creator of The Movie Database, and he's going to tell us about this awesome web service. Travis, I'm really glad you could join us for the course. Can you tell us a little bit about yourself and the movie database? Yeah sure. So I started TMDB seven years ago. Just as a side project to help serve images to the media center community. And what started off as literally just a website sharing zip files. Has turned out to be one of the most popular movie databases on the Internet. Awesome, so what exactly can we do with the movie database? So yeah, I'd like to mention you know, seven years ago, when I started TMDB we were just sharing images. And since then, obviously our database, our service has evolved a lot. And some of the cooler things we've added is, goes way beyond just you know, searching for movies and finding you know, the filmography of an actor or an actress. We wrote, wanted to make it as easy as we could to let developers on any platform, you know, mobile or even just other websites. To plug in, you know, sessions and account features without ever having to worry about the back end. And that's exactly what most of our service, account service does. As Travis mentioned, the movie database and its API provides methods to users through its account services. This would include things like rating movies or making a list of your favorite movies. When data like this takes on a personal or a private element, such as my private Flickr images or my favorite movies list, we might call this user access data or user data. Sometimes all the data that's made available by an API will be user data. And the reason an API might do this is just to make sure that the data that it provides is more secure and private. It has to go through a user. This user data is very different from, say, data just about movies. The data just about movies should be accessible by anyone. Data like this we might call anonymous data, or anonymously accessed data. And as developers, we will want to work with both kinds of these data. As we saw in lessons one and two, to access anonymous data, we typically call a method. And we might use an API key and pass it some arguments. This type of interaction's not always this simple, but it's pretty standard. For user access data, we can't just get to the data so easily. This is especially true if we wanted to change our rating or add something to our movie list. How does the API know if the user is actually authorized to do this? APIs handle this by authentication, and as you explore different APIs, you'll find that each API handles authentication differently. Let's check out the features of the My Favorite Movies app. When open the app we're presented with this nice login screen and the user is prompted for their username and a password. I'll go ahead and enter my credentials and log in. Once we're in were presented with this tab control and it has four tabs. And the log out button is in the top left hand corner. And on the first three tabs we have the statically defined movie genres. We have sci-fi, comedy, action. And in any of these tabs there's 20 movies listed in no particular order. Then on the last tab we have our favorite movies list. For some of you, you may have no movies here if you haven't favorited anything yet. But as you can see I have three movies here that I've already added to my list. I happen to know that the movie Fury is on the Action's tab and this is a movie I just recently watched and I really liked it. So I want to add it to my favorites but I need to select it here first. Then on the detail view, I'll tap the heart icon to add it to my favorites. If we go back to our Favorites list. There you can see Fury's been added to the bottom. What's happening here is when I tapped the heart button here I favorited the movie and that data was posted to the server. Then when I returned to the Favorites tab on a separate request that movie was returned to my new favorites list. It's pretty cool. Now that you know what this app should do when it's done the next step is to figure out to use the movie database to create this app. Let's break down the operations we just saw on My Favorite Movies and determine which API methods we should use. Obviously we need to be able to login. And this is going to require us to authenticate. And this step can be very complex. It involves a number of substeps and we are going to cover each of them later. So for now, we'll just assume we've already logged in. So on the genre tabs, we need to be able to get a list of movies by the genre that's selected. Then for favorites, we need to be able to get a list of our favorite movies. Finally once we selected a movie, we need to able to add or remove it from our favorites lists. So to complete this exercise, we need to determine which methods to use. So to start your search, you want to open up the documentation for the movie database API. When you've found the correct method names, enter them in the text boxes next to each question. I've included a link to the documentation in the instructor notes. For getting a list of movies by genre, we use the /genre/(id)/movies method. And as the documentation indicates, only movies with ten or more votes, or ratings, are included. Then, to get a list of a user's favorite movies, the /account/(id)/favorite/movies method should be used. There's also a fun method called /account/(id)/rated/movies, and this returns a list of the movies that users rated and the movie's associated ratings. To add or remove favorites, we'll use the /account/(id)/favorite method. This method is different than all the methods we've seen before and it uses the HTTP POST method. It'll let us post data and close in our request. In this case, it'll be whether or not this movie should be added to our favorites list. Let's take a closer look at the methods we'll use in the My Favorite Movies app. Here's the documentation for the movie database. I've posted a link to this documentation in the instructor notes. Scroll down a little bit here on the left. This section on the right gives us a list of all the methods provided by the API. I'm going to select Account, and then go to Account/ID/Favorite right here. This is a method that we'll be using in My Favorite Movies. As you might expect, this method can be used to add or remove movies from an account's favorite list. You can see we have this information about the required parameters, as well as this required JSON body section. The JSON body, also known as the HTTP body. Is part of an HTTP request that allows us to pass parameters, without having to pass them in the URL, like we've done before. We'll start using the JSON Body when we make our first post request later in this lesson. For now I want you to focus on an extremely useful feature of the movie database's documentation. If we click this post banner here, a pane will slide out from the right. And in this pane, we can take a look at example request. This is very much like the API explorer that we saw with Flickr, so let's scroll down a little bit. And it gives us this really nice boilerplate code, that we can use to call each of the methods in the API. So for this particular example, we're calling HTTP, here's the url, for count id favorite. Notice it has id in red, because you'd have to substitute in an id value for the user id. But if we keep going down, we can see in a share all session, these are some classes that we're familiar with, and this is really nice. If we continue to scroll to the bottom, we can see an example response. And for this particular method, the response returns a status code and a stats message, and if it's successful, it says, the item slash record was updated successfully. Before you get started, I highly recommend just taking some time with the documentation, and clicking some of the other methods and taking a look at their example responses. And their example boilerplate code here, to actually make the network request. If we look back at the required parameters section, we see this parameter called session_id. What's this parameter all about? Well, if you do some digging, you'll find that The Movie Database uses sessions whenever we want to write data using the API. And by write, I'm referring to the methods that update or change data that's stored in the movie database. So this would include methods like, account ID favorite, where we're changing an account's favorite list. It might also include methods for rating a movie. There's some separate documentation about sessions, that's located on the movie database's main website that I'm looking at now. I'll post a link for this in the instructor notes as well. This page details how to create and use a session, and it's associated session id. Without reading the entire page, we see that the basic work flow requires us to create a new request token. And then we can either do Step 2a or Step 2b. Step 2a says, ask the user permission via the website. Or we can the user permission via the API, and then in Step three we create that session ID that we just saw in the documentation. Now, you'll for Step two, we do have these two different ways of asking the user for permission. One uses the website. And one uses the API. In this lesson, we're going to use Step 2b, and we're going to ask the user for permission via the API. And then in the next lesson we're going to ask the user for permission via the website. So you'll get to look at both approaches. Now if you haven't already, I highly encourage you to go through this page and read it yourself. And some of the terms might not make sense yet, but start building a mental picture of the steps required to create a session. because a session's what we're going to need to make our first post request, and actually favorite movies right? The My Favorite Movies App. So we'll need to be able to do that. Before we go on, let's talk to Travis and see what he has to say about authentication and the movie database. So Travis, it appears in the My Favorite Movies app, we'll need to use a sessions ID in order to add and remove movies from our Favorites List. Can you tell us a little bit about how this is done? Yeah, sure. So basically, you know, to get a lot of the account features available on the API, so letting an account create a movie, add them and remove them to your watch list, create custom lists, etcetera you need to get a TBB user account. So, once you have an account on the website you're able to go through a off flow on the API that lets you [COUGH] create a session that let' you do these account features via the API. Cool. Sounds like sessions are definitely the place to start. In this lesson, as we build My Favorite movies, we're going to learn how to use the first of two off flows that the movie database makes available to us. Then in the next lesson, we'll switch up the flow so you'll get exposure to both forms. So at this point, you've seen information about sessions on the movie database website, and heard about the movie database authorization flow from Travis himself. But once we start writing code for this, things can get a little complicated. So to get a good idea of the organization of all of this and how it will work in the app, let's look at a flow chart that describes how a user will log in. The first thing we'll need to do is get a request token. Once we have that we're going to login with the API and then we can create a session ID. Remember for the movie database, we need a session to make any requests that write or update data. Finally, we'll grab the user ID and we can then move on to the next view. Now we can see from the arrows that these steps need to happen in a specific order and we wouldn't want to move onto the new step before our current step is finished. It's for that reason that, in our code, we're going to keep these steps chained together, meaning we'll move onto the next one only after our current step completes. This means checking each time that we have the value we're expecting when a step completes, and printing or displaying an error if we don't. Hey, everybody. I hope the course has been fun so far. This lesson can be particularly challenging, but I want you to know that I've been in your shoes. So, to ease you into building the My Favorite Movies app, here are a couple things I want to call to your attention. First, some of the app's been implemented ahead of time. This is going to allow us to focus on just the networking code. Second, the AppDelegate's used like a singleton to get the NSURL session. If you've never heard about singletons before, check out the link in the instructor notes. And last, we've broken each HTTP request into a seven-step process and we'll cover that in just a moment. For now, let's get started with the movie database. Before we can get started using the Movie Database API, you'll need to sign up for an account. To do this go tot he Login or Account Login at the top of the site. Then you'll want to follow the link that says click here to get started. For this exercise go ahead and sign up for an account with TheMovieDB. Then once you're signed up, get an API key. Also, I highly encourage you to play around with some of TheMovideDB features. So try favoriting a movie, or create a list, or go and rate a movie. And when you're done, check the box. There's something else we need to talk about before you start writing code. Go ahead and download the starter code project for my favorite movies and then open up the info.plist file. I believe it's located in supporting files > info.plist. Remember how we had to modify the info.plist file in the image request app? This accounted for images that used HTTP instead of HTTPS. Well, as of now the movie database also relies on HTTP to actually make some of its request for images and such. And to adhere to Apple's ATS standards, this just won't cut it, so we've made some changes to the info.plist file. And we'll collapse out the at transport security settings. And let's just collapse all these so you can see everything. Instead of allowing arbitrary loads, like we did in the image request app, and remember, this looked like we'd go here, allow arbitrary loads, yes. So this property, we've gotten rid of, we don't need this property anymore. To do this, we've used the exception domains dictionary, which in itself contains dictionaries for each domain that the API uses. And for each domain, we can specify that we want to allow it to use insecure HTTP loads. Now I know some of these key value pairs you haven't seen before, but it's not really important that I get into all of them right now. The only one that I want to point out is NSIncludesSubdomains. This key provides a boolean that says whether or not you want settings of a domain, say like cloudfront.net to apply to all of it's subdomains. A subdomain is an extension to a domain name that's used to organize resources together. For instance, udacity.com is a domain, and it has the subdomain review.udacity.com. On review.udacity.com, you'll find webpages, images, and other resources that are related to Udacity project reviews. So if we were to set NSIncludesSubdomains to yes for udacity.com in our info.plist file, that means we'd want to extend any settings of udacity.com to all its subdomains, like review.udacity.com, discussions.udacity.com and any others. I just wanted to make you aware that these properties have been updated for my favorite movies. If you want to read more about these properties, the ones that you can use for ATS, I've posted a link in the instructor notes. Now that we're signed up with the movie database, let's take a quick glance at the starter code project. I'll run the app. And right now we have this login screen with the username and a password text field. We also have some space below where we can put debugging information. If we try to log in with the username and password, the UI becomes disabled and it's waiting for a login to occur. Let's go ahead and stop this and take a look at the classes involved in this project. Starting with the app delegate.swift, this file's a lot more involved than it's been in previous applications. It has properties for the shared NS URL session that we can get access to from any other class in the project. And it also has properties for a request token, a session ID, and a user ID. These are all things that we'll need when authenticating and using the movie database. There's also this config property, and we've taken care of this for you. You don't really need to worry about it. It's just another black box, treat it like the GCD black box. And then the last thing I want to show you is here at the bottom, it's this method called tmdbURLFromParameters. This method, like the ones that we saw before in Flick Finder, is a method that returns a properly escaped and ASCII safe URL. But instead of for Flickr, it's for the movie database. It also has this additional parameter called withPathExtension. And this adds a path to the URL that's constructed. This is because for the movie database, the different methods of the API are specified as part of the URL path. This is different from Flickr where the method was specified as part of the URL's query. So take a second and let that soak in. Okay, let's go back to the code. Next we have the movie.swift file that contains the movie struct, which is the main model for this app. I'm not going to go over this struct in detail, so we can just focus on the networking part. But I encourage you to look over it, it's relatively simple. Next we have the Constants.swift file. This file contains constants for the movie database that you can use in your implementation for the app. And of course, we still have the GCDBlackbox.swift file. Under this, the next folder we have is this Provided Classes folder. In this folder, there's a swift file for the movie database configuration and then a border button class, which is used for that login UI. We'll skip these two and move on to the folder that contains the files where you'll be making all of your changes in the view controllers. For this exercise, you will be making changes to the LoginViewController.swift file. Here at the top, you'll notice we have this property for the app delegate. Then in the viewDidLoad method, we're getting the shared applications delegate. This is what gives us access to the properties that we just saw on the app delegate.swift file. Now scroll down to the log in pressed action. Here we go. Assuming we've provided a user name and a password, we disable the UI, setUIEnabled to false. And then we call the getRequestToken method. This is going to begin our authorization flow. And this aligns with the steps we saw in Ian's flow chart. The first thing we need to do is get a request token, so let's follow this. Oops, we use a command click. There we go. In the requestToken method, we've commented the seven steps. We have one, two, three, four, five, six, seven, that need to be taken to get the request token. Now, we've already implemented some of these steps to get you started. Let's go over them. First, we define the methodParameters. For this method, the only parameter that's needed is the API key. Then, we build our URL using the appDelegates tmdbURLFromParameters. This method takes the methodParameters as an argument, and then we specify the PathExtension for this particular method, which is /authentication/token/ new. And you would see this if you look at it in the documentation for the movie database. This particular method will get us a new request token. >From here, the code is like what you've seen before. We create a network task, and then we need to start it. It's going to be up to you to handle the response and finish steps five and six. To get started, I recommend that you go through the documentation for the authentication/token/new method and look at the example response. I posted a link in the instructor notes. The basic idea is this, deserialize the JSON data and then parse out the request token. Once you have the request token, you can just print it out for now. Also feel free to use the login view controllers debugTextLabel as a nice way to display errors to the user in case something goes wrong when making your request. When you're done with the exercise and you've printed a request token, check this box. Let's walk through the changes together. Right now I'm in the documentation for the authentication/token/new method. Let's look at an example response. It shows that if the method returns successfully, we should have a request token, as shown here. Let's go back to the code. I'm going to go ahead and copy in some boilerplate guard statements like the ones we've been using in the previous apps. So I'll have this function called displayError. And it'll print out the error, and then on the main, it'll set the UI back to true, or re-enable it. And it'll also set the debug text label to hey, our login's failed. And it's because of Request Token. And then the first guard statement we'll make is to make sure that the error is nil. Then we'll make sure that our response status code begins with a two, or that it's successful. And then we'll make sure that some data was actually returned and the data isn't equal to nil. For parsing the data, we'll use the tried and true NSJSONSerialization. And turn the data into a dictionary that we can use. And then the last step is to get our request token. So for this statement, we'll look in the parsed results, and make sure that we have a value that's stored at the request token key. If this statement succeeds, then we have the request token, and we'll just print it. Now, let's build and run this. And I'll just enter in some dummy username and password because it shouldn't matter at this point. And I'll click Login. Great, there's our request token. Now, let's move on to the next step of the authentication flow. According to Eden's diagram, the next thing we need to do is log in with the API. If we look back at the code as soon as we get our request token, this is where we need to continue to the next step. First, let's store the request token in the app delegate in case we need it later, and then we'll call the loginWithToken method. If we skip down to this method, we can see that it's currently empty, and I did this on purpose. I want you to get more exposure writing the networking code involved in all 7 steps, so that the code just becomes second nature. For this exercise, start in the API's documentation, and find the proper method for logging into the movie database. Once you find it, take a look at any required parameters and also what an example response looks like for that method. Then, implement the 7 steps in order to login. And once you're able to successfully login with the API, print a message that says you're ready to get the session ID, and when you're done, check this box. Let's walk through this step by step. This time the method you want to use is authentication/token/validate/with_lo- gin. This method takes four parameters, the api_key, the request_token, the user name, and a password. And if we take a look at the example response, the key that we're looking, success, and we want the value to be true. So let's go back to Xcode and see how it's done. First, I'll create our methodsParameter dictionary. And we'll add the APIKey, the RequestToken, and then the Username and Password that are supplied by the TextFields. Next, we'll build the URL and this time we'll use the PathExtension authentication/token/validate_with_lo- gin, and this will create our NSURLRequest. >From here it's a lot of repeat code. We'll create our displayError function again, and then do our series of guard statements, the first checking for the error not being nil. And then for the successful response. And then for the data not being nil. Then let's turn the JSON into a dictionary and look for that success key. So to check for our success key we'll look in parsedResults and we'll look for the key Success. And then with the Where clause, we can check that the value that we pull out is equal to true. If we make it this far then let's print something that says we're logged in and we're ready to get the session ID. Also, we need to make sure to resume our task so that it starts. So let's run this to see if we get our print statement. This time I want to make sure to use my actual username and password, otherwise this won't work. And there we go, there's our print statement. Now that we've logged in with the API it's time to create the session ID. As seen in 's flowchart, this is the last step necessary to perform writes to user access data. I'll help you out on this one, the method that you're going to want to use to get the session ID is authentication/session/new. This method is pretty straightforward. It just takes the API key and then the request_token. It says that the request_token needs to be approved by the user before being used here, and that's what we did when when we logged in through the API. Now back in the completion handler for loginWithToken, we need to go ahead and call the getSessionID method. This method's empty but it describes the task at hand. We need to get the session ID and then store it in appDelegate.sessionID. >From there, we can move on to get the user ID, and we'll do that a little bit later. So like before, implement the seven steps and get the session ID. Once it's received, we can just print it for now. When you're done, check this box. Here's the solution. At this point, I hope the steps for each task are becoming more familiar. I'll start again with the parameters, which for this request are the API key and the request token. Then to build the URL, we'll use the /authentication/session/new method. Next I repeat the steps that we've been taking to create the task here, then we have this displayError function and then we check for error cases, so one, two, three different error cases here, these guys. And here we convert the JSON data into a useable dictionary. And then, we grab our session ID, so we look in the results and we look for the value of the session ID key. We store the session ID in the app delegate and then we print it out. And don't forget we need to start the task using task dot resume. Now let's go ahead and run this. I'll enter my credentials again. And there we go, and there's the value we've been looking for all along, a session ID. Up to this point our requests have been working fine, but there's potentially a big security problem. If you've been paying attention, our requests for this app are being sent using HTTP. We can see this if we go to the app constants file. We notice that our API scheme is HTTP. And this scheme is what's being used, here we go, in the tndbURLFromParameters that's using our ApiScheme, which is HTTP. Now, while we've defined the proper settings in the info.plist file to allow for this, there's still a big security risk. Especially if we're making requests that send usernames and passwords as parameters of URL, like we did when we logged into the API. Let me show you what I'm talking about. Let's go back to the LoginViewController and let's find that loginWithToken method, here we go. Let's add a print statement that shows the URL for the login request that we're making and our loginWithToken method. When I click the login button, okay here's our URL, so I've clicked the login button and we can see that the URL's being printed where the username and password are sent as plain text. So if somebody was watching the network traffic going from my phone to a server, or even from my simulator to a server, they could see these values and this is obviously very bad. Let me show you how this might look for somebody who's snooping on network traffic. I'm going to do this using an application called Charles. You don't need to install Charles yourself, I'm just going to use it for this example. In Charles we can see all the web traffic that's incoming and outgoing on this particular machine. So I want to see the requests that are being sent to the movie database, and as you can see, we've made a request recently. If I select this request and then I go look at the summary, I can actually see what the traffic looks like as it's leaving my machine. So I can take a closer look, and here's our validate_with_login method, I can actually see my username here, and then here's my password in plain daylight for everyone to see. So we definitely need to fix this, but thankfully, it can be done really quickly since the movie database provides us a way to send requests like these securely. If we go back to the documentation we can take a look at this HTTPS/SSL section and, as we can see, it simply tells us instead of making an HTTP call ,we just need to make an HTTPS call, and then we're set. What this is effectively going to do is by making the HTTPS calls, it's going to encrypt all the data that's being sent from our apps so that nobody can snoop on us. If you want to hear more about HTTPS, now I put a link in the instructor notes to our web development discussions on the topic. Okay, so to fix the problem we just need to make one small change in the constants.swf file. Let's change our scheme from HTTP to HTTPS. Now we'll build this project. Let's go and log in. Now I'll go ahead and switch back over to Charles and you'll see that we have the HTTP request that we previously did and then these HTTPS requests. And as you can see, since we're using https, we don't really know anything in terms of snooping about what's happening in our request, whereas we can still see things that are being passed with this request. The best part about all of this is we're pretty much getting it all for free because the movie database supports HTTPS. So, when in doubt, just use HTTPS. We're almost done with our login, but before we go to the next view, we need to grab the user's ID. If we look back to the methods of the documentation like the one for adding and removing a favorite we can see this ID in curly braces. And like we said a little bit before, this ID corresponds to the user ID and getting it ahead of time and storing it will save us having to make requests later when we want to add favorites, or do something else that requires the user ID. Back in Xcode lets go to the get session ID method and lets go to the bottom where the completion handler is finishing. Here we go. And we've stored the session ID and now it's just called get user ID. And if we look at the get user ID method, it's empty and it's ready for you to implement. So for this exercise, find the correct movie database method to use to get the user ID, implement the seven steps, then store the user ID and call the completeLogin method. If you do all this correctly, then the completeLogin method will go to the next view. And when you're done, check this box. I'm not going to walk through this solution step by step, and I hope that most of this code that you see here has become pretty routine. Let's just go down to the bottom. Keep going. Here, we store the user ID in our app delegate, and then we call the complete login method, to go to the next view. So let's test this and see what happens. I'll enter my credentials and click log in. And there we go. We've completed the authentication flow plus we've gotten the user ID. And we're here in our main tab view. And for fun I'll go to the favorites tab just to see if the movies that I've already selected as favorites on the website show up here. And there they are. Next we're going to tackle our first post request to favorite and unfavorite movies. A couple lessons back we've talked about how their various types of request that you can make to the server. And so far, we've talk specifically about get request and then have seen how to use them in our examples. Earlier in this lesson, we mentioned that we'd also be implementing what's called the post request to add a feature to our my favorite movies app. Now, it's time to look at this in more detail. A POST request, as you may recall is a request where the client submits data to a web server for processing. The data that's sent is enclosed in the message body of the request, which can then be processed to a specified resource. We'll use a post request to favorite or unfavorite a movie in the Favorite Movies list of our app. So let's go back to the movie database's API documentation. By searching for the word favorite on the API page, I found this method, which allows me to add or remove a movie to an account's favorite list, which seems like what we want. Now we'll click on the post banner to open up the right-hand panel, which has information on how to set up this request. Here at the top, we see the URL that the POST request should be made to. In other words, that's where the resource we want to update is located. Now, this section underneath that is titled request should give us the information that we need to create this in code. These little drop down menus give us a few additional options. Let's keep this setting as production and this one appears to be a language setting, so let's set it to Swift and see what we get. Cool, this looks like stuff we can use even if we don't know exactly what it is yet. But before we dig into it, I feel like we missed something. What was this over here at the top before we changed to Swift? Headers, we haven't talked about that yet. So headers are actually a part of an HTTP request along with the URL and the message body, they allow us to supply additional parameters that specify how the request should operate. Here we see that for this request, two headers are supplied. The accept header field allows us to specify which content types will accept in response. In our case, we want to accept JSON as our response. The content type header field let's us specify what kind of content we're sending in the body. In other words, what format our data is in, so that the server knows what's coming and can determine how to parse it. There are many other types of HTTP header fields. A list of them is linked in the instructor notes. Awesome. Now, we understand what these headers are for. Let's go back to this code and see if we can understand what's happening. So this already looks a bit familiar, we did this when making our other requests. Here, we are creating the URL and then using NSMuteableURLRequest to make the request from the URL. Now these lines are new, but if you look at them, we already know what they're doing. Request.HTTPMethod = POST, we're setting our request method type to be of type post, then request.addvalue application/json for HTTP header field accept. This is just the code we need to set up our two header fields. Now if we look back at what was displayed when we had the language settings set to raw, there was what looked to be a bit of JSON. "Media_type", "movie", "media_id", 550, "favorite", true. This seems like the information we'd want to give the server, but with our own values specified. So it looks like this little JSON piece is here to show us what we should be sending. Let's look back at the Swift code we're provided. Request.HTTPBody =. So it looks like here's where we want to supply that data, the data that we want to post. This is where we should fill in what movie we're talking about and whether we want favorite to be true or not. Those can be variables that we can put in our code. The rest of this is actually all stuff we've seen before. Just getting the sessions, making the task, etc. We already know how to do that. So when you make this POST request in your app in Xcode, you should be able to copy over most of the spoiler plate code and only really need to change a few things. Now the final step in the My Favorite Movies app is adding the ability to add and remove favorites. And this is what'll happen when we click this favorite button here. If it's not selected and we click it, then a movie will be added as a favorite and if it's showing up as blue like for this movie. And we click it, it should remove it from our Favorites list. And this is going to require us to use our first HTTP post request. In the code, the button that we've been clicking is connected to the toggleFavorite action in the movieDetail view controller. Here at the top of the method we have a constant that's commented out. So let's uncomment this. And it's called shouldFavorite. This constant determines whether the request that we're going to make is going to set the favorite to true or false, or add or remove it from our favorites list. Then we have the familiar seven steps that you'll be implementing. Also, at the bottom in a comment section, I have the UI updates that you'll want to perform after the request is completed. Now, because this is a post request, some things are going to be different. I highly recommend that you look at the documentation for the account id favorite method, and use its example code as a starting point. The changes aren't that drastic and I think you'll be okay. Also, I'll give you two other hints. First, you'll need to use the movie property of the MovieDetailViewController. This property is going to be important as one of the parameters that you'll send in the JSON body. Second, when you parse the data for this request, you'll need to check for th status code. And the status code is returned in the results, and this will help you determine whether the request was successful or not. If you are favoriting a movie, then the status code you want to see is either 1 or 12. But if you're unfavoriting a movie the status code you'll want is 13. If you want to find out more information about status codes like these, I'll post a link in the instructor notes because these are not the only status codes that could be returned by the movie database. When you're finished implementing the toggle favorite method check this box. Here I am in the MovieDetailViewController file. Let's write the code to finish this out. First, let's set the parameters, which for this method are the ApiKey and the SessionID. Then let's build our URL, and this time the pathExtension is going to be /account, and then we'll substitute in our userID, and then favorite. Now the next steps are really important. We need to make sure the HTTPMethod for this request is set to POST. Then we want to add the value application/json for the Content-Type and the Accept headers. The Accept header tells the API that we will accept JSON in the response, the data that comes back to us. And the Content-Type header tells the API that the data that we'll be sending in the HTTP body should be treated like JSON, which leads us to our next step, creating the HTTP body. This can be done in one line using Swift's nice string interpolation. And here you can see that we're using that movie property so that we can get the movie's ID, because that's what's required here in the media_id argument. And then for favorite, we're going to use shouldFavorite to determine whether that should be true or false. All I've done here is adapted the example code from the documentation and set the values we want, specifically the movie!.id and the shouldFavorite. Then I can make the request. Now parsing and using the data is nothing new. Let's scroll down to the interesting part. Here we go. Now once we have converted the JSON into a useable dictionary, we need to check for the status codes. So let's pull up the status code here. And then if we are favoriting, so if we are setting favorite to true, then we'll want to look for 12 or 1 as the status code. And if we're not favoriting, if we're removing it from our favorites list, we need to look for a status code of 13. Then we need to update the UI to reflect those change. So if we just favorited a movie, that's true, then we'll set the tint color to nil, which will give it that blue color. Otherwise we'll set the tint color to black. All right, if we've done everything right then we'll be done with My Favorite Movies. I'll enter my user name and password, one last time. We'll it Login. And let me go to a movie I haven't looked up before. How about The Martian? We'll click the heart to favorite. And let's go to our Favorites. And it's added The Martian here at the bottom, so it looks like it's working. And let's go back to this and let's remove it. Go back to Favorites. And it has been removed from bottom. If we go back to here, you can see that it also updates and it's been removed from this particular view. By removed, I mean that it's been removed from our favorites. And this is it. We've made our first POST request and we're done with My Favorite Movies. Way to go. Now, if you want to download the completed version of this app, there's a download link and instructor notes and I encourage you to check it out. In this lesson we built the My Favorite Movies app while applying what we learned about authentication and security. As you build more networking apps, you should keep the importance of these things in mind. Because at the end of the day, what users really want are apps that are easy to use, perform well, and most importantly they keep their data secure. As we close out this lesson, take a moment to fill out the box below with the things that you've learned, as well as any feedback on how we can improve. Lesson four is next. There, we'll focus on improving our networking code while building the Movie Manager app. In the app, we can search for movies by name, like Big Hero 6, and then we can add it to our Favorites or to our Watch List. To build an app like this, we're going to have to get smarter about how we design our apps. If we don't, these changes will get really big and messy. So, join me in lesson four, as we improve our code by building the Movie Manager app. When we finished our last lesson, our networking code was beginning to look bloated and clunky. This was the result of us throwing together code without considering sound design. In this lesson, we are going to fix that problem by adhering model, view, controller paradigm. We're going to do this while we build the Movie Manager app. Before we dive in, let's go back to Travis and hear his thoughts on building great apps that use the Movie Database. Hey Travis. We're about to try our hand at building a more complex app that uses the movie database. But before we do, we were wondering, what kind of apps would you like to see? What makes a great app that uses the movie database? You know, honestly anything and everything around movies, TV shows and, and actors and actresses. We have apps that let you, you know, keep track of personal watch lists, let you search your favorite movies, and find out who is in that movie with so and so. You know, my favorite apps are the ones that, you know, combine a nice, sleek, well thought out interface and tie in all those account features that we make available via sessions. It's really, really awesome when you see your hard work be taken by another developer and designer and, you know, lay it out on an iPhone. And you just see how that API powers the experience. You know, behind the scenes, and it's so seamless. And, you know, it's my job to make sure that that is, is as seamless as possible, and just works. And, you know, the more we get to see of that, you know, those, the pretty mobile apps, websites the better. Awesome. Thanks Travis. So, what to make of this? The big take away from Travis's answer is that his favorite apps are ones that are sleek and just work. I'd imagine that most people would agree with this statement because at the end of the day, users don't care about the code, they just care about the end product. But there's a catch. To make sure the end product is as seamless as possible, we have to have well-designed code. So let's take a look at our end product now, the Movie Manager. Here's the movie manager. Let's take a look at what it can do. This first screen should look familiar. It's like the login screen from last lesson, however in this lesson we're going to use a new auth flow that's similar to OAuth. OAuth's an authentication standard that focuses on. Our apps not having to collect usernames and passwords. And you can see here there's no username or password field anymore. Using this off-flow is going to be great exposure for us, because it's like OAuth. And OAuth is so commonly used by other APIs. If we tap the button then this web use display, and we can either allow or deny the app access to our user data. In some cases you may not see this screen first because you have to log in through the website so you may be presented with a username and a password except this time it's in a web view. In either case, once we get here we'll tap allow so that we can actually access the app. Once we're in, we have another tab view controller. And you can see here at the bottom we have a movies tab, a watchlist tab, and a favorites tab. On the movie tab, we can search for movies by name so I'll start searching for one of my favorite movies, the school of rock and as I'm typing, you can see that the table view updates automatically. This is really slick. And then when we tap it, we're presented with this detail view. On the detail view you've seen this button before, this is the favorites button and then this button here will allow you to add the movie to your watch list. So I'll go ahead and add school of rock to my favorites and to my watch list. And then rather intuitively I can go back to the watch list tab and school of rock's been added here at the bottom. And then if you look at the favorites tab, it's also been added to the bottom here. And that's the app. Let's go build it. Like in the previous lesson, this app, the Movie Manager, has increased in complexity again. And this is all the more reason for us to check out the code base ourselves. At work, I find myself diving into unknown code bases all the time to get up to speed on a new project. Okay, so first you'll want to download the starter code project for the Movie Manager app. I've posted a download link in the instructor notes. And then, you'll want to answer the following questions. Which class is used to handle Step 2a of the movie database's authentication flow? Which class is the only view class in the project? What is the name of the file containing constants for the movie database? And finally, based on the movie database constants, how many methods of the movie database API will this app use? You can write your answers in the boxes next to each question. The answer to the first question is the TMDBAuthViewController. We're going to cover how this class handles step 2a of the authentication flow in more detail later in this lesson. Next the only view class that we have is the bordered button. The next question should have introduced you to the TMDBConstants.swift file. This file contains stokes and constants related to the movie database. And the last answer is actually derived from the TMDConstants file. If you look at the method stroke, there are a total of nine methods that this app will use. Hopefully these questions force you to look at a few files. But, if you haven't all ready, I would recommend taking a quick look through the project before moving on. This project is already split in some virtual folders that will get us thinking about the Model view and Controller. The AppDelegate and the GCDBlackbox have been place outside of this folders and we can ignore them for now. In the Model folder, we have this clients folder and then under Clients, we have TMDB for the movie database. This folder structure represents the idea that we could have multiple clients or managers that handle all the code related to an API, but since we're only working with the movie database, we just have the single TMDB folder, but you could imagine others like one for Flickr or Facebook or so forth. Now in the TMDB folder, we have SWF files that pertain to the main model of our project, the TMDB movie as well as the API's configs, constants and a TMBD client that will handle all the communications with the API itself. We'll talk about this more later. You'll also notice there's this one controller-like file called TMBDOffViewController. We've designated this file as part of the model instead of the controller, because it's used specifically for the movie databases off-flow and nowhere else. But that was just our design decision, it doesn't have to be this way. If we look inside the TMDBClient file, we see that the client is only partially implemented. These two methods here are still commented out. Here at the top, we've moved the authentication state into this class instead of it being in the app delegate like it was in my favorite movies. And if we scroll to the bottom, we have some helper methods. And at the very bottom, we have a method that allows us to use this client like a singleton. So, in a very similar way as to how we use the AppDelegate in My Favorite Movies. Now these two empty methods at the top called taskForGETMethod and taskForPostMethod. The purpose of these methods is to reduce the common code in our request and you've probably noticed that there's a lot of common code between each network request that we've been making. We also have this TMDBConvenience.swift file, which you'll be adding code to as well. Now let's look at the View, it contains a single file called Borderdbutton.swift. Now some of you may be thinking, what gives? Shouldn't this folder contain our storyboards and media files since they are what the user sees, they are the View. Well, you could do it that way and it's really up to you, but we've decided to keep our NBC folder split and organization or we're just focusing on the SWF files and not the other associated media files. Our reasoning for this is because most of the actual view classes have already been built by Apple and are packaged together inside of UIKit. And in that way, we've decided that this View folder over here should only contain custom code of ours that is purely view-related. So in this case, the only custom UI code that we have is this BorderedButton. Finally, let's talk about the controllers. This folder contains classes that touch a little bit of the view and a little bit of our model. I'll start with the loginViewController. This class is a prime candidate for why our previous app, My Favorite Movies was so poorly designed. In this controller, we have four methods for the four different steps that are require for the movie databases authorization flow and you'll note that the log in with token uses the new step to A, which we're going to cover more detail later. But we have the getRequestToken, then loginWithToken, which is step two. GetSessionID and then the user ID isn't really part of the authorization flow, but we get the user ID ahead of time, so that we can use it with requests like adding and removing movies from favorites. Now each of these methods, let me blow one of them out right here. Each of these methods has a lot of duplicate code and they make this controller a really big and heavy class. I think, let's see, we're at 340 lines right now. So, it's starting to get pretty large. But what's worse is that if want to add more complexity, this controller is just going to keep growing and growing and become really hard to deal with. And when you have big files like this and lots of duplicate code, then you know you have problems. What we should be thinking about is how we make our code light, clean and reuseable not overly complex and hard to manage? For our apps, a great way to fix this problem is to always keep our view controller small by migrating a logic like this, this networking code away into the model. So for this application, we're going to take the code that's in this login view controller and move it into the model or into the movie database client, this TMDB client. We need an API client, but how do we design it? A good place to start is thinking about the API methods that we want to make and what they might return. So what methods or function calls do we need to make? If we list the API interactions that we need, then we can write convenient API methods for each one. The interactions we need are getting a request token, getting a session ID, getting the user's ID, searching movies by search string, getting a user's favorite movies, adding and removing favorite movies, getting a user's watchlist movies, and finally, adding or removing watchlist movies. For this exercise, I want you to think of an intuitive function name for each requirement and what these functions might return. There are no perfect answers for this exercise, but some answers are better than others. Typically, we want to go with simple, intuitive function names with return types that are convenient and expected. Using something simple and intuitive may be like, for this one, get request token, is a property of good reusable APIs, and you should assume that others want to use your API client in their projects. So take this approach with each of your function names that you write here and then write the return types here. Here are my answers for the function names. And as you can see, most of these are named in a pretty straightforward way. It's almost a one-to-one mapping with the requirements that we saw in the interactions here. As for the return types, getRequestToken should return the request token, which is a string, and the same applies for getSessionID. Then for getting the UserID we should return an integer because that's what the UserID is represented as. For getting movies by search String or getting favorite movies, or even getting our watchlist movies, each of these three functions all return an array of movies, and so you can see the brackets here and then the TMBDMovie object is what should be returned. And then in final two POST functions, postToFavorites and postToWatchlist, we should return the status code indicating whether the post succeeded or not, and the status code is represented as an integer. Again, all these answers are not absolute. This is just my design approach to the API methods. We'll use these functions as we implement the Movie Manager, but as you build apps, feel free to create and to tweak API clients over time, until you have something that's usable and awesome. To improve our networking code, we need to find a way to reduce the redundancy between each network request. Right now, we're looking at the login view controller and we have this split view. On the left we have the get Session ID method, and on the right we have the get User ID method, and there's a lot of code duplication between these requests, as well as our other requests. Now these methods have been modified ever so slightly since the MyFavoriteMovies app, but nothing drastic, you should be able to follow this. Now what we want to do is identify what's common between both of these requests. This is what's going to allow us to create a reusable piece of code to get rid of all the stuplication. For example, in each of these requests, we don't need to duplicate adding the ApiKey. Both of these methods take the API key. So maybe we can pull that out. And if we keep looking we'll find plenty more examples of this. So for this exercise called Abstracting Away Redundant Code I'm going to provide you with a code snippet of the getSessionID method. And this code snippet, you can find in the instructor notes. And you're going to look at this snippet and determine which sections of the code are redundant by comparing it to the other network request. And finding these redundancies is going to be such a valuable skill for you to practice and it's going to give us a basis for how to build our API client. Now when you're done looking at the code and you found the sections you think are redundant, I want you to enter for the section numbers as a comma separated list in this box. For example, if the redundant sections are 2, 4 and 8, then your answer should look like this. And the sections are numbered within the code snippet that you'll download. Here are the redundant sections. They were 1, 3, 5, 7, 8, and 11. If we go back to the code, we can confirm this. For each network request that we currently have in the project, we need the API key, so that's definitely redundant. Then, we always need to build the URL and the request object, but sometimes the path extension is different. So the path extension part itself is not redundant, or the same, between our different network requests. Moving on, creating the network task is always the same. However in the completion handler, we may handle errors differently. For example, on both of these methods, we may want to display an error back to the user in the login view itself, but that doesn't always have to be the case. We may have a network request for adding or removing favorite movies, and for that we might want to use an alert view or something different. Next as we keep scrolling, we always make the same guard checks, these three here, and then we always convert our data, our deserialize the JSON into a usable dictionary. So these sections are redundant. This is the big difference in our code after we have the dictionary and we start looking for the values that we need. So for all the other redundant code that we've seen above and even the task.resume, this is redundant as well. We need to move this into something reusable. And if you're thinking, hey why not move the redundant code into a function or method, then you're on the right track. We're going to do this next. So let's look back at the TMDBClient.swift file. There are two commented methods in this file called taskForGETMethod and taskForPOSTMethod. The goals of these methods is to take the duplicate code that exists for the GET request the the POST requests that we're making to the movie database and moving them here. Now, you could create different methods for this goal. They don't have to be called taskForGETMethod and taskForPOSTMethod. Those were just some names that we chose for this example. Now you could even split these methods taskForGETMethod and taskForPOSTMethod into smaller methods, each specialized for a different part of making a network task. So maybe building the URL, making the task and then you could have something that checks the errors and I'd highly encourage that. But for now, we're just going to work with these two methods. I'm going to delete these real quick and use them as a way of giving you an idea of how this kind of process works. How this process of better architecturing our apps work. Because at the end of the day, what we're really trying to accomplish here is better design of our code. And if you talk to ten different developers, you might get ten different ideas about what better design is, but that's kind of another topic. For now, let's just focus on what these methods take as parameters and what they return, so that we can work on this specific example. Each method takes a string parameter called method. The intent of this parameter is to represent the API method that should be used by the request. So remember these are things like, what was it, authentication, validate with token or slash account. These were the methods that we're talking about, then our second parameter for lack of a better word is called parameters and it's a variable parameter and it takes any of the parameters that we want to specify in the URL such as the ApIKey. These are things that go in the query portion of the URL. Next, for the taskForPOSTMethod, we have this extra parameter that's not included in taskForGET called jsonBody. And of course, this parameter allows us to pass in values into the HTTP body of a post request and we'll look at it more later. Now, the last parameter is where these two methods get really interesting. Both methods end with a closure parameter called a completionHandlerForGET in this case and completionHandlerForPOST in the taskForPOSTMethod. Now remember, a closure is just a block of code. If you need a refresher on closures, I recommend that you go back and watch the SWF syntax section that we have on closures. Now these closures that we've called completion handlers, they're very similar to the completion handlers that you seen before when we used the NSURLSessionDataTask for request and we can look an example at over here. Remember, those completion handlers, they had the data, response and error parameters and these completion handlers aren't run until the data task itself completes and then it executes this block of code. These things are very similar here on the left. These completion handlers very similar, but the signature is just a little bit different. These completion handlers take result, which could be AnyObject and an optional NSError and a return void or nothing. We're going to use these completion handlers to pass back the resulting data from our network requests in the result parameter or if an error happens for our request, then we'll pass back back the error in the error parameter. If that was hard to follow, then let's pause and let's take a look at the taskFor GetImageMethod. It's already implemented and it has a similar completion handler, it's called completionHandlerForImage and it's going to look very much like what we'll do for these two methods. So, let's take a look at this one real quick. So in this method, we start by building the URL, so we can make a network request for some image. Keep scrolling, there we go. It makes the request and then the completion handler for the request, it starts with our series of guard statements to make sure that there was no error and then assuming all these guard statements pass, then it calls the completionHandlerForImage. And it passes the resulting data, the imageData and because there was no error, it passes nil for the error and then it calls the resume method for the task to make sure it runs and then we return the network task. Now the network task being returned here is just an implementation detail, don't worry about that for now. Let's focus on this call to the completionHandlerForImage. This line of code, it calls the closure that's passed Into taskForGETImage. It's calling this closure. So, let's see what this looks like if we're call taskForGETImage. It's going to make this make a lot more sense, I think. Now back in our loginViewController, let's pretend that I want to call taskForGETImage. So to call this, I'm going to specify some phony size and file path and then we'll get to the completionHandlerForImage closure part. Now, this is where we get a real opportunity to see the power of closures. Here where I'm calling taskForGetImage, I want to specify what I want to happen when this task completes. Closure, which we've specified as a trailing closure, it has access to the imageData and any error that may have occurred and you can get rid of Void here. If you think about it, this is the exact same behavior that we want with our taskForGETMethod and taskForPOSTMethod. Inside of our view controller, so this is our loginViewController remember, we want to be able to make our request using the client. So that TMDB client's being used and then when the request completes, we can use the resulting data or the error in the view controller. And this helps reduce the complexity of our view controllers, because it puts all of the networking code into the client. We don't see any networking code here. We just see the tasks that we're wanting to call and we see, hey, we're going to get some data back or some error back. What do you want to do with it? So from the perspective of the view controller, we don't really care how the networking works. We just want to know are there results or was there an error and then we can handle those cases appropriately. So that was a lot to take in, so let's just pause for a second. If you need to take a deep breath, if you need to go back and rewatch this video from the beginning, feel free. When you're ready to move forward, we're going to get started with tasksForGETMethod and it's going to look a lot like this taskForGETImage in the sense that it's going to allow our view controllers to just make the call and then have our completion handler, our closure here, specify what we want to do with the results. To begin writing our task for GET method, I'm still in this split view. And on the left, I have the task for GET method that we're going to implement in the TMDB client. And on the right, we're looking at the get SessionID method in the login view controller. And if you don't know how to use the split view, you just need to select the assistant editor here and then you can select which files you want using these file navigators here at the top for the left and right views. Now, what we want to do is pull the common code elements out of getSessionID from here on the right into the taskForGETMethod on the left. Now as we stated earlier, each method may have different parameters, but they all take the ApiKey. So as our first step for test for GEt method, we can ensure that the APIs included in our request by adding it to our parameters dictionary, that's past in the function. And remember, this can change, because the dictionary itself can change, because we declared it as a variable parameter. Next, we need to build the URL on the requested object. So I've copied over the two and three steps here from getSessionID, but they need to be tweaked slightly, so that we can construct the URL depending on the method that we're using. And remember, we pass in the method strain as the first parameter for taskForGETMethod. So for the withPathExtension argument, let's just change this to method. Now let's create the request and start to finding the completion handler for the data task with request method. In getSessionID, the first thing that we do is to find the display error function, but we don't need that here in taskForGETMethod. Instead, we'll let whoever calls task for GET method handle any errors that we pass back using that completionHandlerForGET. Remember, how when we looked at taskForGETImage, I think it was. Yep and login view controller that we can respond to the image data that was being passed back or the error that was being passed back, that's where we're going to let people respond to the errors using this completion handler. So, we're not going to add that here. Instead, the first thing that we're going to do is make these GUARD checks. So, let's copy the GUARD statements that we've been using all along and let's move them over here. And instead of calling it displayError, we can use the completionHandlerforGET to send the error back. So I'll define a method called sendError, which is going to be similar to our displayError. It's going to construct a NSError like we need and then our result that it's going to pass back is nil and then we can just simply replace diplayError with sendError, sendError and sendError. There we go. Now, we're ready to turn our JSON into a usable dictionary after we've made these GUARD checks. Now, we can do that by copying this code over or we can use a method that's already defined in the TMDB client and that method is called convertDataWithCompletionHandler. So if we pass in our data and then it also takes a completion handler and this completion handler, its signature, it matches the signature of our completionHandleForGET. So, let's do that and then let's go down to see what this or we could scroll down or we can click to see what this method actually looks like. Now, this method takes our data and then it takes a completion handler or closure matching the closure type that we saw for what is it, completionHandlerForGET. So let's go back down here and what this is going to allowed us method to do is to handle the converting of our data into usable dictionary and because it takes our completion handler, it can call it. So if this conversion into usable dictionary fails, then it can call our completion handler and it will pass nil for the results and pass the NSError. Our error with the ConvertDataWithCompletionHandler. Otherwise, it'll call it and pass our results back, our usable dictionary and an error of nil. And this will bubble backup to where it's being called here, which in turn, you can think of it as bubbling back u to wherever the completionHandlerForGET is defined, so in our view controller. It will bubble back up with either the resulting data or our error and the last thing we need to do is to make sure we start the task, which we already have that there and that's it. We now have a reusable method that will make a GET request and return some data or an error from the movie database. So next, we're going to do the same thing for task for POST method. Now, it's going to be your turn to implement the task for POSTMethod. This method should look very similar to task for GETMethod with one major difference, the HTTP body. Remember, HTTP POSTRequest can send extra parameters through the HTTP body. So, you'll need to account for this by modifying the request object, which should be a NSMutableURLRequest, and then have the appropriate HTTP body, HTTP method, and header values. Also as a hint when you're creating this method, I'd recommend looking at the post requests that you made in the My Favorite Movies app, the one that you made to add or remove a movie from favorites. When you're done, check this box. Hopefully you got something like this. The taskForPOSTMethod should start very similarly to how the taskForGETMethod started. We should add the ApiKey to the parameters. And then for the request, it should be an NSMutableURLRequest instead of just the NSURLRequest. And we want to configure the method to be of type POST, whoops, there we go. And then we want to add the header values or the Accept and Content-Type header. And finally we want to add the HTTP body. >From here the rest of the method is almost a carbon copy. The main difference being that we use completionHandlerforPOST instead of completionHandlerforGET. Now the fact that the rest of this code is almost a carbon copy of taskForGetMethod means that it could probably have been placed in its own method too. But we're going to pause just short of doing that like we said earlier. We're just going to focus on taskForGETMethod and taskForPOSTMethod. Now, this is only half the battle. We have to use these methods. So, to make this work, we're going to pair task forget method, and task for post method, with what we're going to call convenience functions. And, these convenience functions will be the perfect solution for removing all the web service logic away from our controllers, and we'll implement those in just a moment. But first, let's outline our new authentication flow that we're going to be using. Let's return to our chart and make just a small change. Instead of logging in with the API, we can now actually use the website to log in. The first step, getting the request token, is still the same. So let's do that first and then we'll cover logging in with the website in more detail. With our test for GET method in place, it's time to write our first convenience function. I'm here in the login view controller, and I ultimately want to make a single call to run the entire authentication flow and access the app. To do this we've created a method called authenticateWithViewController, and it's part of the TMDB client. To use this, we'll use the TMDB client shared instance and we'll call the authenticateWithViewController method. This method takes a host ViewController, which should be this log in ViewController and a completion handler to let us know if the off flow succeeded, or there's an error string if it failed. So I'll go ahead and specify self, and then if I'll hit enter on this parameter, it will auto complete, and we have our trailing closure. We can get rid of void for now. So at this point, we actually know enough to finish this completion handler. If the off flow is successful, then we need to log in. But if it's not successful, then we can display an error to users. Now for either of these cases we want to make sure that these lines of code, which affect the UI, are run using the form UI updates on main function. Now let's dive into the authenticateWithViewController method and see what's going on. Yikes, okay, this method is definitely not pretty. We have this pyramid of code kind of jutting out to the right and then it's coming back down to the left here and just hard to understand what's going on. Sometimes you hear this type of code referred to as a pyramid of doom. And the reason that this is happening is because we have a bunch of completion handlers nested within each other. Now the reason we have to do this is because, for instance, when we call getRequestToken, we have to wait for it to complete before we call loginWithToken. And this continues all the way down until our final step, which is getUserID. And this looks exactly like what we saw in this flowchart. So let's kind of break this down piece by piece. So I'll just bring this back up, so that we can have a restricted view here, and let's look at the getRequestToken. If it succeeds, then we're going to print the requestToken, we'll store it, and then, we'll call loginWithToken. Otherwise, we're going to call this completionHandlerForAuth and we're going to pass it success, which in this case is false, and an error string that's generated by getRequestToken. Now if we succeed, we're going to log in with the token, and let's see what this looks like. And let me go ahead and collapse the getSessionId. And similarly, if this request succeeds, then we are going to call getSessionID with our request token, otherwise we are going to call completionHandlerforAuth. We are going to pass it at failure and then the error string in this case is coming from our loginWithToken. Then if that suceeds we'll go with sessionID. Let me bring this back up, store the session ID, get the user ID. This is our successful case. Otherwise not a success. Only pass the error string. And let's get user ID. And there we go. And this is hopefully our final success case here, where we're storing the user ID. And then, success or fail, we're going to call completion handler for auth with whatever value success gets from getUserID, and whatever value error string it's populated with, hopefully null. Now, all this nesting of completion handlers is extremely hard to look at, it's hard to manage, and it's hard to reason about, and if you follow people in the iOS community, they're saying the exact same thing about code that looks like this, which is why there are nice alternatives to this nesting structure. But they're outside the scope of this course. If you're interested, I'll post some links in the instructor notes where you can find out more. Let's go back to the getRequestToken. We'll follow it by command clicking, there we go. This is the first convenience method that you're going to be implementing in this exercise. The comments include these three steps that you'll want to complete to call the taskForGET method that we implemented earlier. And for this third step, we see it says send the desired values to completion handler. The completion handler it's referring to is this completion handler. We have success, requestToken, which can be an optional string. So it's nil or a string, and then the error string as well. And this is what's going to be populating, here we go, these values here, so take some time to finish implementing get request token. Remember you'll need to specify the parameters and method in order to call taskForGET method. Then take the data resulting from task forget method call and extract the desired value and return it back in the completion handler. If you do this correctly, then the request token should be printed out. When you're done, check this box. Let's walk through the solution step by step. First, when specifying the parameters, the request token method only needs the API key. So, we can just create this empty dictionary, because the task forget method will add the API key when we call it. Now when we call the task forget method, we want to use the method authentication token new, and then we'll pass in our parameters, and now we need to move on to step three. First, we'll check to see if an error was returned. If an error is returned we'll print it, and then we'll call our completion handler for token, we'll pass, success is false, there's no request token, it's nil, and we'll give some error strain. Otherwise, we need to pull the request token out of the results, so we'll look at the request token key here. We'll grab a request token. And then we'll call the completion handler for token where success is true. We'll pass our request token. And there's no error string. Or, if we can't find the key, then we'll handle that accordingly here. Let's go ahead and run this, and see what happens. If everything works correctly, then when I click this button, it'll start our off flow. And there's our request token. Now, all the steps we've taken to get back to this point may seem like a lot of work for what we already did, or something that we did similarly in lesson three. But, that's the wrong mindset. By splitting our code up like this, it becomes much easier to manage. And as we move forward, it'll be easier to add new methods to interact with the movie database. For our next step, we need to authenticate by logging into the movie database, but this time we're going to use a different offload that goes to the movie database website. Let's go back to Travis for a little bit of context. Travis can you explain this, how we use this flow when we log into the website to authenticate, and why did you go with this approach instead of using something popular like OAuth? Yeah, no, for sure. So back when I did the first pass of authentication OAuth was just a little bit of a mess. And, you know, [COUGH] instead of trying to force this system that was just kind of broken onto our users', I just had the tools or something that was really close to OAuth, but ultimately our own. And, you know, you'll see as you go through the principles of OAuth, and our off flow are almost identical. You do all the, you know, credential checking on the website, so you're not passing usernames and passwords over the air they're really almost identical. It's just that we, we just thought it was a lot easier to do it ourselves. Thanks for filling us in, Travis. Rolling your own solutions definitely sometimes the best way to get the functionality that you want. And before we move ahead, let's take a look at those principles that Travis was referring to. I wana focus on a key point that Travis mentioned about this new outflow. He said that the credential checking is done on the website. Instead of passing usernames and passwords over the air, the users are asked to give their consent for an app to access resources on their behalf. Behind the scenes, this interaction can get really complex. And the standards are always changing. So I just want to give you a high level view of what is happening, and why. For many apps you may have seen are screen like this one. This is the app Trivia Crack, asking me for permission to use the Facebook API, on my user's behalf. Notice the glaring similarities between this screen, and the screen for the movie manager. In either case, whether I'm selecting OK here, or Allow here, what's happening behind the scenes is that both of these apps are going to be given some type of request token, that'll allow them to access user resources. For instance, if I select OK here, then I've given consent for Trivia Crack to use Facebook to access things like my friends list, so it can display it in the app. Some of you maybe asking the same question that I did, which is to even get to this consent form, doesn't it require me to pass my credentials over the air at some point? Yes it does. However, the main difference is that your credentials are shared with a third party. Instead of your apps. For example, here the credentials are shared with Facebook and a Browser instead of Trivia Crack and for us the credentials are shared with the Browser and TheMovieDB instead of the movie manager. If you were instead enter your credentials directly into the app. Or even worse, store them on the app. This could be a big security problem. Instead, this approach takes the liability away from our apps and puts them on the third party and the browser, which are pretty trusted systems. For the movie manager, we'll use a UI WebView to handle this process. Alternatively, one could use Safari to handle this entire interaction, where the app opens Safari. Ask the user for consent and then we go back to the app, but we won't take this approach in this course. The next step in the off-low is to authenticate the user using the movie data base website. In code, we go right into this step and we call it the login with token method. Let's dive into this method and see how it works. First, we construct the URL specified in the documentation that ends with our request token. Using this URL, we create a request, and then we create a instance of the TMDBAuthViewController. This TMDBAuthViewController itself contains a UIWebView. If you haven't used a UIWebView before, it's a view provided from UIkit that can be used to display web content. So once we create this ViewController, we start setting its properties that are going to control how the WebView behaves. Notice this really important step here. We set the ViewController's completionHandlerForView property equal to the completionHandlerAccepted by the login with token method. What this will allow the ViewController to do is to redirect execution back to our API client, once the WebView has dismissed. So now the real question, how do we know when to dismiss the WebView? Let's run the app to gain some insight. If I tap the authenticate button, then the WebView should appear. Now this WebView will appear with either this screen or the login screen, if you haven't logged in yet. But once you log in, let's click Allow. The next screen tells us that we have given consent. But we need to dismiss the view. Now let's go back to the TMDBAuthViewController. The key to dismissing this view is implementing a function that's part of the UIWebViewDelegate. In particular, we need to determine when the WebView has redirected us to a page that confirms that the user has given us consent, like when they clicked Allow. So for this exercise, you'll be implementing this behavior. First, determine the appropriate UIWebViewDelegate function to use. This function should allow you to check the URL that is loaded by the WebView. And you'll want to check if the URL indicates that the user has given consent. If that URL is loaded, then dismiss the controller. When you're done adding this functionality, check this box. I'll start answering this question by looking at Apple's documentation for the UIWebViewDelegate. If we scroll down, of these four methods listed, webViewDidFinishLoad definitely stands out as the method that we're looking for. With this method we should have access to the URLs that are being loaded by a webview, including the URL that's loaded after a user taps Allow. Now checking for this is surprisingly simple. Back in the TMDBAuthViewController, I'll start by implementing webViewDidFinishLoad. In this function, I can check for the webview's current URL by digging into this absoluteString. I'll just print this value out first to see what the URL is after the user's clicked Allow. So, we've clicked Allow, and the last URL that's printed here, this is the value we'll want to capture in order to dismiss the view. So let's stop this and finish the implementation. So we'll check the absoluteString, and if it's equal to the AuthorizationURL plus the requestToken and allow, then we can assume that the user's clicked the Allow button. If that's the case, then we'll dismiss the ViewController and call the completitionHandler that we stored earlier. Let's see if this works. And there we go, the controller dismisses. Now that we're logged in, the next two steps are to get the Session ID and the User ID. Each of these steps will closely mimic what we did to get the Request Token. In code we already called getSessionID here, and getUserID here. So all you need to do is correctly implement both of these convenience methods. If you implement these correctly then the completionHandlerForAuth closure will be called, where success is true, and we don't have any errorString. This should cause the main tab view to be presented and we're ready to use the app. Okay, so now it's your turn. When you're done implementing getSessionID, and getUserID, check this box. I'll walk you through my implementations. For getting the session ID we start by specifying a dictionary of parameters with just the RequestToken. And then the API key will be added by taskForGetMethod. Then to make the request we'll use the AuthenticationSessionNew constant. >From this point the rest of the code is much like before. We check for an error here. Otherwise we're looking for the session ID. if we successfully find the sessionID, then we return it as part of the completion handler. Okay, now let's look at get userID, it takes the session ID as a parameter so we've specified it here. And we're going to call the task FerGET method using the APIs account method. Then in the resulting data, we look for the ID key. Let's check. Is that ID? Yeah, so the ID key, and that'll give us the user ID, and then we pass this back in the completion handler, and for this to work you may notice that we need to cast this into an integer. So let's go ahead and run this and see if we make it to the main screen. I'll click to authenticate, and I'll click Allow. And after everything runs behind the scenes, our main tab view controller appears. Nice. Now I know this may not seem like a huge breakthrough, but the big payoff is back in the code. If we go back to the LoginViewController, look how nice the API client hides away all the networking code. This is literally all our log-in view controller needs to see. And we can go ahead and remove all the existing functions that we had. So let's get rid of those. The auth flow is complete and we can continue implementing the rest of the Movie Manager app. Back in the code, I'm now working with the more completed version of the app. You can download this version of the app with the link in the instructor notes. This version has implemented some more of the movie database client and its methods, and I'll run it to show you what's going on. We can login using our new auth flow. And here in the movie picker view we can search for movies. So I'll do a quick search and I'll select a movie. >From here we can favorite and unfavorite a movie, but the watchlist functionality is left incomplete. If we go back you can see this when we select the WatchList tab, because no movies are populating the table view. But the Favorites tab is working just fine. Okay, so let's stop this and go back to the code. Here in the TMDBConvenience file, we'll scroll down to getWatchListMovies. This is one of two methods that is not implemented yet, and those will be the focus of the next two exercises. Now this method's what's used to populate the WatchList tab with movies from your watchlist and it's going to be up to you to implement it. To implement this method, I want you to look at the already implemented methods getMoviesForSearchString and getFavoriteMovies. Really study them and pay close attention to the substitute key and helper method that's used in getFavoriteMovies. When you've finished implementing getWatchlistMovies, you should see your watchlist movies in the WatchList tab. And when you're done with this exercise, check this box. Let's take a look at the solution. Like getFavoriteMovies,our first step will be to specify the session ID as one of the parameters. Then because the method contains the ID that we need to substitute with the user ID, we can use this substituteKeyInMethod. If we follow the constant that we used here, you can see that there's the ID that will end up being substituted. The next step is to make the git request. Then we check for an error. Otherwise, we have our results. Now the results in this case is an array of dictionaries, so we can use this moviesFromResults method that's part of the TMDBMovie to create an array of TMDBMovies from the array of dictionaries. And then we return them in the completion handler. Okay, let's see if this works. I'll run the app, we'll click through to authenticate, and then, let's go to the watch list. And here, in the watch list, I see some movies that are on my watch list and I can check the movie database website to verify that these movies are indeed on my watch list. We've had our taskForPOSTMethod in place for a while. Now we're going to use it. So let's go to the TMDBConvenience file and find our last unimplemented method. Here we go, postToWatchList. This is the method that you'll implement. This method should closely mimic the postToFavorites convenience method, and when it's complete, you'll be done with the movie manager. Also, if this doesn't seem like enough of a challenge, why not try adding the ability to display a movie's rating as a bonus feature? With the movie database client in place, it should be a short amount of work. Now this isn't a requirement but it is a cool bonus to really flex your networking muscles, and make sure you understand the benefit and the power of our new client. Let's take the steps to complete postToWatchList. I'm going to start by copying the code over from postToFavorites since they should be similar. Now wait a minute, you may be thinking to yourself, Jared's copying code again, this means that we have duplication, so should be abstracting this away into something more elegant? Well the answer's yes and no. These methods do share some of the code but it's really just indicative of the fact that these two methods use similar kinds of data. Now think of it this way, if you're going to abstract some of this code into another method, how often would that method be called? Would it be reused as often as something like task forget method or would it only be called once? This is the kind of thinking you're going to have to do as a developer, and that's the real beauty of design. My advice would be to abstract away functionality into methods as necessary, but don't overdesign something. You want to strike a balance. Anyways, back to the code. The first thing I need to change is the method that's being used. So in this case we want to use the AccountID watchlist. There we go. Then I want to change the JSON body to use the watch list key, and the watch list value, that's passed into this function. There we go. We'll also need to change over the name of the completion handler. And we may also want to change our error string here. Outside of this, the rest of the code can remain the same. So, lets give this one more run. Click through to authenticate. I'll go to my watch list and let's go to the Lego movie. Now let me pull it off my watch list, that looks like it's working. It's no longer there, and let's add it back. And I'll check our watch list. And there it is. If you've made it this far then you're done with the Movie Manager. Congratulations. In this lesson we built the movie manager and an API client for the Movie Database. We also talked about the different authorization flows that you might see when you build apps. You'll want to remember this lesson well because the principles taught here are really going to help you when you start building more complex apps. So before we head into the final lesson of the course, let us know what you've learned as well as any feedback on how we can improve. You're now ready for the final lesson in the course. In this lesson, I'm going to prepare you to build the course app called On the Map. Here's the app in action. First you login with your Udacity credentials. And then you're going to be presented with a map that shows the locations of other iOS students that are in the program. So you can see these pins here. And I'm going to go ahead and submit my location. Which is Mountain View, California, that's where we're located. So I'll paste it here and I'll find it on the map. And them I'm going to share the link for the iOS nano degree. And I'll submit this and you can see my pin's posted on the map. As well as these pins for the other iOS instructors. This is pretty cool. And without further ado, it's time to go to the final lesson and build On the Map. Hey everyone and welcome to the final lesson of this course. At this point you should be comfortable making web service requests and have a good basis for designing API clients. So to wrap things up, I'm going to introduce you to a network performance tool, some other extended topics, and prepare you to build on the map. Here are four networking apps that we've built this course. But there's a glaring problem with each of these. For each of these apps we've assumed near perfect network conditions. Or we've at least assumed that the network conditions were equivalent to the machines we were testing on. In the real world this is hardly the case. While networks are always getting better, connections are still unreliable. And as we build apps we need to keep these things in mind. To get us thinking about apps that address these kinds of network problems, we'll take a look at Apple Maps next. Here I am in the iOS simulator. Prepackaged with the simulator are several different apps, including Apple Maps. To get Maps to actually focus in on a location, we need to go to the debug settings, and set our location to one of the predefined locations. Or you could even put in your own custom location. I'll just select Apple for now. Then if you click the arrow in the bottom left-hand corner, it'll ask us whether we want to allow Maps to use our location or not. We'll click Allow. And now we're focused in on the location of Apple. I'm going to start dragging around on the map. I want you to pay attention to what's happening as I approach into new areas that haven't been loaded yet. As we expect the map just continues to load in these new grid squares, for new locations on the map. Now here's the fun part. I'm going to use a networking tool, which I'll introduce in just a moment, to change our packet loss to 100%. Essentially we have no network connection. My question to you is, what will happen when I start dragging this map around, when we have 100% packet loss? Will Maps crash? Will Maps display an error message that we've lost the network connection? Will Maps even allow us to drag at all? Or will Maps load empty grid squares? Put a check next to your answer. The correct answer is that maps will show empty grid squares. And here's it in action. When I drop the network connection and I start dragging around, you'll see that we have these empty grid squares that cannot be loaded. Now this is actually better than not crashing, obviously, so we might call this behavior failing gracefully. And in cases like this when our network connections completely gone, this is a great option. I like to think of the approach like this, to keep the user from not panicking your app shouldn't panic either, just fail gracefully. Let's take one more look at how Apple Maps would respond in the face of network problems. Just like the last exercise, I'm running Apple Maps with no network connection. But this time, let's say I want to post a pin to the map. What will Apple Maps do in this scenario when I try placing a pin and we have 100% packet loss? Will Maps allow me to drop a blank pin? Or maybe Maps won't let me drop a pin at all. Will Maps show an alert? Or the worst case scenario, will maps crash? Put a check next to your answer. When I ran this experiment, myself, Maps kind of surprised me. It'll actually let us drop a blank pin. Let's take a look now. We could see that the network connections down again because I'm getting these blank grid squares. And if I click and hold to drop a pin, then this blank pin is dropped. Here's another nice side effect, when the connection's restored, the pin automatically updates itself with a location. This is about as graceful as failure can get. In the last two exercises, I've been meddling with the network connection, turning it off and back on. The tool I'm using to do this is called the Network Link Conditioner. It's one of many tools that Apple makes available to developers for testing their apps. In fact, this tool can do a lot more than just turning the network on and off. It can also vary the network connection by what are known as profiles. A network profile, like the ones listed here, 100% loss, 3G, DSL they allow us to specify things like the up and down bandwidth and packet loss rates. So you can choose from any of the presets here. Or you can even create your own in Manage Profiles. I think it goes without saying that this tool is an invaluable resource for testing your networking apps. While you will not be required to use the Network Link Conditioner tool for on the map, you should at least install it for future work. To install the tool, you need to follow these steps. First in Xcode, go to the Xcode menu item here at the top, go to Open Developer Tool, and then click on this More Developer Tools option. >From here, you'll be directed to Apple's website and it'll ask you to log in if you haven't already using your Apple ID. Then on this Download for Apple Developers page, search for the network link conditioner tool. Once you've searched for it, you should see one of these Hardware IO Tools for Xcode downloads. You'll want to download the version of the hardware tools that's compatible with your version of Xcode. To complete this exercise, you'll need to download and install the Network Link Conditioner. If you get stuck at any point, you can check out the article I've linked to in the instructor notes. Check this box when you're done. When you finish installing the Network Link Conditioner, it should become available in your Mac System Preferences. We could see it here at the bottom. >From here it's as easy as turning the tool off and on and varying your profiles. But now for the real question. What are some general approaches to handling issues of poor network connections? We'll answer this next. Up to this point, all the apps that we've been building, we've assumed there's a, a perfect network connection. And we know that we can't always trust this, in the real world or, networks are flaky sometimes, sometimes non-existent. So, I brought Jason in to talk about what we can do in those situations. Yeah. Thanks Jared. The problem with an app like the Favorite Movies app, is we have to fetch everything every time we use it. So you think the movie poster's coming down, you fetch them all to populate the table, but then as soon as the cell scrolls off the bottom and back up, we don't re-fetch that poster. Mm. Each time. Right. It'd be nice if we could take that media and store it onto the hard drive to make it persistent. So, that's one type of data, but what will we do with a more structured data that we have, the movie structs themselves, that contain movie titles and Other information about movies? [CROSSTALK]. Yeah, that's no problem. We, we pull down that JSON. We punched it into an array of struts. We can take that entire array and persist it onto the hard drive in tact. We can pull it out and populate the table with it again. Cool, so this is the type of stuff we'd be learning in the persistence course. Yeah. Keep in mind you don't need to use any of this in the On the Map app, but it's fun to fetch data as much as you want. But in the Persistence course we'll learn these techniques. Oh. On the map, you'll be receiving a written spec for how the app should work. But since I'm kind of a visual person, I want to give you a demonstration of what it should look like. At the log-in screen, you're presented with the option of either logging in with your Udacity email and password, or you can authenticate with Facebook. Since the Facebook authentication is optional and not required, I'm going to go ahead and log in with my Udacity email and password. Once I've entered my email and my password, I'll go ahead and log in. The first screen I'll see is this tab view controller, with a tab for map and a tab for a list. In the map view, I can drag around on the map and I can see pins of other students who have placed their locations. So there's some over here on the east coast of the United States. Then we also have some over here on the west coast, near San Francisco. I've gone ahead and zoomed in on Florida. And if I tap this pin here, we can see that this was the pin posted by Jessica, and her link is for her LinkedIn profile. If I were to tap the link this would take us directly to Jessica's LinkedIn page in Safari. I'll go ahead and switch over to the list view, and we can see the names of the same people that have posted pins. In the same way, if I were to tap any of these entries, they would take me to the links that these students have provided. And if you haven't noticed, all the students here are actually some of the iOS instructors that we have. Now let's go back to the map. Here in the top left corner, I have the option of posting a pin. The basic requirements of this app say that you could post as many as pins as you would like. However, if you'd like to go the extra step, when you try to post a pin, you should check to see if a pin has already been posted for this user. And in my case, there already is a pin from me. So this menu here is asking me, would I like to overwrite my location, or do I want to cancel this request? I'll go ahead and select Overwrite. And now I'm presented with this input view. I'm going to overwrite my location to go back to my hometown of Huntsville, Alabama. And I'll find it on the map. And behind the scenes, the app geocodes the location into a longitude and a latitude where this pin will be placed. For my link, I'll share my LinkedIn profile. And then I'll tap Submit. So now the input process is done and my new pin is posted here in Huntsville, Alabama. And if I tap the pin, then there's my name and there's the link to my LinkedIn profile. And if I tap the annotation, then it takes me to my LinkedIn profile in Safari. These are the main user interactions for the app. If you're a visual learner like me, I hope this helps. You may be thinking, wow this app looks cool, but how do I even get started? So lets go over a few quick basics. First, this app is sort of similar to some of the previous apps we've made in this networking course. You should feel comfortable using those apps as references, or even for some starting code. Secondly, in the previous apps we've made, we've used various client API's to build out the apps functionality. For on the map you'll be using two such client APIs, the Udacity API and the Parse API. You'll be using the Udacity API to authenticate users. You'll do this by working with a web service method that we've exposed for this purpose. This Udacity API guide should take you through the process. The Parse API you'll be using to access data for the student pin locations and lengths. Parse is a common solution used by mobile apps for a persistent data in the cloud, and is an alternative to using core data, which we'll actually be talking about in the next course. Note that while Parse does have a SDK available for iOS, we want you to use the Parse web API for the on the map project. This Parse API guide should take you through the process of using Parse for this purpose. For this app, you'll also have the option to enable users to login through Facebook. This feature is not required, but we still want to give you some info in case you decide to attempt it. To enable Facebook login, you'll need to do the following. Read through Facebook's documentation on their login feature. Connect your own Udacity user account to your Facebook account, which can be done on the account settings page of the Udacity website. And at the bottom of the Udacity API Guide, you'll find some methods that you'll need to implement to get the Facebook login working. The last point I want to make is if you think of the app as one massive project, it can appear very daunting and make it hard to get started. That's why it's better to see the app as a bunch of pieces that make a whole, and tackle one chunk at a time. Making a simple wire frame or setting up the networking code of one of the aforementioned clients is a good place to start. As always, check out the forums for help or pointers. Congratulations, you're now at the end of the course and you should be proud of how far you've come. I want to take this time to say thank you. It's been a joy and a privilege to share this content with you. In this course we learned a lot about networking and how to use it in our apps. We started with simple web requests and built interesting and fun to use apps that gave users access to data over the network. We also looked at how to design our networking apps while adhering to the model view controller paradigm. Those are the two key takeaways I want you to finish with. Making web requests, and doing so while considering good design. These alone can get you pretty far, and they'll be crucial for completing on the map, but I know you can do it. So now it's your turn to go out and network for yourself. Again, thank you and always remember, keep learning I hope you had as much fun taking this course as I did creating it. I learned a lot in the process and I imagine that you did too. So take a moment and let us know the biggest takeaways of the course, as well as anything that we can improve on for the overall experience. Thanks again.