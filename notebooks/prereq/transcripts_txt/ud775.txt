Hi. Welcome to Version Control. I'm Carolyn, one of your instructors for the course. And I'm Sarah, your other instructor. In this course, we'll cover the concept of Version Control and why you might want to use it. Yeah. So, Version Control is sort of like having a giant undo button for your project. You mean like this one? Yeah, exactly. It makes it easy to save versions of your files at different points in time. You can also restore previous versions and compare different version. Yeah, it also makes it a lot easier to collaborate with other people. No more sending huge .zip files of your project back and forth. Now, learning to use Version Control is a little bit like learning to type: it's hard at first, but once you can do it, it makes you a lot more efficient. You might feel like learning a whole new system to keep track of versions of your files is a lot of work and maybe not worth it, or that if you're hard core enough, you don't need Version Control. But if you look at successful companies like Google and Facebook, you'll find that they all use Version Control internally. What about you, Caroline? Well, when I first started using Version Control, I basically only used it when I needed to. But now I like to use it for all of my projects. It's kind of addicting. Cool. Let's find out why. In this course, you'll learn to use Git, which is a version control system, and GitHub, a code sharing and collaboration platform. You'll need to use a Unix-style command line, so if you haven't used that before, then check out one of the tutorials in the instructor's notes. You'll also be looking at some code in this course, so experience reading and writing code will be useful, but it doesn't matter which particular programming languages you know. To give you a better sense of what you'll learn if you stick with us through this course, here's the rough breakdown. We'll have three lessons. In this first lesson, we'll focus on how version control can be useful and what different forms it might take. You'll also install Git and start using it to explore some existing code. Then, in lesson two, you'll learn more about Git and start using it on your own. Finally, in lesson three, you'll get some practice sharing code and collaborating with others using GitHub. Hey, I'm here with Larry, and he's been having a problem with a webpage he's been working on. I think this is a great opportunity to both help Larry out with his problem and to show you what version control can be useful for. Yeah, so, I've been working on a website, and it looks a lot different than it did before. There used to be a banner at the top. And like the design looked a lot better before. Hm, so, what did it look like before? I have an old version saved on this tab. Oh, yeah, I see. It looks like you changed the description. Yeah, I filled it in. Cool. Did you change anything else? I think I might have, but I'm not sure. Do you still have the HTML for this version? Yeah, I do. Cool, so you could compare the two and see what changed. Okay, let's try it. Now I want you to find the differences between the two versions of this HTML. Go ahead and find the lines that have changed, then enter the line numbers in this box, separated by commas. So other than the description, hm, it looks like you changed style1 to style! . [LAUGH] Huh, oh, yeah, I did do that. That wasn't intentional. I was going to change my stylesheet, but then at the last minute, I decided not to. I think I made a mistake. Yeah, sounds like a typo. So what happens if you fix that? Let's try it. Cool, it worked. Great. You know, it's kind of annoying doing it manually. Is there any way to get the computer to help me? Yeah, there are some built in tools that can automatically compare files. I'll go over how to use these in a minute. Good thing I saved the old one then. Yeah, I'm glad you did. In a bigger project, having an old version saved can mean that you spend a few minutes finding your mistake instead of hours. You just found the differences between these two files by hand and it worked all right. But it probably seemed pretty tedious and the files were also small. What if you had files with hundreds or even thousands of lines? Let's take a look at what we could do in that case. Now, let's take a look at a program that require's a bit more code. This is a game called Asteroids and I know this text is a little hard to read, but it says press space to start. Some of you may recognize that this is a classic arcade game that has been ported so you can play it in the browser. You press the left and right arrow keys to turn the ship, up to fire the engine, and space to shoot. Props to Doug McGuiness for creating this game. If you want to play it yourself, there's a link to it on Doug's website in the instructor notes. But right now, we're going to be focusing on finding a bug in its code. The code for this game is in JavaScript. But don't worry, you won't need to know JavaScript to complete the exercise. I thought using space to fire the engine might be more intuitive to me, so I changed the controls for the game to use space instead of up arrow. Then I needed a different way to shoot, so I decided to use enter instead of space for that. But when I tried the game out, the engines didn't work at all anymore, I couldn't move. I think I made a typo, but I'm not sure where. Most of the code for this game, including the codes that maps keys to actions, is in a file called game.js. Now, this file contains over a thousand lines. It would be way too time consuming to go through this entire file, comparing the new version to the old version. Fortunately, there are a bunch of tools that can automatically find differences between files. If you're using Windows, you have a tool in the command prompt called FC, which stands for file compare. If you're using Mac or Linux, then FC is a different unrelated command, but you have a built-in tool, called Diff, you can use, which stands for difference. I'll demonstrate using these tools to compare the HTML you just compared manually in the previous exercise. Then I'll ask you to go through the same process to find the differences in game.js. On Windows, I'll open the command prompt first. By the way, if you'd prefer to use git bash to complete this exercise, then, you can follow the instructions for the Mac and Linux students that are coming in a minute. But for now, I'm going to show how to complete the exercise in the command prompt. So first, I'll need to change to the directory that has my files in it. So I'll type cd Downloads. Since I downloaded my files to the downloads folder. Now I'll enter the command FC favorite-app-old.html favorite-app.html. So, to the FC or File Compare Program, I passed two files, the first one that I want to compare, and the second. Now, when I hit enter, I can see that I'm comparing the files Favorite-app-old.html and FAVORITE-APP.HTML. So, each of these two sections are showing different parts of the file. So here, you can see that favorite-app-old.html href style-1.css, and FAVORITE-AP.HTML href style-!.css. Then down here, you can see the next section that changed, which was the description. Some description here changed to the fun fact. Did you know that sunflowers were used to remove toxins from a pond after the Chernobyl disaster? Sections that didn't change aren't shown, since we're only trying to focus on the differences here. On Mac or Linux, I'll open the terminal, navigate to where the files are, then enter the command diff -u favorite-app-old.html favorite-app.html. The -u option stands for unified diff format and it will make the output a little easier to read. Now, I'll go ahead and hit Enter. The output format here is a little bit different than for FC. I'll scroll back up. And first, you can see that there were some lines at the top. And you don't really need to worry about these lines. They're just showing you that you're comparing favorite-app-old.html, to favorite-app.html. Ones with no plus or minus sign next to them like these haven't changed. That is they existed in both the old version of the file and the new version. Lines with a minus sign were removed. That is they existed in the old version, but not the new version. And lines with a plus sign were added, so vice versa. Now I'll scroll back down. And here's the style sheet change that you found earlier. And here's the description change. Now, go ahead and download the filesgameold.js and gamenew.js from the downloadable section and compare them using either FC or Diff. Your files will probably be downloaded to the downloads folder, so you can navigate there by using CD downloads, just like I did. What word contains a typo in the version of game.js but not in the old version? Once you found the word, enter it in this box. Use the correct spelling for the word. On Windows, I'll open the Command Prompt and cd to the Downloads folder. And this time I want to use FC to compare game_old.js to game_new.js. So I'll scroll back up to the top, and I can see that I'm comparing the files, game_old.js and game_new.js. And there's a, a few different changes here. So I'll have to look through for a little bit, but if I scroll down, here's the typo, spacr. That's not right. On Mac or Linux, the process is very similar. I'll open the terminal, cd to the Downloads folder, then run the command diff -u game_old.js game_new.js. The diff is in a slightly different format than when I ran this on Windows, but the content is the same. If I scroll back up here's the typo. I'll go ahead and open the game.js file. Search for spacr, and here it is. I'll change it back to space now. Now I'll go ahead and try out the new controls. I can move now, but it's harder to play the game since I only have two hands, because Enter is a bit far from the arrow keys. I think I'll change the controls back. Now I'm going to hand you over to Sara to reflect on what you just accomplished. We just saw with Caroline that looking at the differences between two files is a little bit annoying to do manually and that there are tools that make it easy to do automatically. Think for a bit about how this could help with the process of producing good code. Throughout the course, we'll ask you to take a minute to think about things and write down your thoughts about material we've just covered. I know it can be tempting to say, oh, I don't need to do this or I'll just wait to see what you guys have to say about it. But doing these exercises will really help cement the concepts as we go. Seriously, there's research on this. Check the instructor notes for details. Also, later in the course, you'll be getting practice using version control by saving different versions of these files. Since this course isn't about writing code, this will be one of the primary sources of practice you'll get. So be sure to actually write something down each time you see one of these prompts so that you have some content to work with. Don't worry about pausing this video while you get things set up or to see the reflection prompt. You'll see some directions after this video ends. We'll ask you to create a separate file for each lesson's reflections. You'll also want to make sure to use a simple text editor like Sublime, Notepad++, Emacs or Vim, and not a rich-text editor like Microsoft Word or OpenOffice. And use plain text .txt files so that you can easily look at their content on the command line. Please do take the time to do this right now. In our earlier examples of comparing different versions against one another, we just conveniently had those old working versions sitting around. In that case we manually saved off old versions under different file names. I personally used to do this all the time with school essays, math papers, and law tech and so on. This is one very primitive form of version control. How else might you get old version of your files? It's likely that you've actually interacted with some systems that do some form of version control for you. Have you ever used Dropbox? Dropbox actually periodically saves versions of your files. After you've edited a file, you can right-click and choose View Previous Versions. And then in the browser, you can check some of the old versions. Note that by default Dropbox only saves these version for 30 days. Do you use Google Docs? There's a little link up at the top that says, All Changes Saved in Drive. If you click on that you get a side panel of all the old revisions made by anyone who's ever worked on the Doc. And you can restore to any point in time. What about Wikipedia? If you go to any Wikipedia article, say maybe the one on version control, you'll see a View History tab that you can click on to see all the old versions. You can click through to see an entire old version or you can compare any two versions against one another. Let's take some time now for another reflection If you were to design a version control system specifically for code, what would it look like? In the rest of this lesson, we'll be discussing many ways version control systems can be different and what a programmer would want in each case. Wikipedia and Google Docs are clearly not designed for writing code. They require you to use their special purpose editors that don't have any features that programmers tend to want in an editor, like syntax highlighting and parenthesis matching. Using Dropbox is a more plausible alternative here since you can use any editor you want and the files are saved on your computer, as well as in the cloud. Similarly, when you save copies manually, you can edit with whatever program you prefer. Wikipedia also doesn't actually save files on your computer, which would make it hard to run your code. Google Drive does let you save your Google Docs files on your own computer, but they're in a special format that only works with their special purpose editor and you can't access the history offline. Dropbox is similar. Again, you can edit your files on your own computer, but you can only see the history online. Manual saving is the only option here that you can use offline. Of course syntax highlighting and offline access to history aren't the only areas where programmers would want different features in their version control. The next feature I want to consider is whether users should manually choose when to save or whether the systems should save versions automatically. Let's think about which option would be better for code. As a programmer, when would you want to have versions of your code saved? Consider a few different use case scenarios when you're coming up with your answer. One option would be at regular intervals, maybe every hour. Or maybe whenever there's a big enough change, maybe 50 lines or so. Or maybe when there's a long pause in editing. Or lastly, when you choose to save a version. Let's look through the options. This one is likely to save way more versions than you really need. But even if you're only actually saving when there's been a change over the course of the hour, you're likely to save at points that don't make a lot of sense. What if you're in the middle of typing a line? Your saved versions might not even compile, much less make sense as a logical checkpoint. This option does have the advantage that if you tend to be forgetful, and not save often enough on your own it can give you more fine grain detail than you would have had. But otherwise, there's not much reason to make this choice. Okay, let's look at the second one. This has some of the same problems as the above, and you might get versions that aren't actually usable. Plus, if you write a critical three line change one day and then don't touch the code for a week, your change doesn't get recorded until after you've made some other unrelated changes. What about this third one? This one's a little bit more promising. You'll probably get some changes that have some kind of logical meaning from this strategy. But, you might also get some not so meaningful ones that come up when you have to go run to catch your train or go have a nice dinner. Okay, so what about this fourth one? This has the potential downside of user error. Not saving often enough or saving too often, but it also offers a lot of flexibility. Let's go back to adding things to our chart. Remember from the intro video that this course is going to involve a version control system called Git? You may be wondering how Git got its name. It was created in 2005 by Linus Torvalds. Git is British slang for something roughly equivalent to unpleasant person. Torvalds once said, I'm an egotistical bastard and I name all my projects after myself. First Linux, now Git. Git was designed with code in mind. It's not the only system built with that goal though. One early widely-adopted version control system for code is called CVS, Concurrent Version Systems. Another system, SVN, also known as Subversion, is fairly similar, but improved on CVS to some extent. Another system you may have heard of is Mercurial, abbreviated hg, the elemental symbol for mercury. Mercurial has a lot in common with Git, and CVS and SVN are pretty similar. So to avoid cluttering up our chart, I'll just add SVN and leave the others off. Let's go ahead and fill in the chart for our new entries. All right, so which of these systems have the user manually saving versus autosaving? Well, clearly manual saving requires you to manually save. Wikipedia also requires this, so does SVN. Dropbox and Google Docs, on the other hand, save versions for you whether or not you manually save. So what does Git do? Git takes the manual approach, allowing the user to choose when to create checkpoints. While it may seem like having changes saved automatically would be convenient or nice, Git's system makes it much more likely that each individual version represent a logical change. We'll expand on why this is useful later. But intuitively, being able to view old versions is much more useful if each checkpoint is meaningful. In Git terminology, these user-created checkpoints are called commits. Commits are the basic building blocks of Git, each one representing a version of the content at one point in time. Git requires the user to supply commit message each time a commit is created. This makes looking through old versions much more useful and pleasant than the Google Docs model, assuming that the user supplied a useful commit message. You'll actually get a chance to see what this looks like in Git soon with Caroline. Throughout the course, Carolyn and I introduced a lot of new concepts and terminology. To help you keep track of everything, we'll build a map of these concepts, often asking you to think about how these ideas relate to one another and where the new ideas fit in to the grand scheme of things. Let's get started by writing down a few of the things we've talked about already. The first and biggest concept we've introduced is Version Control. This refers to any system that allows for systematic versioning of content. That is anything that makes it easy to create, store, and access different versions of the same documents, code, recipes, or whatever content you're working on. Here are some specific Version Control systems we've talked about. These are all types of Version Controls, so we could draw lines between each of them and the Version Control node and annotate the connections with labels like Type of. But if we do that, our map will soon get cluttered with tiny annotations. Instead, let's use colors to indicate what type of relationship each connection has. We'll use this color blue to mean Type of. As you've probably gathered by now, the system we'll be focusing on is Git. Though we will continue mentioning some of these others from time to time to contrast with Git using our comparison chart. The most recent concept we've come across is the Git Commit. This new concept is not directly related to Version Control. It connects through the Git system. And if we drew lines between every second order connection, our map would quickly get out of hand. Some of these other systems also involve some similar concepts to Commits. But they don't actually call them that. So we'll just keep it connected with Git. Do you think that this should be the same kind of connection as the ones we already have? Remember that those were type of connections. Commits aren't a type of Git, but rather a component. So the connection here should be a new color that indicates a part of connection. We'll use green for that. And we'll add the label here. Note this time, I walked you through the process of adding items to the concept map to give you an idea of what we're doing with it. Later on, you'll be asked to decide how new items fit in for yourself. Now, let's go to Caroline to find out how to view previous Commits and Git. Thanks, Sarah. Now, I'm here in the forest because everything I'm about to do can be done completely offline. I'm going to take a closer look at how Git works and how you can use it to view the history of a file. Specifically, I'll take a look at game.js which contains the code from the Asteroids game you saw earlier. Since I had been using Git to keep track of changes while writing this code, I can navigate to the directory where the code is saved and type git log. What I get is every commit that's ever been made, starting with the most recent. Notice how each commit has an ID, an author, a date, and a message associated with it. For now I want you to focus on the commit message and the ID. The message explains what has changed since the last commit. And the ID is sort of like a serial number. It uniquely identifies each commit and lets you refer to it. I'll scroll a bit by pressing the down arrow so you can see the commits with the changes we discussed earlier. This commit is where I switched the control keys to use space for movement instead of up arrow. This one is where I fixed the typo. And this one is where I reverted the controls back to the way they were before since I didn't like the new controls. Scrolling back up to the more recent commits, you can see some commits by Doug doing things like making a iPad version of the game, and there's also a commit by me adding some color into the game to make it look more interesting. I can check what changes a commit introduced by using the git diff command. Git diff is similar to the FC or diff program you used earlier, but instead of just comparing two files, it can compare different versions of a file within git. Right now I'm going to use git diff to see the difference between these two commits. So first I'll copy the first commit ID that I want, and then I'll copy the second and paste them both into my command here. When I hit enter, I see the changes made between the two commits. If you are using macro linux, this output looks very similar to the diff output earlier. All you need to notice in these lines is that we're comparing two versions of the file game.js and here's the actual diff. You'll notice that git supports the nice feature of colorized diff. So the black lines didn't change. The red lines with the minus sign were removed, meaning they only existed in the first version. And the green lines with the plus sign were added, meaning they only existed in the second version. These changes should look familiar since they're the same changes you looked at before. Here's the typo you found. All right, so where should we add diff? Diff is clearly related to both Git and commit, and, and also to version control more indirectly. But like we said, we don't want to add all these second-order connections, so let's just connect it with commit. The relationship between diff and commit isn't really type-of or part-of, so we'll need a new color for it. Since diff takes two commits and compares them, we're going to call this the operates-on relationship. When writing code in many languages, it's common to have features that span multiple files. Let's say you have a function that currently takes one argument defined in one file and a call to this function in another file. If you want to change this function to take an additional argument, you'll need to simultaneously change code in both files. In many of the non-code oriented version control systems we mentioned previously, files are tracked one at a time. If I open two Google docs and edit both of them, then later I want to find the versions of the files before I made either of the edits, first I have to find the right version in one doc, then dig through the other one's log to find the revision for approximately the same time. That's doable, but really annoying. Let's consider a few situations to think about whether tracking files individually or together makes more sense. For example, competition-style coding. In case you're not familiar with them, most coding competitions just ask you to solve a problem that can be done in a single file. Another example would be an HTML file and a CSS file that together make up a web page. Or maybe some photos you've Photoshopped. Or a novel, split up into multiple chapters. For each of these situations, if you think it makes more sense to track the files together rather than separately, check the box next to it. In this case, even though coding is involved, the files are not really interrelated, so it's fine to track each of the files separately, so we don't need to check this one. In this case the files will be highly interrelated. The CSS file will define styles that refer to elements in the HTML file, so there will likely be changes involved both files. For example, you might have a single change that both adds an element to the HTML file and also adds in a rule to the CSS file to position and style that element. For this third one, it's probably fine to track the files separately since it's unlikely that changes to one image will have anything to do with changes to another file. For this last one you could sort of go either way. In most cases, changing a single chapter won't have as much effect on the other chapters, but if you want to make a big change like changing a character's name, you probably want to change it across all the chapters all at once so checking this would be reasonable too. You just saw with Sarah that when you work on a project, you'll often have multiple files that you want to track together. Git calls such a collection of files a repository. When you save a version of your files in git, in other words, when you make a commit, you will save a version of every file in your repository. If you only have one file in your repository, for example game.js, you already know that git stores a version of your file each time you choose to commit. So if you committed changes at 1:00, 2:15, 6:09, 6:54 and 8:20, then it would look like this. But you might also have some other files in your repository. For example, index.html and index.css. You don't need to understand what these files are. The important thing is that all three files are connected, so they're all required for the game to function properly. Git will also track the state of these files each time you commit. A commit is a snapshot of every file in your repository at the time you choose to make the commit. So for example, this is the fourth commit in this repository. If you've only changed game.js in this fourth commit, then index.html and index.css will be identical between these two commits. On the other hand, you can change all the files in a single commit. For example, if you added a new button in the third commit, that would affect all three files. So if you did a diff between the second and the third commit, you would see the differences in all three. Let's take a look at how that looks. First, I'll do a git log, and I'll use the --stat option, which gives some statistics about which files have changed in each commit. So we can see all the same information here as before. But each commit also shows what files were affected in that commit. You can see that these most recent two commits only affected game.js. The green plus signs indicate additions, and the red minus signs indicate deletions. So you can see in this commit, some code was added and some code was deleted. The number of pluses and minuses is proportional to the size of the change. You don't need to worry about the units, but you can see that the second commit is a much bigger total change than the first commit. Now, I'll scroll down a bit to try to find a commit that affects more than one file. Here's one. You can see that this commit effected game.js, index.html, and ipad.js. Now, I'll press Q to stop viewing the git log output. And I'll go ahead and type git diff, and the two commit IDs that I want to compare. So this one, and this one. Like before, we see output in getting which file has been changed. First, game.js changed, and here's the diff for game.js. Next, we see the index.html was changed. In scrolling down, we can also see the diff for index.html. Finally, ipad.js was also changed and we can scroll down to see the changes to that file. My name is Jeffrey Middleton. I work at Google On Search, specifically in web ranking, which is how we decide for a given query what results we're going to show in what order. And I have been using git since I first started programming really for about six years. So for me, the biggest useful thing about version control is when I'm working on something bigger on my own. If I'm just doing a small task, it's kind of okay to be able to do it without any, without any version control. I can just sit there, do the little thing and be done with it. But if it's something bigger I really like to be able to break it up into pieces, to kind of think about my work in terms of a bunch of steps, and to be able to fix all of my mistakes by moving forward and backward. And kind of get everything together in the right way before I'm, before I'm really ready to share it with other people. The learning curve with version control really varies a lot depending on what you're using. I think some systems that don't offer as much are really fast to pick up, but then more complex version control systems like git. There is a pretty steep learning curve, but I think it's worth it because the power is so great, and once, once you do learn it, once you get past the curve you can really do a lot. And it's things that you couldn't do without having learned that much. Now that Git is installed, you'll need to download the asteroids repository. To do that, you'll need to be somewhere with internet access, which is why I've left the forest. Now let's get started and download the repository. I'm sure you've downloaded files before, but in this case, what we're doing is a little different. Because we don't just want to download the actual files, which would be the files from the most recent comment. Instead, we want to download the entire history. Git has a command allowing you to copy an entire repository from one computer to another. The command is called git clone because it creates a clone of the repository. To use it, type git clone followed by a URL to the other repository. We put the URL for the asteroids repository in the instructors notes, so go ahead and copy that URL and clone the repository like this. Now I won't need Internet access anymore for the rest of the lesson, so I'm going to head back to the forest. Once the repository is finished cloning, go ahead and cd into it. Now you should be able to use git log and git diff just like I did earlier. Go ahead and give it a try. In order to get the colored diff output like you saw earlier, with the red for deletions and green for insertions, run the command git config --global color.ui auto. If you don't do this, you'll just see black and white diffs, which will be harder to read. The git config command just changes your settings in Git and the --global flag means that it will apply to all of your Git projects and not only this one. Use git log to find the ID of the commit that reverted the controls. This commit has the message Revert controls. Enter the idea of that commit in this box. Then use git diff to find how many lines were added and deleted by that commit and enter those numbers here. Recall that to find the difference between two commits, you use the command git diff, the ID of the first commit and then the ID of the second commit. To find the commit which reverted the controls, first I'll type git log. Now, I don't see a commit with the message revert controls yet, so I'll press the down arrow and scroll down. And here it is. Since I found it, I'll press Q to quit out of git log. So this is the commit ID of the commit that reverted the controls. It starts with b067. Now I want to see how many lines were introduced in this commit. Remember that the changes introduced by this commit will be different from the previous commit. So, I can copy this commit ID, type git diff and paste it, and then I'll copy and paste this commit ID. Now I can just count up the lines that have changed. So far, there's two insertions and two deletions. We'll scroll down. Another insertion and deletion, so that's three each. Another, so four each. And I'll press Q to quit git diff. So, the correct commit ID started with b067 and there were four lines added and four lines deleted by that commit. It's been a while, since we last updated our Concept Map. And we discussed several new topics in the meantime. As a refresher, here's what the map looked like the last time we touched it. The map is getting pretty complicated at this point. And we're mostly just going to be talking about git and not so much the other concepts at this point. So, let's go ahead and zoom in and just look at this part of the graph. Okay. Great. That's a lot simpler. One new concept that we've talked about is the idea of a Git repository. A Git repository is a collection of files that are tracked by Git as a cohesive unit. You can have lots of different Git repositories on your computer and we'll talk later about how repositories can interact with one another. How to commits interact with their repository? How are they connected? At this point, it's important to remember that the current graph is not set in stone. We can modify it, to add new nodes between already connected ones. Repositories are a part of Git and commits are parts of repositories. So lets add those two connections. There's no need to keep this connection between commit and Git. Since it's pretty redundant. Since they're already connected through repository. So let's go ahead and get rid of that. Now, let's consider clone. Clone takes an existing repository and creates a new one just like it. So it should clearly be connected to repository. Does one of our existing connection types make sense? Or should we make a new one? It looks like the operates-on connection would work here pretty well. Now lets consider log. Log shows the commits in the repository prior to the current commit. How would you represent how it fits in to the existing map? In the following quiz, check the box next to any node that you think log should be connected to. In the text box, use the phrases for the existing connection types or write other if you don't think that any of the existing ones fit. Remember, this stuff is pretty subjective. So if you don't pick the same thing as what we thought made sense. Don't worry about it. You can keep trying until you land on our solution. Or you can just give it a shot and continue through to see how we did it. Please do try it yourself before continuing on though Here's what we ended up with. Log shows you a list of commits so you can say that it operates on commits. You could also say that commits are a part of log, so if that was your first thought, that's also valid. This way just stays a little more consistent with the way we've been constructing the map so far. You could also make an argument for connecting directly with repository as well since log shows commits in a particular repository. But this way, the map just stays a little bit cleaner and the two are still connected through the commit node. You've seen how a commit is a snapshot of every file in the repository at the time the commit was made. We can use git to view the difference between any two commits. For example the difference between these two commits, would show what code I added to add more color to the game. Being able to view the difference between any two commits is pretty convenient. But we can also temporarily change our files back to how they were at the time of any commit. This is called a git checkout, and it's sort of like restoring a previous version. If you're coming from SVN, this is not the same thing as a SVN checkout. In git, checking out a commit means resetting all of your files to how they were at the time that commit was made. Why would you want to check out a previous version of your code? One reason might be, if a bug was introduced, but you're not sure which commit introduced it. You can test wether a commit has the bug by checking out that commit and running the code. To run the code in the Asteroids Repo, I'll need to open up the index.html file on a web browser. If I'm on Windows I'll first open up this file navigation GUI. Next I'll need to navigate to the directory where the Asteroids Repository is. For me that's in my home directory, so under C, users, Seabucky. And then I put it in a version control directory and then in the Asteroids folder. Now I want to open this index.html file. So I'll right-click on it and select Open with Google Chrome. Now, sadly, this game will not work in Internet Explorer. So you'll need to use either Chrome or Firefox to open this file, unless the process is the same. But you should navigate to the file using Finder. If you've stored your repository in your home directory and you're having trouble finding it, just press CMD+SHIFT+H to find your home directory. For me the files are in the version control directory and then the Asteroids directory. So I'll right-click on index.html and open with Google Chrome. So you can see the game looks a little different now. The asteroids are solid and gray. And my spaceship is blue. I'll just go ahead and play for a little bit. Whoa, what just happened? I can shoot an endless stream of bullets. This isn't how I remember Asteroids working. Okay, as fun as that was I don't think it was the intended behavior. One of the recent commits must have introduced this bug. But which one? It's going to be hard to tell just by looking at the git log. So. Let's check out an older commit and see whether it has the bug. I'm pretty sure the code was working when I reverted the controls. So I'll start by checking out that commit to double check. I'll type git checkout. And then copy and paste the commit ID. If you're on Mac you can copy and paste the commit ID by just using Cmd+C and Cmd+V. If you're using Linux you'll need to copy and paste with Ctrl+Shift+C and Ctrl+Shift+V. And if you're using Windows, then you'll need to enable QuickEdit mode. Which you can find instructions for how to do in the instructor's notes. And then you can copy and paste by right-clicking. So now I'll go ahead and check out this commit. Now I get this strange warning we mentioned before. You are in detached head state. Like we mentioned, head is what git calls the commit that you're currently working on, and you've detached it here by checking out an older commit. Now here's the reason git thinks this is worth learning about. What do you think would happen if we made changes while we had this older commit checked out? Where would the commit fit in our history? It gets a little complicated so git includes some instructions for how you can deal with this. Don't worry if you don't understand these instructions yet. We'll be going over them in detail in lesson two. For now, we're not going to make any changes, we're just going to run the code, so you won't need to worry about the rest of this message. Now I'm going to run the code and see if it has a bug. Even when I hold down space, I can only shoot one bullet at a time. It looks like the bug hasn't been introduced yet. If it had we could have just checked out an even older commit and tried again. Now an interesting thing happens if I type git log while I have this older commit checked out. Revert controls shows up as the most recent commit, and the commits from before like Doug touching up the iPad version of the game and me adding color. Aren't showed in git log at all. Now can still get back to the most recent commit by typing git checkout, followed by its ID. But what if you don't remember the ID? For now we've put it into the instructor's notes for you, so don't worry about it. In lesson two, you'll also learn another way to switch between commits without knowing their IDs. Now I've narrowed down the commit that introduced the bug to one of five. Go ahead and do the rest of the work and find the exact commit that introduced the bug. Paste the ID of the first commit with the bug into this box. If you run into any issues, check out the troubleshooting guide we've added to the downloadable section, and see whether your problem is covered. If it's not, please ask about your problem on the forms. Since this is your first time using git to check out previous commits, this process might take a little longer than you'd like. You might even find it faster to track down the bug without using git. Or you might want to throw your computer out the window. However the time you're investing now, will keep paying off in your projects for years to come. Eventually you'll barely be able to remember how hard using git was at first. To sum this exercise. First, I'll want to check out the most recent commit again using the commit ID that I noted down. This is in the instructor's notes in case you forgot it. Then I'll do a git log. And I want to check out each of these commits one at a time until I find the one with the bug. If I do that, I'll find that this commit has the bug and the previous commit does not. That means that the commit starting with 25ed is the one that introduced the bug and this commit ID is the answer to the quiz. If we want to know exactly how the bug got introduced, we can use git diff to compare the commits. I'll do that now so git diff. Then the first commit ID. Then the second. As you can see in addition to some other changes, this commit removed the line, delayBeforeBullet equals 10. It's not surprising that this removal would cause the problem we saw. My guess is that the line was removed accidentally, while making these other changes My name is Lewis Kaneshiro. I build courses here at Udacity and I've used version control in different forms for about four years now. Version control makes me more of a risk taker in the sense that I'm able to explore pretty significant changes in the code base. Architecture differences at, at a very low level without fear of breaking the entire project. and, and, and freaking out, you know, for lack of a better word, to try to make it work again. And so, without version control the way I looked at code was as soon as it was working, I would make very small iterative changes. Whereas with version control I, I'm able to rethink the entire code base or, or rethink parts of them that quite honestly I wouldn't have approached or even touched for fear of breaking it. So, in general big picture the things I really like about version control is really this idea of exploration. Without version control I feel that developing as a programmer is, is taking little baby steps of making a program incrementally better. Whereas with version control you can explore such a large space of, of, of things to try, and you can do that easily without really worrying about having to go back and fix a project that's that's broken. So I feel version control has made me a better programmer because it allows me to explore deep concepts, deep architectural concepts within programs that I wouldn't be able to explore easily and more efficiently if I was not using version control. Before you continue to the next lesson, I'd like to encourage you to take a minute to set up a Git workspace that will work well for you. If you take the time to configure a few things about Git, it can be much easier and more pleasant to use. My configuration includes this custom prompt, which shows my user name in purple and what directory I'm in in blue. Having it more colorful like this just makes it stand out more from the other commands. Now, if I cd into a directory with a Git repository, I also have this in green, which shows which commit I currently have checked out. Right now, it's just showing the commit ID, but in lesson two, you'll see how to give commits names and this will become more useful. This prompt will also show a star if I've made any changes since committing. So if I were to open up game.js and add another line, then you see a star here, which indicates that I have changes that haven't been committed. I'm just going to undo that, so now the star is gone. I also have tab completion set up so I can type just the first few characters of a Git command, for example, git l and press Tab, and the rest of the command will be completed automatically. There are also some situations where Git will open up a text editor. For example, as you'll see in the next lesson, when you make a submit, Git opens an editor for you to write a commit message. You want to just set this editor to whatever you prefer to use. Now I'm going to walk you through the process of getting your workspace set up on Windows. There are also written instructions in the instructor's notes. If you're using Mac or Linux you should skip to the next video. First I'm going to configure git bash to use a white background. If you prefer to use a dark background you can skip this step. I'll click this icon, select Defaults and go to the Colors tab. Then I'll set the screen background to white and the screen text to black. Then I'll close and reopen Git Bash and the screen is white now. Next I'm going to download two files that are needed for the setup I showed you earlier. One to enable tab completion, and one to enable the git features in the prompt. The links to these files are in the instructor's notes. To download each file, I'll visit the page, right-click anywhere on the page, and select Save as. I'll save the file to my Downloads directory. Next, I'll use Git Bash to move the file to my home directory. My home directory is where I start out when I open Git Bash. Or I can move to it by typing cd ~ if I need to. Now I'll use the command mv which stands for move to move the file I just saved to my home directory. Now the first argument is the file I want to move, which is in my Downloads directory and it's named git-completion.bash.txt. Now the .txt was created by the web browser, but I don't actually want that. So I'll choose the name git-completion.bash as the new name. And without specifying a directory it will automatically get saved to my current directory. Then I'll go through the same process to save the second file in the instructor's notes as git-prompt.sh. Next I'm going to create a file called .bash profile which contains configuration for Git Bash. I recommend using the configuration file that I used when filming this course. To do this you can download the file called bash_profile_course in the downloadables section. Then use Git Bash to move the file from your Downloads directory or wherever you downloaded it to, to your home directory and name it .bash_profile. Don't forget the dot at the beginning of the name. If you already have a bash profile, then don't run this command. Instead you can copy and paste the content from my bash profile into your existing one if you like. I don't see any changes to my prompt yet and that's because I'll need to close and reopen Git Bash before the changes take effect. I'll do that at the end of the video. In case you're curious about what's in this batch profile, or if you'd like to pick and choose which lines to keep, I'll go through what each line does. Don't worry if you don't understand how each line works though. Even experienced UNIX programmers frequently copy and paste this kind of thing from their friends, rather than writing it from scratch. This first line loads one of the files you downloaded earlier, and enables tab completion. These lines define some colors, which will be used in your prompt. This line loads the other file you downloaded earlier, and it's necessary for the git related stuff, like commit IDs, to show up in your prompt. This line makes it so that an asterisk will show up in your prompt if you change something in a git repository. And this line sets the prompt. It will show your user name in purple, the commit you have checked out and other git related stuff in green, and the directory you're currently in followed by a dollar sign in blue. Anything after that will be displayed in the default color. If you're curious to learn more about how prompts work in bash, check out the link in the instructor's notes. But it's not necessary for the rest of this course. Now I'll configure git to use Sublime as my editor for things like commit messages. You'll want to configure git to use whatever editor you like, but the process should be similar. First, I'll need to figure out where Sublime was installed. For many people this is under C:\Program Files\Sublime Text 2. And that's the case for me. If it's not here, you might also try looking under C:\Program Files (x86). Then I'll run the command git config --global core.editor followed by the text editor that I want to use in double quotes. For me, this is Sublime, and I'll need to specify the full path to Sublime. But for now, I'm just going to type sublime as a placeholder, followed by -n -w. The -n means Sublime will open in a new window and the -w means git will wait for you to close Sublime before trying to continue. Now, I'm going to replace sublime with the full path to Sublime in single quotes, starting with the directory you saw earlier, and then I'll add sublimetext.exe. I know you can't see the whole command here. You can copy and paste it from the instructor's notes, although you'll have to modify it if Sublime is installed in a different location for you, or if you're using a text editor other than Sublime. It's also a good idea to make sure you can launch your text editor from within Git Bash. I'll show how to do this for Sublime. If you use another text editor, I recommend you use Google to figure out how to launch it from within Git Bash. I can already launch Sublime within Git Bash by typing the full path to it, but I'd like to have a shortcut. To create one I'm going to add a line to my bash profile using Sublime. Now opening the bash profile is going to be a little tricky because anything with a dot at the beginning of the name is a hidden file and it won't show up in most file system explorers. To get around that I'm going to temporarily rename the file to not have a dot at the beginning of the name, then I'll change it back once I finish. Then I'll open up Sublime and open the file. I'll navigate to my home directory under Computer > C:\Users\cbuckey. And then I'll select the bash_profile. Then I'll add this line to create a command called subl, which will open Sublime. If you use Sublime, you can copy and paste this line from the instructor's notes. Although again you might need to modify it to be the location Sublime is installed for you. Note that this command also won't work until you close and reopen Git Bash. Now that I'm done, I'll rename the file to have a dot at the beginning of the name again. If I didn't do this, then this file won't automatically be loaded when Git Bash starts up. Next, I'll run two more Git config commands that will come in handy later this course. I'm going to run them now so that all the configuration advice for the course will be in one place. You can copy and paste these commands from the instructor's notes. Finally, I'll close Git Bash and reopen it. Now, I can see that my prompt has changed. And if I want to view my bash profile using Sublime, I can run subl .bash_profile. Remember to close and reopen Git Bash when you're finished or your changes won't take effect. Now I'm going to walk you through the process of getting your workspace set up on Mac. And the process on Linux is similar. There are also written instructions in the instructor notes. If you're using Windows, there are instructions in the previous video. First I'm going to download two files that are needed for the set up I just showed you, one to enable tab completion, and want to enable the special Git features in the prompt. So I'll go to the webpage with the first file and you can find the link to this file in the instructor's notes. Then I'll right-click anywhere on the page and select Save As. And I'll save the file in my Downloads directory. Now I want to make sure that Hide extension is unchecked, so that I can see the exact name the file is being given. And by default, it's suggesting Redirecting.txt. But I want to change this to git-completion.bash, and then I'll Save the file. Now I want to move the file to my home directory, which I'll do using the Terminal. Now when I first open the Terminal, I start out in my home directory, or I can type cd ~ to get to the home directory if I need to. Now I'll use the command mv, which stands for move, to move the file I just saved into my home directory. The first argument is the file I want to move, which is in my Downloads directory and it's named git-completion.bash. And I want to move it into the current directory while keeping the same name. Then I'll go through the same process to save the second file linked in the instructor's notes as git-prompt.sh. Next, I'm going to create a file called .bash_profile, which contains configuration for the Terminal. I recommend using the configuration file that I used when filming this course. To do that, you can download the file called bash_profile_course in the downloadables section. Next, use the Terminal to move this file to your home directory. You should name it .bash_profile and don't forget the dot at the beginning. Now if you already have a bash profile, then don't run this command, and instead you can copy and paste the content from this file into your existing bash profile. And if you're running Linux, then you might need to name this file .bashrc instead of .bash_profile. Now I don't see any changes made to my prompt yet, and that's because I'll need to close and reopen the Terminal before the changes take effect. I'll do that at the the end of the video. In case you're curious about what's in this bash profile, or if you'd like to pick and choose just the lines you're interested in, I'll go through what each line does. Now, don't worry if you don't understand how each line works though. Even experienced Unix programmers frequently copy and paste this kind of thing from their friends, rather than writing it from scratch. This first line loads one of the files you downloaded earlier and enables tab completion. These lines define some colors, which will be used in your prompt. This line loads the other file you downloaded earlier. And it's necessary for the git related stuff like commit IDs to show up in your prompt. This line is what makes sure that the asterisk will be shown in your prompt if you make changes in a git repository. And this line actually defines what the prompt will be. The prompt will show your username in purple, the commit you currently have checked out or other git related stuff in green. And the director URN followed by a dollar sign in blue. Then any text after that will be displayed in the default color. If you're curious to learn more about how prompts work in bash, check out the link in the instructor's notes, but it's not necessary for the rest of this course. Next, it's important to make sure you can launch your favorite text editor from the Terminal so that you'll be able to set it as your default editor within git. I'll show how to do this for Sublime. If you're using another text editor, I recommend that you Google to figure out how to use it from the Terminal. Now, I can launch Sublime from the Terminal by running this long command. Where this is where Sublime is stored on my computer, but I'd like to have a shortcut. To create one I'll use Sublime to add a line to my bash profile. Files with a dot at the beginning of the name don't usually show up in file system explorers, so I'm going to have trouble opening my batch profile with Sublime. To fix this I'll use the trick of moving my bash profile to a file without a dot at the beginning of the name. Then to open the file in Sublime, I'll first navigate to my home directory, which I can do by pressing Cmd+Shift+H. And then I'll select the file bash_profile. Then I'll add this line to it to make the subl command stand for the same command that you saw me enter earlier. You can copy and paste this line from the instructor's notes if you're using Sublime. Now I'll save the file and I'll change the name back to have a dot at the beginning using the Terminal. If I don't do this, then the bash profile won't take effect when I open the Terminal. Again, this command won't work until I've restarted the Terminal. Now I'll configure git to use Sublime as my editor for things like commit messages. To do that I'll run git config --global core.editor and here I need to put in double quotes the command to open my text editor. For Sublime that's subl -n -w. Where -n will open Sublime in a new window, and -w will wait until you close your file before continuing. If you use a different editor, you will need to modify this part of the command to use the editor that you like. See the instructor's notes for more details. Next I'll run these two git config commands, which will come in handy later in the course. Please copy and paste these commands from the instructor's notes and run them. Finally I'll close the Terminal and reopen it. Now I can see that my prompt has changed to become more colorful. And if I want to view my bash profile using Sublime, I can run subl .bash_profile. Remember to close and reopen your Terminal when you're finished, or your changes won't take effect. Congratulations, you've finished the first lesson of the course. In this lesson, you learned why saving old versions of your files might be useful, and you learned some systems that can help you do this called version control systems. You also learned a particular system called Git, and got practice using it to review the history of existing projects. In the next lesson, you'll create your first Git repository and create that history. See you then. Hi, welcome to lesson two. In the first lesson, you learned what version control is and how Git compares to other systems. In this lesson, you'll learn how to use Git on your own machine for solo projects. You'll learn how to create a new repository and make commits. You'll also learn what it means to merge and branch in Git and how to use these tools to keep track of experimental changes to your project. Then in lesson three, we'll learn how to use Git collaboratively across multiple machines using GitHub. Let's get started. Let's jump back into using git. What makes a git repository a repository? Last lesson you interacted with an existing repository, the asteroids repository. For the most part it just looks like a normal directory on your machine. The only real difference is that git repositories store a bunch of metadata about the history of the repository since it was created. We won't go into the details of how exactly this metadata is stored, but where is less complicated. It's right here in the main directory. But it's tucked away in a hidden directory. Meaning that it doesn't show up in most file explorers by default. Hidden files and directories are often used for data that the user doesn't need to directly interact with. These directories and files are only different from normal ones in that they start with a period which tells the operating system to hide it from the users. One way to see these files is by going to the command line and using ls -a. In addition to all the normal files that you see when you type ls, when you do ls -a, you also see the hidden files. See, here, you have hidden .git. So, how does this hidden .git directory even get there? Last time you cloned an existing repository, which transferred all that metadata over to your computer. If you want to start from scratch, you'll need to explicitly tell git that you want to make a new repository. In the next video Caroline will show you how that works. Thanks, Sarah. Now once again, everything I'll be doing in this lesson, I can do completely offline. I won't internet access to create a repository or add commits to it. That's why I'm here at the forest again. First, I'm going to create a Git repository. I can either do this in an empty directory and create files later or I can create the repository in a directory that already contains files. Right now, I'm going to use an existing directory with some recipes. I'll run ls dash a. And I can see that there are three recipes here. A cake recipe, a frosting recipe and a chili recipe. Notice that there isn't a .git directory because this isn't a git repository yet. Now I'll run git init, which initializes or creates a new Git repository. Now if I run ls dash a again, I can see that the .git directory has been created. How many commits do you think the new Git repository contains? Enter your answer in this box. And recall that commit is a snapshot out of a Git repository. If you're not sure how many commits it will contain, then just pick a number you think is reasonable. Next, what command could you use to find out the answer to the previous question? Here's a hint. This is a Git command that you learned last lesson. Git doesn't any commits when you create the repository. You'll have to do that yourself. So the correct answer here is zero. Now Git could create an initial commit with everything in the directory, but it doesn't do that for a couple of reasons. The first is you might not want to commit everything in the directory, and second, you wouldn't be able to write your own commit message if Git created the commit for you. You can find out what commits are in your repository by running git log. Let's try that out on this new repository. Now, I'll run git log on my new repository to see what commits it has. I get the error message, fatal: bad default revision HEAD. Now, head is git's name for the current commit. So, this error message is letting me know that I can't view my commit history, because there aren't any commits yet. To see that this really is a git repository, I can run git status. Status is a command I like to run frequently, because it shows which files have changed since the last commit. Right now, I can see that I'm on the master branch. We'll discuss what that means later in this lesson. Now, git would ordinarily show the most recent commit. But since there isn't one, it says initial commit here. And git says that my three files are untracked, because its not tracking the history of those files yet. Now, go ahead and follow the same steps to create a repository for your reflections. Run the commands git init and git status in the directory where you've created your reflections. When you're finished, paste the output of git status into this box. Running git init should have given you the message Initialized empty Git repository in whatever directory your reflections were in. Then, running git status, you should see any files you have listed as untracked files. If you have one file named lesson_1_reflections.txt, then your output should look like this. Now that you've learned how to initialize an empty Git repository, let's talk about how to add changes to a repository. In my recipes directory, I have the three files, cakerecipe.txt, frostingrecipe.txt and chilirecipe.txt, on my hard drive, which is called my working directory. I also have an empty Git repository that I just created. Now I'd like to add a commit to this repository. Now, you might think I could just run git commit to create a snapshot of the current state of my files. However, Git allows you a bit more control than this. Recall that it's a good idea to keep commits small with one commit per logical change. Git makes it easier for you to do this by allowing you to specify exactly what changes should be committed. To accomplish this, Git uses an intermediate area called the staging area. You can add files one at a time to the staging area. For example, first time I add the cake recipe and then the frosting recipe. Then, when I'm ready to commit, Git bundles the entire contents of the staging area into a single commit and adds that to the repository. Let's see how this works on the command line. To remember what I've added so far, I'll use git status. And I see that I still need to make my initial commit and my three files are still untracked. Now, the command to add files to the staging area is called git add. First, I'll add the file cake-recipe.txt and then I'll add the file frosting-recipe.txt since I think it makes sense to put the cake and the frosting recipes in the same commit. Now I'll run git status again and I can see that these files show up as new files under changes to be committed. This is Git's way of saying that they have been added to the staging area since if I created a commit now, these files would be included. Now go ahead and use git add to add whatever files from your reflections repository you would like to put in your first commit. Which file or files will you add? Will you add both files in one commit or will you use separate commits for each file, and why? Write your answer in this box. After your staging area contains the changes you want in your fist commit, run git status and paste the output in this box. Now I've decided to add only my reflections from lesson one to the first commit. I did this because I want to have one commit per logical change and I think of the two lessons as logically separate. But this is a bit subjective, so you may have decided to add both files to the staging area and commit them both at once. To do this, I ran git add lesson_1_reflections.txt. After that, git status shows that my lesson_1_reflections file is in the staging area, which is why it's marked Changes to be committed, and my lesson_2_reflections file is still untracked. All right. There are a bunch of new concepts here. Let's start with init. Init creates a repository and doesn't directly relate to any of the other concepts currently on the map. So it seems pretty straightforward. We just want to connect it to repository. Since it does something with repository, it creates it. This is an operates on connection. There's only spot that makes sense for init, given this. The rest of these are a little bit trickier. Let's think about the staging area. You put things into the staging area before you make a commit. So it's pretty related to the concept of a commit. Git add and git status both work on the staging area to help you make the commits. Both of these are going to have operates on connections to the staging area. Status also shows you what's in your working directory, so it'll have an operates-connection to working directories as well. So this gives us enough information to fill in all of these. You've just seen how to add changes to the staging area, so now let's go over how to create a commit with those changes. I've just added my changes to cake-recipe.txt and frosting0recipe.txt and I'm ready to create a commit for them. To do that, I'll run the command git commit. And Git opens the editor I've configured so that I can write a commit message. In my case, the editor is Sublime. I'll enter the message Add a cake and frosting recipe since that describes the changes that will be present in this commit. It's standard Git practice to write your commit message as if it were a command, which is why I said Add a recipe, rather than Added or Adds a recipe. Next, I save the file and quit the editor. And I can use git log to see that the commit has been created. Here it is. Now if I run git status again, the initial commit note has gone away and the only remaining untracked file is chili-recipe.txt. I'd also like to commit this file in a separate commit and I can do that using the same process. Now go ahead and commit the changes in your reflections directory that you previously added to the staging area. You can do this using the command git commit. Then continue committing until you have committed all your changes using git add, git status and git commit. What is the output of git status after all your changes are committed? Paste the output here. First, I'll use git status to recall what's currently in the staging area. I've added my lesson_1_reflections to be committed. I'll go ahead and commit those using git commit and I'll enter the commit message, Add lesson 1 reflections. Now I want to commit my lesson_2_reflections, so I'll add those and then run git commit again. Now that all my changes are committed, the result of git status is that I have nothing to commit and my working directory is clean. Let's return to the Asteroids repository from the previous lesson. Do you remember the bug you saw, where you could shoot without a delay? You now have the knowledge you need to fix that bug and commit your fix. First, I'll do a git log. Now, I'll scroll down to the commit where you found the bug had been introduced. You may recall that it was this commit. To double check, I'll use diff to compare it to the previous one. Sure enough, this commit removed the line, this.delayBeforeBullet = 10. I want to readd this line, so I'll go ahead and copy it. And I can see that it should be added inside the if statement, this.delayBeforeBullet is less than or equal zero. I'll open game.js in Sublime. Search for delayBeforeBullet. And hit Find until I find the appropriate if statement. Here it is, so I'll insert the line. Now I'm ready to add the file to the staging area, and then commit it. First I'll use git status. And I can see that game.js has been modified, and that the changes are not staged yet, which means that they are not in the staging area. Right now, I remember exactly what changes I've made to game.js since I made them just a minute ago. But often, I'll find myself making changes, taking a break, and then coming back and forgetting what changes I've made. So I'm going to show you how to use git diff to see the exact changes that you've introduced since committing. To make the illustration more clear, I'm also going to introduce a change to index.html that I don't want to commit yet. I'll just collapse this line onto the previous line. Let's think about what the working directory, staging area and repository look like right now. The repository contains several commits. And each commit contains several files. I'll focus on the most recent commit in the files game.js and index.html. The staging area is a copy of the most recent commit until I add changes to it, so it has those same files. Finally, the working directory also has the same files in it, but I've made some updates to game.js and index.html, which I'll represent using these stars. You know that you can use git diff to compare two commits by entering their commit ID's. But the staging area and the working directory are not commits, so they don't have ID's. However, it's very common for Git users to want to compare the working directory to the staging area, so git diff with no arguments will do that. This will show any changes you've made that you haven't added to the staging area yet. So I'll go ahead and run git diff with no arguments, and I can see the two changes I just introduced. Here's the change to game.js, where I re-added the delayBeforeBullet. And here's the change to index.html, where I combined two lines into one. Now, I'll add game.js to the staging area and run git diff again. This time, I only see the changes to index.html, since game.js is the same in the staging area and working directory now. Now, the staging area contains the updated version of game.js, but not of index.html. That's why, when I used git diff to compare these two, I only saw the changes to index.html. Now, you might also want to view the difference between the staging area and the most recent commit. I like to do this right before I commit, to double check that the files I've added are really what I want to put in the commit. The command for this is git diff --staged. If I run this command now, I should see the changes to game.js, but not index.html, since index.html is still the same. Sure enough, git diff --staged shows only the change to game.js. This is exactly what I want to commit. So I'll go ahead and type git commit. And I'll use the message: Add delay back to bullets. Now, I'll run git diff again and I'll still see the changes to index.html, since I haven't committed those. If I run git diff --staged though, I see nothing, since I did just commit everything in the staging area. Finally, I don't actually want these changes to index.html anymore. To get rid of them, I'll run git reset --hard. Which discards any changes in either the working directory or the staging area. But be very careful if you ever run this. Most actions in git are reversible, since you can always restore previous commits. But you've never committed the changes in your working directory or staging area. So if you run this command, you can't get those changes back. In this case, I had just run both git diff and git diff -staged. So I know exactly what changes are in the working directory and staging area, and I'm sure I don't want them anymore. Now I'll run git diff again. And there are no changes. What two versions of your files does each form of git diff compare? For each form of git diff, fill in the two versions that compares in these boxes. Each box should contain either working directory, staging area, commit one or commit two. Note that commit one is the most recent commit in this repository Git diff with no arguments compares the working directory to the staging area, git diff--staged compares the staging area to commit1 which it the most recent commit. Git diff commit1 commit2 compares commit1 to commit2 You've just learned how to initialize your repository and add commits to it using the staging area. So far, each commit that you've made has built upon the previous commit, creating a linear commit history. Now let's take a look at some times when you might want to make a commit history that branches out into multiple versions. Making a straight line of changes makes a lot of sense if you're just fixing bugs, adding new features or updating documentation. But what if you wanted to try out a new experimental feature that you're still not sure will work, but you still want to have a working demo to show your friends when they ask what you're working on? Or maybe you're learning Italian and want to make a version of your project for Italian-speaking people while leaving the native language version intact. In this case, you'll probably want to eventually create a setting for switching between the two languages. But maybe as a first step, you just try changing the text and seeing if you need to rework your layout a little. Of course, you could just make your changes and record the IDs for all the commits. And then use git checkout to jump back to the real official version when you need to show it to somebody. And then back to your other version afterward. But what if you find a bug in your real official version and you need to make a fix there? You need to update your records and use this new commit as your real version. This would be a lot of overhead. To make this kind of situation easier, Git allows you to create labels for your commits. These labels are called branches. In this case, we would have three different branches. First, we would have master. Master is the name given to main branch in most Git repositories and every time you create a repository, Git creates a master branch for you. This branch we would probably call something like italian and this one we might call experimental or maybe just exp for short. Remember how in last lesson when you checked out some old commits, you'd get the detached head message? Basically at that point, Git was warning you that you were looking at a commit that was not labeled with a branch name. So far, you've always been in a detached head state or on the master branch, which Git creates for you. It's possible to check out a branch in the same way you checked out commits in the past, except with the hopefully human-readable branch name rather than an unpronounceable series of characters. If you check out a branch and then make a commit, the branch label automatically updates to the new commit. That branch also stays checked out, so you don't have to check it out again. This is how you've managed to stay on the master branch without knowing anything about branches up til this point. As a matter of terminology, we sometimes refer to the current last commit on a branch as being the tip of that branch. It is possible to have multiple branch labels attached to a single commit, but making a new commit will only update the branch that you have checked out and leave any others alone. At this point, it's natural to wonder if there's any way to combine two branches, say if your experimental feature has finally worked out, but your main branch has grown since the two diverged. The process of combining two commits is known as merging and we'll get to that later on in the lesson. But first, we want you to get comfortable creating, checking out and committing to branches. Caroline will help you get started with this. Thanks, Sarah. Now, I'm going to use git branches to create an experimental change in the Asteroids repository. This game is pretty hard, and I don't want to change that. But I'd also like to create an easier version of the game. If I do, there will be two versions of the game that are almost exactly the same, but with some slight differences. So this is a great time to create a branch. Now, there's a lot of ways I could make this game easier. But here's one. Every time I shoot an asteroid, it breaks into three smaller fragments. I'll try making it easier to complete the level by only making it break into two each time. I don't want to make this change on the master branch though, since I don't consider it an official update to the game. Instead, I'll create a branch called easy mode for that change. I can use the command git branch to create and view branches. First, I'll run git branch with no arguments, which shows me my current branches. Right now, the only branch is master, which is the default branch. Now, I'll run git branch easy-mode. When I give an argument to git branch, it creates a new branch with that name. So now, when I run git branch again, I can see that the easy-mode branch was created. This star next to master means that master is the branch that is currently checked out. So that's the one that will update if I make a change. That's not what I want. I want the easy-mode label to update when I make a change. And master to stay the same. So I'll run the command git checkout easy-mode. And now, when I run git branch again, I can see that easy-mode is the checked out branch. Since I just created the easy-mode branch, it has the same code as master right now, but I'm about to change that. To make the easy-mode, I'll open the file game.js. I saw earlier that the code I'm interested in changing has a common break in to fragments. So I'll search for fragments. Here I find a loop that executes 3 times, which is making 3 smaller asteroids, which the author calls roids. So I'll change this 3 to a 2. And give the game a try. Sure enough, now only two smaller asteroids form. Now, I'd like to commit this change. Even though it's only a one-character change, I consider this one logical change since it changes the behavior of the game and it completely accomplishes the goal I had. I'll add my change to the staging area. And then commit it. And I'll use the commit message make asteroids split into two smaller pieces rather than three. Now, go ahead and create and easy-mode branch on your computer. Then checkout that branch. And commit a change making the game easier. You can use the same commit that I did. You can find the line that I changed at line 678. Or you can search for break into fragments, like I did. When you're finished, paste the output of git status into this box. When I run git status, you can see that it says, on branch easy-mode, since I checked off the easy-mode branch. And it says, nothing to commit, working directory clean since I've committed all my changes. Hi. My name's Mike Wales and I'm the Web Development Curriculum Manager here at Udacity. I usually create a new branch whenever I'm moving on to a different piece of work. Anytime I'm doing something different, I will create a new branch. I like to think of it as context switching. Whenever I'm switching to work on a new feature or whether I'm going to correct a bug, I'll create a new branch at that time. Git branches help you keep a project organized, particularly, when you're sharing that project publicly. You'll have your master branch, and that would be your production quality branch that never breaks, always works. And then you could have a development branch where active work is taking place on your project. Then a lot of times you'll have things like an experimental branch or maybe some unique feature branches. Those are things that you're working on, and you fully expect them to break, and you want to share those with the public, but with the understanding that this isn't production quality work just yet. Branches are also good when not only collaborating publicly, but their really good to collaborate with yourself. So a lot of times, if I'm working on a feature, and then I come across a bug. Branches allow me that ability to context switch and get away from the work I'm doing on my feature. Go back to where I need to be to fix the bug and then compartmentalize that work. Branches are really good. Even if I get bored on working on a feature. It gives you the ability to, okay, I want to switch and start working on something else right now. Last time, we talked about some cases where you'd want to use branches for your solo projects. You might also want to use branches to keep things organized when working with others. If you and your collaborators all make changes on the same branch, you can't easily work on separate features simultaneously. A common workflow for people working on projects together, includes making a new branch for every feature or bug-fix. This way, if multiple people are working on changes at the same time. They can each check out their branch to continue work after taking a break. Without worrying about things changing up from under them. Then once a feature or bug-fix is complete, the author can either update master to also point to the tip of the new branch. Or if there have been changes to master in the mean time. Combine it with the current master, using gits and merge feature. We'll talk about merging in detail later. I've actually been working on a new feature for the asteroids game, that adds a new game mechanic. In addition to getting points for destroying asteroids and spaceships, you can also collect coins by touching them with your ship. This adds a new challenge, since there are now somethings that you want to hit and others that you want to avoid. I'm finally ready to share this branch with Caroline. So I tell her that she can check out the branch and play test it, so that I can get some feedback before adding it into the main branch. Thanks. Now Sarah told me that her branch is named coins. So I'll check it out using git checkout coins. Now, I get this message saying that branch coins is set up to track remote branch coins from origin. Whoa. That's a few words that you haven't heard before. The fact that it's a remote branch means that I didn't create it myself. Instead, Sarah created it and so I'm looking at her branch. You'll learn more about remotes in lesson three. But for now, once I've checked out the branch, it behaves just like the branches that I created myself. Now I'll open the index.html file and try the game out. Now this is a coin right here that Sarah added. And when I run into it, then my score goes up. Cool. Now you might be wondering why Sarah's version of the game doesn't have color. That's because Sarah started working on this branch before color was added to master. To see this, I'll do a git log. So I can see that these recent commits are all by Sarah. If I scroll down to get to the most recent commit that wasn't from Sarah, I see that it's this one where I reverted the controls back from my experiment in lesson one. That's because this was the latest commit on master at the time when Sarah checked out her branch. By contrast, if I check out master and run git log there. I can see many newer commits that are more recent than the commit that Sarah started working on. The color commit is right here. Git can also help you visualize the branch structure via the command git log dash dash graph. I'll also add the flag dash dash oneline to make the output shorter and easier to see. And I'll need to tell git which branches I want to visualize. So, I'd like to see master and coins at this point. These commits existed before the coins branch was created. These are commits that Sarah added to the coins branch. And these are commits that were added to master after the coins branch was created. Now that you've seen what commits are in each branch, grab a pencil and paper and draw a diagram of the commit history in the asteroids repository. Including the easy-mode, master and coins branches. You don't have to include all the old commits just, however many of the recent commits you think will be informative. When you're finished, check this box. If you're having trouble, try using git log to see what commits are on each branch. And make sure you watch the solution video to compare your diagram to Sarah's. I'll start my diagram with the last commit that the coin branch has in common with the master branch. As you can see that's the revert controls commit here. I use an ellipses to indicate there's more history off over here. After this commit our history branches off into the master branch and the coin branch. So I'll split off here, keeping the master branch straight. Each of these two branches has several more commits. I'll label the last commit made on each branch with the appropriate branch label. Now remember, we also made a new branch off of master called easy mode, and made one commit on it. So we'll add that to the diagram as well. You've seen git log output a few times now and you know that it doesn't necessarily always show you every commit. So how does git log figure out which commits to show you? It turns out that each commit knows about its parent. That is, it stores a reference to the commit that was checked out when it was made. If you were on a branch when you made the commit, it still just stores the commit ID of what was then the tip of the branch. Commit doesn't care anything about branch names. Only the branches themselves store anything about the position of the branches. To make it really clear what info is actually stored by Git, I'll include arrows in our diagram to show each commit's parent. This will become more important once we get to merging, but it's good practice to start thinking of commits as having parents now. All right, back to the question of git log. Log starts with the current commit or the latest commit of any branch or branches that are specified and traces back until it gets to a commit that doesn't have a parent. This will generally be the initial commit. This leads us to the concept of reachability. You can see that in our diagram, there are some commits, say, this one, that can't be reached by other commits, say, this one. There's no way to get from here to here. Suppose we checked out this commit. Remember that we marked this with a star. And then we made a new commit from there, which would move head or the checkout commit to here. If you then checked out an existing branch, say, a master, then the commit that you just made would be lost, unless you happen to have written down the commit ID, since it's not actually reachable by any of the current branches. To drive home this concept, we've created a fictional diagram. We've used shortened Git-like commit IDs to label each commit and we've just used letters to label the branches. Given this diagram, if I ran git log for each branch a and b, which commits would be listed? List the commit by their shortened IDs from most to least recent and separate them with commas. Also, are there any unreachable commits in this diagram? If so, list them here. All right, let's trace through the branches. For a, the most recent commit is this one, 3fc. Its parent is f26 and its parent is e3d. So we list them in that order. Similarly for B, we start with 4d9 and travel up back to e3d. All right, now that we've gone through all the commits that can be reached by a and those that can be reached by b, are any of them missing? Well yes, this one, f36. Now that you know about branches and reachability, you know everything you need to, in order to understand the entire detached head message we saw earlier. Remember, to get this message, we checked out a commit, not a branch. Remember that head just means current commit. So head now points to this commit. First git says that you can look around and make experimental changes and commit them. You now know that git's history can be non-linear. So if you commit changes, they would look like what we saw before, here, and head would get updated to the commit that you just made. Next, it says that you can discard any commits that you make in this state without impacting any branches. Since this commit isn't included in any branches, it won't show up in git lock. It's not reachable and the changes made here don't show up in any of the branches. And like we said before, if you then checked out an actual branch, it would basically be like this commit never existed. The next bit says that if you want to create a new branch to retain these commits you can do so by using this command. Git checkout -b new_branch_name. Running git checkout -b is equivalent to running two commands. First, its just like running git branch new_branch_name and then, running git checkout on that new branch. Since this sequence of commands is something that people will want to do pretty often, pretty much every time you're making a new feature, it's nice that there's this shortcut for it. If we do either version of these commands while we're still on this commit, then the new branch would be created here. Then any further commits will be on this new branch, since we already know that making new commits brings the branch with us. This last line just reminds us what commit we're on, making at as a shortened version of the commit ID, and then tells us what the commit message was. Great, now you understand the entire warning. You've learned how to create branches and how to keep track of which branches contain which commits, using diagrams. Now, let's take a look at how to combine changes from multiple branches into a single version. Since the coins branch is finished, I'd like to incorporate the changes into the master branch. If no changes had been made to the master in the meantime, back when I first started it, I could just update the label to be where I am now. But changes have been made in master. So I'll need to somehow combine the coin branch, with the master branch and create a single version that contains all the changes from both. Git can actually combine the master branch with the coin branch automatically, which is pretty impressive. To get an idea of how this works, let's look at a simple example first. Suppose two people, I'll call them Jake and Rachel, are editing two copies of the same file independently. You can imagine that this is the game.js file from the Asteroids repository or any other file, really. At the beginning of the day, they both start with the same version of the file. During the day, each of them makes some changes, possibly adding some lines, or removing some lines. At the end of the day, Jake's version of the file contains some lines of content. We'll refer to them as B, D and E. Now of course, in reality, these would be lines of code or may be instructions for a recipe. But I'm using letters instead, so that you can focus on how to create a combined version of file without getting bugged down by thinking about the specific content. Similarly Rachel's version contained a couple of lines. A, B, C and D. Now, Jake and Rachel want to combine their two files into a single version with both of their changes. For each line, mark whether you think it should be present in the final file. Pick yes if it should definitely be in the file. No if definitely not. And unknown if it's impossible to figure this out from the information you have. This is a hard question, so don't worry about getting it right on the first try. Just try your best and think about each line individually In figuring out which line should be in the final file, first we'll look at the lines that are the same in both versions. Line B is in both, so it should be on the final list. It may have been there at the beginning of the day and neither of them removed it. Or possibly both Jake and Rachel added it independently. Either way, we definitely want it. The same thing is true for D. Now let's look at some that are different. Rachel's file contains A, but Jake's file doesn't. There are a few different ways that this could have happened. Maybe the original file didn't contain A and Rachel added it. In that case, we do want A in the final version, but it's also possible that the original line did contain A and Jake deleted it. In that case, the final version shouldn't contain A. It might seem like it would be safest to just include A since you can always delete it later. But remember that these letters could be representing code, so re-adding a deleted line could cause a bug. So, without anymore information, we can't really tell whether A should be in the final version or not, so we mark it as unknown. We can see that the same reasoning applies to C and the opposite is true for E. It's in Jake's file but not Rachel's, meaning that either he added it or Rachel deleted it. Since we can't tell these apart, we don't know whether we should include it or not. In this example there were several lines where you could really tell whether or not it should be included in the final file. This is because it could've been added by one person or they could have been removed by the other and we couldn't tell which was which. How could we solve this problem? Well, it would definitely help to know what the file looked like at the beginning of the day. If the original file looked like this, with the lines A, B and D, could we then determine for these unknowns whether or not they should appear? Again, this is a hard question. Here's how I would go about it. For each line that's in Jake's file, but not in Rachel's, I would try to figure out whether Jake added the chore, or whether Rachel removed it, and vice versa All right. We already knew that lines B and D should be in the final list, since they were in both files. Before, we didn't really know whether the lines had been there at the beginning of the day or whether Jake and Rachel had both added them. But now we know, it was already there. Now let's look at A. At the beginning of the day, line A was present. Rachel's file still contains it, so she didn't do anything with it. But Jake's file doesn't contain it. That means that he removed line A. So we don't want it in the final file. Now let's look at C. C doesn't appear in the original and Jake doesn't have it either, but Rachel does. Since it wasn't there to begin with, we know that she added it, so it should be in the file. The same thing goes for E. Since it's not in the original, but Jake has it, we do want it in the final file. Now that you have a sense of what a merging strategy could look like for a simple file, let's take a look at how Git could use this type of strategy to allow you to merge two branches together. Right now, I want to create a combined version of my coins branch and the master branch. If all Git had was these two commits, it wouldn't be able to tell how to merge them together, just like you couldn't tell earlier whether Jake added a line or whether Rachel deleted it. Luckily, Git also has a record of what the code looked like before the two branches diverged. This is analogous to the file that Rachel and Jake had at the beginning of the day. Using these three commits, Git can create a combined version of the two branches using a similar strategy to the one you used earlier. Commits are the basic building block of Git, so it probably isn't that surprising to you that this combined version will also be a commit. But what will be the parent of this new commit? As it turns out, when you use Git to create a merge commit, that commit stores information about both of its parents, so I'll add arrows to both. Since the goal of this merge is to get the content from the coins branch into the master branch, I'm going to want this new commit to be the new tip of the master branch since the master branch is the one getting updated. Git practitioners will often refer to this process as merging the coin branch into the master branch. After the merge, the master branch will include all the changes that had before plus the changes from the coins branch. It's sort of like creating a new commit with all the changes from the coin branch, except that I still have access to each of these old commits. Note that this is very different from what we would see if we took the state of the files at this point, at the end of the coin branch, and made a commit with that on top of master. All that would do is basically set master to be the same state as coins, but that's not what we want to do. We want to have all of these changes merged in as well. Once we've successfully merged the two branches, we won't need an easy reference to this commit anymore. We'll be able to reach it through the master. So once we're done with the merge, we can delete the coin branch. Note that when we talk about deleting branches, we mean deleting the label. The commits will still be there in the history. However, if no branches can reach the commit, deleting a branch does effectively discard its commits. So if you deleted the coins branch without merging it in first, you would essentially be abandoning these commits since they would all become unreachable. After you create the merge commit, which commits do you think would be included if we ran git log on the master branch? For each of the commits with the checkbox next to it, check whether or not you think it would be included. All of these commits will be shown, including the ones that don't have check boxes next to them. We just thought it'd be kind of tedious for you to check all the boxes. This one on the other hand, won't be included, because it's not reachable by this commit. You might be wondering what order Git will show these commits in, since there are two separate paths. The answer is that the commits are sorted by the time they were created. So, the commits from the two branches might be shown as interleaved. Now Caroline will walk you through actually doing the merge and deleting the branch. Thanks, Sarah. Now, I want to merge the coin branch and the master branch together. After the merge, I'll want the master branch to update and point to the merged version. So if I didn't already have the master branch checked out, I would check it out now. I'll just verify. And yes, I am on the master branch already. I'll run git merge master coins to create a merged version of the two branches. When I hit enter, my editor pops up so that I can type the commit message for the merge commit. Unlike the other commits, this one comes with a default commit message. Merge branch coins. I could change it if I want to. But leaving it like this, makes it clear when I've merged two branches. So I'll just leave it as is. So git lets me know that it made the merge and the file gain.jf has changed. If I run git log, I can see the merge commit. Now I'll go ahead and test whether this worked. If it did, I should see both color and coins when I run the code. Well, I can see that there's color and there's a coin. It looks like the merge worked correctly. One thing you might notice though is that the coin is not colorful like the rest of the game. That makes sense. Git only merges the little changes that you make. And the code to add this coin added a non-colorful version. Now if I run git log again, I can still see the merge commit and I can see these commits added by me and Doug. And there's also some commits by Sarah and enter with the commits by me and Doug. Since the commits are sorted by the time they were created. Now this causes an interesting side effect on git diff. Let's say, I wanted to view the difference between these two commits. I could do it and I would see the difference between them, but this commit is not the parent of this one. So I wouldn't just see the changes introduced by this commit. Let's try it out. Now as you can see, there are quite a few changes in this diff. But actually, this commit was pretty small. To see just the changes introduced by this commit, I'd have to diff it against it's parent. But how do I know what the parent was? While git includes a command called git show, which will show you what changes were introduced by a commit compared to its parent. So that way, I can see the diff between this commit and its parent without actually knowing what the parent was. And now there's a much smaller diff. Since I don't need the coins branch anymore, I'll delete it using the command git branch dash d coins, where d stands for delete. This won't delete the commits in the branch, it will only delete the label. That could have made the commits hard to find. But those commits are now reachable from the master branch, so it's not a problem. Here you can see git lets me know that I deleted the branch. To get some practice creating a merge commit, go ahead and repeat my steps on your own computer if you haven't been following along. If you're interested, you can also introduce a new commit making the coin solid and yellow. But this is optional since you weren't required to have experience with JavaScript. If you do want to make the corn solid and yellow, I recommend using git diff and git show to see what code was introduced in both branches. Otherwise, the solution video will contain instructions for how to make this commit if you're curious. Did you merge the branches on your own computer? Select the most accurate option To make the coins yellow, first I'll use git show to look at the changes introduced by the color commit. Scrolling down, I can see that within the Ship, the color was set to navy and solid was set to true. Similarly, within the Asteroid, the color was set to lightgray and solid was set to true. That probably means that I have to add lines like this to the coin object. Next, I want to compare the first commit before coins were introduced to the final coin commit. I can find the IDs for those by using git log --graph --oneline. So I'll use git diff and here's the latest commit before the coins branch and here's the latest commit with coins. So if I scroll down a bit, there were a lot of changes, but I can see that the coin was introduced here. So I'll open the file game.js and search for coin. And once I find the correct place, then I'll add the lines, this.color equals yellow and this.solid equals true. Now I'll save the file and check whether it worked. And here's a yellow coin, so it looks good. Now I'll double check what my changes were using git diff, add them and commit them. And I'll use the commit message, Make coins yellow. Okay. You have now successfully used Git to merge some branches. At this point, you might be wondering whether Git can always automatically determine how to merge branches. Let's think this through by taking a look at another simple example. In this example, just like in the last one, the original file contains a couple of lines, A, B and D. Remember, these are just stand-ins for lines, not the content themselves. Again, like in the previous example, Jake's file and Rachel's file look a little bit different at the end of the day. This time, at the end of the day, Jake's file contains the lines, A, B prime and D, where B prime just stands for a modified version of B. And then Rachel's file at the end of the day contains A, B double prime. Again, another modified version of B, but not the same one as Jake's. And D. If it helps to think about this in more concrete terms, you can imagine that this file is a recipe and that B is a line that calls for preheating the oven to 375 degrees. Then B prime, for instance, could call for preheating the oven to 400 degrees. And B double prime could call for 350. Then again, this content really could be anything. Just like you did in the last exercise, consider for each line whether or not it should be in the final version. If you think it should be, mark it as yes. If you think it shouldn't, mark it as no. And if you don't think that we really have enough information, mark it as unknown. All right, lines A and D existed in the original file. And there still in both Jake and Rachel's versions. So will mark those as yes. Now let's think about all these B's. Both Jake and Rachel probably had reasons for changing it to what they did, but we don't know which one was right. The two of them will probably need to get together to discuss which one should go in the final version. As for line B itself, you could argue that since both Jake and Rachel modified this line, it should definitely be removed. You could also argue that after discussing their changes, they might just decide that they want to keep the original after all. So let's mark this as unknown. Both of these are reasonable answers. The important thing to notice is that we're not sure which version of B should be present in the final file. In this example, how can Git tell if B prime and B double prime are modified versions of B or if the users just deleted B and wrote entirely new lines in the same area? Rather than expending a lot of effort trying to figure this sort of thing out, Git just notes that the lines are different and goes from there. So how does Git know whether or not there should be a merge conflict? Consider the following two examples. In both cases, we start with two identical copies of the same file. In the first case, two different contributors add new functions to the bottom of the files. These are different functions that don't interact with each other and have nothing to do with one another. However, in the second case, two different contributors add different implementations of the same function with different names. In the first case, you pretty clearly want both functions to be included, but in the second situation, you probably only want one version of the function, probably whichever one is either more memory efficient or faster, depending on what you're going for. But Git can't really tell these two options apart. It would take some pretty sophisticated machine learning to do this. And this is only one possible scenario. Making Git smart enough to figure out all the possible cases where you'd want to auto-merge would be a huge undertaking. So instead, Git just assumes that if you're merging together two commits that have changes in the same general area, the authors will want to know about it and have the chance to figure out for themselves which change to keep. This decision to ask the user whenever there's any ambiguity at all does sometimes lead to situations where it seems really obvious to you, as an expert on the content, how to resolve the conflict. But Git brings it to your attention anyway. While this may be annoying, it's significantly better than if Git tried to guess too often, which could lead to weird conglomerate changes that don't really make any sense and probably wouldn't compile or run. Remember that merging creates a new commit, so we'll have to add a node here. Merge commits have multiple parents. And in this case, those parents will be the current tip of the master branch and the current tip of the easy branch. We're trying to update easy mode, so we'll want to move the label to the new commit. Next, Caroline will walk through the process of actually creating the merge node on the command line. Thanks Sarah. So I don't want to include the easy mode of my game in master, since I still want the official version of the game to be the standard difficulty. But I do want to include all the latest changes from master in the easy mode branch. Do to this, I'll first check out the easy mode branch. So that easy-mode will update whenever I make changes. Then I run git merge master easy-mode. Now git alerts me there was a marge conflict in game.js. This means that both branches, master and easy-mode changed the same part of game.js. Just like when Rachel and Jake both modified the same line. Git can know which changes to keep. So I'll have to resolve the conflicts. To resolve the conflict, I need to open game.js and find where the conflict occurred. Now git represents conflicts using these special lines, so I can always find it by searching for a bunch of less than signs in a row. If I scroll down, I can see that these lines divides the screen into three sections. One, two, three. The top section, marked HEAD is my code. The bottom section, marked master is the code that's in master right now. And the middle section is the original version that both branches modified, which git called the common ancestor. Now when I'm trying to resolve a merge conflict, the first thing I do is try to understand what changes both branches have made. The difference between the middle section and the top, shows the changes that I made in the easy-mode branch. If I'd forgotten what those changes were, I can spend a few minutes comparing and recall that the difference was changing this three to a two. The difference between the middle and the bottom shows the changes that were made in master. And it happens that this particular change was made by Sarah. It's pretty common when I'm resolving merge conflicts. That one set of changes will be made by me. And the other by someone else. So, I might need to go talk to that person. But first, I always try to understand what they were doing. By looking at the changes they made. Here, it looks like Sarah replaced this entire section of code with a call to a function called breakIntoFragments. Now that probably means that she created this function and moved this code into that function. Which is a pretty common way to make code more readable by breaking it up into understandable parts. Now, I need to find this function that she wrote to see if she just moved the code over or if she also changed something. I could search for it. But in this case, it turns out that it's right up here. Now it might look like this function existed in both versions. Since it's not inside the special merge conflict lines. But actually, that's just because this change didn't create a conflict. Now after I've spent a few minutes comparing this function to the code that was removed by Sarah below. I could see that she didn't make any changes to the code, other than to move it. Now, how should I reserve this merge conflict? On the next screen, rewrite the code to what you think the final version should be. Make sure to remove all of these special lines. For example, if I wanted to undo my changes, I could just delete my version and the original version, as well as these special lines to leave only Sarah's code. Instead, you should create a version of the code that incorporates both of our changes In this case I want to keep Sarah's change of moving this code to the function. So I'll need to make my change to the function. So, I'll scroll back up to the function and change this 3 to a 2. Now I'll delete my version since I already have the change from it and the original version since I don't need that version any more and I'll delete git's special lines. I'll also clean up a little bit by removing these blank lines. Now I'm left with the call to the breakIntoFragments function, which breaks each asteroid into two fragments, rather than three. I've just resolved the merge conflict by moving my change of splitting the asteroid into two fragments into the new breakIntoFragments function. However, I still need to let git know that the conflict is resolved. I can do this by committing the resolution. First I'll save the file. Then I'll go back to the command line and run git status. This time, instead of showing game.js as simply modified, git shows the file was both modified. That's because both branches modified the file and then there was a conflict. I resolved the conflict, though, so I'll add the file to the staging area. Now I'll run git status again, and git says, all conflicts are fixed but you are still merging. Use git commit to conclude the merge. So I'll go ahead and do that, and once again git has already filled in a commit message for me. This time it notes that I just merged the master branch into easy-mode, and that there was a conflict in game.js. Like before, I could change this message if I wanted to. But this message describes the commit well, so I'll leave the message as it is and quit. Now I'll run git log. Notice that only one new commit was created. Git didn't create a separate merge commit and a conflict resolution. Instead, it just put them both in the same commit. Now to get practice resolving a merge conflict, go and merge master into easy-mode on your own computer. When you're done, run the command, git log -n 1 and paste the output in this box. The -n flag means that git log will only show that number of commits, in this case, one. After I completed the task. Here was the output of git log dash n 1. The commit message specifies that I merged the master branch into easy-mode. And that there were conflicts in game.js. Now let's go to Sarah to add some of the new concepts you've learned to the concept map. You know that merging and branching both have to do with commits, but what kind of relationships does each of these ideas have with the commit. Branches are really just labels that refer to commits, so we have this new kind of relationship, through first year relationship. So this has to be branch. Let's make sure this really makes sense. Does diff really have an operates on relationship with branch? Well, yes. You can diff two commits or you can diff two branches, which is basically just diff into two commits. But they're sort of different ideas, similarly you can run log on a branch or on a commit. So this must mean that merge goes here. So let's check this one, does merge operate on commits? Well, yeah, merge takes two commits and sort of smushes them together into a new commit. So I think operates on is a pretty good description there. Okay, so the staging area with Git, it's really helpful and really powerful. I think I try to use it in a way where I've just only written the things that I actually want to commit and all I have to do is stage them and commit it. But in practice, things get a little messier than that. So, I think the common pattern for me is I do one thing and then in the process, I accidentally do something else, and then I'll use the staging area to help me just stage the first thing and commit that. And then if I'm ready to commit the second thing, I can. If I'm not, I can keep working on it. But it's just a really helpful tool to make sure that your commits are only the thing that you actually meant to commit even though probably along the way, you did a lot of other things. So for my own projects, I probably won't have that many branches. If, if it's simple enough, I'll even just have one. The main thing that I'll just be doing is committing as often as I possibly can. I'll try and just whenever I think that I've accomplished anything that I can call a commit, that I can call a single unit of work, I'll just commit that. And it does lead to having probably a lot more commits than you'll ultimately need to look back at, but at the same time, there's going to be a handful of them that you really want because you want to undo that one thing or you want to just see why you did that one thing. And it's just really, really valuable to, for those commits to be able to have them and not have them jumbled up with other things. So, committing really, really often is the most important thing for me. Congratulations, you've finished lesson 2. In this lesson, you created a Git repository and added commits to it for the first time. You also learned to use the staging area to control exactly what changes go into each commit. Finally, you learned to maintain parallel versions of your code using Git branches and how to merge 2 branches together into 1 combined version. In the next lesson, we'll see how to use GitHub to share your projects and collaborate with other people. See you then. You now know when you might want to use version control and how to use Git to create and modify version repositories on your own computer. You've learned how to create branches to track new features and how to merge your changes together. In this lesson, you'll learn how to share your changes with other people and how to bring other people's changes into your own projects. There are many ways to do this, but we'll focus on GitHub, a product designed specifically for achieving those goals. GitHub is a website that makes it easy to share an entire git repository with other people. For example, here's a repository that we've created at Udacity. This repository is the source for a browser-based, create your own adventure story. Here are all the files in the repository. I can click round and navigate the directory structure and I can look at the commit history. If I go back to the main page and scroll down a little bit, you can see some information about the project. I can also directly view the contents of files, assuming they're plain text, like code or the story. GitHub also supports a couple of other formats for things like images, 3D models, and map data. In this file, I can click through to the story itself and start making some choices. You can always go back to the main page at the repository by clicking here. This is a public repository so anybody can look at these contents and suggest changes. Caroline and I will go over how this works in detail in this lesson and by the end of the lesson, you'll be able to contribute to it yourself. This is a living project, so by the time you visit this page things might look a little bit different, but the basics will be the same. GitHub is the home of many public projects like this one. A lot of public projects are open source, meaning that you can copy and modify the code for your own purposes. GitHub also lets you suggest changes and send them back to the creator of the project. Some of these open source projects are pretty small, and relatively unknown, like mathquill, which only has ten contributors. You might recognize this one. Some projects are much larger, like iPython, an interactive shell for Python that's nicer than the one you get by default. Another large project is Bootstrap, which is a framework that makes it easier to do web development. There's also jQuery, a JavaScript Library that makes it easy to interact with HTML and Atom, a text editor designed for editing code, and allowing users to customize their experience. These are projects that anyone could theoretically contribute to, of course, any changes must be accepted by the people maintaining the project. But even if the original author chooses not to incorporate your changes, you can still keep your own version. GitHub aims to promote open source by allowing anyone to host public repositories for free and charging for private repositories. Many companies including Udacity use Git to keep track of changes to their proprietary code and use GitHub to host a private copy of their repository and allow for easy code reviews when developers submit changes. For this lesson you'll be interacting with GitHub a lot. Creating, modifying, and suggesting changes to public repositories. So you'll need to set up an account. This is pretty straightforward but you'll probably also want to get set up to smoothly interact with GitHub from the command line which is a little bit more involved. You'll see instructions for how to get everything set up after this video. Now that you've got your GitHub account set up, it's time to make your first public repository, namely by putting your reflections repository up on GitHub. Like with many cloud hosted systems, this will involve syncing between the repository on your computer and the version hosted on GitHub, which is the version you will see on the website. When interacting with GitHub, the information you send and receive is in the form of git commits so changes must be staged and committed before they can be sent. You may notice that I didn't draw a working directory or staging area for the GitHub repository. These exist for every repository, but since the GitHub repository is hosted on GitHub's servers, they're not directly accessible. So they aren't really relevant here. Unlike with many services that sync with cloud hosted versions of your files, when using GitHub, you will need to choose when and how to get the two versions in sync. You can think of this as being similar to how git lets you manually decide when to save a commit. If GitHub automatically got updated with your local version after every single commit, you might end up making things public before they're fully ready, since new features often require multiple commits. So, since syncing doesn't happen automatically, how do we sync between the local copy of a repository and the one hosted on GitHub? In particular, how can you get the current state of an existing repository onto GitHub to begin with? You might be tempted to answer GitClone. That's how it got a copy of the repository from GitHub to local back in lesson one. This would be a pretty reasonable guess to make, but it turns out that GitHub doesn't allow directly cloning onto their servers. So instead, first you'll need to create an empty repository on GitHub. Don't worry about actually doing this right now. The important part is to think of an empty repository in a known location, for the moment. To allow for syncing data between two repositories, git has a concept of a remote repository. This lets you store the location of a repository that you will want to send and receive new commits to and from. Git users often refer to these remote repositories simply as remotes. You will see how to set up a remote soon with Caroline. But for now, I'll represent the connection between the two repositories with an arrow. So what kind of interactions can you have with a remote? Well, you can push data and you can pull data. I mentioned earlier that what you send and receive from remotes are commits. But instead of selecting each individual commit, the most common way to send and receive data is by specifying a branch. So in the case of this repository, and most likely your reflection's repository as well, all we need to do is push the master branch and all the commits will be sent since they're all reachable by the commit at the tip of master. So when you push master, both of these commits will show up. If either of these commits had already been on the GitHub servers before we ran the push command, git wouldn't have bothered sending it. You could imagine that if you had a large repository with hundreds or thousands of commits, it would be very inefficient to send every single commit every time. Just to make sure this concept makes sense, let's look at a hypothetical situation. If I had this commit history locally, and this GitHub repost set up as a remote, then pushed branch a, which commits would need to be sent? Note that here I'm representing both repositories just by showing their commit histories, since communication between repositories only happens at the level of commit history. So it's not necessary to show the working directory or staging area for either of them here. When we push branch a, Git will start form the tip e53 and trace back to find all the commits that are reachable from that commit and send the ones that aren't already on the GitHub repository. So e53 and fd2 will both be sent. But 6b4 won't, since it's not reachable from branch a. And a3b won't, because it's already on the remote repository. So after the push, the GitHub repository will look like this. Like Sara said, to share my reflections repository on Get Hub, I'll first need to create a repository on Get Hub. To do this, I'll make sure I'm logged in by looking for my username in this corner, and then on any screen, I'll click the plus sign and select new repository. I'll name the repository reflections, and I'll leave it as public. Now, I don't want to initialize the repository with a README. If I were making a repository on git-hub before I had created any content, then I probably would check this box. Because that way my repository would start out with one commit in it. You can't clone the repository with no commit, so this is often a good idea. But since I already have commits in my repository that I want to share. I wont check this box. Next, I'll need to add this repository as a remote to my reflections repository, on my computer. Just like I can use the command, git branch, to view and create branches, I can use the command, git remote, to view and create remotes. First I'll run the command git remote with no arguments, to see all the current remotes. The output is empty because I haven't added any remotes yet. Next, to add the repository on GitHub as a remote I'll run, git remote add, and I'll supply the name I want to use. Now I can use any name here and it's the name that I'll use within this repository, to refer to the repository on GitHub. If you only have one remote, it's standard to name it origin, so I'll do that. Next, I'll need to supply a URL for my remote. I can find the URL on the GitHub page where I just created the reflections repository. So I'll copy the URL, then paste it into my command, then press Enter. Now if I run git remote again, I can see that the origin remote has been created. To verify that the URL was added correctly, i'll run git remote -v. V stands for verbose, and means that git remote will output more information. That is, it will be more verbose. The output shows both the URL where I would fetch data from, and the URL where I would push data to. In most cases these will be the same URL. Here I can see the same URL that I just pasted. Now in order to send my changes to the remote, I'll use the command git push. Git push takes two arguments. The remote I want to send changes to, and the name of the local branch that I'd like to push. I named my remote origin,. And I've made all of my changes in the local master branch. So run git push origin master. Before I ran Git Push, I had made a bunch of changes in the master branch on my local repository. And my repository on Git Hub was empty. Running git push copied all of the commits reachable from my master branch to origin. That is my repository on Git Hub. By default, the branch created on Git Hub will have the same name as the local branch that I pushed. So this branch will also be called master. Now I'll refresh the page on GitHub. And I can see that all my files have been added. I can also see here that the branch I'm on is named master. Now create a reflections repository on your own GitHub account. Then push your reflections from your own computer to GitHub. Post a link to your new reflections repository on the forums. Then take a minute to read some of the other students' reflections. You might not want to read their reflections for lesson three yet though. Their reflections will be more valuable if you think about them for yourself before reading what other people have said. Once you've shared a link to your reflections repository, check this box. Hopefully you enjoyed seeing the reflections posted by other students in the course. How were they different from your reflections? Now that you created your repository on GitHub and it has some commits. Let's take a look at what this looks like on the GitHub website. Like in the Create Your Own Adventure repository, I can see what files are in the repository. Also scrolling back up, I can view the commit history by clicking on commits. This is similar to running git log on the command line. But it shows the history of the repository on GitHub, rather than showing the history of your local repository. So you'll only see changes that have been pushed to GitHub. It's also possible to create and edit plaintext files directly on the GitHub website. Right now I just pushed from my local repository to GitHub, so they have the same content. But I'm going to add some content directly on GitHub so that you can see what happens when you have changes on GitHub that aren't present on your local repository. In practice, this can happen if you make the changes directly on GitHub. But it can also happen if you push changes to GitHub from another computer. Or if there's another person working on your project who pushes changes to GitHub. To create a new file, I'll click this plus sign. I'm going to create a file for my lesson 3 reflections. And I'll the first reflection prompt. You'll be seeing this prompt pretty soon. Now, I'll scroll down. And here I can enter a commit message. The message to go in the first box, and I can use the second box if I want to add a longer description of my commit, but I'll leave that blank. Now on the right side of the screen I can click Commit new file. Now I can see that a new commit has been created. Create file for lesson 3 and add first reflection. Now I'll demonstrate pulling these changes down to my local repository in a minute, but first, I want you to create a new reflections file on GitHub so that you can follow along. You'll see some instructions about how to do that on the next screen. Let's think about what the two different versions of Caroline's repository look like at this point. Here's what the local version looked like before Caroline interacted with GitHub at all. Then, she pushed the master branch. And then, since the commits were on the master branch, everything got sent. So at that point, they had exactly the same history. Then Caroline edited a file directly on GitHub and made a commit on the master branch, updating master. So, this is where we are now. Her local version is out of date with the remote GitHub version. To get the repositories back into sync, she'll need to pull her master back into the local version. This will bring the new commit into the local version and update master. Now I'll hand you off to Caroline to see this on the command line. Thanks, Sarah. Now, like you saw, the commit that I just made is shown in the commit history on the GitHub site. However, when I run git log, I can see that that commit isn't present in my local repository. To get it, I'll run git pull. Like when I run git push, I need to specify the remote, which I've named origin. For pull, I'll also need to specify the branch I want to pull, which is the master branch on the remote. Before I ran git pull, I had some commits in my local repository which I'd pushed to git hub. I also had a new commit on GitHub, adding the lesson three reflections file. When I pulled the master branch from the origin repository, that is, my repository on GitHub, it pulled all of the commits reachable from the master branch on GitHub down into my local repository. In this case, I had the master branch checked out, so git also updated my local master branch label to point to the new command. Now, it's not necessary for these two names to be the same, but they usually are. Then, I'll run git log again, and I can see that my new commit is present in my local repository now. Now go ahead and pull the changes you just made in GitHub into your local repository. When you're finished, which of the following is true? Are there changes in your local repository that are not present on GitHub? Are there changes on GitHub that are not in your local repository? Or is neither true? All the changes in your local repository are present on GitHub and vice versa. There shouldn't be any changes in your local repository that are not on GitHub because you ran getPush after the most recent change you made to the local repository. Similarly, you ran getPull after the most recent change you made directly on GitHub. So there shouldn't be any changes on GitHub that aren't in your local repository. Instead the two repositories should have the same commits right now. Okay. Let's see where these fit in. Let's start with GitHub. GitHub is a service that lets users interact with Git. There are couple of different ways that we could've represented this. Maybe GitHub operates on Git, or maybe even that GitHub refers to Git. But I chose to represent it as Git being a part of GitHub. Now let's think about remotes. A remote in your local repository is basically a reference to another repository, so we can say that remote refers to repositories. Also when you clone a repository, a remote gets set up for you automatically, so we can say that clone operators on remotes. So remote goes here. At this point the remaining two spots are exactly the same. They both operate on both remote and branch. So we could put these in either spot. Let's check that this actually makes sense. When you push or pull, you have to specify what branch you want to push or pull. So, it definitely operates on branches. Pull takes a branch from a remote and brings it to your local repository. And push does the opposite, taking a branch and pushing it to a remote. So these do both operate on a remote as well. All right. We now have our Concept Map up to this point. Our coworker Larry, you saw in the first lesson, has been putting together a recipes repository. Carolyn and I like these recipes, but we want to tweak them a little bit to be more to our tastes so that we can then share them with our friends. Larry's okay with us sharing our modified versions, but he wants to keep his version as it is. Since Carolyn and I both want to make changes and we want others to see it, hosting our versions on GitHub would be a perfect fit. It would be possible to get a copy up on GitHub doing only things that we've already talked about. First, we could take Larry's repository and clone it, to say, Caroline's computer. This would automatically set up Larry's repository as a remote called Origin. Then we could create a new repository on GitHub on Caroline's account. She could then set up this new repository as a remote, which she could call whatever she wanted, say Our version. She can then push the changes to the remote, as we've seen before. And then since I want to contribute to this repository, as well, I could clone it to my computer, setting up Caroline's version as origin. This is pretty involved,, and it also doesn't give Larry any recognition for the work that he did on his original repository. Since there's no way somebody looking at ,Our Version, can have any idea about Larry's, unless we link to it explicitly. To get a similar effect with less work on our part, GitHub has a feature called Forking. This allows you to make a copy of somebody else's repository directly on the GitHub servers without pulling down the code to your local machine first. You can fork an existing repository and have it appear under your own account with just a single click. Then to make your modifications, you'd likely want to pull down the code onto your own machine, unless the files are simple enough to edit directly on GitHub. Forking is a lot like cloning. In fact, a fork is just a clone that GitHub makes for you on their own machines. There are a few other side effects to forking. Like GitHub keeping track of the number of people who've made forks on your repository. And the forks all linking back to the original. It also makes it easier to suggest changes back to the original repository, which we'll cover in detail later in the lesson. So, since Larry's version is already on GitHub, forking makes a lot of sense in this case. Caroline can make the fork on her account. Then we can each clone our new version. The clones don't need to know anything about the original repository. Since there are a lot of related concepts in the space of different ways to version your code, we want to make sure that everything makes sense so far. Each of the following diagrams represents either creating a branch, a fork, or a clone. Use the text boxes to indicate which concept is represented by each diagram. Branches happen on a single repository. Of course, you can push and pull branches, but when you create one, you're creating it on one single repository, so the only one that could possibly fit that mold is this one. We have one branch and here we've got a second branch. So this one is a branch. Cloning involves taking an existing repository and making one just like it. The original repository could either be remote, like in this case, so here we cloned from GitHub to local. Or you could even clone a local repository into another spot on your computer. We haven't really talked about this, so this one was probably a little tricky. This one looks a lot like a clone too, but remember, we are cloning our repository from GitHub onto GitHub. You do that using GitHub's built-in fork feature. Forking is only used within the context of GitHub, taking an existing GitHub repository and making a copy of it, whereas clone works on any two repositories. To Fork the recipes repository, first I'll visit Larry's repository on GitHub. You can find the link for this repository in the instructor’s notes. Now I'll zoom into this part of the page, and click the Fork button here. Then a copy of the repository is made on my own GitHub profile. Now, when I visit my profile, I can see the recipes repository here. Now I'd like to be able to edit these recipes on my own computer rather than just on the GitHub website. So I'll also want to clone this fork. For recipes it doesn't matter so much where I edit, but if I were writing code I would definitely want to be able to edit on my own computer. The GitHub page contains the URL I should clone over here, so I'll copy that URL. And paste it into my git clone command. Now I'll cd into the new repository and you might think that I need to add the fork on GitHub as a remote so that I'll be able to push to it but actually when you clone a repository Git automatically sets up a remote pointing to the repository you cloned from. I'll verify that by running git remote -v. And, sure enough, there's a remote called origin. And the URL points to my repository on GitHub. Finally, since I want Sarah to be able to collaborate with me, she'll need permission to push to this repository. I'll add her as a collaborator by going to Setting, clicking Collaborator, and then adding her GitHub user name with the salogel42. You won't need to add Sarah as a collaborator to your repository, but you can add anyone who you would like to be able to push to your repository. Then I'll need to click the Add Collaborator button. Now fork Larry’s repository to your own GitHub profile. Don't fork the one on my profile, since I'll be making changes to my fork throughout this lesson, and you don't want those changes. Again, you can find full link to Larry's repository in the instructor's notes. Once you've created the fork, clone your fork and run git remote -v and paste the output into this box. When I run git remote -v in my Chrome, I can see that both URLs are github.com/cbuckey-uda/recipes.git, which is the URL of my fork on GitHub. You should have seen the URL of your fork, so your username should have been here instead of mine So far in this lesson, when two repositories have gotten out of sync, it's always been a matter of one repository having commits that the other doesn't, like in this case. What if both repositories have new commits reachable from the same branch? What do you think would happen if you pulled or pushed in this case? When you pulled earlier in the lesson, your local repository didn't have any commits that the remote was missing, so pulling set your state to the be the same as the remote. But if that happened in this case, we would be losing this commit. So, what really happens when you pull a branch? What you want is a combined version of both of these branches. Does this sound familiar? What you really want to do is merge the local and remote versions of the branch. We'll get into the details of how that works soon once you actually have some changes in both repositories to incorporate. For personal projects, this would only happen in practice if you are working from multiple different machines or made some edits directly on GitHub and others locally. The more common reason for an issue like this to come up is when you're collaborating with others. Caroline and I will demonstrate collaboration, but unfortunately, we don't have the time to directly collaborate with each of you. You'll follow along with Caroline's side of the collaboration. And when I make changes, you'll run some code that we wrote to make it look like I've made the same changes in your repository. We'll give instructions on how to do this when the time comes. First, you'll make a quick change to one of the recipes locally. After this video, you'll see some instructions for doing so. I decided to add some onion power to the recipe, so I need to add onion powder to the ingredients list and then also add it down here. And this line is a little long now, so I'll break it into two lines. Now I'll use git diff to double-check what changes I've just made and I can see the addition of onion powder. Add the chili recipe to the staging area and commit. Now when I run git status, I can see that my branch is ahead by one commit and that's the commit I just made. Okay. Now that I've added onion powder to the recipe, oh, I have a message from Sarah. I guess she made a change removing cumin from the chili recipe. Yeah, I agree, I don't like cumin much. Sounds good. Now, I'll go take a look at that. I'll look at the commit history to see Sarah's change. Looks like this one. Now I'll scroll down to see the dif. And it looks pretty straightforward. She removed cumin from the ingredients list and she removed the direction to add cumin. Since Sarah and I both modified the same line though, Git is going to mark this as a conflict. On the next screen, you'll see some instructions to add Sarah's changes to your own fork. Then Sarah will go over how I can resolve this conflict. Okay, I mentioned earlier that getting everything up-to-date would require merging the local and remote branches. How does this work in practice? As it turns out, when you have a remote set-up, Git stores local copies of all the remote branches. These will each contain the state of the remote branch as of the last time you pushed or pulled the branch. Let's look at how this would play out over the lifetime of a repository. We'll consider a repository that got created on GitHub with a readme, and then got cloned. Remember that cloning sets up a remote for you called origin. We've already seen that when you clone a repository, you get a local branch called master, that points to the same commit as the remote one. But what you haven't seen yet is that you also get a local copy of the last known position of that branch on the remote. The name of that branch includes the name of the remote, origin, since you can have multiple remotes set up, as well as the name of the branch on the remote. In this case, master, with the two separated by a slash. So in this case, it'll be origin/master. And since we've just had an interaction with the remote, it's currently in the same location as the actual remote version. Let's consider what happens when you make commit on the master branch locally. As usual, when you make a commit on a branch, that branch will get updated to point to the new commit. But, neither the local origin/master branch, nor the actual master branch on the GitHub repository, will get updated because you haven't communicated that you want to do that. However, if you push the master branch, the local origin/master branch and the remote GitHub branch will get updated with the new commit. Similarly, if this branch were to get updated on GitHub and then we pulled, both of these would get updated with the new commit. Let's go back to thinking about what happens if you've got different changes on each repository, with one change locally and another remote. It turns out that you can update just the local copy of the remote branch, leaving your actual local version alone by running the command git fetch. In cases like this, where there are potentially conflicting changes, using git fetch to update the local copy of the remote branch can be nice, so that you can use git log and git diff to see what changes were introduced, both on the local and remote repositories. This way, if you're going to be offline for a while, say if you're about to get on a plane, you can update your local copy of the remote branch before you leave. And then you'll have access to any updates that have been made to the remote since you last synced up, while you were offline. But you don't have to act on combining those commits right away. Speaking of combining changes, now that you have the commit from GitHub on your local repository, it's now possible to incorporate them into your master branch, using git merge. It turns out that this is exactly what happens when you do a git pull. First, the remote branch gets fetched, updating the local copy of the remote branch. Then, that branch gets merged into the local one. To put it more concretely, in this case, fetching updates origin/master with the contents of GitHub's master branch, and then origin/master is merged into master. So git pull is the same as git fetch followed by git merge. Now Caroline will demonstrate doing this process on the recipes repository on the command line. I can update the local copies by running git fetch origin, which will update all of the local copies of every branch for the origin remote. I can inspect the local copies by running git log origin/master. Or git diff origin/master master. But before I do that, I want you to predict what you'll see if you run these commands. You can also run the commands yourself to see if you're right, but it can help to think about this before trying it. I'd like you to predict the output of git log and git status both before and after you run git fetch. If you run git log origin/master before you run git fetch, which of these commits do you think will be shown? Larry's commit, adding the chili recipe? Your commit, adding a new spice? Sarah's commit, removing cumin? Check all that apply. Similarly, check all the commits you think will be shown after you run git fetch. When you run git status on the master branch, Git will let you know whether your local master contains any commits that are not reachable from origin/master or vice versa. If you run git status before you run git fetch, will it say that your local master is one commit ahead of origin/master? One commit behind origin/master? Will it say that your branch is up-to-date, meaning the two branches point to the same commit? Or will it say the two branches are out of sync, meaning each has a commit not present in the other? Similarly, after you run git fetch, what will git status say? To answer this question, let's think about what commits were present on GitHub and in your local repository before and after git fetch. When you cloned the repository, the latest commit on it was Larry's commit adding the chili recipe, so that also became the latest commit in your local repository. Of course, there were other previous commits, but I'm leaving them out here for the sake of space. Now you made a commit adding a new spice, so that commit is also present in your local repository. And that's where your master branch is. origin/master still points to the commit that was on the remote at the time that you cloned. After you cloned, Sarah added the no cumin commit on GitHub, but your origin/master branch won't reflect that yet. So, this is the state of master on GitHub. Now, this was the state of both repositories right before you ran git fetch. So, if you ran git log origin/master, you should have seen that Larry's commit adding the chili recipe was present, but your commit adding a new spice and Sarah's commit removing cumin were not present on the origin/master branch. If you run git status, you should have seen that your branch was ahead of origin/master by one commit. This makes sense because git log and git status both run without internet access. Suppose you were somewhere without internet access when you ran these commands. Your local git repository would have no idea that the cumin commit existed. So, of course, the cumin commit wouldn't be shown when you ran git log origin/master. And git status wouldn't know that your branches were actually out of sync. It thinks that your branch is just ahead. Now when you run git fetch, git fetches the no cumin commit and updates the branch origin/master to point to that new commit. Your local master still points at the new spice commit like it did before. So at this point, you have a local copy of the no cumin commit saved, and you can access it via git log. If you run git log now, you'll see both the no cumin commit and the chili commit. You still won't see your new spice commit since that's only on your local master branch. Now, since both origin slash master and master have one commit that is not present on the other, git status will show that your branch is out of sync with origin/master. Since I've already run git fetch, my origin/master will contain Sarah's changes, which I can verify by running git status. As expected, I see that my branch and origin/master have diverged and have one and one different commit each. Now I'm ready to merge Sarah's changes into my local master. So, to do that, first I'll make sure I have the master branch checked out. And then I'll run git merge, and the two branches I want to merge are master and origin/master. Like I expected, I got a merge conflict, so I'll open the file and resolve it. So I can see here's the original version before either of us made changes. Here are my changes with onion power added, and here is Sarah's version with cumin removed. I'll just take Sarah's version and add onion powder to it. Then I'll delete both of the other versions and save my changes. Finally, I'll let git know that the conflict was resolved by adding the chili recipe and committing. As usual, when I merge, Git creates an automatic commit message for me, this time letting me know that I've merged the remote-tracking branch origin/master. Since running git pull is the same as running git fetch and then git merge, I could have run git pull origin master and the same thing would have happened. If I run this now, then I can see that master is already up-to-date, which makes sense. Now create a merged version of your changes and Sarah's changes by running either git pull or both git fetch and git merge. Then push the merged version up to GitHub. Once you're finished, run git status and paste the output in this box. To push my changes to remote, I'll run git push origin master. Then when I run git status, I see that I am now up to date with origin/master. I'm not ahead and I'm not behind because now I've merged Sarah's changes into my local master and I've pushed my changes up to the master on GitHub. At this point, you might have some questions. You might be wondering if GitPull is the same as fetching and then merging. Why haven't our previous pulls generated merge commits like this one did? It's a fair question. The answer is fast-forward merges. This kind of merge occurs when you merge two commits, where one is ancestor of the other. That is, where one commit is reachable by the other. If all merges happened the way we've been showing you so far, if you took b and tried to merge it into a, then you would end up with a merge commit that had both commits as a parent, and you would move a. In the usual case, merge commits are generated to keep track of all the commits that played a part in getting to this new stage. But in this case, the commits that played those parts are this one and this one. And this commit already has all the information about this one's history. So there's not actual reason to add this extra one. So instead of adding a new commit, all we would do is update the label to point here instead. Hopefully, at this point the name fast-forward merge makes sense. We're taking a label from the history of a branch somewhere in its ancestry, and moving that label forward to the tip of the branch. Take a look at these commit histories. Check the box next to each diagram, where merging branch b into Branch a would result in a fast-forward merge. Remember, the only criteria for whether something would be a fast-forward merge is if the branch you are merging into is an ancestor of the branch that you're merging from. This is an example of that. It's pretty clear. If you trace back from b you get to a. So this one would definitely be a fast-forward merge. In this case you can also get from b to a. There would be another way to go. But since this is in the history at all, we do check this one. Here there's no way to get to a from b. Nowhere in the line from b to the first commit do we find a. So here, no, we can't do a fast forward merge. We would have to create a new merge commit. Similarly, in this case, a is not in the path from b to the initial commit. So we can't do it here either. Now that you've seen how to make changes public by sharing them on GitHub, I wanted to show you a work flow you can use to get feedback on your changes to a project before you update the master branch. As an example, here is the recipes repository both locally on my own computer and my fork on GitHub. If I have a change I want Sarah's feedback on, then first I'll make that change locally on a separate branch. Next, I'll push that change to my fork. Now my change is shared on GitHub, so Sarah can see it, but it's not in the master branch. That way if Sarah finds a problem with my change when she reviews it, I won't have broken master. Next, I'll use a feature of GitHub called pull requests that make it easy for Sarah to see exactly what I've changed and leave comments. When we're both ready, I'll merge this change into the master branch. Right now, I want to change the cake recipe to use canola oil instead of vegetable oil, since it's healthier. First, I'll make a new branch called different-oil. Then I'll check out that branch, and I'll go ahead and make the change. Now, I want to show Sarah the changes I've made, so I'll add them, commit them, and push them. Note that this time I'm running git push origin different-oil to push the different-oil branch instead of master. Now that I've pushed my branch, it's possible to see it on GitHub. To see what branches exist, I can choose this drop down, and I can see that right now I'm looking at the master branch. And here's the different-oil branch that I just pushed. This list of branches is the same list I would see if I ran get branch on the repository on GitHub. So only branches that I've pushed to GitHub will show up. To see what the files look like on the different-oil branch, I can click on it, which analogous to running git checkout. Sarah could also do this and then view the commit history to see what changes I've made. Instead though I'm going to create a pull request for my changes. I'll go back to the main page for the repository, and I could click the compare and pull request button here since I just pushed the branch recently. But if I'd pushed it less recently and that button wasn't there, then I would check out this branch, scroll down a little and click Pull Request. By default, GitHub assumes I want to merge my changes into the original repository, which is Larry's repository. But instead, I want to merge my changes into the master branch of my own fork. So I'll scroll to right and click Edit. And now I can change the base fork to cbuckey-uda/recipes. Now I'll scroll down and to the right, and click Create pull request. Now, GitHub makes a view that shows all of the commits that are present in this pull request and all of the changes that have been made. If I go back up to the repository and scroll to the right, I can also see a list of all Pull Requests. So, Sarah can check this list and see that I'd like to merge these changes into master. Now, I'll turn you over to Sarah while she looks at my pull request. Since I'm watching Caroline's fork of the recipes repository, I got an email notifying me when she made a pull request. I can click through in this email to see the pull request on GitHub. You might be wondering why these are called pull requests. Caroline initiated this request, but she's not asking to pull anything. She's trying to merge one of her changes into master, or you might think of this as her trying to push into master. So why is it called a pull request? It's because she's requesting that I pull her branch into the master branch. Another good name for this might be a merge request. But, pull request is what GitHub picked, so we'll go with that. So Caroline wants me to merge her different-oil branch into the master branch. Since the master branch is the main branch, and it's what people will see when they first come to the repository, I want to make sure that it really looks good before actually doing the merge. All right. It looks like she just changed vegetable to, oh, canols? I think she meant canola, based on the name of the pull request. I don't really want to merge this in because it has a spelling error. That would probably be confusing if anybody was looking at this later. So instead of merging it now, I'm actually going to leave a comment. I could put my comment here, commenting on the whole change, or I could do an inline comment here. I think I'll choose that option. At this point, I'll go back to the main pull request. If there were more commits, I could look at them here, but since there's only one, I don't need to look at anything else. If I had decided that the change was good, and ready to be pulled in right now, I could have pressed this Merge pull request button. This will only appear when the merge could go through without a conflict. So it's a nice indicator to the person reviewing the changes, as to whether or not it's really ready to go. If the change would have created a merge conflict, I would ask Caroline to merge master into her branch first, so that I could see how she resolves the conflict. That way I know that when her code finally does get added to master, there's no chance that something's going to go wrong with a bad merge. All right, at this point you should go ahead and make the change that Caroline described by creating a new branch off of master, and committing a change that switches vegetable oil out in favor of canola. You can make a typo or other mistake on purpose so that you'll have a reason to update the pull request later. You don't have to. Go ahead and push your new branch to the fork, and then use GitHub to initiate a pull request, but make sure not to click the Merge button yet All right, let's start from the beginning. With this action, we edit and save a README. This change will only affect the working directory. All right, what about this one, git add README? This will take the change from the working directory and add it to the staging area. So, the staging area will be changed. Then we have git commit. Running git commit will create a commit with the changes from the staging area and update the master branch. Okay. So, what about git pull origin master? This will take the commit currently in the master branch on GitHub and pull it into the local branch and merge it into what's currently on master. So, the local master is the only thing that changes. Now we have git push origin master. This will take what's in the local version and push it to the remote. So this operation just changes the remote. Okay, down to the last one. If we have a pull request to merge the alt branch into master, and that pull request gets accepted and merged in, then the alt branch will get merged with master. So the GitHub master branch is the only thing that will get updated. I just got an email letting me know that Sarah commented on my pull request. She says that I misspelled canola. Well, I'll go take a look. Canols oil. Yeah that's not right. I'll go ahead and fix that. And I'll commit my fix. Now since I want this change to be visible on GitHub also I'll push. Pushing the branch automatically updates the pull request on GitHub. Underneath Sarah's comment about my misspelling you can see my commit fixing the typo. Also, if I look at the commits I can see there are two now. And if I look at the files changed I can see the correct spelling. Now I'd like you to follow the same steps and make a pull request on your own. First, create a new branch called different-oil, then make a different commit on the different-oil branch, to use canola oil instead of vegetable oil like I did. If you want, you can make a typo on purpose but that's optional. Then push your different-oil branch to your fork on GitHub and create a pull request. Make sure to change the base to the master branch of your repository and not Larry's repository. If you made a typo earlier, then make another commit to fix the typo and update the pull request. Finally, paste the link to your pull request in this box. You can find a link to your pull request by viewing your repository on GitHub, scrolling over to the right, and looking at the list of pull requests. Then click on your pull requests, and copy this URL from the URL bar. Finally, make sure you don't merge the pull request yet. If you do, then a later exercise won't work The link to my pull request is github.com/cbuckey-uda/recipes/pull/1 since this is the first pull request in this repository. If you're having trouble creating your pull request, please post about your problem in the forums. Okay. Now that you've seen how create a pull request, let's take a look at what happens when someone else makes changes that conflict with your pull request. Sarah has said that my pull request looks good, but she has also made a pull request. I can see it here in the list of pull requests. It looks like she increased the amount of oil to put in the cake so that it would be more moist. Since our changes affect the same line, git will mark them as a merge conflict, so one of us will have to resolve the conflict. I'll go back to this screen and merge Sarah's changes first, and then I'll need to resolve the merge conflict. Yes, confirm. And since Sarah only created the more oil branch in order to make this pull request into master, it's safe to delete the branch now. Now when I go back to my pull request, I see that it can't be automatically merged anymore. This is because performing a merge between the master branch and my branch would now cause merge conflicts. Rather than having you resolve the merge conflicts from the browser GitHub requires you to merge the changes on your own computer and send update the pull request with the merged version. Let's go to Sarah to talk about how you would do that. Here's what the recipes repository looked like on GitHub before Caroline merged in my change. Notice that I've left some of the earlier changes out this time because I'm a little bit pressed for space. Here's the branch that I created to add more oil to the recipe. And here's Caroline's branch with the different kind of oil. With the misspelling, and master at this point is still unchanged. And here's what the local version looks like. My changes aren't there because she hasn't pulled since the last time she pushed. What do you think happened in this diagram when Caroline clicked the button to merge my branch into master? You might be remembering when we talked about fast forward merges. And how since master is an ancestor of more oil. Master might just get updated to point to the tip of more oil branch. That would be a great guess. That's actually what I would of expected, but it turns out that even if you could of had a fast forward merge, merging with the button on GitHub will always make a commit anyway even if no extra information is given by making that merge commit. After clicking the button to make this merge commit. Caroline also deleted this branch. GitHub makes this very easy to do after a merge and it's pretty common to want to actually get rid of this branch cause usually it's named for the specific purpose that, that branch was serving and once you merge it in it's pretty much at the end of it's life. So we'll go ahead and remove it from the diagram as well. So this is what GitHub looks like at this point. Now if Caroline wants to update her pull request to include my changes. If merging these two branches wouldn't cause a conflict, I could actually just pull in her request now. But since we changed the same lines, she's going to have to pull these changes over into her local version. So she'll need to pull master. This will update her local version with all the commits on master that aren't already on her version. So this one and this one. And it'll also update origin/master. There wasn't an obvious place to put this, since there's so many things attached to this commit. And I'm a little low on space. So, here's an arrow to show you that this is attached to this command. Remember, Caroline's eventual goal is to get her change into the master branch up on the GitHub repo. So, you might be tempted to think that she should just merge her branch into master and push it up. This is basically what happened the last time we had a merge conflict. But remember, this time we're using pull requests to communicate our changes to one another. So if Caroline just merged her branch into master and pushed it up, I wouldn't have a chance to check out her updates and make sure her changes still looked good before she updated master. In this collaborative environment it's often only acceptable to make changes to master through pull request, since otherwise things can change out from under you without notification. So Caroline will need to make the fix to her branch. Fix the typo for canola, and then merge in master into her different oil branch. And then push her branch up to GitHub which will update the pull request so that I can look at that before merging it back into master. Sounds good Sarah. So like Sarah said, the first step will be to get her changes into my local repository. Right now if I run git log on the master branch, I don't see Sarah's commit. So I'll need to run git pull. And I'll pull from the origin remote in the master branch. Recall that if I wanted to take another look at Sarah's changes first, I could run git fetch, examine the changes, and then run git merge origin/master master. But since I already know what her changes are, I ran git pull instead. Now I want these changes to be incorporated into the different-oil branch, so I'll run git checkout different-oil, and then git merge master different-oil. As expected, I get a merge conflict. I'll resolve the conflict keeping both of our changes, so now there's three quarters of the cup of canola oil, and then I'll commit the merge. Now I'll run git log, and I can see that this branch contains both of our changes. Here's where the more oil pull request was merged, and here's the merge commit that I just made. Now go ahead and repeat these steps in your own repository. In order to get Sarah's changes to appear in your fork, you'll need to download and run the code we've provided in the downloadables section. There are instructions on how to do this in the instructor's notes. Now this code won't actually make a pull request, so you won't see a pull request appear in your repository. Instead, if you look at your commit history on GitHub, you should see a commit that looks like this one, saying, merge pull request. And you should also see Sarah's commit, adding more oil so the cake is moist. Once you've run the code to simulate Sarah's changes, update your local repository with Sarah's changes and merge your master branch into your different-oil branch, like I did. Finally, push your different-oil branch to your fork to update your pull request, which I haven't done yet. Once you're done, here are some things you can check to verify that everything has gone correctly. Your local master branch should contain Sarah's changes. Your local different-oil branch should contain the merge commit, merging Sarah's changes into your branch. The same merge commit should be visible on your pull request. And the merge button on your pull request should be green. Check these boxes once these things are true for you. Now, I'll run git push origin different-oil. As you saw before, pushing the branch updates the pull request. So, now the pull request can be automatically merged. If I look at the changed files within the pull request, I still only see my changes. That's because this view, only shows changes that are present in my branch, but not present in the master branch. And Sarah's changes are in both branches now. Finally, I'll leave another comment for Sarah, so she'll know to take another look and make sure everything looks good now. That's because GitHub will email Sarah, if I leave this comment. But it actually, won't email her that I've updated the pull request, so I want to make sure she sees the update With the addition of these concepts, the Map's gotten a lot more complicated. Let's start by looking at this spot. The thing that goes here has to be a type of clone, and it's a part of GitHub. So, it will be something that's GitHub specific and not a part of the original Git system. It's also going to be something that operates on a repository. Of these options, the only one that fits is fork. Let's double check that this makes sense. Forking is like cloning but with some extra steps and you can only do it on GitHub itself. It also takes a repository and makes another repository, so it does operate on repositories. All right, let's move on. Remember, how we talked about pull being a combination of fetching and merging? When we have merge here, so this will have to be fetch. Let's check, that this makes sense. We know that fetching is a part of pull, but does it operate on remotes and branches? It clearly operates on remotes, because you're fetching data from the remote repository. The connection to branch is a little less clear. You can definitely, fetch a particular branch. When you fetch, the branch doesn't necessarily get updated. But remember that, we have references to the remote versions of our branches, and those are the things that get updated. So, it does operate on branches, as well. Now, it might be tempting to put fast-forward merge here. Since, you would think fast-forward merge would be related to merges. But the way that I think, about fast-forward merges is basically, that they change where a branch points. So, it's take a branch label from one commit to another commit. So in my mind, it just operates on a branch. We're down to one option and only one spot left, so this is gotta be, where this guy goes. Let's check, that this actually makes sense. When you make a pull request, you're asking to have a particular branch be merged in, with the main branch or some other branch. It doesn't necessarily, have to be a master. And pull requests are purely GitHub idea. They don't exist in git proper. So, mergers are part of pull requests. Pull requests, work on branches. You merge two branches together. And it's something that's part of GitHub, so it all fits. All right, we're done with the Concept Map for this lesson. My name is Brent Beer. I'm one of the trainers here at GitHub. Which usually entails sometimes doing online classes. Classes in person. Or sometimes, with Enterprise customers doing private courses, as well. So, one of the things that confuses people, often, when they first start is, well, I know, I've heard about Git and I've heard about GitHub. You know? What is the difference between the two? And Git, itself, being the version control tool that GitHub is built on. So, Git is largely the thing that will be interacting with on the laptop. Doing that local work first and as soon as we use a few choice commands and send things up to GitHub that's when it's more the social component or it's in it's network, it's in a cloud if you wanted to use that term as well. So Git is local. GitHub is where we share and collaborate with other people. The reason why I like pull request is because it allows us to, really get that work that we're wanting to, kind of, work on, and complete that feature. And allow us to collaborate with other people just to show them our work. Get feedback on it. So that we can have people kind of working with us as they choose to or as we want to pull other people into the work itself. When GitHub started you know, a few years ago kind of a, as a out of a need for the Ruby community to have ways to kind of share their code and collaborate. It's expanded past that and now, you know, a lot more open source communities and languages have, you know, grown within GitHub and the GitHub ecosystem. So, GitHub helped the open source community and, and helped make it a little bit better by allowing us to have this centralized place where we can talk about any features that we're wanting to work on. Any problems that we might have as we decide to share code around or incorporate code into other projects so it helps the communities kind of have that place where they can pull together, talk about their new features and work through problems together. In fact, the node community itself is one of the larger communities that first started out after GitHub was already around. So, they were able to flourish as a community, whereas other communities maybe were older and came to GitHub later and then grew from there. While you're making a contribution to the create your own adventure story, you may find that your pull request can't be merged because of merge conflicts. Here's how that could happen and how you could fix it. Suppose you fork the original repository on GitHub, clone your fork, then make a change in a new branch, and push that change to your fork. In the meantime, someone else changes the original repository on GitHub. If there are merge conflicts between their change and your change, then your pull request will not be able to be automatically merged. Since there's no way to resolve merge conflicts on the GitHub site, you'll need to resolve the conflicts within the clone on your computer. To do that, you'll need to get the conflicting changes from the original repository into your local repository, which you can do by adding a remote. Recall that you already have a remote set up called origin that points to your fork. But you'll still need to add a remote that points to the original repository. And many people name this remote upstream. Adding and fetching the upstream remote will add branches like upstream/master into your local repository, so that you can merge the upstream branch with your local branch. For example, I created a pull request to add an option of stop, drop, and roll to a page of the story where there was a fire. In the meantime, though, another change was made to the same file to add an option to turn on the chocolate sprinkler. That change conflicts with mine, so I need to resolve the conflicts before my pull request can be merged. So in this diagram, this is the commit adding the chocolate sprinkler, and also this one. And my change was to add a stop, drop, and roll option. These commits were the same in all the versions. Since I created my change in a separate branch, I want to make my master branch the same as the master in the original repository. So, I'll run git pull upstream/master to update my master branch to the latest commit from the original repository. Then I'll merge the master branch into my changed branch, and I'll push both the changed branch and the master branch to my fork. I didn't need to push the master branch, but I thought it might be nice. Now since this whole process only contains commands that you've already learned, I want you to try doing this on your own before I demonstrate how to do it on the command line. As a reminder, the steps you'll need to carry out are, first, add the original repository as a remote in your clone. Next pull the master branch from the original repository into your clone's master. Merge the master branch into your change branch locally. And resolve any merge conflicts. And finally, push your change branch to your fork, which will automatically update your pull request. If you run into trouble, I'll demonstrate how to carry out this process in the solution. If you didn't run into this problem because your pull request was merged without conflicts, I encourage you to get some practice by making a new change and then not making a pull request for it. Then you can wait for someone else to make a change and then get some practice bringing your fork up to date. Even if there are no merge conflicts, you can still get practice merging. Once you've finished this process, check this box First, I want to add the original repository as a remote to my clone, so I'll copy the URL here. Then I'll run git remote add. I'll name the remote upstream, and I'll paste in the URL I just copied. Now I'll check out the master branch and bring it up to date with the original repository by running git pull upstream master. When I run git log, I can see that the chocolate sprinkler changes here. Now I'll check out the stop, drop, and roll branch again, and I'll merge it with the master branch by running git merge master stop-drop-roll. I'll resolve the merge conflict by adding my stop, drop, and roll option alongside the chocolate sprinkler option, and then I'll get rid of the special lines and the other versions of the file. Next I'll add the fire and commit to complete the merge. Finally, I'll run git push origin stop-drop-roll to push this branch to my fork. Note that you'll need to push this to origin, which is your fork. And not upstream, which is the original repository. Since you don't have permission to push to the original repository. Since I also want master on my fork to be up to date, I'll also check out the master branch and push that as well. Now it looks like my pull request is good to be merged. Congratulations, you've finished lesson three. In this lesson, you used remotes to push changes up to GitHub and pulled down changes made by other people. You also got practice using pull request to collaborate with other people. This is also the end of the course. We hope you enjoyed it. We certainly had fun making it. What was your favorite part about making the course, Sarah? Oh, I really enjoyed thinking about how all the concepts fit together, so we could draw the concept map. What about you? Hm. It's a tough question. But I really enjoyed adding color to the Asteroids game. I was so excited when I got that working. What about you guys? What did you like about the course? Or what do you wish that we had done differently? Go to the forums to tell us what you think. Thanks again for joining us. And remember to use Git on your next project.