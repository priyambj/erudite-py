Hi. I'm Pete LePage, a developer advocate at Google. And I'm Cameron Pittman, a front end course developer at Udacity. We're here to help you create websites that look and feel great, no matter the device. In this course, you'll be learning basic guidelines, that make sites look great across the dozens of different devices in use today. So Pete you're the expert. What are websites like Google News doing to look so good on every device? That's a great question. Google news uses two different strategies. A fully responsive version for phones and tablets. And for desktops it uses a responsive layout that starts at a minimum size. That works well for them, but adds a layer of complexity and extra work to keep things up to date. Hm, that's interesting. You know I know there are a lot of different ways to accomplish good, responsive design. What about websites like Skinny Ties? Yeah, Skinny Ties was fully responsive across all devices, laptops and desktops. This is my preferred way of building sites, because it means no matter what device the user's on now, or in the future, my site's probably going to work well. Nice. You know, that makes a lot of sense. Great, then let's get started. Cool. The first step to developing a responsive site is to get inspired by other responsive sites. For this quiz, I want you to surf the web and find an example of a site that does responsive design well. Share your findings in the box below or in the forums. Here's an example of a responsive site. Check out alistapart.com. Watch what happens as I resize the window. I'll scroll down, and then pull the window in. You can see that the content reflows to fit the smaller viewport. Besides its responsive layout. A List Apart is also a great resource for web developers who want to stay on top of their game. So, you are looking at the project for this course. Notice how it's not responsive at all. At the ends of lessons 2, 4, and 5, you'll be challenged to improve this site's responsiveness. I want to make it super, super clear that there is no right solution to this challenge. You'll hear us repeat throughout the course that responsive design is an art, not a science. To improve your responsive design skills, you'll just have to practice. I'll be talking through the decisions we made, and the steps we took to make this site responsive. And I really don't expect your answers to look anything like ours. This course is all about thinking responsively. Sure, we want you to walk away with a few new CSS tricks up your sleeves. But more importantly, I want you to walk away approaching responsive design, from the right mind set. I'm recording this video now after having spent several months working with Pete on this course. Over this time I have actually learned quite a bit. I'd done some responsive work before, but I hadn't approached my sites the way you'll be learning in a few minutes. A few weeks into filming I decided to revamp my personal site. And this is what I came up with. Now I know it isn't the prettiest thing in the world, but it's nicely responsive. And believe it or not this website actually only took a few hours to build over a weekend that wasn't to bad. What helped is that I approached responsiveness systematically from the state instead of just as an afterthought. All this is to say, that thinking responsively is a huge help for your development. So, are you ready to get started? Are you excited to get responsive? Let's get started. Pete. This is really annoying. What's that? Well I'm on google.com/finance and this is ridiculous. I have to pinch and zoom like crazy and look my fingers take up like half the screen. How am I supposed to hit a button that's only ten pixels tall? Yeah, and try and look at that same site on your TV and it's just as bad. Come on. People don't actually do that to themselves do they? It's crazy. They do. Uh-huh. The mobile market is growing faster than any other market. And if you're a web developer and not building for mobile devices. You're just going to lose all of your users. That's the core concept behind responsive design. Make your content work across any device. Throughout this course, you're going to need to test your site on different devices. So, pull out your credit card and get ready to order all of these devices that you see behind you. [LAUGH] Pete, I, I don't think we can ask everybody to do that. Fair enough. Instead, you could just use a simulator or emulators. Simulators and emulators are great tools. While they're not always 100% accurate, because they're on different hardware and sometimes have a different code path, they'll often get the job done. And for this course, we'll be just fine. In this course, Cam and I are going to use an emulator built into Chrome, but be sure to check out some of the other ones including the iOS simulator, and some of the cloud based services in the instructor notes. Nice, I like that a lot more, emulation is definitely the much cheaper solution. It is, here lemme show you how it works. I'll open up Chrome Dev tools emulator, and look at a mobile view of the web fundamentals site. I'll open Chrome, navigate to Web Fundamentals, then open the Chrome Developer Tools, using Cmd, Option J, or Control ALT+J. Next, I'll hit the emulator button. It's that phone looking icon in the toolbar. Great, the emulator is ready to go. I can start loading pages and see how they look. But before I do, I like to dock the tools to the right side of the browser window. Since most phones are viewed in portrait, docking to the right side gives me the most amount of vertical space. The other thing I need to do is pick the device that I want to emulate. Chrome has a bunch of predefined devices, that I can choose from. It auto-magically sets the view port size, the user agent string, device pixel ratio, and enables touch emulation. If you're not familiar with some of these terms, don't worry. We'll cover them as part of this course. Now I can see how a page renders across different devices without ever leaving Chrome. Sweet, that looks about how I'd expect it. Chrome has several other things that it can emulate for you in the Emulation panel. Hit Escape to bring it up. Why don't you go check out a few sites with different emulated devices and see how they behave? And, don't forget to check out some of the other things that you can emulate while you're there. Let's emulate a custom device. It should have the following characteristics, a width of 412 pixels, a height of 603 pixels, a device pixel ratio of 3.5, and then the user agent string should be this. You'll find a copy of it in the instructor notes. When you open the URL in the instructor notes, you'll see a website that looks a little something like this. Pop open Dev tools, and then go ahead and start Emulation mode. When you've successfully emulated the device, you'll see a code appear somewhere on this website. Type your code into this box to continue. To start the new width goes here. The new height goes right here. And I type the device pixel ratio in right here. For the user agent string I simply pasted into the box right here. And then I got this message that I needed to reload. And ta da, I've got my view port set correctly Testing on real devices is important, so be sure to do that whenever you can. In the following videos, Peter Lubbers will explain how to set up remote debugging in Chrome for Android. If you already know how to remotely debug, skip ahead to the video called Lesson One Summary. The set up is simple. All you need is an Android device, a USB cable, and your development machine. Let's take a look. Before you get started you need to turn on the Developer Mode in your Android device. This may be different on any given device and you can check your device's manual on how to do this. In many cases though, you need to go to your device's settings, click on About Device and then click on Build Number seven times. Seriously. Next you'll want to turn on USB debugging Again, this varies slightly on your given device, but this is usually located in the developer options. We also need to make sure we have the right tools [UNKNOWN]. On my laptop, I have Chrome Canary and on my mobile device, I have Chrome Beta installed. Now that we have everything set up the way we need, open Chrome on your development machine and go to Chrome inspect. Make sure the site you want to debug is open on your mobile device and then connect your laptop to your mobile device via USB. Then confirm that you want to allow USB debugging. Back in our development machine, we can see a list of the attached devices and the Chrome tabs that are open on the devices. You can even open other tabs. We can also focus on specific tabs, you can reload them And you can even close a tab. The best part of course is that you can inspect the pages that are running on your mobile device, from your development machine let's take a look. One of my favorite new features is the new screen cast mode. This allows you to drive the experience on your mobile device from your development machine. You can click on links, and see them update simultaneously on the device. As well as on your desktop. As you can see, you have all the familiar features from the development tools available for mobile now. Now, that was really easy and it's also possible to do this on mobile Safari with the web inspector using the iOS web kit debug proxy. Now, that's a little bit harder to set up, so check out the link below for more information. Great job! You are ready to go. In this lesson, you have learned about responsive design, why it's so important, and you've got the tools to get started developing. And in the next lesson, you will break down the basic components of responsive design, like the view port, element sizes and tap targets. At the end of the lesson, we'll have a chance to apply what you've learned as you work on the home site. See you next lesson In this lesson, you'll learn how to optimize your pages for different screen sizes, including the difference between CSS and device-independent pixels, and how to choose the right sizes for your elements. And at the end of the lesson, you'll build the mobile version of the hometown site. Now, when I'm working on my sites, sometimes I notice that content seems to flow off the page or I have to pinch and zoom to see anything. What's going on here? Well besides your CSS which could use a little bit of work, the biggest problem is that you don't have the viewport set properly. The viewport defines the area of the screen that the browser can render content to. Here, let me show you an example. In my laptop, I've sized the browser window to 800 pixels wide, which makes my view port 800 pixels. If I expand the width, the view port size changes, and now I have a view port width of 1000 pixels. All right, well that seems simple enough. But not all displays have the same pixel density right. Right. Like what about something like your Chromebook pixel display. Right. Well the Chromebook pixel display, tells me that it's got a width of 2,560 pixels by 1,700 pixels. But when I make the browser window the full width. And ask for the view port width. It tells me its only 1280 pixels wide. Wait. Not the full 2560. Nope. Not at all. Hm. Well not all pixels were created equal. Were they? Exactly. A pixel isn't always a pixel. Instead of reporting the width in the number of physical hardware pixels, the browser reports the width in the number of DIPs, or device independent pixels. As its name implies, a device independent pixel is a unit of measurement, that actually relates pixels to a real distance. The idea being that a device independent pixel will take up the same amount of space on a display regardless of the pixel density of the display. So if there are twice as many hardware pixels across as there are pixels reported by the browser, the chromebook pixel must have a device pixel ratio of two. Right. The browser has a view port width of 1280 dips. The 1280 dips get scaled up to 2560 hardware pixels. When the page is rendered on the display. Back to my un-optimized website. What's the browser doing, when the viewport isn't set? Unless you tell the browser that your site was designed to work on a small screen it assumes that they weren't. And renders the page, as if it were on a screen that were 980 DIPs wide. Now, imagine that content being scaled to fit on a phone that's only 360 DIPs wide. It gets scaled to less than half. Yuck. It then tries to make the content look better, by doing something called font boosting. The browser tries to pick the primary content on the page and scale it up. Oh, wait a second. So now the browsers actually trying to guess at what content is important? Sounds like a problem. Yep. That means that some fonts are large and easy to read. While others remain small, and are really hard to read. Users will have to spend a lot of time pinching to zoom in order, to see and interact with the content. That is not ideal. Nope. The different pixel measurements in web development, are actually pretty tricky. So we're going to go through a series of quizzes to help you understand the differences between them a little bit better. For this quiz, there's a mobile screen with a resolution of 1920 by 1080 pixels. What kind of pixels are these tech specs referring to? Are they device independent pixels, hardware pixels, or CSS pixels? And the correct answer is hardware pixels. This mobile device has 1920 pixels going across horizontally in landscape mode, and 1080 pixels going vertically in landscape mode. And these are the actual physical pixels on the device. Here are a few diagrams representing the difference between hardware pixels and dips. The blue grid represents a grid of hardware pixels. So, one pixel, two, three, four, five, six, et cetera. And then, the single orange square represents a single dip. So in this diagram, a dip takes up this much space, of the hardware pixels, in this case it takes this much. In this case it takes up this much of the hardware pixels, in here it only takes up one hardware pixel. So which of these diagrams represents a device pixel ratio of two. Remember, the device pixel ratio compares the number of pixels in just one dimension, not two. So think one dimension. Starting with the first diagram. We can see that for every one hardware pixel across, we have one dip across. So, that's not the right answer. Here, for every three hardware pixels across, we have one dip across, which would make a device pixel ratio of three. And that's incorrect. Over on this one. Looking across, we've got about one and two-thirds hardware pixels for every dip, so that's not going to give us the right ratio either. Which means of course in the last one, where we have two hardware pixels across, for every one dip across, that gives us a device pixel ratio of two. Given two screens of identical resolution, like the two you see here, why would text look different on the different screens? In this case, we can see that the resolutions are identical, and we also know that they have the same source, so the HTML and CSS are also identical. Is it because CSS styles aren't rendered predictably? Is it because the device pixel ratio differs between the two devices? Is it because the meta tag's initial-scale property on the content attribute is causing inconsistent zooming, on different devices? Or is it because the viewport was never set? Check all that apply. For the first one, no. While CSS can act a little strangely sometimes, the situation you see here is not one that would be caused by quirks in the way different browsers handle CSS. For the second one, yes. Different device pixel ratios can definitely change the size of content on the page, if you don't handle it correctly. For the third one, nope. Initial scale isn't going to cause the inconsistent zooming that you see here. And for the fourth one, yeah. This could be a reason. Without defining the viewport, you're leaving it up to the browser to determine the viewport size, which could cause a disparity that you see here. Given a screen of 1920 by 1080 pixels, and a device pixel ratio of two. What is the maximum width of the viewport in landscape mode measured in CSS pixels? Type your answer in here Okay, it's time to do a little bit of math. To start off with, we know we have 1920 hardware pixels across, and the device pixel ratio of two tells us that for every one CSS pixel, there are two hardware pixels. Multiplying 1920 by one half gives us 960 CSS pixels, so the correct answer here is 960. I want you to calculate how wide the viewport is for the four devices you see here. And remember, the viewport width is generally calculated by dividing the number of physical pixels, by the device pixel ratio. Type your boxes into the answers here. To start with, the viewport on the Phone is about 320 pixels, which is 640 divided by 2. For the Phablet, or the Phone tablet, anything around about 300 is going to be accepted. Sometimes device manufacturers fudge the numbers just a little bit, which is going to give you fractions. So, anything around 300's fine. The Tablet's pretty easy. It's device pixel ratio is 1, which means that it's viewport is the same size as its width. So 1024 pixels. And same thing for the Laptop. With a device pixel ratio of 1 and and a browser width of 800 pixels, you'll get a viewport width of 800 pixels. Notice on the Laptop that the whole screen is larger than the browser. But the viewport is only about the browsers width, not the whole screen, so it's just 800 pixels. By adding the meta viewport tag to the head element of the page we tell the browser that we know what we're doing. We need to use the meta viewport value with =device-width, which instructs the page to match the screen's width in device independent pixels. This allows the page to reflow content to match the screen sizes, whether rendered on a small mobile device or on the laptop. Adding the attribute initial-scale=1 instructs the browsers to establish a one to one relationship between device independent pixels and CSS pixels. CSS pixels are what we're used to working with most of the time, and really the only one I need to worry about. Without initial-scale=1 some browsers will keep the page width constant when rotating to landscape mode. They also scale the content rather than allowing it to reflow. Do you remember my personal site from the beginning of the first lesson? Well, it looks like there are some issues with it. When I opened it up to test on mobile, in this case, a Nexus 5. It looks awful. See how I have to scroll back and forth to see the whole page? The page defaulted to desktop resolutions, which does not look so awesome on this mobile viewport. For this quiz, open up this site with mobile dev tools. Add a viewport, so that it doesn't look totally awful. You will know you've done it correctly when the page actually fits, when you try to emulate a mobile device. Additionally, when you've set the viewport correctly, a code will be displayed, type it in below to continue. All right, I've got my personal side open, and it still looks awful. I'll go into dev tools and then edit the head by right clicking on it and then doing Edit as HTML. I set the name to viewport for the meta tag and then I set the content to equal to width equals device-width and then set the initial-scale to 1.0. When I click off it. Ta-da. Look at that. It looks right. Now, my site actually fits the view port available to it. So what's the take away from this quiz? Don't forget to set the viewport. So Pete, I'm going to talk element widths for a second. I've heard that relative widths are better suited for responsive design. Why is that? Sure. Let's take a look at this website for a second. It's got a beautiful, panoramic image that's 1200 pixels wide. On this laptop screen where the viewport width is 1280 pixels. No problem, the image fits just fine. Right. But now, what happens if you shrink the browser to a size that's below the image's native width? Yeah! If I'm not careful, instead of shrinking and re-scaling the image, the image will keep its original dimensions. Users will need to stroll left and right to see the whole image. Oh. That's ugly and annoying. Yeah. It's not a good experience. On the Nexus 7, about a third of the image is going to get cut off, but on something like an iPhone 5, the users going to see less than half the image. They're going to have to scroll left and right to see the whole thing. Since CSS pixels vary so widely across all these different devices, you shouldn't count on a specific viewport width for your content to render well. Large CSS widths or even absolute positions can result in elements that are either too big or don't fit on the screen at all. This is why you should use relative positions instead of absolute positions such as width 100%. Earlier, I mentioned it's important to make sure that the content fits within the viewport to prevent horizontal scrolling. You should use relative units when specifying widths for elements to prevent them from accidentally overflowing the viewport. Keep in mind, CSS does allow content to overflow it's container. So if you don't specify a side and, say, for example the image is bigger than the container, it will overflow. You can save yourself some headache, and prevent this from happening by setting a max width of 100%. In fact, I recommend adding a catch all in your main CSS for image, embed, object and video elements, that sets this, just to be safe Let's take a look at a few code snippets. And I want you to tell me if you think they're responsive or not. Which of these elements, will work well within a responsive layout? In other words which of these elements could look great on any device? If you're not sure about a code snippet. Open it up in a browser and see what happens. Make sure you test on several different devices. When you're done, check the check boxes for the ones that you think are responsive It's a little bit tricky, because the width is defined at 640 pixels. But the max-width is set to 100%. The max-width actually overrides the width, which means that the owl image will be kept contained within its container, so this one is responsive. Looking at the logo, we see its width is 125 pixels. This is actually fine, because 125 pixels is pretty much smaller than any device, so this one will actually work well and be responsive. This one is actually a little dangerous. Even though the width isn't really that large, the viewport width on some of the smaller devices can be as low as 320 pixels, which means that a box with a width of 350 pixels could cause some horizontal scrolling. So this one isn't responsive. And finally, with the city div, we see its width is 100%, which means it's always relative and will be responsive. Argh, stupid small phone, stupid small buttons, stupid big fingers. Pete, why are developers trying to torture me? Well, they're not really trying to torture you. Well, it really seems like it when the buttons are so small that they barely take up a pixel on the screen. Yeah, it's true. Tap targets or anything that a user might touch tap ,click or try and do input on, need to big enough and easy to hit. And spaced so that you're not going to accidentally hit two at the same time. With a mouse users can be perfectly accurate. Our fingers on the other hand and sorry about that pun, it was bad. But our fingers are about ten millimeters wide, or half an inch, which works out to be about 40 CSS pixels. Oh, okay. So buttons should be at least 40 by 40 pixels. Well, instead of doing 40 by 40, you should make them 48 pixels wide by 48 pixels tall. That makes sure that there's enough room between the elements, for those of us who have fat fingers and fat thumbs. Yeah. It's okay to make some tap targets a little bit smaller. But make sure there's at least 40 pixels of room between any of your top targets, to make sure that users don't hit two buttons or two elements at the same time or miss it completely. Now, it's your turn. What CSS styles would you include to make sure that your buttons are easy to hit? Type your answer in the box here. Tap targets should be bigger than the average finger. So, to ensure that all of your elements are at least that size, add min width 48 pixels, and min height 48 pixels, to every tappable element. Simply using width and height, alone can be a little dangerous, because it won't allow the element to resize if the content inside of it is bigger than the container. Designing a responsive site, uses the same concepts and processes that you go through for a non responsive site. Except instead of drawing a single wide design, there are a few more to accommodate different screen sizes. I like to start my design with the smallest form factor, usually a phone. Once that one's complete, I move up to the next. And as each design is completed, I ask my self is there a need for a design for a wider screen? At some point, there's really no need for a bigger design. By starting small I really have to prioritize what's important for my users. What's the most important thing that they want to do, or that they're going to see on screen? When starting big and then designing down. It can be too easy to just cut or hide content that may be important. Instead, by prioritizing content and working up, the key content is always on the page and users get the full experience, no matter what device they're using. The design for one hardware store prioritizes information about the nearest store, it's address, hours, and phone number and puts those right at the top so I can find them easily. Beyond designing from small to large, I also code from small to large. This way, I know that my course styles, and layout will work for any device, even on legacy browsers that don't support media queries. But probably my favorite reason to start from small and work up is performance. By designing for the smallest view port first, I'm forced to think about performance from the beginning. I have to make a conscious decision about prioritizing content, and how much data I'm sending to the user. Let's put your newfound knowledge to the test. For this question I want you to make some updates to the Hometown Project. If you need the starter files, check out the instructor notes for instructions on downloading that. Here we can see what it looks like right now. We've got two columns, text and images, and we've got the weather and sports scores. When we resize the page, it's pretty clear that the content is no longer fitting the browser. Let's go ahead and make it responsive. First, add a meta view port to the page, and don't forget to set the initial scale. Then I want you to make any adjustments to the CSS in markup, so that everything displays in a single column. Be sure to use relative widths, so that things stretch to fit across any viewport width. And then finally, check your touch targets and make sure that they're big enough. Once you've made your changes, test your site across different viewports. Try it on phones, tablets, and different desktops. And when you're done, here's what it should look like. Notice, to start off with, everything's in one column. And when I resize the page, the content reflows to fit the new viewport. And of course, my buttons are nice and big and easy to press. All right. So this is going to be the 30 second version. If you want more detail, check out the next video where I'll be spending seven or eight minutes really diving into how I use dev tools to make changes. The meta tag looks like this, copy and paste this line into the head of your HTML and you are good to go. In order to make everything display in a single column, I needed to make it take up the full viewport. The basic idea is that I ran through the CSS looking for any containers with fixed widths set smaller than 100%. Then, I simply made them 100%. Using a relative width of 100% means that an element is going to take up as much space as it can, which means that if you've got a container it'll take up the viewport. Tab targets that's easy just add some padding to all of your a tags I used 1.5em and after that I tested, and here it is on mobile and here it is when the screen gets wider, notice that everything is taking up the full viewport. Now if you want the full story of how this happened watch the next video. Okay, it's time to improve our home town app. I'll go ahead and start with the meta tag for the viewport. On the left, I've got the code that you started with, and on the right, I've got my modifications. I added the meta tag with the name viewport, and then I set the content to width equals device width and the initial scale equals 1. Okay, well, that wasn't too hard. Let's see what's next. Now I need to make some adjustments to my CSS and markup so that everything fits in a single column. I'll be sure to use relative widths. To do so I'm going to open up a page in DevTools and make my changes there. Here's the page in its original state. And now, I've got DevTools open. One of the cool features of DevTools is that when I hover over elements in the Elements pane, I can also see them selected on the page. That's pretty helpful. When I'm hovering over the header here, I can see that the header takes up the entire width of the viewport. So that seems pretty responsive, but I want to check out what's inside it. hah. Inside it I see this header inner element. And that's not taking up the entire viewport like we want it. I think I might need to make a change. On the right hand side I can see header inner CSS, and it's width is set to a fixed 800 pixels. That's not right. I double click to change it. And we'll change it to 100%. Great. Now, when I hover over it, I see that the header inner is the entire width of the viewport. So far, so good. Coming down on the page, we come up to the nav. And when it's selected, it's pretty clear that it's not the whole viewport width. On the right side, we can see its CSS. And the width is set to a fixed 800 pixels. Just like before, I'll set its width to 100%. And now when I select it, it looks pretty clear that the nav is now taking up the full viewport width. The header and the nav are looking good, I'll come down to main, and once again we can see that main is set to a fixed width of 800 pixels, now with a width of 100%, I can see that the main is taking up the entire width of the viewport. Nice, and side main content looks good, it looks like it's taking up the full viewport but I want to take a look inside too. And now I see the different sections on the page and there's the hero. Now the hero seems to be of a fixed width. There's a lot of space on the side it could take up, but it's not. So I want to make a change. Its width is set to a fixed 480 pixels. And when I change it to 100%, we see it take up the full viewport, just like we wanted. Looking down in the dom I see the top news section, so I'll click on that. And once again it's obvious that the fixed width should be 100%, or some other percentage, and not this fixed width. Okay? And now the top news takes up the entire width of the viewport. That's good. I have to scroll down a little bit and then I see sports. And the scores aren't taking up the full viewport. If I click on it, I can see pretty clearly why right here. So once again, 100%. And now the scores take up the full viewport, not too bad. This says push the poor weather section down really low and we've got all this open space to work with. So I want to make sure it takes it up. The width right now is fixed at 320 pixels. I can change that to 100%, and now the weather takes up the full viewport. Very nice. And lastly, the recent new section is already taking up the full view port so, hey, not too bad. Don't have to do anything there. Step 1 and Step 2 are done. For Step 3, I want to make sure my touch targets are easy to hit. This means that I want my A tags to be at least 48 by 48 pixels. A tags, remember, are going to be the touch targets, because the As are the links. To do so, I went through the CSS. On the left there's what I started with, and on the right there's what I ended up with, and I went ahead and added a padding to the a tag inside the nav class. I set the padding to 1.5em. Which means that the padding is equivalent to 1.5 times the font size of the a tag. If I open up DevTools and check out what I've done, I can see that the a tag here has a nice box around it and its width is 69 pixels and its height is 54, which means that it's bigger than the 48 by 48 oh, should be 4, that works for me. Farther down in the page, I see the top news item with an A tag and I went ahead and set it's padding to 1.5em as well. Then I added the second one, inherit here, that's going to be the left and the right padding. And it's inheriting the padding from the item that is its container. With DevTools open it's pretty clear the touch target there is great. Good. Let's move on. There's another A tag inside the snippet title class. So once again we'll set its padding to 1.5em. And then of course one last time at the bottom of the page there's an a tag in the footer so, one more change to the padding. Let's take a look at the page in its full glory. The page looks really good on mobile. I can scroll up and down and see that all of the content fits the viewport width we've got here. Of course, if the page gets a lot wider, then things start to get a little ridiculous, but that's okay. Now just to be clear, when you start comparing your CSS to our CSS, you might actually see some differences between them. And that's okay, there is more than one way to solve this problem. And in fact, the CSS that I ended up with in my main .css file, is actually slightly different than the changes I made inside DevTools. DevTools are a great place to start, but of course in the end, you need to make your changes to code. And I well, made a few changes. Congratulations on building the mobile version of the site. You've started to apply the basic concepts of responsive design. In the next lesson, you'll learn the key techniques that you'll need including media queries and break points, in order to build a site that responds to different screen sizes. Yeah, sounds great. We'll see you then. So, so far, you've learned that thinking responsively, means thinking about the user experience for every device. >From the small screen, all the way up to the largest. And inputs too. Buttons need to be big. But responsive design, goes beyond optimizing single elements. Now in lesson three and four, you'll be taking a step back to design page layout. Which means you'll need to think about, what information you're presenting to your user, and how you want elements to be arranged on the page. Picking the right design pattern can be more of an art than a science, so you'll have a chance to try a few different design patterns, as this lesson progresses. And by the end of the next lesson, lesson four, you'll take what you've learned about responsive design patterns to layout the project in a way that looks great. No matter how users find your site. A responsive website, changes based on the characteristics of the device. This means, that your responsive site, needs to apply different styles, for different devices. There are few ways to selectively apply CSS. The easiest, is with media queries. Media queries, provide easy logic for applying different styles depending on device characteristics. Like its width, height, or device pixel ratio. You can change everything, from background images to restructuring the site's layout and even more. Adding responsive styles is easy. Simply include an additional style sheet in your page, with a media query. Let me show you how to write one. Let's add a new style sheet and a media query that applies only when the view port is wider than 500 pixels. I'll add a new linked CSS file with a media attribute, and I'll set the value to screen and min-width 500 pixels so that it's only applied when the screen is over 500 pixels. You may see references to other media types, but ignore them. Media types like handheld, projected, or embossed never really gained any traction and don't do anything. Just stick with screen and print if you think your users are going to want to print your page. I'll take a look at the style sheet that gets applied and see that it changes the background color to blue. All right. I'll reload the page in the browser. Notice that the background remains white, but as I start to resize it, once it hits that 500 pixel break point, the screen turns blue because the media query's been matched. In addition to using the media attribute on a linked style sheet, there are two other ways you can apply media queries. You can embed them with an @media tag, or you can embed them with an @import tag. For performance reasons, you definitely want to avoid @import. It's pretty expensive and perf matters. You'll need to weigh the costs between linked CSS and @media. With linked CSS, you've got many small files, but many HTTP requests, where as with @media, you've got fewer requests, but the files tend to be a little bit bigger. Any filter that meets the criteria of the resulting CSS block, will be applied using the standard CSS rules of precedence. That means when the viewport is less than 500 pixels, no styles are applied but above 500 pixels my body color becomes orange. And above 800 pixels, not only do I have the orange text, but I also have the blue background. I'm pretty sure that also means, I've got some pretty bad taste in colors. The media queries used most often for responsive web design are, min-width, and max-width. Max-width rules are applied any time the viewport width, is less than the value specified. For example, max-width 500 pixels is matched when the viewport is 500 pixels or less. It's also possible to create queries based on min device width, or max device width, but this is strongly discouraged. The difference is subtle, but very important. Min width, is based on the size of the browser window. Where as min device width, is based on the size of the screen. In addition using device width, can prevent content from adapting on desktops or other desktops that allow the windows to be resized. Because the query is based on the actual device size, not the browser window. The other reason some browsers, [COUGH], the Legacy Android browser, may report the wrong value. Now it's your turn to write some media queries. You'll be using dev tools to make some changes to this page. Inside the elements pane, open up the head. There, you'll find a style tag, and inside the style tag, you've got some breakpoints set up for you. And it's here within the style tag, that I want you to make your changes. Simply right click and do edit as HTML. And you'll be able to change it. Apply style, so that between zero and 400 pixels, the background color changes to red. And then between 401 and 599 pixels, the background should be green. And if the page is 600 pixels or wider, make the background blue. When you've set the right break points, you'll see a code on the screen. Type it in here to continue. And by the way, you might find it's easier to actually write your code in a regular code editor like Sublime Text and then paste it in here This is what I put in. I needed a max-width media query that would set the background-color to red when the screen was no larger than 400 pixels. Then, I needed another media query that set the background-color to blue when the screen was no smaller than 600 pixels. And then finally, I needed to set the background-color to green for screens between these two break points. I went ahead and did it by setting the background-color to green before these two media queries. This way, the CSS cascade kicks in, and it's only applied, this color here, when these two break points are not. Of course, I easily could have put background-color green into a media query, but well, I didn't need to. And there it is, blue, green, and red. That wasn't too difficult. I think it's time to move past simple cosmetic changes to the site. So far, you've used media queries to change simple things, like background color and what not, but you can also you use media queries to change the entire layout of the page. In fact, this is how developers accomplish responsive design. By using media queries like minwidth and maxwidth, developers can change the entire layout of the page. Right, the point at which the page changes layout, is called a break point. And depending on how your site is laid out, you might have one or several break points. You know what, let's take a look at a few examples of pages using breakpoints. Afterwards, I'll show you a few more pages, and you tell me, how many breakpoints they've used. Here's a simple site, Skinny Ties. I've opened up Dev Tools in another window, so when I resize this, you'll see the resolution show up right here. And like any responsible, responsive designer, I'm starting with a small mobile design. This one looks pretty clean. I'll start expanding and at 480 pixels, I hit the first break point. There are now two columns, there are bow ties and pocket squares next to each other, okay and at larger than 690 pixels, there are three columns, nice. Once the view port is larger than 915 pixels, all of the fonts get bigger, which is a pretty nice touch. I also noticed a few other small changes as the page was getting larger. After you watch this video, maybe you can check out Skinny Ties, and try to find them. I also took a look at CNN.com's new layout. This one is a bit more complicated. Once again, I am starting small. Notice the hamburger icon in the top right-hand corner. Clicking on it makes the nav bar show up. That's pretty nice. Also notice that there are social media icons underneath this main story. I've expanded the page larger than 725 pixels across, and now these social media icons are gone, unless you hover over. This would be use something that would be called a minor breakpoint. Which isn't a huge page layout change, but there's still something slightly different. I've expanded the page past 800 pixels wide, and I see that the hamburger icon is gone. There's more room at the top of the page, so as a result, the navigation menu options are just showing up here. Larger than 935 pixels, the layout really changes. With the extra screen real estate, a few sentences about the main story show up over here, and all of this description is now on the right. Notice the social media icons, are once again showing by default. Larger than the classic 960 pixel width. The new screen real estate is being taken up by other top stories for today. And I found one more small break point. Larger than 1024 pixels, an ad shows up. All in all, not a bad design. So now, it's time for you to think about break points. For this quiz, I'm going to show you two websites. And I want you, to tell me, how many break points each website has. First off, there's medium.com. Pay attention to this example. I'll start small, and then slowly resize the page. Watch the way the content changes. Okay? And this is the sample site I want you to check out. Notice how this content changes, when I resize the browser. You can find a link to this page, in the instructor notes Let's start with Medium. As the page gets larger, we can see that the text reflows. That's good, but that's not a breakpoint. But, once the viewport is wide enough, we see that the images got larger and, so did the text. That's a breakpoint. Once the viewport is this wide, we can see that there's now a margin on this side of the page. That is another break point, so in the medium.com example I noticed two break points in the men with max width example we start off and the page says no, then it gets a little bit larger and the page says yes, but if we get to big it goes back to no. So, this means that the course example also has two break points. The million dollar question that, every developer has to ask themselves is, where do I put my breakpoints? Defining breakpoints based on specific devices, products, brand names or anything else, will almost always result in a maintenance nightmare. You never know what next hot device will be or what will be hot two years from now. Instead, look at the content to find the right breakpoints. Scott Yale said it best. We shouldn't choose break points at all. Instead, we should find them, using our content as a guide. Pete, I would love to get some insight, into the choices that you make when you're trying to decide, what breakpoints to use on a page. Sure. Let's take a look. I'm going to walk you through my thought process on how I built this responsive weather forecast page. Typically, when I'm trying to pick my breakpoints, I'll start in my desktop browser with my viewport set as small as I can get it. I also like to have the Chrome DevTools open because it shows me the screen width in the upper right-hand corner as I resize the window. Next, I'll slowly start resizing the window, looking to see when the content tells me that it wants a breakpoint. And probably somewhere here, at about the 550 pixel mark, looks like a good place. Anything wider and the spaces between these columns are going to become too big. In my code, I've already got my viewport set and a default set of styles that are applied for any viewport width. I'll add weather-medium.css to the head with a media query that checks for a screen and if the viewport width is greater than 550 pixels. Great. I'll switch back to the browser, hit Refresh, and start to resize. Perfect. At 550 pixels, things look exactly like I expect. Because that breakpoint was only at 550 pixels, I think I probably want to add another one. Otherwise, we'll run into the same problem with too much space between columns. I easily have a room for another one since most desktops and laptops are significantly wider than 550 pixels. I'll go through the same process, and I'll continue to expand the viewport until it looks like I need another breakpoint. Again, I'm looking for a place where the content tells me that it wants a breakpoint. 700 pixels looks to be right about the right place. So, I'm going to go ahead and add one here. Again, I'll add a new style sheet, but this time, point it at weather-large.css. It'll check for screen and check to see if the viewport width is at least 700 pixels. A quick refresh in the browser and resize. And we've got it. Things are looking good. I could keep adding breakpoints, but in this case, I think having two breakpoints is enough, essentially one at a small viewport, one at a medium viewport, and one at a large viewport. Okay, that's enough of me talking. Now it's your turn to give it a try. For this quiz, I want you to take a look at the hometown hero image and the navigation links, NEWS, EVENTS, CULTURE, and BLOG. Start with a small viewport and resize the page to make it larger. Pay attention to the size of the hero image, and the spacing between the nav links. As you play with it I want you to ask yourself, where would you add a breakpoint? Type your answer in here and just to be clear, there's not just one right answer, this is as much of an art as it is a science. Oh, and here's a hint, if you open up DEV Tools and resize the page, you'll notice that the resolution is displayed in the top right-hand corner. That'll help you find out where you want to put your breakpoint. So, I started small with theft tools open, so I'd get the resolution, and I pulled the page out. All right, that's about 680 pixels, and I think this still looks good, so let's make it a little bit larger. Here I am at about 815 pixels. Still, I think that looks good. I think I can go larger. Okay, now I'm at 1130. Okay, this is definitely way too large for here. Let's pull it back in a little bit. Around 850 pixels or so, I think I'm about at my limit for how wide, I want this image to be, and for how far apart I want these elements to be. So, for my answer I put 850 pixels, but really like I said this is an art not a science. So if you didn't get the same answer as me that's totally fine. This isn't the right answer but, you know, it's what I think. So far, I've used only simple media queries, testing only one characteristic, but in some cases, I need more complex tests. This media query, only applies styles when the screen width, is greater than 500 pixels. And the screen width, has to also be less than 600 pixels. If we look at this altogether, our media query is only applied between 500 and 600 pixels. Are you ready to give it a try? What are the set of media queries, you need to apply in order to apply styles from these classes? Use this diagram as a guide. Class AA applies from 0 to 400 pixels. Class BB applies from 301 pixels to 600. CC applies for any browser with a width, greater than 601 pixels. And DD applies for any browser with a width greater than 961 pixels. You'll need to write four media queries. One for class AA, one for class BB, CC, and DD. In order for a class to display, set it to display block. And when you type out your answers. Don't worry about new lines, just make your media queries one long line so they fit in the box. I'll go ahead and start you off with @media for each of the media queries. And then at the end of it I went ahead and drew these curly braces. If these were real media queries, this is where the styles would go. Finish them up and good luck. This was a tough one. Media queries can get complex. Especially when they start overlapping like what we've got here. But, let's go ahead and set through each part step by step. AA applies from zero to 300 and also from 300 to 400. Which makes its max width, 400 pixels. BB starts at 301 pixels, so we set its min-width to 301, and it goes all the way to 600 pixels, so we call that max-width, 600 pixels. CC starts at 601 pixels, so we say it has a min-width of 601 pixels. And it doesn't have an end, so there is no max width. DD seems to be the same as CC, except it starts at 961 pixels. That wasn't too bad. So Pete, I love the way breakpoints and media queries are giving us control over our CSS styles. You know, you've had a lot of experience in the past building responsive sites. What patterns or general strategies have you found to be the most useful? You're right. There are several great patterns out there. But I'll start with probably the most simple and one of the most important ones. The grid fluid system, with the grid fluid system columns end up wrapping to the next line as the browser width starts getting smaller. There's a lot of good examples out there that you can try like Bootstrap or the 960 pixel grid layout system, that are easy to use and have everything done for you already. Huh, well, that does sound like a pretty nice, flexible strategy. You know, I did a little searching, and I found that the HTML 5 Rocks page is an example of a site that uses a fluid grid. Notice how when I shrink the screen, the articles that are three columns across in this main section shift down to a single column. Also, if you're unfamiliar with grid-based layouts, or you think you'd have a hard time designing one of your own, in the Intro to HTML and CSS course we cover grid-based layouts. Check out the link in the instructor notes to learn more. Flexbox, is one of the most powerful tools that you can use for layout. It's changed a lot in the last couple years, but at this point, it's hit candidate recommendation and it's supported by most browsers. In this class, I'm just going to show you the current syntax. But, in your code and for anything you're building. For production, I want you to make sure that you're including all of the vendor prefixed version. So that way, if anybody's on an older browser, you're not leaving them out in the cold. The reason Flexbox is so powerful. Is its ability to fill the space available. If an element has extra room around it, it'll expand to fit or if it's getting crowded elements will shrink, so that they take up as little space as possible. Let me show you an example. Flex box makes it super easy to position elements left or right, without floats. You can also change the order of elements, without changing HTML, and flex box makes it really easy to accomplish a lot of other common layout techniques. Pete, how do you approach design with flex boxes? Well, let me show you. Cool. I'll just start with a simple page, that has three divs, contained within a container div. In normal block layout, each div is positioned, one underneath the other one. But once I add display flex to the container div, the divs, are now shown in a row. That's because the default flex direction, is row. By default, flex items fit on a single line. So no matter what I set the width of the elements to be, they won't wrap. Instead, the browser will size them to fit within the viewport. I can change that, by adding flex-wrap: wrap; to the container element. That tells the browser, that it's okay for the elements inside to wrap to the next line. Now, as I resize the viewport, instead of resizing elements, it wraps the first element. And then, only resizes when it really needs to. So far, we've only looked at two properties of the flex container. There are several others worth looking at. Another feature of Flexbox that I found to be really useful, is the ability to change the order of elements, using the CSS order attribute. For example, when the screen width is 400 pixels or below, the elements are shown in the order of their markup. Keep an eye on this dark blue div, and this red div, here. As the viewport changes size, the order of the elements starts to change. To set the order, I just need to add an order attribute to each element. This means your content, can be totally responsive. In some layouts, content appears in one order, but in other layouts it appears in a whole different order. I'm going to use Flexbox to create this layout, and then I'm going to give you a design mock that I want you to provide the styles for. I've got my markup for the HTML here. The first thing I need to do is set up Flexbox on my container element. I need to add display flex. And flex-wrap, wrap. Looking at my layout I can see that some things are out of order. For example this dark blue box, is not in the same place down here. And I want to make sure they are. Are. So in addition to setting the width of each element, I need to remember to set the order. To make things a bit easier for myself, I've added the styles in the order that the elements appear. The header element is the first element, and it spans the whole width. So I'll set the width to 100 and order to one. Red and orange are next. Each looks to be about 50% of the view point width. So I'll set width equals 50% and order to two and three respectively. In this design, the footer is next at 100% width, and order equals four. The next line is light blue, dark blue, and green. Light blue and green, each looks like they are about 20% wide. Dark blue looks like it's about 60% wide. So, I'll set order to five, six, and seven on each of those elements respectively. Let's compare this to our sample. Looks about right to me. Let's see how you do. Here's another challenge. The layout that you see here was created with Flexbox. For all of the elements of different colors that you see on the screen, type in the width and the order of the element that would be needed to create this layout. I'll give you the first one. The light green box and the top covers the entire span of the viewport, so its width is 100%. And this would be common for something like a navbar, and it comes first on the page. So I'll set its order to 0. Now you go ahead and fill out the rest All right, I'll just go in order. I'll start with the three boxes we see here. Each box takes up a third of the page. So I'll set their width to 33%, and the orders will go up sequentially. One, two, and three. On the next row down, the dark green. And the orange boxes are both taking up 50% of view port, so as their widths to 50% and their orders are four and five. And lastly there's another element that takes up the full width of the view ports this would be something probably like a footer on the page, and because it goes the whole view port width it has a width of 100%. And I set its order to six because it's last. You might have decided to give each element a different order number, and that's totally fine, so long as they're in the right sequential order. I could have just as easily picked increasing prime numbers, but that would've just been silly. So flexbox and flex grids seem like great general purpose strategies, for responsive design. But, there are more complex patterns for designing responsive layouts. Right. In the next lesson, you'll experiment with four different techniques for creating responsive layouts. Great. See you then. Responsive patterns are quickly evolving, but there are a handful of established patterns that work well, across pretty much any device. Most patterns used by responsive web pages can be categorized into one of four patterns, mostly fluid, column drop, layout shifter, and off canvas. In some cases, a page may use a combination of patterns. For example, column drop and off canvas. In each of these examples, and the examples moving forward, the colored boxes represent areas of content. Let's break them down one by one. I'm going to show you how these patterns work, and then using your Flexbox skills and media queries, you're going to practice implementing them. The first is column drop. Column drop is probably the easiest. At its narrowest viewport, each element simply stacks vertically, one on top of the other. As things get wider, the elements expand, until the first break point is hit. At the first break point, instead of having all the elements stacked, two elements are now side by side. And the third element is underneath. The elements keep expanding as the viewport gets wider until the next break point is hit. And then, things reflow to a three-column layout. Generally, once the viewport hits a maximum width, the columns hit a maximum size, and instead of getting wider, margins are added to the left and right. So how do we code this? Let's start with the smallest viewport. We have our three divs, inside of a container div. The container is a flex container, with flex-wrap, wrap. Next, I've set the width of all of the divs to 100% to give me that stacked layout. Because this is just a sample, I'll pick a totally random break point at 450 pixels. I want that dark blue div to be 25% of the viewport width, and the light blue div to be 75%. And I want to keep the green at the full width. I'm going to add a new media query that checks if min width is greater than or equal to 450 pixels, and then change the width of dark blue to 25 and light blue to 75%. I'll add a third break point at 550 pixels and make the dark blue div 25%, the light blue div 50%, and the green div to be 25%. To get that to happen, I'll add a new media query that tests for screen, and min-width 550 pixels. Inside that media query, I'll set the width for dark blue and green to 25% and light blue to 50%. Let's try it in the browser. We're all stacked at 400 pixels. At 450, our layout changes, and again at 550 pixels. Perfect. The mostly fluid pattern, is very similar to column drop, but it tends to be a bit more grid like. With more columns and columns fitting in different ways, depending on the viewport width. Just like column drop at its narrowest viewport, the layout is stacked but as the layout gets wider, the grid pattern starts to appear. And eventually, once the layout hits its widest viewport, margins are added on the left and right, instead of expanding things out. I've made this one a bit more complexed, with a few additional divs. Just like column drop, I'm using flexbox and setting the width of each element to 100% at their narrowest viewport. At the first breakpoint, I'll make the light blue div and the green div, 50% width. Just like before, I'll add a min-width query, to check for a min-width of 450 pixels. If that's the case, I'll make the light blue and green 50% width. I want another breakpoint at 550 pixels. I'll add the media query, and set the appropriate widths on the right elements. And finally a lot of breakpoint that adds margins to the side, when the viewport is beyond 700 pixels. Let's take a look at it in the browser. Everything is stacked as I expect at below 450 pixels. And as I expand up, I get a switch and 450. I'll get a switch again at 550 pixels. And above 700 pixels, I'll start getting margins added to the side. That's exactly what I wanted. For the next quizzes, we'll be analyzing this layout. Let's see how it looks, when it gets larger. Go ahead and pull this out, and there we go. We can see that we have a breakpoint. And this is our desktop layout. For this quiz and the next one, type in the widths of each element as percentages, into the boxes you see here. This wasn't too hard. The green box and the light blue box, both have widths of 50%, because they take up half the width of the container, but all the other boxes like the dark blue, the red, and the orange, all take up the full width of the container, so they're at 100% width. Now, let's move on to a larger layout. For this one, go ahead and type in the widths as percentages, into the boxes you see here. With a wider viewport, things are a little trickier, but still not too bad. Here, the green and the light blue boxes are 50%, but now we've got this red box which is taking up about a third or 33% of its container's width. And the orange box is taking up two thirds or 66% of it's container width, but what's going on when we resize our viewport from here to here? At the largest size, the container around all of the boxes, becomes fixed width, but the widths of the elements inside it don't change Are you ready to code mostly fluid layout? You've already seen this layout before, but you haven't had a chance to modify it's CSS yet. This quiz you'll be adding some CSS break points to some HTML, so that the page layouts match what you see here. Here let me show you what you'll be doing. In the head of the document you'll find two style tags. The first style tag just has default styles. And you don't need to change these. Here let me close them. The second style tag includes the responsive styles. And this is where you're going to put your breakpoints. My advice is to write the initial breakpoints in the source file, with classes that you might want to modify at that breakpoint. Then open the page in the browser, and toy with the styles using dev tools. If you got the styles set that you think look right, go ahead and change the source files. Also, try playing around with the order while you are messing around with the break points. It's actually pretty fun. Check this box once your layout matches the sites that you see here. Good luck! I'll start with the small layout. At min-width 450 pixels, the only real change from the default, is that the light blue and the green elements both take up 50% of the viewport. So, at min-width 450 pixels, I set width 50% for the light blue and the green elements. So far, so good. At min-width 550 pixels, it looks like the only difference is that now the red box only takes up 40% of view port, while the orange box, takes up 60% of the view port. So, I made my change, and well to be honest, this doesn't quite look like what I expected. I thought the red box would be probably a little bit farther over. So you know what, let's go ahead and change something. Inside Dev Tools, I'll change that 40%, which I was mistaken about. And I'll change that to 33%, which means that the width of the orange box needs to be 66.6%. I was a little bold there and instead of testing first, I just went ahead and set the widths inside my source code, but looking at this height, this isn't actually what I expected. I think the orange isn't taking up enough space, and I think the red is taking up too much space. So, I think I'll use devtools to make some adjustments. Instead of 40 60, I'll go ahead and make it one-third and two-thirds. So, red becomes 33.3%, and orange becomes 66.6%. All right, that's looking a lot better. And lastly, there's min-width, 800 pixels. The only difference between 550 and 800 pixels, is that with 800 pixels, there are now left and right margins. At the break point with the min-width of 800 pixels. I went ahead and set a fixed width of 800 pixels and then a margin left and margin right of auto. With a quick save and a refresh of the browser, it looks like the page now has margins on the left and right. Already, that looks pretty good. The layout shifter pattern is probably the most responsive pattern with multiple break points across several different screen widths, but the key to this layout is the way that content moves about instead of reflowing and dropping below other columns. Flex box really shines here, because we can use the order CSS attribute. Amazing. Because so much can change in each layout, it does require a bit more planning to maintain. I'll go for something a bit more complex this time. In order to get the layout I want, I've wrapped the light blue div, and the green div inside container two. I've made one small change to the container class from the last example. And I've set it's width to 100%, so that the element inside takes up the full width. When no break point has been hit, only the default styles are applied making each element 100% width. Stacked on top of the other. When the first media query is hit at 500 pixels, the break point changes the dark blue and the container, each to be width of 50%. The red div remains at 100%, because we haven't changed it. At 600 pixels things start to get really fun. To get everything to fit, I need to change the width on container2 to 50% and the width on dark blue and red to 25% each. Next, to change the order, I need to specify an order for each element. Remember, the default order value for an element is zero. If I set order to negative 1 on the red div it'll appear first. To get the dark blue element, to show up last, I need to set it's value to anything greater than zero, so one. Let's take a look in the browser. It's all stacked to start. But as it gets wider, and hits the first break point, the dark blue goes to the left with light blue and green on the right, until finally it switches up again. Nice! For this quiz, I've got some CSS on the screen with two break points and the two resulting layouts. I want you to tell me which div is which. For the red, green, and dark blue boxes, type in the IDs of the elements over here that match. Your options are box A, box B, and box C. I'll take a look at the smaller layout first. Box A takes up 50% of the viewport, and has an order of negative 1, which looks like it's the lowest meaning box A comes first, but probably means the Red Box is box A. Container 2 has a width of 50% and no order. So, I think it's probably a good guess that container 2 is talking about the light blue and the green divs. I can see that boxB must come after boxA, and because this doesn't have an order, it's probably order 0, so that means that boxB is going to be the Dark Blue Box. That probably means the Green Box is boxC. But, I want to take up the larger viewport to confirm my suspicions. I can see that boxC has an order of negative 1 in the larger viewport, which means that it looks like it's going to come first. That's a pretty good argument that the Green Box is boxC, but let’s just goes ahead and make sure. Box B has a width of 25%, and an order of 2. Which is the largest one I see here, so it's probably going to come last. Well that seems to make sense, because I said that the Dark Blue Box is boxB, and here boxB seems to be the last one. BoxA is 25% and comes right before boxB. Which makes it the red one. So, I'm feeling pretty good about my answer that the Red Box is boxA. And lastly, there's still this container class with a width of 50%. And it looks like it's still being applied to the light blue, and the green boxes. So, in the end, boxA is Red, boxC is Green, and boxB is Dark Blue. With off canvas, instead of stacking content vertically, the off canvas places less frequently used content, for example navigation or app menus, off screen, only showing them if the screen is large enough. On smaller screens, the off canvas content is typically shown when the user taps on the hamburger icon. Let's take a look and see how it's done on the web fundamentals site. In narrow viewport, the navigation menu is hidden, until I click the hamburger menu. In other cases, the off screen content may actually come in from off the screen. In this sample page, the content is coming in from the left. But in other cases, it could come in from the right. Let's take a look at the code for this example. I have two elements, the dark blue nav and the main content in light blue. In order to make sure the elements take up the full viewport width, I need to set the width on HTML, body and main to 100 %. Next, I'll set the styles for the off-canvas nav element. I'll set a specific width of 300 pixels, being careful to keep it reasonably sized so that it doesn't overflow the viewport. I'll use translate minus 300 pixels to move it off the screen. And add a transition of 0.3 seconds, so that it animates in nicely. When I want it to appear, I'll add an open class that resets the transform. Now, I'll add a break point at 600 pixels that repositions everything back to its normal spot. The media query at 600 pixels resets the transform. Adding flex grow 1 to the main element allows the element to grow and take up the full remaining width of the viewport. Let's give it a shot in the browser. When the viewport is small, the navigation panel is hidden until I hit the hamburger menu. But, on wider view port, it's shown by default. Nice So, you just learned how to make a hamburger menu, which is pretty darn cool. So I want you to think about what that means for your site layouts and transitions. I want you to pretend that you're developing a website, with an off canvas navigation menu. When the user clicks on the hamburger icon, a nav element should show up alongside some main content. On mobile viewports though, the nav isn't going to be visible, until the user actually makes that click. Take a look at the CSS here, which handles the nav menu's transition, from hidden to visible. This open class, is going to be applied on click, which means when the user clicks on the hamburger menu. This class will be applied. Which of the following four diagrams, accurately shows what's going on? In them, the gray box represents the viewpoint. The bluish, purplish box represents an odd menu. And of course, there's site content inside. So, pick the diagram, best represented by the CSS here. I'll start from the last diagram. It shows the nav coming in from the right, see how it's over here off the canvas? And then it comes in and covers the canvas on the right side. This one is wrong, because this property translate negative 300 pixels, means that the nav bar is starting 300 pixels to the left of the view port. So, this can't be right. In this example, it shows the nav bar showing up from, well, nowhere. It's not over here. This is wrong. According to the CSS over here, it clearly exists somewhere. In this example, the nav bar is starting off to the left of the viewport, but then when it comes in, it pushes the content off the viewport. This is wrong, because the position of the nav element is absolute. Which means that when it comes in it will actually just cover the existing content. All that is to say that this diagram accurately shows the way the navbar will show up on screen. And there you have it. This is a good way to visualize the way your navbar is sliding in on the screen. All right. It's time for you to start applying the layout skills you just learned. And here's what it looks like on desktop. Not that great. I think you can do a lot better. For this part in the project, pick a set of breakpoints that you think look good. And then, use one of the patterns that you just learned, to style the page, so it looks great, even on desktop and tablet. If you didn't finish the exercise from the last time you worked on the project. Don't worry. You can grab a working copy, linked in the instructor notes below. Make sure that you test on phones, tablets, and browser windows of all different sizes, so that you get a sense of what the page looks like everywhere. Adjust your breakpoints, until you get something that you're happy with. And remember what might work on one phone, might not work so well on others. And of course if you can make sure that you test on real devices as well, because sometimes you'll uncover unexpected behavior or design elements that well you just didn't expect, I'm going to show you what we came up with but this is by no means the right answer. This is just what we like and you could totally go in a different direction. And if you're happy with it, then that's great. But this is what we did. We've got a breakpoint here, and then another breakpoint there. The important part of this part of the project is that you try out different layout patterns, and find out what you like. Good luck. I'm going to show you what we came up with. But this isn't necessarily, the right answer. Remember, this an art, it's not a science. And either way, I'm not going to give you the whole answer. I'm leaving a few tweaks for you to make, and you'll be working on this site again, at the end of the next lesson. Looking at the new site, there are a number of major changes. Let's go ahead and start small. First off, the Nav buttons that were right here above the hero, have been shifted off-canvas, into the Hamburger button menu. The Hamburger button, is the one with the three horizontal lines. And now we've got our Nav-Links, over here on the side. This is a nice way of retrieving, a little bit of screen real estate. Also, the header text, is a little bit smaller to match this smaller viewport. The first breakpoint comes in a 550 pixels. See how the elements ref load and change their location on the screen. The weather is now here, in this second position, the hero is only taking up about 60% of the viewport width, while the weather has the other 40%. Also, the Nav button showed back up. To see how it's done, I've opened up Sublime Text. You can see some breakpoints, like this one using min-width 550 pixels and this one using min-width 700 pixels. And these breakpoints include changes to order and widths of different elements on the screen, like hero and weather. Great points like these, make it really easy to change the width and order of elements and totally change and shift the layout. The next great point comes in at 700 pixels across. The layout's changed a bit. Top news is moved up here. And we've got 50% on the Top news side, and 50% for the hero image. And the weather is now, down below. At even larger widths, eventually the main section of the page, keeps to a fixed width. This was accomplished with a breakpoint that set the width to 850 pixels, once the page's view port is as large or larger than 850 pixels. I've also the shifted the scores and the weather. The scores are taking up 60% of the screen and the weather's got 40%. The design that you see here, takes advantage of a mostly fluid design, with a little bit of layout shifting, I think the hometown site is actually looking pretty good right now, but it's definitely not perfect. Let's look at the weather real quick. On this view, the weather looks like so, with this cute little icon right here and then the actual temperature right next to it. But if you resize the screen just a little bit. The temperature drops down to the line below it and that's actually kind of gross. I don't like that. I also think that something better could be done with the hero image. Watch the edge of it as the screen resizes. See how the edge actually changes? That's because right now, CSS is being used to set and position the image. Background size cover, will scale up the image to make sure it covers the entire div. I think there could be a better solution. What do you think? In the next lesson, you'll get a chance to finish the site and make even more improvements. Your responsive design toolbox is really growing. In these last two lessons, you learned how to use grid layouts for responsive design, and you also learned the four common responsive design patterns. In the next lesson, you'll learn about some advanced techniques that you can use to really make a site shine. That's awesome. Let's do it. Sounds good. You've now got the most important skills that you need to build responsive websites, so congratulations. You've got a good understanding of what responsive means, you know how to use flex box to lay out your designs, and you've got several common design patterns. Absolutely, and I think you're ready to take your skills to the next level. In this lesson, you're going to learn about some of the other things that are important to responsive design, like images, tables, and typography. Each of these sections could be their own course and in fact, some of them are. That sounds great. Let's go ahead and get started. Sweet. A picture is worth 1,000 words and images play an integral part of every website. The HTTP archive has it pegged at near 1.2 megabytes per page, which means images take up 65% of every website. In order to do responsive web design, we need to consider images. If the rest of my page is changing based on device characteristics. Wouldn't it make sense that my images should be changing too? You're absolutely right, Cam. Using the same image, but changing the resolution is probably one of the most common use cases. Think providing a standard image for a laptop, but a 2X image for a high DPI display, like a Chromebook Pixel, or a Retina iMac. The best way to do this is using the source set attribute on an image tag. With source set, the browser will choose which file it wants, and then only download that one. Well that might work for logos and some other things, but what about the case where I want a different crop of an image? It doesn't make sense to show a big, wide image on a narrow portrait phone. Exactly, and that's what's called art direction, and where the new picture element come in. The picture element uses media queries to select which image to use, but responsive images could be a course of their own. Thankfully my good friend and fellow developer advocate Sam Dutton has you covered here. Hey, Sam. Thanks Pete, great stuff. When you're finished with this course, you'd like to find out more about responsive images, stuff like the picture element source set, come and check out our course on responsive images. Thanks, Sam. So Pete, it seems like we've covered all the usual elements for responsive design, what about tables? That's a great question. Let's take a look. Cool. Tables can be tricky. If they're more than a few columns, there's a pretty good chance that it's going to overflow the viewport on smaller screens, forcing horizontal scrolling. Yuck, To fix this, there's several options, and I'm going to show you three. Hidden columns, a technique called no more tables, and contained tables. Like break points, you want to experiment to decide what works best for your content, and remember, different content might call for different answers. Hidden columns essentially hides columns based on their importance as the viewports size gets smaller. Let's see how you might do this with a baseball scoreboard. As you can see all of the data is there. The short name, the long name and the runs scored during each of the innings plus the final score. I'm going to start small and ask myself what's the most important information. In this case, I'm going to go with the short team name and the final score. I'm going to use display none, to hide everything else. Then as the viewport size gets bigger, let's swap out the full team name and start showing each of the runs per inning. The biggest problem of hidden columns is that you're hiding content from the user. What happens if I need to know how many runs were scored in the 7th inning? If I'm a device with a narrow viewport, it's just not there, I can't see it. So use this technique with caution. And if possible, use abbreviated data instead of hiding it completely. For this quiz I've given you a simple HTML table on the right there's a media query, remember sometimes the best way to deal with a table column on mobile is just to simply get rid of it. So along those lines fill in the blanks in the media query, so that the game time class is hidden when viewports are 499 pixels wide or smaller. To start, I set max width to 499 pixels inside the media query. And then I simply apply display none. What's nice is that table columns like these, can be hidden like anything else with display none. With the no more tables technique, below a certain viewport width, the table is collapsed and resembles a long list, as opposed to a table data. The nice thing about this technique is all of the data is visible no matter what the size of the viewport is. Let's take a look with the baseball score again. In a wider viewport, everything looks good, but as the viewport shrinks, the table collapses. Every column has essentially become its own row with the table header beside it. Using a media query, I need to tell the table that below a certain width, in this case 500 pixels, I don't want it to act like a table anymore. Inside my media query, I'm going to force all table, thead, tbody, th, tr and td elements to render as display block. Next, I need to get rid of the table header. I could set display none, but that would cause accessibility problems for people using screen readers because the browser won't tell them the column headers. Instead, I'm just going to position the content way off screen. Since the table cells are now displayed as full width block elements, I need to add some left padding and also set the position on these elements to relative. To add the row labels, I'm going to use the before pseudo selector and add td before, and inside, I'll set the position to left: 6 pixels so that I get it positioned in the right place. Now I need to add the content. I could put the labels in my CSS, but that's icky and will mean that these styles will only work for this table. Instead, I'll use content: attr(data-th). That will then pull the values from the data-th of each of the td elements. Here, let me show you. And there you have it. That data-th is used as the label for each of the rows. One of the easiest things you can do, to contain the table in the view port. Is to wrap it in a div. And set the width to 100%. And overflow x to auto. Then, instead of breaking out of the view port. The table will instead, take up the same width. But will scroll within the view port. Let's try a little experiment. I want you to read the first paragraph of Alice's Adventure in Wonderland out loud. It's a little weird right? With only a few words per line, it's kind of awkward to read. Words or phrases that might be read as groups, end up getting broken across multiple lines. Making it hard to parse the sentences. Why don't you try this one instead. It's got a few more words per line, so maybe we won't have the same problem. It's the same content but with more words and it still doesn't work. If a line of text is too long, readers get lost when trying to find the next line and end up reading the same thing over and over again. Or they get lazy and might read the first part of each line, but by the end, they're skimming. Over the last century, there's been lots of research done to determine the ideal measure. That's the technical term for the length of a line. I've seen research ranging from 45 characters per line to as many as 90 characters per line, depending on the font used, if it's in print, if it's projected, or on a computer screen. But, there seems to be a pretty solid consensus around 65 characters per line for the web. It's not a hard and fast rule, but it's a good place to start. We need to consider the way people read as we create our designs, since it can affect our layout. That's why line length is an important factor to consider as you're building sites, and something I always take into consideration as I choose my breakpoints. It's also important to make sure that fonts are big enough to read across any device. I always set my base font to at least 16 pixels, and at least a 1.2em line height. Depending on the situation, I may even increase it for text heavy sites. 14 pixels is just too small. That may sound big, but makes for a much better reading experience. Even on a desktop, it works quite well. In addition to choosing major breakpoints, where layout changes significantly, it's also helpful to add minor breakpoints to make some small changes. For example, between major breakpoints, it may be helpful to adjust margins and paddings on an element. Or to increase the font size to make things, a little bit easier to read and feel more natural in the layout. In this case let's boost the font, when the viewport width is between 400 and 550 pixels, where our break point kicks in. I'll also separate the low and high temperature, so that they're not on the same line and make the weather icons bigger as well. Let's switch to the source and I'll add a media query that's applied, when the viewport is between 450 and 550 pixels. It ups the base font, changes the low and high temperature to be inline block, and increases the icon size. I'll save the file, and then take a look in the browser. Sure enough, my icons are now bigger, my fonts are now bigger, and everything looks like I expect it to. In this before and after, you can see how things have really changed. The icons are much bigger, the font sizes have also changed, and the minimum and maximum temperatures are now shown in a slightly different way. For larger view ports I want to limit the maximum width of the forecast page. Panel, so that it doesn't consume the entire view port as it gets wider. I already have a link style sheet with min-width query of 700 pixels. So in there, I just need to set some margins and padding. Let's take a look. I'll set the width to 700 pixels, and set margin left and margin right to auto. I'll come back to Chrome, hit Refresh, and now we've got what I want. There you have it. You can use minor break points, to adjust the little things and really make things shine. All right. Well, using all the skills that you've learned throughout this course, it's time to make some final tweaks to the home town site. To start off, I want you to update the sports score table. Go ahead and put your favorite sports teams in, and make sure it's responsive. I've also added another column into the sports score table just to make things a little bit more difficult. Next up, double check your text. Is there any text that's too long? If so, find a way to make it fit a little bit more naturally. This is also a great place to add some minor breakpoints. Add at least one, or I'm sure if you keep trying, you could find a lot more than just one to add. Lastly, try replacing a few of the images with responsive images. If you haven't completed the responsive images course, check out the responsive images section of Web Fundamentals using the link in the instructor notes. And when you're done, make sure you share your project in the forums. That's the best way to get feedback and make improvements. Here's what we came up with. Remember, this is by no means the only way to build this site. I'm sure your sites look totally different than this one. And that is totally cool. Like always, when I started working on this. I started with a small viewport. At a glance the most noticeable improvement. Is the fact that the text is now a lot larger. This is a nice change, to help improve readability. As to the new location column in the sports score table, well, it disappeared on mobile. When there's enough room for the locations, I went ahead and added Display Block, to the location class to make them show back up. When the viewport is now in the desktop range. I decided to shrink the text in the Sports table, to make room for the location. While I would rather make a totally different, snazzier table to make everything fit, I thought that making the font smaller was a nice compromise to keep all the information I wanted in the table. Next on my list of changes is the Latest News section. In the old version, I didn't really like the way the text was wrapping around these images. And I also didn't like the fact that these images were just so small. I decided to give myself a little bit of flexibility. So I turned each article or snippet, into a flexbox. You can tell that at the smallest screen size, I've totally dropped the thumbnail images, and I've gone ahead and cropped the text to three lines. Adding this ellipses here to the end of the last line, isn't super simple actually. So if you want to do the same, I suggest starting with the link that you can find in the instructor notes. As the page gets wider, the images show back up, and they scale with the width of the page. Next up, I tackle the thumb nail images for the articles. Originally, these images were being scaled down from an image that was something like 2000 by 1400 pixels, which is just absolutely massive. And way too big for this use. So I used image processing software, to scale the image down to twice the resolution of the largest resolution thumbnails could take. With this layout, thumbnails don't get any larger than 245 by 164 pixels. High density displays, need higher density images. So, I scaled the image down to 490 by 327 pixels, which is a much smaller file. To learn more about using images responsively and responsibly, try our Responsive Images Course, made by Google's Sam Dutton. For the final version of this project. I put all of my code in to final.css. It's essentially just a series of breakpoints, and then small changes to the snippets and scores. I'm not going to go in-depth to my code at the moment. But the instructor notes, has instructions on how to download and play with my source code. All in all, I'm pretty happy with my copy of The Brighton Times. But, this is just my layout. I want to see what you've done, too. Make sure that you post all of your sites in the forums. Pete, this has been a really fun whirlwind tour of everything somebody would need to start developing responsibly. It has. We've learned to the basics of well-sized elements for mobile. Using breakpoints and media queries, to change the page layout for different devices. Common responsive design patterns, and we've gone into some advance techniques, like minor breakpoints. At this point, you've got all the tools and concepts you need to build amazing responsive sites. You know, and I think it's fair to say that, all you need now, is an idea for a site, and some time to let your content inform your responsive design. Go build something awesome. Good luck, and have fun.