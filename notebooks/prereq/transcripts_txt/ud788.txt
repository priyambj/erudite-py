All right by now you know your way around UI controls, stock view controllers and delegates. It's time to put those new skills to use and build something. In this lesson you're going to create the first version of Mean Me a simple version of the app that you will eventually include in your portfolio. In order to make the app you're going to have to extend your UI kit knowledge in a number of ways and we'll guide you through the process. Let's start with a close look at the app's behavior. The MemeMe app lets you create a meme with an image and some text. Everyone loves a good meme. And it's easy to get a laugh from friends. This is the meme editor view controller. It lets you select a picture and edit text at the top and the bottom of the picture. The picture can be selected from the device's photo album or by using the camera. When I press on the camera button in the bottom toolbar, the camera launches and I can take a new picture to use in a meme. When I press on the album button, I'm brought to the photo library where I can choose from recent photos. I like this one of the baby hedgehog. Whether we're using the camera or the album, you'll use Apple's UIImagePickerController to select your image. After I've chosen an image, I return to the Meme Editor. Notice that because of the shape of the hedgehog picture, I'm making my meme in landscape mode. Here text is entered into a text field. When the editing is complete we show the text in an outlined white font. It's slightly different from impact to the true meme font, but it's pretty close, and available among Iowa stock funds. When I click inside the bottom text field, notice how the view slides up so that the keyboard doesn't obscure the bottom text field. Now our meme is ready to go, so let's share it. You can find the share button in the upper left corner. And here's our old friend, the activity view controller. Let's send this to Kunal. And that's all there is to it. This project begins like most development projects, with a list of new technologies to learn. This can be a daunting stage in a project, but it can be exciting, too. Let's walk through the list. In order to build MemeMe 1.0, you'll need to be able to pick an image using a UI image picker controller. You'll need to be able to edit and display text with a particular style, move the view to accommodate the keyboard, and share a meme using the activity view. And when you're done, you'll have a meme editor with the ability to create and share a meme. In reviewing the meme 1.0 to do list, which of these items do you think will be the most challenging? Which do you feel the most confident about? Mark one of the check boxes for each item on the list When you have a complex project, it's important to approach it one small piece at a time. We don't recommend that you jump straight into writing meme. It's easier to experiment if you create a temporary X code project that you don't plan on keeping. To learn to pick images, for example, you might want to create a one button app that picks and displays a single image, the smallest possible project that will let you learn what you need to know. Baby steps to the meme generator. So here I've made a simple project to experiment with, and since the meme editor has a toolbar at the bottom of the screen, I'm going to go ahead and drag one of those in. And I'll position it and set its constraints. The tool bar comes with this button, but I'm going to go head and change its label to pick. And you see I've already got an image view, so you can go head and drag one of those in and set its constraints. Now I'm going to close this outline view for a minute and open up the assistant editor, and then we can add an outlet for our image view. Now, let's go down to our button, and we'll add an action for our button. Let's call it pickAnImage. And that ought to do it for Storyboard. So, we'll focus on our view controller file. I'm going to get rid of this extra method for now, and here in the pick and image method that we just added, we want to launch out UI image picker controller, just like we did in lesson two. So we add these two lines to present the image picker and let's run it and see how it looks. And there we go. We can choose from our outlets. So we're making progress, but when I choose a picture, I can't really tell that it's being chosen. We still need to implement the delegate pattern, and set our view controller as the delegate of the image picker. Next step, we'll investigate the delegate protocol so we'll know what method will be called when the picker has an image chosen. If you've been using the simulator keyboard to test out your version of me me, you may have noticed a little problem. Especially when editing this bottom text field. [NOISE] The keyboard covers up the text field, and leaves the user stuck. One can avoid this by shifting the entire view up, like so. To isolate the keyboard issue, let's build a simple app. Here I've got an app with a text field in an image. The text field's at the bottom and it gets covered up if we don't shift the view. Shifting the view a simple. Remember way back when we built click counter from scratch in code? To place our views we use the frame property. That's the property we'll use to shift the main view up. More specifically, frame.origin.why. The point where y = 0 is at the top of the screen. To move the view up above the keyboard, we subtract the height of the keyboard like so. But how will we know when the keyboard is about to slide up? This is where NSNotifications come in. In short, NSNotifications provide a way to announce information throughout a program across classes. To announce information, like the keyboard appearing or disappearing. For more details, see the upcoming text note on the NSnotification center. Kind of like we subscribe to mailing lists, objects have to subscribe to, or observe, notifications. In this block of code, the view controller is signing up to be notified when an event is coming up. The event, UIKeyboard will show. We'll call the subscribeToKeyboardNotifications method up here, and view will appear. When the event UIKeyboardWillShow occurs The method Keyboard Will Show is called and that method shifts the frame. But right now the compiler is complaining because we haven't implemented this get Keyboard Height method. Notifications carry information in the user info dictionary. The UI keyboard Will Show notification carries the keyboard frame in its user info dictionary. So that's how we get the keyboard height. So now let's see this keyboard shift in action. But let's not forget, just like with mailing lists eventually we need to unsubscribe. So here's the method to unsubscribe from keyboard notifications. And we'll call this unsubscribe method up here in view will disappear. Congratulations on making it to the last lesson. In this lesson, you're going to iterate on your previous work with Meme Me and get the app portfolio ready by adding the ability to view sent memes. That might sound pretty simple, but the sent memes feature is a tricky one. It employs a tab view, a table view, a collection view, not to mention implementing navigation, so you'll need to extend your UIKit knowledge in each of these areas. We'll take you through each topic one step at a time. Let's start with a close look at this updated version of the app, Meme Me 2.0. Here's the Sent Memes view, it's the first screen presented upon launch. The Sent Memes view keeps track of all recently sent memes. Here you can see a few that I sent to my teammates earlier. You can see the memes in a table view or a grid. Notice how I can switch back and forth using these tabs. When I press the grid icon, the collection view appears. When I press the table icon the table view appears. The grid is created using a UI collection view controller. It's similar to the UI table view controller but has a more flexible layout mechanism. Both of these views access the same meme model objects, and they're embedded in a tab bar controller. >From the Sent Memes page, the user can go back and create new memes. When I press the button with the plus icon in the right corner the meme editor slides up from the bottom. Now I can make a new meme. Here I'll make one about my favorite cow on the beach. And of course when we're done with our new meme we'll want to share it. Here, let's send this one to Sebastian. When the meme has been sent, the meme editor slides back down and the Sent Memes view is revealed again. And this time the collection includes the new cow meme. And that's meme me 2.0. Let's walk through the topics we'll need to research in order to add the sent memes page. We're going to be experimenting with tab bar controllers in order to be able to switch between the Table View and the Collection View. We're going to need to learn about UI collection views. Which you'll see are very similar to UI table views. And you'll also be learning how to share a single data model across multiple View Controllers. In the upcoming sections we'll guide you through the steps to learn these new skills. If you think back to the table views we've built so far, Bond villains, make your own adventure, favorite things. They all had an array of data that they used to populate a table. For meme, we're going to have two view controllers displaying memes. A collection and a table. They could each have their own separate array of memes. But that doesn't seem right. The two ViewControllers should be accessing the same data using a shared model. So where can one keep a data model so that it can be accessed by both ViewControllers? The AppDelegate, the delegate to the UIApplication object, is a good place because it can be accessed from anywhere in your project. Now keeping data in the App delegate is a little bit controversial. But in our case, it's the simplest option. And there are solid precedents for it, including Xcode's core data templates. You can add your memes array to the App Delegate with this line of code. And whenever you create a meme, you'll want to add it to the app delegates array. So you could add the following code in the view controller that edits the meme. And finally, when you want to access this data from the collection view controller or the table view controller, you could add these lines. For a recap of the code in these three methods, see the upcoming text note. We want the user to be able to toggle between viewing set memes as a collection and viewing them as a table. We'll do this using a tab bar controller. Tab bar controllers are fairly straight forward, lets practice by setting up the Bond Villian's app using tabs. Here I've got the Bond Villian's app with the master detail structure and I'm going to drag in a tab bar controller. The tab bar controller comes automatically connected to two items. I don't need those though, so I'm going to go ahead and delete them. I'll connect the tab bar controllers first tab by dragging from the connections menu. Here under triggered segues to the navigation controller for my table view. Next up, we'll connect the collection view controller. Here you can see I've added the Villain Collection View Controller for showing bond villains in a grid. And I've assigned it as the root ViewController to this second navigation controller. I'll connect the second tab to the navigation controller for the collection view, again, by dragging from the ViewController segues in the tab bar controllers connections menu. And then once I've got the tab bar controller all connected up, I want to make sure that it's set up as the initial ViewController. Which I can do here in the attributes inspector. And then we'll run it. Okay, there's our table, and we can toggle to a collection and back to a table. Alright. And if you want to change the appearance of the bar items, you just go back into Storyboard, click on the bar item in its respective navigation controller, and then in the attributes inspector, you can change the title [SOUND] or you can add an image. Now I'm going to walk through how to set up a collection view in Storyboard. There are two ways to set up table view controllers and collection view controllers in Storyboard. The first way you've seen before. You start with the regular UIViewController like this one. And then you drag in a table view or a collection view. The second option is to use a Table View Controller like this one. Or a Collection View Controller like this one. In the table views lesson, we used option one. Now we'll set up our Collection View Controller using option two. Here I've opened to the Bond Villains in Tabs project. But this version doesn't have a Collection View Controller set up yet. To access this project, switch to the git branch in the instructor's notes. Now open up the Bond Villains in Tabs project so that you can follow along with me as I go through the steps to add a Collection View Controller to your project. The first step is to drag in a Navigation Controller. Next, you'll want to delete the Root View Controller that automatically came with that Navigation Controller. Next you'll want to drag in a Collection View Controller, and this item is of the class UICollectionViewController. Next up, Ctrl+click on that Navigation Controller and set its Root View Controller to be the Collection View Controller you just added. Remember that we want our collection view to show up in our tab bar. To accomplish that, first Ctrl+click on the Tab Bar Controller and we want to add this second Navigation Controller to our view controllers array. So we can drag here from the view controllers array, and add that second Navigation Controller. Next, we need to set the name of the Collection View Controller to match the name of the class where all our collection view methods are implemented. To do that we click on the Collection View Controller and then open up the Identity Inspector on the right. Here under Class, we're going to put Villain Collection View Controller. Of course, when you're setting this up for Meme Me, you're going to put sent Memes Collection View Controller. Next, we're going to configure our Collection View cell. In order to do that, let's open up the Outline View on the left. Here, in the outline, under Villain Collection View Controller, we can see the Collection View cell. Go ahead and click on it. We need to set the name of the cells class to match the custom cell class that we implemented earlier. So up here under Class in the Identity Inspector, we're going to put Villain Collection View Cell. And when you're setting up Meme Me, you'll type in whatever name you used for your custom cell class. Now, I'm just going to make this collection view cell a little bit bigger, and then I'm going to drag in an image view. Right now, I'm just dragging in an image view for testing purposes. I just want to be able to see the cells so that I know I set them up correctly. Now I need to connect an outlet to this UI image view. So you can see here that I've opened up the Assistant Editor. And we've got our VillainCollectionViewCell.swift file here on the right. Now to connect the outlet, all I do is drag from the circle to the UIImageView in Storyboard. Last, but not least, we need to make sure we set the reuse identifier for our collection view cell. So you'll want to make sure you click on the Collection View Cell, and then you'll go over here to the Attributes Inspector, and under Identifier, put VillainCollectionViewCell. All right, let's run it and see what we've got. All right, there's our collection view and it seems to be loading data fine. And in the next session, I'm going to talk about how to use the class UICollectionView flow layout so that you can arrange these cells the way you want them. In order to display your sent memes evenly across the collection view, you'll want to set the size of the custom meme cells, and the spacing between them. To accomplish this, we use the class, UICollectionViewFlowLayout. Here I've opened the class reference, and you can also find a link to it in the instructor's notes. I encourage you to take some time to read through it carefully. The UICollectionViewFlowLayout class has three properties it will need for laying out our sent memes. Minimum line spacing, minimum inter-item spacing and item size. To implement a UICollectionViewFlowLayout, first, add a flow layout object to your collection view controller using this line of code. Open up the assistant editor so that you can see the storyboard file. And then connect the flow layout outlet to its representation and store reward. You can see here that it's marked with a little yellow box. Next, set the spacing between items by setting the minimum inter-item spacing property, like this. You can see that the variable space is being set to 3. Similarly, use the minimum line spacing property to set the spacing between rows. Naturally, you don't need to use 3. Use whatever spacing you think looks best. Last but not least, set the item size. The item size is the size of your cells and I encourage you to set the item size to be dependent upon the size of the main view, which is dependent upon screen size. That way your layout will work for multiple screen sizes. To access the size of the main view, you can use this, self.view.frame.size. Here Iâ€™m accessing the width property and you can do the same for height. So let's see how our layout looks. Okay, so apart from this one image, the layout in portrait looks pretty good. Let's see what it looks like in landscape. In landscape you can see that we've got a little extra space between items. And I'm going to leave it up to you to figure out why that is and get this layout looking the way you want it. I'll give you a hint. One solution involves accessing the height of the main view, kind of like the way we accessed the width here. And that ought to give you a good start on collection view flow layouts. Way to go. You're almost there. And you have all the tools you need to build Mimi on your own. Best of luck. Now, go get to it. Hi I'm Gabrielle, and I'm going to be your instructor for UIKit Fundamentals. If you're taking this course, you should have built at least one single view app that adheres to the NBC design pattern, which means, you know how to add objects and storyboard and connect them in your view controller and you're familiar with some basic features of UIKit, the iOS user interface library. If you're not familiar with these concepts, we recommend you take Intro to iOS Development with Swift first. A link to that course is in the instructor's notes. This course is all about becoming more comfortable with UIKit and mastering its most widely used components. Our primary goal is to give you lots of opportunities for hands-on coding. And you'll build lots of small apps to help you learn specific concepts. At the end of the course, you'll have the skills required to build a mean generating app from the bottom up. Let's take a detailed look at this app in the next video. We call this meme generating app MeMe. MeMe lets you choose an image from your phone. Here I've got some funny ones of my teammates, like this one of Jared in the library. So I'm going to make a meme that makes fun of napping and API's because he's working on a networking course. And then once you've added text to an image, you can share it with a friend. MeMe stores the memes you've made in a collection of meme model objects. And you can browse your memes in a table or a grid. Like most apps it's built from standard UI components, right off the shelf, which makes it intuitive to use. At first glance, this may seem like a daunting task. There are probably a lot of pieces you're not familiar with. But don't worry. By the end of this class, you'll have the confidence and skill to create this app on your own. UIKit is a big library. We won't be covering all of its classes, but we've selected a path through the material that will give you a strong foundation to build on. We'll be covering, outlets and actions, presenting view controllers, delegates, tables, navigation, and we'll wrap up with some skills you'll need specifically for the MemeMe app. In this first lesson we want to take a close look at each object that's used to create an app. We'll write an app entirely in code, and then we'll see how storyboard can be used to replace that code. To begin, let's develop a way to diagram objects, so that we can visualize our apps' components and see how they're connected. Here's our first simple app, which we're calling Click Counter. It has one button and one label. When you tap the button, the label shows an integer value that increments. This app is extremely simple. In fact, you might think you could build it in your sleep. But we want you to get in to the habit of diagraming all the objects used to create an app. Let's give this a try for each of the objects in Click Counter. We can draw each of the objects we're interested in as a rectangle. And we'll represent object properties with circles like this. All ViewControllers inherit a view property. This points to the root view of a page. In this case, the view that paints the white background. Our diagram needs two more view objects, a button to click and a label to show the click count. We will draw objects that paint the view in blue. These view objects contain the complex code required to get all the pixels painted in the right colors. These are UIKit objects that we use off the shelf as they've been written by Apple. Do we need a model object? In this case, our app only needs to remember one number so that it can increment. Let's make an int property in our ViewController. We'll call it count. This is the basic architecture of our app. We've got our model that stores the click count, our view objects that paint the screen ,and our ViewController that ties everything together. These objects get created and connected right before this page is displayed. Now let's say the user clicks the button after the page is displayed. Those button tabs turn into events, so we'll indicate that in our diagram as well. So what else will these objects need in order for the app to work? Let's think through the sequence of events that happens as the user taps the screen. The user taps a button on the screen and that button interprets that tap as an event, invoking an action in the ViewController. Now we're in our control code, our custom code. Here the Viewcvontroller updates the model. After updating the model, the ViewController needs to also update the text of this label. But right now, the ViewController doesn't have a way to access that text. In order to accomplish this last step, we need to add a label property to the ViewController. All right. Now that we got a plan, let's go recreate these objects in the viewcontroller.swift file Now we're going to write Click Counter without any help from Storyboard. You'll begin by creating a fresh project. We're going to use the Single View template in this case. And remember if you need help, you can always follow the steps in the instructor notes. Here I've opened the ViewController.swift file in the Click Counter project. If your ViewController.swift file has extra methods when you first open it, go ahead and delete them. The template automatically creates those, but we don't need them right now. Our next goal is to write swift statements that will create the subviews for the label and the button. We can put the code here in viewDidLoad. You may remember from course one that this executes once, after the initial view object is set. Let's start with the label. We can allocate it and initialize it here. Without Storyboard, we're going to have to position our label on the screen with code. All views have a frame property that we can use to do this. And we can use the method CGRectMake to set the x and y coordinates here and also the height and width. So I'll go ahead and set our label's text to 0, and then try running it. Okay. So we're not seeing anything yet. That's because we still need to add our label's view to the view hierarchy. That way the label's view is associated with our existing view. So here I'll call up the view property, add the label as a Subview, and that's, let's try running it again. Awesome! We can see our label now. We can do similar work with the button, so let's go ahead and add some comments so that our code's a little more organized. So here I'm setting the button's frame, setting the title, giving that title a color we can actually see, and then adding the button's view as a Subview of our real view. And, now we run it again. And now we can see our button and our label. Not too bad for a few lines of code. Now that we've made some headway coding Click Counter, think back to the diagram we're trying to recreate. How have we progressed so far? Here are three diagrams depicting Click Counter in different states. Choose the diagram that you think best represents how our app's objects are currently connected. This diagram here, with only the view property set, reflects the state of our app right now. We've created our objects, but there are still some connections missing. So we still need to create this action and invoke it on the ViewController. We also need two properties, the count property and the label property. Let's go add those to our code. Here we are back in our ViewController.swift file where we need to create two properties. We'll declare the count and label properties here at the class level, setting count to 0 but leaving the label undeclared for now. Hm. Looks like the compiler's complaining. Let's see what it has to say. Class ViewController has no initializers. So something's going on with the initialization of these variables that we just added. Right now, this label property has a non-optional type. Let's see what happens when we make it an optional. Okay, that seems to please the compiler. So what did I just do? This exclamation point here indicates an implicitly unwrapped optional. We'll hear more about optionals and conditionals in the upcoming Swift session with Jason, but the gist of it is that optional properties can be nil and still compile. In this case, our label property is nil at compile time because it hasn't been initialized yet. You can see that the code also compiles if we go ahead and initialize the label property when it's defined. But we'll leave it as an optional for now. Okay. We have our label property, but we still need to set it. With this line of code, we're taking the object reference stored in a local variable in ViewDidLoad and giving that value a more permanent home in our property. It is this connection that will enable our ViewController to set the label's text when the button is clicked. Now let's write the method that will be called when the button is clicked. Inside this method, we'll use the two properties we just created to increment the count and then set the label's text. Notice that we use this self.label property to reach out of the ViewController object and modify the label. It gives us an outlet to the label. This is the reason properties are called IBOutlets in storyboard. Okay, now we're really close to having a working click counter. All that's left to do is get the button to invoke this incrementCount method. So now our ViewController should be all set. But our buttons still need some work. This button is an instantiation of the UIButton class. It belongs to a category of view objects called control objects. Control objects turn user actions like finger taps into events. Now we need to create an object inside this button that will tell it to contact our ViewController when it's clicked. We call this a target action, and this is the word that IB action is derived from in story word. This little target action holds three key pieces of information. An object to notify, the target, the method to use, the action, and the event that will trigger the target action. So now let's go back to Xcode and implement our target action. We do this by invoking a method on the button object. Here in viewDidLoad, we're going to add the target action to our button. And here you can see the three key components of the target action. The target, which is self, the method to use, which is incrementCount, and the control event, which is TouchUpInside. And with the action added to our object model, our click counter should work. So let's check it out. All right. Very nice. A method like this is sometimes referred to as a Call Back Method. We configure the button so that it will call back when an event occurs. We're not changing the code in the button we're just leveraging it's architecture. It was designed to call back the controller. We're going to be seeing this pattern a lot in UI Kit. We interact with our view objects so that they reach back and contact our control objects. We see it here with actions, and we'll see it later with delegates. In general, actions are method indications from views back to view controllers. Outlets on the other hand, are indications in the opposite direction, allowing method indication from controller to view. Next up, we'll transition back to building our apps using Storyboard and now, hopefully you can see storyboard as a tool made to accomplish the very goals that we just worked out in code. Now that you've seen the nuts and bolts of this app all in code, let's take another look at how Storyboard represents objects. Storyboard has three different ways of showing our objects. In an expandable outline view, in a visual canvas view, and in the text editor itself. It's important to find all three of these to be sure you're confident manipulating outlets. To start out with let's focus on this ViewController.swift file. The first thing you're going to want to do is delete any extra code you have in this viewDidLoad method leftover from when we built this app programmatically. Make sure you hold on to these two properties that we made. And also this increment count method. Right now, Storyboard doesn't know about this label property that we've created. But we can change that by adding at IBOutlet in front of it. This is how storyboard's going to recognize this property. Notice that when a property is marked as an IBOutlet, this circle appears in the left margin. Let's close the assistant editor and focus on the Storyboard for a minute. Inside Storyboard, new controllers are represented by yellow circle icons, like this one in the outline view, and this one in the canvas view. The outline view is an expandable tree that shows the view controller the view and any subviews. The canvas view is just another representation of the exact same objects. If we control click on one of the view controller icons, we see the pop up connections menu. And here we can see our label property. You can see here that this circle representing our label property is empty. That's because it hasn't been initialized yet. So let's go ahead and do that now. To initialize our label, first we open up the utilities pane and drag in a label from the objects menu. Let's close this utilities pane, and then we can set our label property by dragging from new referencing outlet to the canvas view. Here in the pop up connections menu we can see that our label property is set. If I control click here in the canvas view I can also see that the label property is set. If I want to unset it I just click on this small x. I want to show you one more way you can set that property. So let's open up the assistant editor and see that you can drag from the circle in the left margin here straight to the canvas view. And then let's check again in our pop up connections menu and see that our label property is set. Okay now we want to connect up our button the way we did for the label. First let's make a little room for the button by moving this label up a bit. And we'll need to open up our utilities pane so we can drag in the button. There we go while we have this utilities pain on the right open let's go ahead and set the titles on this button and label. To do that you're going to want to go to the attributes inspector and then you can see here's where our Title gets set. We'll just say Click. And then for the label let's just set its original text to zero. Let's close our Utilities pane for now and move this back to the center. And next up we're going to set the target action on this button. First up, let's open up our View Controller file for a little review on target actions. Recall that the target action that we added programmatically had three key components. Its target which was self, the action which was the method increment count, and the event that would trigger that action touch up inside. So now we're going to use storyboard to tie together these same three pieces of information. But first, we need to mark this method as a IB action, so that it actually shows up in storyboard, similar to how we did with the label property. And we can close our assistant editor for now and focus on story board. And then move this over a bit. And to set our target action, first we bring up the buttons pop up connections menu, go down to touch up inside, drag to our View Controller, and choose the method we want to be our action. I'm just going to remove that target action really quick so I can show you how to make it one other way. Using the canvass view you can still get to this menu, go from touch up inside to the view controller and then the method increment count and you can see the three key components of the target action. Let's go ahead and run it so we can see it in action and if we click on the button we can see our count incrementing. So that ought to take care of click counter. Now, we're ready for the next step. So far, you've seen quite a few buttons and labels. But remember, the UI kit offers a diverse palette of UI controls. This gives us the freedom to choose UI elements that make for the most intuitive user experience. In the next step, Color Maker, we have three UI switch controls. Which are fairly similar to buttons with one new type of event. When the user flips the switches, we see the combination of the three color components in the window. Here we'll use three controls hooked up to three outlets and we'll route the events from all three into a single action. The code and story board are complete but the outlets and actions aren't connected yet. Go ahead and download the project from the downloadable section. Now we're going to focus on Switches for a minute and see what we can learn by revisiting Apple's documentation on UI controls. When we use buttons, we configure our target actions to work with the event touch up inside. What's the name of the event that corresponds with the switch being thrown? How do we know if the switch is on or off? Find the class reference document for UI switch and then check the correct options. You can see in the documentation that a Switch being thrown triggers the event, UI control event ValueChanged. And we know whether a switch is on or off by checking its" on" property. So, we'll connect each of these three Switch actions to the UI control event ValueChanged. Before we start connecting outlets and actions let's apply some of our diagramming strategies. Let's think about how the views and the view controller will interact when the user starts tapping the screen. Here's the sequence we expect. The user touches one of the switches and the switches turn those taps into events, this triggers target actions that we set. An action method will be invoked on the view controller, and in that method, the ViewController looks at the state of all three of these Switches. That determines the background color, which the ViewController will then set on the colorView. So we'll need outlets to get the state of each of these three switches, we'll need an outlet for the colorView. And we'll also need to set actions for each Switch. If you haven't downloaded the Color Maker Project yet, go ahead and do that now. You'll find it in the instructor notes. Then when you open the project in Xcode, you'll notice that the code inside the view controller is already written for you. Have a close look at this change color component action. You can see that it uses all four of the outlets that are used in this app. All in this one method. Let's see what happens when we run the app. There are switches, they look okay, but they're not actually doing anything. I can't say that's all that surprising. Because if you look here you can see that none of these outlets are actually connected. If you look at these circles in the left margin, I mean. Connect the actions and outlets in Color Maker and choose the option that best describes your experience. Hopefully, those connections worked for you. If not, here are a few pointers. To set the actions, we start by ctrl+clicking on each switch. Here you'll see a familiar list of events, just like with the button. And, down here, you'll see the event value changed. This corresponds to the UI control event value change, that you found in the documentation. We want to invoke an action method on the view controller each time this event occurs. So, we drag from the circle to one of the view controller representations, and then choose the method. We also have the option to open the Assistant Editor, and drag straight to the method, like this. And, don't forget we also need to connect our four properties, so let's move back to storyboard. Then you can open the pop-up menu for each switch, go down here to New Referencing Outlet, and drag to the view controller icon. This ones the green switch, and we'll need to do the same for the red, blue, and the color view. It doesn't matter which view controller icon we drag to. Last one is the color view, and then we should be all set. Let's revisit the Color Maker app. New iOS developers often note that one typical challenge is debugging a project when an action or outlet is not set correctly. To expose you to this challenge, we've created three broken versions of the Color Maker app. Download Color-Error-1 from the downloadable section below. Run the project, and see if you can find out why it's not working. Enter your response on the upcoming slide In this first debugging challenge, the action is not set on the blue switch. There are a few ways we can find this error. If you run the app, you'll notice that the red switch seems to be working fine, the green switch acts as expected, but the blue switch isn't doing anything. This is characteristic of a missing action. The control seems dead. Let's go back into our View Controller file for a second. In a more complex app, you'll often check to see if an action is being called by adding a break point in the method in question, like this. You could also add a print line statement, like this. We'll talk a lot more about debugging in the networking course, but in this case, the best strategy might be to just poke around in Storyboard. If you know the actions that your app is supposed to have and you're comfortable finding them in popup menus, you can usually track down a missing action pretty fast. If we look here at the green switch, you can see that value change is connected. If we do the same with the blue switch, we see that that value changed action isn't connected. When we run this version of the Color Maker app, you'll notice that the red switch seems to be working fine. The green switch doesn't seem to be working and the blue switch is producing teal instead of blue. If you are thinking that this is because the properties are set incorrectly, then you're on the right track. When you're connecting a lot of outlets, it's pretty easy to accidentally point one to the wrong view. Let's take a look at how things look in the View Controller by opening up this parallel text editor. >From the View Controller side, everything looks as expected. All of our controls here are connected, and our color view's connected. So we'll need to have a look at the popup menus in Storyboard to get to the root of the problem. If we take a look at the popup menu for the green switch, we can see why that wasn't working. Its outlet's not set. And then if we take a look at the menu for the blue switch, we can see that it points to both blue and green controls. That explains the teal. So let's fix that. We'll go into the green switch and add its outlet. And let's double check the blue switch, and we can see that it's only pointing to the blue control now. And let's run it again for good measure. Red switch still works, green switch works and blue is producing blue. Let's take a closer look at this version of Color Maker. We go in here to the red switch. Oh, yikes, this looks like a pretty serious problem. Fatal, fatal error. Unexpectedly found nil while unwrapping an Optional value. Okay, so something's nil, and the compiler is pointing us straight to this line where our colorview is getting accessed. So, the first place to look might be the colorView. So, let's go up to where our colorView property is set, and oop, the outlet is not set. So, to fix that outlet, we're going to want to go back into Storyboard, then we're going to open up the pop up menu for the colorView, and drag from New Referencing Outlet to the view controller. Let's run it again, and see if that took care of the problem. Red switch seems to work. Green looks okay. Blue. All right, back in business. Well done. You've completed the first lesson. We've covered a lot, including object diagrams, target actions, making connections in storyboard, optionals. And in the next lesson, we'll be focusing on view controller presentation. Welcome back. In lesson one, we made single screen apps, but most apps have more than one screen of information. In this lesson, we're going to focus on view presentation and segways. What are our options in iOS for presenting a UI with multiple pages of content? How do new pages of content make their way onto the screen? We're going to talk about two stock ways that Apple provides. The first is through implementing a navigation structure as exemplified here in the messages app. Notice that when I click on a specific message stream, the message details slides in from right to left. If I want to return to the previous view, the main messages table in this case, I can use the Back button in the top left corner. That Back button is always there in iOS navigation. A second way to bring a view onto the screen is modal presentation, like you see here when I press the Compose button in Messages. Modally presented views slide up from the bottom of the screen. Modal presentation is often used for Alert views. If I click on the camera for a photo attachment, an alert modal slides onto the screen, giving me photo attachment options. You can see that this alert view also slides up from the bottom. You'll be using a modally presented image picker like this one when you build MiMi Oh, and one more thing before we get started. I want to take a minute to acknowledge that lesson two is a significant jump in difficulty from lesson one. We're really getting into the thick of UI Kit now, and learning some powerful skills. So get your game face on, don't forget to take breaks, and make sure to reach out for help if you get stuck. Can you identify the two methods of view presentation in the apps you use from day to day? After you've done some investigating, answer the quiz question. When are pages presented from left to right, as in navigation, and when are they presented from the bottom, as in modal presentation? And for more insight from people who spend a lot of time thinking about user interface design, check out Apple's human interface guidelines on navigation and modal presentation. You'll find a link in the instructor's notes. Apps use a navigation structure to present views when each page is a part of a hierarchy or a flat sequence. Users make one choice per page, and can retrace their steps to make different choices. Such a hierarchy often takes the form of a list of items, each with a detail page. Apps use modal presentation for things like temporary views and alert views. As well as self contained activities that only offer the choice to be completed or dismissed. In this lesson, we'll focus on modal presentation. Navigation will come in lesson four. Imagine that you have the code for the messenger app. Where would we look to find a swift statement that presents the image picker view on top of the composer view. We would find such a statement in the View Controller that's currently on screen. The compose message view controller. The invocation looks like this. Now let's have a closer look at these three arguments. The third one is often set to nil. It's a closure, which is a block of code that can be invoked once the view is presented. This second argument indicates how the view appears. When animated is set to false, the view flashes onto the screen immediately, without the upward slide. For this first argument, we'll need a reference to the view controller that's being presented. Let's figure out how to get that reference. Now we're going to set up a simple project, so we can experiment with presenting stock view controllers. You're probably familiar with views like the Camera Roll, Activity Views, and Alert Views. These are off the shelf view controllers which we'll present without modifying Apple's code. To get some practice with presenting off the shelf view controllers, we'll make a one button app with a method named experiment, which presents one of Apple's view controllers. It'll look something like this. One button which presents the camera roll, and the experiment method will look something like this. In this method we'll need a reference to the view controller we're about to present. So how will we get that view controller reference? We'll just make one. So here we invoke the constructor for the view controller required to select an image, and then in this line, we present the image picker. Now see if you can repeat this experiment on your own. Just create a single view project with a button labeled Present, and then connect that button to an action named experiment. If you get stuck, consult the steps in the instructor notes. But first try to complete it without peeking. Again, your app should look something like this. When you're finished, describe your level of confidence working through this exercise. If you had any trouble with this exercise, be sure to post questions on the discussion forum. Next up, we'll look at two other stock view controllers, activity views and alert views. In the meme app, we need to show the Activity view in order to enable users to share memes. Let's go back into our experiment app and see about presenting the ActivityViewController. We'll start out with just an empty image object, we can then use that image to instantiate a UI ActivityViewController. And then we just present it. Let's see how that worked. And there's our Activity View. One can make an alert view in a similar way. Here we're just constructing our AlertViewController and presenting it and then we'll try and run it, and then we'll try and present our AlertViewController. Oh, uh-oh, okay. So let's scroll up to the top of the console to see what's going on. URL alert controller must have a title, a message, or an action to display. Okay, so if we add one of those, this should fix the error. So we'll try that. Let's close the console up. And then we'll return to our ViewController and close that too. So here we're adding a title and a message to our AlertViewController, so let's see if that fixes the problem. All right, show me an Alert View hey, sweet. Okay, now we're successfully presenting our AlertViewController, but right now there's no way to make it go away. Remember that any time you present a view, you also need to provide the user with a way to dismiss it. The first two view controllers we presented had their own Cancel buttons built in, but Alert View doesn't have that, so we have to solve the problem ourselves. We could just try adding this dismissViewController method right after presentViewController. Let's see what that does. Okay, show me an alert view oh, well it showed me an alert view but then the alert view immediately left. Which is not that surprising since we called dismissViewController immediately after we called presentViewController. What we really want is for the AlertView to be dismissed after the user has taken some action like clicking an OK button. AlertView has an interesting way to do this with closures. As you know, closures like this one, enable us to pass methods around as arguments. So let's see how that looks. Okay, our AlertView appears, I click OK, and it goes away. Perfect. Now that you have some experience presenting off the shelf view controllers, you're probably wondering how to present your own custom view controllers. Here we have an app that simulates rolling dice. The first view controller with the roll the dice button, presents a second view controller that displays a roll of the dice. The second view controller can be presented in the same way as the camera roll or the activity views and alert views. But this time we have full control over the displayed view controller. The app is currently incomplete. In a second, you'll be asked to download it, and look at the Xcode project. But before we get into the Xcode files, let's pause for a second, to draw the object diagrams for the two view controllers. That way we can clarify which IBOutlets and IBActions the project should contain. The first view controller is simple. It's just a single button with a single action. This is the action that should trigger the presentation of the Dice View Controller. The Dice View Controller is slightly more complex. It needs outlets to these two image views that are for the dice. It also has one button with a single action. This action will cause the view controller to be dismissed. If you look in the instructor notes you should see a file called dice.zip. Go ahead and download that file and then examine the Dice Xcode Project with the following questions in mind. Check off each question as you find the answers. Here we are in storyboard and to address the first two questions in the quiz, we want to double check that our actions and outlets are all connected. First let's check the roll the dice button. So, we'll look at the pop-up menu here, and we can see roll the dice down here, the roll the dice action, but it's not connected to anything. So, that's one connection that's missing. Let's go ahead and fix that. And we also need to check the action for the OK button. So, that looks fine, that's hooked up. And there's two outlets we need to check, the two outlets for the dice image views. So, let's look at our Dice View Controller. Here, the first die outlet is set, you can see it highlights there, but the second die outlet is not set, so let's go ahead and fix that. To see where the images for these dice are stored, we need to open up the project navigator. Here, if you click on this folder images.xcassets, you'll see all the dice images here. And next we're going to go into the RollViewController.swift file and go ahead and close our project navigator. And then if you look in the Roll the Dice method, you can see that the first value, the dice value, is coming from calling this function randomDiceValue. And then if you go into the function randomDiceValue, you can see that the method arc4Random is what's actually generating the random numbers. Now, if we go into the Dice view controller file, we can see how these random numbers are matched up with images. Here in this line, a view will appear. You can see where the image names come from. Remember that the Dice images have the names D1, D2, D3, etc. Which means that the strings for the image names can be built up from the dice values. Let's take another look at these dice values. Why do they have question marks at the end? We declare these properties with optional types because we expect them to be nil until the rollTheDice method is called. Remember from the first Swift session that it's okay for optional types to be nil. The question mark specifies a wrapped optional, and you can see that the dice values are conditionally unwrapped here in viewWillAppear. This if let construction unwraps the first value optional by assigning it to a new variable under the condition that first value is not nil. Here we are in our RollViewController.swift file. And the first thing I want you to do is delete any code that's in the rollTheDice method. Here in this method, we're going to present our custom view controller. So how are we going to do that? We might as well start by trying to present it the same way we did the UI Kit view controllers. So in that case, we just construct our DiceViewController and then present it. But also we need to set those dice values. So we'll do that in these two lines. Okay, let's see if it runs. Okay, so far, so good. Mm, got a problem. What does the console say? Okay, fatal error, unexpectedly found nil while unwrapping an optional value. Okay, so the green highlighting is pointing to the first die property, and we know if the first type property is nil, that's going to cause a runtime error. Because firstDie is an implicitly unwrapped optional. So why is firstDie nil? If we look back at our object diagram, we're reminded that these outlets to our views were created in storyboard. We created this instance of DiceViewController without storyboard. So that means these outlets, these views, and this action don't exist yet. So that's a problem. So in order to get rid of this error, we need to get a fully assembled DiceViewController from storyboard. So let's close the console and then go back into our RollViewController.swift file. So here's where we were presenting our DiceViewController before in the rollTheDice method. You go ahead and delete this reference to the DiceViewController, and we're going to replace it. In this line, first we get a reference to a storyboard object. And then we asked for the DiceViewController by name, using its storyboard identifier. Let's take a closer look at this new method, instantiateViewControllerWithIdentifier. This identifier is just a string. It's the name that you give the view controller in storyboard. So let's double check that we actually set that name in storyboard. So if I open up the storyboard file and click on the DiceViewController, I can look in the Utilities pane and click on the Identity Inspector. In the Identity Inspector, right here you'll see the storyboard identifier. And we can see that, yes, indeed, it is set to Dice View Controller. Just for kicks, I'm going to go ahead and delete this storyboard ID and the class ID and see what would happen if you forgot to put the name of the view controller. Now let's try and run it. Okay, so it compiles fine. Roll the dice. Uh-oh, terminating with uncaught exception. Okay, so if you get one of these exception errors, what you want to do is scroll up to the top of the console. And then you'll get more information about the error. In here we can see, storyboard doesn't contain a view controller with identifier DiceViewController. So that's pretty much what we expected. But we know how to fix that. We'll just go back in storyboard and reset the name. There, that ought to do it. Now let's go back into our RollViewController.swift file. Because I want to point out one more thing about that instantiateViewControllerWithIdentifier method. What's going on at the end of this line here where it says, DiceViewController as DiceViewController. If you Alt+click on this method, you can see that it returns any object. That's why we need to cast that returned object as a DiceViewController. Let's think about these dice values for a second. Even though they were displayed in the dice to controller. They were actually generated by the RollViewController. It is usually necessary for a presenting controller to configure or pass data to a new view controller. We are about to learn two more ways to use storyboard to present view controllers using segues. Each of the three ways finds a slightly different strategy for passing information from one View Controller to the next. Of the four view controllers that we've presented so far, which ones required the presenting controller to provide information to the new view controller? We actually didn't need to configure the Camera Roll. But, on a physical device, we could've modified it to get an image using the camera. For the Activity View, we supplied an image to be shared. For the Alert View, we supplied the title, message, and OK button. And, for the Dice View Controller, we supplied the two die values. In storyboard, Apple refers to a transition between view controllers as a segue. These segues are depicted using this gray arrow that's interrupted by this circular icon. You can see a lot of segues and storyboard for this make your own adventure app. Which you'll see a lot more of if you stick around for lesson 5. Here on the roll the dice method of our role view controller dot swift file, we saw how to present view controller's programatically. Now we're going to move onto a second way of presenting view controllers, by combining code with a storyboard Segway. Now, I don't want any tears, but first we have to delete all of the code code in our roll the dice method. Back in storyboard we're going to open up our pop up menu for the role view controller. And under triggered segues we're going to drag this manual segue to the dice view controller. Here we have a few options for the segue. I'm going to choose modal here. But we'll talk more about the push and custom options when we get into the navigation lesson. Next we need to set the storyboard identifier for our segue. So let's close this outline view and open up the utilities pane and then if we click on the segue we can see in the attributes of inspector where we can set the storyboard identifier. So we'll call it roll dice. Now we have our segue from storyboard. But we need to write the code that calls it. We want the segue to happen when the dice is rolled. So we go into the rollTheDice method in our RollViewController.swift file. Here we're going to invoke the method performSegueWithIdentifier. And our identifier, of course, is rollDice, and our sender is self okay let's run it and see what happens when we roll the dice. You can see that a new view is appearing but other was no dice. Why would that be? Well we never set their values. And in fact our first view controller never even had a reference to the dice view controller. Let alone the dice. So how are we going to set those dice values. Let's leave that question open for now and posture review the steps for creating the segway. We've got one more segue option to explore. There's a third way to present a view controller using only a storyboard segue, no code. But don't worry. I haven't forgotten that we still need to figure out how these two view controllers should communicate. We'll get those dice values set, I promise. We're going to take this segue that we added earlier and delete it. And we'll replace it with a segue that goes directly from the roll the dice button to the dice view controller. We also need to remove the action from this roll the dice button. The action that's connected to touch up inside, that is. And finally, let's close our outline view for a second. Open up the utilities pane, click on that segue, and go into the attributes inspector. That's where we'll set the storyboard identifier for this segue. And we're going to call it rollDice. And now we'll run it. Our view is appearing as expected, but still no dice. I think it's time to get these two view controllers talking to each other. Now we've presented our DiceViewController in three different ways; programatically, using a combination of code and Storyboard, and entirely in Storyboard. Recall that in the first solution, the incoming instance of DiceViewController is manipulated directly. The current view controller has a chance to prepare the incoming view controller and what did that preparation involve? The roll view controller sets the two dice values on the dice view controller. When we use a segue the dice view controller never makes an appearance in our code because story board hides the creation of the object. So now we need a new hook to allow communication between the two view controllers. The method we need is called prepareForSegue. All view controllers inherit this method and it's invoked right before any segue is performed. Its entire purpose is to allow the current view controller to configure the incoming object. One really handy feature of Xcode is that Alt+clicking on a class can take you directly to its documentation. Let's take a closer look at the documentation for the UIViewController class. Let's see what we can find in the Interacting with Storyboard section. You're already familiar with the storyboard property, which we used to get a reference to the dice view controller. We've also seen prepareForSegue and performSegueWithIdentifier. It's good to become comfortable with these methods and properties now, because they'll all come into play again soon as we begin to work with navigation controllers. Let's go ahead an implement prepareForSegue in our RollViewController file. I want you to pay close attention to this segue argument, because it has some information that we really need right now. In particular, the segue has this destinationViewController property, which in this case is the DiceViewController. And now that we have a reference to the DiceViewController, we can set the dice values. And now let's try running it. Sweet! We've got dice! Here is your next challenge. In this Rock Paper Scissors App, the user selects from three buttons. Then, a view is selected with a response from their opponent, the phone, and a win, or lose message. Your challenge is to present the results Results of a match in three different, a different way for each of the three buttons. Implement presentation of the results of your controller from the rock button programatically. Implement the paper button using a combination of code and segue. And implement the scissors button using only storyboard, apart from the prepare for segue method of course. Congratulations on completing this lesson. Now you should be familiar with presenting out of the box and custom view controllers. In the next lesson, we'll be talking about the delegate design pattern. In the previous lesson, we looked at different ways that one view controller can present another. In this lesson, we're going to learn about the delegate design pattern. Many of the most common views in UIKit use this design pattern, including text views, pickers, tables, and collections. Delegates are used to make important connections between model, view, and controller. We'll start out by focusing on how the delegate pattern is used with text fields. We're going to make an app with three different text fields. Each embellishes text in its own way as you type. Our goal is to use delegates to create many different customized behaviors using just one view. The first turns the words cat, dog and fish into emojis. The second sets the text color to be a combination of color words used in the text. And the third is related to a label which keeps a character count as you type. For all three, the text field views themselves look the same. They're used directly off the shelf as written by Apple engineers. The differences in their behavior come entirely from delegates. A delegate is an object that executes a group of methods on behalf of another object. The ability to reuse views without needing to subclass and modify them is an important goal of all graphical user interface libraries. We want view classes to be used as is, and then we want control and model classes to have the freedom to customize those views. The delegate pattern allows for this. Let's look at some examples of view reuse and customization in the apps we use everyday. Here in Safari, you can see a text field that was designed specifically for searching. It has custom completion and is often presented with a table view of search results. If we look in settings, we see a table that uses the same view class as the search tables, but they look and feel pretty different and present content in a different structure. How does the delegate pattern enable the same view classes to serve such different functions? Once you're on the correct branch go ahead and open up the text fields project and run it. Type into all three fields and watch for similarities and differences in the behavior of the three views. Also if you need to dismiss the simulator keyboard you can do that in the Hardware menu. Go to Hardware > Keyboard > Toggle Software Keyboard. You can also use the shortcut Cmd+k. When you've picked out some commonalities across the text fields. Answer the quiz question. Compare and contrast the following features of the three text fields. Presenting the keyboard. Response to new characters being typed. Rounded corners. Reaction to the return button. And behavior when editing begins. Mark features that differ between the three with a check. Hopefully, you marked response to new characters being typed, reaction to the return button, and behavior when editing begins. So what governs these differences? The unique behaviors of each text field come from the delegate. In other words, the control object. But apart from their content, the text fields look identical. Their similarities, like presenting the keyboard and rounded corners are governed by the UITextField object. In other words, the view. One way to think about a delegate is to imagine that each key difference one sees across views of the same class, corresponds to a question that the view could ask of its delegate. For example, what should I do with these new characters? How should I respond when the return button is clicked? What should happen when editing begins? in other words, the view needs some other class to decide what to do with user input. So, what kind of object can answer these questions? The view's delegate is usually, but not strictly, going to be a control object. It makes sense for control objects to answer the view's questions, because control objects are designed to perform tasks like passing user input to a data model. The key to the delegate pattern, is that the view establishes the questions that it needs answered and encodes them in a protocol. A protocol is a list of methods that a delegate must implement. Any object that fulfills the protocol can become a delegate. If the only difference between the three text fields is their delegates, can we swap the delegates and see the behaviors swap? Let's look into the project and give it a try. If we look over here in our outline, we can see our three text fields and our label. And if we select a text field and look in the identity inspector, you can see that its class is UI Text field. None of these views have custom classes. Now, let's close these windows. And switch back to the project navigator. Here, you can see the emoji text field delegate and the colorizer text field delegate. They each have a class to themselves but you're probably wondering where the third delegate is. Here in the view controller.swift file, you can see that our main view controller is also a UI text field delegate. It's going to be the delegate for the character counter. If we look a little closer at our view controller.swift file, you can see here are the outlets for our four views. And here are the two delegates and if we scroll down here, to viewDidLoad. We can see that each of the delegates gets assigned to a text field. And that the delegate for the character counter, gets assigned to self. If we swap the delegates, the behavior of the text field swaps as well. You can see here that I have switched the colorizer and the emoji delegates. So, let's see how that affected our text field behavior. And here, you can see that the behaviors have swapped. The first text field is acting as the colorizer and the second text field is acting as the emoji fire. We can do this because the three text fields are identical. The only difference is supplied by the delegates. In a little while, we're going to trace the flow of control through the objects in this app. That way, we can see exactly how these text fields interact with delegates, using the UI text field delegate protocol. Welcome back. Now we're going to use an object diagram to clarify how text fields interact with delegates using the UI text field delegate protocol. We'll start with the view controller. Which of course has outlets to the four views and here are our views. Up here our colorizer are and the emoji delegates. You can see that each of the corresponding UI text field view objects has an outlet pointing to a delegate. These objects can be delegates because they implement the UI text field delegate protocol. This third text field has the view controller as its delegate. So the view controller also needs to implement the UI text field delegate protocol. So why would we want to use a view controller as a delegate? Because the view controller's role in the architecture is to manage all of the views. The behavior of the third text field is connected to a label. The label is updated with the character count whenever the text in the text field changes. Now I want to walk through the method indication so we can clarify how the delegate pattern is used to keep the character count label up to date. So if we were to trace the user's actions, the user's going to tap on the third text field tap a key on the keyboard and then the number is immediately updated. Now let's step through that sequence of events again in our diagram. The user taps the keyboard. The text field realizes that the text will change. The text field invokes the method should change characters in range. All of these methods happen behind the scenes. The text field invokes the method. Should change characters in range. The view controller receives that invocation. So it updates the label. And it returns true. If we zoom in on the ViewController.swift file, we can see the code for some of these steps. We won't be able to find these first three steps in our code. Those are happening behind the scenes. The first step we can see is number four, when the invocation comes in from the text field. Here is step five, where the variable new text is being set to the characters we just typed. Here's step six, where the text of the label is being set. And here's step seven, return true. Notice again that you don't get to see where the UI text field delegate method invocations begin. We just implement the protocol and handle the indications as they come in. Now let's take a quick look at the other two delegates. The emoji and colorizer text fields have some minor differences in behavior. For example, in the emoji text field, if there's text, it clears when editing begins. So it's not possible to edit existing text after you switch to a different text field. Also, the return key in the emoji text field doesn't hide the keyboard. The colorizer doesn't clear text when editing begins. So it's possible to edit existing texts. And in the colorizer text field, the return key does hide the keyboard. So, given what you know about the two delegates and the protocol, which methods do you think the two delegates implement? When a user first taps inside the emoji text field any existing text clears. If you are able to discover that the text field did begin editing method is called as soon as the user taps inside a text field you probably guessed that this method is being implemented in the emoji text field delegate. Both the emoji text field and the colorizer text field are manipulating user generated text. So we can guess that their delegates both implement, should change characters in range. We also know that in the colorizer the keyboard dismisses upon pressing return. So we can guess that the colorizer delegate implements text field should return. The text field id end editing element is a good place to save text once editing is finished. Notice that neither the emoji nor the colorizer text field does anything with the text after editing is finished. Let's take a look at the emoji delegate. If we look inside the text field did begin editing method down here at the end of the file, we can see in this line of code that as soon as the user clicks into the text field the text is cleared. So what about the rest of emoji delegates functionality, lets scroll up to the top of the file. Up here we can see a dictionary that maps animal words to emoji symbols to replace those words with. By the way, don't worry if you've never seen a dictionary before. We're going to discuss swift dictionaries in the next lesson. Most of the action is happening in this should change characters in range method. Whenever the text changes, the delegate is told. Then it proceeds through these steps. It constructs a new string. It looks for each emoji string, and then replaces emoji strings with emoji characters. If we replace a string with an emoji we return false here. And if not, we return true. And let the text field modify the text. Now let's see how the colorizer works. Remember the colorizer closed to the keyboard on pressing. Which is probably the user experience we're after. So let's take a look at how this was done. You'll want to scroll down to where the text field show return method is. And here in the text field show return method you can see this call to text field resign first responder. Anytime a keyboard starts editing, we say that it becomes the first responder. That's why touches to the keyboard only show up in the current text view instead of all of them. Resigning this first responder status dismissed the keyboard. So what else is going on in this delegate? If we scroll up to the top we can see just like the emoji delegate. This colorizer delegate also has a dictionary. This dictionary maps color strings to UI color objects. Whenever the text changes, this loop finds all of the color words in the new string. It creates an array of color objects corresponding to the color strings, and then passes that array into a. Helper method, which blends the colors. You can see this blend color array helper method down here, and here you can see the text color of the text field is being set to the blended color. Now you're ready for your next challenge app. And this random color app the colorizer text field has been changed so that it randomly changes color every time the text changes. This is achieved with the random color text field delegate. I'm going to walk you through the steps to create the random color text field delegate. Then you can run through the steps on your own to see the random color app in action. The first step is to create an empty random text field delegate class. To do this just control click on the folder where you want to put it. Then go to New File. Choose swift file and then name it. Next you'll want to import UI kit, define your class, subclassing NS Object and declare the UI text field delegate protocol. Inside your new delegate class, you'll need to create a method that will return a random color. If you need some help writing this method, there are some helpful suggestions in the next reading node. You'll also want to implement the method textField shouldChangeCharactersInRange. This is where you'll set the color of your text. And then the last two steps are in the viewController.swift file. You'll need a variable for your new delegate. And then assign that delegate to one of the text fields. After you've completed those steps, run the simulator and verify that it works. Now you're ready to write your own delegates. The challenge up for this lesson has three text fields with customized behavior. A zip code text field that only allows digits with a maximum of five digits. A dollar sign text field that begins with the text for $0.00, and then fills in the dollar figures as digits are added. And finally a text field that can only be edited when this switch is set to on. Here in the first field once I get to five digits I can't type anymore. Here in the second field the digits fill in from right to left. And there are always two digits beyond the decimal. By the way, don't forget that Cmd+K toggles the keyboard. In the third field, the user has to flip this switch in order to add text. You can see that tapping inside the first two fields brings up the number pad instead of the QWERTY keyboard. You can set this in the attribute inspector in Storyboard. Actually, let's open up the utilities pane and take a minute to explore the attribute inspector. This is a super convenient way to configure UI kit view components. Here you can set your placeholder text. So you might want to to put something like, Type your zip code here. Here you can configure the clear button like the one you saw on the Safari search bar. Here you can set capitalization. If you add something like a confirmation code, you might want all characters to be capitalized. And here's the keyboard type, which for the zip code we want set to number pad. And just two more tips before you move on to the challenge. You're going to need to set the delegates for your text fields. If you want to do this in Storyboard remember your delegate is just a property. So you're going to look for it in Storyboard where you always look for properties, in the pop-up connections menu. And here under Outlets you can see your delegate. Also, for manipulating text you might want to revisit these two lines of code from the emoji textField delegate. The end of the string class has a method named stringByReplacingCharactersInRange. It's perfect to use in a UI text field delegate. This method is helpful when you need to build new strings from typed input. In order to use this method, Swift strings are usually cast to NSStrings. In this case the variable newText represents the text that will be displayed. Yes! You're halfway through the course content. Now it's time for the fun part. Working on the first version of the meme app. Your chance to put into practice what you've learned about constraints, UI controls, text field delegates, and modeling presented views. The next lesson has a different tone. It's a self guided format for working through the particular skills necessary for meme. We're going to ask you to look into a few new topics as well. Like keyboard animations and notifications. But don't worry, I'll guide you through the trickiest parts. You've done an excellent job making it to this point. Now get psyched to start on the portfolio project. In lesson 3, we looked at text field customization. We created delegate objects which implemented the protocol that the UI text field class was designed to use. In this lesson, we're going to look at table views. And, you'll see that they're more complex, but that their architected in a similar way, just like text views, table views use delegates. Both view classes need view controllers to implement delegate protocols, in order to invoke the methods they need. Methods that would be inappropriate to implement inside of view class. Again, with tables, you'll see that we can customize UI kit views by implementing their protocol methods in our own way. Remember, that through protocols, views are able to ask a series of questions of their delegates. Protocol method invocations begin in the view, and call upon a control object, which is often a view controller. Table views are considerably more complicated than text fields, in fact, tables use not one, but two protocols. One of those protocols has 33 methods, and the other has 11. Tables are a cornerstone of UIKit and they're very customizable. That's the huge method count. We're not going to go through all 44 methods now though. It turns out not every method in a delegate protocol is essential. So, we'll focus on the most important first. Is it true that some protocol methods get used more than others? Think about the UI text field delegate, and then answer the quiz question. Which method did we use the most to customize the text fields? In our text field apps, shouldChangeCharactersInRange was implemented the most frequently. Now, let's take a look at UI tables in iOS apps, and start identifying the most essential of the 44 delegate methods. Let's start with a table view from the iOS Health app. Here's the table for Health Data. If we dissect the content view for each cell, we see a UI ImageView, a UI Label, and another UI ImageView. Here in the Maps app, you can see that as I type, the table is rapidly being repopulated. But, the components of the small views, the magnifying glass icon, the placement of the text, those are repeating. In both Health Kit and Maps, you see an image here on the left margin. And, you see the same font in the text field. These top views are instances of the same view class. The Search bar is a stock view that we're going to use, as well, in our practice apps. If I return to the map of San Francisco, and drop a pin on Golden Gate Park, clicking that pin gives me another table view. Here the cell separators are similar to the ones we just saw. But, there are no image views, and each cell contains a button. Here in my contacts, the table cell views are separated into sections. But, in this lesson, we're just going to stick to one section. Here, in the albums table of the photos app, we see a similar structure. But, the smaller views are formatted a little differently. The image views are larger, and we see two labels with custom font sizes. Stop for a moment, and think about which of the pixels on this screen are actually drawn for the table view, per say. Because, the screen is filled up with these smaller repeating views, the pixels that are being drawn are contained in the smaller views. These small repeating views are called cells, they're subclasses of UI TableViewCell, which is a UI view. Tables tile the cell views vertically and draw in separators. Think about the different tables and their similarities. What kind of data is necessary to populate a table? What kind of data model could be used to populate this table? The view in each row shows the same three things, the album name, an image from the album, and the picture count. Then those rows are repeated. So, this table could be a representation of some ordered list of similar items, for example, an array. Which of the following models might be used to construct this table? An array of structs? An array of dictionaries? We can only speculate about the real photo app code, but it's probably something like the array of structs. But, for many tables, the dictionary technique would work fine. Note that in both answers, there is an array of repeating data objects, and each data object can be used to build a single table view row. We'll experiment with both types of data structures and we have a SWF session coming up on array and dictionary syntax. No matter the data structure, the table view will need to ask questions of its delegate in order to access the data in the model. Let's take a closer look at the delegate methods that make this possible UITableViews have two delegate protocols, with a total of 44 methods. The two protocols are the UITableViewDelegate, which governs responses to user events, and the UITableViewDataSource, which enables the table to access data in cells. So, think of the delegate as being associated with events. And the data source is being associated with data, appropriately enough. The table uses its delegate protocol to ask event questions like these. What should happen when a button in a cell is tapped? What should be the response to cell selection, how should I respond when a user begins editing a row? What should happen when a cell is deselected, the table uses it's data source protocol to ask data questions like these. How many rows do I have, how many sections do I have? What are the titles for the sections, what is the cell view for each row? Here I've opened the class reference for the UITableViewDelegate. Where you can find a complete list of the protocols methods. Many are related to managing sections, like the ones we saw in the context and settings apps. Don't worry about those as much for now, since we'll be focusing on single section tables. Visit the documentation on your own, skim through the list. And for each method, think about the question that the view is asking its delegate. When you're done, answer the quiz question. Think of yourself as a table. If you could only ask three of these questions and you needed to build a single section table, which would you pick? You'll find that the essential interactions are how many rows, what is the cell for each one, and what should happen when a row is selected? The first two are required to build a table at all. We'll see that tables ask how many rows they have, and then for each row, they ask for a cell view. After we build some tables, we'll look at what should happen when a row is selected. This is the most common way that users interact with tables. Okay, let's prepare to look at the actual methods. You remember the textField should change characters and range method. Notice that the first perimeter of the methods in the textField delegate was always the textField itself. It will be the same in the tableViews two protocols, notice that the tableView method has an argument named indexPath. This is a struct with two members, row and section. By the way, for more on structs, see the instructor notes or peak ahead into the Swift section in lesson five. When the table wants to get the cell for a particular row, it invokes a method asking for the cell and it passes in an indexPath object with the row property set. Similarly, when a table wants to alert its delegate that a row was selected. It invokes the appropriate method and passes in an indexPath object with the row property set. Remember, we're interested in the following three questions that the table will ask. How many rows? What is the cell for each row? And what should happen when a cell is selected? Which method signatures corresponds to these questions? The essential methods are numberOfRowsInSection, cellForRowAtIndexPath and didSelectRowAtIndexPath. The first two are data source protocol methods. And they're so important that they're the only required methods in the protocol. If you keep writing IOS apps, before long you'll have written dozens of tables, and these methods will become second nature. The third method is used all the time to respond to the user selecting a row. We'll see it a little bit in this lesson and a lot in Lesson 5. Okay, time to actually create a table. Here you can see a simple app that creates a table showing someone's favorite things. Remember that at the very least, this table needs two things from its data source. The number of rows, and the cell for each row. If we focus on the ViewController.swf file for a second, here we can see the favorite things model, which is just an array of strings. So how does the UITableView know how many rows it has? A table view finds out how many rows it has by asking its data source. More specifically, by invoking the data source protocol method, number of rows in section. Check out the get branch in the instructor notes. And inspect the project in ViewController.swf files. Play around with the methods to see what they do, and then indicate your choice below. Given that the table will invoke this method on the view controller, which implementation seems right? The first implementation is definitely the way to go. When it runs, the table looks empty, but I am able to select the first four rows, which tells me that the row count is correct. Notice that if I add an item to the array, in this case, Brown paper packages tied up with string, now there are five selectable rows in my table. It's still empty though, so let's see what we can do about getting those cells populated. Well that was easy. The next method is a little more complicated. Self erode at index path is the method that the table view uses to get cell objects one at a time. There's a challenge in the implementation of this method. It isn't so difficult but sometimes it trips people up. This challenge comes from an optimization that tables need. Consider how fast we like to be able to scroll through tables. iPhone users want to be able to swipe along a list in a split second. It's an interesting technical challenge each row is a fairly complex view object. If we have to swipe through a few hundred rows that's a lot of objects to allocate. Too many objects as it turns out. If every cell had to be allocated as it appears on the screen the scrolling would get choppy. So Apple's worked out a caching scheme to reuse these cell objects over and over. Kind of like stairs on an escalator, when cell objects scroll off the screen they get reused on the other side. Anything that is shared across cells gets reused, cell border, image placement, recurring control elements, recurring labels, the structure of the cells data. This means these shared elements don't need to be re-specified when a cell comes onto the screen. Only the data needs to be re-specified. At any given time, there will be a few TableViewCell objects that are off the screen in a queue waiting to come back on screen with new data. Because of this, we never need to construct cells ourselves. The queue is kept inside the table view so whenever we need a cell we dq one from the table view, populate it with data and we're good to go. Some tables combine more than one type of cell. To accommodate that cells are tagged with string reuse identifies to keep them separate. In those cases the tables keep separate queues for each type of cell. Our favorite things table only needs one kind of cell. But we'll still need to give the cells a reuseIdentifier. All right, let's figure out what the code should look like. When a table invokes the cell for row at index path method, it passes the control object and index path. An index path is a struct that holds the row number. In order to populate our table cells, there are a few steps we need to perform in this method. The first step is to dequeue a reusable cell from the table. Using the correct reuse identifier. The second step is to find the model object that corresponds to the row in question. The third step is to set the images and labels in the cell using the data from the model object. And last but not least, return the cell. For the favorite things app, we'll use a standard table of U cell. It comes with the UI label property named text label. And our reuse identifier will be FavoriteThingCell. Here are three different implementations of cell for row at index path. Which of these three performs all four of the steps previously outlined? To try out the different methods, check out the branch in the instructor's notes. It's this third option that captures the necessary steps. In the first line we deque the cell. This requires a cast because the method returns an object of type AnyObject. In the second line we use the indexPath.row value as an index into our array in order to get the string that corresponds to the row in question. Then we use that string to set the text of the label in the cell. And finally we return the cell. And notice that we've written this method so that it will work with any value of index passed out row. Next up, you'll get a chance to practice your table view skills with a new project named, Doe, Rae, Me. So far, we've been discussing the role that the view controller plays as the delegate and data source for a table. We've also implemented the methods, number of rows in section, and self row, and index path. Now let's do something different. In the favorite things app, the table was already set up in storyboard and you wrote the view controller code. In the next step, Bond villains, we'll do the opposite. The view controller is ready to go. Your job is to set up the storyboard. This app displays villains from James Bond movies along with their evil schemes. In the version you're about to check out, the model and view controller are complete, but the table doesn't exist yet. We need to add something to this empty Bond Villain storyboard. Let's start by outlining the steps required to set up a table and connect it to the villain view controller. Step one, add a table to the main view. Step two, add constraints so that the table fills the view. Step three, connect the table's data source property to the view controller. Four, create a prototype cell and five, set the cell's reuse identifier. Many of these steps will be familiar to you. Put a check next to the steps you're already comfortable with These first three steps, we've seen before, but these last two are new. Next up, we'll go through each step in Xcode. And now for those steps. First, we drag a table into the view from the object menu. It'll automatically expand to fill the whole view. You'll want to drag this upper border down a bit so that it ends up a. Below the status bar. Next we bring up the constraints menu, and add constraints for the borders. And once the table's in place, we can connect the data source. So Ctrl-click on the table to open up the pop-up connections menu. Then you can drag from this data source property to the view controller icon. You're probably familiar with those steps by now. Here come the two new steps. Add a cell to the table by going to the attributes inspector, and setting prototype cells to one. If you click on the cell, you'll see it needs a reuse identifier. Let's go into the project navigator so we can double check what the cell was called in the Villan view controller. Here you can see the VillanCell. Is being dequeued. So, here we can see our reuse identified to be VillainCell. By the way, when you're entering text into these cells. Make sure you always hit return. Otherwise storyboard won't save it. This is weird behavior, and the source of a lot of frustration for both new and accomplished developers. And those are the steps for setting up a table view in storyboard. So let's run it and see how it looks. So you can see that the pictures and names are there, but not the evil schemes. That's because of the cell style. If you go back into the attributes inspector, you will see this drop down menu labeled style. Here you can see your options for cell styles, and we'll have more details on that in the next section. We've updated the rock, paper, scissors app so that it keeps a running history of each match you play. The challenge for this lesson is to add an additional view with a table to show the history. This is one example of how the completed app could look. Note that the challenge combines the material of the past two lessons. We'll segue to a new view and the new view will be a table. Let's take a look at the code that's been added. Here you can see that the RockPaperScissorsViewController has a new property, an array named history. We know that this array is going to be filled up with results from matches. Let's find where the matches are being added. Here in the throwDown method, in this line, you can see where the matches are being added. The history array will be the model that drives the table. The model that determines the number of rows, etc. Right now the history table is kind of bare. The cells are using the right detail cell without adding an image. For the challenge up you're free to create any cell you want. You can create images for winning and losing, different text sizes, fonts. Go nuts! If you are interested in adding your own custom cell views, in the next section we have a few notes to steer you in the right direction. You just learned how to implement table views. Your first complex views. This opens up so many possibilities for new features you can build. In the next lesson, we'll get deeper into how to smoothly incorporate those tables into your app's navigation structure. In lesson two, we looked at different ways that IOS apps present multiple pages of content. We said that we'd return for a deep dive into how side to side navigation presentation works, and here we are. Using navigation controllers is an absolutely fundamental skill. We're also going to take one more step with the iTable views and make and app that responds when a user taps a table row. An essential interaction when navigating a multi page app. Let's look at a few examples of side to side navigation. Here in the settings app, you can see that taping on a cell drills down into the next layer of the navigation hierarchy. The settings app has multiple layers. Let's say, I want to change my Siri settings. I tap General and then Siri, Language, and then I can give Siri an Australian accent. I can always return to the previous view with this Back button, ultimately bringing me back to the root view controller. Notice how intuitive this flow is. Users have come to expect this type of movement through a layered structure. If you take advantage of iOS UI conventions in your app design. Your users won't need to be told how to find what they're looking for. But let's check out the IOS music app. If I go into the more tab it brings up a table of options. Then if I drill down into genres and country, eventually. I can bring up the songs from my favorite show Nashville. You can see how you table views are in IOS apps. This action button on the right takes me to the song that's currently playing. Once in the player, this action button brings up a with album info. Have a close look the nav bar. The back button and the title are standard. They're always there. The action button on the right is optional, but something you'll see frequently. How does the app know where to go, when the back button is pressed? When we drill past a page of content, where does it go? In other words, what kind of state is being managed by this navigation controller? We have to figure all of this out. Now take a look at some of your favorite third party apps and see if you can find these navigation features. A hierarchy of pages emanating from a table, a nav bar with a back button, and a nav bar with a custom right bar button. Check them off as you find them. Here in Spotify if I go into your music I see a table of playlists. Then if I drill down into one of those playlists, I see a table of songs. So I have a hierarchy of table views and the back button lets me retrace my steps. Here this custom right bar button lets me edit my playlists. In the playlist table the right bar button brings up a model of actions that can be taken on a song. To get some practice using navigation controllers and storyboard, we're going to build a Make Your Own Adventure app. It will look like this. It begins with the first line of a story and the user gets to choose what happens next. So here we've got a tiger and I think she should stalk to the door and peek down the hallway. So we press that button and it leads to the next part of the story. Let's work through the steps to make this app. Even though this app will have multiple views, I'm starting with the single view template, because it's the simplest. The first thing I'll do is delete this View Controller that was automatically generated, then I'll drag in a Navigation Controller. If you look in this automatically generated Root View Controller, you'll see that it has a Table View. But we don't need a Table View for this app, so let's go ahead and delete that as well. Then drag in another View Controller and we're going to set that to be the Review Controller. I do that by bringing up the pop-up menu for the Navigation Controller and dragging this Root View Controller property to this View Controller I just brought in, then I drag in a Text View for the story text and two buttons for the choices. Making sure to set the appropriate constants of course. This view is the first in a series that have the same UI components. So, once I have this text view and these buttons setup the way I like them, I'm just going to copy and paste the whole View Controller. I can do that by drawing a rectangle around the View Controller like this. Careful that second View Controller appears right on top, but it is there. Once we have our two new View Controllers, we can add some more text for the next part of the story. To segue way from one screen to the next, I bring up the Connections menu for each button and add a triggered segue, like this. Let's run it and see what we've got so far. Hm. I'm getting a black screen. That's not what I want, but I have a guess at why it's happening. I need to make sure my Navigation Controller is set as the initial View Controller. So, I go into my Attributes Inspector and I click this is Initial View Controller. Let's try it again. Okay, much better. So you can see I need to adjust my to my constraints a little bit on the buttons, but we've got a good start to our story. Now repeat these steps on your own and for more details and notes on how to polish up the app, consult the upcoming reading node. It would be good if when I get to the end of my story, I could start over. So that I can see all the different possibilities for the tigers fate. Here's what that would look like. Where in the storyboard, should we put the start over button? We could drag separate buttons into each of the end points in Storyboard. But we need to consider this, what class is the object that would receive these actions? If we look in the Identity Inspector, we see that the View Controller for each story node is a UIViewController. We can't add an action method directly to a Stock UIViewController class. The name of the subclass we're using is MYOAViewController, as you can see here in the project navigator. So, we'll go back to the Identity Inspector, and we'll add that class name so that we can programmatically add a button to each story node. By the way, a detailed review of these steps will be provided in the next part of the lesson. Okay. Let's see about adding that button in code. Every View Controller has a property called a Navigation Item. This item can be used to control the title and buttons. Here in the Navigation Item documentation, you can see that it has a right bar button item. With these two lines of code, we can add the right bar button item in the viewDidLoad method and specify the title, start over. Now, we'll run it and see where we are. Well, there's our button, but naturally it doesn't lead anywhere because we haven't set the target yet. Now let's implement the startOver method. How should we implement this method? Which class should be responsible for navigating back to the root of the app? In this case, the answer is the UINavigationController class. Each ViewController has a navigation controller property. It's an optional that references the navigation controller that a given ViewController is embedded in. When a ViewController receives the indication to start over, it can communicate with the navigation controller. And here you can see the careful unwrapping of the optional. We could just pop off the current view controller like this, but we want to go all the way back to the beginning. So we call popToRootView controller. Here's a recap of the two properties we just learned about. The navigation item property specifies features of the nav bar. The navigationController property provides a reference back to the navigation controller for programmatic control of view controller popping. Now take some time to get to know these properties and get that start-over button working for all the endpoints in your story. Let's think a little more carefully about how the NavigationController is keeping track of ViewControllers. A navigation controller has a stack of ViewControllers. Remember that a stack is a Last-In-First-Out data structure, like a stack of cups. It has two operations. Items are popped off of the stack, and items are pushed onto the stack. When we start the Settings app, the top level settings page is displayed with the title, Settings. If we click on Notifications, a new ViewController gets pushed onto the stack. We can choose to push a number of different views next. Phone, Messages, Passbook. Now the stack is three ViewControllers deep. We only have one choice if we want to pop. That corresponds to the Back button. You can see here beside the Back button that the navigation bar shows the title of the next ViewController on the stack. In this case, it's the Settings ViewController. How can we see some evidence of stack behavior. It'd be nice if we could see console output every time one of our view controllers was popped off the stack. Every time the OSD allocates a swift class including our view controller it calls a deinitializer. What if we put a print statement into the deinitializer like this. Think about what would appear down here in the console if a print statement was added to the deinit method in the ViewController for make your own adventure. Or see for yourself by adding this method to the ViewController class. Then answer the quiz question. ViewControllers are deinitialized. When they are no longer on the screen, they slide off the screen to the right, or they're covered up by a new Controller sliding in from the right. View controllers are deinitialized when they slide off the screen to the right. DeInIt is invoked as view controllers are popped off the navigation stack. I'm overriding the deinit method in the make your own adventure view controller, and you can see that when I press the back button one print statement appears in the console. If I press the start over button, two print statements appear in the console, one for each view controller that's popped off the stack. This deinitializer is only available in swift classes. What else is specific to swift classes as opposed to structs? We've seen both classes and structs in many of the apps we've built so far. How does one know when to use a struct and when to use a class? In lesson three, we wrote the rock paper scissors app, and we used three different techniques to present the ResultsViewController. One for each of these three options. For rock it was all in Code, for paper it was a named Storyboard Segue, triggered using Code. And for scissors it was a triggered Segue attached to the button in Storyboard. In the Make Your Own Adventure app, the segues have all been of this third kind. We've attached the segues directly to the buttons using a pop-up connections menu and storyboard. Automatically triggered segues are great, but all three of the segue techniques are available in navigation, the same way they are in mobile presentation. What would it take to reproduce the three segues in rock, paper, scissors. Using a NavigationController instead of modal presentation. In this segment, we're asking you to do just that, the next reading note will walk you through the steps to do so. The navigation controller works especially well when combined with the table. This arrow accessory on the right of the table view cell is a common UI component. It's standard to the master detail pattern. So what governs the appearance of this detail view? Here in the UITableViewDelegate protocol, you see the method didSelectRowAtIndexPath which we talked about in the previous lesson. When a table row is selected we want to show the details for the selected object. So we use the method didSelectRowAtIndexPath to push the detail view controller on to the navigation stack. One of the following code snippets was copied from the next iteration of the Bond villain's app. Which looks like the right way to push a detail view controller? This third option is the way to go. To push the detail view controller the table view controller proceeds in five steps. First it receives the invocation from the table view that a row has been selected. It gets the detail view controller from the story board object, looks up the object associated with the index path that was passed in, sets the data in the detail view controller, and finally, pushes the detail view controller on to the navigation stack. Let's implement the master detail pattern in the bond villain app. We're going to use the master detail structure in the Von Villain's app to show details on each villain. Here you can see the villain table and then if I could click on Jaws a detail view appears with an image and a label and if I go back I can do the same for any of the villains. You've already seen all the steps to build this now it's time to put them all together. Here's your next challenge app. At the beginning of the lesson we created a make your own adventure app using static segues. Now we're going to expand on that app using data driven stories. Here's the completed version of data driven make your own adventure. Here's the tiger story from the beginning of the lesson. Just like before we navigate through the different nodes by clicking on different prompts. Most of the story nodes have two prompts. But of course the nodes that ends the story have none. In a second will look at the code for the data model that drives these stories. Each node in the story has a struct. That describes the nodes message. And the prompts to move on to other story nodes. Right now, you're looking at a completed version of the app. But in the branch for step 5.5. The table view delegate and data source methods for the story node view controller have been left blank. When we run this incomplete version, notice that there are no prompts. Your task is to modify the story no View Controller so this table is working. Let's take a closer look at the data structure. The app has four stories stored as serialized versions of arrays in dictionaries here in the supporting files group. You'll learn more about how to store arrays and dictionaries in the iOS persistence course. So for now let's focus on how stored data is parsed into these model objects that represent stories. Here you can see that there's a class to represent each adventure. It has a credit's property for the author's name and the start node property which contains the first line of the story. Initially, these adventures get shown by the route table view controller. Here's the table view it governs and when the user selects a story, the story node View Controller gets pushed on to the navigation stack. Let's take a look at that code. So here we are in the route table view controller and we want to scroll down to the method didSelectRowAtIndexPath. So here's what happens when a user chooses a story. First you get the adventure object. Then you grab the first node in that adventure. You instantiate the story node View Controller from the storyboard object. Then you set the story node that's going to start that adventure, and get loaded into the story node view controller. And you push the story node view controller on to the navigation stack. The story node view controller shows one story note at a time. Let's take a look at the struct for that story node. Here you can see the message property that provides the text for the story. And then there are three different methods related to the story prompts. The prompt count which tells you how many rows that prompt table should have. The prompt text for a given index and then the story node objects to that a given prompt leads to. You can see that now that we have an underlying data model, we don't need all those view controllers like we had before, we just need this one story node view controller and we populate it with different data. Your challenge is to write the code that will populate the table of Prompts. And then perform a push segueway to the next story node when a prompt is selected. If you open up the story node View Controller, and you scroll down to the table view delegate and data source methods, you'll notice that they're either empty, or they just have placeholder data. Your challenge is to fill these methods in and get the app working. All right you've completed the course content. Now it's time for Meme 2.0 putting on the finishing touches. In this iteration we'll add navigation, a Table View, a Collection View and get even more practice with delegates. Similar to the lesson that guided you through the first version of Meme the upcoming lesson a self guided. And focuses on skills specific to building Mime. We're going to ask you to look into a few new topics as well. Like Tab Views, Collection Views and how to use a shared data model. These are not trivial topics as always be sure to reach out for help if you get stuck. You're almost done with the course. Now get psyched to bring your portfolio project to the next level.