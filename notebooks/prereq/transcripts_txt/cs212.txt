Hi. I'm Andy. I graduated college in 2009, and I started traveling the world, biking across the country, and basically living the life of a drifter. When I found out about Udacity, I decided this was the job for me. Last semester I TA'd Sebastian's class on Programming a Robotic Car, and this semester I'm going to be TAing Peter's class on the Design of Computer Programs. I'm going to be available in the forums to help you with your questions, I'm going to record supplementary videos when there's things that seem confusing, and I'll be there for you to yell at in case the grading scripts don't work, though I think we've got most of those bugs ironed out. See you in class. [Andy] This lesson is on list comprehensions. This is something that wasn't covered in CS101 but will be used in many future classes, including CS212. List comprehensions are a powerful tool for quickly and concisely creating lists. For example, let's say you have a list of the Udacity TAs like this, and maybe we'll want to write the TA names in uppercase because lowercase is a little bit boring. One way we can do this is with a for loop like this one. And let's see how it works. This for loop is really doing 5 different things. First we create the empty list baduppercasetas, and I've called it baduppercasetas to emphasize that this really isn't the way we're going to want to create such a list. Next it generates the indices, and it does that here. These indices will be 0, 1, 2, 3, 4, 5 because udacity_tas is a list of length 6. Then we iterate over these indices. Next we apply the upper function, and this is a function that just takes a string and converts all of the characters to uppercase. Finally, we append to the baduppercasetas list. And this code will be perfectly functional, but it is bad, it is ugly, and it is slow, which is why we have list comprehensions. And just to show that this code works, let's run it. And sure enough, we get a list of the TA names, and they are printed in uppercase. Using list comprehensions we could solve this problem in 1 line of code. And here Python recognizes that udacity_tas is an iterable. Iterable just means any object that can be iterated over. So for example, lists can be iterated over, strings can--and you'll see a lot of that in CS212 in the first unit--tuples--and if you don't know what those are yet, don't worry. These are all iterable objects, and this notation tells Python to iterate over all of the entries in udacity_tas, call each entry name, and then apply this upper function to name. The brackets indicate that we want to put the results into a list, and that's the list that we see down here: Peter, Andy, Sarah, Gundega, Job, Sean. And actually, I'd rather print each name on its own line, so let's do that like this. That's better. [Andy] Now, what if our data structure was a bit more complicated than a list with strings as entries? Here we have a list where each entry is a tuple, as indicated by these parentheses. For now let's just think of tuples as unchangeable or immutable lists. Each of these tuples contains a TA name, the country where that TA lives, and the course which that TA is currently instructing. This data is interesting, but I'd rather have it presented to me as a list of sentences, and we can do that with list comprehensions. So here we've turned ta_data into a list of strings, and each of those strings is a sentence about a TA. For example, Peter lives in USA and is the TA for CS262. How do we do that? We use the same sort of list comprehension we used last time, but now ta_data is an iterable and its entries are tuples. These tuples each have 3 entries, and when we reference these names here, here, and here, Python understands what we're talking about. Now let's have a quiz. Using the same structure for ta_data that we had before, I want to construct sentences but only about the country in which each TA lives. For example, Peter lives in USA, or Gundega lives in Latvia. I've given you 3 options for possible list comprehensions that may accomplish this task-- that given ta_data will produce the correct ta_country. And so which of the following list comprehensions will work? Check all that apply. And let's go through each of the options. This first option will not work. Since ta_data is a tuple containing 3 elements, we need to reference each of those 3 elements for Python to understand what we want. Here we only reference name, country; we don't even reference course at all, so Python gets confused and if you try to run this you will get an error. The second option looks great. It's readable; name, plus lives in country is very easy to understand. It references all 3 variables in ta_data. Looks like I forgot my closed brackets here. This third option will also work. It has 2 variable names, and we reference all 3 elements in the tuple, but I don't like this one as much as the second one. The reason being "x lives in y" doesn't remind me that I'm talking about a name and a country. As far as readability is concerned, I prefer option 2. And, you can see, if we try to run option 1, we get an error message--value error-- too many values to unpack. If we run option 2 or 3 however, we get exactly what we want. Let's introduce one more feature into our list comprehensions. Remember ta_data and ta_facts. When we ran this, we got a list of strings which each contained a fact about a TA. Like: Job lives in the USA, and is the TA for CS387. Well, what if we only want facts about TAs that don't live in the USA? So, in this case that would be Gundega and Sarah. Well, since these TAs are working remotely, let's call it remotetafacts, and all we have to do is add a simple "if" statement. And now when we run this, we only get these two strings about Sarah and Gundega. The addition we made was pretty intuitive. This "if" statement just says: "If the country is not the USA," then we're going to add an entry according to the rules we described earlier. I hope you learned a lot about list comprehensions. You should feel free to click the link below the video to learn even more, but now it's time to practice. Use list comprehensions to identify all the TAs who are teaching a 300-level course. So that's any course beginning with the number 3, which in this case will be Gundega and Job. You may want to use the string.find method to help you out here. Your variable, ta_300, should look exactly like this. And this is how I solved the problem. I assigned ta_300 to name + is the TA for + course for name, country, course in ta_data. And, notice I had to use this country even though it didn't show up here and that's because each of these lists contain 3 elements and I need to reference all three of those elements. I only did this if course.find for this string CS3-- because you'll notice all of the 300 level classes have CS3 in them--was not equal to negative one. Because, remember, find returns negative one when it doesn't find what you're asking for. And when I run this, I get exactly what I want. Good work. The first unit of CS212 uses poker as a vehicle to teach about the design of computer programs. If you don’t know the rules of poker yet, don’t worry, that’s exactly what this video is for. Now of all you know about poker is what you’ve seen on TV or in a casino, you may think it’s pretty complicated. There is that intimidating green table and it’s surrounded by some very serious looking people and these people often have very silly hats or ridiculous sunglasses and they are saying things like, raise, or all-in. Now if you ever want to actually play poker, you are going to have to learn what all this means. There is betting, there is folding, there is calling, there is raising, and it can get pretty complicated. There is a lot of strategy involved. But for the purposes of this unit, we only need to know the most basic aspect of poker and this aspect is common to every single variation of poker and that’s how hands are arranged because at the end of the day, all of these different versions of poker have to do with making the best five card hand that you can. Now these different hands each have different names and there are nine of them. So let’s talk about what each of these names mean and since this class uses python, I’ll start my numbering at zero. The best hand and this one that you almost never see in poker is the straight flush and here we have a straight flush. The suit here is hearts, so you can see every single card is a heart and they are all in sequential order, nine, ten, jack, queen, king. If you ever go into a poker form online, you would see these cards were in as 9H, TH, JH, QH, KH and that’s the system we’re going to use here. The next best hand is four of a kind and here we have a four of a kind with four aces and a six. The six is usually irrelevant to this hand but we’ll talk a little bit about how to break ties in class. Next best is the full house and a full house is just three cards of one rank, so here we have three tens and two of another, so two, twos. This hand is a full house so we would call it tens full of twos. Next is the flush and a flush is five cards of the same suit and here the ranks don’t matter. You can see we have a three, six, jack, queen and king but they’re all of the suit spade. Next we have the street and a street is just five cards in sequential order, five, six, seven, eight, nine and here the suit doesn’t matter at all. We have a spade, diamond, club, diamond and another spade. Our next hand is the three of a kind and three of a kind is just three cards of the same rank, so these three fours are what’s relevant. The queen and again in some special circumstances where we’re playing with multiple decks, they may be used to break a tie and again we’ll talk about that in class. Next we have two pair, for example, a pair of jacks and a pair of nines would be two pair. The second worst hand is a pair and a pair is just two cards of the same rank, here we have two threes. The eight, five, two don’t do much to help our hand here. Finally, we have nothing. So we could also call that high card because when two people who have nothing show down their hands, the one with the highest card wins. Here we have king high and this is really quite a bad hand. If you are ever in a casino, I wouldn’t go playing this and expecting win. And that’s it; those are our nine hands, straight flush, four of a kind, full house, flush, straight, three of a kind, two pair, pair and nothing. Noticeably design them all in number, zero through eight. This is one of the numbers we’ll be using in our poker program to compare hands. It turns out, we’ll need a few other numbers to distinguish between for example two full houses, six for six is inadequate, we’ll need to add some other numbers in there but we’ll explain that in class and for now you should understand the rules of poker well enough to follow on. [Norvig] Now, by all means, you should use the library functions like random.shuffle. That's what they're there for. But I'm going to allow a little bit of a diversion here because the shuffle algorithm is one that's important to me personally. It was the first nontrivial algorithm that I came up with on my own when I was in high school and one of the first cases where I saw that my teacher was just completely wrong. Here's the algorithm that my teacher was trying to describe to me. Of course, I went to high school in the Dark Ages before there was any Python, so it wasn't written in exactly this language, but I've translated it into Python to make sense to you. Here's what the algorithm does. It says we're going to keep track with an array of which items have been swapped so far, and then until they've all been swapped at least once, we're going to generate 2 random indices into that array and then swap them and record the fact that they were both swapped and keep going until all the items have been swapped at least once. So it looks like this. Again, we have this deck of cards and then we have a parallel array of the same length which tells us whether we've been swapped or not, and that starts out as being all false, while this one starts out being cards. And then we go through and we pick out random numbers. So say we pick out I and J as being here and here, and say we have a 9 of diamonds there. Then we're going to just swap the 2. And so we cross those out. We now have the 7 of spades there and the 9 of diamonds there, and we mark the 2 spots as being swapped. So now this one is true and this one is true. Those 2 spots have been swapped, and then we keep on going until all the elements of swapped are all equal to true. Then we know we're done. So that's what my teacher was trying to sell to me that day in high school. I was sitting in the back, and I just woke up and I said, "That can't be right." I just had this visceral reaction that said, "I can see what the algorithm does, "and I know it swaps everything, but it just seems too inefficient." "It has this loop that keeps on going, and it's not a for loop, it's a while loop." And it just seemed to me that it was possible that this loop could go forever. Depending on the choice of random numbers, this might never terminate, and that just seemed wrong. It seemed like there was a much better way. And in my head I came up with the shuffle algorithm that we showed before. Knuth calls it Algorithm P for permutation. It just seemed like that was the simple and correct way, and this was just too complicated, and that really bothered me. I thought that an algorithm should be guaranteed to terminate. [Norvig] Part of the problem with this approach is that it's not guaranteed to terminate. Another part of it is that even when it does terminate, it's going to take a little bit longer to do so. And the question is, how long is it going to take? Assume we have N elements in our deck. How long is it going to take for this algorithm to run? Would it be roughly on the order of N swaps or roughly on the order of N squared swaps or roughly on the order of N factorial swaps? Which of those do you think corresponds to the time it will take on average to execute this algorithm? [Norvig] And the answer is it will take about N squared on average. It will be more time proportional to N squared. And the way you can see that is to think about how long it's going to take to get the very last item of this swapped array filled in. So say all the items are true all the way through, except there's 1 holdout that we haven't got yet. This one is still false. About how long will it take until we randomly choose a number so that we can make this one be true? And the answer is there's N of these. And each time we're going through and we're generating indices, so it's going to take about N random numbers before we get that. So for each of these N elements of the array we can expect on average to take N or less. For the first one it will be easy. The second one will be a little bit harder. The last few it will be harder still. But in the average case, the complexity is going to be on the order of N times generating a random number for each of the N elements of that array or order of N squared altogether. [Norvig] Here is the algorithm I was able to come up with. Knuth calls it Algorithm P. Other people have discovered it before him, so it's been discovered over and over again. The idea is you just go through the deck and make 1 swap for each of the index i. And what we swap it with gives an equal chance for any of the items that haven't been seen yet to occur in position i. So again, we've got our deck and we're going through 1 at a time looking at each position. And when we get to a general position i, we're going to swap i with the range from i through to the end. So we're going to pick out for this element i any one of these elements and then swap them. Say we pick this one. Then we would swap those 2. And then we would move on to the next position of i. So the very first element we pick any element in the array, swap it into the first position, then we look at the second element and pick any element from the second on, swap it into that position and so on. And so we can see that every element in the array has an equal opportunity to appear at each position. So the qualities of this algorithm that I like is that it's so simple and clear. It just says in 1 statement. It makes it obvious that each location i can have any of the elements of the deck with equal probability. Now, there's one part of it, I guess, which is not the most clear, which is are we exactly right here? Here we've got N and here we've got N - 1, and that should bother you a little bit. Do we have this right? In general, ranges are tricky in Python because ranges go from-- If we say random range from i to N, it's not going all the way up to N; it's only going to N - 1. And the same thing here. If we say from range to N - 1, actually the biggest number there is N - 2, but there's N - 1 of them because we include 0. So ranges are always a little bit tricky. We can have these off by 1 errors. We want to make sure that we got this right, and so let's have another quiz. The quiz is, for that statement for i in range (N - 1), what would happen if we replaced the (N - 1) with an N? And the options are, would that give us an index error that we've gone too far into the deck and we have the wrong index? Would it give us a value error from random range? Would it tell us, "You've got the wrong number in there"? Would it give us no error but the results would be unfair in that 1 permutation of the deck might be more common or more probable than another? Or would it give us no error and still be fair but maybe just a little bit slower? [Norvig] And the correct answer is that there would be no error. It would still be fair. Each permutation of the deck would occur with equal probability, but it would take N divided by N - 1 times longer--just a tiny bit longer. We can see that what's happening here is if you remember what our deck looked like, when we got to the second to last element, we swapped the second to last element with a random selection from the last 2, so that's up to N - 1. If we changed the range to go all the way to N, then we would do 1 more step where we would swap the last element with an item in the range of just the last element. So swapping the last element with itself--that would be the only choice-- that wouldn't really do anything effective. It wouldn't hurt. It would just take a little bit longer. And so to avoid that redundant operation, we'd use N - 1 rather than N. [Norvig] Now, I said that with the correct shuffle algorithm, the Algorithm P, every permutation of the deck has an equal probability. The next question is, for the teacher's algorithm does every permutation have an equal chance? What do you think? Yes, they're all the same, it just takes longer to get them; no, some of them will be different, have a different probability; or no, some will have a 0 probability, that there will be some permutations that it's impossible for the teacher's shuffle to generate. Tell me which you think. This is a hard question. It takes some analysis to be able to figure it out. You may be able to tell just by looking at the algorithm, or you may want to write some code to analyze what the situation is. [Norvig] And the answer is that every permutation has a non-zero probability, but they don't all have the same probability. And let's see how I discovered that. I wrote some test code that generated this output, and what I did is I gave it some example inputs, some example decks, that were very simple. First I gave it the deck consisting of 3 items--a, b, and c-- and then I gave it the deck consisting of 2 items--a and b-- and I had it test for both shuffle algorithms--the correct algorithm and the teacher's algorithm. I had it generate a few thousand decks, shuffle them, and then figure out how many times each of the possible outcomes come out. For 3 cards there's 6 possible permutations. Both shuffle algorithms generated all 6. For the correct shuffle algorithm you can see that they're all about 1/6 of the time. 1/6 of the time would be 16.6667%, and they're all pretty close to that. For the teacher's shuffle algorithm, not so much. Notice that the combination abc only shows up 5% of the time, whereas some of the other combinations show up 27% of the time. Not very good distribution of probability at all, so there's something wrong with that algorithm. And it's even more obvious when we just give it the trivial case of a 2-card deck. With the correct algorithm it turns out to be exactly 50-50. It might have been 49.1, 50.1. This is just luck that it was exactly 50-50 in my simulation. But with the teacher's algorithm, way off. 1/6 of the time you get ab, and 5/6 of the time you get ba. [Norvig] Now I'm going to show you this program, test_shuffler, that produces the output you just saw to see if a shuffle program is correct, if it comes up with a balanced set of results. So what am I going to do? First I'm going to keep track of the counts of every result that comes back from the shuffler. I'm going to start counts off as a default dictionary. That means that its default value is the default value of integer, which is 0. So the counts all start at 0. And then I go from range(n), so n times, and by default we're going to go 10000 shuffles. We're going to make a list out of the deck that we get passed in. The deck is just a string of characters. That's the simplest thing to show. Then we're going to shuffle the input and then count the result. And result here is a list of items. We're going to join the list of items together back into a single string to make them smaller and easy to deal with, and then we just increment that count. So abcd comes in, we make a list, we make the list abcd, we shuffle that, maybe we get bcad, and then we increment the count for that result. Now, we calculate the expected count, what we expect to get, and that's 1 over the factorial of the number of items in the deck because all n factorial where n is the length of the deck items are equally probable. And so the expected count should be n times that. And then we say that the result is okay if the counts for each item-- The ratio of the counts to the expected value should be about 1. And we're going to say if it's within 0.9 and 1.1 of what we expect, then that's okay. If any item doesn't have that, then it's not okay. What we passed in as shuffler is a function, and functions have a name attribute, so we're pulling out the name of the shuffler and then we're just printing out the name of the shuffler, the deck we're shuffling, and whether it's okay or not, and then we print out the individual probabilities for each of the possible results. And then I made another function, test_shufflers, which takes a list of shufflers and a list of possible decks and it applies the test to the cross product of them. For every shuffler we test every deck and we print the result. We saw that the function shuffle1 was not a good function, so I'm trying to fix it up, and I have 2 attempts here called shuffle2 and shuffle3. We can see what's going on here. In shuffle2 it's almost the same as shuffle1, except when I pick out 2 random indices to swap, I'm only saying that swapped of i is true, and I'm not saying that swapped of j is true. Otherwise it's the same. In shuffle3 I go through the deck. Rather than have a while loop, I just go through the deck for each of the indices and swap that index with something in the random range of N. So in other words, we swap each of the elements in the deck with any one of the other elements. [Norvig] In this quiz we're going to consider each of the shuffle routines-- that is, the shuffle routine coming from Knuth, the Algorithm P, the shuffle1 that was the teacher's original shuffle, and the shuffle2 and 3 that we just saw. And for each of them I want you to tell me, is the runtime order N or order N squared, and is the result that we get back correct in the sense that all outcomes are equally probable? We already know that the shuffle routine is order N and it is correct, and we know that shuffle1 is order N squared and it's not correct. And now what I want you to tell me is for shuffle2 and 3 what's the order of complexity, and is it correct? If so, hit this check button. [Norvig] The answer is shuffle2 is still order N squared, and you can see that because it's similar to shuffle1 in the way it goes through and checks off the elements that are swapped. But it is in fact correct. It does give a balanced result that any outcome is equally likely, and you can see that by running the shuffler test on it. Shuffle3, on the other hand, has a nice order N runtime, but unfortunately, it's not correct. It's biased in the results that it produces. So in conclusion, we should stick to the original shuffle-- that is, not the teacher's function, not any attempts to fix it up, but the one I was able to come up with in class and the one that's in the literature of Knuth and others. [Norvig] Now, one more thing. Note that the shuffle routine--both the ones that we wrote and the random.shuffle from the standard Python library--return None. That is, they don't return a useful value; they just return nothing. And the idea of the shuffle routine is that they modify the input. So there's this eternal tension in programming between computing a result and doing something. So functions like square root and sine function and so on take an input and return a result. They don't modify the input, and they create a new value as a result. But functions or subroutines or methods like shuffle are different. They take an input and modify that input. They take the state of the world and do something to the state of the world rather than just compute a result. We talk of these functions that compute a result as pure functions and these that do something as impure, and I like to talk of them as subroutines rather than functions because they aren't functions in the mathematical sense; they have an effect on the world. You'll see that most of the code that I show in this class is of the computing type rather than the doing type. The main reason for this is that the computing code is easier to test. So if I wanted to write a test for a computing function, for a pure function, I can do something like assert sorted of the list ([3, 2, 1]) = [1, 2, 3]. A single line and I'm done. On the other hand, if I want to test a subroutine that does something, that affects the state of the world, I have to first set up some state. So let's say input = [3, 2, 1]. Then I have to call the subroutine or method, say input.sort, and then I have to inspect the state to see what happened. So I would assert that input is now equal to--oops. Let's make sure we have double equals signs there. Input is now equal to [1, 2, 3]. In this case there's not that much difference. We have a library method sort and a built-in function sorted. With the built-in function it's a single line to test. With the doing subroutine it's 3 lines to test. But in general, as we add more state and we have functions that do rather than compute, it's going to be more work to set up the state, invoke the method, and then test it, and it's easier to do the test for pure functions. And that's why I prefer them when they make sense and stick to the doing approach only when necessary. When there's a lot of state that we have to deal with, then we go ahead and write methods or subroutines that modify the state rather than write pure functions. Hi. I'm Peter Norvig. I'll be your instructor for CS212, Design of Computer Programs. I'm assuming that you have some background. You took CS101 or the equivalent elsewhere, so you understand the basics of statements, expressions, and data types in Python or some other language. Now, what this class will be about is the design process: how to take what you already know and put them together in order to solve a problem. We'll talk about some of the attributes of good programs-- correctness, efficiency, generality and so on-- and we'll give you a process for thinking about design: how to go from the uncertain stage of not knowing what the problem really is and working your way all the way through to a good solution. We'll also give you a set of tools that you can use along the way. I had a lot of fun choosing the examples for this class and working them out, and I think you'll have a lot of fun too, and when you're done, you'll have a real sense of accomplishment. So I hope to see you in class. Welcome to CS212. Now, in this class, you're going to be learning by example. So I will pose some problems to you and you'll get a chance to create your solution. And then I'll show you and discuss my solution. It's important to note that there's more then one way to approach a problem, and I don't mean that my solution is the only way or the best way. My solutions are there to help you learn a style and some techniques for programming. But if you saw problems a different way, that's fine. Good for you. All learning that goes on happens inside of your head, not inside of my head. So what's important is that you understand the relation between your code and my code that you get the right answer by writing out the solution yourself and then you can examine my code and maybe pick up some pointers and some techniques that you can use later. For example, suppose I ask you to compute the sum of a list of numbers. Here's the mathematical formula. And I ask you to write function, which we'll call ss, for sum of squares, which takes a list of numbers as input. If you've taken CS101, you might write a solution like this, initialize the total=0. We'll go through the indices of the numbers and for each one we'll increment the total by the square of the number, and then when we're done we'll return the total. So that's a perfectly good solution. No problems with that whatsoever. If you're able to come up with that you've done your job. But then after you come up with your solution I'll show you mine and mine might look like this, same function definition. But I might prefer a functional style rather a sequencial style where I'm return the sum of the squares of X for each X in number. Now maybe you've never seen something like this before maybe you didn't know about the sum function. Maybe you didn't know about this type of generator expression in line so this might all be new to you. Important point is that this solution of yours is just as valid as mine. So what I want you to do is just compare your solution to my solution and see if there's anything interesting or new in mine that you might pick up. I don't want you to say, hey, that's not fair, Peter, you introduced some new idea that I haven't seen before. Don't let that make you upset. Instead, I want you to say, well, my solution works, but this is interesting, too, and this is something new. I want you to be happy that you learned something new, and proud that you came up with a solution that is just as good. But happen to just use some different techniques. So remember, learning is not me saying something and pouring that into your head. Rather, learning is what goes on inside of your head. And it's up to you to make use of what I show you. So that you can learn. This class is an apprenticeship. You learned first by observing, then by trying it yourself when the next example comes up and then finally now you really got it down when you can take what you've learned and teach it to someone else, may be in the forums or may be outside of class. Now one final point. The problems in this class are hard, the best learning takes place when you're challenged and this class will challenge you. Don't worry if you don't get everything on the first try, use the forms to ask questions, view the videos more than once if you think that the helps, give yourself time to let new ideas sink in, you may have to see them multiple times before it makes sense so don't worry about having to review multiple times or ask for help. It's hard but it's fun hard, so welcome to the class, good luck. I hope you enjoy as much as I do. [Norvig] In this unit, we're going to talk about how to write a poker program. This is going to be an example of a general process where we start with a vague understanding and then we refine our understanding to have a formal specification of a problem, then we specify that into something that is amenable to being coded, and then the design process we end up with working code. So we'll follow these steps 1, 2, 3. The first thing I want to do in the understanding phase is make an inventory of the concepts that we're going to have to deal with, and so let's look at what we have. First we have this notion of hands. A hand consists of 5 cards, so here's an individual card, and a card has a rank and a suit. This card, the 5 of diamonds, the rank is 5 and the suit is diamonds. The main program we're trying to specify we'll call poker, and it takes a list of hands as input and returns the best hand. What's the best hand? Well, you can see the rules of poker. There are links to describe where we can look them up, and we'll go over them briefly throughout the course of this video. But we can say, for example, that this hand is called 2 pair. You can also say it's jacks over 2s with an extra 5, and the rules specify which hands beat which, which is the best ranking for each hand. So this is another concept that we have: the concept of a hand rank which takes a hand and maps to something like, in this case, 2 pair and maybe with some more details. And what are the concepts that make up the hand rank? There are 3. One is the concept of cards of the same rank, the same kind, and we'll call that n of a kind for 2 of a kind, 3 of a kind, or 4 of a kind. So here I have 2 of a kind in two 2s and in two jacks. This hand is a straight--5, 6, 7, 8, 9--because it's 5 consecutive ranks. Suits don't matter. And then the notion of a flush. This hand is a flush because all 5 cards have the same suit, and the ranks don't matter. So there are a few more details about the ranking. You can look it up on the links, see the Wikipedia article on poker hands. But now I think we're ready. We know about the types of data we have to deal with-- hands, card ranks and suits-- and we know about the sort of operations or functions on them. Now we're ready to move into the design phase. [Norvig] Here's a quiz question. I want you to tell me which of these possible representations for a hand do you think make sense. Somewhat this is subjective. You may have different opinions. So tell me all the ones that you think are pretty good and not the ones that you think are problematic. So it could be a list of 2 character strings, a list of tuples of numbers and strings, a set that was similar to the list, or just a single big string. [Norvig] My answer is I think these first 2 are both quite good. Either of them would work just fine. The set one I think would work great for a regular deck of cards with 52 cards, but it might not work well if you had wild cards or if you were playing with a big shoe of 2 decks. Then you might have 2 of the exact same card, and then a set can't represent that. This string has all the information, and so you could deal with that, but at some point you're going to want to break this string up into 5 individual cards. It's just easier to have that done right from the start rather than have to do the operation on it. [Norvig] So now I'm ready to tackle the main function, poker. And we said it takes as input a list of hands, and it's going to return the best hand. So it takes as input the list, returns the best hand. I haven't quite figured out how to write the function itself, but at least I've got the prototype going. Now, out of a list of hands we want poker to return the highest ranking hand. Do we know of something that will help us do that? Think about it. Do you know of a built-in function in Python that selects the highest ranking item from a list? If you do, go ahead and give its name. [Norvig] And the answer is that the function max fits the bill. Max is a function that takes a list as input and returns the highest ranking one. [Norvig] Just to make sure you understand max, tell me what these 2 calls will return. [Norvig] So here I have the 2 calls to max. And when I hit Run, I see the answers are 5 and -5. So the first call to max, what's the maximum of 3, 4, 5, and 0? That's 5. That's the highest number. The second call to max I'm using the keyword argument which says give me the maximum according to this function, so give me the maximum of these numbers according to the absolute value of those numbers. And the largest absolute value is -5 has the absolute value of 5, so that's the highest, and so that gives me the highest value. And so here we see the result -5 is the actual value which has the highest according to the absolute function, and so it tells me -5 is the best. [Norvig] So now you understand how the key argument to max works, and now let's assume that we've defined a function called hand_rank, which takes a hand as input and returns some sort of a rank. Now, given that, how would you write the definition of the function poker to return the maximum hand according to the highest ranked? [Norvig] And the answer is simple. We take the maximum out of all the hands, with the key equal to the hand_rank. I like this definition because it's so simple-- the whole body is just 1 line-- and also because it corresponds so closely to the problem specification. The specification says, return the highest ranking hand. The function definition says, return the max of the hands according to the hand_rank, which is basically the same thing. It's easy to see that the implementation matches the specification. Now, if we can just make the hand_rank function clear and correct, we'll be in great shape. But before moving on to defining hand_rank, which will be the most complex function that we will write, it's a good idea to think about how the functions will be used and to write down some test cases. There are several ways to write tests in Python, and here's the simplest way I know. That is, we define and then call a function. I'm calling the function here test, and test consists of some setup of some variables and then some tests that I'm writing with the assert statement. An assert statement in Python, if you haven't seen that before, says, I'm asserting that the following thing must be true. And if it's not true, then the program will stop and print an error message. If it is true, it'll just move on, and if the tests pass--here I have only 1 test-- if that test passed, then we'll return tests pass and print that. [Norvig] What is the one test I have here? First I've defined 3 hands. sf stands for a straight flush, fk stands for 4 of a kind, and fh stands for full house. I've defined those by taking this string, splitting the string up on the spaces, and so that will give me a list of 5 cards for each of these 3 possible hands. And then I've asserted that when we play a game of poker between these 3 hands that the winning hand is the straight flush. The whole idea of having tests like this is a vital part of software development. It's important that each part of the specification gets turned into a piece of code that implements it and a test that tests it. So here we have only 1 test. This is a test that tests part of the implementation of the poker function. If you don't have tests like these, then you don't know when you're done, and you won't know if you've done it right, and you won't have confidence that any future changes might not be breaking something. So remember, to be a good programmer, you must be a good tester. Write your test cases and test them often. I want you to add 2 more tests: 1 test that will test whether the winner between 4 of a kind and full house is correct-- and so what should that be? It should be 4 of a kind-- and another test that seems a little bit more trivial but testing if we have 2 copies of full house playing each other that full house indeed is the winner out of those 2. [Norvig] And here they are. It's very simple. We assert that when we call poker with 4 of a kind and full house that 4 of a kind wins and when we call it with full house and full house that, in fact, full house wins. [Norvig] One important principle of testing is to do extreme values. So in some sense, this is kind of an extreme value. We're testing 1 hand against itself. But there are other types of extreme values. What if the list of hands that's passed to poker has only 1 item or 0 items or 100 items? Well, poker is not usually played as solitaire, so there wouldn't be much point in having 1, but nothing in the specification rules it out. So add a test that checks when 1 hand plays that that 1 hand is the winner. What about 0 hands? The specification doesn't say, but it does say that the function poker is supposed to return a hand. And if we pass it a list with nothing in it, then there's no hand to return. So I think the best thing to do is to make it clear that when we're passed 0 hands that that's going to be an error. If you wanted to, you could return the value none. That might be a reasonable thing to return. But I think the best thing to do is just to say that that's an error. We also want to have extreme values. What if 100 people are playing poker at once, if hands is a list of 100 different hands? We want to allow that too. It would be unusual, and we'd need a big deck of cards with 500 cards, but it could be done. So I want you to write tests to check for 1 player and to check for 100 players. [Norvig] So here we have a test for 1 player, and I've chosen the straight flush. I could have chosen anything. I say when the straight flush plays solitaire, it wins. Here I've chosen a list with 1 straight flush and 99 full houses, and I say when 99 full houses play a straight flush, the straight flush wins. You may not know this notation, these types of operators in Python. We can take a list and multiply it by a number, and that just says repeat that list that many times. So 99 times a 1 element list is a 99 element list all with the same element, and then we can add 2 lists together, and that just says concatenate them. So this 1 element joins in with these 99 elements to make a 100 element list. This is far from a complete test suite. We would really want much more complete coverage of tests. Poker, we have 9 different rankings of the hands. We would want to have at least 1 for each of those, so there would have to be at least 9 tests and probably many more tests than that before we had real confidence that we got it right, but at least we got a start and we have some simple sanity tests within our test suite. [Norvig] I think it's a good time to return to hand<u>rank,</u> the most complicated function we'll have to deal with. We know hand<u>rank takes a hand as input, but what does it return?</u> We want it to return a value indicating the ranking of a hand, but we're not quite sure what that value should be. It has to be something that's comparable by max, so, well, why not a number? There are 9 different types of hands that we know about, from straight flush at the top to high card at the bottom, and we can number them from, say, 0 to 8, with 8 being the highest for the straight flush. So here's a sketch of a solution. We know it's going to be important to look at ranks, so let's get them first. We can extract the ranks with our card<u>ranks function,</u> and then we can say first we want to check and see if we have a straight flush. So if the ranks form a straight and the cards form a flush, then we can return 8, the highest value. Otherwise what's next? Four of a kind. And the only thing we need in kind is the rank, so I'm going to just pass that in. If the ranks form 4 of a kind, then return 7. And we could go on from there. I go through the cases 1 by 1. We have straight flush, we have 4 of a kind, we would next go to full house and then flush and so on. The question is, would this work? If we continued to flesh this out and we defined the 9 different cases to return the numbers from 0 to 8, would that give us a definition of hand<u>rank</u> that's a working program? And I want you to tell me yes, it would work fine in all cases; no, it would signal an error condition and crash the program; no, it would get some inputs wrong and some of them right; or no, it would get all the inputs wrong. Which do you think is correct? [Norvig] And the answer is that it would, in fact, get some of the cases right. In fact, it would get many cases right. It would get all the test cases that we've seen so far correct because in each one of those we can distinguish between 2 hands just by a single number. We can distinguish that a full house is better than a straight just because looking at the numbers that get returned. For a full house we would return a 6, and for a straight we would return a 4, and we know 6 is greater than 4, and so max would do its job and would give us the right answer. But it wouldn't give us the right answer in all cases. So for example, what happens if somebody had a pair of 10s and 3 other cards and another player had a pair of 9s and 3 other cards? With what we had written so far, pair turns out to be ranking number 1, and so the hand rank for this would be equal to 1 and the hand rank for this would be equal to 1, and those would be the same and it wouldn't be able to choose between them. But we know that we want the pair of 10s to outrank the pair of 9s, so we've got to come up with some way to make that comparison so that we're able to distinguish between 2 rankings that are the same in terms of what they're called. They're both called pairs, but they differ in what they are: a pair of 10s versus a pair of 9s. [Norvig] It looks like that means that we're going to have to use something more complicated than just this ranking from 0 to 8. I'm going to propose a couple possibilities. One possibility would be to continue to return integers but to use bigger ones. So let's take an example of what we want to compare. Let's say we have 2 hands that are 4 of a kind. One has four 9s and a 5, and the other one has four 3s and a 2. We want this hand to rank higher. Under the old formulation, they would both be ranked as a 7 because 7 is the rank for 4 of a kind. So if we want to change that to use a different type of result, we could use integers and we could say, let's say, 70905 and 70302, so the 9 and the 5 to represent that this is 4 of a kind of 9s with a 5 left over and the 3 and the 2 to say it's 4 of a kind of 3s with a 2 left over. We could use real numbers. We could say 7.0905 or 7.0302. Another possibility is we could use tuples. We could use 7, 9, 5 versus 7, 3, 2. A tuple is just like a list, except it can't be modified and it has a slightly different set of operations associated with it. But basically, it just means a grouping of 3 values in this case. What I want you to tell me is out of these 3 possibilities, which one of them would work at all and which one of them seems best in terms of being most convenient and easy to work with within our program? [Norvig] And the answer is that all 3 of them would work just fine. We could make it work in all cases. It makes the necessary distinction. And in each of these cases, the entries in this column are greater than the entries in this column, and so max could do the job. But it seems to me that the case with tuples is the most convenient. Here with these integers or reals we'd have to be doing very complicated arithmetic to add things up and then break them apart to make sure we got the right answer. But with the tuples it's simple. We just use a comma operator. We say start with a 7, add in what we have 4 of a kind in, add in what we have the remaining 1 card of, and that gives you the 3 values, and we don't have to deal with any complicated arithmetic. Now, if you aren't familiar with tuples, you might want a little bit of practice to understand how they work. We said that 7, 9, 5 is greater than 7, 3, 2. So in other words, this expression is a true expression in Python. And the way the evaluation works is you first look at the first element. If one of them is greater, then that element is greater. If they're the same, then you go on to the second element. So in this case, 7 is equal to 7 so we move on. 9 is greater than 3, and so that means this guy is greater than that guy. You may have seen a similar type of thing in ordering between strings. So we can have the string 'hello' and compare that to the string 'help', and we do it in exactly the same way that we compare tuples. We go left to right. H compares to h. They're the same, so we move on to the next character. E compares to e. They're the same, so we move on to the next. L is equal to l. Move on. And here we have an l and a p, and p comes later in the alphabet than l, so help would be greater than hello, or hello would be less than help. The same type of idea, and this is known as lexigraphic ordering. It's so called because lex meaning words. This is the way that words are ordered. But we use the same name when we're comparing strings or when we're comparing lists of numbers or lists of any other type of value. We can understand the ranking that we're going to assign to this hand, by the way a Poker player would call out his hand, when asked to reveal it. So our player declares "Straight Flush, Jack high!" That's all you have to know about the hand. A straight flush, the highest ranking, and then the tie-breaker. All we have to know is that the Jack is the high card. So the number 8 stands for straight flush, and the number 11 stands for Jack, and that completely describes the hand. Here's another hand. Let's see what our player would declare for this hand. "Four Aces, and a Queen kicker!" So, four Aces is the major rank, which is a 7. Ace is card rank number 14, and the Queen is card rank number 12. So that's the complete description of the hand: <7, 14, 12> Let's do another one. What's this hand? "Full house, eights over Kings." So even though a King is higher than the 8, The 8 is what counts more importantly, because there's three of them. So a full house is major ranking number 6, then the 8 because there's three of them, then the King, which is 13. That's the remaining card. That three element tuple completely describes this hand. Here's another hand. How do we declare this one? Our player has called "Flush 10, 8," describing the two highest cards in his hand, because that's usually enough to distinguish the the hand from all other flushes that might be out there. But in actuality we might need all the hands to break the ties. Now a flush is ranked number 5, and in order to break the ties, we look at all the cards in the hand. Highest first, and working all the way down. So something in there should be able to break the tie. Although, it certainly is possible, although unlikely, that somebody else has those five exact cards in another suit, and it actually would be a tie. There would be no tie-breaker. Let's look at this hand. Our player describes "Straight, Jack high." That's all he needs to say, because if it's a straight, if you know Jack is the high card, then you know the other cards have to be "10, 9, 8, 7." So we only need two numbers to describe this. 4 meaning "straight," and then an 11 meaning "Jack." Next hand, "Three sevens!" Usually that's enough to disambiguate a hand, but if we really need to break the ties, then we would look at the next highest ranking card. Next is the 5, and then finally the 2. So to describe the hand, we have the rank number, which is 3. Then the 7's, then the complete list of the five cards. Next hand "Two pairs, Jacks and Three's!" That describes most of the hand, but we also need to compare all the cards, including the two pairs, but it's the highest ranking pair, first. So first, the 2, meaning "two pairs." Then, the 11 for the Jack (the highest of the two pairs). Then, the 3 for the three's. And now we need the final card. I happen to have all of the ranks standing around, so I use that as a stand-in for the final card. Either way, that fifth card can completely disambiguate the hands, if you happen to tie on the Jack's and the 3's. Here our player declares "Pair of two's, Jack high." That partially describes the hand. Notice we lost the exclamation point. He's not so excited about his hand this time. So a pair of two's, that's down to ranking number "1." Then the pair of two's is the first tie-breaker. And then all of the cards in the hand. Our final hand, and our poor player declares "I got nothing." Now he's REALLY crying. But sometimes nobody else has anything either, and then we still have to decide among the players who have nothing, who wins. And we just go in order of the ranks of the cards. So "nothing" is 0. And then the ranks of the cards from highest to lowest. [Norvig] Now let's go back to hand_rank. We still have the same specification that the input is a hand and the output is a value indicating the ranking of a hand. But instead of having the value be an integer like it was before, now the value is going to be a tuple where the first element of the tuple is still going to be the single value representing the type of ranking-- 8 for a straight flush, for example-- but then the next element of the tuple serves to break ties. If 8 is the highest compared to any other hand, then that's the winner. But if there are multiple hands that have an 8, they all tie and we have to go on to the first tiebreaker. And what should the tiebreaker be? Well, in this case, we can just look at the high rank. So we can look at the max out of all the ranks breaks the ties. And the idea there is if we had a hand that, say, had ranks 2 3 4 5 6, then the only thing we care about is the 6. We can completely specify this hand because we know it's a straight. So if 6 was the high card, then that tells us everything we need to know about the straight and how it compares to any other straight. So for that kind of hand, we'd get the value (8, 6) and a hand that was, say, 6 7 8 9 T would get the value (8, 10), and we know that this hand would win because (8, 10) is bigger than (8, 6). So this gives us a way to break ties between straight flushes. We can do the same type of thing for all the other rankings. So rank 7 is 4 of a kind. What do we want to put in there to break the tie? The first tiebreaker is the thing that you have 4 of a kind of. So you say, I've got 4 of a kind, 4 kings, and we can just say, what do you have 4 of a kind of? But now I have to firm up the definition of kind. We weren't quite clear on what it returns. We can make it return a value which is the actual rank. So if I have four 7s, it should return 7. If I have four 10s, it should return 10, and that will be the tiebreaker. And then normally, if we're playing a regular game, there would only be 4 of a kind in a deck. So if you had four 10s, nobody else could tie you because there wouldn't be another four 10s. But we want to allow for the possibility of playing a game where there's 2 decks. So we could go to a tiebreaker, and then the tiebreaker would be the remaining card in your hand, which is the card that you have 1 of a kind of. So for example, say if you had a hand that had four 9s and a 3, then our value would be 7, meaning 4 of a kind, 9, meaning you have four 9s, and then 3, meaning that's the final tiebreaker. There's something a little bit tricky here that I want to go over and make sure we get right. Here I'm kind of overloading the idea of the function kind. I'm using it to return a value--returns 9 when you have four 9s-- but I'm also using it as a Boolean test, saying if you have 4 of a kind at all, then do this. And so I want to arrange kind to return a false value when it doesn't have 4 of a kind and to return a true value, which is a number, when you do have 4 of a kind. And you can do that in Python. In other languages, you would have to decide one or another. In a language like Java, you couldn't have something that returns either a Boolean value or a number, so you'd have to have another way of dealing with that. But in Python you can do that. You can have kind return a number when it's needed and return a false value when it's needed. One thing you have to worry about is it turns out that in Java the value 0 is, in fact, counted as false. So if I was saying I'm going to return either a false value or return a number and if 0 was one of those possible numbers, then I could be in trouble. But in this case, 0 is not a possible number because the ranks go from 2 to 14, so I'm okay. And we'll see more about that when we define the kind function. [Norvig] Before we finish up the hand_rank function, I'm going to go back to the tests and add some tests for it. So let's take our 3 sample hands here and write tests for each of them-- write what the hand_rank function should return for each of these 3 hands and write a test that asserts that value. [Norvig] Here I've added the tests. For a straight flush the value is 8, the value for a straight flush, followed by a 10, because 10 is the high card in this particular straight flush. For 4 of a kind the value is 7, indicating 4 of a kind, then a 9, indicating that we had four 9s, and then another 7, indicating that the remaining card was the 7 of diamonds. And for a full house the value is 6, 6 meaning full house, followed by a 10, meaning that we had three 10s, and a 7, meaning that we had two 7s. [Norvig] So now I'd like you to fill in the rest of the definition for hand_rank. We have the values for 8 and 7. Go ahead and fill in the remaining tests and return tuples for the values from 6 down to 0. That will be the hardest assignment you've had yet. It might take you a little while to work on it. Make sure you use the test cases, run the tests to make sure you have your hand_rank function working properly. [Norvig] So here's my solution. You can look at the code. I think it's pretty self-explanatory, so I won't go through all the details. I'll just mention a few things. First of all, notice that it's returning a tuple consisting of the major rank and then the tiebreakers, and it just goes through them all in order-- 8, 7, 6, 5, 4, 3, 2, 1, 0. And then the interesting part is, 1, how do you determine what major rank it is? So we test to see if it's a straight flush. Then it's number 8. That's a straight flush. Another example: If you have 3 of a kind and you also have 2 of a kind, then that's a full house, which is number 6. And then what are the tiebreakers? They're the important cards first that are part of the thing. So with a full house the most important tiebreaker is the 3 of a kind, and then the next most important is the 2 of a kind, and we pick out what each one is, put them in that return value to break the ties. And a final thing I'll note is that card_ranks is defined to return the ranks in sorted order. so that, for example, when you have nothing, just returning the ranks, that means that the highest card is first and that's going to be the first tiebreaker, the next highest card is second and that's the next tiebreaker and so on. And that's all you need to know. [Norvig] So let's go through the helper functions 1 by 1, but first let's go back to tests and add some tests. Let's work on the card_ranks function first. And what I want you to do is add tests for each of the 3 cards that we've specified here to say what the card ranks should be. [Norvig] And here's the answer. For the straight flush the values of the card_ranks is 10, 9, 8, 7, 6. Here was the straight flush, and notice what we've done is we put the order with the highest cards first because we're going to use these ranks for tiebreakers, and in tiebreakers it's the highest first that counts. So we always want the result from card_ranks to be sorted highest first. For 4 of a kind, four 9s and a 7. That looks right. The 9s come before the 7. For full house, three 10s and two 7s. 10s come before the 7 and again, that looks right. [Norvig] Here's a definition of card_ranks that's almost right. We say what card_ranks does. It returns a list of the ranks sorted with higher first. We pulled the ranks out of the cards, so here we're iterating over the cards and we're having 2 values: the rank and the suit. And what this is doing is saying each card is a 2 value element, and we can break down those 2 elements into the first and second, the one that has rank 0 and rank 1 or index 0 and index 1. And so we're saying a card consists of a rank and a suit, and we're only going to collect up the ranks and make that into a list. So ranks is the list of ranks, then we sorted it and we said we want to reverse sort so that the higher comes first rather than the lower, and then we return the ranks. This is almost right, but the problem is if we just pull out the rank of each card as is, then the rank T for 10 is the highest because T comes alphabetically after A and Q and all the other cards. But we don't want that. Instead we want 10 to map to the number 10 and J to the number 11 and so on. So we're going to have to come up with a way of fixing that, taking these letters that we pulled out of the cards and mapping them into an integer in the correct way. See if you can fix this definition of card_ranks to correctly return a list of numbers, not a list of characters. [Norvig] Here's one way to do it. What I've done is I only changed this line, and instead of just returning r for r, s in hand, I've taken r and used it as a lookup into this value. So I'm saying when r is the letter 2, I look up into this string and say what index is 2 in there and where is it? You start counting at 0, so it's 0, 1, 2. So the character 2 would map to the number 2, the character T would map to the number 10, J to 11, Q to 12, K to 13, and A to 14. So that gives me a correct mapping from characters to index numbers, and they'll all come out right. I could have done it other ways. I could have had a dictionary lookup, I could have had a long set of if-then-else statements, but this seemed the simplest way to do it. [Norvig] Okay, now let's go on to the straight and flush functions. The first thing to do, of course, is to add more tests. In this case, I won't make you write them. I'm going to write them myself. I've written 4 tests here. I should be much more exhaustive than this, but I wanted to have 1 true and 1 false for each of the 2 cases. Remember a straight takes as input a list of ranks, not a hand or list of cards. And so 9, 8, 7, 6, 5, yes, that is a straight. 9, 8, 8, 6, 5. That's got a pair; it's not a straight, and so that should be false. As for flushes, the straight flush which had all clubs, that should be true. That should be a flush. And the 4 of a kind which had all 4 different suits should not be a flush. I've written the tests. Now it's your turn to write the code. I want you to write straight, which should return True if the ordered ranks form a 5-card straight and False otherwise, and flush, which should return True if all the cards in the hand have the same suit and False otherwise. [Norvig] And here is 1 answer. For straight what I did was I said it's a straight if the difference between the max and the minimum is 4-- say 2, 3, 4, 5, 6; 6 minus 2 is 4-- and also if all the cards are different. So make a set out of the ranks, and if the length of that set is 5, that means if there's 5 different ranks that have a max versus minimum of 4, then it's a straight. For flush what I did is I extracted out the suits, iterated over the hand with the r and s being the 2 characters within each card, collected up all the s into this list, and then I asked, is the length of that set equal to 1? [Norvig] Okay, so we're going great and we're almost done. We just need to implement kind and 2 pair. So let's write some tests first, as usual. Again, I'll do the tests for you. So what I've added here is one more card or one more hand to deal with-- 2 pairs, a pair of 5s and 9s with a 6 left over-- and then I pulled out the ranks of 4 of a kind ranks and 2 pair ranks by calling card_ranks, and then I made these assertions. So is there a 4 of a kind in the 4 of a kind ranks? Yes, there is. And in fact, it's a 9, those four 9s. Is there a 3 of a kind there? No, there's not. We're asking for exactly 3, not at least 3, and so there's 4 but there's not 3. Is there a 2 of a kind there? No. Is there 1 of a kind? Yes, there is. There's four 9s and there's one 7. So 1 of a kind in 4 of a kind ranks is yes, there is. There's a 7. And then in terms of 2 pair, does the 4 of a kind have 2 pair? No, it doesn't, so we return None. And does the 2 pair have 2 pair? Yes, it does, a 9 and a 5. I'm going to ask you to write the kind function, which takes the n of a kind you're looking for, the list of ranks, and it returns the rank that that hand has exactly n of if there is one and returns None otherwise. And it should go through the ranks in left to right order and find the first one that corresponds to n of a kind. And there are many ways to do it. Here's how I chose to do it. I go through the ranks, and then for each r in the ranks, I check to see if the ranks has a count of exactly n of those, so count is one of the methods that exists on lists. We can ask a list to count how many times it has an element. If that's equal to n, then return that element. And if not, then just return none. Now I want you to define the function two pair, which takes ranks as input, and if there are two pair within the ranks, then it should return a 2-tuple of the highest and lowest rank, and if there aren't 2 pairs, it should return none. So here's how I chose to do it. I first picked out the first pair, and if there are 2 pairs, that should be the highest, because remember, the ranks are ordered from highest to lowest, so if I'm going through the ranks from left to right, I should hit the highest one first. And then to find if there's a low pair, what I've done is reverse the ranks and then look through those, so now I'm going from lowest to highest, and I should find the lowest pair first. Now if I found a pair, and I found a low pair, which is not equal to the pair, then I want to return the two of them. Otherwise I just return none. So congratulations. We've gone through the whole program. We've come up with a solution, and now when we hit the Run button, it prints out "tests pass," so we've done everything that we promised to do, and it works okay. But I'm still not confident because I know we've done some tests, but we haven't done exhaustive tests yet, so I feel pretty good about it. You should feel good about what we've done together. Congratulations on that. But don't feel like we're done yet. We've still got to come up with more tests to prove that we've got it right in every case, and in fact, I want to share with you a test that somebody pointed out to me that I hadn't thought of at all. So I've added 1 more test, but I've added a bunch of new hands, and since it seemed to be getting complicated, I documented what each hand is. And the key point here is one particular hand or one particular set of rankings which is a straight that goes from ace through 5. An ace, 2, 3, 4, 5. It's almost a straight flush, but we just missed, but that's not important. What's important is that it's a straight and that the ace is low, and this is the only hand or the only set of rankings in which the ace counts as a low card rather than a high card, and in our program, we'll mess that up in 2 ways. One is we won't even recognize this as a straight because we're counting the ace as being a 14, not as being a 1, so we won't know that it's a straight, and secondly, even if we did, we'd want to count the 5 as being the high card in this hand, not the ace. We've got to come up with something to deal with that, so let's see, what are the possibilities? Well, perhaps we want to modify the function straight. We also want to return the correct hand rank for this hand, so maybe we have to modify the function hand rank. And third, the card ranks probably have to change as well. We want the card ranks for this hand to have a 1 for the straight rather than a 14. And what do you think about the prospects of making 3 changes? Would you say that that's okay because the changes that you envision making seem to be small ones to the 3 functions? Would you say it's okay regardless of the size of the change? That's just the way it is. We have to put up with it. Or would you say we should be able to do better? And we should look for a solution that doesn't require changing all 3 functions. What would you vote for? Well, my inclination was I think we can do better. I listed 3 places where we could make a change, but it seems like we're really only changing 1 thing. I mean, after all, it's really only one hand that we're dealing with. I think we can do better by isolating that change, and in general, that's what I want to try to do. I want to be able to say that the amount of change should be proportional to the amount of change in the conceptualization, and here there's only 1 change in the conceptualization of what it means to be a straight with a low ace. We should be able to confine that change to 1 place in our program rather than 3 places. So what can we change? Do we have to change the function poker? Do we have to change the function hand rank? Do we have to change the function card ranks? Or the function straight? Now, I said I wanted to get it down to changing 1 function, but that might not be possible, so select all the functions that you think are going to need changes in order to accommodate that ace-low straight. And my answer is that only card ranks needs to change, and let's see what we have to do to make that work. So here's the function card_ranks. It takes a hand, pulls out the ranking for each hand, makes that into a number, sorts them so that the highest numbers are first, and returns that, and now I'm claiming that we can make 1 change to card_ranks so that it will handle the case of an ace-low straight and come up with the right representation for that in terms of ranks that will allow the rest of the program to function properly. Can you come up with that change? Well, here's what I came up with. Instead of returning the ranks directly, what I want to do is say under 1 condition, if the ranks is equal to this ace-high or ace-low straight, rather, then I want to fix it. Otherwise I want to leave it the same. If the ranks is equal to this ace low--and we'll fill in that later-- if that's the case, then what I want to return is a fix, which is 5, 4, 3, 2, 1. This is the only time when I'm returning a 1 as a value. Up here we had 2 and above. There was no 1 that you could return. But now an ace, instead of being 14, we're going to count the ace as a 1, and we're going to do that only in the case when the ranks that we had so far was an ace, 2, 3, 4, 5, which according to the sorting would have come out as 14, 5, 4, 3, 2. And I got the syntax backwards here when I did the insertion, so what I want to say is return 5, 4, 3, 2, 1, which would be the correct ordering for where we want to put an ace if we had ace, 2, 3, 4, 5, as our hand. And for any other hand, just return the ranks as is. And my claim is that this will make everything work because now we've taken this one hand that was problematic, and we corrected it by making an ace be a 1 instead of a 14, and now all the other comparisons of ranks will work out properly. This will, in fact, be a straight because 5 - 1 is 4, and there's 5 different cards. And the high value in here will, in fact, be a 5 and not the ace. So now we're in pretty good shape, but there's one more thing that bothered me in the initial specification, and that was we said that if there's a tie, don't worry about it, or we claim that there won't be any ties, but there could be. And I would hate to have this program tell me I lost when I actually tied. I wouldn't mind it telling me I won when I actually tied, but I don't want it to tell me that I lost. What if I finally got a straight flush, ace high, only to find that another player had exactly the same hand but in a different suit? Well, if that happened in the Old West, you might expect some shots to be fired, but assuming there was no cheating going on, the 2 winners should split the pot equally. That's the way the rules of poker work. And the way our program would work is it would arbitrarily choose one of the maximums out of the 2 that tied. That doesn't seem fair, so to accommodate that idea, what do you think we can do? How are we going to handle ties? We could change the function hand_rank. We could change the function poker, or we could add a new function. And check which ones you think would work okay and which single one do you think would be best? Well, the answer is that changing hand_rank wouldn't help anything because it really is a tie, and hand_rank really does return the same value. If we both have straight flushes ace high, hand_rank should return exactly the same thing for both. Just because we have different suits doesn't mean they should have a different hand_rank. But we could change poker to return a list of everybody that tied rather than arbitrarily choose one of them. Or we could invent a new function, say, we might want the function "pokerwithties." So either of those would be okay. I think the best is not to introduce this new function because once we have that, who would really want the poker function? Who would want to say "Let's play a game of poker where we don't do ties correctly?" I think we really want to handle ties correctly, so I think that's the best approach of the 3, but either approach would do. Here's the function poker. What am I going to do to change this to handle ties? It seems like it might be complicated. We didn't talk about ties here at all. The max function doesn't do anything about ties. How are we going to handle that? Well, here's my suggestion for how to handle it. I'm just going to say we had the right idea here that we want to go through all the hands, and we want to compare them using hand_rank. But instead of returning the one maximum, let's invent a new function called allmax that returns a collection--it could be a set or a list--of all the maximums. And now let's have you write the function allmax. It takes an input, which is a list or something else that you can iterate over, and Python uses the word "iterable" to refer to that. And it optionally takes a keyword argument just the way that max did. Max can take a key or not. And what we want to do is return, and let's make a commitment and say we're going to return a list of all the items in the iterable that are equal to the max of the iterable. Here's what I'm going to do. I'm going to start out by keeping track of the results in a list, which is initially the empty list. I'm keeping track of the max value. Initially we don't have any. Now, the key function, I'm either going to use the key function you provided me, or if you didn't, I'm going to use the function that just maps an argument to itself, and that's for this notation here. Lambda x maps to x means the function that maps the function to itself. And then I'm going to go through the iterable. For each x, I come up with an x value, which I get by applying the key, and if the x value is greater than the max value so far, or if I don't have a result yet at all, and that would be the case if I'm at the first element of the iterable, then I want to create the result to be this list of the single item x, the value of the first one that I've looked at, and I want to set the max value to be equal to that x value. If it's a tie, then I just want to append x onto the list of results that I've been building up all along. And then at the end, I want to return the result. Now, of course, I should write tests for this as well just as I always did, and now that I have allmax and I have my new version of poker, I've also got to write a new documentation string here. I've written a new documentation string for poker to say that it's returning a list of the winning hands rather than a single winning hand. I have the definition terms of allmax. I should write more tests for allmax. I should go back and change the tests for poker so that instead of returning a single hand, they return a list of the single hand for the tests I have so far. And then I should also add some more tests where there are some ties and make sure that it handles that properly. Once I've done that, it looks like I'm done. Okay, time for a quiz, and in this quiz I'm going to ask you to write a function, and what I'm going to ask you to do is to define the function called deal, which will deal out some hands so that we can actually play some poker. And you should give this deal function the number of hands that you want dealt, the number of players, and we'll optionally allow you to define the number of cards in each hand. For regular poker that will be 5, but there's other games where you deal out 7 or other numbers of cards. We want to allow for that too to make the deal function a little bit more general. Your task is to define the function with that signature that would return a list of numhands different poker hands. Each one has n cards, and I'll give you a hint that you should look at the Python module called "random" and look up to see if there's something there that can help you shuffle the cards, so what deal will do is take a deck, shuffle it, and then deal out those hands and return the value of those hands. Okay, here's my solution. I define deal. It takes the number of hands and the number of cards in each hand. And then I've also added in an optional parameter to make the function a little bit more general. Here I built up a normal poker deck with the 13 different ranks and 4 different suits. I have a list comprehension that goes over both of them and makes a 52-card deck. But I provide that as a parameter because you might want to deal different types of decks. In other games like pinochle, you have a different number of cards. I just want to make deal a little bit more general, so I provide that as an optional parameter. Then I randomly shuffle the deck, and if you looked up in the random module, you see there is a function called shuffle. That's the one you want. And then I go through, and for the number of hands I take a slice out of the deck which has been shuffled and accumulate that into the result list. Now, let's look a little bit more carefully at exactly what this expression here means, pulling out this slice. I've got a deck of cards which have been shuffled, so they're not in any particular order. Say the 3 of clubs is first, and then the 7 of spades, and so on. And now I want to pull out this slice out of the deck, which is defined as the deck starting at n x i and going up to n x (i + 1). And we'll assume for now that n = 5. When i = 0, then this will go from 0 to 5. And we'll pull out the first 5 cards, 1, 2, 3, 4, 5. That slice will be the first element that we'll pull out. Now when i is equal to 1, we're dealing to the second player, and 5 x 1 is 5, 5 x 1 + 1 is 10, and we'll pull out the next 5 cards. 1, 2, 3, 4, 5, and so on. We'll keep on going until we get numhands different cards and return them in a list. Now let's just make sure this works. Let's print, and let's just deal out 2 hands. And there we see we get 2 hands back. There are 2 total hands, and each of them has 5 cards. If we wanted to, we could deal different numbers of cards, so here we deal 2 hands, and they each have 7 cards. Now, I said that Wikipedia has a very nice page that mentions all the types of hands, and it also gives the percentages for each hand. That is, out of all the possible poker hands, what percentage are a straight flush, four of a kind, full house, and so on, so here's the percentages. We see that about half the hands don't have anything. They're just the high card with no pairs or anything else. And then 42% are pairs, and then less for each of those. And we see the percentages align with the actual poker values. That is, the most rare hand, the straight flush, is the highest ranking. The next most rare hand, four of a kind, is the next highest ranking, and the most common is the least highest, so that makes sense. Poker is a sensible game from the point of view of probability. Now, one thing we can do is see if we can duplicate this type of table. That is, can we test our routines and make sure we've got it right in that we identify straight flushes, high cards, and everything else the correct number of times? What I'm going to do is come up with a program that randomly generates decks or deals from the deck and then checks to see what kind it is and checks to see if we can reproduce this probability table. We're going to look at random deal percentages, and first we're going to have a quiz. Say we want to deal out a random number of hands and then count how many of each type we have and then come up with that table like we just saw from Wikipedia. And the question is about how many hands should we deal out to get a good estimate of the probabilities? That is, we're not going to get the exact estimate, but we want to get some estimates that are close to the right probabilities, and the more we sample, the closer we'll get. Should we look at about 52 hands, about 50,000 hands, 700,000 hands, or about 52 factorial hands? And then I also want you to answer why, so one per card, or do we need about 1,000 per card so that the random variations are evened out? Or do we need about 10 for least common hand, least common ranking? Or do we need one for each of the possible permutations of everything that came out of the deck? The answer is one per card wouldn't be enough, and in any case, the number of cards is really irrelevant. What's important is the number of possible hands and the number of possible results we get for each type of hand, the rankings we get for each. One per card doesn't make sense. 1,000 per card doesn't really help that much. Now we're talking. So here we say at least expect to get 10 possible results for the least common rank, so least common is the straight flush, and if we said if we expect to get 10 straight flushes, then probably we're not going to get exactly 10, but it's not going to be off by that much. If we expected only to get one straight flush, then maybe half the time we'd get zero, and half the time we'd get 2, and that would be off by a lot. That wouldn't be very good, but 10 seems about right. At least we're in the right ballpark. If that's the right answer here, then what does that translate over here? Well, we can just look up the probability. We had that on the previous page. Look up the probability. It's about 1 in 60,000 or 66,000, and so if we have a little bit more than 10 of each, then that comes up to 700,000, and that's a lot less than 52 factorial, which is the total number of permutations of the hands. Actually, permutations isn't that important. A better number would be the total number of combinations. But even the total number of combinations is bigger than 700,000, so we're probably okay going here. And here's the code to calculate the hand percentages. I give a default value for n, the number of deals that we're going to do, the default of 700,000, but you can put in as many as you want. And I should say don't try to run this function here with 700,000 as the input because it will take too long. It should take 20 or 30 seconds, and running on our servers, we don't let you run that long, so if you want to run it here, put in a smaller value for n, say 1,000 or so, or if you want to run it on your own home machine, you're welcome to go ahead and do that. We make up a vector of counts which starts with no count for each of the 9 possibilities, and then we go through the deals, and what I'm going to do is deal 10 hands and over 10 times, and for each of those hands, I compute the ranking and then increment the count for the ranking, and then I just print out the results. When I hit Run, here's what the results look like. And if I want to compare them to what we got from Wikipedia, I can go ahead and do that. Here you can see we have 2 columns. These are the results as computed by our random sampling, and these are the results as computed by exact math as shown in Wikipedia, and you can see they're pretty close in all cases. In the real world, problems tend not to solve just one specific puzzle, but they exist in an environment. They occupy a niche in an environment that evolves over time, and we can plot the program's evolution through a multidimensional space, and we can think of the different axes along this space, and one of the most important axes is correctness. Does the program do the right thing? Another axis is efficiency. Does it do it fast enough? Another axis is features. What exactly does it do? And another one is elegance, and I'm using the word elegance here coming from Richard O'Keefe, a programmer who said "Elegance is not optional." And elegance encompasses a number of attributes, or as they're sometimes called, "ity." That is, things that end in i-t-y like clarity, simplicity, and generality are all part of elegance. We can think of our program as occupying a point in this multidimensional space, and we'd really like it to be over here on the right where the correctness is high, although correctness doesn't have to be 100%. We all use programs that crash occasionally, and the programs are still useful to us. And then over time, the program evolves and moves in some of these directions. If the program is too slow, then we have to move it up along the efficiency direction, so we have to re-architect it and move it up to make it faster. Over time, we want to add more features to our program, so say for a poker program we want to deal with wild cards, or we want to deal with having to deal with ties, and so we move out along the feature dimension and move that program to a new space. And then sometimes we think about moving the program to a new point in the space of elegance, so moving along the elegance dimension without increasing the correctness or features or efficiency. And in some sense you might think "Well, that's not really doing anything." "Changing the elegance isn't gaining you any of these features." But what it is gaining you is nothing right now, but it's gaining you something for the future. A program that is more elegant is easier to maintain, easier to change, and so what you're doing is you're buying time in the future by making the program easier to maintain today. Now, when I think of a point in this multidimensional space, here we have correctness, and we're up against the right edge but maybe not quite all the way to the right edge, and similarly with all these other features. Now, Voltaire was not a programmer, but he gave some very good advice to programmers and engineers. He said, "The best is the enemy of the good," and so what Voltaire meant by this is if you're striving for perfection, then you may waste too much time. You may make a bad engineering tradeoff to say "I'm going to have to get to 100% correctness, and I'm going to spend so much time doing that when I could have been doing something else." "I could have been adding more features or adding other attributes to the program." So you have to learn to be a good engineer and make good tradeoffs. For any change you make in this multidimensional space, any improvement you make in any of the dimensions, there's a benefit to that. You make the program more correct or more featureful or more efficient. But there's also a cost. It takes you time to do that. And you have to learn to make the right tradeoffs and say "What do I need most?" "Which direction do I need to move, or am I done?" "Do I not have to move anymore?" Now, for the moment I want to get back to this other idea of moving along the elegance direction without changing the other dimensions, and that's often called "refactoring." That is, we take a program, and we change it around not that it does something different but that it's clearer and easier to maintain. Now, here's a line from my hand<u>rank program</u> that bothers me a little bit, and what bothers me here is I'm repeating myself, so I'm asking do we have 3 of a kind in the ranks, and do we have 2 of a kind in the ranks? Okay, if we do, that's a full house, and then what are we going to return? 6 is the marker for a full house, and then the 3 of a kind and the 2 of a kind. But I'm repeating myself, and so that violates what's known as the "Don't repeat yourself" principle or sometimes called "DRY." I thought to myself is there a different way to do this? Can I refactor my routine so that I'm not repeating myself, so that I only have to say this once? And in doing that, I came up with a different representation for a hand, for the ranks of a hand. Consider this hand. We have a 7, a 10, a 7, a 9, and another 7. Now, in the representation we have so far--and note I'm leaving out the suits here, they don't matter--in the representation we have so far, we would sort these in order. We'd have the 10 and the 9 and the three 7s, and then we'd go through and we'd say is there 3 of a kind, is there 4 of a kind, is there 2 of a kind, and so on. But I want to come up now with a representation that takes into account everything we need to know about this hand, and I can do that using this function that I'll call "group." We group this hand, and group is going to return 2 values. First it's going to return the counts for each of the different kinds of card ranks, and so here we have three 7s and one 10 and one 9. And those counts are going to be sorted biggest first. And then the second value that groups is going to return is the card ranks for each of these, and so what did we have 3 of? We had three 7s. And what do we have 1 of? Well, 10s and 9s, and we're going to put those in order of biggest first. This representation of taking this hand and turning it into a counts and a list of ranks is in some ways a better representation of exactly how a poker hand counts. Here's the new hand<u>rank function using this new representation for hands.</u> We call it in the same way. We pass in a hand. And now we create the groups and pull out the counts and the ranks, and then we do what we did before where we say we have to deal with the ace-high straight, and so change the ranks if we have to. And then similarly to before, we check to see if we have a straight or a flush, and now we can check for what the results are, and here we're returning a single number, 0 through 9, and in every case we return the ranks. Know that what we're doing here is we're actually changing the signature of hand<u>rank.</u> This version of hand<u>rank is going to return different results</u> than the previous version of hand<u>rank, but that's okay</u> because it's still going to work in conjunction with our evaluation in that it's going to return the higher value for the higher hand, even though it's returning slightly different values. Why is it slightly different? Because we're only returning a single number, and then we always return the set of ranks, and those ranks are there even when they aren't needed, so for example, when we have a straight, we don't really need all the cards in the ranks. And in the previous version of hand<u>rank, we only return the high card.</u> Here we're returning all of them, and what we do is we go through and we say, "What are the counts?" If the counts are just 5 of a kind, that's the highest. Otherwise we check for straight and flush, like we did before. Otherwise 4 of a kind, and the only way we can have 4 of a kind is if the counts are 4 and 1. Otherwise we check for a full house, and the only way we can have a full house is if the counts are 3 and 2. Then we look for flush and straight. Those are next in order. Then we look for 3 of a kind. The only way to have 3 of a kind is 3, 1, 1. 2 pairs has to be 2, 2, 1. One pair has to be 2, 1, 1, 1. And then high card would be 1, 1, 1, 1, 1, but we don't have to explicitly check for that. We just have 0 as the final value. This is simpler. We're not repeating ourselves. We have a nice representation here. Also, one thing that I really like about this representation is it showed me a new fact about poker hands that I had never realized before, and that if we look at these values, (5,) (4, 1) (3, 2) (3, 1, 1) (2, 2, 1) (2, 1, 1, 1) and then here--I haven't written it but it would be 1, 1, 1, 1, 1-- these are all the partitions of the number 5, so in mathematics, a partition of an integer is the set of numbers that add up to that integer. And for the number 5, that partitions into 7 possible ways, and it turns out that poker recognizes all 7 of those as a different thing. Poker has a name for all the partitions, and the even more amazing thing is look, they're in lexicographic order. If we sort the 7 partitions, they're in exactly the same order as the poker hands. 5 comes first, that's the highest. 4, 1 comes next. That's the next highest, and so on. I never knew that before about the mapping between poker hands and partitions, but this representation of hand rank makes it clear. Now let's scroll down and look at the group function. What group does is it takes a list of items and then returns a list of counts of items and the item itself. It just goes through the set of items and returns pairs of the count and the set and then sorts them in reverse order so that the highest comes first. And now this returns a list of pairs, and we'd like to turn that into a pair of lists, and the unzip function does that. It's a little bit tricky. You have to look up the zip function and apply it to the destructured list of the pairs, but rest assured that that just pulls out, converts a list of pairs into a pair of lists, and we call that up here in order to get the right answer. Now, I'm always thinking about refactoring. I'm also always thinking of when are you done, and when is it time not to refactor anymore? But I was having so much fun with this, I just wanted to try one more possibility, and that's to say rather than have a long case statement of the different results, can we just have them in a look-up table? And so what I did is I took all 7 of the partitions of the numbers of the number 5 and put them into a table called "count_rankings" and then had the corresponding poker ranking, 0 for a high card, 1 for a pair, 2 for two pair, and so on. And now instead of having a statement here that's a long case statement for all of the 9 possibilities, I can just say that the result is the maximum of taking the counts, looking them up in this table, and that will give you a value for anything having to do with pairs or 3 or 4 of a kind. And take the maximum of that, and this expression here, which says 4 times straight plus 5 times flush. Now, that might seem a little confusing, but what that's doing is it's using automatic conversion of booleans into integers and saying if straight is true, that corresponds to 1, and if false, that corresponds to 0. So if straight alone is true, that will give you a 4, and that's the right ranking for straight. If 5 alone is true, that will give you a 5, and that's the right ranking for flush. And if straight and flush are true, that will give you a 9. And what we had to do here, in the previous results straight flush was supposed to be 8, but it's okay if it's 9. All we have to do is take 5 of a kind and bump that up to 10, and now we get the right rankings by taking the maximum of that. We still have to return the ranks to break the ties, but now in 1 line we did what took 9 lines before, and you can decide is this what you like? It's nice and concise. Or do you like the previous approach because it was more explicit? And that's a question of taste. It's up to you which one you prefer. Now let's look at our lessons learned. We always start by understanding the problem. Look at the specification. See if it makes sense. If it doesn't make sense, talk to people. Try to figure it out. Consider different ways of trying to make sense of it. Then define the pieces of the problem. For our problem we had cards and hands and ranks and suits and so on. Figure out everything there is to represent in the problem. As much as you can, try to reuse the pieces that you have. We used the max function. We used the random shuffle function. Those were sort of standard pieces that we already knew about. Make sure you write tests. You don't know what you've done. You don't know what your program does unless you can specify it both in terms of the pieces that you're defining and in terms of the test that tells you what is it that this program does? And then explore the design space. We have many dimensions for the design space. We have to deal with correctness, with efficiency, with elegance, and with features. Decide where in the design space you want to be. Keep moving in the right direction, and use good taste to know when to stop. I hope we've learned something from this. Now let's take a look at some homework problems to really reinforce these lessons learned. Oh, hey. We're back. Welcome. Excuse me a sec. I was just sketching out a business plan on the back of this napkin. So I have an idea, then question mark, then profit. But you know, this just doesn't work so well. These napkins are so porous the markers don't work on them. I think I'm going to throw away this cliche and move to a different cliche: the back of the envelope. Much easier to write on the back of the envelope, and it's a really valuable skill. It's a valuable skill in real life to be able to do quick and dirty calculations, and it's especially useful for computer programmers. It allows computer programmers to have the important virtue of being lazy. You don't normally think of lazy as being a virtue, but it is. It allows us to say we're going to come up with the simplest design we can, validate on the back of an envelope that that design is efficient enough for what we're trying to do, and then we can stop. We don't have to try to make it more complex. This whole class is about managing complexity, and one of the most important ways to manage complexity is to leave it out completely, just go for the simple solution. If we can do that, then we're well on our way to better designs. In this class we'll learn how to do that, we'll learn how to do the calculations of when you're efficient enough, we'll learn when to stop, and we'll learn how to make programs more efficient. I'm going to start with a well-known puzzle called the Zebra Puzzle. Here's a description of it. We're going to try to address this puzzle, see if we can come up with a program to solve it, and explore the methodology for how we come up with that solution and the process of deciding what's a good enough solution and whether a brute force solution will work. You can read the description of the puzzle here. Now let's start to analyze it. We'll begin with an inventory of the concepts in the puzzle just to make sure that we understand what's going on. The first concept is houses. We're told there's 5 of them. And then there's properties of the inhabitants of these houses and of the houses themselves. So there's nationality, colors of the houses, the pets that they own, the drinks that they drink, and the smokes that they smoke. And then in addition to properties, there's a notion of assignment of properties to houses. And you can think of that either way. You can think of it as assigning house number 2 the color red or think of it as assigning red to house number 2. Then there's a notion of locations, the locations 1 through 5 that mention the idea of the first house and the middle house and of the next to relation and of the immediately to the right relation. And I think that covers most of what was in the specification. Let's go back to it and see if it works. So I'm seeing lots of concepts that we've already covered: 5 houses, Englishman, red house, Spaniard, dog. There's a few words that we haven't covered, things like lives in and owns the. We covered them in a generic sense of saying it's an assignment of Englishman to a house and assignment of the dog to a house, but the question is, do we need to separate out the different types of assignment? So the question is, are we missing this idea of a property name with a description attached? So for example, the property name would be nationality and the description is lived in. Do we need to name them like that, or do we just need the notion of a property group to say that there are these properties of Englishman, Spaniard, Norwegian, Japanese, and Ukranian, and the 5 of them go together but we don't need the name for them, or can we ignore this notion of grouping altogether? This is somewhat subjective--what's a good design choice?-- but tell me which of these 3 do you think are plausible or reasonable design choices and check all that apply. [Norvig] My answer is defining property names would be a fine design choice. It would probably help us understand what's going on in the definition of the program. Defining groups without names would also be fine. Ignoring the groups I think would not work, and here's the problem. We have to know that if red is assigned to house number 2, then blue cannot be assigned to house number 2, but orange juice can be assigned to house number 2. So there's this idea that properties within a group are mutually exclusive and properties outside of the group are not. We need to represent that in some way. [Norvig] The crux of the whole matter is doing the assignments. There are 2 ways to do it. We can deduce what assignment must be true-- that it must be the case that the Englishman is in a certain house. Or we can just try different possibilities-- try to put the Englishman in house 1, then in house 2, then in house 3 and see what works. You'd have to be very clever to figure out how to do all these deductions, and I don't want to try to be that clever. I want to see if I can get by with just trying all the possibilities, make the computer do the work so I don't have to. So let's approach that and let's say we're going to try all possibilities. And so first we put the Englishman into house 1, and later we'll try him in houses 2, 3, 4, and 5. What about the Spaniard? If the Englishman is in house 1, what possibilities should we try for the Spaniard? Give me your best answer: all the numbers; only 1; only 2; or 2, 3, 4, 5. [Norvig] And the answer is 2, 3, 4, 5 because Spaniard is in the same property group as Englishman, and so it can't be in 1 but it can be in any of the others. [Norvig] Within a class of 5 properties, the class must cover the 5 houses but in any order. How many ways can we make that assignment? In other words, here's 5 houses, here's 5 properties in a property group, and here's 1 possible assignment. How many different assignments are there of assigning these properties and matching them up with the houses? Are there just 5 ways, 5 squared ways, 2 to the 5th ways, or 5 factorial ways? [Norvig] And the answer is 5 factorial. And you can see that because there's 5 different houses that you could assign red to, and then for each of those 5 assignments there would be 4 that you could assign green to of the remaining unpainted houses and then 3 for blue and 2 for yellow and then only 1 left for ivory. That's 5 factorial. [Norvig] But we don't just have 1 property class; we have 5 property classes. We've got the nationalities and the pets and so on. And so if we want to make all the different ways of making assignments of all 5 properties to all 5 houses so each house will have a color, a nationality, a pet and so on in each of the possible ways of making that assignment, how many is that? Is it 5 times 5 factorial; 5 factorial squared; 5 factorial to the 5th; or 5 factorial factorial? [Norvig] And the answer is 5 factorial to the 5th because for each of the assignments of 1 property we can have the same number of assignments of the second property, the third, the fourth, and the fifth. [Norvig] And now, how much is 5 factorial to the 5th? Just back of the envelope, is it approximately a million, 20 billion, or 5 trillion? [Norvig] And the answer is 20 billion. How do you do that back of the envelope? 5 factorial is 120. Let's just round that off to 100. 100 to the 5th--that's 5 times 2--is 10 digits, so that works out to 10 billion. And we rounded down to get from 120 to 100, so we should round back up, and maybe it's somewhere around 20 billion. It turns out that the actual number is 24.9 billion, approximately, so that's not a bad estimate. [Norvig] We're in this range where we might be done but we're not quite sure. Our computers can do about a billion instructions per second or so on a good second-- that is, one where they're not wasting part of the second with a page fault or a cache miss. If the answer had turned out to be in the millions, we could say, "Oh, great. We're done." If it had turned out to be in the trillions, we could say, "It's totally infeasible." "We need a better solution." But if it's somewhere in the middle with the billions, then we're not quite sure. We better try to refine the result a little bit to tell if this brute force approach is going to work. And think of the space of solutions in terms of execution time as like a contour map. And here deep down in the valley where there's only millions of computations needed, millions of instructions needed to complete the answer, then we're really happy because we know that's going to go really fast. And outside of the happy valley there are these high peaks where we have trillions of computations needed, and there we're going to be sad. If we're stuck out in these domains, we're going to have to somehow find a path back in because we can't just go ahead and calculate when we're out at the trillions. And in the middle here where we need billions of instructions to complete our computation, then we're not quite sure. So maybe we're happy here and we can stay in this domain. Maybe we want to find our path through the wilderness back into the happy valley. It depends on the problem. And we're going to try to look at problems in terms of this space, try to find our way back in, but know when to stop when we've got close enough. Now let's keep thinking about what it means to do an assignment. Try to get just a little bit more concrete about it. If we want to assign red to house number 1, let's think about the ways in which we could implement that. Here's 1 possibility where we say we're going to have an array of houses. We take number 1 and we add red to its set of properties. That means that each house is represented as a set. Here's another possibility where we take house number 1, we set its color property equal to red. Here each house would have to be represented as a user-defined custom class which had properties for color and nationality and so on. Here's a third possibility. We have a variable called red, and we just assign that the number 1. So here we were assigning properties to houses, and in this one we're assigning houses to properties. I want you to check all the approaches that you think would be reasonable designs for implementing assignment. [Norvig] I know there can be matters of opinion here, but from my point of view they're all reasonable. So they would all work. They'd all be fine. But for the moment, this one looks just a little bit simpler, so I'm going to go with that until I have some proof that the simple won't work and that we'll have to go to something more complicated. In this approach we named the properties. We talked about the possibility of whether you have to do that or not. Here we aren't naming them, and so it will be up to me as the programmer to manage the groups of properties. Here's 1 way I could do it. I could simultaneously assign the 5 properties that are in the same group of color to the 5 houses. Of course this would only be 1 of the possible assignments. After I tried this one, I'd have to try another assignment-- maybe [1, 3, 2, 4, 5]-- and I'd have to go through all the possibilities. Can you think of a good way to do that? What statement or other implementation can you come up with to have the 5 properties go through all the combinations of possible houses? And if you want, pause the video now and try to think of that on your own. [Norvig] So here's 1 approach. First we'll define the houses. Say there's 5 houses. That was the number 1 thing stated in the problem. Then we'll say orderings is some collection of possible orderings of the houses, so [1, 2, 3, 4, 5] would be 1 element of orderings, [2, 1, 3, 4, 5] would be another element and so on And then we just use a for statement to iterate the 5 variables in the property group through all the possible orderings and then put in our code here. The question is, what is this function F that gives us all the orderings? Is it the permutation function, the combinations function, the factorial function, or something else? And the answer is permutations. That's sort of the definition of all possible orderings is called the permutations. [Norvig] It turns out that Python has a permutation function in the itertools module, so you could import that or you could write one yourself. If you do that, one question is, what would be the length of orderings? Tell me that. [Norvig] And the answer is 120, or 5 factorial. [Norvig] Now, suppose we arrange our program like this. So we set up the houses and we have a list of all 120 possible orderings and then we iterate each of the 5 properties in each of the 5 property groups through all those orderings. And so now, 5 levels nested deep into our code we've got an assignment of all 25 properties. Each of them is assigned to one of the houses, and now we can check the constraints, like the Englishman lives in the red house and the Spaniard owns the dog and so on. Those can all go here. If we find something that checks out, we can just report we've got an answer. Now, I want you to go back to the back of your envelope and tell me if we wrote the program this way and filled in this code with all the constraints and then ran it, about how long do you think it would take to find a solution? About a second, a minute, an hour, or a day? Click on the best answer. [Norvig] The best estimate is about an hour, and we'll go to the back of the envelope again to figure that out. [Norvig] 5 factorial to the 5th was 24 billion. And if we assume we have a 2.4 gigahertz computer, which is fairly typical, then if all this could be compiled into 1 computer instruction, then it would take 10 seconds. But of course that's ridiculous. You can't do all of that in 1 instruction. If it was 100 instructions, then that would mean it would be 1000 seconds, which is about 16 minutes, but that seems too little. It's probably going to be more like 1000 instructions to make it all the way through doing all this and then checking the constraints, and so that would be about 160 minutes. And so an hour to 3 hours. Maybe we'll say 2 or 3 hours, somewhere in there. It might be as little as 1 hour. We can't really tell because this is just an estimate. But it's definitely going to be in the hour range and not in the minutes or day range. In fact, I actually ran this program, and we'll come back later and see how well this estimate of somewhere in there worked out. Let me just say because we've learned that this will take somewhere in the range of an hour, don't try to run it here in the browser by hitting the Run button because we timeout the calculations after just a few seconds, so it's not going to work here. You could type it into your own computer if you have Python running on your own computer, set it going, and see how it works. But first we have to figure out how to do all the constraints. So we already did constraint number 1, which was houses = [1, 2, 3, 4, 5]. Now let's do constraint number 2, which is that the Englishman lives in the red house. We want to write some if statement to check if the Englishman lives in the red house and if so, we go on; if not, we give up. And so how do we check if it's true that the Englishman lives in the red house? So if, and then I want you to fill in some expression here. We'll just say that this is constraint number 2. Tell me what you could put in here. [Norvig] And the answer is all we have to do is check to see if Englishman and red have been assigned the same house number. And we just do that with saying if (Englishman == red). And I should note just as an aside if you wanted to be sort of clever and make it look more like English, in this case it would be okay to say if (Englishman is red) because is is checking for whether 2 objects are identically the same object. Equals checks to see if they have the same value. And it turns out that Python handles small integers like 1, 2, 3, 4, and 5 as a single identical object. So the is check would work as well as the equals check here. [Norvig] Now, before we go on to constraint number 3, I want to go backwards a little bit and say there's 2 concepts we haven't talked about yet: the concepts of being next to and immediately to the right of. Immediately to the right of--well, because we've used house numbers to assign houses, we can say that house 1 is immediately to the right of house 2 if they differ by 1, if h1 - h2 is 1. So house number 3 is immediately to the right of house number 2. What I want you to do is fill in the code for next to to say if 2 houses are next to each other. [Norvig] And the simplest way to do that is just ask if the absolute value of the difference rather than the positive or negative value is equal to 1. But an alternative way to say it if you wanted to break it down in terms of the other primitive, you could say that nextto (h1, h2) is defined as immediate right of h1, h2 or immediate right of h2, h1. [Norvig] Now let's put the whole thing together. I've defined zebra_puzzle. It's a function. It doesn't take any arguments because there's only 1 puzzle. There aren't different puzzles that require different arguments. It's going to return a pair of WATER and ZEBRA, so 2 house numbers indicating which house drinks water and which house owns a zebra. I've repeated houses = [1, 2, 3, 4, 5] and I've also defined first and middle. I've repeated the work of figuring out all the orderings. That's constraint #1. And then I've written the whole function as a generator expression, and I chose to do that rather than sticking with the nested for loops just because the structure is a little bit easier. What we're doing here is we're asking for the next version. So in other words, the first time through we're asking for the very first solution to this iterator expression where we say iterating through the 5 properties, if each of the tests is true, then return the values of WATER and ZEBRA and then keep on doing that for all possibilities. But I'm only interested in the very first one, which the next after nothing is the first. So go ahead and return that. Each of the constraints is very easy to state. Englishman is red, the Spaniard is dog, coffee is green and so on. We have some immediate rights and nextto, and that's the whole problem. So in some sense we have a solution; in another sense we know that it's going to take something like an hour or 2 to complete. And maybe we're not happy with that, so we're going to make it faster. But before I do that, I want to do a little bit of review of these generator expressions because probably you haven't seen this too much before. [Norvig] And before I do generator expressions, we're going to do list comprehensions. You've seen them before. We saw in Unit 1 we said that we could get the list of suits by saying [s for r, s in cards]. And so the format here is we have the individual term of the list comprehension and here we have a for clause. And in general, we're going to have 1 for clause at least and then, optionally, we could have more here, either for or if clauses. And that's what a list comprehension looks like in general. Now, what does the list comprehension mean? This expression is similar to saying we're going to write out a loop where we say the result starts as the empty list, then we take the for part and then we take the term and append that into the result. And then when we're all done, result will hold the value of this expression. Now I'm going to show you a more complex list comprehension. Say we wanted the list of suits for all our face cards. Then we could say s for r, s in cards if the rank of the cards is, say, in jack, queen, king. I don't know why you'd want that, but there's a possibility. So I've got the term I'm building up, I've got 1 for loop controlling it, and now I've got an if statement, and that's as if we had written this code if we had inserted inside the for loop an if statement and then only done the appending of the term s if the if statement is true. And in general, we can have any number of for statements, if statements, more for statements, more if statements. We can keep on adding those for clauses and if clauses and intermingling them in any order we want, as long as the for clause comes first. And we can have that 1 big list comprehension, and that corresponds to putting in more fors and ifs here in this loop. The whole thing is read left to right except for the term. So the way to read a list comprehension is to say I'm going to ignore the first part for now, and then I think of it as saying it's a bunch of nested statements-- for statements, if statements, for statements. They all get nested deeper and deeper. Then when I get to the end, the very last clause, now I'm appending together the term, so now read the term. And that's why it's okay that term here looks like it's referencing a variable s that hasn't been defined yet. That's okay because s has been defined here. And it looks like it's used before it's defined, but that's not the case, because when it's actually used is right down here at the end. [Norvig] So that was list comprehensions. Now let's look at generator expressions, which is almost the same idea. The syntax is the same in that a generator expression consists of a term, a mandatory for clause, and then optional for and ifs clauses-- as many of those as you want--0 or more. There's 2 differences. The generator expression uses parentheses instead of square brackets. Square brackets mean list; parentheses means generator. And then the other difference is that the computation doesn't get done all at once. Instead, a generator expression returns a value, which is a promise to do the computation later. So if we say g = this and then g is this promise, it hasn't done any calculation yet. It hasn't calculated any of the terms. And then I can ask, give me the next g. Then it starts doing the calculation and it keeps on looping through the for clauses or maybe multiple for clauses until it finds the first term and returns that. And then if I want, I can again ask for the next g and it will give me the second one and so on. Let's look at an example. Here I've defined the function sq for square of x. It takes in the value x, prints out that it's been called, and returns x x. Here I've defined a generator from this generator expression that says g = (sq( x) for x in range(10) if x%2 == 0). So that's saying if x is an even number. And notice nothing has happened yet. We didn't get any printing of square was called, so square hasn't been called yet. The generator function is this promise. We can look at it. It says it's a generator object, but no computation has been done yet. We can ask for the next g and now, finally, square gets called with 0 as an argument, and we return 0 as a result. We can do that again. We get 4, 16, 36, 64. And what do you think is going to happen next? Now we're getting to the end of the loop. Range(10) means 0 through 9, so there are no more. So now when we ask for the next one, Python raises this condition called StopIteration. So it's saying, "I've gotten to the end." "I have to stop the iteration because there's no more I can give you." "I can't give you the next one." This seems a little bit inconvenient because now I've got these errors and my program has to deal with them, but the idea is that you rarely will be calling next directly. Rather, most of the time you'll be doing this within a for loop. So I can say something like this where I say for x2 in this expression do something, and now the protocol for a for loop arranges to call the generator each time, to call the next function, and to deal with the StopIteration exception and catch that. And so everything works fine. I can also convert the results. Here I've said I've got a generator expression and I'm converting that into a list. It does all the work and then it returns the result as a list. So I never have to deal explicitly with those StopIterations. Why do you think I chose generator expression to implement the zebra puzzle? Do you think I wanted to confuse students; have less indentation so that the code would fit on the page; stop early as soon as I found the first result; or make the code easier to edit, to move around the various pieces of the constraints and so on? Check all that apply. [Norvig] The answer is no, I didn't try to confuse you. In fact, I'm trying to show you a very useful tool in generator expressions. Yes, I thought the indentation was important. With all those fors and ifs, I would have run out of space across the page. Yes, I wanted to stop early, and so a list comprehension would have been a bad idea because a list comprehension would have had to do all the work, whereas a generator expression can stop as soon as it's done. Having statements rather than expressions also would allow me to stop early. And yes, it's easier to edit. If I wanted to move around the order of the clauses, instead of having the indented structure that I would have with statements I have a flat structure and it's easy for me to pick out 1 of the constraints and move it somewhere else in the list without having to worry about getting the indentation right. So editing expressions is easier than editing statements in Python. [Norvig] I wrote this version of the function, and as soon as I wrote it, as I was recording this video I set it running. And you know what? It's still running. It hasn't completed yet. I've got to admit I've done this before, so I have an idea of how long it's going to take. But we're in a race with it. Let's see if before it completes-- we know it's going to take on the order of an hour or so-- can we write a program that's better and faster and maybe even though that program's got a head start, we can catch up with it and finish first? The problem with this program is it goes through all this work to try all the 5 factorial to the 5th combinations and then they get ruled out really early. And some of the combinations, it seems silly that we're bothering with them. So if the Englishman is not red, we should know that by the time we've got through the second set of assignments here. Here we've assigned red to some house and Englishman to some house. If we didn't assign them to the same house, why are we bothering to go through all the possibilities for the other properties? And so what we could do is move this constraint up to the earliest time in which both Englishman and red are defined, so there. Now I've moved it up, and now if Englishman is red is false, then we don't even have to bother to go through all 3 of these loops. So we're going to eliminate a lot of work in just that 1 clause. Now let's consider another of the constraints. Let's look at immediate right of green and ivory. Can we move that up? And where can we move it up to? Can we move imright(green, ivory) up to here, here, here, or here? [Norvig] And the answer is we can move it all the way up to the top because both green and ivory are bound at this point. [Norvig] And if we keep on going, moving every constraint up to the highest point it will go, we get this. And now I've checked, and the original version of the puzzle that I set running is still running, and now I can hit Run on this and in less than a second I see my result, (1, 5), meaning water is drunk in house number 1 and the zebra is owned in house number 5. This is an amazing thing. It's as if we had a car race and we had the start here and the finish someplace far away and we had this competitor car which was the original zebra puzzle car-- we'll call him z for zebra. We said, "Go!" and it started out down the path towards the finish. We wanted to build a competitor to that, but we just let it go. It's running, and we're thinking and we're analyzing and we're not doing anything, and it's getting farther and farther ahead and closer to the finish line. Maybe we spent half an hour and it's halfway through. It's gotten up to this point. We're still stuck at the Start sign, but what we're doing is we're building a better car. We're building a super fast race car, and we're putting the pieces together using what we know, and eventually this car has gotten a long ways along the way and then we say, "Now we're ready to go." And when we hit Go, zoom, we're there in less than a second, what took this car who had a half hour head start is not even close. So it's like the tortoise and the hare, only in reverse. And by thinking and coming up with a better design, we were able to beat this original design even though we gave him a half hour head start. We won the race. We get the checkered flag. We should be happy at what we've done. And congratulations. Now, if you're the type who just cares about winning the race and finishing first, we can stop here. But if you're a little bit more analytic and you like to know the exact scores and times, then we've got work to do. Here's 1 thing I can do. There's a module in Python called time. In that module there's a function called clock which gives you the time of day. And so I can set t0 to be the time before I call the zebra<u>puzzle,</u> t1 to be the time afterwards, and just return the difference so that will tell me how long the zebra puzzle took. If I hit Run, the answer it came back with was 0.0 seconds. That's because the system I'm running on doesn't have an accurate enough clock. And I know it's accurate down to the thousandth of a second, so all we can say here is that it took less than a thousandth of a second. I've run it on other systems, and it comes back at 0.00028 on that other system. I was able to do this, but this looks like a good opportunity for generalization. Why do I want a function that only times the zebra puzzle? It would be great if I had a function that could time the execution of any function. So here I've defined a function called timedcall which takes another function as input, sets up the clock, calls that function, calls the clock again to figure out the time, and tells me what the elapsed time is. So I could call timedcall of zebra<u>puzzle to get the answer of how long that took,</u> or I can apply this to any function. So I built a useful tool that I can use again and again. I can make it even more useful by doing 2 things. One is saving up the result and returning that as the second value in case we're interested both in the result and in how long it took, and secondly, allowing functions that take arguments. You may not have seen this notation before, so let's talk about it for a second. [Norvig] So the <i>args notation appears in 2 places.</i> It appears in the definition of a function, and it can appear in a function call. In the definition of a function, what it means is this function can take any number of arguments and they should all be joined up into a tuple called args. So if the call to the function looked like this, something(f, 1, 2, 3), then 1, 2, 3 would be bound up into a tuple and assigned to args. So within the body of something, args is equal to the tuple (1, 2, 3). And then this part here means take that tuple and apply it not as a single argument but rather, unpack it and apply it to all those arguments. So fn(<i>args) is equivalent to writing fn(1, 2, 3).</i> It's just a way of packing and unpacking arguments with respect to function calls. One thing I want you to notice here is that we used a function as a variable, as a parameter or something that's passed into another function. We're using the property of Python that functions are first class objects just like integers and lists and everything else. Functions are objects that you can pass around. That's very powerful because that way we can control both what happens and when it happens. The idea here is that we want to call this function but we want to delay calling of the function until we've already started the clock. We want it to happen between the time we start the clock and the time we end the clock. And in order to do that, if we tried to write something like this-- timedcall(zebra<u>puzzle())--then timedcall wouldn't work.</u> It would be too late because what we pass to timedcall would be the result of zebra<u>puzzle.</u> We don't want to pass the result; we want to pass the function that we're going to call and be able to delay execution of that function until the right time, until we're ready to set the clock. And so functions allow us to do that--to delay execution until later. Now, let's get back to this idea of taking timings. When we're taking timings we're doing measurements. Now we've changed what we're doing from having computer science being a mathematical enterprise to having it be a experimental enterprise-- and experimental science. We're actually doing science. It's as if we're dealing with the messy world with some chemicals in a beaker, and we're making measurements of those rather than trying to do mathematical proofs. One thing we know about doing experimental science is that one measurement isn't going to be good enough. That was clear when we got a measurement of 0.0. We know that wasn't right. We know that there can be errors in measurements. One way in science that we deal with that is by repeating the measurements multiple times. I want you to tell me why you think some reasons are that scientists, when they do an experiment, take more than one measurement. Is it because we want to reduce the chance of some external event effecting the result? Because we want to reduce the natural random variation? Or because we want to reduce errors in the measurement process? Check all that apply. The answer is that all three of these are reasons to repeat measurements-- take more than one measurement. Now, just by itself taking repeated measurements won't solve all these problems. If you have a systematic error, then repeating them will just repeat the same systematic error, but they certainly are required, although we may need more. Let's build a better tool. Here I built a function called "timedcalls" with the plural s rather than a single timedcall, and it takes a number N, saying repeat this timing N times. Then it takes the function and the arguments to apply to. It builds up a list of the timed calls. It throws away the results and just takes the time. Then it returns three values, the minimum of the times, the average of the times, and the maximum of the times. From those you can do whatever statistical analysis you want to do in order to get a better feeling for what the timing is like. Now, if the function runs very quickly-- say, if the function took 100th of a second then you might want to give an N of 1000 or so. If the function takes about a second to run, maybe you don't want to wait that long or maybe you want to give a smaller value of N. Part of the problem is if you have a good idea how long the function takes, then you can be precise about what a good value of N is. If you don't, you don't know. I'm going to propose a different version of timedcalls. This version has the same signature as the three inputs and returns the min, average, and max, but this time it treats N two different ways. What we're going to do is say if N is an integer, then do the same thing we did before, but if N is a floating point number, then what we want to do is keep on repeatedly call timedcalls for the number of trials it takes until we've added up to that number of seconds. If N is equal to the integer 10, we repeat 10 timedcalls. If N is equal to the floating point number 10.0, then we repeat it until 10.0 seconds have elapsed. Here is a hint. We can ask if N is an integer and then do one thing. If N is not an integer, then to the other. See if you can fill in that code. Here is my answer. If it's integer, we do what we did before. Otherwise, we go into a loop until the sum of the times is greater than or equal to the floating point number that passed in. Now I think we've got a pretty good handle on timing our functions. Another interesting question would be how many assignments did we take along the way, not just how long did they take? Now, if our program had been structured using for statements rather than using the big generator expression, we could do it something like this. We could say we're going to count the number of assignments. We're going to start the count at 0, and then every time we go through an ordering we're going to increment the count by 1. You might say we want to increment the count by 5, because we've assigned each of the 5 houses one of the colors, but I'm counting that as 1. You can choose which one you want to go on. Then we just have a structure like that, and we can keep track of the counts. That will work fine, and it's not too bad, but it bothers me a little bit that we had to do such violence to this program. We had this program, and we had to go in in so many places, interrupt it, and put in so many statements. I wanted to see can we separate that out a little bit? Now, when we're designing a program, we're thinking at multiple levels. We're thinking about different aspects of that program. For example, we always have to think about is the program correct. Does it implement what we want it to implement? We saw in the zebra puzzle that we also want to worry about is it efficient. Maybe we have a correct program, but it takes an hour, and we'd rather have a program that takes thousandths of a second. We also have to worry about the debugging process of as we're developing the program, we're building up all sorts of scaffolding to make it run properly that maybe we won't need later. Traditionally, we write our program. Some of what we're written has to deal with having it be correct. Then some of the code interspersed in there deals with efficiency. Now we've talked about adding further code that deals with debugging it. We end up with this mess that's all interleaved, and wouldn't it be nice if we could break those out so that some of the debugging statements were separate, some of the efficiency statements could live someplace else, and the main sort of correctness program could, say, stay distinct from the other parts. This idea is called "aspect-oriented programming." It's an ideal that we can strive for. We don't get it completely, but we should always think of can we separate out these different aspects or concerns as much as possible. What I want to ask is if I've written the function this way as this big generator expression rather than as nested statements, I can't have count equals count plus 1 statements inside here, because there's no place to put something inside a statement, and I'd like to separate the counting as much as I can from the puzzle to do the minimum amount of damage or editing to allow me to insert these bookkeeping nodes that do that counting. Let's think about that. What would be the right way to do that? I'll tell you what I came up with. This is the second-best answer I came up with. That's to say, well, what am I doing? I'm counting iterations through the orderings, so maybe the place to insert my annotations is right here. I want this to be a debugging tool. For debugging tools, I'm willing to have shorter names, because they're things that really aren't going to stick around. I'm going to use them for a while, and then I'm going to get rid of them. I'm willing to have a one-character name here, although it bothers me a little bit. I can always rename it as something else. What I'll do is I'll just insert this call to the function c around each of my uses of orderings. I'm going to insert 1, 2, 3, times 5, 15 characters. There we are. I think that's a lot less intrusive than putting in a lot of count equals count plus 1 statements. I'm pretty happy with that. What I've done here is defined a function called "instrument function," which will count the calls that it takes to execute the calling of a function with the arguments. I haven't shown you the definition of c yet, but when I show it to you, you'll see that it keeps track of two counts-- the number of starts, the times we started an iteration, started the for loop, that was measured with the c function, and the number of items that we got through. How many times did we go through that for loop? We initialize those counts to 0, we call the function, and then we say what do we get back. With the zebra puzzle, it only took us 25 iterations over 2,700 items. Puzzle2--this was the definition for when we took the original definition and then moved only one of the constraints up in the ordering. That gave us this number of iterations and items. I didn't show the puzzle where none of the constraints are moved up. That would've taken even more. We see even here quite a reduction in the number of iterations in the counts, and this tells you how efficient we are. To implement the function C, I have to tell you about a new tool called a generator function, which is almost the same as a generator expression, and we'll show you what it looks like. I'm going to define a function to iterate over the integers from some start to some end. This is going to be just like range. Range is a great function, but sometimes it's annoying, because you really don't want to 1 less than the end. You want to go up all the way to the end. That's what ints is going to do. I'm going to implement it as a generator function. I'm going to start off with an integer I that starts at start number that you told me. Then while i is less than or equal to the end I'm going to introduce a new type of statement here called yield, and I say yield i, and then I'll say i equals i plus 1. Now, the yield is something new, and it makes this definition a generator function rather than a regular function. What that means is what's going to happen is it's going to execute. As soon as it sees this yield statement, it's going to generate that value i but keep it's place and when asked for the next, it will continue incrementing i and then continuing through the loop. When we call this function, if we say L equals the integers from 0 to 1 million, now L won't be a list right away. It'll be a generator. Now L is equal to this generator, some funny object. Then you call next of L to get the next object, and you keep on going through. More commonly, instead of calling next explicitly, you'd say for i in L. And so generators obey this iteration protocol just like other types of sequences. The great thing is we can yield from anywhere inside this function. We get a very complicated logic here and then yield a partial result and then continue getting the next result right where we are. This is a convenient feature for writing functions. Another great thing about generator functions is it allows us to deal with infinite sequences. Let's say we wanted to allow the possibility of an open ended interval of integers. We'll make end be an optional argument, which can be None. The idea is that if we have a call, say ints, starting at zero, but I don't give it a end, then that means all the non-negative integers--0, 1, 2, 3, going on forever and never stopping. The question for you is how would you modify generator function in order to make it obey this idea of never stopping when end is equal to None. You should be able to modify just this line here to make it obey this idea that it should keep on going forever when end is None. The answer is we want to continue with this while loop while i is less than end or end is None. In the case where end is None, that will give you an infinite loop. Let's give you practice with one more example. I want you to define for me the function all_ints, which generates the infinite stream of integers in the order of 0 first, then +1, -1, +2, -2, +3, -3, and so on. Put in your definition. Here is my answer. It would start by yielding 0. Then for i in all the positive integers yield first +i and then -i. If you didn't want to use ints here, you could do an alternative solution that looks like this. While True means it's an infinite loop, and I'm yielding +i and -i and then incrementing. Now, after all that, I think you're finally ready--you're mature enough-- to learn the whole truth about how for statements actually work. You've been using them all along, but you may not have known the inner details, the gory truth, about what's inside the for statement. Now, when I saw for x in items, print x, you probably have a model that looks something like this: assuming items is a list or a tuple or a string, you think of this code probably as something like i equals 0 while i is less than the length of the items, x equals items at i, and then print x. That's a good model as long as items is one of these sequence types like lists. But items can also be other things, as we've seen. It can be a generator expression, for example. Overall, Python calls the thing that can be iterated over in a for loop an iterable. Strings and lists are examples of iterables, and so are generators. What actually happens when we implement this piece of code, it's as if we had written this code. First we take the items and we make an iterator from them by calling the built-in function "iter." I'm going to call that "it." Then we're going to have a while loop that goes forever. Its loop control says while True we're going to assign x to be the next item off of the iterator, then do whatever was in the body of the for loop, in this case print x. We're going to keep on doing this sequence as long as we can get an x value. But when next stops then we'll have an exception, which is a stop iteration exception, and we don't need to do anything more. We're done. That's what a for loop really means in Python. We take the items, we create an iterator over them, we call that iterator until we're done, and then we pass through to the next statement. We're finally ready to define this c, this counting function. What it does is it takes a sequence, it says this is the first time I've been called. I'm going to initialize my starts to one. Then I'm going to enter into a loop and this means that c is a generator function. The generator function will be returned, and as part of the for protocol, we'll call that generator function each time we want the next item in the sequence and each time we do that, our count of items will be incremented. When we're done, when the for loop doesn't want any more, we'll stop incrementing. We don't necessarily go through every item in the sequence. We'll just have just the right number of counts for item. This will give us the right number of starts and the right number of items. We can do that because we control the time of execution, because this is a generator function and not a regular function. In summary, what have we learned from our friend the zebra? Well, we learned that we took our approach of making a concept inventory and then refining the ideas and choosing the simplest implementation we could think of and then doing a back of an envelop calculation to say how long is it going to take to run this simple implementation and then refining the code as necessary, making it a little bit faster by swapping around some of the clauses. We also learned the idea of building tools. We built tools for timing and counts. In general we learned this idea of separation of aspects from the program to try to keep the design as clean as possible, so that you could tell what was working on getting the problem right and what was working on making it more efficient. In the end you might say, wow, that was a clever solution. It was great to see how it works out, but we can see if we just follow the steps we can arrive at a solution like that every time. Now we're going to turn our attention to a different type of puzzle. This is called a cryptarithmetic problem. "Crypt-" for cryptography--secret writing---and arithmetic for arithmetic-- doing addition and other types of problems, and the idea here is that each of these letters of the alphabet stands for some digit from 0 to 9. The problem is to figure out which digit stands for which such that the equation will be correct. Some people call these alphametics--is another name for them. They're a puzzle for humans to work out because there are so many possibilities, and humans are limited in the speed in which they can mark them out. But there are some types of inferences that they can make. For example, in this addition problem here we have an addition problem of of two 3-digit numbers, and the result is a 4-digit number. E is that fourth digit, so what does that tell us about what the letter E must stand for? What digit it must stand for? Do you think E should be 1 or 2 or 3 or 4 or 9? The answer is that E has to be 1 because E is the carry digit. After adding up these two 3-digit numbers we get a little bit more, and the most that the carry digit could be is a 1. If O stood for 9, even 9 plus 9 is 18, and we might carry over a little bit. But still that's 19. It's not 28. So the E must be a 1. We could go on from there and figure other things. Is this digit the digit that replaces the N? Do you think that should be odd or even? The answer is N must be an even digit because D plus D, no matter what D is, that's equal to 2 times D, so N must be even. Human problem solvers would continue on like that, making inferences from what they know about the rules of arithmetic to figure out what each letter should be. In the end we come up with one of two possible solutions. Either 655 plus 655 equals 1310 or 855 plus 855 equals 1710. Here is one possible design for coding up a solver for these types of problems. That design would be to write down all the rules of arithmetic in terms of carry digits, in terms of odd and even and so on. Now, that seems like a challenging task. There's a lot of complexity involved in understanding all the rules about arithmetic. Even if we figured out everything about addition, there's also subtraction and multiplication and other operators. So what we really want is a short cut that'll allow us to eliminate this complexity. Let's go back to the back of the envelope and see if we can figure out a shortcut. One possibility would be to try all possibilities. There are 10 digits. All combinations of digits--all permutations of the digits, rather-- would be only 10 factorial, which I happen to know is about 3 million. That's not so many. It seems like it's feasible to try all the possibilities. It's not going to be super quick. We would rather have this be thousands rather than millions because there seems to be a fair amount of work in substituting in all the letters with digits. But we can expect to be able to try all millions, not within a second, but within about a minute or so. Now we have an approved design, which is we represent our formula as a string, and we'll use official Python notation here with the double equal sign. Then we fill in with all permutations of the 10 digits for each of the letter, and if there's fewer letters, we have to account for that. For example, we might substitute a 1 for the Os, and a 2 for the Ds, and a 3 for the Es, and a 4 for the Vs, and a 5 for the Ns. Otherwise just copy the equation. Then evaluate that and check if that's equal to True. If it is, then we have a solution. If it's not, we'll go back and we'll try another combination-- maybe 1, 3, 3, and so on. We'll keep on going through until we find some permutation that works. That's the design. Now, let's take an inventory of all the concepts we're going to need. First we have equations. There's two types of those--the original and the filled-in. The original has letters. The filled in has digits. Letters and digits are concepts we have to deal with. The assignment of a letter to a digit or set of those is also a concept we have to deal with. I think that's pretty much it. Maybe one more concept is evaluation or validation that the filled in equation is an accurate one. Now let's come up with some choices to represent each of these concepts. The original equation can be a string. The filled-in equation can also be a string. The letters will be single character strings like D. The digits will also be single character strings--like 3. The assignment of letters to digits will be some sort of mapping or a table that consists of this type of mapping that says D would be replaced by 3 and so on. It turns out that there is a facility built into Python that's part of strings called the translate function. We can call the str.translate method in order to enact that type of assignment or substitution. Then for the evaluation, there is a function called "eval" in Python, which takes a string and evaluates it as an expression. You may not be that familiar with these last two items, so let's go over them. Eval is pretty simple. If we asked for eval of the string "2 + 2," then that would give us a value 4. If we asked for eval of the string "2 + 2 == 3," Python would evaluate that using it's normal rules and tell us that that's equal to False. Now I'm going to show you how these translation tables work. I'm going to define a variable called "table" that's using the string.maketrans function, which makes a translation table, and I'm going to tranlate from the characters 'ABC' to '123.' I can give any number of characters here-- the characters I want to replace and the ones I want to replace them with. I should say that this is using the string module, so somewhere we have to say import string before we start doing any of this. You only have to do that import once, of course. Now I'm going to define a formula f to be a simple formula A plus B equals C. Then I'm going to call the translate method of the formula f and pass it this translation table. That will evaluate to the string 1 plus 2 equals 3. It has taken each of the elements in the table, and they correspond A to 1, B to 2, C to 3, substituted those into f and given me back a brand new string. Now if I go ahead and evaluate f.translate of table, which is 1 plus 2 equals 3, then that will give me the result True, because 1 plus 2 is 3, and that's a legal Python expression. Now what I want you to do is to define for me the function "valid," which takes a filled-in formula like 1 plus 2 equals 3, filled-in formula f, and returns True or False. True if the formula is, in fact, valid. If it represents a true equation like this. And False if it represents an invalid equation like 1 plus 3 equals 3. Or it should also return False if it represents a error like 1 divided by 0 equals 3. That wouldn't return True or False, that would signal an error, and I want you to handle that within the code for valid. I'll give you a hint, which is you should consider using a try statement. Try, do something, and then you can say "except ZeroDivisionError" something. What that does is it executes the main body in which you can test if evaluating this expression f is true or not and return appropriately, but if evaluating the expression f causes a zero division error, then this clause will catch it, and then you can do the appropriate thing here. You should also think about if there's anything else that can go wrong within the execution of valid. Here's my version of the solution. I'm defining valid, takes filled-in formula f, and it's going to return True. The main part is if we evaluate f and if that's true, then we should return True, but I also had to check for the zero division error and even to be a little bit more sore here, I ended up checking for arithmetic error, which is a super class of zero division error. It covers a few additional things like overflow of really big numbers. You didn't have to do that. I would've been fine to just catch the zero division error. If there is such an error, then you should return False. But I did one more thing here, and it looks kind of complicated. I'm using a regular expression search, and let's look at exactly what's going on in this confusing part of the clause here. Let's say we have a formula like ODD plus ODD equals EVEN. Now, one of the rules of the way we form numbers is that we don't want to have a number that starts with 0. EVEN could be, say, 3435. That would be a perfectly valid set of digits to fill in for the word EVEN. It shouldn't be 0405, because we just don't normally write numbers with a leading zero. I excluded that. How did I do it? I did a regular expression search for the regular expression slash b, which matches at a word boundary--b stands for boundary. Then I'm looking for a zero followed by any digit 0-9. I'm looking for that within f, and I want that to be not true. If I took this string here--something plus something equals 0405, and I did this regular expression search, it's saying find me a word boundary, a boundary between a letter and/or a digit and something that's a punctuation or something else, a word boundary followed by a 0, followed by another digit, it would say, yes, indeed, that search does succeed. It succeeds right here. The 0 and the 4 match. I want that not to succeed, so I would return False. I would rule out this case where we have a word starting with 0 and 4. I did that, one, just because it's good form that normally you don't allow valid numbers to start with a zero, and also because in Python we could come up with an error because of that. Here is the problem. In a Python program, the string 012 corresponds to an integer, but the integer it corresponds to is not 12. It's 10. Why is that? Well, it's an old historical accident. Way back in the 1970s, the C programming language defined it that way, where they said any number that starts with a 0 is going to be interpreted as an octal number, which means base 8. So 012 means one 8, zero 8-squared, and 2 more, so 8 + 2 is 10. So that would give us the wrong answer if we allowed octal numbers to sneak in where we were expecting decimal. It would also give us a possible error. If we had the string 09 that gives you an error, because 9 is not an octal digit. To avoid all those problems, I put in this regular expression that says any time you see a lead zero just rule it out. Now what I want you to do is write for me the code for the function solve. Solve takes an unfilled formula with letters in it, and if it can find a solution in which you can fill in all the digits, it returns the string with the digits filled in properly. If not, it should return None. Put your code here. You can assume that we already have the correct definition of what a valid filled-in formula is. You can assume that we have a function called "fill_in" that I'm not showing yet. Fill_in takes a formula and generates a collection of all the possible filling ins of the letters. You pass it the string ODD plus ODD equals EVEN, and it passes you back first string filled in with, say, a 1 for the O and a 2 for the Ds and so on. Then the next string filled in with different numbers filling in each of the possible digits, and so on and so on. Here's a code that's pretty simple. All we do is we iterate the variable F over all the possible values of filling in the formula. If we say that filled-in formula F is valid, then we should go ahead and return it. Otherwise, when we get through the end of the loop, we automatically return None. Now I want to talk about a strategy for defining the function fill<u>in,</u> which takes an unfilled formula and returns all the possible filled in formulas. What do we have to do? Well, let's consider a formula, and I'm going to take one that's simpler than one we've seen before. I'm going to take the formula I plus I equals me. What we have to do then is find out what all the letters are in this formula and fill in all possible values for digits for those letters. It seems like a good thing is to collect all the letters, and in this particular formula the letters should be IME. What are the possible digits that we want to replace these three letters with? Well, we can just iterate through all the 3-digit numbers, but make sure that we're not duplicating any of those numbers. So maybe we'll start with 123, then 124, and so on, 120, and then 13. We wouldn't do 131, because we already have a 1 there, so 132, 13--can't do 133, so 134, and so on and so on. We just have all these possibilities. How many possibilities are there? Well, there's 10 possible first digits. Then we don't want to repeat a digit, so 9 possible second digits, and 8 possible third digits, so that's 720 possibilities. Not very many at all. It should be really fast to go through all these possibilities. Now, what function gives me all the possible sets of numbers in order--so order matters. 120, for, example is different than 012 or 201 and so on. What function is it that we give it the list of digits? so we want some function F, we give it the list of digits, and we give it the number that we want, and there are three letters in this particular formula, so we want three of them. What function F takes that and then returns this sequence of all possible sets of numbers? Maybe it returns it as a tuple or a list or whatever. The question is what function can do that. Is it combinations, permutations, factorial, or some other function? The answer is that it's permutations. That's what the definition of permutations is. We take some collection, and then we pick out some number of them. The order matters, and we have all possibilities. So there is a built-in permutations function. It happens to be in a library called "itertools." Now with that in mind, I've given you the template of most of the the fill<u>in function,</u> and I want you to just put in two missing pieces. What does the fill<u>in function do?</u> First, it finds all the letters in the formula, and I want you to fill in that piece. Then it iterates a collection called the digits, a permutation of the digits taken from all the digits n at a time, and you have to fill in the right value of n. Then it builds a table from taking the letters. That means you want to make sure that the letters up here are represented as a string and not as some other type of collection. It makes a translation table from the letters and a string of all the digits that we got out of the permutations. The function itertools.permutations returns a tuple of results, and so we want to join together that tuple into one big string, make up the translation table, and then call formula with the translate method with that table to translate all the letters into the appropriate digits and yield that result. In other words, fill<u>in is a generator function not a function that returns a list of results.</u> Why did I do it that way? Well, because you might get lucky. It might be that the very first formula you try or one of the few first formulas you try is the correct one. If I do for f in fill<u>in a formula, I ask for the first formula, and if it is valid,</u> then I want to return it right away. I don't want to waste time calculating all the other possible fill<u>ins.</u> That's why a generator makes more sense here. See if you can fill in these two missing pieces. The first part here was easy. We want digits to be the same length as the number of letters, because we want to substitute them one for one--123 for ABC or whatever. We want to ask itertools.permutations to take permutations of the letters taken n at a time where n is the number of letters, the length of the letters. That part's easy. This part's a little bit more complicated--how do we find the letters. Here's what I did. I used the regular expression, the "re" module. I used the findall function so that says find all letters from A to Z, and I didn't specify here capitals before. My interpretation and the general rules for this type of cryptarithmetic problems is that they should be capitals, but if you allow lowercase as well, that's fine. Find them all within the formula, make a set of those, because if a letter occurs more than once we don't want multiple versions of it. We just want individual ones. Then join them together into a string. Now, I should say that I snuck in one piece of code here that you haven't seen before that may seem wild at first. That's the very first line. It says from future import division. That seems pretty amazing. Wow. Python has a built-in time machine. What does it mean to import division from the future? In Python 2.x, version 2.6, 2.7, and so on, if you do integer division in Python 2.7, say, 3 divided by 2 evaluates to 1. And 1 divided by 2 evaluates to 0. The reason is in their wisdom the designers of Python said, well, if you're going integer division, you probably want an integer answer, and we'll do the best we can, and we'll have to truncate to give you the answer. In Python 3, the designers decided, well, that's really confusing. What you really want when you divide 3 over 2 is 1.5, and when you divide 1 over 2 you want 0.5. That's what Python 3 does, so it says let's change the result from an integer to a floating point number if that's the best you can do. Now, if you want this kind of behavior in Python 2, then you say from the " <u>future</u> <u>" with two underscores on either side of it import division.</u> I want that because in my cryptarithmetic problems I really prefer this type of answer and not that type of answer. Now I'm done, and I got a pretty concise program. It followed by plan very nicely and easily. I like this design of the three pieces that I've tried to divide it up into. Look how simple the solve function is. It just says iterate over all possible ways of filling it in, ask if it's valid, and if it is, return. Can't get much more clear than that. Valid is pretty simple. Valid is almost like asking is eval f True. If it were that simple, I would just put it in line up here, but it's not quite that simple. I need the try and except, and I need to catch the arithmetic error, and then there's this little trick with the leading zero digits. I like having a separate function for valid to break that out. Then I like having fill<u>in as a generator.</u> To make the logic of the main function simple but not to slow me down by requiring me to generate all the possible answers at once, the generator comes up with up the answers one at a time. It's separating out the flow of control from the logic. Now, am I done at this point? Well, no, because what I have to do next is convince myself that I've got it right. Here I've defined some test examples, and here I've written a simple test function. What does it do? It iterates through each of the possible examples. It prints out what the example is, the original formula. Then it uses the time call function that we defined in the previous lesson. It calls solve on the example and gets back the time it took and the possible results and prints that out. Then in the end it prints out the total elapsed time and does that by starting a timer at the start and taking a time at the end and just calculating the difference. It's going to tell me for each example what the answer is, how long it took for that example, and how long it took for all of them together. Here is the results of the test. For each example, we see the example printed, then the filled in example found, and you can verify that that is, in fact, correct. It took a tenth of a second or so. Some of them take less. When there's only one variable it's really fast. Here we find these Pythagorean triplets of 3-squared plus 4-squared equals 5-squared, and 5-squared plus 12-squared equals 13-squared. Notice that we've gone beyond the most simple of cryptarithmetic problems, which were just word plus word equals another word. Here we can allow division and exponentiation. Over here I've been even more complicated where I've come up with AN plus BN equals C**N, and N is greater than 1. The lowercase letters I have not translated, because I said the only letters that count as being translated by digits are going to be the upper case ones, so I can use any of this Python syntax like the and operator. Now, if you can find a solution for this when N is greater than 2, I want you to let me know. But here I found one when N is greater than 1. I've split the atom. I've determined that all that glitters is not gold. I've determined that 1 is less than 2 and 4 is less than 5. You can see a bunch of other equations that I've been able to process, including ODD plus ODD equals EVEN. And for these 14 different examples it took 2 seconds. Not too bad. Now I want to ask you one quiz question. What if we wanted to return or to print all values of the filled-in formula rather than just the first one? For some of these formulas there are multiple possibilities of digits to fill in that would all work equally well. If we wanted to see them all, if we wanted to have them all printed out, what should we do? Should we change the function fill-in to return a list rather than generate results? Should we change the single word "return" to "print" in the function solve? Should we change the function valid to do something else to validate each of these possible formulas? Or do we need to add a new function to do something that we haven't done before? The answer is all we need is this one word change. So far we're returning the first value we found, but if we print it, then we can see that and the loop will keep on going, and we can see all the possible Fs--the filled-in formulas that are valid solutions. Now if you have Python installed on your own machine, and you have some kind of a terminal or shell in which you can get a command prompt, you can type the command Python, and then give it the -m flag, which says module, and then load what's called the cProfile module-- lowercase c, uppercase P. Then the name of your file that you want to profile. I called my cryptarithmetic file crypt.py. Execute that, and you'll get a nice table of where all the time goes. If you don't have Python installed or you can't run a command like this, you can do it from within Python. What you'll have to do is say import the c profile module, and then do cProfile.run and then a string to be evaluated, which is the code that you want to run. Then you'll see output that looks like this. In the right had column we see the various functions that are being called. Within my crypt program there are three main functions--solve, fill in, and valid. Then within the regular expression module, I was calling search and compile, and then there's various other built-in methods of Python, such as the string maketrans function, the eval function, and so on. These other columns tell us the number of times each of these functions was called, the total time spent, some percentage--we won't worry about that. That's time per call. Then the cumulative time, the total number of times spent there. Mostly I was just called solve. That was about 75 seconds. Within that 62.7 seconds when to valid, so that's where most the time is going. I should say that most of these results are pretty much what I was expecting. I was a little bit surprised that the re search too so much time--12 seconds out of the 75. I was also a little bit surprised that this maketrans and these other methods, the translate methods, took so little time--just about 3 seconds all together. If we want to make our program faster, it seems obvious that we'd better look where the time is. Out of that 75 seconds, 63 of it is within valid. That's where we have to look. Of valid, 47 seconds is within eval. If we want to make our program faster, it makes sense to concentrate our efforts on the parts where most of the time is. It's not just a good idea. It's the law. It's called the Law of Diminishing Returns. The way the law works, if we imagine our total execution time as being this bar here, and if we said that goes up to 75 seconds, 63 of those seconds was taken up by the call to valid, and 10 seconds was taken up by fill in, and then all the rest by everything else. We can see if we want to make things faster. We'd better make this bar shorter or maybe this bar, and it won't help much to make these other bars shorter. For example, if we made fill in and everything else vanishingly small, then if we didn't touch valid we'd still have an execution time of 63 seconds, even if we could improve these infinitely fast and we wouldn't have helped all that much. Here is a quick quiz on diminishing returns. Say if we have an execution time that's this long and function A takes up 90 seconds, and function B takes up 10 seconds for a total of 100 seconds execution time. Let's saw we're able to make an improvement to our code. We speed up B by a factor of 10. We make B ten times faster. The question is how much faster do we make the overall execution of our whole program if B is made 10 times faster? Do we make the whole program 9 times faster, 5 times faster, 2 times faster, or 1.1 times faster? These are approximate number, not exact numbers. The answer is even though we sped up B by a factor of 10, we've only made the whole program 1.1 times faster-- that is, 10% faster. The problem is we've left A unchanged, so our new program would have an execution time that looks like this. B would be this tiny little slice here. It would just take 1 second rather than 10 seconds, but the whole program would still take 91 seconds. If we want to make our program faster effectively, we'd better concentrate on the eval function, because that's taking up about 47 out of our 75 seconds or about 63% of our time. The problem is that eval is a built-in function. We can't go editing eval to try to make it faster, but if we can't touch eval itself, the only choices we have are we could make fewer calls to eval. We call it fewer times. We'll spend less time in it. Or we can make easier calls to eval. Pass it an argument that's easier for it to evaluate. Let's concentrate on easier first. Do you see a way to break up the problem of evaluating a formula into smaller pieces in such a way that we could make the resulting program, say, 10 times faster. What do I mean by making it easier or breaking it up into pieces? We could do eval of ODD plus ODD and then do eval of EVEN and do those separately rather than do them all together in one equation. Of course, I'd probably substitute in the numbers here rather than eval the letters themselves. That might be one way of breaking it up into smaller pieces. Often this idea of divide and conquer is a good idea for program design. Do you think that that approach would work here to make the calls to eval easier so that we could cut down on this 47 second execution time. Yes or no? I guess this is an matter of opinion. You might have some ideas. I might have different ideas, so don't worry if you agree with me too much, but think about it and give me your answer. Well, my answer was no. I couldn't think of a good way to break these up that would make the calls easier and still get the job done. If you've come up with a good way, great. I want to hear about it. Let's talk about it in the forums. But if we can't figure out a way to make the calls easier, then we're going to have to concentrate on having fewer calls. Let me write down some possibilities for fewer calls and see which ones you think make sense. One possibility would be for each equation, like ODD plus ODD equals EVEN, rather than evaluating them all N factorial times, maybe we could combine all of those into one big equation. Certainly that would result in fewer calls if we could figure out a way to do that and still get the right answer. Another way might be to, say, could we figure out a way to fill in one digit at a time? Rather than do all N factorial permutations of digits, if we could do one digit, see if that works, and if it does then do the next digit. That would certainly help us do a smaller number of calls. That's the approach we took with the zebra function where we started out by doing all the permutations, and then we figured out let's go through and if there's a contradiction, let's stop and not do the remaining ones. The question is can we figure out a way to take that general approach for this problem. Then the third approach would be to eval the formula once but eval it as a function with parameters. To do all the work of figuring out how to understand number plus number equals number, do that just once and then call that function repeatedly with all the permutations. There'd still be lots of calls to the function, but there'd be fewer calls to eval. Tell me which one of these three do you think is the most promising. Again, it's a matter of opinion. You might have better ideas, but I want you to think about it and tell me what you think. My feeling was that this was the most promising. I couldn't figure out how to fill in one digit at a time and make that work, because if we had something like the word EVEN, and we fill in 1 digit, and we have, say, 8V8N, I didn't figure out how to make sense of that. We have this mixture of some letters that are filled in and some that aren't. That didn't work for me. This approach, one big formula--yes, we could figure out a way to make one big formula, but the problem is I don't think that would be any faster, because it would take eval a long time because it would be a very long formula. This approach I think is the most promising, so let's talk about it. Let's consider a formula--I'm going to write a new one. Let's say You equals Me-squared. We're treating these formulas as strings. Now when we substitute numbers into this, we get something like 123 equals 45-squared. What happens when we call eval on this string? What eval has to do is it takes it's input, which is a string, and then it has a process of parsing that string into a parse tree. The parse tree would say something like this is a comparison, and it has an operator, which is a number, which is 123, and another operand, which is an expression which has the number 45, and then the exponentiation operator, and then the number 2. Python builds up a data structure that looks something like that. There's another operation of code generation in which Python takes this tree and says in order to evaluate this tree I'm going to do something like load the number 123 and then load the number 45 and then do an operation on that and so on and so on and then return the result. That's a lot of work to build up this tree, generate the code, and then finally, the final operation after we've come up with this, is to execute this code and come up with an answer, which in this case would be false. Now, this is a lot of work for eval to do, and it seems like there's a lot of duplicate work, because we're going to do this for every permutation of the digits, but each time we go through this part of the work, the parsing, is going to look exactly the same with the exception of the specific numbers down here at the bottom, but the rest of the parse tree is going to look the same. Similarly, this part of the work, the code generation, will also look the same except these numbers will differ. We're going to have to repeat that over and over again. What we'd like is an approach where we can only do these two parts once and then pass in the specific numbers and then get our final result back. But one this I should say is that the eval function doesn't take a statement, like this function definition. It takes an expression. Furthermore, we don't really need this name F. That was kind of arbitrary. We'd be fine with having an expression that represents a function but doesn't have a name associated with it. Then we can pass that directly to eval. It turns out there is a way to do that in Python. There is a keyword that creates a function as an expression. That keyword is lambda. It's kind of a funny keyword. I would've preferred them to use function or fun or maybe just def and leave the name out, but they chose lambda. It's based on the lambda calculus, the Greek letter λ, which is a branch of formal mathematics defining functions. The syntax is fairly similar to the syntax of a definition of a function, except we leave the name out. It's an anonymous function with no name. It also turns out for some reason we leave out the parentheses. We just say lambda Y, O, U, M, E, then a colon, and we leave out the return, and then we just put in the rest of the code--100 times blah, blah, blah, blah. Here's an example of how it all works. This I've actually typed into the Python interpreter. I've defined a function f as a lambda expression. It looks like this. Then I've asked what F is. All Python prints out is it says that it's an object of type function, which doesn't have a name other than the lambda and the address and memory where it's stored. Then I'd say, is F true of the sequence 1, 2, 3, 4, 5. That is, Y is equal to 1, M is 2, E is 3, U is 4, and O is 5. The answer is no, it's False. This is not equal. Then I asked is it true for 2, 1, 7, 9, 8. Yes, that's true. The reason is because it works out to this expression 289 equals 17-squared. Now I'm thinking of a design where we have some type of a solve function that's going to solve a formula, and we're going to have a compile formula function that's going to take a string formula as input and return a lambda expression function as the result of compiling the formula. As part of that, I want to have a function that I'm going to call compile_word, It's going to take a word like ME and compile that into something like 10M plus E. You could have some variation on exactly how you want to express that. It will also take a word like equals and compile that into itself, into equals, and a word like 2 and compile that into 2 itself. This is the function I want you to write. Compile_word where compile_word of YOU is something like this-- don't worry about the communicativity and associativity. You can write this any way you want as long as it is a code that would compute the right answer. It's important to put parentheses around it. Anything that's not an uppercase word you should leave alone. Here is what I did. I used the isupper method of the word, which is a string. String.isupper method to check if it is in fact an uppercase word. If it is, then I enumerate all the letters in the word. I reverse it, so this slice says reverse it. The missing numbers on either side says take the whole word, and the -1 says go from the back forward, so reverse the word, enumerate it give me pairs of indexes from 0 to N along with the individual digits. Then I'm going to just say 10 to the ith power and the digit. That gives us 1 times U plus 10 times O plus 100 times Y. It works out backwards from the normal YOU order, but that doesn't matter. I take those results, I put a plus sign in between them, and I wrap parentheses around them. If it's not upper, I just return the word itself. Now I explained the whole program. I'm calling it faster_solve, and I take a formula. The first thing I do is compile the formula. That gives me back the function that represents it, and while I'm there, I'm also returning the letters that are within the formula. That evaluation or compilation of the formula is done once. Then I go through all the permutations of the digits taken length of letters at a time. Notice that I'm using actual integers here, not strings, for the individual digits. If applying the function to the digits is true, then I did the same thing that I did before of making up a translation table and calling the formula.translate to get my final result. Note I only have to do this translation once. On the specific permutation that I know works, I don't have to do it every time like I did in the previous version of solve. Then if there's an arithmetic error, I catch that and go on to the next permutation. Now, the function compile_formula takes a formula as input. First I figure out all the letters, so that's going to be the Y, M, E, U, and O. Then I figure out that the list of parameters I want to put into my function is going to be a string consisting of the letters with a comma in between them. I figure out all the tokens. A token is an individual term like the U or the equal signs or the ME and so on. Now let's take a look at what we did here. So we had re.split and then this regular expression and then out of the formula. So what does this say? This says I want to split up the original formula, and the way I'm splitting it up is I'm taking sequences of the characters A-Z in a row. The plus means one or more, and the parentheses means keep that result. So when I have you = me squared, this part and this part will match, and they'll be returned as individual elements in this split, and so will the other parts. Re.split will return the list consisting of the parts that it found in the split plus everything in between. And it will be this type of list, and then I'm going to map compile word-- it didn't quite fit on one line-- to re.split, and that will give me-- these tokens will remain unchanged, and these will be converted into the form that multiplies out the digits. Then I'm going to assign that to the variable tokens. Now I've got my tokens. The body of the function we just formed by concatenating all the tokens together. If I wanted to I could put spaces between them; it doesn't matter. And the function is lambda created with the parameters in the body, and then I just return the evaluation of the function, so that complies the function, does it only once rather than once per permutation. And I return the letters that I found. As a convenience, because when you're debugging this function you may want to say, "Well, what did this function look like?" "What did I come up with? What did I come up with?" I have an optional parameter here I have an optional parameter here that says if you pass in verbose equals true, then it just prints out what it found. It just makes it a little bit easier to debug this function. And now, when I run profiling again, look what I get. The time has sped up quite a bit on the simple list of 14 examples that we saw before. This version of the code is 25 times faster. On a more complex list, it's only 13 times faster. But it's at least an order of magnitude faster. And we did that because we eliminated calls to eval. So we found the bottleneck. We found that eval was the function that was taking up the most amount of time in the previous profiling. We figured out a way to call eval less often by precompiling, and now we've done away with that difficulty. Let's do a recap of what we learned in this unit. First, we talked about some Python features that were maybe new to you. We used complex list comprehensions. That's something like x-squared for x in blah, blah, blah, if something. We showed generator expressions, and that's similar but with parentheses. We talked about generator functions or just generators, and we recognize those with the yield statement. We talked about the idea of handling different types. This has the fancy name of polymorphism, meaning different forms. We saw an example of that in timed calls where we said that the input n-- and then there are other inputs there--n could be either an integer, in which case we would do one thing, or a float, in which case we would do something else. We checked which is which by using "isinstance." We talked about the eval function and how we can use that to map from a string to a Python object, which is the result of evaluating the string. In particular, the case of evaluating to a function. Eval is a way of making the computation be done once and getting all that work over with so that we can then use that work repeatedly. We also talked about instrumentation, and we did timing with the time.clock method that's built in, and then we built up timedcall and timedcalls routine. And we talked about counting number of invocations of functions or assignment statements or whatever. There we came up with our own routine that we called c. I guess I should say a little bit about variable naming conventions. Why did I use a short name like c here, whereas other places I had long, more expressive names? I guess the reason is c was used only for debugging purposes. It wasn't intended to be part of the final part of the program. I felt justified in having that be short, because I was going to be typing it and deleting it frequently. Things that are going to persist for longer have longer names For example, it's fine to say "for i in range something" where there we know that i is an index integer, and it only persists over this short loop. It's okay to have a short name. If something lasts longer, we probably want it to have a longer, more descriptive name. Hi. Welcome back. As you can see from this spread, this lesson is going to be about tools. Now, we homo sapiens fancy ourselves as tool makers. We think that's what distinguishes us from the other animals. In the physical world, we've invented lots of tools. These general ones like screw drivers and plyers, you're probably very familiar with, and some very specific tools--look at this one. You may not know what this does, but look how nicely it fits into my hand. Or look at this one. What do you think this one does? If somebody can tell me on the forum what this one does, I'll send them a swell prize. or look at this one--surgeons forceps. Now, these have been refined over the years and now we can refine them where they serve as a third hand. It's got this trick where I can attach it on, and now I don't have to put my hand on it anymore, because it's got a little locking mechanism. Our tools get better and better over time. Now, there's a saying that a poor craftsman blames his tools. I always thought that all that meant was you shouldn't complain, you shouldn't whine, but I realized it means more than that. It means that the tools become a part of you, and if you're a good craftsman then the tools are a part of you. You know what to do with them, and so you're not going to end up blaming your tools. That's what we're going to learn in this lesson about software tools. We're going to learn about some general software tools, about some very specific software tools, and specifically, we're going to talk about two. We're going to talk about, first, language. Now, language is perhaps homo sapien's greatest invention--our greatest tool. In computer programming, well, a computer program is written in a language, but a computer program can also employ language as a tool to do its job. The other tool we're going to talk about is functions. Of course, you've been using functions all along, but we're going to talk about new techniques for using functions and learn why they're more general and malleable than other tools. So see you in the lesson. If you haven't heard of regular expressions or used them before, then this review is for you. If you have, feel free to skip to the next video. Let's start by reviewing what you know about finding a substring within a string. Suppose we have a string called S in Python. Now, you may know that we can find a substring within it-- For example, s.find of 'word' will return the position in which the string 'word' occurs within s and return that index if it exists. So in fact, where it does exist, so it will return that index, 0-1-2-3-4 and so on. It turns out the answer is 21. And if it didn't exist at all, then by convention, it would return -1 to indicate failure, because -1 is not a valid index. But suppose we aren't looking for exactly one individual word. Suppose there's a whole family of words that we want to find. Take a crazy example: Let's say we're interested in the family of words used by sheep. There's a sheep. And what do they say? Well, the sheep can say, "Baa!" or "baaaa!" and so on. Let's say we're interested in the family of words that have a B and an A and then any number of more As, and then an exclamation point. We can't specify that as a single word for "find" or even as a finite set of words, because there's an infinite set of words. And so what a regular expression is is a way of describing that infinite set of words in an interface that allows you to find them. So a regular expression, which we'll also call a pattern, is a way of describing this infinite set of possible words. We'll describe it as a string, and a string starts with a B and is necessarily followed by an A, and then followed by any number of subsequent As, and for that we'll use a special notation, A*. The asterisk means, "Any number of the preceding character." And then it has to end in an exclamation point. So that's there. So the asterisk is a special character. The exclamation point, the As and the Bs are normal characters. And this regular expression or pattern specifies this infinite language of "baa"s with any number of As more than one. So what goes into a regular expression? Well, we saw one example where the star was a special character, and where, for example, A* represents "a," "aa," "aaa," and so on, as well as the empty string, because it could be zero occurrences of A. So let's make a list of the special characters, examples of their use, and what they match. So we've seen the asterisk. Another special character is the question mark. So "A?" matches either the empty string or the single string A, and nothing else. So it means an optional occurrence of whatever comes before. In this case, an A. It could be a B, a C, whatever. Another special character is the dot or period, and that stands by itself. It doesn't have a two-character sequence. And so for example, a dot can match the character A or the character B or C or 7 or exclamation point, or any other single character. But it doesn't match the empty string, and it doesn't match a multiple character string. We're almost done. There's only two more special characters in this subset of regular expressions that I want to talk about. Languages like Python have very complicated patterns that they match against for regular expression. Some of them go beyond regular to irregular expressions. But we're going to talk about a specific subset that we can write a program for to do regular expression matching. And it's only going to have five special characters. So these three, then the up arrow, again, is a character that's by itself, not a two-character sequence. So the up arrow by itself matches only right at the beginning of the line, or, that is, the beginning of the text that we're matching against. And so it's not much use by itself, but in conjunction with another character, it can limit the match to the beginning. So for example, up arrow-B matches against any string that starts with a B, like "ba" or "bb" or anything else where B is the first character, but it doesn't match something where the B is in the middle, like ABC, Whereas B by itself would match against ABC in the middle. And finally, $ is the convention for matching at the end. So, A$ matches "ba", but doesn't match, say, "ab" or anything else where the A isn't at the end. So let's correctly strike these out to say that these are not matches for these two patterns. Okay, so that's it. These are the five special characters. What else goes into a regular expression? Well, the empty string, and the only example of the empty string is the empty string. And what does that match? Only the empty string. Then any character that's not one of these five, like an A, that matches exactly the character itself. A matches A, B matches B, and so on. And finally, any concatenation of two regular expressions matches those two one followed by another. So, "ba", that matches "ba", but doesn't match other sequences, like "aa" or "bb". Okay. So that's my language for regular expressions. Five special characters, empty character, one character, or two regular expressions concatenated to each other. Let's get to writing some code. Now, in the Python RE module, there are two functions: search and match. Search takes a pattern, a regular expression in the form of a string as we've defined, and a text, and it returns "true" if the pattern appears anywhere in the text. Rather, I should say I'm simplifying a little bit here. The Python RE module returns a more complicated result, a not literally true, but a result that is true and has some more data. But in our implementation we're just going to return "true" or "false." So if the pattern occurs anywhere in the text, return "true", and then "match" says "return true if the pattern appears at the very start of the text." To make sure we understand what these are supposed to be returning, let's add some tests. Here we had four tests, each testing this regular expression, "baa*!" If we search for that within the string, "Sheep said baaaa!" it should find it right here. If we search within this string, it shouldn't find it because the B and the As are there, but it's not followed by an exclamation point, so that should be false. If we try to match it against this string, it's false because it doesn't occur right at the start. And if we try to match it against this string, it's true because there is a match right at the start. Now, regular expressions are complicated, so I wanted to add some more tests. Just to go through, we'll check for the dollar sign, we'll check for the up arrow at the start. We'll check for stars, we'll check for the question mark, optional, and we'll go into more detail, testing a pattern against multiple possible words--at the end, at the start, in the middle, check for this dot character. And if we can do all that, then we have some confidence that our routines are working. So let's get back to the routines. Now, if you want, you could go ahead and try to write search and match. They're complicated, and you need to understand a little bit about the processing of regular expressions to get them right. If you feel you're up to it, go ahead and try it now. If not, I'm going to lead you through it step by step. The two seem similar, so it'd be nice to write one in terms of each other. Let's write "search" in terms of match, although it'd be possible to do it the other way around. Now, a real distinction is whether a pattern starts with a up arrow or not. So if we're searching, remember, a search tests against anywhere in the pattern. So what I'm going to do is I'm going to check, say, "Does the pattern start with the up arrow?" And the only place that the up arrow really makes sense is as the first character in the pattern. If it appears elsewhere, we're gonna just consider that an error and not try to deal with it. Your program can return whatever you want if the up arrow appears in the wrong place, not right at the start of the pattern. If it does return right at the start of the pattern, then we can reduce this to a match with some different pattern over the same text. And if it doesn't, then we can also return it to a match, reduce it to a match with some different pattern over the text. What I'd like you to do is fill in these two patterns to say, "What is a search expressed at in terms of a match with an up arrow and without an up arrow?" And the answer is a search with an up arrow constrains the pattern to match right at the beginning. So that's the same as just doing a match with the rest of the pattern. And the rest of the pattern is just the pattern from position one, onward. Now, if the pattern doesn't start with an up arrow and we're doing a search, that means the search could be anywhere within the text. But that's the same as asking for a pattern that has any number of characters at the beginning, match of any character any number of times, and that's the same as adding a dot star to the start of the pattern. Otherwise, let's walk you through it. And the answer is if the pattern is the empty string, then that matches anything, because the empty string occurs in every text, even if the text is itself empty. So we just return "true" no matter what. If the pattern is the dollar sign, that means that matches only at the very end of the text. So we want to return "true" only if the text is the empty string. So we say "return does the text equal the empty string?" True if that's true, false if that's false. And I put parentheses around it just as a convention of when you're checking in a return value. It makes it a little bit easier to see that this is a return value. Now, when we have a character followed by a star or a question mark, that's the hardest part, let's save that for last. Now let's consider the final case--and the final case is when we know that the pattern is not empty, and we know that we've gone through all the special characters. So the first character is not a special character, except maybe it's a dot, because we haven't dealt with dot yet. And so we want to match the first character, and then we want to match the rest of the pattern, whether that's empty or whether it's something more. So what I'm going to do is invent a new function that I call match one, and that matches a single character, and we want to return "true" if that single character which is the first character of the pattern matches against the text, and if we can recursively match the rest of the pattern against the rest of the text. So this is saying, "We don't have a special character here, except maybe a dot," and so we have like b followed by a, we want to match the b against the text, and then we want to match the A against something else. So fill in for me here what I should be matching against to match the rest of the pattern against the rest of the text. And the answer's pretty easy. We just want to look at the pattern and say, "We already dealt with the first character-- "Character zero," so now we just have to deal with the rest of the characters, and we already matched against the first character of the text, so now we just have to match against the rest of the text. Now, the final part is when we have a character followed by a star or a question mark. That's a little more complicated. I won't ask you to do that yourself. I'll show you. Let me walk you through this. First thing we're going to do is we're going to break up the pattern into three pieces. The pattern was something like "A*!" And so the first part is P, which is a single character that comes before the star. The second part is the operator, which is either a star or a question mark, and the third part is the rest of the pattern: Everything else after the star or the question mark. Now, there's two cases. If the operator is a star, we're going to just give up and call another function here. And we're going to have to write that function. But rather than do it inline, we'll call it, which we'll need because it's going to end up being a recursive function. So we'll match star, which says, "Match P any number of times followed by pattern against the text." If the operator is a question mark, then if we can match the first character, P, against the text, and match the rest of the pattern after the question mark against the rest of the text, then we return "true." But if we can't do that, then it's also okay, if we can skip the first character P, not match the first character P, and go ahead and match the rest of the pattern. So this matches when the first character matches; this matches when the first character fails. That's all there is to do with match. But now we have two promises to keep: We have to write match one and match star. Again, feel free to try them on your own if you want, but I'm going to go ahead and show them to you. Match one is pretty easy. So we're matching a single character P against the text. If there is no text, a single character can't match against it, so we return "false." Otherwise, if the P was a dot, that matches anything, so we should return "true." Or if the P is exactly equal to the first character of the text, then we should return "true." Now here's match star. We have a character P, we want to match any number of that, zero or more, and then match the rest of the pattern against the text. So how can we do that? Well, one way we can do it is by matching P zero times. So that's just matching the pattern against the text. Or we can match P one time against the text, and then do a match star of P followed by the pattern, against the rest of the text after the first character. Notice that it wouldn't do here to do a recursive call to match; we want a recursive call to match star. Because we want to say we're matching either exactly zero times, or one time followed by zero or more times. That's it. And if we go ahead and run the test and print out the results, we find that all the tests pass. And I should say that the subset of the regular expression language and the approach we use to solve it, I owe a lot to Rob Pike, who wrote a very nice essay on how to do this, and here's a URL link to it. And you'll be seeing Rob in an interview at the end of this class in the final unit. So that should give you some idea of what regular expressions are, how to write programs to process them, and a little bit of the power of what they can do. Now, in this program, a regular expression was just a string, and it was easy to deal with because all we had to deal with was the first character of the string, the second character of the string and so on. But regular expressions can get more complicated. They can have nested structures that are more like trees than strings. And so in the rest of this unit, we'll be dealing with an internal representation of regular expressions based on trees that will be different from this. You can still have input in the form of strings that gets translated into trees, but we'll be dealing with a tree structure from now on. So this should give you an intro and a review that's good enough to handle the rest of the lesson. You already know one language we've been using--the Python language obviously. That has a syntax for statements and expressions, but there are also some subparts of Python that seems like quite a different language. One example would be the language for formatting strings. Here's an example from the Python reference language. You see that this rather bizarre string here with %(#)03D and so on. There's a language of format strings itself to produce this type of output. There are other parts of the Python language that allow you to customize it to your use. You can create your own type of classes, and they can have their own type of expression, including operator overloading. We're used to expressions like x + y. Say if x is 2 and y is 3 then that would be 5. But you can also say x + y where x and y are your own types of data types. They might be matrices. They might be components of some kind of building that you're building, and this can say to put them together. It may be two shapes that you can concatenate on the screen. You can define your own language over the types of objects you want to deal with. You can go one step farther than that and define your own domain specific language. Here's an example. This is a language for describing an optimization problem having to do with the price on octane and various types of fuels, and you can describe the parameters and then build the language processor to take this as input and compute the output. Of course, you could do that with a regular Python statement just as well, but here what we've done is design the language specifically for this problem and then written the problem description in that language. In this unit we'll cover what is a language, what is a grammar, the difference between a compiler and an interpreter, and how to use languages as a design tool. We'll start with a language that many of you may be familiar with-- the language of regular expressions. You've seen them if you've taken CS101. Maybe you've seen them elsewhere. In any event, we'll give an overview of them. There's a language for regular expressions. They can be expressed as strings. For example, the string abc* describes a language, and that language consists of any number of a's followed by any number of b's followed by any number of c's. Elements of this language include the strings abc, aaa, bcc. Stars can be any number, so it could be zero of them. Say, just b would be an example. The empty string all by itself would be an example. Ccccc would be an example. An so on. Now, there's a whole language of symbols like + and ? and so on for regular expressions. To make sense of them, we have to be able to describe what are the possible grammars and then what are the possible languages that those grammar correspond to? A grammar is a description of a language, and a language is a set of strings. Now, this form of description of the grammar as a long sequence of characters is convenient when you're quickly typing something in, but it can be difficult to work with. Grammar expressions get long. So we're going to describe the possible grammars in a format that's more compositional. In other words, what I'm going to describe is an API, which stands for application programming interface. This is the interface that a programmer uses rather than the UI or user interface that a user uses when you click with your mouse. We'll describe a series of functions calls that can be used to describe the grammar of a regular expression. We'll say that a regular expression can be built up by these types of calls. First, a literal of some string S. For example, if we say lit(a) then that describes the language consisting of just the character string "a" and nothing else. We have the API call seq(x, y). We could say seq(lit(a), lit(b)), and that would consist of just the string "ab." So far not very interesting. Then we could say alt(x, y,). Similarly, alt(lit(a), lit(b)), and that would consist of two possibilities-- either the string "a" or the string "b." We'll use the standard notation for the name of our API call here. Star(x) stands for any number of repetitions--zero or more. Star(lit(a)) would be the empty string or "a" or "aa" and so on. We can say oneof(c) and then string of possible characters. That's that same as the alternative of all the individual characters. Oneof('abc') matches "a" or "b" or "c." It's a constrained version of the alt function. We'll use the symbol "eol," standing for "end of line" to match only the end of a character string and nowhere else. What matches is the empty string, but it matches only at the end. The only example we can give is "eol" itself, and we can give an example of seq(lit('a'), eol), and that matches exactly the "a" and nothing else at the end. Then we'll add "dot," which matches any possible character-- a, b, c, any other character in the alphabet. Now, of course Python has a regular expression module called the "re module." If you really want to use regular expressions, you import re and get started. The point here is not so much to use regular expressions as to show you what it's like to build a language processer. So to get started doing that, I started by writing a test function that defines some regular expressions using this API. First I defined a, b, and c as being these literals. Then I combine some more complicated examples. Then I showed some example of assertions, of what we want to be true. We've defined two functions that match the functions in the re module. The first function is called "search." It takes a pattern and a text, and in the regular expression module this function returns something called a "matched object." What we'll have it do is return a string which will be the earliest match in the text for the pattern, and if there is more than one match at the same location, it'll be the longest of those. For example, search('def', 'abcdef') would return "def" because it's found there. The next function is called "match." It also takes a pattern and a text and returns the string that matches. But for match, the match must occur at the very start of the string. Search('def') would return None, indicating that there is no match. But search('def') in this string that has 'def' at the beginning would return that match. Here are some examples of the types of things that I want to be able to do. That gives me the start of a specification for how I want to write my search and match functions. I would like to start out with an inventory of the concepts that are going to be used. So far we have the notion of a pattern or a regular expression, of a text to match against, of a result, which will also be a string of some kind. It doesn't seem like there's all that many more concepts. One thing that it looks like we'll need is some notion of a partial result, and some notion of control over the iteration. What do I mean by that? Well, some of the matches are easy. If we match search for a literal 'def' within 'abcdef,' it's easy to imagine just going down the line of this string and saying does it match here? No. Here? No. Here? No. Here? Yes. We'll return that result. But what if we're matching with the pattern--let's say we have the expression 'a*b+'-- any number of a's followed by one or more b's. In our API notation, we would write that as seq(start(lit('a') plus(lit('b')). Let's say we're matching that against the string 'aaab.' Now if we had a control structure that says sequence, look to match the first, and then look at the second, and if the first--star(lit('a'))--only had one possible result, then it would say, yes, it matches here right at the start, now look for something after that. Does it match plus(lit('b'))? No, it doesn't. I've got to have iteration over the possible results. I have to say that star(lit('a')) can match in more than one location. It can match with zero instances of a, with 1, with 2, with 3, and it's only after 3 that then we can match the second part, find the b, and then find that the whole expression matches. That's going to be the tricky part is worrying about this control when one part of a sequence doesn't match or similarly when we have an alternative between two possibilities--a or b or alt(a, b). This trickiness seems like it's going to be difficult, but it all resolves itself after we make one good choice. It takes some experience to see what that choice can be, but if we decide to represent these partial results as a set of remainders of the text, then everything falls into place. What do I mean by remainder? I mean everything else after the match. If we match a literal "a" the remainder after we match zero characters of this string would be "aaab"--three a's followed by a b. The remainder after we match one a would be two a's followed by a b and so on. What I'm going to do is define an auxiliary function called "match set," and it takes a pattern and a text, and it returns this set of remainders. When given just this pattern here as the input, star(lit('a')), and this text as the text then the remainder would be the set consisting of three a's and a b, two a's and a b, one a and a b, or just b. In other words, star(lit('a')) could have consumed 0, 1, 2, or 3 a's, and that's the remainder that's left over. So the result will be this set. Here's the code. It's just 20 lines or so. I've left out a couple pieces to give you something to do, but let me first try to explain how it works. We take a pattern and a text. We're breaking down the pattern into its components. The components are an operator and then and x and a y part, depending on the definition. For example the literal will only have an x component. Sequence and alternative will have both and x and a y. We'll see how that component is written later, but for now just assume it's going to pick out the right pieces. Then we decide which operator we have, literal, sequence, alt, and so on, and return a proper set accordingly. For example, if the operator is asking for literal string x, we ask does the text start with x? If it does, then the remainder will be a singleton set, a set of just one element, which is the remainder of the text after we've broken off the length of text characters. If we matched a three-character sequence for x, we return the text without the first three characters. If x was 1 character, we return the text without the first character. Otherwise, we return the null set. There's no match. The alternative is particularly nice. It says if we have an alternative between x and y we just return the union of the those two match sets. This character, the or bar, means "union" in Python, the union of two sets. Sequence is a complicated one. It says if we're asked for a sequence of x and y, we first find a matching set for x. That's going to be a set of possible remainders, and we go through all of those. Then take the remainder of that text, which would be t1. Then match y against that remainder. For each of those alternatives, that's what we're going to return in this set. For example, if this is our pattern--seq(star(lit('a')) plus(lit('b')))--it looks like that, and we're matching against "aaab" then the x is the star(lit('a')), and y is the plus(lit('b')), and the matchset for x is this set here. We try to match y, the plus(lit('b')), against all of these match sets, and it'll fail to match against each of these three. It will match against this one, and so now we have a match that consumes the entire string. The result from the match of this sequence of x and y will be the set consisting of just the empty string, because we've matched off all the a's and one b, and there's no remainder left over. Note that there's a big difference between the outcome of saying here's a result consisting of one string, the empty string, versus the set that is the empty set. The empty set is a failed match, and the set consisting of the empty string is the successful match. Now let's see if you can fill in your code for these two missing cases here. Remember, you're going to be returning a set of possible remainders if the match is successful. Here's my answer. A dot matches any character in the text. If the text has at least one character, then there's going to be a match, and the match is going to have a remainder, which is all the rest of the text. That remainder is a set, and it's the set of one element, and the element is the text from the first character on. In other words, dropping off the 0th character. We're going to return that if there is any text at all. That is, if the text is not empty. Otherwise, if the text is empty then we're going to return the null set. Defined the null set down here. How about for oneof? Oneof takes a string of possible characters and what it should return is similar to dot. It should return the remaining characters if the first character is equal to one of the characters in x. We're going to return exactly the same thing, a set consisting of a signal answer which is the original text with the first character dropped off, and we're going to return that. What I'd like to be able to say if the text starts with any of the characters in x. It turns out that I can actually say exactly that--text.startswith(x), if I arrange to have x be a tuple of characters rather than a character string. Here I have the documentation from the Python manual for the string that starts with method, and it says it's true if the string starts with a prefix, so we can ask does some string start with a particular string--yes or no? But prefix can also be a tuple of prefixes to look for. All we have to do is arrange for that x to be a tuple, and then it automatically searches for all of them. What I'm saying is I want the API function oneof('antibiotic'). That should return some object, but we're not yet specifying what that object is, such that the operator of that object is oneof, and the x for that object should be the tuple a, b, c. It's sort of a little optimization here that I've defined the API to construct an object of just the right form so that I can use it efficiently here. Just go ahead and check does the text start with any one of the possible x's. Otherwise, return no. If you didn't know about this form of text.startswith, you could have just checked to see if any of the character c for c in x. We'd say return the rest of the string if any of hte characters in x if the text starts with any one of those characters. Otherwise, return "no." This looks like a good time to define the rest of the APIs for the constructors for patterns. Here I've defined literal and sequence to say they're going to return tuples where the first element is the operator, the second-- if it exists--is x, and then the final--if it exists--is the y. Those are for the components that take an operand or two, but dot and end of line don't, so I just defined dot to be a one element tuple. See if you can go ahead and fill in the remainder of this API. Here are the definitions I came up with. Note that I decided here to define plus and opt in terms of things that we had already defined-- sequence and alt and star and lit. You could've just defined them to be similar to the other ones if you prefer that representation. It's just a question of whether you want more work to go on here in the constructors for the patterns or here in the definition of match set. Let's just review what we've defined in terms of our API. We have a function match and a function search, and they both take a pattern and a text, and they both return a string representing the earliest longest match. But for match the string would only return if it's at the start of the string. For search, it'll be anywhere within the string. If they don't match, then they return none. We've also defined an API of functions to create patterns-- a literal string, an alternative between two patterns x and y, a sequence of two patterns x and y, and so on. That's sort of the API that we expect the programmer to program to. You create a pattern on this side and then you use a pattern over here against a text to get some result. Then below the line of the API--sort of an internal function--we've defined matchset, which is not really designed for the programmer to call it. It was designed for the programmer to go through this interface, but this function is there. It also takes a pattern and a text. Instead of returning a single string, which is a match, it returns a set of strings, which are remainders. For any remainder we have the constraint that the match plus the remainder equals the original text. Here I've written versions of search and match. We already wrote matchset. The one part that we missed out was this component that pulls out the x, y and op components out of a tuple. I've left out two pieces of code here that I want you to fill in. Let's do match first. Match interfaces with the matchset, finds the set of remainders. If there is a set of remainders, then it finds the shortest one. The shortest remainder should be the longest text, and then we want to return that. We want to return the text, and it's a match not a search, so the match has to be at the beginning of the text, and it would go up to match. So we match from the beginning of the text. How far do we want to go? Well, everything except the remainder. How much is that? Well, we can just subtract from the length of the text the length of the shortest, and that gives us the initial piece of the longest possible match. Here search calls into match. What we do is we start iterating. We start at position number zero. If there is a match there for the text starting at position zero, then we want to return it. If not, we increment i to 1, and we say does the text from position 1 on-- is there a match there and so on. We just keep on going through until we find one. Here what we want to say is "if the match is not None, then return m." Notice that it would be a bad idea to say "if m return m." Normally it's idiomatic in Python to say that if we're looking for a true value. But the problem here is that the empty string we want to count as a true value. A pattern might match the empty string. That counts as a match, not as a failure. We can't just say "if m" because the empty string counts as false. We have to say "if m is not None." Let's quickly summarize how a language interpreter works. For regular expressions we have patterns like a or b plus, which define languages. A language is a set of strings like {a, b, ab, ba, ...} and so on, defined by that pattern. Then we have interpreters like matchset, which in this case takes a pattern and a text and returns a list of strings or a set of strings. So we saw that matchset is an interpreter because it takes a description of the language, namely a pattern as a data structure, and operates over that pattern. Here's the definition of matchset. You see it looks at the pattern, breaks out its components, and then the first thing it does is this big case statement to figure out what type of operator we have and to do the appropriate thing. There's an inherent inefficiency here in that the pattern is defined once, and it's always the same pattern over a long string of text and maybe over many possible texts. We want to apply the same pattern to many texts. Yet every time we get to that pattern, we're doing this same process of trying to figure out what operator we have when, in fact, we should already know that, because the pattern static, is constant. So this is kind of repeated work. We're doing this over and over again for no good reason. There's another kind of interpreter called a "compiler" which does that work all at once. The very first time when the pattern is defined we do the work of figuring out which parts of the pattern are which so we don't have to repeat that every time we apply the pattern to a text. Where an interpreter takes a pattern and a text and operates on those, a compiler has two steps. In the first step, there is a compilation function, which takes just the pattern and returns a compiled object, which we'll call C. Then there's the execution of that compiled object where we take C and we apply that to the text to get the result. Here work can be done repeatedly every time we have a text. Here the work is split up. Some of it is done in the compilation stage to get this compiled object. Then the rest of it is done every time we get a new text. Let's see how that works. Here is the definition of the interpreter. Let's focus just on this line here. This say if the op is a literal, then we return this result. The way I'm going to change this interpreter into a compiler is I'm going to take the individual statements like this that were in the interpreter, and I'm going to throw them into various parts of a compiler, and each of those parts is going to live in the constructor for the individual type of pattern. We have a constructor--literal takes a string as input and let's return a tuple that just represents what we have, and then the interpreter deals with that. Now, we're going to have literal act as a compiler. What it's going to do is return a function that's going to do the work. What is this saying? We have the exact same expression here as we had before, but what we're saying is that as soon as we construct a literal rather than having that return a tuple, what it's returning is a function, which is a function from the text to the result that matchset would have given us. We can define a pattern--let's say pattern is lit('a'). Now what is a pattern? Well, it's a function. It's no longer a tuple. We can apply that pattern to a string and we get back the set of the remainders. It says, yes, we were able to successfully parse off "a" off of a string, and the remainder is a string. We can define another pattern. Let's say pattern 2 equals plus(pat). Pattern 2 is also a function, and we can call pattern 2 of let's say the string of five a's followed by a b. Now we get back this set that says we can break off any number of a's because we're asking for a and the plus of that and the closure of a. These are the possible remainders if we break off all of the a's or all but one or all but three, and so on. Essentially we're doing the same computation that in the previous incarnation with an interpreter we would have done with matchset(pat2, 'aaaab'). Now we don't have to do that. Now we're calling the pattern directly. So we don't have matchset, which has to look at the pattern and figure out, yes, the top-level pattern is a plus and the embedded pattern is a lit. Instead the pattern is now a composition of functions, and each function does directly what it wants to do. It doesn't have to look up what it should do. In interpreter we have a way of writing patterns that describes the language that the patterns below to. In a compiler there are two sets of descriptions to deal with. There's a description for what the patterns look like, and then there's a description for what the compiled code looks like. Now, in our case--the compiler we just built--the compile code consists of Python functions. They're good target representations because they're so flexible. You can combine them in lots of different ways. You can call each other and so on. That's the best unit that we have in Python for building up compiled code. There are other possibilities. Compilers for languages like C generate code that's the actual machine instructions for the computer that you're running on, but that's a pretty complicated process to describe a compiler that can go all the way down to machine instructions. It's much easier to target Python functions. Now there's an intermediate level where we target a virtual machine, which has its own set of instructions, which are portable across different computers. Java uses that, and in fact Python also uses the virtual machine approach, although it's a little bit more complicated to deal with. But it is a possibility, and we won't cover it in this class, but I want you to be aware of the possibility. Here is what the so-called byte code from the Python virtual machine looks like. I've loaded the module dis for disassemble and dis.dis takes a function as input and tells me what all the instructions are in that function. Here's a function that takes the square root of x-squared plus y-squared. This is how Python executes that. I loads the square root function. It loads the x and the 2, and then does a binary power, loads the y and the 2, does a binary power, adds the first two things off the top of the stack, and then calls the function, which is the square root function with that value, and then returns it. This is a possible target language, but much more complicated to deal with this type of code than to deal with composition of functions. Let's get back to our compiler. Again, in matchset I pulled out one more clause. This is a clause for sequence, and this is what we return. If I want to write the compiler for that sequence clause, I would say let's define seq(x, y). It's a compiler so it's going to return a function that operates on x and y, take as input a text and then returns as result. We could take exactly that result. While I'm moving everything to this more functional notation, I decided let's just show you a different way to do this. This way to do it would be fine, but I could have the function return that. But instead, let's have it say what we're really trying to do is form a union of sets. What are the sets? The sets that we're going to apply union to. First we apply x to the text, and that's going to give us a set of remainders. For each of the remainders, we want to apply y to it. What we're saying is we're going to map y to each set of remainders. Then we want to union all those together. Now, union, it turns out, doesn't take a collection. It takes arguments with union a, b, c. So we want to turn this collection into a list of arguments to union. We do that using this apply notation of saying let's just put a star in there. Now, we've got out compiler for sequence. It's the function from text to the set that results from finding all the remainders for x and then finding all the remainders from each of those after we apply y. Unioning all those together in union will eliminate duplicates. Now it's your turn to do one. This was the definition of alt in the interpreter matchset. Now I want you to write the definition of the compiler for alt, take a pattern for (x, y), and return the function that implements that. Here is the answer. The structure is exactly the same. It's the union of these two sets. The difference is that with a compiler the calling convention is pattern gets called with the text as argument. In the interpreter the calling convention is matchset calls with the pattern and the text. Here's the whole program. Now, compilers have a reputation as being difficult and more complicated than interpreters, but notice here that the compilers is actually in many ways simpler than the interpreter. It's fewer lines of code over all. One reason is because we didn't have to duplicate effort here of saying first we need constructors to build up a literal and then within matchset have an interpreter for that literal. Rather we did it just once. We said the constructor for literal returns a function which is going to be the implementation of the compiler for that type of pattern. It's very concise. Most of these are one-liners. Maybe I cheated a little bit and I replaced the word "text" with the word "t" to make it a little bit shorter and fit on one line. There's only one that's complicated. That's the star of x, because it's recursive. The ones I haven't listed here is because they're all the same as before. Before we get into star(x) let me note that. I didn't have to put down search here, because search is exactly the same as before. I didn't have to put down plus, because plus is exactly the same as before. It's defined in terms of star. What is the definition of star? One thing we could return is the remainder could be the text itself. Star of something--you could choose not to take any of it and return the entire text as the remainder. That's one possibility. The other possibility is we could apply the pattern x. From star(x) apply the pattern x to the text and take those sets as remainders. For every remainder that's not the text itself-- because we already took care of that. We don't need to take care of it again. For all the remainders that are different from the whole text then we go through and we apply star(x) to that remainder. We get a new remainder and that's the result. That's all we need for the compiler result. Oh, one piece that was missing is how do interface the match function, which takes a pattern and a text, with this compiler where a pattern is applied to the text. That's one line, which is slightly different. Here before we called matchset. In the previous implementation we had matchset(pattern, text). Your job then is to replace that with the proper code for the implementation that calls the compiler. The answer is that the interface with the compiler is we just call a pattern with text as the input. That's all we need to do. So far what we've done is call the recognizer task. We have a function match which takes a pattern and a text, and that returns back a substring of text if it matches or None. It's called a recognizer, because we're recognizing whether the prefix of text is in the language defined by the pattern. There's a whole other task called the generator in which we generate from a pattern a complete language defined by that pattern. For example, the pattern a or b sequenced with a or b. That defines a language of four different strings--{aa, ab, ba, bb}, and we could define a function that takes a pattern and generates out that language. That all seems fine. One problem, though. If we have a language like a then the answer of that should be the empty string or a or aa or aaa and so on. It's an infinite set. That's a problem. How are we going to represent this infinite set? Now, it's possible. We could have a generator function that generates the items one at a time. That's a pretty good interface, but instead I'm going to have one where we say let's limit the sizes of the strings we want. If we say we want all strings up to n characters in length, then that's always going to be a finite set. I'm going to take the compiler approach. Rather than write a function "generate," I'm going to have the generator be compiled into the patterns. What we're going to write is a pattern, which is a compiled function, and we're going to apply that to a set of integers representing the possible range of lengths that we want to retrieve. That's going to return a set of strings. So for example, if we define pattern to be a<i>--we did that appropriately--</i> and then we asked for pattern, and w gave it the set {1, 2, 3}. Then that should return all strings which are derived from the pattern that have a length 1, 2, or 3. So that should be the set {a, aa, aaa}. Now let's go ahead and implement this. Okay. Here's the code for the compiler. Now, remember the way the compiler works is the constructor for each of the patterns takes some arguments--a string, and x and y pattern, or whatever-- and it's going to return a function that matches the protocol that we've defined for the compiler. The protocol is that each pattern function will take a set of numbers where the set of numbers is a list of possible lengths that we're looking for. Then it will return a set of strings. What have I done for lit(s)? I've said we return the function which takes a set of numbers as input, and if the length of the string is in that set of number-- if the literal string was "hello" and if hello has five letters and if 5 is one of the numbers we're trying to look for-- then return the set consisting of a single element--the string itself. Otherwise, return the null set. Star I can define in terms of other things. Plus I've defined in terms of a function sequence that we'll get to in a minute. It's a little bit complicated. It's really the only complicated one here. We can reduce all the other complications down to calling plus, which calls genseq. Sequence does that too. I've introduced epsilon, which is the standard name in language theory for the empty string. So it's the empty string. It's the same as just the literal of the empty string, which matches just itself if we're looking for strings of length 0. For dot--dot matches any character. I've decided to just return a question mark to indicate that. You could return all 256 characters or whatever you want. Your results would start to get bigger and bigger. You can change that if you want to. I levt space for you to do some work. Give me the definitions for oneof(chars). If we ask for oneof the characters abc, what should that match? What it should match is if 1 is an element of Ns then it should be abc. Otherwise, it shouldn't be anything. Similarly for alt. Give me the code for that. The answer is if we want an alternative of the patterns x and y, then we use a protocol. We say let's apply x to the set of numbers. That gives us a set of strings that matches. We'll just union that with the set that comes back from applying y to the set of numbers. Now, for one of char--this will be a list of possible characters that we're trying to match one of. If 1 is in our list of numbers, then we should return all of those, and we have to return them as a set. We'll say the set of character if 1 is in there. Otherwise, there are no matches at all, so return null. That's the whole compiler. I want to show you just a little bit of the possibility of doing some compiler optimizations. Notice this sort of barrier here where we introduce lambda, where we introduce a function. Remember I said that there's two parts to a compiler. There's the part where we're first defining a language. When we call lit and give it a string, then we're doing some work to build up this function that's going to do the work every time we call it again. Anything that's on the right of the lambda is stuff that gets done every time. Anything that's to the left is stuff that gets done only once. Notice that there is a part here building up this set of s that I'm doing every time, but that's wasteful because s doesn't depend on the input. S is always going to be the same. I can pull this out and do it at compile time rather than do it every time we call the resulting function. I'll make this set<u>of<u>s and I'll give that a name--set<u>of<u>s.</u></u></u></u> Over here I'll do set<u>of<u>s equals that value.</u></u> It looks like I'd better break this up into multiple lines. Now I pulled out that precomputation so it only gets done once rather than gets done every time. You could look around for other places to do that. I could pull out the computation of this set of characters and do that only once as well. That's a lifting operation that stops us from repeating over and over again what we only need to do once. That's one of the advantages of having a compiler in the loop. There is a place to do something once rather than to have to repeat it every time. Now there's only one bit left--this generate sequence. Let's talk about that. Now sequence in this formulation is a function that takes x and y, two patterns, and what it returns is a function, and that function takes a list of numbers and returns a set of text that match. So sequence is delaying the calculation. It's computing a function which can do the calculation later on. Genseq does the calculation immediately. It takes x and y and a set of numbers, and it immediately calculates the set of possible text. Now the question is what do we know about genseq in terms of the patterns x and y and the set of possible numbers. We know at some point we're going to have to call the pattern x with some set of numbers. We're not yet quite sure what. That's going to return a list of possible text. Then we're going to have to call y with some other set of numbers. Then we're going to have to concatenate them together and see if they make sense, if the concatenation of some x and some y, if that length is within this allowable set. Now, what do we know about what these Ns should be in terms of this set of possible numbers here regardless of what this set is. This could be a dense set, so we could have Ns equals 0, 1, 2, all the way up to 10 or something. Or it could be a sparse set. It could be, say, only the number 10. But either way, the restriction on x and y is such that they have to add up to no more than 10. But x could be anything. If the list of possible numbers that we want to add up to is only 10, that doesn't constrain x at all other than to be less than 10. This N should be everything up to the maximum of N sub s. Then what should y be? Well, we have two choices. One, we could for each x that comes back we could generate the y's. Or we could generate the y's all at once and then try to combine them together and see if they match up. I think that's actually easier. So for the y's also, they can be any size up to the maximum. Then we take the two together, add up the x match and the y match and see if that length is within N. In this example, if Ns is equal to 10, here we want to have the Ns be everything from 0 up to 10 inclusive in both cases, and we get back some results like, say, a, abb, acde, and so on, and some other result over here--ab, bcd. Then for each of them we add them up, and if we say abb plus ab and check to see if that's in Ns. If it is, we keep it. If it's not, we don't keep it. Here is candidate solution for genseq. We take x, y, and a set of numbers, and then we define Ns as being everything up to the largest number, including the largest number. We have to add 1 to the maximum number in order to get a range going from 0 up to and including the largest number. Now that we know the possible values of the numbers that we're looking for for the sizes of the two components-the x and the y components-- then we can say m1 is all the possible matches for x, m2 is all the possible matches for y. If the length of m1 plus m2 is in the original set of numbers that we're looking for, then return m1 plus m2. This seems reasonable. It looks like it's doing about what we're looking for to generate all sequences of x and y concatenated together. But I want you to think about it and say, have we really gotten this right? The choices are is this function correct for all inputs? Or is in incorrect for some? Does it return incorrect results? Or is it correct when it returns, but doesn't doesn't always return? Think about that. Think about is there any result that looks like it's incorrect that's being formed. Think about does it infinite loop or not. Think about base cases on recursion and saying is there any case where it looks like it might not return. This is a tricky question, so I want you to try it, but it may be difficult to get this one right. The answer is that it is correct when it returns. All the values it builds up are correct, but unfortunately it doesn't always return. Let's try to figure out why. In think about this, we want to think about recursive patterns. Let's look at the pattern x+. We've definec x+ as being the sequence of x followed by x<i>.</i> And now for most instances of x that's not a problem. If we had plus(lit('a')), it not going to be a problem. That's going to generate a, aa, aaa, and so on. But consider this--let's define a equals lit('a'), pat equals plus(opt('a')). Now, this should be the same. This should also generate a, aa, aaa. The way we can see that is we have a plus so that generates any number of these. If we pick a once, we get this. It we pick a twice we get this. If we pick a three times we get this. But the problem is there's all these other choices in between. Opt(a) means we we can either be picking a or the empty string. As we go through the loop for plus, we could pick empty string, empty string, empty string. We could pick empty string an infinite number of times. Even though our N is finite-- at some point we're going to ask for pattern of some N-- let's say the set {1, 2, 3}--we won't have a problem with having an infinite number of a's, but we will have a problem of choosing from the opt(a) the empty part. If an infinite number of times we choose the empty string rather than choosing a, then we're never going to get past three as the highest value. We're going to keep going forever. That's the problem. We've got to somehow say I don't want to keep choosing the empty string. I want to make progress and choose something each time through. So how can we make sure that happens? What I have to do is I have to check all my cases where I have recursion and eliminate any possibility for infinite recursion. Now, there are two possibilities in the star function and the plus function. Those are the two cases where regular expressions have recursion. But now star I defined in terms of plus, so all that's left is to fix plus to not have an infinite recursion. Here's how I define plus. Basically, I said that x+ is defined as x followed by x*, and the x* is in turn defined in terms of x+. The problem was that I was going through and saying, okay, for x when I'm doing plus(opt(a)), for my x I want to choose opt(a). Okay, I think I'll choose the empty string. So I chose that, and now I'm left in a recursion where I have an x*, which is defined in terms of x+, and I haven't made any progress. I have a recursive call that's defined in terms of itself. We know in order to make sure that a recursion terminates, we have to have some induction where we're reducing something. It makes sense here that what we're going to reduce is our set Ns. One way to guarantee to do that is to say when I'm generating the x followed by the x* let's make sure that the x generates at least 1 character. If we can guarantee that x generates a character, then when we go to do the x* we've reduced our input. So we have this inductive property saying that now our set of Ns will be smaller. It's smaller by 1 each time, and if it started out finite and we reduce by 1 every time, then eventually we're going to terminate. Let's see how we can implement that idea of saying every time we have an x+ we have a x and an x*, we have to choose at least 1 character for x. Note that that's not limiting us in any way. That hasn't stopped us from generating all possible expressions, because if we were going to generate something, it would have to come from somewhere--either from this x or this x-- and we might as well make sure it comes from here rather than adding an infinite number of nothings before we generate something. Here's what gensequence looks like. We have a recursive base case that says, if there are no numbers that we're looking for, we can't generate anything of those lengths, and so return the empty set. Then we say the xmatches we get by applying x to any number up to the maximum of Ns, including the maximum of Ns, but then we got to do some computation to figure out what can be the allowable sizes for y, and we do that by saying, let's take all the possible values that came back from the xmatches and then for each of those values and for each of the original values for the lengths that we're looking for, subtract those off and say, total is going to be one of the things we got from x and one of the things we got from y, that better add up to one of the things in Ns. Then we call y with that set of possible ends for y and then we do the same thing that we were going to do before. We go through those matches, but this is going to be with a reduced set of possibilities and count those up, and now, the thing that makes it all work is this optional argument here, saying the number that we're going to start at for the possible sizes, for x in the default case, that's 0, and so we start the range at 0. But in the case where we're calling from +, we're going to set that to 1. Let's see what that looks like. Here's the constructors, the compilers for sequence and plus. For a regular sequence, there is no constraint on this start for x. X can be any size up to the maximum of the N's. But for plus, we're going to always ask that the x part have a length of at least 1, and then the y part will be whatever is left over. That's how we break the recursion, and we make sure that genseq will always terminate. Now this language generation program is a little bit complex. So I wanted to make sure that I wrote a test suite for it to test the generation. So here I've just defined some helper functions and then wrote a whole bunch of statements here. If we check one of 'ab' and limit that to size 2, that should be equal to this set. It's gone off the page. Let's put it back where it belongs. One element of size 0, 2 elements of size 1, and 4 elements of size 2, just what you would expect. Here are sequences of a star, b star, c star of size exactly 4. Here they are and so on and so on. We've made all these tests. I should probably make more than these, but this will give you some confidence that the program is doing the right thing if it passes at least this minimal test suite. This is a good time to pause and summarize what we've learned so far. We've learned some theory and some practice. In theory, we've learned about patterns, which are grammars which describe languages, where a language is a set of strings. We've learned about interpreters over those languages, and about compilers, which can do the same thing only faster. In terms of practice, we've learned that regular expressions are useful for all sorts of things, and they're a concise language for getting work done. We've learned that interpreters, including compilers, can be valuable tools, and that they can be more expressive and more natural to describe a problem in terms of a native language that makes sense for the problem rather than in terms of Python code that doesn't necessarily make sense. We learned functions are more composable than other things in Python. For example, in Python we have expressions, and we have statements. They can only be composed by the Python programmer whereas functions can be composed dynamically. We can take 2 functions and put them together. We can take f and call g with that and then apply that to some x. We can do that for any value of f and g. We can pass those into a function and manipulate them and have different ones applying to x. We can't do that with expressions and statements. We can do it with the values of expressions, but we can't do it with expressions themselves. Functions provide a composability that we don't get elsewhere. Functions also provide control over time, so we can divide up the work that we want to do into do some now and do some later. A function allows us to do that. Expressions and statements don't do that because they just get done at 1 time when they're executed. Functions allow us to package up computation that we want to do later. Now one thing I noticed as I was writing all those test patterns is that functions like seq and alt are binary, which means if I want a sequence of 4 patterns, I have to have a sequence of (a, followed by the sequence of (b, followed by sequence of (c,d), and then I have to count the number of parens and get them right. It seems like it'd be much easier if I could just write sequence of (a, b, c, d). And we talked before about this idea of refactoring, that is changing your code to come up with a better interface that makes the program easier to use, and this looks like a good example. This would be a really convenient thing to do. Why did I write seq this way? Well, it was really convenient to be able to define sequence of (x,y) and only have to worry about exactly 2 cases. If I had done it like this, and I had to define sequence of an arbitrary number of arguments, then the definition of sequence would have been more complex. So it's understandable that I did this. I want to make a change, so let's draw a picture. Imagine this is my whole program and then somewhere here is the sequence part of my program. Now, of course, this has connections to other parts of the program. Sequence is called by and calls other components, and if we make a change to sequence, then we have to consider the effects of those changes everywhere else in which it's used. When we consider these changes, there are 2 factors we would like to break out. One is, is the change backward compatible? That is, if I make some change to sequence, am I guaranteed that however it was used before, that those uses are still good, and they don't have to be changed? If so, then my change will be local to sequence, and I won't have to be able to go all over the program changing it everywhere else. So that's a good property to have. So for example, in this case, if I change sequence so that it still accepted 2 arguments like it did before, but it also accepts more than 2, than that would be a backwards compatible change as long as I didn't break anything else. And then the second factor is whether the change is internal or external. So am I changing something on the inside of sequence that doesn't effect all the callers, than that's okay. In general, that's going to be backwards compatible. Or am I changing something on the outside--changing the interface to the rest of the world? In this case, going from the binary version to this n_ary version, I can make it backwards compatible if I'm careful. It's definitely going to be both an internal and external change. So I'm going to have to do something to the internal part of sequence. And then I'm also changing the signature of the function, so I'm effecting the outside as well. I can make that effect in a backwards compatible way. Thinking about those 2 factors, what would be the better way to implement this call? Let's say we're dealing with the match-set version where we're returning a tuple, would it be better to return the tuple sequence (a, b, c, d) or the tuple sequence of (a, sequence of (b, sequence of (c, d)? Tell me which of these do you prefer from these criteria. The answer is this approach is much better because now from the external part everybody else sees exactly the same thing. But internally, I can write the calls to the function in a convenient form and they still get returned in a way that the rest of the program can deal with, and I don't have to change the rest of the program. Let's go about implementing that. Let's say I had my old definition of sequence of (x,y), and we say return the tuple consisting of a sequence x and y. Now I want to change that. How would I change that? Well, instead of x and y, I think I'm going to insist that we have at least 1 argument, so I can say x and then the rest of the args, and I can say, if the length of the rest of the args equals 1, then I've got this binary case and then I can take sequence of x. The second arg is now no longer called y. It's called args at 0. Else: now I've got a recursive case with more than 2 args, and I can do something there. So it's not that hard, but I had to do a lot of violence to this definition of sequence, and come to think of it, I may be repeating myself because I had to do this for sequence, and I'm also going to have to do it for alt, and if I expand my program, let's say I start wanting to take on arithmetic as well as regular expressions, then I may have functions for addition and multiplication and others, and I'm going to have to make exactly the same changes to all these binary functions. So that seems to violate the "Don't Repeat Yourself" principle. I'm making the same changes over and over again. It's more work for me. There's a possibility of introducing bugs. Is there a better way? So let's back up and say, what are we doing in general? Well, we're taking a binary function f of (x,y), and we want to transform that somehow into an n_ary function--f prime, which takes x and any number of arguments. The question is, can we come up with a way to do that to automatically-- change one function or modify or generate a new function from the definition of that original function. What's the best way to do that? How can I map from function f to a function f prime? One possibility would be to edit the bytecode of f. Another possibility would be to edit the source string of f and concatenate some strings together. Another possibility would be to use an assigment statement to say f = some function g of f to give us a new version of f. Which of these would be the best solution? I think it's pretty clear that this one is the best because we know how to do this quite easily. We know how to compose functions together, and that's simple, but editing the bytecode or the source code, that's going to be much trickier and not quite as general, so let's go for the solution. What I want to do is define a function, and let's call it n_ary, and it takes (f), which should be a binary function, that is a function that takes exactly 2 arguments, and n_ary should return a new function that can take any number of arguments. We'll call this one f2, so that f2 of (a, b, c) is = f(a, f(b, c)), and that will be true for any number of arguments--2 or more. It doesn't have to just be a, b, c. So let's see if you can write this function n_ary. Here's a description of what it should do. It takes a binary function (f) as input, and it should return this n_ary function, that when given more than 2 arguments returns this composition of arguments. When given 2 arguments, it should return exactly what (f) returns. We should also allow it to take a single argument and return just that argument. That makes sense for a lot of functions (f), say for sequence. The sequence of 1 item is the item. For alt, the alternative of 1 item is the item. I mentioned addition and multiplication makes sense to say the addition of a number by itself is that number or same with multiplication. So that's a nice extension for n_ary. See if you can put your code here. So what we're doing is, we're passed in a function. We're defining this new n_ary function, putting the code in there, and then we're returning that n_ary function as the value of that call. Here's the answer. It's pretty straight forward. If there's only 1 argument, you return it. Otherwise, you call the original f that was passed in with the first argument as the first argument, and the result of the n-ary composition as the other argument. Now how do we use this? Well, we take a function we define, say seq of x, y, and then we can say sequence is redefined as being an n_ary function of sequence. Oops--I guess I got to fix this typo here. From now on, I can call sequence and pass in any number of numbers, and it will return the result that looks like that. So that looks good. In fact, this pattern is so common in Python that there's a special notation for it. The notation is called the decorator notation. It looks like this. All we have to do is say, @ sign, then the name of a function, and then the definition. This is the same as saying sequence = n_ary of sequence. It's just an easier way to write it. But there is one problem with the way we specified this particular decorator, which is if I'm in an interactive session, and I ask for help on sequence, I would like to see the argument list and if there is a doc string, I want to see the documentation here. I didn't happen to put in any documentation for sequence. But when I ask for help, what I get is this. I'm told that sequence is called n_ary function. Well, why is that? Because this is what we returned when we define sequence = n_ary of sequence. We return this thing that has the name n_ary function. So we would like to fix n_ary up so that when the object that it returns has the same function name and the same function documentation-- if there is any documentation--and have that copied over into the n_ary f function. Now it turns out that there is a function to do exacty that, and so I'm going to go get it. I'm going to say from the functools--the functional tools package. I want to import the function called update_wrapper. Update_wrapper takes 2 functions, and it copies over the function name and the documentation and several other stuff from the old function to the new function, and I can change n_ary to do that, so once I've defined the n_ary function, then I can go ahead and update the wrapper of the n_ary function-- the thing I'm going to be returning from the old function. So this will be the old sequence, which has a sequence name, a list of arguments, maybe some documentation string, and this will be the function that we were returning, and we're copying over everything from f into n_ary f. Now when I ask for help--when I define n_ary sequence, and I ask for help on sequence, what I'll see is the correct name for sequence, and if there was any documentation string for sequence, that would appear here as well. So update_wrappers is a helpful tool. It helps us when we're debugging. It doesn't really help us in the execution of the program, but in doing debugging, it's really helpful to know what the correct names of your functions are. Notice that we may be violating the Don't Repeat Yourself principle here. So this n_ary function is a decorator that I'm using in this form to update the definition of sequence. I had to--within my definition of n_ary--I had to write down that I want to update the wrapper. But it seems like I'm going to want to update the wrapper for every decorator, not just for n_ary, and I don't want to repeat myself on every decorator that I'm going to define. So here's an idea. Let's get rid of this line, and instead, let's declare that n_ary is a decorator. We'll write a definition of what it means to be a decorator in terms of updating wrappers. Then we'll be done, and we've done it once and for all. We can apply it to n_ary, and we can apply it to any other decorator that we define. This is starting to get a little bit confusing because here we're trying to define decorator, and decorator is a decorator. Have we gone too far into recursion? Is that going to bottom out? Let's draw some pictures and try to make sense of it. So we've defined n_ary, and we've declared that as being a decorator, and that's the same as saying n_ary = decorator of n_ary. Then we've used n_ary as a decorator. We've defined sequence to be an n_ary function. That's the same as saying sequence = n_ary of sequence. Now we wanted to make sure that there's an update so that the documentation and the name of sequence gets copied over. We want to take it from this function, pass it over to this function because that's the one we're going to keep. While we're at it, we might as well do it for n_ary as well. We want to have the name of n_ary be n_ary and not something arbitrary that came out of decorator. So we've got 2 updates that we want to do for the function that we decorated and for the decorator itself. Now let's see if we can write decorator so that it does those 2 updates. So let's define decorator. It takes an argument (d), which is a function. Then we'll call the function we're going to return _d, and that takes a function as input. So it returns the update wrapper from applying the decorator to the function and copying over onto that decorated function, the contents of the original function's documentation and name, and then we also want to update the wrapper for the decorator itself. So from (d) the decorated function, we want to copy that over into _d and then return _d. Now which update is which? Well, this one here is the update of _d with d, and this one is the update of the decorated function from the function. So here we're saying the new n_ary that we're defining gets the name from the old n_ary, the name in the documentation string, and here we're saying the new sequence, the new n_ary sequence, gets its name from the old sequence. Here's what it all looks like. If you didn't quite follow that the first time, don't worry about it. This is probably the most confusing thing in the entire class because we've got functions pointing to other functions, pointing to other functions. Try to follow the pictures. If you can't follow the pictures, that's okay. Just type it into the interpreter. Put these definitions in. Decorate some functions. Decorate some n_ary functions. Take a look at them and see how it works. Okay, now for a quick quiz. We have this definition of decorator, and we've seen how that works. Here's an alternative that was proposed by Darius Bacon, which is this1 line--return the function that updates wrapper for the decorator applied to the function from the original function, and then 1 more line, which says, decorator = decorator of decorator. Can you get any more recursive than that? The question is, does this work? I want you to give me the best answer. The possible answers are yes, it does; no, it's an error; no, it correctly updates decorator such as n_ary, but not the decorated function such as (seq); or no, my brain hurts. Now if you answered, no, my brain hurts--well, who am I to argue with that? But I think the best answer is yes, it does in fact work. Even though there's only 1 update wrapper call, both of them happen, and the reason is because decorator becomes a decorator. So this version of decorator updates (seq), and then this version that gets created when we make it a decorator updates the decorator. If you took CS 101, you saw the idea of memoization. If you haven't seen it, the idea is that sometimes particularly with the recursive function, you will be making the same function calls over and over again. If the result of a function call is always the same and the computation took a long time, it's better to store the results of each value of N with its result in a cache, a table data structure, and then look it up each time rather than try to recompute it. We can make this function be cached very simply with a couple extra lines of code. We ask if the argument is already in the cache, then we just go ahead and return it. Otherwise, we compute it, store it, and then return it. So this part with the dot, dot, dot, is the body of the function. All the rest is just the boiler plate that you have to do to implement this idea of a cache. We've done this once, and that's fine, but I'm worrying about the principle of Don't Repeat Yourself. There's probably going to be lots of functions in which I want to store intermediate results in a cache, and I don't want to have to repeat this code all of the time. So this is a great idea for a decorator. We can define a decorator called memo, which will go ahead and do this cache management, and we can apply it to any function. The great thing about this pattern of using memoization is that it will speed up any function f that you pass to it because doing a table look-up is going to be faster than a computation as long as the computation is nontrivial, is more than just a look-up. Now the hockey player, Wayne Gretzsky, once said that you miss 100% of the shots you don't take. This is kind of the converse. This is saying you speed up 100% of the computations that you don't make. So here's the memo decorator. The guts of it is the same as what I sketched out previously. If we haven't computed the result already, we compute the result by applying the function f to the arguments. It gives us the result. We cache that result away, then we return it for this time. It's ready for next time. Next time we come through, we try to look up the arguments in the cache to see if they're there. If they are, we return the result. And now I've decided to structure this one as a try-except statement rather than an if-then statement. In Python, you always have 2 choices. You can first ask for permission to say are the args in the cache, and if so, return cache or args, or you can use the try-except pattern to ask for forgiveness afterwards to say, I'm first going to try to say, if the args are in the cache, go ahead and return it. If I get a keyError, then I have to fill in the cache by doing the computation and then returning the result. The reason I use the try structure here rather than the if structure is because I knew I was going to need it anyways for this third case. Either the args are in the cache, or they aren't, but then there's this third case which says that the args are not even hashable. What does that mean? Start out with a dictionary d being empty, and then I'm going to have a variable x, and let's say x is a number. If I now ask, is x in d? That's going to tell me false. It's not in the dictionary yet. But now, let's say I have another variable, which is y, which is the list 1, 2, 3, and now if I ask is y in d? You'd think that would tell me false, but in fact, it doesn't. Instead, it gives me an error, and what it's going to tell me is type error: unhashable type: list. What does that mean? That means we were trying to look up y in the dictionary, and a dictionary is a hash table--implemented as a hash table. In order to do that, we have to compute the hash code for y and then look in that slot in the dictionary. But this error is telling us that there is no hash code for a list. Why do you think that is? Are lists unhashable because lists can be arbitrarily long, or because lists can hold any type of data as the elements, not just integers, or because lists are mutable. Now I recognize this might be a hard problem if you're not up on hash tables. This might not be a question you can answer. But give it a shot and give me your one best response. The answer is because lists are mutable. That makes them unlikely candidates to put into hash tables. Here's why. Let's suppose we did allow lists to be hashable. Now we're trying to compute the hash function for y, and let's say we have a very simple hash function--not a very good one--that just says add up the values of the elements. Let's also say that the hash of an integer is itself, so the hash code for this list would be equal to 6, the sum of the elements. But now the problem is, because these lists are mutable, I could go in, and I could say, y[0] = 10. Y would be the list [10, 2, 3]. Now when we check and say, is y in d? We're going to compute the hash value 10 + 2 + 3 = 15. That's a different hash value than we had before. So if we stored y into the dictionary when it had the value 6, and now we're trying to fetch it when it has the value 15, you can see how Python is going to be confused. Now, there's 2 ways you could handle that. One--the way that Python does take is to disallow putting the list into the hash table in the first place because it potentially could lead to errors if it was modified. The other way is Python could allow you to put it in, but then recognize that it's the programmers fault, and if you go ahead and modify it, then things are not going to work anymore, and Python does not take that approach, although some other languages do. Now to show off how insanely great memo is, we'll want to have before and after pictures, showing the amazing weight loss of a model that was fat before and was thin after applying memo. Oh! Wait a minute. It's not weight loss. It's time loss that we're going to try to measure. We want to show that before, we have a function f, and that's going to run very slowly, making us sad. And after, we have a function memo of f, and that's going to run very quickly, making us happy. Now we could do that with a timer and say it took 20 seconds to do this and .001 seconds after, but instead of doing it with timing, I think it's a little bit more dramatic just to show the number of function calls, and I could go into my function and modify it to count the number of function calls, but you could probably guess a better way to do that. I'm going to define a decorator to count the calls to a function because I'm probably going to want to count the calls to more than 1 function as I'm trying to improve the speed of my programs. So it's nice to have that decorator around. So here's the decorator countcalls, you pass it a function, and this is the function that it returns. It's going to be a function that just increments entry for this function in a dictionary callcounts. Increment that by 1 and then go ahead and apply the function to the arguments and return that result. We have to initialize the number of calls to each funciton to be 0, and that's all there is to it. So here I've defined the Fibonacci function. Through cursive function it calls itself twice for each call, except for the base case. I can count the calls both with and without the memoized version. So I'm going to do before and after pictures--before and after memoizing. So here's before. I have the values of n and a value computed for Fibonacci number of n, the number of calls created by countcalls, and then I have the ratio of the number of calls to the previous number. We see the number of calls goes up by the time we get up to n = 20. We got 10,000 calls. We can scroll down, and by the time we're up to n = 30, we have 2.6 million calls. And here's the after. Now we've applied the memo decorator. Now the number of calls is much more modest. Now at 20, we're only at 39 calls, and at 30, we're at 59 calls rather than 2.6 million. So that's pretty amazing weight loss to go from 2.6 million down to 59, just by writing 1 little decorator and applying it to the function. Now just as an aside here, and for you math fans in the audience, I'm back to the before part. This is without the memoization. This number here in this column is the ratio of the number of calls for n = 30 to the number of calls for n = 29. You can see that it's converging to this number 1.6180. Math fans out there, I want you to tell me if you recognize that number. Do you think it's converging to 1 + square root of 5 / 2, 25.888 / 1600, or the square root of e? The answer is 1 + square root of 5 over 2, otherwise known as the Golden Ratio. The Golden Ratio I knew was actually the ratio of success of elements of the Fibonacci sequence--the sequence 1,1, 2, 3, 5, 8, and so on-- converges to that ratio. But I didn't know that the number of calls in the implementation also converges to that ratio. So that's something new. I want to make the point there are different types of tools that you can use in your tool box. We just saw the count calls. I think I would classify that as a debugging tool, and we saw a memo, and I'll classify that as a performance tool. Earlier, we saw n_ary, another decorator, which I can classify as an expressivenes tool. It gives you more power to say more about your language. This gives you no more power but makes it faster. This isn't going to end up in your final program, but helps you develop the program faster. I want to add another tool here in debugging called trace, which can help you see the execution of your program. So I'm going to define a decorator trace, which when we apply to fib, gives us this kind of output. When I ask here for what's the 6th Fibonacci number? It says for each recursive call, we have an indented call with an arrow going to the right saying we're making a call, and for each return, we have an arrow going to the left. When you ask for fib of 6, you keep on going down the list until we get near the end. When we ask for fib of 2, then that's defined in terms of 1 and 0, and they both return 1, so that means fib of 2 returns 2 and so on. We can see the shape of the trace here as we go. It's coming to the right and then returning back and coming to the right some more and returning back. The pattern takes a long time to reveal itself and would take even longer for larger arguments other than 6. But it gives you some idea for the flow of control of the program. So that's a useful tool have, and here's an implementation. It follows the same pattern as usual. Decorator takes a function as input. We're going to create another function, and this is what it's going to look like. We're going to figure out what it is that we're going to print. We're going to keep a variable, which we keep as an attribute of the trace function itself called the level. We'll increment that as we come in, print out some results here. We initialize the trace level to 0--the indentation level--and then finally, we return the function that we just built up. I've left out some bits here, and I want you to fill them in to make this function work properly to show the trace that I just showed. So the code you had to write was pretty straight forward. Like most decorators, we compute the result here by applying the function to the args, then we return the result down here. Maybe a little bit tricky is what's in this finally clause, which is we're decreasing the trace level. So the indentation level goes up by 1 every time we enter a new function and down by 1 every time we go back. The issue here is, we want to make sure that we do decrement this. If we increment this once, and then calling the function results in an error, and we get thrown out of that error, we want to make sure we put it back where it belongs. We don't want to mess with something and then not restore it. So that's why we put this in a try finally. We're coming to the end of what I want to say about decorators. I wanted to add one more debug tool. That's one I'm going to call disabled. It's very simple. Disabled is another name for the identity function-- that is the function that returns its argument without doing any computation on it whatsoever. Why do I want it and why do I call it "disabled?" Well, the idea is that if I'm using some of these debugging tools like trace or countcalls, I might have scattered throughout my program trace define f and some other traced functions. Then I might decide I think I'm okay now. I think I've got it debugged. I don't want to trace any more. Then what I can do is I can just say "trace = disabled" and reload my program, and now the decorator trace will be applied to the function, but what it will do is return the function itself. Notice we don't have to say that disabled is a decorator, even though we're using it as if it were one, because it doesn't create a new function. It just returns the original function. That way we won't have the trace output cluttering up our output, and the function will be efficient. There won't even be a test to see if we are tracing or not. It'll just use the exact function that passed in. Now we're done with decorators, and I want to go back to languages. The first thing I want to say is that our culture is full of stories of wishful thinking. We have the story of Pinocchio, who wishes to be a real boy, and the of Dorothy, who wishes to return from Oz to her home in Kansas by clicking her shoes together. They find that they have the power within them to fulfill their wishes. Programming is often like that. I'm righting the body of the definition of a function, and I wish I had the function "fib" defined already. If I just assume that I did, then eventually my wish will come true. In this case, it was good while writing the right-hand side to just assume I wish I had the function I want and proceed as if you did, and sometimes it's a good idea to say I wish I had the language I want and proceed as if you did. Here's an example. Suppose you had to deal with algebraic expressions and not just compute them the way we can type this expression into Python and see its value if x is defined but manipulate them. Have the user type them in, modify them, and treat them as objects rather than as something to be evaluated. Now, my question for you is it is possible to write a regular expression which could recognize expressions like this that are valid. Is the answer, yes, it is possible to write that? No, it's not possible because our language we're trying to define has the plus and asterisk symbols and those are special within regular expressions? Or no, we can't parse this language because this language includes parentheses, and we can't do balanced parentheses for the regular expressions. If you're not familiar with language theory, this may be a hard question for you, but go ahead and give it a shot anyways. The answer is that the problem is the balanced parentheses. Regular expressions can handle a set number of nesting parentheses--one or two or three-- but they can't handle an arbitrary number of nestings. It makes sure that all the left parentheses balance with the right parentheses. We're going to need something else. The thing we traditionally look at is called context-free languages, which are more general than the regular languages. We'll see how to handle that. The tricky part is if I have an expression like m*x + b I want to make sure that I parse that as if m and x are together and not x and b are together. Another way to say that is I want to see any expression as if it were the sequence of something plus something else plus something else. These pluses can also be minus signs, but anything with the time sign, I want to have that all be within the dot-dot-dot rather than encompassing a plus sign in it. What I want to do is write a grammar that defines the language of these expressions. Grammar is a description. It's finite in length, and it should be easy to write. A language is the set of all possible strings that that grammar describes. I want to be able to say that in a concise language. Maybe something like saying I'm going to define expressions, and I want to define the expression as something that looks like this. I need a name for the dot-dot-dots. Let's call that a term. An expression can be a term, a minus or a plus. Let's use regular expression notation to describe a plus or minus. Then more terms, but I can just say recursively that that's an expression. That will give me any number of terms with plus and minuses in between them. That's one possibility, but that's recursive, and I need a base case so I can say it can also be the case that an expression can consist of a single term-- a + b is an expression, a + b + c is an expression, and also just a. That's the rule for expression. Then I would write the rule for term. It would be similar. It would take into account the multiply and divide, and I would write the rest of the grammar in this format. Notice here I've just sort of made up--I've used wishful thinking to say I wish I had a notation like this to describe what the grammar is. Here I've continued my wishful thinking, and I've written out the complete grammar. I think I've got it right. Now all I'm missing is something that understands this format. Let's continue the wishful thinking and wish that we had a function that could take this format and turn it into something that we can then use in a parser. Here I have applied the wishful thinking and said I wish I had this function grammar that would give me this grammar G, and then I could use it to parse expressions. Now it's up to me to deliver on that promise or that wishful thinking. The first thing I should ask myself is what do I want this object G to look like? One good idea is that G could be a dictionary. The keys of the dictionary would be these things on the left-hand side, and then the values of each key would be some object corresponding to this representation on the right-hand side. I would have expression--something like this. Now all I've got to do is figure out what goes on the right-hand side. Here I've made a choice, and what I've said is, well, the right-hand side looks like it's always going to be a set of alternatives. The order matters, so I'm not going to make it into a set. I'm going to make it into a sequence of some kind, and let's make that a tuple. The right-hand side is always going to be a tuple of alternatives. It might be a tuple of length 1, but it's always going to be a tuple. Each element of that tuple is going to be a sequence-- here a sequence of three items, here a sequence of one items. We'll represent sequences as lists. Here are the three items, and here is the one item. Every right-hand side is a tuple of lists where the lists are a sequence and each element of the list is a atom. The atoms can either be the name of a category that's defined on the left-hand side, or they can be a regular expression that's going to match actual characters in the input when we go to parse. Now, of course I could have typed in the whole grammar like this to begin with, but that would have been messy and error-prone and harder to read. I did myself a favor imagining the language I wanted and writing in that language, then figuring out how to get it into something the computer can understand. Now all I have to do is write this function grammar that translates from this format into this format. Fortunately, it's really easy to write this function. Here the whole thing is. Here's what I've done. I've initialized the grammar that I'm going to produce to be the empty dictionary. Then I've gone through the whole description--the description is the input-- and split it up by lines. For each line I've split up each line by the arrow into left-hand side an a right-hand side. Then for each right-hand side I've split that up, using the or sign, into a list of alternatives of one or more. Then I've just said let's assign to the left-hand side--expression or term--a tuple, because that's what we're using for alternatives of the map of splitting up each alternative. The alternative here would be a string. It would be the string of everything starting from term and ending with expression. Then I just mapped the split function to it to split it up into individual atoms. That would split it up into a three-element list--term, plus or minus, and expression. That's all I need. This is a description of the grammar format, immediately implements it, and builds up a dictionary for us. I should say I've used here this utility function "split." It's just like string.split, except when it splits things up it strips the white space from each of the pieces. Now, I should say that if we take this grammar here, and if I have this function to define grammars, and if I write a function to parse, I can take this and if I have an expression like m * x + b, I'm going to parse it just great. Unfortunately, with this description just as it is, I would have trouble with m * x + b with spaces in between it, because nowhere here did I say that spaces can occur between tokens. In some grammars you're free to put spaces everywhere, and in other grammars you aren't. If I want this grammar function to be useful, I should be able to tell which is which. I'm going to show a new version of grammar that takes that into account. Here it is. There are two things you should notice about it right away. First is that I add an optional parameter to say you can specify what white space is allowed in between tokens. Here it's saying s* is allowed--any number of spaces--zero or more. You could change that if you have a different type of grammar you're defining. Secondly, have much longer documentation here-- a documentation string describing what the language is. Third, I've added one more statement here, which says if there are any tabs in the input, replace them with spaces. Why did I do that? Notice that I'm splitting here an arrow surrounded by spaces and an or bar surrounded by spaces. If somebody had written something and used a tab there rather than a space, that would be really hard to debug. I don't want to have to force them to debug it. I want to do the debugging for them and make that not be an error at all. Now I'm going to define the parser, and I want it to have this signature. I'm going to define a function pare, which takes a symbol, saying I want to parse something like an expression. It takes text that we're going to parse, and it takes the grammar that defines that symbol and all the other symbols. I want it to return--when we had regular expressions we looked at returning a set of remainders. I'm going to have this return a single remainder. The idea is that we want the author of the grammar to have some control over what's going on and make this grammar be unambiguous so that there is a single result for each parse rather than having to keep a set of results. The idea is that for each symbol we're going to consider the alternatives in left-to-right order. If we're asked to parse an expression, we'll say can we parse this alternative. If we can, if we can parse in succession a term and then a plus or minus then an expression and then we'll commit to that. We'll say that's the result we're going to return. That's the single remainder, and we're not going to even explore the other alternatives. Because we have this left-to-right choice, that's why we decide to write the expressions in this order. We don't write them in the opposite order because if we wrote the rule this way and we were trying to parse the expression a + 3, we'd be asked to parse this, we'd try to parse a term, we'd say, yes, a is a term, and then we'd stop, and we'd say that's the end. We wouldn't even consider parsing off the term plus the expression. This is no good. It's up to the author of the grammar to write rules in the correct order so that the longest thing gets tried first. Our regular expression functions are what is known as recognizers. They told us--yes or no--is a string part of a language. Here what we're doing is different. It's a parser. It tells you--yes and no--is it part of the language, but then it also gives you an internal structure, a tree structure of the parts of the expression. Here it would be a + 3. If we had m * x + b, then that would parse into a structure that had m * x + b. Here I said we were a remainder, but actually I want to return a two element tuple of the tree followed by the remainder. Here's what we're going for. If I asked to parse the expression a * x with the grammar G, I want to get back this tree structure. It looks kind of complicated. All it's really saying is that we have an a in the first element, then the multiply sign, and then an x in the third element, and there's no remainder. We parse the whole string. That's what it says, but there's all these intermediate parts here because that's the way the grammar is defined. I should say here that this is a tree, remainder result. We're going to use the convention that Fail corresponds to a value of None. Let's think then about what we have to do to be able to parse a text. I can think of four cases that we have to deal with. One, we want to be able to parse an expression or a symbol like the expression keyword. To do that we've got to be able to look that up in the grammar G. We've also got to be able to parse a regular expression, plus or minus, and we've seen how to do that before, so we reduce that to a solved problem. We're going to have to be able to parse a tuple of alternatives. Here one alternative or another alternative done in left-to-right order. Finally, we're going to have to be able to parse a list of atoms representing a sequence--1, 2, 3. Now, I'm going to tell you the plan for how we're going to implement this as code within the function parse. So this first case I'm going to handle with a subroutine called "parse_atom." This is an atomic expression. We should be able to handle that. The second part, the regular expression, is a type of atom so it occurs within the parse_atom routine. We're going to define a variable called "tokenizer" to help us do that. Then we're going to use the built-in re.match along with the tokenizer to recognize those regular expressions. Then for the alternatives, a tuple of alternatives is what you get when you look up the symbol, like exp, in the grammar. I could have had a separate function called parse_alternatives but instead I just decided to have that be part of parse_atom, because it was so simple it was just an immediate step to go from the symbol to the list of alternatives. Finally, to parse this sequence of atoms, I have a subroutine or function called "parse_sequence." Here we go. Here's a function "parse." It takes a start_symbol like expression. It takes a text like 3x + b. It takes a grammar defined with our grammar function. The first thing we do is define the tokenizer. The tokenizer has two jobs. First it has to handle white space that occurs before the token, and it does that by looking up in grammar under the key consisting of just a space. In the definition of grammar we arrange to store the white space parameter under that key. This says build up a regular expression that will parse off the appropriate amount of white space--some, all, none, whatever is appropriate for your grammar. Then parse off whatever was defined but the atom that we're looking at next. We'll see when tokenizer is used how we go ahead and do that. Then parse sequence says we're just going to go through a sequence. This is a of atoms. We're going to initialize our result to be the empty list. Then we're going to go through, try to parse an atom one at a time. If we get back nothing for a remainder, then Fail. Otherwise, append to the result the tree that we built up by doing that parse and continue on in the loop. Notice that we're updating the text variable, so we're taking the remainder each time and parsing the next atom from the remainder of the previous atom. Now parse_atom handles two cases. If the atom is something that's in the grammar like bxb expression, we map it into this tuple of alternatives by looking it up in the grammar, getting that list of alternatives. For each alternative, we try to parse. If we have a successful match--that is if the remainder is not None, indicating failure-- if there's some sort of remainder left over, then we want to return the result. We return the remainder we got, and we build up a tree structure consisting of the atoms that we're trying to parse plus the tree of whatever we got back. If we exhaust all the alternatives and we can't come up with anything, then we return Fail, which says no tree and no remainder. Otherwise if the atom is not in the grammar, then it must be a regular expression. We take the tokenizer that we built up before. We insert the atom, which is a regular expression, into that tokenizer and match it against the text. If there's not a match, then we Fail. If there is a match, we pull out the matching part. That's going to be the tree. That's the token that we matched. We go ahead and we take the rest of the text after the match and return that as a remainder. This is the only place where the text actually advances, in this one spot where we're matching tokens against the input text. These two routines are internal routines inside the definition of parse, and here's the body of parse that just says parse this atom-- the start symbol against the text. That's the parser, and I know we went really quick. We didn't have time to go over a lot of the details. If you hadn't seen anything about parsing or languages before, I may have been too fast for you and I apologize. But part of the idea was to teach a little bit about language theory, but more the idea was just to give you a tool and to show you how these tools are built and how you can use them. Don't worry if you didn't get all the details of exactly how the parser works. If you are interested, there's another course and there's some other documentation that you can read to get up to speed on it. But I just want to talk about one more thing. There's something that bothers me here, which is say is say we have an expression-- one single expression that's really long--and we start parsing it this way. We say let's go left to right. We'll do the first alternative first. Parse the term, and it parses this big, big long term and then tries to parse a plus or minus, and it says, oops, I hit the end. There's no more plus or minus. This alternative fails. Now I try the second alternative, and the second alternative says start with a term and we go back and we parse this whole big term all over again. We've doubled the amount of work, and it can be worse that that, because inside of each of these terms there's more little pieces, and we can be doubling each of those pieces work. That seems really inefficient. What we'd like to be able to do is fix up our parser so that once we've done this work we don't have to do it a second time in case this version fails. Don't worry about doing the work of saying what if like 5 out of 6 of these got parsed, just worry about the individual atoms, and saying if I did the work of computing the tree for an individual atom. I don't want to have to repeat that twice. The quiz question is can you go into here and modify this parse function so that it has that property that it doesn't repeat the work twice. Once it's done it once, it's asked to do it a second time, it doesn't repeat the computation. It just does the computation once. That may seem like a daunting task, but there is a solution that's really simple that you have the tools for to be able to solve. Here's the answer to turn this parser from a slow one to a fast one that doesn't repeat its work. All we need are these five characters. All we have to do is say let's apply the memo decorator to parse_atom, and then we're done. The recursive call to parse_atom with term and the remainder as inputs. We've done it once. This'll be the same call here. We just look it up in the cache table, and we've got the result. Notice in order to make that work, I had to make this function, parse_atom, be something that had arguments that were hashable. The atom and the text are both strings and those are both hashable, but the original call to parse that had a grammar as the third argument-- well, the grammar is a dictionary, and dictionaries are mutable, so they're not hashable. I couldn't memoize the the whole parse function, and then have parse be called recursively here. That's why I had to have parse_atom and parse_sequence be internal functions inside the definition of parse, so that the grammar would be a variable that this function knows about, but it's not one of the arguments so that the memo decorator works. Now we've got a grammar, and we've got a parser. Let's see what it's good for. Here's an example of parsing URLs. Here's an official specification from the W3--the World Wide Web Consortium. There's a definition on their page. It's not quite in the right format that we use. But it was very easy to take their format and translate it into our format. I just sort of went down their rules one-by-one. Some of them you copy verbatim. Some of them I had to fix up a little bit. You can see here is the whole specification of the grammar. It's 40 lines or so. It's fairly involved and verbose. But it handles URLs. It was straightforward to go from the specification that they had on their website to one that could be parsed by the simple parser we built. Now, I have to say that as I was doing this, I didn't get it all right the first time. I made a couple of types that made my grammar not work, and I found this function very useful. I wrote this function to verify a grammar. What it does is it finds all the tokens that are on the left-hand side and on the right-hand side, and then it shows them to me. It shows me the nonterminals, the things that are on the left-hand side. It shows me the terminals that are the right-hand side but not on the left-hand side. Those should be the regular expressions. It shows me some suspects. What's a suspect? That's a something that looks like it's the name and should appear on the left-hand side, so it's alphanumeric characters, but doesn't. If they've done that, it's probably because I spelled it wrong in one place and tried to have the same word used twice and spelled it wrong in one place. Then there are the orphans. Those are the things that appear on the left-hand side but don't appear on the right-hand side. They're useless. They're defined, but they aren't called anywhere. As I was writing this grammar, I would call this function and say, oops, there's an error. I fixed it and called the function and say, oops, there's another error. Then I got it right. Congratulations. We should be happy we've made it all the way through. Now let's try to summarize what it is that we've covered in this unit. To a large extent, this unit was about tools-- how to build useful tools, how to recognize what they are and put them together, and how to apply them to components of a domain. In particular, one of the important tools we looked at is language-- being able to define the language that you want to deal with rather than the language that Python happens to give you. We talked about grammars that describe a language, interpreters that interpret them, and compilers that do the same thing only faster. The other main lesson in this unit was functions. Functions, too, are a very powerful tool They're powerful in a way that statements are not. With statements, although in the end we need our statements to write our programs, they have this flaw in that they're not as composable as functions are. If you want to reuse a statement somewhere else, the only you have to do is copy and paste. That's an issue. That can be a problem. because then you've copy multiple copies and you update one but you don't update the other. With functions you compose them rather than copy and paste them, and so that means there's one function that's an object, and that gets reused automatically. When you change it, it gets changed everywhere, because there's one object, not multiple copies with copy and paste. That's the advantages of functions. We talked about decorators as functions. We showed how to use functions as objects, and we showed some patterns for how they fit together and allow us to define tools. I hope you found this all useful, and I think you'll see in the homework assignments that we have for this unit that the difficulty has been stepped up a bit, but you should be able to handle them with the tools that we've covered. I'm going to begin this unit with an old problem known as the "water-pouring problem." Here's what we're given: two glasses of water and we have a faucet in a sink, which can be the source of as much water as we want. Now, these glass are of different sizes. I haven't drawn them that much different, but this one is 4 oz, and this one is 9 oz. For those of you in the rest of the world besides the U.S., an ounce is about 30 mL. Our goal is to measure out a specific amount of water. What we want to have is 6 oz of water measured out. Six ounces won't fit in this glass. The idea is at the end want to have this glass filled with exactly 6 oz of water. There's no gradated markers. It's not like a function.graduated cylinder or measuring cup where we have the measurements on the glass. It wouldn’t be accurate enough to just eyeball it. What we've got to do is we've got to figure out how to do that by measuring out a precise amounts into the cups and pouring them off. For example, if the goal had been 5 oz, then that would have been easy. We'd just fill the 9 oz all the way up to the top, and then pour the 9 oz into the 4 oz until the 4 oz is all the way full, and then what would be remaining here because there's 9 altogether would be 5 in this glass. Five ounces is easy. Six ounces is not as obvious how to get there. The puzzle is to find a sequence of pouring actions, and the pouring can be from one glass to another. It can go in the other direction. It can go from the faucet into each of the glasses. And it can go from the glasses down the drain. Six different actions we can take, and we want to find a sequence of actions that arrives at this goal of 6 oz. Of course, we can generalize the problem and put any number rather than 9 and 4 and 6. As usual, let's make our inventory of concepts that we're going to be dealing with. We have the glass, and the glass has a capacity and a current level. This glass would have capacity 9, current level 5. We're also going to need collection of glasses probably--a pair of glasses. I guess we can say that the pair of glasses and they're current levels represents a complete state of the world. We'll think of that as a state of the world. Everything we need to know about where we are in the problem. Then we have a goal that we're trying to reach. We have the pouring actions--1, 2, 3, 4, 5, 6. That breaks down into emptying, filling, and transferring. The transferring, I think, is a little bit tricky, because there are two ways to do it. When we were transferring from the 9 oz into the 4 oz-- so we transfer from x to y--we can do that until y is full. That's what happened here. The 4 oz was full. Or we could do it until x is empty. If we were starting to pour back 4 oz from here into an empty one, we could do it until it was empty. Anything else in the inventory? Oh, well, we certainly need a notion of a solution. A solution is going to be a sequence of steps-- to pour from here to here, then from here to the drain, then fill up, then pour again, and so on. What this unit is really all about is techniques for finding these solutions, which are sequences of steps. Again, we're always talking about managing complexity in this class. The complexity we're trying to manage here is a complexity There's a complexity that comes from combinatorial problems. We've seen that before. In the cryptarithmetic problems ODD + ODD = EVEN. We had these up to 10! different permutations of digits to assign, and it was complex because we had to consider them all. In the zebra puzzle we had 5!^5 combinations to consider. It was complex because it took a long time to consider them all. We came up with an optimization to consider a few of them by going one at a time. For our pouring problem, we know there are 6 actions, 2 empties, 2 fills, and 2 pours. The glasses are of size 4 and 9. The goal is 6 oz. I guess my question for you is how many combinations do we need? For cryptarithmetic it was 10!. For zebra it was 5!^5. For pouring is it 6^4, 6^(9-4), 6^6, or 6^9, or can't tell--none of the above? The answer is that you can't tell. This is a different type of combinatorial problem than the previous ones. In the previous ones we had a fixed number of variables, and we knew how many combinations we had for each variable. In the zebra problem, there were 25 variables, and that's all there was. We could enumerate all the combinations. For the pouring problem we're trying to not fill static variables but rather put together a sequence of actions to go from one state to the next. We don't know how long that sequence is, and of course, at each point we have 6 different options of different ways to go. From each of those 6 more. We know it's going to be roughly 6 to the something, because we branch 6 at each point, but we don't know what that x is, because we don't know how long the sequence is. So that makes the problem slightly different. If we want to be foraml, we call it a combinatorial optimization problem, but usually we just called it a "search" problem. Now it's called search traditionally, but I think "exploration" is a better name for it. We start out at home, and in this case our home is where we have two glasses. Zero and zero are the values for how full the glasses are. Then we start to explore. One way we could explore is to fill one of the glasses Then we're at this state--say we're at 0 and 4-- but we know that there are other actions in which we could explore in other directions. Now we could take one of the other states and explore from there in other directions. We have lots of choices going forward of this huge space that we're exploring. Now, somewhere out in this space--and we don't know which direction it is-- is this goal state, which has 6 and then actually any amount in the other glass. We're trying to reach that, and we're distinguishing this part of the state space as a goal. So I drew this as one, but really it's a collection of states in that every state that has 6 on one side and anything on the other should be considered part of this collection of goals. We're trying to search forwards towards that. One reason I like to call it an exploration problem is because we can think of going forward, exploring a new land, and part of that exploration is that we've got a frontier. Here's all the states that are the farthest out that we've gone. If we want to make progress towards the goal, then we're probably going to have to step from one of the frontier nodes farther out. We've separated the set of all possible states into the goal state, the frontier states, and the previously explored states. Then you can see that the way to make progress is to say let's take one of the frontier states and expand that, and we have the advantage here of being a computer that an individual explorer doesn't have. An individual explorer has to take one path, and if they decide they've gone in the wrong direction, they have to go all the way back. A computer can store lots of states in memory. Computer exploration is more like a collection of explorers all collectively expanding the frontier. Our next move can be to say we'll take one of these explorers, say the one in this state here, and say now tell me what's next. You've got 6 actions from there. Where do they go to? Maybe some of them explore the world and generate new states that we haven't seen before. Maybe some of them go to a state that we already know is on the frontier. Maybe some of them regress backwards into previously explored territory. But we can keep on going, expanding out our frontier until eventually the frontier keeps on expanding. When it overlaps the goal, then we've got a solution. Now, in exploration problems like this, there are two problems that we have to worry about. One problem is that there is no solution at all, that the goals are not connected to the to start state. So there's no path from here to there. Then what we want to do is do the exploration we need and report back that it's impossible. We want to find out that it's impossible. Then the other problem is if there is some path that eventually makes it to the goal, We want to make sure that we find that in a reasonable amount of time. That means we want to be efficient about the way we explore the space. It also means that we don't want to get stuck in an infinite loop. Now, if there is a finite number of states and they are connected, then we should be able to find the path. But if we aren't clever, we may miss the solution even though it's possible to find it. For example, if we had a strategy that says first I'm going to explore in this direction-- say this is pouring from cup x into cup y-- and then I go in this direction, pouring from cup y back in to cup x, and then I pour the water back again--so I'm continually just taking water and pouring it between two different cups back and forth, those are all legal steps to take, but I'm ending up with an infinitely long path and I'm not making any progress. We'd like to come up with a strategy for exploration, and the strategy corresponds to deciding which path to expand next. Strategy is always there's some path--let's say this one-- and we say that's the one we're going to explore from next. To avoid this type of infinite loop, here's some possibilities. One possibility would be don't reverse an action. If you come from state A to state B, don't allow the action that goes immediately back to state A. Another strategy would be to say always take the shortest path first. Out of all the paths that you've built so far, when we go to choose which one we're going to expand next, always choose one of the shortest ones. That way we might start to build up an infinitely long path, but at least we won't continue it. First we'll do another one before we do that one. Then another strategy would be don't re-explore. That is, if we're on the frontier--let's say we're here on the frontier-- and we have a move that moves us back out of the frontier into the previously explored zone, then we should not allow that path. My question is check all the strategies that would eventually lead us to the goal. Don't worry about the efficiency of getting to the goal, but which one will eventually get us there and won't get stuck in an infinite loop. The answer is shortest first would work. If there is a path, it'll eventually find it. It will waste some time repeating itself, and may not be the most efficient. But we'll get there. Don't re-explore seems more efficient, because it stops off some of these paths. Don't reverse isn't quite good enough, because if we said, okay, we're going to eliminate the steps that go from A to B and then back to A, but that doesn't stop us from going from A to B to C to D and then back to A and having that longer loop and having that be infinite. Now let's get to solving the problem and coding it up. But before I do that, I want to introduce one more piece of jargon, which is if I'm at a particular state, and I decide that that's the endpoint of the path that I want to expand, and I come up with the states you can get to from there by expanding the path and the steps that it takes to get to those states. I call that the successors to this state. The successors are a collection of states that you can reach\ and the steps that it took to get there. Here is my solution. It's a little bit complicated. Let's go through it step-by-step. I'm saying the input to this pour problem function are X and Y, which are the capacity of the glass for that. Then the goal, which is going to be an integer, like 6, to say that's how much I'm trying to get to. That can be in either one of the glasses. Then the start state, which I'm defaulting to 0 and 0, saying both glasses have current level 0, but if you wanted you could generalize the problem and pass in something else as what we're starting with. I'm using lowercase x and lowercase y to indicate the current capacity of the glasses. Here I check and see are we done before we even get going? Did you give me a start state and say the goal is the have a glass with zero in it? Then we're done before doing any actions. Go ahead and return that. What I'm going to return is called a "path." The path is a alteration of states and an arrow, which will give a name to each action, and then the other states that it goes to, and we alternate out with the states action states and so on. Here, if there's nothing to do, it's just a state with no actions. We're going to keep track of the states that we've already explored and that's going to be a set. We're going to keep track of the frontier. Conceptually, that's a set too, but we're going to pull the items off of the frontier one at a time, so I've made it an ordered list rather than a set. I know which element of the frontier I want to explore first. So the explored is a set of states, and a frontier is an ordered list of paths. The only path we have so far is the trivial path that says we're starting at the start, and we haven't gone anywhere else yet. That's what we start our frontier with. While the frontier is left, while there is still frontier states that we haven't explored from yet, we pop off the first one. Pop(0) says take the 0th element of the list, so we're going to pull elements off of the front of the list and push them onto the end of the list. Then say the current state is the last element of the path, so the path goes from one state to the next, and the last element of the path is the current state. Let's take x and y from there. Then I've defined a successor function that gives me all the successor states and the actions we used to get from there. There should be six of those. Then if we say if that new state is not explored then it's something new. If it was explored, there is nothing left to do. We're already explored from there. If it hasn't been explored yet, then add it to the explored set, make up a new path, which consists of the old path plus we follow an action to get to the new state. If the goal number is somewhere in that state, so the goal is 6 and the state is the two levels of the glasses, say 6 and 3, yes, 6 is in 6 and 3. Then we're done. Return that path as the winner, the path that reached the goal. Otherwise, just add this path onto the frontier, and we'll pull something off the frontier later. If we go all the way through and we run out of frontiers to explore from, then we can't reach the goal and we return fail. You could have Fail be None. I decided to make it the empty list, because all the other things we're returning were lists. Either way, None or Fail, both are equivalent to False in Python if statements. So probably either one would do fine. Here's my successor function. It takes the current levels of the glasses and the maximum capacity of the glasses. What it's going to return is a dictionary of state-action pairs. The state is just an x-y pair of what the levels of the glasses are going to be, and the action is how you got there. We're just going to use strings to represent those actions, so it's just something that we can print out that is otherwise unimportant in the operation of the program. First I wanted to check that this is a legal state that the fill level of x is less than its capacity and the same for y. Then I said here are the six possibilities. The pouring is complicated. Let's do the filling first. The filling says you can fill X up to its capacity--capital X. You can fill Y up to its capacity--capital Y. You can empty X. That'll become 0. You can empty Y. It will become 0. Then the fill--there are two cases. If the total amount of water is less than y, then you can take all the water in the first glass, which is x, and add it into y, so you get y plus x. Same thing in the other direction. But if the total amount of water is more than the destination that you're trying to pour it into, then you could only pour as much as will fill up the other glass. We can see that there is conservation of water here. The total amount is x + y minus this difference plus this difference. I got the definition of my program pretty much just by following out the implications of this diagram. We're going to keep track of an explored set, never try to return there, expand the frontier, pop off one element of the frontier, add in the new elements, and check when we get to the goal. Then that was all kind of generic for any exploration problem. Then for the specific water problem, the successor function and the way that was laid out was specific to what we're doing with the glasses. Now that was a lot of code again, so I'm really going to need some tests to makes sure I got this right. Rather than write the types of tests that we had before with the search statements, I'm going to introduce a new type of test. This comes from the standard Python module called "doctest." It stands for documentation test. The idea is that you can write comments-- the sort of comments that go with your class items and with your function items and then automatically have them run its tests. The tests look just like something that you would type into the Python interpreter. The way doctest knows that you've got a test is you have three-arrow prompt, and an expression is input and the following lines are the output that comes back from that expression. It tests to see if what comes back when you run the test is what was expected. Here I've typed in what I've done at an interactive session, what the results should be, and then when I make a change to my program I can run it again and make sure I haven't messed anything up. For example, at the start here I just want to test out what are the successors of the start state with both glasses empty and when one glass has capacity 4 and the other has capacity 9. In general there are six actions but here a lot of them end up being the same, because if you pour zero into zero either way or if you empty out either of them, it all comes out the same. We only end up with three states, and they happen to have these labels-- (0, 9) filling Y, (0, 0)--we called that emptying Y, but of course emptying 0 gives you 0. It could have been the no opt, but that's just the way the successor function works out. Then (4, 0) is filling X. More interestingly, if you have 3 and 5 and you fill-- so this is testing when we aren't exceeding the capacity, and this test is when we do exceed the capacity. We can see they work out to the right numbers. Then we solve a problem and come up with a solution and so on. Doctest is a nice capacity to allow you to write tests this way. You can sprinkle them throughout your program, and then you can run the test. Just say print doctest.testmod, which stands for test module. If you give it no arguments, it tests the current module. When I run this I get the comforting message that there's a test result that is none of the tests failed, and there were 9 that were attempted. Let's go back and look at the solution. I'm asking given glasses of levels 4 and 9 trying to find the goal 6. This is the shortest solution possible--fill Y, pour from Y into X, empty X, do the same, empty X again, fill Y into X again, fill Y, and pour from Y into X, and then we end up with a 6 in Y. We can solve problems more generally. Here I've defined a function num_actions, which says given an X and Y capacity and a goal how long does it take to solve the goal--the total number of steps it's going to take. Then I asked here for all values of X and Y less than 10--for all capacities less than 10-- and for all goals smaller than the capacity, what's the longest? What's the hardest? Which combinations of those takes the most actions? The answer was if you're given glasses of size 7 and 9 and asked to pour out 8, that's the hardest problem within that range. Now let's introduce another problem. We have a cavern here with a rickety bridge connecting it. On this side, which we'll call "here," we have a collection of 4 people who want to get to the other side, which we'll call "there." Part of the problem is this is nighttime, and it's dark. Fortunately, our team has a flashlight or a torch. The setup is such that the bridge is so rickety that only 2 people at a time can cross, so either one or two people can cross. It's so dark that they need the flash light with them. For everybody to get across, two people are going to have to go across. One is going to have to come back with the flashlight. They'll shuttle each back and forth like that. Now, each of the people has different physical abilities and fear levels, so they each take different times to cross the bridge. This person is speedy, takes 1 minute, 2 minutes, 5 minutes, and 10 minutes. The question is what combinations of actions will get everybody across the bridge the fastest. Let's take our usual approach-- start making an inventory of concepts and figure how to represent them. We want to represent a person, a collection of people, and probably it looks like we want to have two collections of people. One, the collection of people on the here side, and one, the collection of people on the there side. We also need to represent the light or the torch. From there it seems like that's about it, and the other concepts we need are the concepts we already had of states and paths. Now, how about the representation choices. For person, well, I hate to reduce people to numbers, but in this case that seems like the perfect thing to do. This person, regardless of all his wonderful individual qualities, we can just represent by the number 5. How about a collection of people? We could represent a collection as a tuple--1, 2, 5, 10-- as a list, as a set. There's also this data type in Python called a frozen set. What I want you to tell me is of these four, which do you think would be okay for representations just in terms of being able to to manipulate them and calculate the successors. Which of these are hashable? Hashable is important, because if we're going to use the same type of technique we used before for our search we had our explored set, which was a set of states, and members of a set have to be hashable. That's a property that we might want to worry about. Now, I should say one more thing in that the description of the problem it was explicitly stated that each of the people has different speeds. That bothered me a little bit, because I could certainly imagine two people having the same speed. But let's just solve what we were asked to solve where every person has a distinct speed. The answer that all four of these representations would be fine. We can generate successors by appending or adding elements to set lists, tuples, or frozen sets. None of those is too hard to do. It's a little bit easier with sets than with the other ones. In terms of hashing, the immutable data types--frozen sets and tuple-- are hashable, and the mutable types--list and set--are not hashable. Now, out of those many choices, I made a choice to say I'm going to represent as a tuple of (here, there, t), where "here" represents everything that's on this side, "there" represents everything that's on that side, and "t" is the total elapsed time since the start. I'm going to represent here and there with frozen sets, because those are hashable. So this collection here would be the frozen set consisting of {1, 2, 5, 10}, and I'm going to just use the string "light" to represent the flashlight. There would be the empty frozen set. Now, consider this state here representing the start state. What are the successors of that state? Well, any one of the people could go across. They've got to bring the light with them. In the successor state, the light will definitely be there, and it will not be here. It can only be in one place. At least one of the people will be over there and possibly two of the people, so all combinations of sending either one person or two people to the other side, those will each be distinct successor states. Let's see--we've got 4 x 3 is 12, but order doesn't matter, so there's 6 of those. Then 4 more, so it looks like there should be 10 successor states. What I want you to do is write for me the successor function. We're calling it bsuccessors, because we already had a and we're on to b. Or b could stand for "bridge." Remember that a result of the successor function is the dictionary of state action pairs. A state is this (here, there, t) tuple. Here and there have to be frozen sets. The frozen sets contained people--1, 2, 5, and 10-- and/or this light, indicated by the string "light." Show me the function that will generate all the successors. Here I've given you a hint of here's a way to break up the state into those three variables. Then put your code here. Oh, one more thing I forgot is what are the actions. Well, let's say that an action will be represented by the character string arrow going to the right if we're moving from here to there and an arrow going to the left if we're moving from there to here. Here's my solution. I've got to say that my solution came out a little bit more complicated than I expected it to. I think maybe I made a bad choice for the representation. I threw in the flashlight along with the set of people, because I figured you want one set to represent everything that's on one side. But I'm think now after this came out the way that it did that maybe I should have had the flashlight be a separate part of the state. In other words, have the state be a 4-tuple, not of things that are here or there but of people that are here or there, then the time, and then a fourth element being the flashlight saying where is the flashlight. That could either be true or false, saying it is it here, or it could be a character string, saying it's there or here, or it could be a integer--0 or 1. I think it might've been easier if I'd chosen one of those representations. But it didn't bother me enough to go back and make a change. If you want to, you could spend time refractoring and change that. I'm going to just push ahead. Here's what I did. I said if the light is here, then let's look at all the people in here. We'll look at all the pairs of people--A and B. To make sure that they're people, I have to say that they're not the light. For all pairs of people A and B, we can generate a successor state, which is the set of people that were here minus the two people and the light, because the light is going to move from here to there. The second part of the successor state is everything that was already over on the other side on there unioned with the things that are coming over, which are people A and B and the light. Then the time is the time plus the maximum time that it took for A and B to get over. Then I know it says in the specification here that the action is represented just by an arrow. If I want to get the problem right I would do that, but then I decided later on that maybe the action should be more than just the arrow. Maybe the action should also tell who went across. I have the option of doing thing. If I want to just solve the problem the way it was specified then I would return just the arrow to represent the action, and I would do the same thing over here. One subtlety of this that worked out well in my favor-- it's a little bit messy dealing with frozen sets. I don't like the idea of that the name is so long, but I didn't have to consider separately the idea of one person going across and two persons going across. Because we were dealing with sets, the set of people a, b when a is equal to b is equal to 1 person. I get the 1 person crossing for free. That's one nice thing about my representation. But notice that everything is in flux here. I'm trying to choose a good representation. I'm changing my mind as I go along. Should the actions be represented by a single arrow or should they be represented by an arrow along with the names of the people that are going? That's all up in flux. I should say that that type of flux is okay as long as it remains contained. If you have uncertainties that are going to cross barriers between lots of different functions, then probably you want to nail them down. If you think that they're contained, then it's okay to have some uncertainty and be able to explore the exact options later. Here's a quick exercise. Why don't we just define two functions-- path_states, which takes a path and returns a list of the states, and path_actions, which takes a path and returns a list of the actions. The path is interleaved--it contains both--and we want to pull just the states or just the actions. Here's the answer. These are pretty easy functions. We're returning every other one. The states are the even-numbered positions, and the actions are the odd-numbers positions. Starting at 0, going to the end, every other one. Starting at 1, going to the end, every other one. Now I'm going to show you the solution to the search problem rather than try to make you do it yourself, because there are still a few tricks here that are different from the previous search problem. I'm going to define problem, which takes a sequence of elements here. If you want, you can pass in a frozen set of {1, 2, 5, 10} or whatever, but if you didn't I'm going to go ahead and do that kind of version for you. I'm going to make it into a frozen set, and I'm going to add in the light in case you forgot to specify that. You can just ask bridge_problem of the list 1, 2, 5, 10. I'll take care of it all for you. Like before, the explored set starts off being the empty set. The frontier starts off being the one initial state, which is the frozen set we just made up for everything that's on the here side, and empty set for everything that's on the there side, and 0 for the elapsed time. The idea is to get everybody away from here onto the other side. If we were given a trival problem where there was already nobody here, then we're done and we return that initial state. Otherwise, just like before, we start popping things off the frontier. Just like before we're looking at our successors, and the only difference is down here. Whereas before we put a path on the end, and we were expanding our our frontier and taking off the shortest path first from our frontier, because in the previous problem, in the water-pouring problem, the best solution was to find as the solution that was shortest, with the smallest number of steps. In this problem, the best solution is defined as the one with the smallest elapsed time where the elapsed time of a path is the second element. That's the t element here of the final element of the path. That would be the total elapsed time of a path. So we sort the frontier by the total elapsed time. Now it is a little bit wasteful here that we're going through this loop, we only added in one new element, and we sorted the whole thing. Python's actually pretty good at that type of sort. There are other ways to make that more efficient, but just conceptually that's what we're doing. We always want to have the frontier sorted, so that we're taking the fastest time first. I typed that program in, and I ran it for the very first time. Bridge_problem([1, 2, 5, 10]). I got an answer back. Remember, the answer is a path, which is an alternation of states and actions. We can pick out just the actions, like this, by asking for the path and then taking a slice of that path, starting at element number 1, going to the end, and giving us every other element. That'll be just the actions. Those are these three actions. That's my proposed solution that my program came up with. My question is is that correct? Yes or no? The answer is no, that's not correct at all. I've been cheating a little along the way in that I've been showing you solutions that I got the second or third time once I'd debugged them and got them right. This time I wanted to show you a little bit of the debugging process. I got something wrong here. I don't always get them right the first time. This is so wrong looks what's happening. I said the first move is at the 5 and the 2 go across together. It seems like a perfectly reasonable move. They're going from here to there. The second move was that the 1, by his or herself, comes back from there to here. But 1 isn't even over there. How could 1 come back? I must have messed up the successor function. Let's take a look. Here's the problem. I was careful about doing the here case. I made up this nice expression, but then I did a copy and paste, and I edited the expression, and I swapped around the here and the there in this part. When I created the new state, I did that correctly. But down here I'm iterating over the people that were here. I'm trying to have candidates move from there to here, and I'm iterating over people that are here. That doesn't make any sense at all. I've got to fix that. Now the question is is it going to run this time. I found a bug. I fixed it. Is the program correct now? Yes, no, or not enough information, you can't tell yet? I think the right answer is that you just can't tell. I'm hopeful that it's going to work, but I know I fixed one bug. I don't know whether there are other bugs lurking in there. Now I run it again. This is the path I get. These are the actions in the path. Let's see if it makes sense. Now 1 and 2, the two fastest people, go over first, 1, the fastest person, comes back by themselves, 1 brings 5 over again, 1 returns, and finally 1 takes 10 over, and we're done. That looks like a pretty good solution. It came up with a total time of 19. The question is is the program correct now? Yes, it is. No, this example is wrong--there might be a faster example than this and it didn't find it? Or, no, this example is okay. It is the fastest, but the other examples are wrong. Or you still can't tell. The answer to that is that this example is actually wrong. It does get everybody across, and it gets them across in 19, but there's another solution that's faster than that. So let's look at our program and see what we did wrong and why we missed the fastest solution. Unfortunately, we got the wrong answer. Yes, we got a path that leads to the goal, but we didn't get the fastest path. Let's see what went wrong. We had our start state, and then we started expanding that and moving out. That defined our frontier. Then we were very careful about sorting the elements on the frontier, and then we pulled off the very best, the one with the least cost. Then expanded out from there. Let's say the cost of getting to the end of this path with 14, this one 15, this one 16. This is the lowest cost path, we expand that first. Let's say one of the steps cost 5, so that gets us to this state with a cost of 19. Let's say that is in fact a goal state. Now we just stopped there. We said we took off the least cost path. We expanded it. We found a goal. We're done. When we were looking for the shortest path in terms of the least number of steps, that was the right approach, but when we're looking for the least cost path, that's not the right approach. Because even though we pulled off the cheapest path here--the one with the lowerst cost-- here's another path that has a higher cost, but if we expand that there might be a step that only costs 2. We get to this state with cost 17 and that's also a goal. So we made a mistake. We stopped here when we got this result that was 19 when we really wanted this result that was 17. I think the problem was we were prematurely acting. We said just because this was the fastest solution here, we went ahead and took one step away from the fastest and accepted that when that might not be the best answer overall. How can we fix this? One possibility would be to exhaust the frontier. That is, we've got a frontier here. Even though we find a solution from the first element of the frontier, we keep going until we visit everybody on the frontier and give everybody a change to find the better solution. Another possibility is to give everybody one more chance. Once we've found the first solution, now we say, okay, everybody on the frontier gets one more step to see if they can find a solution. The third possibility would be to test later. That is, when we generate this solution, we don't check right here to see if it is a solution. Rather, we just go ahead and throw this onto the frontier and only check to see if it's a solution when we pull the next element off of the frontier. Rather than when we generate a new node and we're about to add them, do the checks later once we've pulled them off the frontier. Now tell me which, if any, of these will work to give us this fastest solution. The answer is exhausting the frontier won't work, because the frontier might be infinite. In this particular problem, there's only a finite number of states, but in some problems there might be an infinite number. If we kept on generating new elements onto the frontier we may never get to the end. Doing one step won't do it either. In this case, if once we found the solution from this 14, we then gave all the other guys one step, it would work in this case. But it might be that it took two steps. Maybe from the 15 there'd be one step that costs 1 and another step that cost 2. I might not just be one step, so that's not going to work. The test later part will work. The reason it works is because now we've guaranteed that everybody on the frontier is sorted, and we're pulling off the shortest one first. If we put it back onto the frontier rather than recognizing immediately that it's a goal, then since we're pulling them off in order of increasing cost, then we know that the first one we pull off the frontier that is a goal that must be the cheapest path to the goal. What I want you to do is take-- this is the same version of the bridge problem solver that we saw before, and I want you to modify this so that it tests for the goal later after pulling a state off the frontier, not when we're about to put it on the frontier. Here's the solution. Two changes are here and here. We pull up the test to this point where we check for solution when we pulled the best path off, and we check for our goal only there, and we don't check for the goal when we're putting something on the frontier. It looks like this is a tricky problem. There are lots of cases that we have to take care of. It seems like a good idea to right some more tests. I've done that here. I've written a few tests. I really should write a lot more. What I want you to do is write at least 3 more tests and run them. I don't have a way of knowing for sure whether you've come up with good ones or not, but go ahead and add at least three more tests to this class of test Now, mostly we're looking for correct code. If you wrote some more tests, you may start to have some more confidence in the code that we have. We're also considering efficiency to some degree. It seems like there's a big problem with the efficiency of the program we have so far. Let me show you one of the issues. Now we represented states as a (here, there, t) triplet. The problem with this is there can be two states that have identical here and there's but differ in the t, and they're going to be considered different states. Why is that a problem? Consider this problem. We have two people--one who takes 1 unit to cross the bridge, and one who takes 1000. It seems pretty clear there is an easy solution. The two of them go across together. It takes 1000, but look how we're going to explore this space. We're going to start out in the initial state that took time 0, and then we're going to start adding things to the frontier. Out of all the ways we could cross, the one that adds the least is for the 1 to go across by himself. Now he's on the other side with the 1 on the other side and the 1000 on the original side. That only took 1 step. Now what's the fastest thing we can do after that? We could take 1 more step and go back to the original state. Here we had 1 and we'll call K for the 1000 on the left-hand side. Here K was left behind and 1 went over to the right. Here we took one more time unit, and we had 1, K on this side. If we continue taking the fastest step we can, we'll get to another distinct state where K is on this side and 1 is on the other side. The flashlight is always going with the 1. We keep on going on like that. We'll go out 1000 different steps. Each of these will be a distinct state, because this will be the state with time t equals 0. Here time t equals 1, t equals 2, t equals 3. But really, although it looks like we're getting different states, in another way of looking at it, we're always getting the same state. We're just going back and forth from here to there and back to here and back and back. We're going around in circles. In order to recognize that these are in fact the same states, we're going to have to take t out of our state, and we're going to have to deal with the t someplace else. We want our representation of a state to be just (here, there). We've got to figure out someplace else to put the t. I'm not sure what the right way to do it is, but why don't we do it this way? We have a path, which is state, action, state dot, dot, dot-- keeps on alternating between states and actions. Let's change that so that the path is a state followed by a tuple of the action and the total time it took after applying that action, then the next state, then the next action and the total time after applying that, and so on. That'll be our new representation. States are going to look like that, and paths are going to look like that. Now, I want you to write the new successor function for the bridge problem. We'll call it bsuccessors2--the "2" just to keep it distinct from the first version. Again it returns a dict of state-action pairs. A state now is just a two-tuple of (here, there), and the here and there are still frozen sets. It's pretty much the same except we dropped out the time t. Go ahead and implement that for me. Here it is--pretty straightforward. I just dropped out the time, and I'm just building up these two components. Now, we got rid of the times in the successor function, so we've got to put them back in someplace. I'm going to generalize a little bit, and instead of talking about times, I'm going to talk about costs for a path. I'm just thinking of maybe we might want to do some other problems that also have paths in them and that aren't dealing with optimizing time but are dealing with optimizing some type of cost. What I want you to for me is to define this function path<u>cost,</u> which takes a path as input and returns the total cost of that path. That's already stored away. We don't have to compute anything new. Because we decided that our convention for paths was it was going to be stored there. That is, we said that a path is equal to a state followed by an action and a total cost followed by another state, etc. Here I've just said, well, if we don't have any actions there or if it's the empty path, then do one thing. Otherwise do something else. Then I also want you to find the bridge cost--bcost is the abbreviation I'll use. That's the cost of an individual action. An action in this domain is something like 2, 5, arrow to the right. I want you to figure out what's the cost of that action. Pretty straightforward. If we don't have at least 3 elements in the path, that means we don't have an action there. It's just an individual state. The cost of that should be 0. Otherwise, we look at the second element from the end. There's a final state and then there's a final action. That should be the final action and total cost--this tuple--we just return the total cost. For the bridge cost of an action, it's just the maximum of the two times. Now we've got our new successor function. We know how to deal with costs. Now it's time to put it all together. It's a little bit tricky, so I'm not going to ask you to do this as a quiz. If you want to you can pause the video now and do it on your own. You're certainly welcome to give it a try. I'm going to go ahead and show it to you. Okay, here it is. The tricky part is just keeping track of the costs and putting them in the right location. Just like before we're popping paths off the frontier. We're checking to see if we hit a goal. We're keeping track of states that we've already explored. But now we're doing something new. We're computing the cost of the path that we just popped off, and that's just pulling the cost out, because we've already computed it and stored it in the final action. Then for each of the successors, we figure out the total cost is the cost of the path that we already computed so far plus the bride cost of the individual action. Total cost so far plus cost for one more action, and then we just throw that into the path. The new path is equal to the old path plus the action total cost tuple plus the state that we end up with. Add that to the frontier and we're done. I just define this simple one-line function here. The final_state of a path is the last element of the path. I use that there. Here is adding to the frontier. Now, it could just be throwing it on there the way we did before, but there's a tricky part here. The complication that I want to deal with here that we haven't dealt with before was there may be two different paths that end up in the same state. If that's the case, we want to choose the best one. We don't want to get to the state from a path that's more expensive. We look at see--is there a path that gets to the state that is already on the frontier? If there is, then check to see which one has a better path cost and use that. The moral of the story is this is tricky. There are a lot of cases to deal with in getting this kind of search just right, and we made a couple mistakes along the way. I sort of duplicated the history of the field. There a couple tools we can get to avoid mistakes. One tool is to write lots of tests, and I just didn't do enough testing. I wanted to go fast. I wanted to be able to show you some of the interesting ideas. I put in a few tests, but I really need more to have confidence that I've got this right. The second thing is to use, or better yet, reuse existing tools. Every time I do a search, I don't want to be rewriting this search routine from scratch, because it is tricky and I will make mistakes. Rather I want to write it once or have somebody else write it once and then reuse it. In order to do that, we're going to have to figure out how to generalize. I've written a a function that's good only for solve the bridge problem through search. I want to write a search function that can solve a wide variety of problems. Then I want to reuse that so that I'm not repeating mistakes, and I'm not introducing new errors. Let's do an example to figure out how to do generalization. What do we generalize over? Well, we generalize over problems. So we're going to need another problem. Rather than have a problem dealing with costs, which we saw were complicated , let's just do a problem where we're finding the shortest path. That is, the least number of steps to a solution. I'm going to choose a classic problem called the "missionaries and cannibals" problem. It works like this: there's a river we have to cross, similar to the bridge but this time it's a river. We've got a boat, and on this side of the river, there are 6 people. No flashlight, but a boat and 6 people. Three of these people are missionaries, and three are cannibals. The goal is to get everybody over to the other side. What makes it hard is that there are two rules. One, at most 2 in the boat. One person can go in the boat and cross from one side to the other, but it takes either 1 or 2 people to get the boat from one side and to get it back. The other rule is that we don't want the cannibals eating the missionaries. If we leave more cannibals that missionaries on either side of the river-- either on this side or over on this side-- then the cannibals are going to gang up and eat the missionaries, and we won't be able to accomplish getting everybody across. We have to shuttle them back in forth in such a way that this never occurs. Now, let's try to come up with a good representation for state. One possibility would be to have a set of missionaries, a set of cannibals, and a boat--let's call that a Boolean, yes or no, saying what's on the starting side and leaving out what's on the other side, because we can figure that out. Given that we know we three missionaries, If there's a set of 2 on one side then the other side there must be 1. Another possibility is that we have 3 integers: the number of missionaries, the number of cannibals, and the number of boats that are on the starting side. These are all integers. Then the third possibility is that we have 6 numbers: the number of missionaries, cannibals, and boats on the first side, and the number of each of those on the other side. It may be subjective which of these is best, but I want you to tell me which of these would sufficient for representing the state. The answer is that all of them would work. All of them have everything you need to know to solve this specific problem of three missionaries and three cannibals in the boat. Now the next question is what representation for states should we use if we want to generalize this problem. So that we're given an initial state when there can be any number of missionaries, cannibals, and boats on one side of the river and any number on the other. Which of these representations is sufficient under those conditions? In this case since we don't know that there's only three missionaries, we need to have both sets of numbers. We can't just say there's two missionaries on the left; therefore, there's one on the right. We don't know how many are going to be on the right. So this six-element tuple would do the job where these two wouldn't. Now I want you to define the successor function for this problem. We'll give you a hint that a state is of that form. Return all the successors. The successors should be a dictionary as before. We want to include successor states that result in cannibals being able to eat, but such a state should have no successors itself. In other words, we're free to generate a successor state that has, say, two cannibals and one missionary in one location, but if we're given such a state then we should return the empty dictionary of successors. Here's my solution. The key to my solution is a list of deltas, of differences in the states that correspond to these moves. What do I mean by that? One thing we can do is send two missionaries from a side with the boat to the other side. That would be a difference of 2 in the missionaries. We would add 2 to one side and subtract 2 from the other side and not change at all the number of cannibals and change the number of boats by 1. Or we could send 2 cannibals, or we could send one of each, or we could send only 1 missionary or cannibal. There are 5 possible moves, basically, depending on where the boat is. That's what csuccessors says. First we check for states with no successors. If there are more cannibals than missionaries but there are some missionaries, then they're going to get eaten, and so we return the empty dictionary as a result. Otherwise, we're going to collect up the number of items in our dictionary, and we're going to do that by going through these deltas and subtracting the deltas from the side where the boat is and adding them in to the other side. We have two directions we can go from left to right, start to the other side, or from the other side back to the original side. I made use here of vector addition and subtraction. I take the current state, which is 6 numbers, and I add or subtract these deltas. That's what these definitions say. Now, it would nice if this type of vector arithmetic was built into Python, and there are versions called "numeric Python" where you can do that, but here I had to write these functions myself. Now let's write a function to solve the missionary and cannibals problem. It takes a start state. Here's the normal problem: 3 missionary, 3 cannibals, and 1 boat on the start side. Nothing on the other side, and it takes a goal state. The goal state is not specified. It's just the opposite of that--3, 3, 1 on the other side. Nothing on the original side. The state is this 6-tuple, and we're trying to find a path from the initial state to the goal state. In fact, we're trying to find the path with the least number of steps. I'm not going to ask you to do this as a quiz. If you're enthusiastic, you can stop the video now and go ahead and solve it on your own, but now I'm going to go ahead and show it to you. Here's a solution that looks pretty much like the pouring water problem. We check to see if the goal is None, then we fix up a nice goal. We check to see if we've accidentally already reached the goal at the start. Then we just search for the shortest path. Now let's generalize. Let's take the specific solver--we had a specific one for the pouring problem and one for the missionaries and cannibals. Let's generalize them. I'm going to call the generalization "shortestpathsearch." That's a search for the shortest path that reaches a goal. Let's take our inventory. The concepts we have to deal with--we've got paths, states, actions, successors. We have a start state. We have a goal. Now let's figure out how we're going to represent each of these concepts. Paths we already had. I don't see any reason to change. We have [state, action, state...]. Notice we're just doing shortestpathsearch. We're not doing bestcostsearch. We don't need to put in the total cost in here. We can just have the action by itself. We have states, and here the states can be atomic. We don't have to know anything about the states. In other words, a state can be anything that a particular problem wants to deal with. Shortestpathsearch doesn't have to know about that. Now, why is that the case? Because shortestpathsearch can interface with states through these two functions-- through successors and through the goal function and through the start state. What do I mean by that? The start state is going to be some atomic state. We don't know anything more about that. Shortest_path doesn't know anything about that. When we go to use shortestpathsearch for a particular problem, then we have to specify what a state looks like, but shortestpathsearch itself doesn't have to know. All it has to know is that if you give the start state to the successor function-- so successor will be a function which takes a state as input and returns a dictionary of state-action pairs. Now, given that initial state that we passed in, we can generate new states and new actions. So the actions also are atomic. Shortestpathsearch doesn't have to know anything about the representation other than that this is where they come from--from the successor function. Now, what about the goal? Well, we could specify an exact state that we're looking for, but sometimes we're looking for multiple states. We could specify a set of states, but sometimes the set of states is really big. There's lots of states that satisfy the goal. Instead, let's have the goal be a function. Its's a function. When you pass it a state it returns a boolean. True or False? Is that the goal? With that now we're ready to specify shortestpathsearch. Shortestpathsearch is going to be a function. It's going to take some inputs, and it's going to return a path, and return failure as a path if it can't find a solution. Now the question is out of this inventory, which of these things do we have to pass into shortestpathsearch to allow us to solve a problem? Check all those that apply. The answer is what we have to pass in is the start state-- you've got to know where you're starting from, a successor function-- you have to know where you can get to from the start state, and a goal function--you have to know when you're done applying successors. That's it. We don't need to pass in any other actions or states or paths, because those can all be generated from these three. Let's see if you can write that function. I've left you with the missionary and cannibals problem as sort of a template, but I want you to generalize that to write shortestpathsearch, which takes a start state, a successor function, and a is_goal function and returns the shortest path. It's pretty easy. We just took the template that we had for missionaries and cannibals and just replace these general functions--is_goal and successors-- put them in here rather than putting in the specific functions for the missionaries and cannibals. Now let's complete the generalization. I'm going to define missionaries and cannibals problem, and we'll give it a 2 just so we can tell the two versions apart. It takes the same arguments as before. You may need some initialization code to get going. Then I want the body of the function, the main part, to just be a call to shortest<u>path<u>search with the appropriate arguments inserted.</u></u> If you need to you can define other functions outside of here if that's necessary. Here's my solution. I had to write some code to fix up the goal if it wasn't specified. Then it's just a single call. We call shortest<u>path<u>search with the start state we were given,</u></u> with the csuccessors function that we've already defined, and then with a goal test. The goal test is that everybody is gone from the start side of the river. That we define this way. Once again generalize. This time I want to go back to the bridge problem and generalize that. What we're going to come up with is lower<u>cost<u>search,</u></u> and that'll take some arguments and again return a path, but let's figure out what we need. Yes, we're going to need the start state just like before. We're going to need a successor function, and we're going to need a goal function. In addition, we're going to need one more thing. We're going to need to know the cost of an action. That's going to be necessary. It's going to have to be a parameter to the function. We'll have the start, the successors, the goal, and the action cost and return from that a path. There's a notion of action<u>cost, and as part of our inventory of concepts,</u> there's also the notion of path cost, but that won't have to be passed in as a prohibitor. Let's see if you can define for me lowest<u>cost<u>search,</u></u> which takes these four parameters and should perform the same type of search as we saw previously with the bridge problem. Here is my solution, and I got it by copying the code from the bridge problem and just generalizing it. Just replacing the B successors with successors and action<u>cost and so on.</u> Now let's go ahead and redefine bridge problem in terms of lowest cost search, thereby generalizing it. In the initialization code you might need here a single call to lowest<u>cost<u>search.</u></u> Any other functions you need to define here. Here's my solution. I have to define the start state given a set of people that are on the here side. I have to define the here side and just make sure that we throw in the flashlight there. Then on the other side there's nobody. Lowest<u>cost<u>search--starting from the start state, we've already defined the successor function.</u></u> I'm defining a new function to test for a goal. We already defined the cost function. The new function to test for the goal is right here. It says if not here--in other words, if there's nothing here, if there's nobody here at all, it's the empty set, or if here is only the set of the flashlight. That normally wouldn't happen, but I guess it could happen if the initial problem was there's no people and just a flashlight. Then you've got a solution with doing nothing at all. I just wanted to make sure I covered that trivial case. Congratulations. You made it to the end of the unit. What have we learned? Well, first of all, some problems require search. What I mean by search is you need to put together a sequence of steps, starting from a start and keep going. You don't know how many steps it's going to take, and you're trying to optimize some factor. There are different kinds of search. We just scratched the surface, believe me. It's a gigantic field with all sorts of different algorithms and different types of applicability for these different algorithms. There are many complications we didn't cover, but we covered two-- the shortest_path and the least_cost search. These are two of the most useful. Third, search is really subtle. There are lots of possible problems lurking in there and many that we didn't even cover yet. What that means is where there is subtlety, there is likely to be bugs, and there are even some bugs where there is no subtlety. That means we have to be careful. We have these two tools for combating bugs. One is lots of tests, and the second is standardized tools. That is, we work really hard to make a tool that we know works and has got all the bugs out of it, and then we reuse that tool. Part of that reuse is generalization-- to look at a specific problem and say, "Here we solved this specific problem this way," and to generalize it, to say here's part of that that I think we're going to use over and over again. Let's break that out, and now we'll have two parts to the solution. We want to be thinking about this specific problem, and we want to be thinking about the more general problem. We want to be allocating our work to one or the other appropriately. Congratulations again. You learned a lot of important concepts. You did a great job in writing some very complex programs. Hey, welcome back. Now, as we've said, this class is all about managing complexity. Now many types of software manage complexity by trying to artificially rule out any type of uncertainty. That is, say you have a checkbook-balancing program, and it says you've got to enter the exact amount. You've got to say $39.27. You can't say, oh I don't know about $40. It's easier to write programs that deal that way, but it constrains what you can do. So, in this unit we're going to learn about how the laws of probability can allow you to deal with uncertainty in your programs. Now, the truly amazing thing is that you can allow uncertainty and what you know about the world, or what's true right now and uncertainty in your actions, if the program does something, what happens next? Even though both of those are uncertain you can still use the laws of probability to calculate what it means to do the right thing. That is, we can have clarity of action. We can know exactly what the best thing to do is even though we're uncertain about what's going to happen. So follow with this unit, and we'll learn how to do that. This unit is about probability, which is a tool for dealing with uncertainty. Once you understand probability, you'll be able to tackle a much broader range of problems than you could with programs that don't understand probability. Often when we have problems with uncertainty, we're dealing with search problems. Recall, in a search problem, we are in a current state. There are other states that we can transition into, and we're trying to achieve some goal, but we can't do it all in one step. We have to paste together a sequence of steps. In doing that, we're building up a search frontier that we're continuing to explore from. Now, uncertainty can come into play in two ways. One, we can be uncertain about the current state. Rather than knowing exactly where we are, it may be that we start off in one of four possible states and all we know is that we're somewhere in there, but we're not sure exactly where we are. The other place uncertainty can come in is when we apply an action, say this action here--action A--it may be that we don't get to one specific state but, rather, we're uncertain as to what the action will do, and we might end up in this state or this state or this state instead of the one that we were aiming at. And so we'll see techniques for dealing with both of these types of uncertainty. Now, one place where people are used to dealing with uncertainty is in playing games that employ dice. And that's what we're going to deal with. In particular, we're going to play a dice game which is called Pig. I don't know why the game is called Pig. I can guarantee no porcine creatures were harmed in the creation of this unit. Here's how the game works. There are two players, although you could play with more. The players take turns, and on his turn a player has the option to roll the dice--a single die--as often as he wants or to hold--to stop rolling. And the object of the game is to score a certain number of points. We're going to say 50 points; 100 is more common, but 50 will be easier on the Udacity servers in terms of the amount of computation required. And so it's my turn, and we have a score. So here's a scoreboard; we'll have players with the imaginative names of player 0 and player 1. And the score starts off 0 to 0. Now there's another part of the scoreboard that is not part of the player's score. We'll call that the pending score. Let's say it's my turn. I pick up the die, I roll it, and let's say I get a 5. Then 5 goes into the pending score, but I don't score any points yet. Now it's my turn again. Do I roll or do I hold--stop rolling? Let's say I want to roll again. This time I get a 2, so I add 2 to the pending score; I get 7. Let's say I roll again. I'm lucky. I get a 6. I add 6 to the pending; I get 13. And I'm going great, so I roll again, and this time I get a 1. And a 1 is special. A 1 is called a pig out, and when you roll a pig out it means you lose all the pending points, and for your hand you score not this total, but just the 1. So my score would be just the 1. Now the other player, player number 1, goes. Let's say player number 1 says, "I'm going to roll," gets a 3. "I'm going to roll again," gets a 4. "I'm going to roll again," gets a 5. So now we have 12 in the pending, and now player number 1 says, "I think I've had enough; I'm going to hold," and that means we take these points from the pending, the 12 points, put them up on the board for player 1's score. And now player 1's turn ends, and it's player 0's turn. So your turn continues until you either hold or pig out, and your score for the turn is the sum of your rolls, if you didn't pig out, if you decided to hold, and the score is just 1 if you pigged out. And you keep on taking turns until somebody reaches the target--here, 50. So that's how the game of Pig works. Now let's go to try to describe the game in a form that we can program. So as usual, we're going to make an inventory of concepts in the game. This time I'm going to try to break things out a little bit, and I'm going to talk about low-level concepts, high-level concepts, and mid-level concepts. As we saw in the discussion forums there's always a question of where do you want to start. Do you want to describe the low level first and build up from there? Do you want to describe the high level first and build down? I think for this case we'll take more of a middle out approach. So, at the mid level there's the concept of current state of the game. We're sort of inching towards a search problem, and we know that we have to represent states for a search problem. So, we want to know the current state of the game. If we're thinking of search problems then we also have to know about actions we can take. We know that there are two actions: Roll and hold. So, here's some candidates for what's in the current state. First, the things that were on the scoreboard. The scoreboard, remember, had three things. Then the player whose turn it is, we might want that to be part of the state. The previous role of the dice, whether I just rolled a five or something else, that might be part of the state. The previous turn score, how much did the other player just make on their turn? So, all of these are possibilities. You might be able to think of other possibilities. I want you to tell me which one of these are necessary to describe the state of the game. I guess I should say here that we're assuming that the goal of the game, the number of points you need win, we're assuming that's constant and doesn't need to be represented in each individual state. We just represent it once for the whole game. Which of these are necessary for the current state? Well, we certainly have to know the score. We have to know how much is pending, because that's going to affect the score. We have to know what player is playing. Now these things, what happened before, they might be interesting, but they don't really help us to find the current state. So those are unnecessary. So, the state's going to end up being something like a four tuple. I've written it as p, me, you, pending, the player to move, that player's score, the other player's score, and the pending score that hasn't been reaped yet. At the low level--I count as low-level things like the roll of a die, the implementation of scores, the implementation of the players and of the player to move, the goal--so these are all things that we're going to have to represent. And then at the high level, I'm going to have a function play-pig, that plays a game between two players, and I have the notion of a strategy--a strategy that a player is taking in order to play the game. Now let's think about how to implement these things, and when I'm doing the implementation, I'm going to move top-down. So I started sort of middle-out saying these are the kinds of things I think I'm going to need; now I have a good enough feel for them that I feel confident in moving top-down. I don't see any difficulties in implementing any of these pieces. If I start at the top, then I'll be able to make choices later on without feeling constrained. If I thought there was something down here that was difficult to deal with, I might spend more time now, at the low level, trying to resolve what the right representation is for one of these difficult pieces, and that would inform my high-level decisions. But since I don't see any difficulty, I'm going to jump to the high level. Now, what's play-pig? Well, I think that's going to be a function, and let's just say that its input is two players, A and B, and we haven't decided yet how we're going to represent those. And its output is--let's say it's going to be the winner of the game. Maybe A is the winner. And we'll have to make a choice of how we represent these players. Now what's a strategy? Well, a strategy--people sometimes use the word "policy" for that. We can also represent that as a function. And it takes as input a state, and it returns an action or a move in the game. In this game we said that the actions are roll and hold. We're starting to move down. Let's just say now how are we going to represent these actions? Well, we can call the actions just by strings, so we use the strings "roll" and "hold" and that could be what the strategy returns. But then we'll also need something that implements these actions, so we'll have to have something that's a function that says--let's say-- the function "roll" takes a state and returns a new state; function "hold" takes a state and returns a new state. But that doesn't seem quite right; there's a problem here. What about the die? That seems to take and effect that roll by itself is not a function from state to state. Rather, roll--if we wanted to specify it--would be a function from a state to a set of states, and that represents the fundamental uncertainty. That's why we need probability to deal with it. That's why we have an uncertain or a nondeterministic domain is because an action doesn't have a single result; rather, it can have a set of possible results. And, in some cases it makes sense to go ahead and implement these actions as functions that look like that, that return sets of states. And I considered that as a possibility, but I ended up with an implementation where I talk about the different possibilities for the dice. So the dice can come up as D, one of the numbers 1 to 6, and now roll, from a particular state with the particular die roll, that is going to return a single state rather than a set of states. And I just think it's easier to deal this way, although in other applications you might want to deal that way. Now the rest seems to be pretty easy. The die can be represented as an integer. Scores can be represented as integers. Likewise the goal. The player to move--we can represent that as an index, 0 or 1, into an array of players. And the players themselves? Well, the simplest way to do it is just to represent the player by their strategy. The strategy is a function, and that could represent the player. We could have something more complex, but it seems like we don't need anything more than that. So players will be strategy functions. Now you're probably itching to write some code by now--so let's get started. What I want you to do first is write these two action functions, hold and role, which take a state and return a state. Here the state that results from holding. Here the state that results from rolling and getting a d. A state is represented by this four tuple of p, the player. It's either zero or one. The subsequent state would remain the same if the player continues and would swap between one and the other otherwise. Me and you, two integers indicating the score, the score of the player to play and the score of the other player, and then pending, which is score accumulated so far but not yet put onto the scoreboard. Go ahead and write those functions. Here's my solution: So, I have my state--I just broke it up into pieces so that I know what I'm talking about. Then if I hold it becomes the other player's turn. The other player's score is the same as it was before. So now remember the second place is the score of the player whose turn it is. So, that was you previously, and then the score that I got--I just add in the pending. I reap all of those, and the pending gets reset to zero. When I roll, again let's figure out what's in the state, if the roll is one that's a pig out, it becomes the other player's turn, and I only got one lousy point. Pending gets reset to zero. If the role is not a one then it's still my turn. I don't change my score so far, but I add d onto the pending. Here's just a way to map from one player to the other. If the other player, if it was one it becomes zero. If it was zero it becomes one. It's always a great idea to write some test cases. Now, one comment on style. Right here I'm taking this state, which is a tuple that has four components, and I'm breaking it up like this into it's four components. When you have four components that's probably okay, but it's getting to worry me a little bit that maybe I won't be able to remember which part of the state is which. If I had more than four, if I had five or six components, I really start to worry about that. So there are other possibilities where we can be more explicit about what the state is rather than just have it be a set of undifferentiated elements of a tuple that we then define like this. We can define it ahead of time. Now here's an alternative. Instead of just defining a state by just creating a tuple and then getting at the fields of a state by doing an assignment, we can use something called a namedtuple that gives a name to the tuple itself as well as to the individual elements. We can define a new data type called state and use capitalized letters for data types. Say state is equal to a namedtuple, and the name of the data type is state, and the fields of the data type are p, me, you, and pending. So I can just go ahead and make that assertion. Namedtuples is in a module. So, from collections import namedtuple gives me access to it. Now I can say s = state (1,2,3,4), and I can ask for the components of s by name. How would I choose between this representation for states and the normal tuple representation? Well the namedtuple had a couple of advantages. It's explicit about the types. It helps you catch errors. So if you ask for the p field of something that's not a state that would give you an error. Whereas if you just broke up something that was four elements into these components that would work even if it didn't happen to be a proper state. There are a few negatives as well. It's a little bit more verbose, although not so much, and it may be unfamiliar to some programmers. It may take them a while to understand what namedtuples mean. I should say we could also do the same type of thing by defining a class. That has all the same positives, and it's certainly familiar to most Python programmers, but it would be even more verbose. Here's what hold and roll look like in this new notation. So, hold--where we're explicitly creating a new state. We look at the state.p, the state.you, the state.me, and the state.pending and so on, similarly for roll. They look fairly similar. You notice the lines are a little bit longer in terms of we're being more explicit. So, it takes a little bit more to say that. I'm sort of up in the air whether this representation is better than the previous representation with tuples. I could go either way. Now I'm going to talk about strategies for a minute. Remember a strategy is a function, which takes a state as input, and it's output is one of the action names, roll or hold. I want you to write a strategy function, which we're calling clueless. So its a function that takes a state as input, and it's going to return one of the possible moves, roll or hold. It does that by ignoring the state and just choosing one of the possible moves at random. So go ahead and write that. Here's my solution: I gave you the hint of importing the random module. I just call it the random choice function, which takes a set of possible moves and picks one at random. Now I want to describe a family of strategies that I'm calling hold at n, where n is an integer. For example, hold at 20 is a strategy that keeps on rolling until the pending score is greater than or equal to 20, and then it holds. The point of this strategy is you get points by rolling, but you risk points by rolling as well. The higher the pending score is, the more you're risking. So there should be some point at which you're saying that's too much of a risk. I've accumulated so much pending that I don't want to risk any more, and then I'm going to hold. So hold at 10, hold at 20, hold at 30 describes that family of strategies. I should say there's one subtlety here that we'll build in to hold at, which is let's say that the goal is 50, and my score when I start my round is say 40. Then let's say I roll a 6 and a 4. According to hold at 20 I should keep on rolling because my pending score is only 10. I haven't gotten up to 20 yet, but it would be silly for me to keep rolling at that point. I would risk pigging out and only scoring one point and getting to 41. Whereas I know if I hold now I have 40 + 6 + 4 is 50. I've already won the game. So, hold at 20 will hold when pending is greater than or equal to 20, or when you win by holding. So, I want you to go ahead and implement that. Since hold at x is a whole family of strategy of functions, hold at x is not going to be a strategy function. Rather, it's going to return a strategy function. So I've given you this outline of saying we're going to define a strategy function, then we're going to fix up it's name a little bit to describe it better. Then we're going to return it. You have to write the code within the strategy function. I should say, we're going to stick with the representations of states, where state is a four tuple of the player to move, zero one, me and you score, and the pending score. Here's my solution: I break up this data to its components. Then I hold if the pending score is greater than or equal to the x, or if I've already won if my current score plus the pending score is already greater than or equal to the goal. Otherwise, I return roll as my move. Now let's talk about the design of the function, Play Pig, which plays a single game of Pig. We decided that this is a two player game, player "A" and "B," and we decided that we're going to represent this as a function. At some point in the future we might want to allow multiplayer games with more than two players, but we're not going to want to worry about that for now. So let's make a list of what the function has to do. It has to keep score--it needs the score for player "A" and for player "B" and for pending. It has to take turns. It has to figure out whose turn it is, and that that turn keeps going until they hold or pig out. Another way to say that is, the score for "A," the score for "B," the pending, and whose turn it is-- all of that is managing the current state. It has to call the strategy functions, so "A" and "B" are going to be strategy functions that we pass in. It has to keep track of the current state, pass that state to the strategy function for the appropriate player whose turn it is, and then that will give back an action, either roll or hold. Then it has to do the action, the roll or hold, and that will generate a new state and we have to keep track of the state we're in. But there's one more trick here--when we were doing a normal search, that was it. We had to figure out what the actions were. Apply the action. When you get to the next state, there's a single successor for each action. But here there's multiple successors for an action. And so we have to do one more thing, which is roll the die, and that disambiguates the action of rolling and makes it not generate a set of possible states, but the action plus the die--that generates a single state. I want you to write the function "Play Pig," which takes two strategies as input, plays the game, keeping track of what's going on-- rolling the dice as necessary, updating the state, and then when one player wins, we turn that player either "A" or "B." One thing I note is--I don't have any tests here. The reason is it's hard to test this. It's hard to write a deterministic test because part of playing the game is rolling the die, and that won't be the same every time. We'll talk in a bit about how to test programs like this. Here's my solution. I put the strategies into a list because we're going to be indexing into that. I start out in the start state. Nothing has happened. No points awarded. Player number 0, that is "Player A," is the player to move. Then I repeat this loop. Tell me everything I know about the current state. If the score of the player whose turn it is, is greater than the goal, then that player wins. "Player 0" or "Player 1"--"A" or "B." Same if the other player is greater than the goal, then that player wins and, otherwise, I pick out the strategy function for the player to play. If "P" is "0," then strategy "0" is "A." If "P" is "1," then strategy "1" is "B." Apply that strategy function to the state and if it's whole, I apply the hold action to the state to get a new state. Otherwise, I assume that the strategy function is legal, and if it doesn't return whole, then it does return roll. I'll give it the benefit of the doubt there, and perform the roll action on the state and on a random integer from 1 to 6, inclusive. That will give me the new state, and I continue until we find a winner. Now, the question is, how can I test a function like this, that includes this nondeterministic component? One thing we want to be able to do is inject into here some deterministic numbers to say this is the sequence of "die rolls" I want to give you and then, from that, then I can check if it's doing the right thing. This is an example of a concept called Dependency Injection, which has a rather scary and intimidating-sounding name, but it's actually a pretty simple idea. The idea is we've got a function like this, it's a big complicated function and way down somewhere inside, there's something that we want to affect, something we want to monitor or track or change. Dependency Injection says this function depends on this random number generator, so let's be able to inject that. How do we inject something into a function? Well, we just add it as an argument. So let's add in the argument here, and let's call it "die rolls" and say, that's going to be a sequence or an iterable that will generate possible "die rolls. In the normal case, that will just be random numbers exactly like it was before. We don't care what they are, but when we want to test the function we can inject the "die rolls" that we want. We can just pass in a list saying what happens if the "die rolls" are a 6 and a 1 and then a 3 and a 5, and so on. Tell me what happens. So here's my implementation of the Dependency Injected Play Pig. I still have the regular arguments "A" and "B." There's an optional argument. If I leave that out it should behave exactly like it did before. But if I specify it, then I have control over it. So "die rolls" should be an iterable that generates rolls. Here we go down and we ask for the next one out of those rolls and get it back. By default, "die rolls" just says we're going to generate an infinite sequence of random integers from 1 to 6. Oops, I think I misspoke there. I think I said that "die rolls" have to be an iterable. Actually, what it has to be is an iterator such as a generator expression or something else, in order for it to have the next apply to it. So now, with this play pig, with the dependancy injection, with the goal being 50, here's a test that I can actually run. So "A" and "B" are going to be my two contestants. "A" is hold at 50, which is equivalent to saying never hold until you win. "B" is the clueless function, the one that acts at random, and rolls is going to be an iterator of some list of numbers, maybe 1, 2, 3 or whatever you want, but I want you to write in there the list which is the shortest possible list, or one of the shortest possible lists that allows "A" to win and then you can check Play a Game of Pig between "A" and "B" with these rolls and make sure that "A" wins. Here's my answer. I've rolled eight 6s. That gives me 48 points, and then a 2--that gives me 50--and that allows "A" to win. There are other sequences that are of the same length, but none that are shorter. So we've seen several different strategies and we've compared them and tried to find one that was better, and we could keep doing that, trying to improve and make a strategy better and better, but what if we could make a leap? Instead of incrementally coming up with a slightly better strategy, would it be possible to leap to the best strategy? To make it sound more mathematical, we can call it the optimal strategy. Can we do that and what would it even mean? On the surface it's not exactly clear. When we did search, we didn't know what our first action was. We started out in some state and we knew there were several different states we could go to, and from there, there were other states we could go to. All we knew is that we were trying to arrive at some goal location. But we knew if we just specified how the domain works, how you get from one state to the next, and if we specified an algorithm that found the best path, the shortest path, or the least cost path, that eventually, by applying that algorithm to that description of the world, we would arrive at the best possible solution. So maybe we can do the same thing here. Even though we're dealing with uncertainty, maybe we can still define what the world looks like and discover the optimal solution. So when we were doing search, it was always sort of one agent doing the searching, so let's call that "me," and what am I looking for? Am I looking for the best path or the worst path? Well, obviously, we're looking for the best path and we can describe that and once we've got that description we've got to search it outward. Now we've gone beyond search in two ways. The most obvious is we're dealing with probability, so we've got dice or whatever other random element there is, and then in addition to that, for the big game, we introduced another complication, which is our opponent. And now this question of what each of these three are trying to do, and I want you to tell me, is our opponent trying to get the best, and that means best score for "me," or is the opponent trying to get the worst score for "me," assuming we're diametrically opposed. So the worst score for "me" would be the best score for the opponent, or is the opponent trying to come up with the outcome that is average? And tell me the same for the dice. Is the dice with "me" in trying to get the best result for "me?" Is the dice plotting against "me" in trying to get the worst result for "me?" Or is the dice going to average out? Go ahead and click the appropriate boxes there. And the answer is, in the game of pig the opponent is trying to defeat "me," so they want the worst for "me." The dice has no intentionality. Everything is equal in terms of outcome for the dice, so that works out to average. So now we have a way of describing the world. When we start out, it's "me" and I have options I can take-- roll or hold--and I go in one direction and I get to a point where it's the dice's turn to roll, and that can have six outcomes. Rather than trying to choose the best, we'll just average over all of them. Let's say there's one here, and now it's my opponents turn to move and my opponent makes a choice, and let's say ends up here. And I look at all these paths through that keep on going until they get to the end of the game. And then if I say, if I always choose the best, and if my opponent always chooses the worst for "me," and if the dice average out, then I can describe all the paths to the end, and I can describe the value of those paths. Now in economics and in game theory, the value of a state is called its utility. It's just a number. So we're at the end of the game, and if there's 1 state where we win, we'll give that a utility of 1. If there's another state where we lose, we'll give that a utility of 0. Now if I have a choice here--it's my turn to move--I have a choice to go either way. I'm going to maximize my choice, and I'm going to move there. That means the utility of this state is going to be 1 because I know I can get 1 by taking the optimal strategy. We keep backing up the tree that way. That's if it was my choice here. If it was my opponent's choice, and they could go in either way, then my opponent is going to minimize my score or maximize their score and go in this direction, forcing me to lose and allowing them to win. So we'll say the utility of this state is 0 for me. And I want to also introduce here another idea called the quality, which is the function on a state and an action and gives us a number--a utility number. So that's saying, what's the quality of this action in this particular state? So if these were the actions, hold and roll, then we'd say for my opponent the quality of rolling from this state would give us this utility, and the quality of holding would give us this utility. Finally, if it was the dice's turn--and let's say there are 6 outcomes, but 3 of them lead to this state and 3 of them lead to this state-- then from the dice we're going to average over all the possibilities, so it's half of one and half of 0, so the utility of this state is 1/2. So now we have a way--if we know the value of the end states, which is defined by the game, defined by when we win and lose and how many points each player gets for that-- now we have a way of essentially searching backwards to say, from the end state, I can go backwards and say, what's the value of one of my moves? Oh! I know that. It's the maximum. What's the value of my opponents? I know that. It's the minimum. What's the value of a random dice roll? I know that. It's the average. Now we could go all the way back, backing up the tree to say, what's the value of this start state? I can collect those values, and I can have a utility for this start state, and we'll see--in the game of pig--the start state for the first player has a little bit better than 50% chance just because they go first. For the game we defined, I think it works out to about 54%-- .54 utility for the player who goes first. We can also work out the quality for each of these moves. We can work out, what's the quality of rolling from this state, and what's the quality of holding from this state, and then the optimal strategy is just the one that says choose the move which has the highest quality. If roll has the highest quality from this state, then that's the move that we should do. So just as we did in search, we're finding our way from the start to the goal. We can do that with a random problems, but we have to find a way not to just 1 individual outcome, but to all the outcomes that were covered by all the possibility of the dice. So the complications going to be more complex, but the idea is the same. Now when you have a decision under uncertainty and there's an opponent, it's called game theory. If there's no opponent, it's usually called decision under uncertainty. There is other names. So let's look at an example of that first before we get back to the game of pig. Here's the decision I'm going to give you. You're on a game show, and you won, and you get a prize of 1 million dollars or euros or whatever currency you want to use. Now you're given a decision. You can keep the $1 million, or the host will flip a coin and you believe it to be a fair coin, and if you call it correctly you get $3 million, but if you get it wrong, you get nothing. So you analyze the outcome of this and you believe that this is a choice by the coin that has a 50% probability of each outcome, and you want to say, what should I do? Should I keep the million or should I go for the 3 million? What I'm going to do is code up a model for this, and then let the decision theory decide. First, I just define a variable million because it's hard to see the number of 0's and count correctly. Now traditionally, utility is used with the abbreviation U and quality with abbreviation Q. So I'm going to define here a quality function that says, given a state and an action, what's my--and given utility, what state is worth to me that's going to tell me the value of that state action pair? And the actions available to me are holding and gambling. Let's go ahead and make that explicit. So in any state, the actions available are holding and gambling, where we're only going to deal with 1 state, but we make this perfectly general. And the state that I start with is, however many dollars I have in my pocket-- could be anything. And given that state, if I hold, my state is going to be increased by $1 million, and then there's some utility on that--how much do I value having what I have now plus 1 million. And if I gamble, there's a 50% chance that I get 3 million more than I have now. There's some utility for that. And a 50% chance that I get nothing more than I have now, and some utility for that. So that describes the quality of the state, but only describes it if I have a utility function. I have to know how much do I like money? Well, the simplest choice for utility function is the identity function. Say the identity function just takes any input x and returns x. It's the input itself, and so we could say, if I start with nothing, the value of the state of having nothing is 0, and the value of the state of having a million is a million. Now here's--the amazing thing is, I can just write out what the optimal strategy is, what the best action is for this state, and what it's going to be is the maximum over all the possible actions from the state, that was just hold and gamble, maximized by EU, which stands for Expected Utility. Expected meaning average. So what's the average utility of each of the actions, and I've defined the average utility as the quality of that state, given that state action pair under the utility function? And that means that the Q had to deal with the averaging, and it did that. It said, 50% this, 50% that. That's the value of gambling. Now this best_action function solves this particular problem. But the amazing thing is is that we can completely generalize this, so if we just add in parameters, now we're saying what's the best_action in a particular state if you tell me what the available actions are, what the quality of each state action pair is, and what the utility is over states, then I can tell you what the best_action is. That works for any possible domain that you can define. It's an amazing thing that we solved all the problems at once. Similarly to the way in search where we had 1 best_search algorithm that could solve all of the search problems. Now it doesn't mean that we're done, and we never have to program anything again because programming can be difficult. There's some problems that don't fit into this type of formulation, and there are many, many problems which you can describe, but which you can't solve in a feasible amount of time. So we haven't solved everything, but it is amazing how much we can do with just this 1 short function. Let's go ahead and solve it. Let's solve this problem, and let's say I start off with $100, what's my best_action? Then when I run that, it tells me the best_action is gamble. Now that doesn't sound quite right to me. If you are faced with that problem, assuming you had $100 to your name. Would you take the gamble--try to go for the 3 million, or would you hold with 1 million? And there's no right or wrong answer to this despite what the interface has to do. It has to tell you one answer is right or wrong, but you can ignore that. I just want to collect some data on how many people think that they would gamble in that situation and how many people think they would hold. So I predict that most people say they would hold, and why is that? Well, under the identity function, sort of the arithmetic function, $3 million is 3 times better than $1 million, and so half of $3 million is 1.5 times better than $1 million. So the gamble is more. But that's only true if $3 million really is 3 times better than $1 million. For most people, that's not true. That going from $100 to a $1 million is a big, big jump. Going from $1 million to $3 million is a smaller jump than that, even though arithmetically it's more, in terms of what you can do, it seems like less, and that doesn't mean that people are irrational in any way. Instead what it means is that for people, the value of money is not a linear function. Rather it's something more like a logarithmic function, meaning if you have a certain amount of money, if you double that money, you don't get twice as much value out of having that money, rather you just get 1 increment more of having that money. So let's try again. I'm going to input the math module, and now I'm going to ask, what's the best<u>action starting from $100 in my pocket,</u> but valuing money with logarithmic function rather than with the identity or linear function. Now my best<u>action tells me that what I should be doing is holding.</u> That corresponds to my intuition. That that's the right thing. I can also ask, well, what if I had $10 million already, then would I take the bet, assuming my value of money is still logarithmic, and best<u>action tells me that yes, I should.</u> If I have $10 million, now I'm starting to look at money as more closely linear again. I'm at this stage where logarithmic function is approximately linear locally. If I've got $10 million, I could say, yeah, I'm risking my $1 million, but that's no big deal. I've already got $10. It's a good bet because if I win, I get 3 or 0--that's 1.5 on average, and that's more than 1, so I'm willing to take that bet, and I don't mind not gaining the additional $1 million. So now I want to ask you a question. So given this quality function Q, and assuming that our utility function is the log function, since we saw that for some values of this state the best action-- the action with the highest quality is 'hold' and other values is 'gamble,' there must be a point at which there is a crossover-- where the two values are approximately equal. So what I want you to tell me is: to the nearest million, what is that crossover point C? That value of state-- that value of the amount of money that I currently have to say that I'm indifferent between the 2-- that if I have C dollars, then my quality for gambling is the same or approximately the same as my value for holding. What value of C to the nearest million is that true of? And just to make it easier for those who can't divide by e in your head, we'll use the log10 logarithms rather than the natural logarithms so that the log10 logarithm of a million is 6. Tell me what the crossover point is to the nearest million. And the answer is crossover C is 1 million, and if I ask for the quality of C gambling versus hold with the log10 utility function-- and that's a two-value tuple-- and we see, in fact, they're the same. Now I want to gather a little bit more data, and here, again, there is no right or wrong answer even though the interface may tell you that your answer was right or wrong, I just want to do this sort of as a sociological experiment to see where people are. So just tell me what your crossover point is. Again, there is no right or wrong answer, but what's the number of dollars-- or euros, if you prefer that--at which you'd be indifferent between accepting this gamble and holding? And put that in as an integer number, not the number of millions. So, if your crossover point is 1 million, write 1 million here, don't write 1. Now let's get to work on defining an optimal pig strategy. So we need a Q and a U function, and an actions function. Let's get started on that. The Q function we'll call Q_pig. It takes a state and an action and evaluates the quality of that against the utility function. And what should we use for the utility function? Well, I think the best thing to use is the probability of winning because we get 1 point for winning and no points for losing. That's a good way of thinking about the game. And so our expected outcome is going to be somewhere between 0 and 1, and that's like a probability. And so the probability of winning is our score. If we win all of the time, the probability of scoring-- of winning is 1, then that should be worth 1 point. If we win none of the time, that should be worth 0 points. So our utility is just the probability of winning. And what is that? Well, if we hold, then we're turning it over to our opponent, and we still have our hold and roll functions that tell us what state we get to when we hold. And then it's our opponent's, and he's going to do his best, so our utility would be 1 minus the opponent's utility-- what he can do best, his probability of winning because either one player or the other has to win So our probability of winning is 1 minus our opponent's probability of winning. If we roll, it's more complicated. If we roll a 1, then we pig out, and it's 1 minus our opponent's probability of winning because it's his turn. And otherwise, we just take all the possibilities for the other die rolls, and it's our probability of winning from the result of rolling in that state, and that's six probabilities all together. So we have to average them. So we add them all up, and divide by 6. And if the action wasn't hold or roll, I'm going to raise the value. What are the actions in this state? Well, if there's some pending numbers, I can roll or hold, and if they're not, I'm just going to roll. That's the only thing that makes sense to do. Now what's the probability of winning from a state? It seems complicated. It seems like we've got a lot of work to do, but actually, we've almost solved the whole thing. All we have to do is say, "What's the end point?" So remember, we start out in the start position, and then we have some end positions where the game is over, and we have to assign utilities, which is the same as probability of winning, which is either 0 or 1. So this is a losing state, so it gets a Pwin of 0. This is a winning state. It gets Pwin of 1. We assign all of those, and then all the other states that depend on these-- we've already figured that out in terms of the Q function. Let's see how that works. So the probability of winning is 1 if my current score plus the pending is greater than or equal to goal. Then I win automatically just by reaping those pending. My probability of winning is 0 if your score is greater than the goal and I haven't won. And otherwise, my probability of winning is the probability that I get by taking the best action. So for all the actions-- among all the actions I can do, look for the Q value of that action-- from the current state according to the utility function-- try to maximize that, and that's going to be my probability of winning. So that's saying I can make the best choice that I can. So we said that we had 3 choice points. Here, I'm making the best choice by maximizing. Here, the die gets to roll, and we're averaging-- we're summing them all up and dividing by 6, so that takes care of the averaging-- and what about the worst choice that the opponent makes? Well, that's just folded in because rather than explicitly worrying about me and my opponent, I just said, "Well, I can use 1 minus the probability of me winning." That's the probability of the opponent winning. So now we're almost there. We've defined the problem. We've defined how the game works, and we're ready to write the optimal strategy-- the best possible strategy for Pig, and I'll let you finish it off. We'll call this function "max_wins"-- the strategy function that maximizes the number of wins-- --at least the number of expected wins-- and go ahead and write your code there, and you can write it in terms of the functions we've defined above and in terms of a call to best action. And this is all it is. We just call best action from the current state using the Pig actions, using the quality function for Pig and trying to maximize the probability of winning. Now let's see how we did. So I'm going to define a set of strategies-- the clueless strategy we expect to do the worst; strategies that try to solve the problem in 4 chunks, in 3 chunks in 2 chunks, and to solve it all in one win; and then the max win strategy. Now, we play a tournament with these strategies, and here's the results we get back. So you can see that the clueless strategy does very poorly-- only wins 23 games out of 500. The max win strategy does the best of all-- wins 325, but there's some competitors that are pretty close. So hold at 20 wins 314-- not that much worse off than the optimal strategy. And that holds up if we play a tournament with more games just to get a little bit more accuracy. You wouldn't be able to hit the run button and do this because it would time out, but if you bring it in to your own development environment, you can do that. And here we see max wins gets 13,100 wins, and hold at 20 is 12,900. So only a couple percent better for max wins over hold at 20, but still it's nice to know that no strategy can do better. And it turns out that if we increase the goal and made a longer game than just playing to 40 points-- that the advantage for max wins over any of these other strategies would only increase. In the betting game, we had different utility functions. We tried out the linear utility, and we tried out the logarithmic utility. What about here? Well, we defined our utility as a probability of winning, and the way the game is defined, that's really the only sensible one. If you're trying to win the game, you should maximize the probability of winning. But maybe your only goal isn't just to maximize the probability of winning. Maybe you're in a big Pig tournament, and your seated at the Pig table, rolling the dice, and in the stands are lots of spectators, watching the game with excitement. And you know that somewhere in the stands, there's a scout from the NPA--the National Pig Association. And what you want to do is not just win the game-- because lots of people are going to win the games-- but you really want to get the attention of that NPA scout so that you can move on and have a professional career. So maybe what your utility function would be would not just be to win the game, maybe your utility would be to maximize the differential, to say, "If I just won the game by a couple points, nobody is going to notice, but if I won by a lot-- if I really clobbered my opponent-- then maybe this guy would take notice, and that would be worth more to me." So you'd give up on the goal of just winning, and try to go for the maximizing your differential. So here I've written the utility function. I called this utility function "The Winning Differential." And given a state, it tells me what that differential is-- expected differential for that state. And what it says is if we're at the end of the game, if somebody's won, then before, remember that our utility function was 0 or 1, but here utility function is my score-- which is me, and I'm going to reap the pending-- minus your score. Otherwise, we just do the same thing with a Q function that we did before. And note that we're always careful to memoize these functions, because they're recursive, they're recalling themselves over and over again. We don't want to repeat those computations, so we memoize them so we only have to each date computation once. Now, what I want you to do is write the strategy function. This was the utility function over states, now I want you to write the strategy function. You can do it in terms of what we've defined before And the answer is you call best action from the state. The actions and the Q function are just like before, but the utility function we're trying to maximize is the differential. Now, I want to say right here that I made a mistake, and I haven't talked about this very much over the course of these lectures, but I'm making mistakes all the time. I know you guys are. You type something in, it doesn't work. I have the same problem over and over again. I keep making mistakes, and that's fine as long as I know how to correct them. Here the mistake I made is--the mechanical mistake was I messed up, and I typed the wrong function at one point. I think these function names are too similar, and I made a mistake in naming them max_diffs and win_diff. They sound too much alike, and when I was playing with this I put in the utility function where I meant to put in the strategy function, and that's an easy mistake to make because they sound the same. Probably I should have come up with better names. I should have called this windiffutility or something like that to make it clear that this is the utility function and this is the strategy function, but the annoying thing was that mistake went unnoticed for a while, and I'll show you part of the problem. Here's the play_pig function. It takes two strategies: A and B. These have to be strategy functions, and then it comes down here, and it applies the appropriate strategy function to a state, and it says if that strategy function decides to hold, then we do the hold action, otherwise-- well, there's only 2 actions you could do, so I'll do the roll action. That makes sense, right? Now here's the problem. If instead of passing in a strategy function you accidentally pass in a utility function, then that's all good down here. You say strategies of P apply to state, and that's really applying a utility function to state, what's the utility function going to return? Well, it's going to return a number, and play_pig just says, "Well, does that number equal to hold?" No, it's not. No numbers are equal to hold. So then I'm just going to assume that you meant roll. And so the fact that I passed in a completely wrong function that's doing nothing related to strategy-- it's returning a number rather than an action-- went completely unnoticed, and instead what my strategy was-- the utility function that returns a number acted as if it was a strategy function that always said roll. Now, in general, that's one of the complaints that people have about Python is that it's too easy to make that mistake because you don't have to declare for each function what are its inputs and what are its outputs. In other languages, you would do that, and the program where you accidentally used a utility function where you expected a strategy function-- that program wouldn't even compile. You'd get an error message before you ran it. In Python, you don't have that protection, so you've got to build in the protection yourself. So what I'd like you to do is update the play_pig function so that it looks at the result that comes back from the strategy function, and make sure that it's either hold or roll and if it's not one of those, then let's decide that what we do is that that strategy automatically loses a game. So if you make an illegal move, you lose the game right there. Here's how I did it--makes the function just a little more complicated. I added a variable called "action" to hold the result of the strategies. If it's hold, we hold. If it's roll, we roll. Otherwise, you lose, which means that the other strategy wins. So now let's go back and analyze this maximize differential strategy versus the maximizing probability of winning strategy. The question is, how do these 2 compare? When are they different, and when are they the same? If you're trying to impress the scouts, you're not going to be making some crazy moves, so probably most of the time, you'd expect the 2 strategies to agree, but some of the time, maybe 1 of them is going to be more aggressive or taking more chances than the other. Let's see if we can analyze that. So I start off by defining a bunch of states, and I'm just going to look from 1 player's point of view. It doesn't really matter to have both since it's symmetric, so for all these values of me, you, and pending, collect all those states. It turns out that there's 35,000 of them. Then I define a variable r to be a default dictionary, which counts up integers, so it starts at 0, and then I go through all the states, and I increment the count for a result for the tuple of the action that's taken by max_wins and the action that's taken by max_diffs. I want to count up. This is going to be hold, hold, roll, roll. etc. I want to see how many of each do we have, and let's convert r back to standard dict, and there we have it. So most of the time, 29,700 out of the 35,000--both strategies agree that roll is the right thing to do. Then another 1200 times, both strategies agree that hold is the right thing to do. But in 2 cases, they differ. So sometimes, max_wins says hold and max_diffs says roll. That happened 381 times, but 10 times more often, it's max_wins that says roll and max_diff that says hold. That actually surprised me. So it's the max_wins strategy that's really more aggressive. It's rolling more often. I thought it was going to be the max_diffs strategy. I thought that was going to be more aggressive, right? So that's the one that's trying to impress the scouts. I thought it was going to be rolling trying to rack up a really big score. But no! So the data tells a different story. It's not trying to rack up a really big score. So what's going on? Well, first it might be nice just to quantify how different they are since I kind of asked that question. So there's 35, 301 states all together and they differ on 3975 + 381, and that's 12% of the states that they differ on. So what's the story? Where do those 12% of the states come from? We still don't know, and we don't even quite know what questions to ask, but it's here that some of our design choices start to pay off. So remember we always start our design with an inventory of concepts, and we have things like the dice and the score, and then we got into things like the utility function and the quality function, so we built all these up, and yes, we're building from the ground up, and yes, at the top, we have a play_pig function, and we can still call that function, but at the bottom, we have all these useful tools. So now when we're not just about playing pig, now we're trying to analyze the situation to understand this story of why are these 2 different? Well, play_pig by itself--the top level function we define--that's not going to help us, but all these little tools that we built down here, they will be helpful. We can start to put them together and explore. So we built this tower, and the tower built up to define the play pig function, and in some languages, it's all about building the tower. When you're done, that's all you have. But in Python, it's common and in many languages, it's a good design and strategy to say let's just build up components along the way so that we--yes, we have the tower, but we can also go out in other directions. If we're interested--not just in playing pig--but we're interested in figuring out this story, then we can quickly assemble pieces from down here and build something that can address that. So I've got all the pieces available. It makes it easy to explore. But I still need an idea, and here's my idea. I expected maximize differential to be aggressive, to try to rack up the big points, and I found out that it was actually maximizing the probability of winning that was more aggressive that rolled more often. Why could that be? I think I might know the answer. I think it might be that the maximized differential is more willing to lose rather than more excited about winning by a lot. What do I mean by that? Well, if you're maximizing the probability of winning, you don't care if you lose by 1 or if you lose by 40, it's all a loss. The maximized differential--if he's losing by a fair amount, he might say, well--say he's behind 39-0 in a game to 40, and say he's accumulated 30 points, If he's trying to maximize the probability of winning, he would keep on rolling. He says, well, I don't have that good of a chance of winning, but all that counts is winning. If I stop now, the opponent's going to win on the next move, so I've got to keep rolling. Probably I'll pig out and only get 1 point, but it's worth it for that small chance of winning. That's what the maximize win probability strategy would do. The maximize differential strategy would say, hey, if I can get 30 points rather than 1, that cuts the differential way down, so that's worth doing. I'll sacrifice winning in order to maximize the differential. Now that's a suggestion of a story, but I don't know yet. Is that the right story? Let's find out. So here's what I did. I wrote this little function to tell a story. The story I want to tell is, over all the states, let's group the states in terms of the number of pending points in that state, and then for each of those number of pending points, say all the states for which there are 10 points pending, how many times did max_wins decide to roll versus how many times did max_diffs decide to roll? And just to consider the ones in which the 2 differ. So throw away all of the states in which they take the same action. Let's see what that looks like. Let me just describe briefly what I do. So I start off--I have a default dictionary and the default is that I have 2 values-- 0 for max_wins and 0 for max_diffs. Then I go through--get the 2 strategy functions to apply to the state. If they're different, figure out what pending is and increment the pending count for the person who decided to roll, and then I just go and print them out. Here's the result. It does tell a story. Look what's happening. When I have a small number of points pending, most of the time, the 2 strategies agree, but when they differ, it's the max_diff strategy that's deciding to roll. But as the number of points increase--the number of pending points increase, we see it's max_wins who's willing to roll, and max_diff not at all, so that's a perfect segregation between the 2 in this crossover point between 13 and 16. We're here. Max_wins is rolling all the time with very high pending amounts. But max_diff is never willing to do that. So what must be happening here is 300 times max_wins has 24 pending points, and he's willing to roll. It must be because the opponent is just about to win and he says, "Even though I'm risking 24, I still want to win the game, so I've got to roll." Max_diff says, "Are you crazy? I got 24 points on the board. I'm going to reap them right now. And yes, I may lose, but I'm really going to cut down that differential." So look what the story told us. I thought that this man in the arena who was playing the max_diff strategy was going to impress the NPA scouts by playing aggressively, and it turned out that the story was completely different. So what does that tell us. Well, first it tells us that there is an interesting distinction about how we wrote our function to maximize differential. Note that the way we wrote it is we completely separated the what, which is the rules of the game for how pig is played, from the how of how does it make decisions, and that was the perfectly general best actions. So we didn't go in and say, we're going to write specific rules for pig to say, if you're in such and such a position, do such and such. Rather we just said, here's how pig works. Here's what I'm trying to do. Maximize differential. You do the rest. So the results that came back were surprising to me because I didn't really understand how the what and the how interacted, but I was still able to write a program that maximized the differential, even though I didn't understand what that program is actually doing, and that's the power of breaking up these aspects into what's happening versus maximizing. The second part that's interesting here is that I was able to do exploration. So it wasn't just that I built a monolithic program that could do 1 thing. It's that I build a set of tools that could explore the area. When I wanted to understand something that was different from what I originally did, I was able to do that because I had the tools around. So we've talked about some probability problems that we can handle with simulation--that is, choosing using a random number generator, some samples, and hoping that they're representative of the problem. And if you choose enough, you get a close enough representation. An alternative strategy is enumeration, where we actually go over all the possibilities and we can compute an exact probability. Now, some problems are so complex that it would take forever to do that, but computers are much better at it than people are, and so it's a powerful strategy. We'll show you some simple examples, and they can scale up to more complex ones. So let's imagine all the possible families living in houses, and these houses have differeing poperties. This one is colored red and has an Englishman. This one has a zebra, and so on. But for now we're only interested in the children that live in those houses, and, in fact, we're only interested in the houses that have exactly 2 children. So we're going to not consider some of them, and consider the other ones that have exactly 2 children, and then we want to be able to ask questions of them. And we can ask probability questions. We're going to constrain ourselves to ask conditional probability questions. So what is the probability of Event A given Event B? And an event is just a state of affairs. So Event B might be the event of the family having exactly 2 children. And so we've crossed off these houses, and we're only taking these other ones, and then Event A might be the probability of having a boy or a girl. Now, in real life, we could do simulation by going out and polling and asking people. In mathematics, we can do enumeration if we make certain assumptions, and one assumption we can make is that it's exactly 50% probable that you get a boy and 50% probable that you get a girl and that one birth is independent from another. So let's address the question. What's the probability of having 2 boys given that there is at least 1 boy in the family? And the universe of possibilities is only the families that have exactly 2 children. So we could put that here in the condition as well-- at least 1 boy and 2 children total. What do you think this probability is equal to? Let's put your answer here and enter it in the form of a fraction. So if you think it's one-half, put 1 and then 2. If you think it's 11-17ths, put 11 and 17. Here's the way to look at it is we count up the number of equally probable events on this side, 1, 2, 3; and then we count up out of those how many appear on this side, just one; so the answer is one-third. Now if you could do all of these just by writing with a pen, you wouldn't be in a computer class. So let's start modeling this. And so we're going to do our concept inventory. So what do we have? Well, these individual results here come from random variables. So a random variable is like the first child born, which can be a boy or a girl. The whole universe is called the sample space, and then these individual sets of circles are called events--like the event of having (2 boys), or the event of having at least 1 boy. And an event consists, then, of a collection of sample points. So a sample point is BG, GB or BB. In terms of representation, we're going to just represent sample points as strings. So we'll have like the string, 'GG', and we can represent events two ways: as a collection of strings or as a predicate-- a function, which is true of certain strings and not of others. So here's what I did: I imported itertools because we're going to need that. I searched for--and found--a new class, called fractions, within the fractions module, and there's a function or a constructor, called fraction, which produces an exact fraction. And the reason I wanted that is because when the answer is 1/3, I wanted to see that it was exactly 1/3. I didn't want to see that it's .33333. So all a fraction is is a numerator and a denominator, paired together, and they know how to do arithmetic. So here's my random variable. I represent that as a collection of possibilities in here-- I just strung the possibilities together. I could have said set of 'BG' or the list of 'B,G' but I just put them together, as a string. Then I said we can combine random variables with a cartesian product--and I used itertools.product-- and then I just said: get all results, which itertools.product produces tuples, and I want to look at them as strings. So now two_kids is the product of two children and we're looking at their sex. So if I evaluate that, I get this collection. And one_boy is just the points in two_kids that have at least one boy in the string. So it would be this one, this one, and this one. And then I can define two_boys as a predicate. That's saying that's True when the count of the number of boys is equal to (2). That would be True here. And finally, I can define my conditional probability. That says what's the probability of (p), given (e), where (e) is an event specified as a list of sample points, all equal, probable, and predicate; is a predicate that returns True or False of elements of that event, and so the True elements are just the ones for which it is True, and then I returned a fraction-- how many out of the event satisfy the predicate. Then I can ask, what's the conditional probability of two_boys, given one_boy--and the answer is 1/3. So that's what we expected. Now let's move on to a slightly more complicated question: out of all the families with two kids-- with at least 1 boy, born on a Tuesday-- what's the probability of two boys? Now, you might think that the answer should be the same-- it should still be 1/3 because why does Tuesday matter? After all, the kid's gotta be born sometime and if it happens to be Tuesday, why would that be any different than any other day? So is it 1/3? Well, as Gottfried Leibniz said, "Let us calculate." So we have the technology to model that. First, a random variable for day of the week-_ and I had to fool around with the capitalization there, to make sure that we have 7 distinct letters: Sunday, Monday, Tuesday, Wednesday, Thursday, Friday, Saturday-- plus ample space of twokidsbday, one kid with their day of birth; the second kid, with their day of birth. What does that look like? Well, it's this huge thing of (2 X 7 X 2 X 7) entries. The first one: Boy born on Sunday; boy born on Sunday, all the way through to the last one: girl born on Saturday, girl born on Saturday. Then a boy born on Tuesday is all the elements of this, where "BT" appears is in the string. So either "BT" will be the first 2 characters or the last 2 characters. And now we're finally at the point where we can say: given at least 1 boy_tuesday, what's the probability of two_boys? And before I show the results, I'm going to ask you what you think it is. You could follow along, either with pencil and paper or do the computation or just think it out in your head. So Enter as a fraction. If you think it's 1/3, put a 1 here and a 3 here--or whatever. If I go ahead and execute this and print the result, it comes out: 13/27. Wow! Where did that come from? So that' surprising--first of all, it's not 1/3, which you might have thought should be the answer if you believe the argument that Tuesday doesn't matter. And secondly, not only is it not 1/3, but it's much closer to 1/2 than it is to 1/3. So just having the birthday there really changed things a lot. How did that happen? Well, I wrote up a little function here to report my findings, and here's its arguments. You can give it a bunch of cases that you care about-- the predicate that you care about and whether you want the results to be verbose or not. And it just prints out some information-- and, by the way, as part of this, I also looked at the question of what's the probability of two<u>boys,</u> given that there's one boy born in December so I threw that in as well. And here's the output I get: 2 boys, given 1 boy is 1/3; 2 boys, given at least 1 boy born on any day is still 1/3; and born on Tuesday is 13/27, and born in December is 23/47. Now, I can turn on the verbose option to report In that case, here's what I see: The probability of 2 boys, given at least 1 boy-- born on Tuesday--is 13/27. And here's the reason--at least 1 boy, born on Tuesday, has 27 elements--and there they are-- and of these, 13 are 2 boys--and there they are. And so, you can't really argue with that. You can go through and you can make sure that that's correct, and you can look at the other elements of the sample space and say no, we didn't miss any-- so that's got to be the right answer. It's not quite intuitive yet, and I'd like to define my report function so that it gives me that intuition but right now, I don't have the right visualization. So I've got to do some of the work myself. And here's what I came up with: We still have the four possibilities that we showed before but now we're interested, not just in boys-- we're interested in boys born on Tuesday. So there's going to be some others over here where there's, say, boy born on Wednesday, along with some other partner-- maybe a boy born on Saturday. But we're not even considering them; we're throwing all those out. We're just considering the ones that match here. And like before, we draw 2 circles: one of the right-hand side of the event-- of the conditional probability. And so how many of those are there? Well, there's 7 possibilities here because the boy has to be born on Tuesday-- there's only 1 way to do that--but there's 7 ways for the girls to be born. So there's 7 elements of the sample state there; likewise, 7 elements over here. Now how many elements over here? Well here, either one of the 2 can be a boy born on Tuesday. So really, we should draw this state as either a boy born on Tuesday, followed by another boy or a boy, followed by a boy born on Tuesday. And how many of those are there? Well, there's 7 of these by the same argument we used in the other case, and of these, there's also 7 but now I've double-counted because in one of these 14 cases is a boy born on Tuesday, followed by a boy born on Tuesday. So I'll just count 6 here. And so now it should be clear: 7, 14, 21, 6, 27. There's 27 on the right-hand side, and then what's the probability of 2 boys, given this event of at least 1 boy born on Tuesday? Well, 2 boys--that's here--so it's 13 out of the 27. So that's the result. Seems hard to argue with. Both the drawing it out with a pen and the computing worked out to the same answer. Now why is it that we have a strong intuition that, knowing the boy born on Tuesday shouldn't make any difference? I think the answer is because we're associating that fact with an individual boy. We're like taking that fact and nailing it on to him--and it's true. If we did that, that wouldn't make any difference. But, in this situation, that's not what we're doing. We're not saying anything about any individual boy. If we did that, the computation wouldn't change. Rather, we're making this assertion that at least one was born on Tuesday-- not about boys, but about pairs. And we just don't have very good intuitions about what it means to say something about a pair of people, rather than about an individual person, and that's what we did here-- and that's why the answer comes out to 13/27. So let's summarize what we did in this Unit. We learned that probability is a powerful tool for tackling problems with uncertainty. We learned that we can do Search with uncertainty, like we did Search in the previous Unit, over Exact Certain domains. Here, we can handle uncertainty in our Search. We learned that the notion of Utility gives us a powerful and beautiful general approach to solving the Search problems. It gives us the best-action function with which we can solve any problem that can be specified in the form that best-action expects, and that's a wide variety of problems. Now, some of them are so complex that they can't be computed in a feasible amount of time. And there are more advanced techniques for dealing with approximations to that. But it's incredibly powerful because it separates out the How versus the What. You only have to tell the computer what the situation is. You don't have to tell it how to find the best answer, and it automatically finds the best answer. And we learned you can deal with probability through simulation, making repeated random choices, and just counting up in how many one answer occurs, versus another. And we learned that if the total number of possibilities is small, you can just enumerate them. You can count them all, and you can get an exact answer, as an exact fraction rather than an approximation. And we learned some general strategies that don't have to do with probability. When we were trying to figure out how to add printing to our game, we looked at the notion of a wrapper function. That is, how we inject functionality into an existing function, by sneaking it in on top of one of the arguments. And this is an example of aspect-oriented programming, where we take the aspect of printing out what's happening and keep that separate from the main logic of the program. We learned that you can do exploratory data analysis. When I was looking at the two strategies for playing PIG and where they differed, that was a completely different question than what I'd designed the PIG program for. Because I had put together the right pieces, it was easy to do the exploration and come to an understanding. And we learned--or, at least, I learned because I was the one who made the mistake-- that errors can pop up, particularly in the types of arguments and results that functions expect in return-- and that you have to be careful, Python, to deal with that because Python doesn't give you the seatbelts that other languages have, to protect yourself from those type of errors. So you have to be vigilant, on your own. And finally, that was a lot to cram into one Unit. So if you followed along all of that-- congratulations, for the work you've done. You've learned a lot. Have fun with the homework; we'll see you in the next Unit. Hi, welcome back. So far in this class we covered a lot of programming techniques, but we mostly done it with small examples of code. In this unit, we’re going to look at a larger example than anything we seen before. We’re going to write an algorithm for finding the highest scoring play in a crossword tile game. Now, versions of this game go by names like Scrabble and Words with Friends. So we’re going to have to represent everything about the words, the tiles, the board, the scoring and the algorithm for finding the highest scoring word. That’s going to be more code I’m going to be writing a lot of it and you’re going to get practice reading, that’s an important skill but I’m also going to stop and leave you plenty of places where you can write some other code and at any point, if you want a bigger challenge, you can stop the video and go ahead yourself and try to solve as much of it as you can on your own and I would encourage you to do that. This is a big step-up. I think you are all ready for it. So let’s get started. We've got a lot to cover and not much time to do it so let's dig right in. Here's a game I'm playing online with my friend, Ken. I'm winning by a little bit mostly because I got good letters like the Z and so on but Ken is catching up. Let's dig right in and come up with our concept inventory. What have we got? Well, the most obvious thing, there's a board, there's letters--both letters on the board and letters in the hand, and the letters on the board have to form words and in the hand they're not. There's the notion of a legal play on the board, so RITZY is a word, and it's a word independent of where it appears, but it's legal to have placed it here where it hooks up with another letter, and it wouldn't have been legal to place it where it bumps into the H or where it's not attached to anything else. There's the notion of score and the score for individual letters. Z is worth 10. An I is worth 1, and there are scores for a play where you add up the letters. Part of that is that there are bonuses on the board. DL means double letter score. A letter that's placed there gets doubled. DW means double word score. If any letter of the word is on that square, then the whole word score is doubled, and we also have triples as well. Somewhere behind the scenes, there's a dictionary and all these words are in the dictionary and other combinations of letters are not. Then not shown here is the notion of a blank tile. Part of the hand might be a blank that isn't indicating any particular letter, but you're free to use for any one, similar to the way we had jokers in the game of poker. Now let's talk about how to implement any of these, see if there's any difficulties, an areas that we think might be hard to implement. The board can be some kind of two-dimensional array, maybe a list of lists is one possibility. One thing I'm not quite clear on now is do I need one board or two? It's clear I need one board to hold all the letters, but then there's also the bonus squares. Should that be part of the same board or should that be a separate board and the letters are layered on top of this background of bonus squares? I'm not quite sure yet, but I'm not too worried about it, because I can make either approach work. A letter can be one character string. A word can be a string. A hand can also be a string. It could also be a list of letters. Either one would be fine. Any collection of letters would be okay. Note that a set would not work for the hand. The hand can't be a set of letters, because we might have duplicates, and sets don't allow duplicates. Now, for the notion of a legal play, we'll have some function that generates legal plays, given a board position and a hand, and then the plays themselves will need some representation. Maybe they can be something like a tuple of say starting position-- for example, "RITZY" starts in this location, the direction in which they're going-- are they going across or down, the two allow about directions--and the word itself. In this case, RITZY. That seems like a good representation for a legal play. I'm not quite sure yet what the representation of a position or a direction should be, but that's easy enough. A score--we'll have some function to compute the score. For letters, we can have a dictionary that says the value of Z is 10. For plays we'll need some function to compute that. For the bonus squares, we'll need some mapping from a position on the board to double word or triple letter or whatever. A dictionary is a set of words. The blank letter--well, we said letters were strings, so that's probably okay. We could use the string space or the string underscore, to represent the blank. Then it's dealing with it that will be an issue later on. Now, I'm a little bit worried about blanks, because in poker Jokers were easy. We just said, replace them by any card and just deal with all the possibilities. Our routines are fast enough that we could probably deal with them all. Here I'm pretty confident we can make it fast enough that that approach will work, but it doesn't quite work because not only do we have to try all possibilities for the letter, but the scoring rules are actually different. When you use a blank instead of a letter, you don't get the letter scores for that blank. We'll have to have scoring know about blanks and not just know about filling things in. That'll be a complication. But overall I went through all the concepts. I've got an implementation for both. Some of them are functions that I don't quite know how to do, but I don't see anything that looks like a show stopper. I think I can go ahead. The difficulty then is not that I have to invent something new in order to solve one of the problems. The difficulty is just that there's so much. When faced with a problem of this size or problems can be much larger, the notion of pacing is an important one. What do I mean by that? It means I want to attack this, and I know I'm not going to solve it all at once. I'm not just going to sit down for 20 minutes and knock out the whole problem. It's going to be a lot longer than that. I want to have pacing in that I have intermediate goals along the way where I can say, okay, now I'm going focus on one part of the problem, and I'm going to get that done. Then when I'm done with that part, then I can move on to the next part. If you don't have that pacing, you can lose your focus. You can get discouraged that there's so much left to do. But if you break it up into bite-sized pieces, then you can say, okay, I'm almost there. I just have to finish a little bit more, and now this piece will be done, and then I can move on to the next piece. The first piece I'm going to look at is finding words from a hand. In other words, I'm going ignore the whole board. I'm going to say pretend the board isn't there and pretend all we have is the hand, and we have the dictionary, a set of legal words. I want to know out of that hand, what words in the dictionary can I make? Let's get started. The first thing I need is to come up with a dictionary of all the words. Now, we've created a small file with about 4,000 words in it, called "word4k.txt." Let's take that file, read it, convert it to uppercase, because Scrabble with Words with Friends use only uppercase letters, split it into a list of words, assign that to a global variable-- we'll call it WORDS and put it in all uppercase, just make sure that it stands out. Let's make this a set so that access to it is easy. We can figure out very quickly whether a word is in the dictionary. Okay, so now we're done. We have our words. Then I want to find all the words within a hand. So the hand will be seven letters, and I want to find all the words of seven letters or less that can be made out of those letters. I'm going start with a very straightforward approach, and then we're going to refine it over time. Here is what I've done. I haven't worried about repeating myself and about making the code long. I just wanted to make it straightforward. Then I said, the first letter a can be any letter in the hand. If that's a work, then go ahead and add that to my set of results. I start off with an empty set of results, and I'm going to add as I go. Otherwise, b can be any letter in the result of removing a from the hand. Now the word that I'm building up is a + b--two-letter word. If that's a word, add it. Otherwise, c can be any letter in the hand without w in it-- the remaining letters in the hand. A new word can is a + b + c. If that's in WORDS, then add it, and we just keep on going through, adding a letter each time, checking to see if that's in the WORDS, adding them up. Here's my definition of removed. It takes a hand or a sequence of letters and then the letter or letters to remove. For each of those letters just replace the letter in the collection of letters with the empty string and do that exactly once, so don't remove all of them. Then return the remaining letters. Does it work? Well, if I find words with this sequence of letters in my hand, it comes back with this list. That looks pretty good. It's hard for me to verify right now that I found everything that's in my dictionary, but it looks good, and I did a little bit of poking around in the dictionary for likely things, and all the words I could think of that weren't in this set were not in the dictionary. That's why they weren't included. That's looks pretty good. I'm going to be doing a lot of work here, and I'm going to be modifying this function and changing it. I'd like to have a better set of tests than just one test. I made up a bigger test. I made up a dictionary of hands that map from a hand to a set of words that I found. The idea here is that this test is not so much proving that I've got the right answer, because I don't know for sure that this is the right answers. Rather, this is what we call a regression test, meaning as we change our program we want to make sure that we haven't broken any of these--that we haven't made changes to our functions. Even if I don't know this is exactly the right set, I want to know when I made a change, have I changed the result here. I'll be able to rerun this and say, have we done exactly the same thing. I'll also be able to time the results of running these various hands and see if we can make our function faster. Here is my list of hands. I've got eight hands. Then I did some further tests here. I'm testing removing letters--got all those right. Then I'm going through the hands, and I'm using my timedcall() function that we build last time. That returnsin lapsed time and a set of results. I make sure all the results are what I expected. Then I return the time elapsed for finding all the words in those eight hands. It turns out it takes half a second. That kind of worries me. That doesn't sound very good. Sure, if I was playing Scrabble with a friend and they reply in a half second, that'd be pretty good. Much better than me, for example. In this game here it says that I haven't replied to my friend Ken in 22 hours. This is a lot better, but still, if we're going to be doing a lot of work and trying to find the best possible play, half a second to evaluate eight hands-- that doesn't seem fast enough. Why is find_words() so slow? One thing is that it's got a lot of nested loops, and it always does all of them. A lot of that is going to be wasteful. For example, let's say the first two letters in the hand were z and q. At the very start here w is z + q, and now I loop through all the other combinations of all the other letters in the hand trying to find words that start with z + q, but there aren't any words in the dictionary that start with zq. As soon as I got here, I should be able to figure that out and not do all of the rest of these nested loops. What I'm going to do is introduce a new concept that we didn't see before in our initial listing of the concepts, but which is an important one--the notion of a prefix of a word. It's important only for efficiency and not for correctness--that's why it didn't show up the first time. The idea is that given a word there are substrings, which are prefixes of the word. The empty string is such a prefix. Just W is a prefix. W-O is a prefix. W-O-R is a prefix. Now, we always have to decide what we want to do with the endpoints. I think for the way I want to use it I do want to include the empty string as a valid prefix, but I think I don't want to include the entire string W-O-R-D. I'm not going to count that as a prefix of the word. That is the word. I'm going to define this function prefixes(word). It's pretty straightforward. Just iterate through the range, and the prefixes of W-O-R-D are the empty string and these three longer strings. Now here's the first bit that I want you to do for me. Reading in our list of words from the dictionary is a little bit complicated in that we want to compute two things--a set of words and a set of prefixes for all the words in the dictionary. The set together of prefixes for each word--union all of those together. I'm going to put that together into a function readwordlist(), which takes the file name and returns these two sets. I want you to write the code for that function here. Here’s my answer. The wordset is just like before. Read the file, uppercase it, and split it. In the prefixset, we go through each word in the wordset and then each prefix of the word, and collect that set p of prefixes and then return them. Now let’s see what these prefixes can do for us. I can define a new version of find_words(), and what this one is it looks exactly like the one before except what we do at each level of the loop is we add one statement that says, if the word that we built up so far is not one of the prefixes of a word in the dictionary, then there’s no sense doing any of these nested loops. We can continue onto the next iteration of the current loop, and that's what the continue statement says is don't do anything below, rather go back to the for loop that we’re nested in and go through the next iteration of that for loop. Normally, I don’t like the continue statement and normally, instead of saying if w not in prefixes continue, I would've said if w in prefixes then do this, but that would’ve introduced another level of indentation for each of these seven levels and I’d be running off the edge of the page, so here I grudgingly accepted the continue statement. The code looks just like before. I’ve just added seven lines. The exact same line indented into different levels goes all the way through a, b, c, d, e, f, and g. Now if I run the test_words function again, I get not half a second but 0.003 seconds. That’s nice and fast. That’s 150 times faster than before, 2000 hands per second. The function is long and ugly, but it’s fast enough. But still I’d like to clean it up. I don’t like repeating myself with code like this. I don’t like that this only works exactly for seven letters. I know that I may need more than that because there’s only seven letters in a hand, but sometimes you combine letters in a hand with letters on the board. This function won't be able to deal with it. In order to improve this function I have to ask myself, "What do each of the loops do?" "And can I implement that in another way other than with nested loops?" The answer seems to be that each of the nested loops is incrementing the word by one letter, from abcd to abcde, and then it's checking to see if we have a new word, and it's checking to see if we should stop if what we have so far is not a prefix of any word in the dictionary. If I don't want to have nested loops what I want instead is a recursive procedure. I'm going to have the same structure as before. I'm going to start off by initializing the results to be the empty set, and then I'm going to have some loops that add elements to that set, and then I'm going to return the results that I have built up. Then I'm going to start the loops in motion by making a call to this recursive routine. What I want you to do is fill in the code here. The answer is here we're doing a nested loop, and the way we do a nested loop is the way we did the first loop-- by calling extend prefix. What is the word so far that we've built up? It's the w we had before, and now we're looping through the letters, so we want to add the letter L to the end of that. Now what are the remaining letters we have in order to add into that word? That's the letters we had before with L removed. That's all there is to it. Now if we test words again, the speed is almost the same--0.003 something, but the function is more concise, more readable, and more general in that it will take any number of letters. Now, there are a lot of variations on this. If you type "import this" into a Python interpreter you get out a little set of aphorisms, almost like a poem, called "The Zen of Python" by Tim Peters. One of them says "Flat is better than nest." We can take out this nested function. Instead of having it in here, we can make it flat like that. I've also made a small change here in that removed works when you're removing any number of letters. Here if I only want to remove one letter, I can just call the built-in method letters.replace directly. When we call test_words() on this just to make sure we haven't broken anything, it verifies okay, and the speed is about the same. You can keep it like this. This is a good approach. I'm pretty happy with this one. But notice what we're doing here--find_words() is sort of a wrapper to extend_prefix(), which takes letters and adds in two more extra arguments-- the prefix that we found so far and the results that we want to accumulate the results into. Instead of having one function call a second, we could do this all in one function if we made these two extra things be optional arguments. We could do it like that--where we just have one function find_words(), which takes letters, and then the optional prefix of our end results to accumulate into. Now in terms of pacing, let's stop here. Let's congratulate ourselves and say we've done our job. We've come up with find_words(), and we said for any set of letters I can find all the words in the dictionary that correspond to that hand of letters. Furthermore, I can do that at a speed of 2000 hands per second, which seems pretty good. We've achieved our first milestone. Now we should think--first I guess we should relax, congratulate ourselves, have a drink or whatever it is you need to do, and then when you're ready to come back then we can start the next leg of the journey. Let's go back to our list of concepts and say what have we done so far and what's next? We think we did a good job with the dictionary, and we did a good job with our hands here. In terms of legal play, well, we've got words, so we're sort of part way there, but we haven't hooked up the words to the board. Maybe that's the next thing to do--is say, let's do a better job of hooking up the letters and the hand with the words in the dictionary and placing them in the right place on the board. I don't want to have to deal with the whole board. Let's just deal with one letter at a time. Let's say there is one letter on the board, and I have my hand and I want to say I can play W-O-R and make up a word. Just to make it a little bit more satisfying than one letter, let's say that there is a set of possible letters that are already on the board, and we can place our words anywhere, but we're not going to worry about placing some letters here and having them run off the board. We're not going to worry about placing letters here and having them run into another letter. We're just going to say what words can I make out of my hand that connect with either a D or an X or an L. So I need a strategy for that. Let's just consider one letter at a time. What I need to find is all the plays that take letters in my hand-- [HANDSIE] let's say those are the seven letters in my hand. Take those letters and combine them with a D and find all the words. What can those words consist of? They can have some prefix here, which can be any prefix in our set of prefixes that come solely from the letters in my hand. Then the letter D that's already there doesn't have to come from my hand. Then some more letters. I'll think of this as a prefix plus a suffix where I make sure that I know that D is already there. Here is word-plays--takes a hand and a set of letters that are on the board, and it's going t o find all possible words that can be made from that hand, connecting to exactly one of the letters on the board. We're going break it up into a prefix that comes only from the hand, then the letter from the board, and then the remainder of the suffix that comes from the hand. The same structure as we had before--we start off with an empty set of result words. In the end we're going to return that set of result words. Then we're going to go through all the possible prefixes that come exclusively from the hand, then the possible letters on the board, and add a suffix to the prefix plus the letter on the board from the letters in the hand except for we can no longer use the letters in the prefix. Find_prefixes is just like find_words except we're collecting things that are in the prefixes rather than things that are in the list of words. Now I want you to write add_suffixes. Given a hand, a prefix that we found before, results set that you want to put things into, find me all the words that can be made by adding on letters from the hand into the prefix to create words. One answer is you could just call extend prefix. We change the order of the arguments around. That would do the trick. Or you could spell it out explicitly like this. I'm going to stick with this because over time we're going to be modifying this function. We're going to be dealing with complications like what happens if you run off the edge of the board, what happens if you intersect with other letters on the board. I want to have something that I can customize rather than the extend prefix that we wrote before. We can write some assertions here. Here we have some letters in my hand, seven letters, and some possible letters on the board, and here's a long list of possibilities for plays I could make. We can already see that this would be useful for cheating--I mean, augmenting or studying your word game play. And to make it even more useful, let's write a function that tells us what the longest possible words are. Given the definition of word play, write a definition of longest words. There we go--we just generate the words from word plays, and then we sort them by length in reverse order so that longest are first. Now, if I tell you the point value of every letter. I'm creating a dictionary with the point values. I'm using underscore to indicate the blank, but we won't be dealing with blanks yet. Now, I'd like you to write the function word_score for me, which takes a word--a sequence of letters--and tells me the total score for it according to the points of each letter, and it's not dealing with any bonuses on the board-- any double letters, or triple words, or anything. Here's my solution. It's pretty straightforward. We just sum the points of each letter for every letter in the word. Now, I want you to write me a function called topn. Again, takes a hand and set the board letters and the number, which defaults to 10, and give me the n best words and highest scoring words, according to the word score function. Again, pretty straight forward. We get the word plays, and we sort them in reverse order again so that bgigest are first, this time by word score, and then we just take the first n. By doing the subscripting like that, it works when n is too big. It works when n equals none. Now, just an aside here, as the great American philosopher, Benjamin Parker once said, "With great power comes great responsibility." We have a great power here to go through all the words in the dictionary and come up with all the best plays. Now, I could read in the official Scrabble dictionary and I could apply the board position that you saw in my game with Ken and I could come up with a bunch of good plays. But that wouldn't be fair to my friend Ken, unless we had previously agreed that it was legal and fair to do so. I'm not going to do that. I got to resist that temptation. And throughout your career as an engineer, these types of temptations or these types of possibilities are going to come up. Having strong ethics is part of learning to be a good software engineer. So now, in terms of our pacing, we've achieved milestone #2. We can stop sprinting again. We can relax. You can have a drink. We can lay down. We can congratulate ourselves or do whatever we want to do. Let's go back to our list of concepts, go back to our diagram of where we were and say, "What should be the next step?" Well, what can we do now? We can take a hand and we can take a single letter on the board and we can say, "Yes, I can pick letters out of the hand and maybe do a S-I-D-E." That would be a good play, except if there was an X here, then it would not be a good play. Similarly, if there were letters in the opposite direction, that could be a bad play. But sometimes, there's letters in the opposite direction and it makes a good play. Where here I'm forming two words at once, and the rules are the play I have to make has to be all in one direction and all adjacent to each other so forming one consecutive word. Then if it incidentally forms some other words in the other directions, that's okay. But I can't put some in this direction and then put some others down in that direction. I think my next goal will be to place words on a row while worrying about the crosswords in the opposite direction. Now let's be a little bit more precise about what the rules are and what it means to play a word within a row and how that hooks up to the other columns. Now, the rules say that at least one letter that you play has to be adjacent to an existing letter on the board. We'll mark with red asterisks such squares. We call these anchor squares. These are the squares that we can start from. Then we build out in each direction, forming consecutive letters into a single word. Now, the anchor squares do have to be adjacent to an existing letter, but they don't have to be adjacent all within a row. They can be adjacent in either direction. Let's expand the board beyond a single row and let's populate this with some more letters. Imagine that this board goes on in both directions. There's probably an E here or something like that. If we restrict our attention just to this row, notice that we've now introduced a new anchor point. This square is adjacent to an existing letter, and so that also counts as an anchor. Now we want to find a word, which consists of a prefix plus a suffix. We get to define the game. We can say that for every anchor point, the prefix is going to be zero or more letters to the left of the anchor point, not counting the anchor point itself. Then the suffix will be the anchor point and everything to the right. Of course, we have to arrange so that prefix plus suffix together form a word which is in the dictionary. Now here's a cool play that comes from the dictionary. BACKBENCH is a word, and note that if we just have this rule of word equals prefix plus suffix where the suffix has to start with an anchor, then there'd be four possible ways of specifying this one move. We could anchor it here with no suffix. We could anchor it here with these three letters as a suffix. We could anchor it here with these letters as a suffix. Or we could anchor it here with all these as a suffix and just H as the prefix. Now, it seems wasteful to degenerate the same result four times, so we can arbitrarily and without loss of completeness make up a rule which says there's no anchor within a prefix. We couldn't use this as a the anchor, because then there'd be anchors within the prefix. Likewise, we couldn’t use this one or this one. We can only use this one as the prefix in order to generate this particular word. The anchor will also come from the hand, and the suffix can be a mix of hand and board. Here, this is the anchor. The prefix is empty. The anchor letter comes from the hand. Then there's a mix of letters for the rest of the word. Now, what are the rules for a prefix. Let's summarize. A prefix is zero or more characters, can't cover up an anchor square, and they can only cover empty squares. For example, for this anchor square here, the prefix can go backward, but it can't cover this anchor. So the possible lengths for this prefix are zero to two characters. Any prefix can be zero characters, and here there's room for two, but there's not room for three, because then it would cover up an anchor. In that case, all the letters in the prefix come from the hand, but consider this anchor. For this anchor, we're required to take these two letters as part of the prefix, because we can't go without them because this abuts. These two must be part of the prefix, and this one can't be part of the prefix because it's an anchor. If we wanted that we generate it from this anchor, rather than from this one. That means the length of a prefix for this anchor has to be exactly two. Similarly, the length of the prefix for this anchor has to be exactly one, has to include this character, because if we place a letter here, this is adjacent-- it's got to be part of the word--and this is an anchor so we can't cover it. So we see that a prefix either the letters come all from the hand o or they come all from the board. What I want you to do is for the remaining anchors here, tell me what the possible lengths are. Either put a single number like this or a range of numbers--number-number. The answers are for this anchor the prefix has got to be one character--the A. This anchor--we can't cover another anchor, so it's got to be zero. This anchor--we conclude this if we want, but we can't go on to the other anchor, so it's zero to one. Here we've got to include the D but nothing else, so it's 1. Now, there's one more thing about anchors I want to cover, which is how we deal with the words in the other direction. For these five anchors there are no letters in the other direction. So these are completely unconstrained. We say that any letter can go into those spots. But in these two anchors, there's adjacent letters, and it would be okay. We could form a word going in this direction. But we can do that only if we can also form a word going in this direction. Let's say there are no more. This is either the edge of the board or the next row is all blanks. Then we can say, well, what letters can go here? Only the letters that form a word when the first letter is that word and the second letter is U. In our dictionary, it turns out that that possibility is the set of letters M, N, and X. MU, NU, and XU are all words in our dictionary, believe it or not. The Scrabble dictionaries are notorious for having two- and three-letter words that you've never heard of. Similarly here--what are two-letter words that end in Y? It' the set M, O, A, B. You've probably heard of most of those. When we go to place words on a particular row, we can pre-compute the crosswords and make that be part of the anchor. What we're going to do is have a process that goes through, finds all the anchor points, and finds all the sets of letters--whether it's any letter for these five anchors, or whether it's a constrained set of anchor letters for these two anchors. Sounds complicated, but we can make it all work. Let me say that once you've got this concept, the concept of the anchor sets and the cross words, then basically we're done. We've done it all. We can handle a complete board no matter how complicated, and we can get all the plays. It's just a matter of implementing this idea and then just fleshing it out. We've congratulated ourselves for getting this far. We've still got a ways to go. Now the question is what do we do next? It may seem a little bit daunting, but there's so much to do, and when I get that feeling, I remembered the book Bird by Bird by Anne Lamott, a very funny book. In it, she relates the story of how when she was in elementary school and there was a big book report due where she had to write up descriptions of multiple different birds. And she was behind and it was due soon, and she went to her father and complained, "How am I ever gonna get done. I'm behind," and her father just told her, "Bird by bird." "Just go and take the first bird, write up a report on that, and then take the next bird off the list and keep continuing until you're done." Let's go bird-by-bird and finish this up. What do we have left to do? Well, we got to figure out how to put letters on one particular row while dealing with the crosswords, then we got to expand from that to all the rows and then we got to do the columns as well, and then we got to worry about the scoring. There was a couple of minor things to be put off like dealing with the blanks. That's a lot to do, and let's go bird-by-bird . The thing I want to do next is say let's just deal with a single row at a time. Let's not worry about the rest of the row. Let's now worry about going in columns. Just deal with one row but also have that row handle the cross letters--the cross words. I'm going to need a representation for a row, and I think I'm going to make that be a list. There are many possible choices, but a list is good. I choose a list rather than a tuple, because I want to be able to change it in place. I want to be able to modify the row as we go, as the game evolves. Row is going to be a list of squares. If the square is a letter, we'll just use that letter as the value of the square. If the square is an empty spot which has nothing in it, I think I'll use dot just to say nothing is there. A trick that you learn once you've done this kind of thing a lot of times, is to say I'm going to be look at letters, I'm going to be looking at locations in the row, I'm going to be looking at their adjacent letters and going to the right and going to the left. If I'm trying to fill in from this anchor, I'll move to the left to put in the prefix and I'll move to the right to extend the word. It seems to me like I'm always going to have to be making checks of saying what's the next character, is it a letter, is it an anchor, what is it? Also, oops, did I get past the end of the board. It seems like I'm going to have to duplicate the amount of code I have to write to check both the case when I go off the board and when I don't go off the board. One way to avoid that is to make sure you never go off the board. It cuts the amount of code in half to some extent. A way to do that is to put in extra squares-- to say here are the squares on the board, but let's make another extra square on each side and just fill that in say the value of what's in that square is a boarder, not a real square that you can play in, but if I'm here and I say what's the value of square number i -1, I get an answer saying it's a border rather than getting an answer that's saying when you go i - 1 from position 0 you get an error. I think I'll use a vertical bar to indicate a border. I'll have one there, and at the end of my row, I'll have another border. Now I've sort of got everything. I got borders, letters, empty squares. The only thing left is anchors. I think what I'll do here is I'll introduce a special type for anchor. I could have used something like a tuple or a set of characters, but I want to make sure I know, and I want to have something in my code that says if the value of row[ i ] is an instance of anchor, then I want to do something. So we'll make anchor be a class, and I want it to be a class that contains the set of letters. I can do that in a very easy way. I can use a class statement to say I'm going to define a new class. The class is called an anchor, and the class is a subset of the set class. Then I don't need anything else for the definition of the class. All I have to know is that anchors are a type of set, but they're a particular type of set. They're a set of anchor letters. Here's a code for that. I define a class of anchor. I have all of my allowable letters. Then I say any is an anchor, which allows you to put any letter onto that anchor spot. Now I want to represent this row where here are the borders, here are the empty spots, and here are the particular letters, and this representation-- the schematic representation as a string does not account for a fact that after the A we're going to have two restricted anchors that have to contain these characters. So we'll define them--use the names mnx and moab to be the two anchors that are restricted to have only those letters. Now our row is equal to the border square is element number 0. Then the A is element number 1. Then we have these two restricted anchors, two more empty spots, another anchor where anything can go--the B and the E, and so on. There's our whole row, and while I'm at it I might as well define a hand. Now my next target, the next bird to cross off the list is to define a function row<u>plays,</u> which takes a hand and a row in this format and return a set of legal plays from the row. Now, rather than just return legal words, I'm using this notion of a play, where a play is a pair of location within the row and the word that we want to play. You can imagine it's going to take the same general approach that we've used before, start with an empty set, do something to it, and then return the results that we built up. What is it that we want to do? We want to consider each possible allowable prefix, and to that we want to add all the suffixes, keeping the words. Now, prefixes of what? That's the first thing to figure out. What I'm going to do is enumerate the row--enumerate actually just the good bits. The row from the first position to the last position, and that tells me I don't want the borders. I don't want to consider playing on the borders. I just want to consider playing on the interior of the row. Enumerate that starting from position number 1. One would be where the A is. Now I have an index--a number 1, 2, 3--and I have the square, which is going to be a, and then an anchor and then an anchor and so on. Where do I want to consider my rows? We're going to anchor them on an anchor so I can ask a square an instance of an anchor. If it is an anchor, then there's two possibilities. If it's an anchor like this, there's only one allowable prefix. The prefix which is the letters that are already there just to the left of the anchor. We want to just consider that one prefix and then add all the suffixes. If it's an anchor like this one, then there can be many prefixes. We want all possible prefixes that fit into these spots here, consider each one of those, and for each one of those consider adding on the suffixes. What I'm going to do is define a function, legal <u>prefix,</u> which gives me a description of the legal prefix that can occur at position i within a row. There are two possibilities. I could combine the possibilities into one, but I'm going to have a tuple of two values returned. I'm going to have legal<u>prefix return the actual prefix as a string</u> if there is one, like in this case, and return the maximum size otherwise. For this anchor here, this would be legal<u>prefix of one, two, three, four, five, six--</u> that's for legal<u>prefix when i = 6.</u> The result would be that there are now characters to the left. It'll be the empty string for the first element of the tuples. The maximum size of the prefix that I'm going to allow is two characters. Now, if I asked here--that's index number one, two, three, four, five, six, seven, eight, nine-- when i = 9, the result would be that the prefix is BE, and the maximum size is the same as the minimum size. It's the exact size of 2. I define legal<u>prefix in order to tell me what to do next based on the two types of anchors.</u> Now, I can go back to row plays. I can call legal<u>prefix, get my results, and say if there is a prefix,</u> then I want to add to the letters already on the board. Otherwise, I have an empty space to the left, and I want to go through all possible prefixes. Here's what we do if there is a prefix already there. Now we can calculate the start of our position. Remember a row play is going to return the starting location of the word. We can figure that out. It's the i position of the anchor minus the length of the prefix. In fact, let me go and change this comment here. I is not very descriptive. Let's just call that start. Now we know what the starting location is for the word. When we find any words we can return that. Then we go ahead and add suffixes. With the suffixes, some of the letters are going to come out of the hand. We're adding suffixes to the prefix that's already there on the board. Starting in the start location, going through the row, accumulating the results into the result set, and then I needed this one more argument. I actually made a mistake and left this out the first time, and it didn't work. We'll see in a bit what that's there for. Now if we have empty space to the left of the anchor, now we've got to go through all the possible prefixes, but we already wrote that function--find<u>prefixes. That's good.</u> Looks like we're converging. We're not writing that much new stuff. Now, out of all the possible prefixes for the hand, we only want to look at the ones that are less than or equal to the maximum size. If the prefix is too big, it won't fit into the empty spot. It will run into another word, and we don't want to allow that. We can calculate the start position again. Then we do the same thing. We add suffixes. What do we add them to? We'll the prefix that we just found from the hand. Since the prefix came from the hand, the remaining letters left in the hand we have to subtract out those prefix letters. Here we didn't have to subtract them out, because they prefix letters were already on the board. We're adding to the prefix from the start, from the row, results are accumulated, and we have this anchored equals false again. We're almost there. Just two things left to do--add<u>suffixes and legal<u>prefix.</u></u> Add<u>suffixes we had before, but it's going to be a little bit more complicated now,</u> because we're dealing with the anchors. Legal<u>prefix is just a matter of looking to the left and see how much space is there.</u> Here is legal prefix. It's pretty easy. Here's the answers of what they should be for each of these positions within a row. One more function to write--add_suffixes--and then we'll be done with this bird. We're given the start location. We recover the location in which we want to place the anchor letter, which is start at the start and then add in however much of the prefix we have. It could be the empty string. It could be more. If the prefix is already a word, then we want to add in a possible play. The play is starting in the start location we put in this word. But there is also this test. This test says we want to make sure that we've at least anchored the prefix. What does that mean? If we go back to our diagram, if we're right here, we get passed in to add_suffixes the prefix B-E--that is, in fact, a word. B-E is in our dictionary, but we wouldn't want to say the answer is B-E, because that's not a play. That was already on the board. We can't say our play is we're making this word that's already there. We've got to add at least one letter. That's why when we were defining row plays, we said we're adding suffixes, but we haven't anchored it yet. Anchored is equal to False. We haven't anchored our potential prefix so far so don't go reporting that prefix as a valid play. Now in the definition of add_suffixes, we say, okay, if it's the first time through, we're not anchored so we're not going return BE as a possible play, but when I do a recursive call to add_suffix, I'll just have the default value and anchor will be true. I will have played on the anchor, and then I'll be okay from then on. One additional test here is saying if there are existing letters already on the board, and you're bumping into them, then you have to count them. If there's a letter already there, don't report everything up to that letter. That's taken care of this case when we get up to this C, we can't like say put a T here and have B-E-T and report that by itself as a word, because the T is running into the C. We've got to continue and see what words can we have--we have to account this C here. Okay. That takes care of adding in the play. Whether or not we found a valid play to add to our list of results, we still want to say are we going to continue? Can we keep going to the right adding on more letters? Well if the pre we have so far is within the prefixes, then yes we do want to try to continue. What we'll do is say tell me what square is in the current position in the row. If it's a letter, try to add suffixes to that-- to the prefix we have so far plus the letter. If there is a letter already on the board, it's mandatory that we have to use it. Otherwise, if the square is empty, then we want to figure out what are all the possible letters that we could place into that empty square. If the square is an anchor, then the anchor will tell us what the possibilities are. Remember an anchor is a set of possible letters, so if the square is an anchor, let's use that as a set of possibilities. Otherwise, if the square is empty and it's not an anchor, then any letter is a possibility. Now we just go through the letters in our hand and say, if that letter is a possibility, then we want to add a new suffix by saying let's place that letter onto the prefix, remove the letter form our hand, and continue adding suffixes from there. When we're done that, return the results. That's it. Now we're done with that bird, but let's go back, look at our test routine. We had these tests for legal prefix. Now, if we go into our interpreter and we run row_plays with the given hand and the row-- that's this row where the hand is maybe ABCEHKN. This is the result we get. That's an awesome result. Look, we got the BACKBENCH that we saw before. We got all the smaller words. We can go through and we can check that each of these makes sense. They are the right ones. They don't run into any letters or do anything wrong. It's hard to check that we go all of them right, but we can still go ahead and make this an assertion. When we run this, all the tests pass and life is good. However, here's something that bothers me. In the definition of row_plays, we're calling find_prefixes of hand inside this loop where we're enumerating over the row, so it's going to happen multiple times. It's going to happen one time for every anchor. Eventually when we have multiple rows it's going to happen for every anchor on every row, but notice that find_prefixes only depends on the hand. It's not dependent on the row at all, so it seems wasteful to be recomputing find_prefixes of hand multiple times. If we were just dealing with row_plays, that would be easy enough. Up here we could say found prefixes equals find_prefixes of hand, assign it to a variable, and then just reference the variable down here. We'd be computing it once outside of the loop rather than many times inside the loop. Eventually, we're going to have a bigger function that calls row_plays once for each row, and we wouldn't want to have to compute that each time within row_plays. We want to compute it just once. We could pass into row_plays the set of prefixes, but that's just complicating the interface. I'd like to cut down on the computation without complicating the interface. In other words, I want find_prefixes, when you pass it a hand, if it hasn't seen the hand before, go ahead and compute all the prefixes. If it has seen the hand before, then I don't have to re-compute it. I'll just look it up and return it immediately. What I want you to do is take find_prefixes and make it more efficient. We could just slap a memo decorator on the front of find_prefixes, but that's probably not exactly what we want, because note that find_prefixes is recursive, though it's going to call itself on each subcomponent of the hand. Really, we want to say I only want to remember the top level hand. If I've seen that exact hand before, then give me the answer. Don't give me the answer for all the sub-parts of the hand. You could write a different decorator that works just on those parts, although that might be hard given that it's recursive, or you could modify the function itself, or you could have two levels of functions. One top-level function--find_prefixes--that calls another function recursively. Your choice as to how you want to handle it. However you handle it, the idea is that if you call find_prefixes with a certain hand and you get back this result, then if you make the same top-level call again, it should immediately return the same result that it saved away rather than trying to recompute it. Here's what I did. I introduced two global variables--the previous hand and previous results. I am making a cache, like a memoization cache, but it's only for one hand, because we're only dealing with one hand at a time. Then I say, we then find_prefixes if the hand that you were given is equal to the previous hand, then return the previous results. I'm only going to update the previous hand and the previous results in the case where the prefix is the empty string. And that's how I know I'm at the top level call when the prefix is the empty string. For all the recursive calls, the prefix will be something else. I'm only storing away the results when I'm at the top level call and I'm updating previous hand and previous results. With that, efficiency improvement to find prefixes, now when I do timedcalls of row plays for this fairly complex row, it's only about a thousandth of a second. If I had a complete board that was similarly complex and say fifteen rows or so in the board, then it'd still be around one or two hundredths of a second and that's pretty good performance. Now back to our diagram. Let's figure out where we are. We did row_plays, so I can check off that bird. What's left? Well, now I want to be able to do all the plays--all the plays in all the rows and all the columns. Another thing I want to be able to do is--notice that I cheated a little bit. I engaged in wishful thinking, which is always a good design strategy, in that when I called row_plays, I gave it a hand and a row, but I made the row myself-- built that sample row that I called a row by making a list and saying, okay, I know A is here, I know an anchor called MNX is here, and so on. I didn't have my program construct that row. All_plays is going to have to somehow do that type of construction. It's going to somehow have to set the anchors within the row rather than having me give them explicitly as test. Then just one more thing to deal with, which is scoring. After I've got all the plays, I want to be able to figure out how much each one scores and pick out the top-scoring play. I talked about pacing at the beginning of this. Now I'm starting to pick up the pace. I'm feeling pretty good now. I'm saying it was a long way, we had to run hard, but now I can start to see the finish line. We can put together one final sprint to get it all done. What do I want to do next? I want to handle complete boards, not just individual rows. Just as we did with rows where we made up a sample row, let's make a sample board. I define a function a_board, which returns a sample board. It's the same one we were dealing with here. Note that I'm making this a function rather than a variable definition. The reason I'm doing this is because every time I reference a_board I want to create a new one, and I want to create a new one, because I'm going to be modifying the old one. I'm going to be placing letters onto the board. I'm going to be inserting anchors into the board and modifying the board structure itself. I don't want to be dealing with the old one that I've already modified. I want to make sure I have a fresh one from scratch, and so Iâ€™m going to say the only way to access this is through the function. What it does is it takes these strings, maps list over each one. Rather than have this first row be a string, the first row will be then a list of characters. Same for all the other rows. There we can see when we call a_board we get this board, but that's not very pretty to look at. I'd rather look at something like this where here I've printed the results. Notice that I put spaces between each letter to make the board more square-like. What I'd like you to do is define a function show, which takes a board as input, print out the results, looking just like that, returns None as a value. Here's my answer--very simple--iterate over over the rows and over the squares in each row print one out. A comma at the end of the print statement says put in a space but not a new line. At the end of each row, that's where I put in a new line. Now let's do a little bit of planning. We did row plays. What is row play return? Well, it's a set of plays where each play is an i-word pair, where i is the index into the row where the word starts. We eventually want to get all plays. Before we can get there, I'm going to introduce another function called horizontal plays, which does row plays across all the possible rows, but only going in the across direction not in the down direction. That'll take a hand and a board as input. A board is just a list of rows. It'll return a set of plays where a play, like in a row play, is the position in the word except now the position is not going just to be i, the position is an i-j pair. It's going to be at this column in this row along with the word. It's a set of tuples that look like that. Let's define horizontal plays. Well, you know the drill by know--familiar structure. We start out with an empty set of results. We're going to build them up somehow and then get the results. Now, how are we going to do that? Let's enumerate over all the rows in the board. We just want the good ones--the one from 1 to -1. We don't want the rows at the top and the bottom, which are off the board or the border squares. For each good row, I'm going to write a function called set_anchors which takes the row and modifies that row and mutates the row to have all the anchors in it. Remember before when I called row plays I passed in manually all the anchors. Here, I'm going to have the program do it for me. Now, for each word, I want to find all the plays within that row and properly add them in to results. I want to do something with the row plays of hand within that row. And I want you to tell me what code should go here. It could be a single line or it could be a loop over the results that come back from row plays. Figure out what goes here so that it can return the proper results. Here is my answer, I call row plays on the row and that gives me a set of results which are of the form i--index into the row-- and a word, and I can't just add that into my results set, because that doesn't tell me what row number I'm in. Instead, I want to add the tuple i and j. I've already got the row number j. Add the tuple of the position i, j along with the word into the results. That's all we have to do. Okay. Back here, check off another bird. Just one left. Well, okay, I lied. It's not quite one left. There is also scoring we'll have to do next, but one left for this part. So all plays, like horizontal plays, takes a hand and the board. What should it return? Well, it's going to be a set, the position in which we start the word. Well, that can be the same as before, an i-j position is perfectly good. Now, we're also going to have some words going across and some words going down. Now, we want our results to be a three tuple. It's a set of an ij position followed by a direction--across or down, followed by a word, a set of those. Now onto the all_plays function--takes a hand in the board, it's going to return all plays in both directions on any square so the play is a position, direction, and a word where the position is an ij pair, j picked up row number, i the column number. Direction is either across or down, and those will just be global variables. We don't have to decide for now how to represent it. I used a trick here--I said all the horizontal plays, the cross plays, we get from calling horizontal plays directly on the hand in the board. The vertical plays--I didn't have to write a separate function. All I have to do is transpose the board--flop the i and the j, call horizontal plays on that, and that gives me a set of results, but they're the results in the wrong direction. They're ji pairs rather than ij pairs. Now your task is write the code to put that all together to take these two sets, one of them is in reversed order, so they have to be swapped around. Neither set has a direction associated with it. Assemble them all into the resulting set that should be returned by all plays. Here's my answer, so I took all the i, j, w pairs from the horizontal plays and just reassembled them with the i, j, putting in the indication that they're going in the across direction and keeping the same word. Then I do the same thing for the vertical plays. They came out in the j, i order. I reassembled them back in the proper i, j order with an indication that we are going in the down direction. And then I took these two sets and just unioned them together. Now, I need some definition for across and down. I can do it this way. I could have just used strings or any unique value that could use a string across and down, but I'm going to say that across is equal to incrementing one at a time in the i direction and zero in the j direction. Down is incrementing zero in the i direction and one in the j direction. We're almost there. Things are coming together very nicely. The only thing we're missing is set anchors. We have to somehow take a row and the row number within the board and figure out where all the anchors are and what the values of those anchors are. To find the anchors we can do that within the row. An anchor is something that's next to an existing letter. That will get most of the anchors but not quite all of them, because notice if we didn't have this row here, we wouldnâ€™t know that that spot is an anchor. To find all the anchors, we're going to have to look at all the rows or at least the two adjacent rows on either side. To find what the anchors are in terms of the set--can anything go there as in this anchor, as in this anchor, any letter can appear there, or is it a restricted set like this one. That we're also going to have to know--what are the other cross words? Here, if there's only a U there and nothing down below-- this is the edge of the board or there is empty stuff down below-- then this anchor can only be the letters that fit in there to make a word going in this direction. Let's dive right into defining set anchors. This is different than most of the functions written so far in that it actually mutates the row rather than returning a result. We start in the normal way. We're going to iterate over the row--the good parts of the row. Then what I'm going to do is take the i-j position on the board and find all the neighbors for that board-- that is all the squares in the in the north, south, east, and west location. Then I'm going to say what are the anchors? Well, if the square is the star, the starting square, then that's an anchor by definition. Otherwise, if the square is empty and any of the neighbors is a letter, then that's an anchor. Now, I've arranged that neighbors(board) is a function that returns the neighbors in this order-- north, south, east, and west--and now I'm saying we're operating on a row, if the neighbor to the north or the south is a letter, then we have a cross word that we have to deal with. If not, then it's an unrestricted anchor. What do I want to do if I have these crosswords? I want to find the crossword on the board. What does that mean? In this location right here, which would be row 2 and column 2, I want to say that the word on the board is an empty square followed by a U. If I go into the interpreter, I want to be able to have this interaction where here is my board. Now if I find crosswords within that board from position 2, 2--that's that position right there right after the A and above the U--what I want to say is that there is a word, and the word is a dot followed by a U--there it is. If we fill in that anchor, we're going to have a word, which is a dot followed by a U. Where does the word start? Well, it starts in position 2. It could have started someplace else. If we had a big board, there might have been a word that started all the way up here and went down. For example, we're not actually going to call findcrossword on positions that aren't anchors, but if we did, it would still work. If we find cross words from position 1, 2--that's the where the A is-- what's the cross word that intersects through that A? Well, that's JAG. It begins in row number 1. Now we're up here, we found the cross words, we found the row that the cross word begins in, we found what the word is, and now we're saying we're going to fill in this location. It's going to be an anchor. It's anchor where the letters are all the letters with which we can replace the dot in dot U and make something which is a word. We can go back to our interpreter and test that out. We can say if W is the dot U, then what is this anchor of all the letters where W replaced by a letter is in WORDS. That's the anchor with X, M, and N as possibilities. Now we're going to say insert that anchor into row[ i ]. Insert into this spot to the right of the A above the U the anchor that says an X, an M, or an N can occur right in that location. That's setting the anchor if there are cross letters above or below. Otherwise, we have an unrestricted anchor. For example, this anchor here to the left of the D--any letter can go in there. We've already defined the global variable any to be the anchor that allows any letter to occur. Sprinting to the finish line. We're almost there. Just a little bit left to go. Only one more slightly difficult part. Here is findcrossword, and because I can see the finish line, I'm not going to explain it line-by-line, but you go ahead and read it. Two other small bits--we need this list of neighbors in the north, south, east, west order, and we've got to be able to transpose a matrix. It turns out that one way to transpose a matrix is an old trick. You map list to the zip of the application of all the rows in the matrix. If that makes your head hurt, don't worry about it. You can play with it a little bit to see why it works or you could use this expression here-- [ M [ j ][ i ] ] for j in the range and for i in the range. Now I'm excited to see it work. I ran it. It did, in fact, work. Solidified the results by putting them into a test--examples of finding cross words, finding neighbors, transpose--that looks like it works. Transpose of a transpose--you get back what you started with. If we set anchors on our sample board--we get back the sample row that we did by hand. If we call horizontal plays, we get back this list now. I feel a little bit bad here that I wrote this as a test, and yet I can't really verify that this is exactly the right answer. I haven't gone through every word in the dictionary to figure out if I got this exactly right. This serves not so much as a unit test--a unit test is something that verifies that your function is doing the right thing-- rather this serves as a regression test. Regression test means that we're just testing it to see if we broke something. We want to get the same result this time as we got next time if we make a small change to our program. We can verify that this looks reasonable--that we got the big word we were looking for, BACKBENCH, other components of it like BENCH and then a bunch of three-letter words, which always show up in Scrabble. That was the horizontal plays. We can also do the all_plays. It's gratifying that all_plays is a bit longer. It's gratifying that BACKBENCH is still there, and when we run it, it passes. Bird-by-bird--we can check off one more. Now there is only one left--scoring. I could take the results from all plays, so each play is a triple of position, direction, and a word, and then I could add a score to those, but it seems like I'm just taking this lists apart and putting them back together so many time. I've already done it three times. I did a row play--took it apart, added it back in j for the horizontal plays, and took that apart, added back in a direction for all_plays. I could do that one more time to insert the score. Maybe that would've been the right choice. Maybe I just got fatigued, and I made a mistake in my design sense, but what I decided to do was modify my horizontal_plays and all_plays functions. There are two modifications. Here in horizontal_plays, after I got the play, I calculate a score, and then I insert that into my result. Now my results are no longer just position, word play--they're score, position, word play. Then I want to do the same thing in all_plays. I want to make my play be a score, position, direction, word tuple, and I'm just, as before, ripping these things apart and putting them back together. Now, remember the board. It's got these double letters, triple word scores, and so on. If you're old-school it looks like this. This is on a piece of cardboard that's a physical material. We've also written triple and double scores, so I need to come up with some ways of representing these spots on the board and how they're special. Now, could I squeeze it into my existing representation of a row? Remember a row is a list, and it can have things like that border is a string. Then we have a letter. Then we can have anchors like ANY. Could I have room for putting information about bonus squares on the board-- the double and triple letters? Could I have, say, 3W to mean triple-word score as an element of this row? I guess my intuition is I don't think that's going to work very well. The problem is one of these squares--say this one-- could be both an anchor and a triple-word score. So we'd need some representation that allowed both of those. That just doesn't seem to be easy to extend what I already have. Let's not override our row notation. Our rows, as we have it--I'm pretty happy with them. I'm not going to allow this. I'm going to keep row exactly as they are. I'm going to introduce another data structure--a parallel board, I'm going to have two boards. One board that I play on and another board that holds the bonuses. Think of it as two layers. One representation of a two-dimensional matrix just holds these double words and triple letters scores and so on, and then on top of that there's a second two-dimensional array that holds the values of the letters and also holds the anchors. Oh, I got a good score. Now I'm going to have board[ j ][ i ] will hold the letter or anchor, and then bonus[ j ][ i ] will hold corresponding bonus-- a double word, a triple letter, or just nothing. Now, just to give you a review of scoring if you aren't familiar with the rules. The letters score their value--the number that's on them--times whatever you've placed them on if that's a double or triple letter score. Here I don't have any double or triple letter scores, so I get the individual values of the letters-- 10, 11, 12, 22--times the total word multiplier, and the pink square are double word scores, so that's a double multiplier--22 times 2 is 44 points for that. Then if the next play goes here, it has to connect. Now, this was a double word, but I don't get any double, because I didn't actually place a new tile over an existing double word, so nothing is doubled, but I do get credit for the Z, even though I didn't place the Z. I get credit for that as 10, not as 20 as it originally scored, but as its face value-- 10 plus 1--this is a triple 1, so that's plus 3 plus 1--10, 11, 14, 15. Then if the next play, say, was here, that would just a score 3, 4, 5. I didn't have any bonuses whatsoever. This bonus here doesn't count, because I didn't play over it. If a bonus is already covered up, it doesn't county any more, so this would just be 5. One more scoring rule. If this is the word on the board--great play putting the Q on a double letter and a double word as well--this would score 20--1, 2, 3, 4 times 2 is 48. The next play could be this, which simultaneously forms 3 words-- NO in this direction and then IN and NO in this direction. For NO, we'd get a double letter is 2 plus 1 is 3. For IN, we get just 1 plus 1, so that's 3 plus 2 is 5. And for NO we get another 3, so that would be a score of 8 altogether. Here is calculate_score. It takes all these variables that we need to specify the play. We're going to start out a total of my word multiplier-- that is, have I got any double or triple letters, and there might be more than one of them. If I had a long word that matches up with some existing letters on the board, then I'd get credit, and if. I covered a double and a triple letter, then I'd multiply by 6 I need to keep track of that. Then I also want to keep track of the cross word totals. Not the word I'm playing but the other cross words, but they are separate from this word multiplier. Figure out where my starting position is from that position. Figure out the direction that I'm moving in--down or across--what the delta are. Figure out what the other direction is. If I'm moving in the cross direction, I want to know that the other direction is the down direction. Now just enumerate the words. Enumerate the letters in the word and the position within the word. Figure out the square on the board and the bonus squares, the word multiplier, if the square was already placed on the board, so if it is a letter--and I've got a function for that. I should be defining this here, so this is a bad piece code. I should be calling is_letter(sq) rather than testing directly, since is decided to make that more abstract. Figure out the word multiplier from the bonuses. You only get the bonus if the letter wasn't already on the board. Figure out the letter multipler--same thing. Increment my points by the points from the letter times the letter multiplier, and now if the square is an anchor and the anchor is not one of these unrestricted anchors, then we want to look for the cross words. If there is a cross word, figure out the cross word score and add that into the total. Why do I have this direction is not down here? Because I'm going to do--cross word score is going to recursively calculate score, and we don't want it to recurse infinitely. We just want it to recurse once. To explain that a little bit more, note up here in horizontal_plays we're calling calculate _score, so the only place we call calculate_score is here, and we're calling it with the across. The way we get the down is because we transpose the board. So for calculate score, we know we're going to be called with the across direction the first time and then the down direction the second time. Although, I guess I feel a little bit bad that that assumption that we're always going to be called with across the first time is kind of hardwired into this. That makes calculate_score a little bit brittle. Probably, I should refactor this to stop the recursion in some other way. But I'm so close to the finish line now I don't want to stop to clean things up. I want to get to the end. Here is crosswordscore. Figure out the position. We find the cross word. That's a function we already wrote. Then we recursively call calculate_score. Now all that's left is to set up this matrix bonus, say where the double and triple bonuses are. Here's what I've done. I've just drawn a picture of the bonus and I called it the bonus_template. But I only drew one quadrant, one quarter of the board, because I noticed that they were all symmetric and so this function bonus_template takes a quadrant in terms of a string, mirrors each rows and then mirrors each set of rows, where mirror of a sequence is just sequence plus the rest of the sequence except for the last one, so there's going to be a middle piece that we'll reflect it around. I made one template for the Scrabble game and one for the Words With Friends game, and then you choose which bonus you want to use, and then I defined these constants for double words, triple words, double letters, and triple letters, and I wasn't quite sure what to use. I know I didn't want to use letters like d and t because I'd get confused with the letters in the hand. I used 2 and 3 for double and triple words, a colon because it has 2 dots for double letters, and a semicolon because it's a little bit bigger than a colon for triple letters. Even though we're so close to the end, it's still good hygiene to write tests, so I took some time to write some, ran them, all the tests pass. You can see here's a tiny little bonus template--a quarter of an array, which looks like that. When you apply bonus_template to it, you get this nice symmetric array. Now what I'd like you to do is modify the show(board) function so that it prints out these bonus entries so that if there's no letter over this 3 in the corner it should print the 3 rather than just printing a dot. Here's my solution--I capture the j and i coordinates by using the enumerate function. I print the square if it's a letter or if it's the border that's off the square. Otherwise, I just print the bonus. Now, one thing I like to be able to do is when I get a play, I want to be able to actually modify the board to indicate what that play is. I want you to write a function to do that for me. It takes a play, but remember a play is tuple of a score, a start position indicated by i, n, j, a direction indicating by delta i and delta j, and the actual word, a string. Let's make this look a little bit better by making it be a tuple. Write the code that will modify the board and in addition to modifying it, let's also return the board Here's my answer--I just enumerated the letters in the word and the position into the word, updated the board, marching down from the start position j, i, and multiplying n, the position into the word, by the deltas specified by the direction. Now, very exciting. We're at the culmination. One more function to write. That's the best play. Given a hand and a board, return the highest scoring play. If there are no plays at all, just return None. Here's my answer. We got all the pieces. We call all plays. We get back. There is a collection of plays. We sort them and take the last one--that'll be the highest. We don't even have to specify what to sort by, because of the score was the first element of the play, so we're automatically sorting by that, and then return the best one if there are any plays otherwise. Otherwise, then I specified no play here in case I change my mind, but I can say no play equals None. Now, I could write something that plays a complete game, but instead I'm just going to have a simple function show<u>best,</u> which takes a hand and a board, displays the current board, and then displays the best play. When I type it in to the interpreter, this is what I get. It found the backbench that we had sort of laid out there, scored 64 points, and out of all the possible plays, it found the optimal one. So, we did it. We made it all the way through. Congratulations. [Rob Pike, Google Engineer:] There is a standard problem, especially when you're learning to program. You have a piece of code on the page, and it doesn't work. You read it and you study it and you don't see what's wrong. Then it often helps in practice to just explain the code to somebody else. Sometimes just hearing yourself say it out loud you'll go, oh, I know what I did wrong-- just explaining what's not working or why. It's such a common technique that there's a--I think it was a computer center at one of the universities--they had a teddy bear on the desk at the help desk. Before you were allowed to talk to an actual person, you had to explain your problem to the teddy bear, because chances were just saying it out loud to the teddy bear would show you what was wrong with your program. [Niniane Wang, CTO, Minted:] The more you like something, the more you'll naturally want to do it. I would say do not force yourself to do something, because other people are doing it. If everyone or if a bunch of people are talking about mobile programming or functional programming or functional programming languages or Lisp or front-end programming, if you try it and you don't like it, you should not try to force yourself to do that. [Sally Goldman, Professor, Washington Univ:] In the end, good code is code that other people can come and change and adapt. [Learning to Program] [Guido van Rossum, Author Python language:] I wasn't quite that ambitious. I initially just thought that I need another programming language. I definitely meant it to be a general purpose language. ABC actually sort of had multiple philosophies. It wanted to be easy to teach and easy to learn, but it also wanted to be a language that was useful for just slightly non-professional computer users. I just liked a lot of thing is the ABC language as a professional programmer. I started copying those ideas and sort of changing them, mutating the ideas and the details of the language of the implementation. [Alex Martelli, Tech Lead, Google:] Back when I joined it was the 1.52 version, so it had been already growing pretty pragmatically for a while. It was still in a phase of a tumult of new ideas and a general attitude in this small group of core committers of, hey, one more feature--how could it hurt? At some point, essentially moving towards the 2.0 release, a sobering sense that Python wasn't a toy language used by people for their own fun anymore. It was starting to become the material to build in very complex, important software system. In the process of designing Python 3, we did actually--as the core Python developer group-- we did a lot of soul-searching and thinking about which parts of the language and which parts of the library can we improve. Using def to introduce a function--what does this mean? Define? Define what? Unfortunately, I have to admit that JavaScript has it right here. The proper keyword to introduce a function is "function." Why use--to save four letters? That's not the Python spirit. Hi. Welcome back and congratulations! We've made it all the way to Week 7. We've done a lot along the way, and this week's going to be a little bit different. First and most important. We have the final exam. There's a bunch of programming problems for you, and you'll see those. There won't be any video associated with it--just the questions, so work on those. I think you'll have fund doing them, and I think you'll be able to handle them all. In addition to that, I didn't want to have any extra-heavy materials, because you're going to have plenty of work on the final exam. Instead, we're going to take some field trips. We're going to go visit with some friends and colleagues of mine who are experts in computer science who use programming everyday and have their own views on what the process of computer program design is like. I think you'll enjoy talking with them. Come on with us. Hey, welcome back. I'm very happy to be here today with Sally Goldman. Sally is a professor at Washington University and is also a researcher at Google. We'd like to talk mostly about the process of choosing the right algorithm and data structure and how your programs are so much tied to that choice. [Sally Goldman, Professor, Washington Univ.]The big picture, I think, in terms of what we focused in the book is if I'm looking at a data structure for a problem, there are broad classes of data structures. Some data structures are very good just searching something with a unique ID. Other things may be good at finding--like I want to find if the word CAT, that substring, is part of a word, and so there's this broad class of data structures. Really, the encapsulation is as important as to understand these abstract data types or ADTs and understand which one of those fits your problem, because that is a fundamental decision, and there is fewer of them so it's easier. First of all, an invariant is something typically about your data that holds all the time. If I have something called search_tree, I may say that if I'm at a certain node everything on the left half is smaller and everything on the right half is bigger. Again, I think it helps just in understand and designing the data structure to remember the this is an important thing and I need to make sure that all the methods and all the operations I do preserve this. In that particular case, it allows me to search quickly. Without that invariant, I'd lose it, but at the same time it lets you formally prove correctness. It's a pretty good dual. I think it helps you reason about it informally and let's you formally, in fact, prove that you haven't forgotten any cases. How do you know you have the right answer? Certainly it's good to prove you're always going to have the right answer, but that proof is about the technique that you created. It doesn't say that your code is right. I think you actually want to prove rather informally at least that you're going to always have the right answer, but you need tests. Without unit tests bug will creep in. The book we wrote we have a couple thousand unit tests, and I'll tell you there are times in the end I'm like, oh, I can make this a little simpler. I didn't need this case, and all the unit tests start going red. Then I'd put a sentence about why you needed it. I think you actually need testing in the code to make sure the code actually really implemented what you intended and testing at the algorithmic level. Looking at the difference in dealing with algorithmic complexity, making sure you actually cover all the cases of the input, and dealing with the complexity of the code and different operating systems, different windows. Yeah, it's tricky and also everyone wants to try out different things, and so you have these different variations and the code gets a lot of cruft built into it that kind of can get it out of hand. I think that industry code is also important to keep that in check. What makes for good code? Clean--it should be fairly modular. You don't want the two-page method. You definitely want to make sure that commonly used blocks are reused and have some documentation on the methods whether in a separate file like if it's a C++ with an H file or something where it's all together. You definitely want to really say what the method is doing. In the end good code is code that other people can come and change and adapt. I studied computer science at Caltech, and then I worked at Microsoft. Then I went to Google. At Google I worked on Desktop and Gmail. I started Lively, and then after Google I started Sunfire, which is a coworking space. Then I can fell in love with Minted. Minted is a startup. We crowdsource graphic design and art from a community all over the world. Then other people can customize and purchase that. I actually started programming BASIC when I was five, but I didn't actually know what I was doing My parents bought this Radio Shack gaming device, because it was cheaper than other devices, and then there was a BASIC emulator. I would write programs. It came with a book of programs. We actually did not buy a memory cartridge, so I would retype every program every time I wanted to enter it. Then eventually I would start modifying it a little bit. Some people start later but are very addicted and spend lots of time thinking about i or playing with programs. Then if you start later but spend more time it's the same. As a woman, you understand the psychology of a very powerful consumer in the market, but who is underrepresented in the people creating products, which is a very powerful position. For example, at Minted our demographic is women, and that means that we are serving this very under-served market that has a lot of spending power. More money is spent by female consumers than by male consumers. We primarily look for people who are strong programmers, so people who like to build consumer websites and preferably who have done that before whether it's for other companies, for classroom projects, or for open source or personal project, people who have worked with object-oriented programming. We happen to use Python, and then on the front end we use JavaScript and jQuery. But anybody who has worked with either object-oriented programming or who has built consumer websites would be great. Hi. Welcome back. I'm here with Joshua Bloch. Josh is a leading textbook author, Effective Java, a book on concurrency in Java, a devilish book on Java puzzlers, and was one of the leaders who brought Java to us and worked on the early APIs, including the collections class and so on. What was that process like? [Josh Bloch, Google Engineer:] I as in the right place at the right time, and I have always enjoyed APIs have kind of been the recurrent theme of the past 20 years, but I used to write them for 10 or 15 people. All of a sudden I was writing them for millions of people. It was chaotic. That's the way the internet was back in those days. Type systems should exist to serve the programmer and not vice versa. If you find yourself constantly fighting with the type system, writing a program that won't compile, and just spend lots of time jamming the thing through the compiler, and it wears you out. You don't really gain any insight in the process-- then there's something wrong with the type system, and I believe that Java's wildcards have that problem. In the case of Java, you've got an existing language that was designed around storing static typing, and if you try to put dynamic stuff into it, there's a little bit of an impedance mismatch. Things that are added to languages after the fact tend not to reside comfortably in the language. When languages grow too much and stray too far from their roots, you generally end up with big messes. Now, we talked about reliability of algorithms. You did a blog post about a bug in a decades old algorithm on binary search. What happened there? That was a an amazing story. I was at Carnegie Mellon University for 1982 to 1990 or so, and when I'd first arrived I took a PhD-level algorithms course from John Bentley, who was a brilliant and funny, and he started out by asking us all, "How many of you know how to write binary search?" We all raised our hands We were hot shot computer scientists. We got our bachelor's and we felt we knew what we were doing. He said, "Okay. Fine. Take out a piece of paper and write it. You've got 10 minutes, and then we'll talk." Ten minutes later, he said, "Okay. Who got it right?" Everybody raised their hand. He picks one person and says, "Put your algorithm on the board." The person does, and he tears it apart. Of course, the person had not gotten it right. It was broken. The point of his lecture was that you need to use invariants in your code. In particular, in binary search the invariants are tricky, and if you donâ€™t think in terms of invariants, you'll get it wrong. Language design is always going to be an aesthetic exercise. You need good taste if you're going to do it, and you're operating partially from the gut. Empiricism is one important part of what you're doing, but if something feels wrong or feels ugly then it's probably a bad idea. There are some people who are really good at doing the aesthetic stuff and at sort of placing themselves in the shoes of the programmer and saying, yes, this'll feel right. Other people can't do that, but they're really good at looking at a grammar and saying, "I'm afraid that you're going to end up with an ambiguity here, if not now when we add these other features that we intend to add." The point is empiricism is great. I would even say it's necessary now, but it's not sufficient. It's out pleasure to be here today with Guido van Rossum, inventor of the Python programming language. [Guido van Rossum, Author, Python Language:] I stayed relatively close the ABC, and ABC's ideals just sort of naturally lead to a language that is easy to teach. I was in a situation where my two choice were on one hand Shell, which is easy and nice for simple scripts, but sort of limited if you want to do anything complex, especially in those days when it was like well before Bash, the original Bourne shell that I mostly had to deal with. Then on the other hand, the C language, which you can use to do anything you want, including implementing your own programming language, but it all takes a lot of effort and it's easy to make mistakes that only sort of come out much later after you've already implemented a lot of code. You'll realize, oh, I should've used a different kind of data structure and start over from scratch. That original computer programming for everybody idea, in part was just a ploy to get funding from certain corners--if I may admit to that. One of the reasons that in the end note much happened was that the funding turned out to be much harder to obtain than just writing a proposal and winning some contests, which we all did successfully, and then getting the funding turned out to be still an impossible hurdle. I know plenty of teachers who have been teaching Python to high school students at some level. I heard recently that somewhere in England there is a national initiative that is at least considering-- I don't know how much that actually became a definite plan to teach Python to all high school students there, which is a great idea-- a wonderful experiment, and no matter what the outcome, a lot will be learned from that experiment. We’re here at the office of Alex Martelli the well-known Python programmer and author. Let’s go in and talk to Alex. In traditional Python the type while – type is strongly connected to an object. An object’s type is absolutely crucial to that object but it’s not connected to the name. A name, a variable if you want to call it that I would prefer to use the word name can indicate any object whatsoever. There is no constraint, a name is name is a name. Well if it quacks like a duck and walks like a duck, it’s a duck. Turns out – it was discovered a few years later that there is actually a bird, which while it does like – is more fologically indistinguishable from a duck but it’s DNA analysis prove it’s a goose. So well, but the point is that if you were a chef needed to decide how to cook it you probably want to use duck recipes because it doesn’t have the amount of fat of the goose so they don't really care about the DNA. So, instead of checking the type of an object, the concept was just make sure it has the methods with the signatures that you need, which you can do simply by trying and that leaves us to being easier to ask for giving some permission, you try literally within a try statement and if the signature is wrong, or the name of the method is wrong, you get a attributor type error and catch it in an x.f. clause and either propagate the error or handle it appropriately. Now, with the introduction of abstract-based classes, the type becomes useful because it’s not anymore a type in the sense of an implementation. It’s a type in the sense of an abstraction. So, for example, there is a numbers abstract base class and if you want to verify that your argument is a number, actually asking if it is an instance of number, it doesn’t constraint at all the implementation, internally the implementation of unbounded procedure, an integer versus a 32-bit flow which is going to be drastically different, but they are both numbers, meaning they both have greater than, less than, plus, minus, times, and so on, so that kind of type check is now respectable in Python. Not anything concrete but checked for the abstraction that’s – it’s duck-typed constraint, if you will. If it is a number then you’re guaranteed of all a set of methods, operators and signatures that you don’t have to check separately, so look at it as a bundle of search operations. Welcome to the first office hours. Peter and I are going to be answering your questions. Well, Peter will be answering the question. I'll be asking the questions every week. We're going to take the questions that you ask in the forums. So far we've seen a lot of really good stuff, so I hope in the weeks to come you guys keep coming to the forums and keep asking such great questions. The first question comes from Prajeet, and he's a high school student who actually lives in the Silicon Valley area. He wants to know when you're about to tackle a new problem how much research do you do? Do you look for methods that have already been written or do you generally just write these tools yourself? And how do you balance that trade off of research time versus time spent writing? That's a great question Prajeet. An important part of being a programmer is knowing what you should do yourself and what you should take advantage of what other people have already done. I like to think of at two levels. One is the low level tools--the built-in functions and data types like strings and sets and dictionaries that are part of Python. There you've just got to learn what's available and keep on learning and reminding yourself of exactly what all the functionality is. The core functionality, how you access the nth element of a list, that you're going to know by heart pretty soon. But there's lots of individual methods, like how you count up how many items are in a list and so on. You may not remember all those, so you'll be looking at the documentation constantly, looking things up, and saying what methods are available on this type. And then the second part is for much larger pieces of code. Say you want a web server or you want to be able to parse and respond to email. Those are the types of things where you expect, hey, somebody else has done that before. That's a big job. I probably don't have to do it. Then you start research, and you find the right module that implements what you need. Programming is always this combination of what you have to do yourself and what do you find that people have already done that you can incorporate into your solution. Mark Sanders asks the next question. He had some concerns with the difficulty level of the class, particularly in the solution videos. Often he'll write some code that maybe solved it one way and he finds that your solution maybe involves functions that he's never seen before. What do you have to say to students who are experiencing this kind of thing. Mark, thanks for that question, and I know other people in the forums had similar types of questions and what I want to say to you is everyone chill out. You've all got this. If you've made it through CS101, you know everything you need to know to answer all the problems in this class. Now, I think that there's this misperception that-- and maybe this is sort of the way school has traditionally been done-- that students think that there is one correct answer, and you're measured by how close you come to the teacher's answer. In this class, that's not the way things work at all. In this class, what I'm trying to get you to do is to grapple with a problem, come up with a solution and then analyze alternatives for how it might be done differently. If you have the problem and you come up with a solution and it solves the problem, then you've got it. That's 100% correct. Pat yourself on the back. Don't worry about how anybody else solved it. You did the job, and I know you can do it. You've got all the background you need--full stop. Now, after you've done, now it's time to introspect a little. I'll talk about the way I did it, and my way of doing it might be different than yours. If you think my way is interesting or has something novel to show that you didn't think of before, then you could say, hah, maybe next time I'll do it that way. But that doesn't take away from your solution. Your solution is still fine, but now you've learned a new trick, a new tool to add to your arsenal that maybe next time you can use. I'll let you in on a secret. Every advanced feature that's in a programming language is there because somebody suffered in the past. Somebody tried to write it out the long way, and it took a really long time, and they said, gee, there's got to be a better way, and then we put the better way into the language. You've got to understand why this is in the language. Now, if I just told you ahead of time, "Here's a new feature. This is part of the language," you wouldn't get it to the degree you would if you see why it's there because you suffered without it. That's the way this course works, and I know it might be different from what you were used to before where you're spoon fed everything you need to know ahead of time. Maybe that's how school works in some cases, but it's not how the real world works. So don't get frustrated. That's the way the class is supposed to work. If you have a solution that works, no matter how you did it, then that's fine. That's perfect. That's 100% correct solution. Then after that you can start learning about alternative ways to do it. Thanks. Serge had a question about how to value, I guess, the clarity of a certain solution or the beauty of a certain solution. How do you, when you're presented with two choices for code, both equally correct and even equally efficient, how do you evaluate which one is better than the other? Great question, Serge. You're right. The first thing you want to think about is have I solved the problem? Do I have it correct? Once you do, then efficiency is another issue. Sometimes efficiency is important. For a lot of the types of problems that we're dealing with efficiency is not important, because all the solutions will be fast enough, but I think that's a minor part of the conversation. The more important part of the conversation is the one you're having with programmers. That's other programmers who are reading your code and with yourself as you start developing and working with your code over time. You want to hold up your end of the conversation. You want to have it be clear, express exactly what you mean to say, and have that all work out. One of the the rules I use is we're all good and communicating in English, or in our native language whatever it is, so if the code can look like that then we know we're going to be successful in our communication. We talk about what's the best poker hand. Well, the best poker hand is the one that's the maximum according to the hand rank. To the extent in which I can write my code to sound exactly like that English sentence, then I think that that code is clear. There's a one-to-one mapping between the English description and the code description. Now, Serge, you mentioned length. The length of a conversation can help clarity of communication or it can hurt it. If I go on and talk and talk and talk and talk, and you start to get bored, then I failed in my communication. Having a program that's too long can be a problem. Similarly, if you ask me a complicated question, and I give you a two-word answer, I may have failed to communicate then. I may not have given you enough context so that you understand my answer, even if my answer was technically correct. A program can fail to communicate because it's too short as well. You've got to learn to have good taste, to say, yes, for my audience this is the right length, this speaks to them and tells them all they need to know with just the right amount of context to get it right. Clair Dunn had a question, and she is interested in this top-down problem solving approach that we used in unit one. What I mean by that is we're often defining functions, even pretending to use, functions that don't exist. When you defined the poker function, you referenced the hand-rank function, even though we haven't written that yet. What can you say about the advantages of this approach to problem-solving versus the bottom-up approach where we would first build up all the pieces and then use those pieces in the poker function. We know when we're finished with our program we've got a complete structure. It's got a top and a bottom. There's a top level function that you call, and then that's going to call subroutines. That's why they're called subroutines, because they're below. They've all got to work in order for your program to work. Now the question is in what order do you address them? I think a lot of that depends on the domain and depends on where you're clear and where you're uncertainty is. If we have a description of the domain that we understand, then it makes a lot of sense to start from the top. I gave the example of saying what's the best poker hand. It's the one that has the maximum hand rank, and that's a high level statement. It assumes that we know how to rank a hand. I think that's quite a reasonable assumption. If you don't understand what's going on, then sometimes it makes more sense just to start down at the bottom and build your way up, to say what are the pieces of the domain and how do they fit together? Let me play with them a little bit, and then I'll think of a good way to put them together. You can go in both directions, top down and bottom up. It depends on your current state of understanding, but I think the key here-- maybe that Clair wasn't used to--is never be afraid to engage in wishful thinking, to say if only I had a function that did the right thing. Then I could proceed. You should always be willing to proceed that way. One last question. You were once a student of computer science yourself. I'm sure there were methods that were helpful for you in learning how to code. What kind of advice can you give to current students of computer science? I should I think you guys are doing great, and it's so much easier for you than it was for me when I was learning. Part of the reason for is that so much is more accessible now. I started before there was an internet, so you couldn't just do a Google search and find results. Secondly, I didn't own a computer. Those were big, expensive things that individuals didn't own. So you had to go to the computer center and use the machines that were there. It was just inconvenient and hard to do that. Now, one of the good advantages of doing that was that meant I was in the same room with other people. You got a chance to talk with your colleagues and friends and learn from them. I would encourage you to keep doing that, to keep finding other people to bounce ideas off of and learning from them. But then you're in such a great position now to learn so much more quickly. >From what I've seen from briefly observing 101 and from what I've seen in this class, you guys are off to a great start. It took me years to get to the level where you guys are just starting out. Keep it up. Thanks for the answer, and thank you all for the great questions. We'll see you again next week. Hi. Welcome to the second office hours. Again we had a lot of really good questions in the forum, so let's get started. The first question came from Matthew Atkinson. He has heard that you shouldn't use functions like eval and exec, which we did use in unit 2. He wants to know why shouldn't we be using these functions, and what's the problem with them. That's a great question. There's a couple reason to avoid these. On is for security, especially if you're going to be evaling a string that somebody passes in to you, you don't know what it's going to be doing. There are lots of dangerous commands that Python can execute like "delete all my files." You don't want to be asking somebody to type something in and then go execute that and allow them to do something dangerous. That's one reason. The other is just in terms of program structure. We like to write our programs so that the functions and variables and so on, have a set scope. This variable exists from here to here, and eval kind of breaks all that structure and goes outside of it and say now we're executing something right here, but it's not executing with respect to where we are in the code. It's executing someplace complete different. That makes it harder to follow the code. There's nothing wrong in terms of do you get the right answer but harder to understand. So we should minimize it. I used it in the assignment for week 2, because there was no other way to easily get around it. But you should minimize the use. Thanks. The next question comes from Sasheen. Sasheen want's to know a little bit more about this big-O notation that we introduced and saw a little bit of in Unit 2. Yeah. The answer to that question is a whole course in algorithms. We can't do that right here. But basically the idea is big O says approximately how many instructions is it going to take to execute this. Actually, big O is an upper bound on that. There's another notation less widely used with big theta which gives a more exact bound, but the idea is if I have a doubly nested loop that says for i = 1-n and then inside of that is nest for j = 1-n then that's the order n-squared, because we're going to n * n executions of the inner loop. The basic idea is that's more than if we were just doing what are n executions of the loop. So if you can get away with a single loop instead of a double loop, that's better. That's really all you need to know about big O. Alright. I should say there will be an algorithms class sometime in the near future for those of you who want to learn more about this. Thomas Grace had a question about these attributes you use--function attributes-- specifically in the C function that had c.starts and c.items. What's going on there? So Dave Evans in CS101 chose not to really focus on Python classes, which is probably a good choice, because it's a big topic. The idea here is that classes of objects can have attributes. These are parts or components of the object, and they're named with this dot-notation--object, dot, then the name of a field that's a component of that object. In most languages you define all the fields ahead of time. When you define what a class looks like, you say these are the fields that compose this object. Python is a more dynamic language, and some classes of objects you're allowed to add fields to them as you go, and functions are one of those types of dynamic objects where you can at any you say I want to add a new attribute to this function. Other objects have that same approach where you can add to it. And so what was going on in the C function is that I needed two variables that I wanted to keep track of something. I needed two counters. I could have just used a global variable name, but that would be cluttering up the name space. There'd be no way for you to, if I just made up a name like cstarts and citems-- by looking at the name of the variable you could figure out that they were related-- but there'd be no structural way to say that these are all related. They belong together. You want to minimize the number of global variables, because people's memories are small. By putting everything into one object, we say this belongs together. Using c.start rather than a variable named cstart is a way of structuring things together. In Python you can do that automatically. You don't have to have a declaration. You can just say I want to add a new attribute to a function, and you go ahead and assign it. Great. I had no idea you could do that either. I was very excited to see that. Yeah. If you come from a language like Java or C, you're not used to that. There you've got to declare ahead of time what your attributes are going to be. Right. Next question comes from Tracy Zelman, and she just wants to hear a little bit about when do we use lambdas. How do you decide when to use a normal function versus lambda. All a lambda is is a function definition without assigning a name to it. In a normal function definition we say "def", then we say the function name, the arguments, and the body of the function. We're simultaneously doing two things. We're defining what the function does, and we're giving it a name. Now, what a lambda does is break those out to say we're defining a function, but we're not giving it a name. Why would you want to do that? Well, we do it all the time. If we have an expression--like say we have the arithmetic expression x + 1 * x - 1, we didn't both to give names to those subcomponents--the x + 1 and the x - 1. We just wrote them down. So a lambda is like that. It's a function that's a small thing. We didn't want to bother giving it a name. We just wanted to use it in place. So that's the advantage of lambda that you aren't bothered with a name, and you can just write it right there without having to define it at one point and then use it at a second point. That's the good thing about it. The bad thing about it is that it's limited. In Python lambda can only have an expression. It can't have statements in it, and it just doesn't really fit with the rest of the language. Some languages are really designed around expressions like that, and they go really well. In Python it doesn't fit that much. I think mostly you should avoid it and just define a function with its name in the normal way, but sometimes it's really convenient to put everything in one place rather than having to define in one place and use in a second place. Great. Udacer had some questions about the program design strategy that we've been using. Namely, should we implement the strategy that we've been using in every single problem we approach? Is there somewhere we don't really need it? If we chose not to use the strategy, what are some of the disadvantages? Well, whatever you can do to get your job done, go ahead and do it. I've given you some approaches. I wouldn't say that there is just one strategy, but rather there is a collection of strategies that you want to be able to understand what's going on, make your inventory of concepts, build those up. You have a lot of choices within that. Do I want to start top down, bottom up, middle out? That's all up to you. As long as you arrive at the end of a description of the whole domain, and the whole program and you get it right, then congratulations to you. I think every body develops their own style for how they go about addressing this, but there are ideas of what it means to have a high-quality program-- correctness, efficiency, and so on. Then more driven by taste is what does it mean to be readable and extensible. You'll learn that over time. Great. For one last question, Takanzi wants to know if you have any good recommendations for computer science, and specifically Python, books. Oh, books. Okay. Yes, I do have some recommendations. If you search for Peter Norvig's library in Google Books, I have some there. With this question maybe I'll go and update them some more. I can mention a few. In terms of general programming books, I really like The Practice of Programming. I like The Elements of Programming Style, which is rather an old and somewhat dated book now in terms of the examples it uses, but still really up-to-date in terms of the advice. I like Structure and Interpretation of Computer Programs, which has been a standard textbook for introductory computer science. I like Programming Pearls is a nice collection of short essays. Then in Python books, there's a lot of them, and I haven't kept up with all the possibilities. There's a nice online book of How To Think Like a Computer Scientist that has a Python version. There's Python in a Nutshell, Python Cookbook, Learning Python. Headfirst Python, I think, is an interesting, somewhat different approach. There are a lot of them there, and I'll try to update my Google Books library to give a little bit of commentary on each one. Thank you. Thank you for all the question. Thank you for your answer. Stay tuned for the next unit, which will be posted on Sunday and also for a couple more editions to the Python glossary. All right. See you in class. Hi, and welcome to the third office hours. We've got, again, more good questions. Let's get right at them. &gt;&gt;All right. The first one comes from Voythos, and Voythos is taking CS262 as well with Wes Weimer. In that class they talked about finding state machines as a representation of the underlying engine for regular expressions. In our implementation, is that actually what we did or did we do something different? That's a great question. We didn't explicitly show that, but there is a one-to-one correspondence between a regular expression and a finite state machine. And we can post some references, some supplementary material for that. But you can make up a little table of here is a regular expression-- say the alt regular expression, a or b--and then here's a finite state machine. I guess one way to implement that would be you'd have a start state, you'd have two epsilon transitions to the a or b, and then two epsilon transitions coming back. So any regular expression corresponds one-to-one to a little collection of nodes in the finite state machine. That means you can go in either direction. Does that mean that we've actually implemented that? Well, it kind of depends on how you look at it. Yes, you could say that we've implemented it, because you can show what they look like, but we aren't really creating objects that correspond to these individual states. They're sort of existing ephemerally when we execute the program rather than being defined exactly ahead of time. In that sense, no. I guess, maybe in the more important sense, the types of manipulations we can do with what we implemented are slightly different than what you would do if you explicitly created these finite state machines-- particularly this transition between deterministic and nondeterministic machines. That's a little hard to do exactly in the representation that we had, although you could do something very much like it by starting to memoize your functions and so on. You could arrive at the same place as you would by doing that transition with machines. Great. If you want an in depth discussion on finite state machines, you can check out the link below this video to Wes's course. The next question comes from Luca. Luca wants to know when work with a compiler is really, really heavy and you have a really long regular expression, is there any way of dumping out the final set of these low level machine instructions so they can be culled later. Yep. Okay. That's a great question. A couple answers to that. One is that within the regular expression module, the re module in Python, there is a compile statement that takes a string in and returns a compiled version of that regular expression. So if you're running your program once, you can compile that regular expression once at the very top of your program then use the compiled expression each time. Now, if you do that explicitly, then you're all set. If you don't, the regular expression module does most of the work for you, because what it does is it keeps a little cache--it does something like memoize and keeps the last few regular expression that's done and says, I've seen this string before. I know what it compiles to. I'll just fetch that compiled object. It does that automatically. That's within one run of your program. Now, another thing to think about is between runs of your program. What if you've compiled everything, and then you don't want to have the startup time of compiling it over again? There's another module called pickle. Well, what are pickles? They're ways of storing cucumbers for a long time so they don't get rotten. That's what the pickle module does. It takes an object that exists within the running Python interpreter and writes it out to disk in a form that can be read back in. Next question comes from Thomas, and his question has to do with mistakes. Basically, you never seem to make any--at least in the videos. Maybe you can talk a little bit about your design process in coming up with these lectures and how mistakes figure in there. There is always a trade off of how many mistakes we want to leave in, and believe me, I make lots of them. And I make them at various points in time. So as I'm first thinking up the questions we're going to do, I'm coding up answers. And I make mistakes there in a couple of ways. One is, I just make errors. I write something. It computes the wrong answer. It generates an error. I swapped the order of two arguments, or I pass the wrong thing in. I'm making those mistakes all the time. Those aren't very interesting ones, so I don't show them. And then, when I'm recording the videos, I make mistakes there too. And, sometimes errors have crept into the program that I didn't notice when I was developing them. I didn't write enough test cases, and then I have to decide what to do. And mostly, those have ended up on the cutting room floor. So, just as when you watch a movie or a TV show, you don't see most of the outtakes. Sometimes after the credits, they roll a few of the outtakes So believe me the errors are there, we're not just showing most of them. Next question comes from Eduardo Lopez. He points out that Python is a flexible language. We can use many different programming paradigms. We can do functional, procedural, or office-oriented programming. How do you decide which of these paradigms to use when approaching a new problem? Yeah, I guess I try to think of things as how can I get as close to the problem as possible? And so I want to program at the level of the problem. And then, incidentally, I have to program with a particular language. And so I start analyzing the problem and saying, what are the pieces of this problem, what are the objects I'm going to be manipulating, what are the ways I'm going to manipulate them, and try to do most of the analysis at that level. And then once that analysis is done, then I can say, well, what do I have in my programming language? And there there might be some differences between languages. So if you're using Python, you might have more functions. If you're are using Java, you might have more classes. But they're still implementing the same basic set of ideas. And I like that approach because there is a more direct connection between the problem and the solution, rather than a multistep of going from the problem to the language implementation and then back to the solution. All right. Thank you. That's all we have for this week. See you next week. See you next week. Hi, and welcome to the sixth office hours. &gt;&gt;Welcome. It's going to be our last office hours, and it's been a ton of fun TAing this class. I'd first like to thank the students and Professor Norvig--you, too. This has been a great experience. &gt;&gt;Great. What have we got for questions this week? First question comes from Horace, and he says, What steps should I take after finishing this class to keep improving at a programmer? That's a great question. There's so much to do. Of course there are other classes available. So you can search online. You can see what classes are coming up next. Figure out what you're interested in and just have at it. Then the other thing is to do more programming on your own. Pick out a project and try to achieve it, try to complete something. That can either be find some opensource project where you can contribute or just something of your own, something that you always wanted to do. Just get started and try to build it. For small problems, project Euler has a lot of really great problems. You can check that out online. Next one comes from Lee. After teaching this class, you've been very active in the forums, and you've seen a lot of the common mistakes student's have made. What can you say about some of the common mistakes that have been made throughout this class and any general suggestions on being a good programmer. Huh. I didn't see that many things that were common across everywhere. I guess some around the structure of mutable variables seems to come up again and again. I made this array and then I altered the element of the array but all the elements got altered. Why did that happen? Well, it's because each row of your matrix was actually the same row. That seemed to be a problem. There was one today of the default arguments to functions. They're set up, and that's a single argument. If you modify it then you have a problem with that. That was one thing. I guess another one is just reading the documentation and getting familiar with things. I don't see that so much as an error on the part of the students. I just see it as not having enough familiarity, and it just takes time to get familiar with things. I guess another is just read carefully. I see people ask a question and then see the answer and say, "Ah! I realize the mistakes I made or the misconception I had." Sometimes that's just part of the learning process, but maybe you could use that as a lesson to yourself of saying, I'm stuck. I could be because there is some preconception that I have that is blocking me. Think of what preconceptions am I holding and should I relax one of those. Next question comes from Ginger, and she wants to know what areas of software you are particularly excited about. I think it's an exciting time now when there's so much going on and so many opportunities, new companies springing up, new ideas in software. I guess to me one of the things that's really interesting is connecting with the world in a deeper way. We're used to the idea of data like text and numbers can be processed by computers, but now we're starting to see images and video and sound, and people are walking around with phones that have input devices for all of these constantly with them. This connection to the real world is so much stronger, and that just opens up so many new areas. Next question comes from Egoots, and Egoots wants to know if you have any tips for reading other people's code and writing your own code so it's more readable by others. Okay. In terms of reading other people's code, a lot of it is practice. Just go out there and start doing it. I always like to play with code when I'm reading it. I find it hard and frustrating to read code without an interpreter or compiler available so that I can actually run it and try it and see what it does. Theoretically, you should be able to write code so you don't have to do that, but it's just so much easier if you can, to say I'm really want an example here of what does this function do? The person who wrote the code didn't document it, didn't give me an example. Okay, I can run it myself and see what it produces. I think of reading as more of an interactive process rather than a passive one-- the way you read a novel and don't be afraid to do that. I think another aspect is how are you reading it? When you read a novel, you pretty much start at the front and you go to the end, but when you read code you don't do it like that. have to figure out what you're reading for. Are you trying to understand the whole code? In which case you're still jumping around and you're figuring out, well, what's the big idea? What are the key components? Let's flip back and forth. Let's follow this cross reference. It's another reason why I don't like reading statically. I want to be able to jump to the definition of a symbol and my IDE does that for me. You're jumping around, and then another way of reading is to say here's a big complicated package, but I just want it to do this one thing. So I'm going to restrict myself from trying to understand everything. I just want to understand one path through so I can get at this function call or this functionality and have it do what I want it to do. I find that hard for me. I guess one of the things I see is sort of maybe a generation gap in that the younger engineers I work with are so much better at that than I am. They can look at a piece of code and say, I just want to get this one functionality. They figure it out, they use it, and they're on to the next thing whereas I usually lag behind. I say, okay, I think I got this functionality but, gee, this is interesting. Let me look around a little bit more and see if I can understand the structure more deeply. I'm learning more from that, but I'm diverting myself from what my task really was-- to just find out as much as I needed to know and not more. That's something I know I need to train myself on of doing a better job of reading selectively. All right. The last two questions both come from Jeff. His first question: Where do you get your wonderful shirts? [laughs] Okay, Jeff. Well, one answer is not available to you in that my wife makes some of them. She's not going into the business of mass producing them, so you won't be able to get one. This one I think is made by a company made by Jam's World, but I get wherever I can. The last one--a little more content-driven--is why do you structure so much of this course around games? What made you decide that? Yeah, I guess the reason I choose games is I wanted you to get experience of understanding a set of rules and following them. Games are sort of an abstraction of that. We wanted to have a seven-week class. It's not that long. We wanted to be able to go through a lot of examples and more real-world problems are just so complicated and messy. I think that's one reason games exist in the first place, right? They say the game of chess is supposed to be an abstraction of war. It's much easier to set up a chess board than it is to muster up a couple of armies and go through the messy business of destroying each other. Games are an abstraction, but they're still complicated. They have interactions. They have rules that you have to get right. So they seemed just at the right level for a short class like this as opposed to a more real world problem where we have to spend the whole seven weeks just to understand one of them. Great, that's all the questions we had. How about this one on recursion? Oh, sorry. I missed that one. Good. There was a question on recursion. This was from Egoots as well. Basically he's having a hard time implementing recursion in his daily coding routine. He finds that it's easier to just use loops, and do you use recursion in your everyday coding? I guess there is a couple answers to that. One is I think you should use it when it's appropriate and not when it's not. Now, there are some approaches and there are even some simple languages where recursion is your only way of implementing loops. I don't prefer that approach. I think you want to do what's most natural. When is recursion natural? I think there's a couple cases. One is when you have a recursive data structure. If you have a tree, a tree is defined as it's either a node or it's a node that has two trees or n trees as subparts. So there is recursion built right into the definition, and it just makes sense to implement the whole thing recursively. So most of the time when you have structure like a tree that's like that, it's simpler to do a recursive routine. Sometimes you don't, so we showed some search techniques where instead of just searching recursively we built up a queue like the frontier queue to essentially hold the equivalent of what would be on the recursive stack. Why do we do that? Because we wanted more control over the order of the recursion. We didn't want to just do left branch first or right branch first. We want to be able to pick where we went next. To make control we made the program more complicated. Anytime you take a naturally recursive data structure and process it nonrecursively it becomes more complicated. I think the opposite is also true. If you take a non-recursive thing like iterating over the elements of a list in a for loop-- you know, for x in list--that's much simpler as a for loop but becomes more complicated if you write it recursively. There I would prefer having for loops. There's another case that's sort of intermediate where you have a mathematical formula. More often mathematical formulas are written recursively. Then you have to decide. Is it best to implement that with recursion or with a loop. That's how I see it. The other question was are there limitations in terms of the implementation, and yes, that's true. In many languages there's a recursion limit. In some languages specific types of calls in a location in the function where it's the last thing that the function does doesn't get counted against the call limit. In Python they do get counted, so you have a limit. By default in the Python implementation it's a thousand levels deep. And so you have to think about that. Even if it is more natural to do recursion. If you say, well, I'm going to be doing it over structures that are more than 1000 elements deep, then you have to accommodate. I guess that's another reason to say why recursing down a list is probably a bad idea, because in many applications you do have lists that are more than 1000 elements deep, but recursing over a tree is probably okay, because if you have, say, a balanced binary tree you would only hit the limit if it has 2^1000 elements, and you'd run out of memory before you hit that problem. All right. Well, I think that's all the questions. Again, it's been a lot of fun. Any last words for the students? Thank you so much and good luck on the rest of week six and on the exam. I think you'll find it interesting and challenging and a good conclusion to the class. Thank you all. Solution Code for the final exam can be found in the instructor comments box below. Thanks for taking the course. Solution Code for the final exam can be found in the instructor comments box below. Thanks for taking the course. Solution Code for the final exam can be found in the instructor comments box below. Thanks for taking the course. Solution Code for the final exam can be found in the instructor comments box below. Thanks for taking the course. Solution Code for the final exam can be found in the instructor comments box below. Thanks for taking the course. Solution Code for the final exam can be found in the instructor comments box below. Thanks for taking the course. Congratulations! You've completed CS212. You've done all the work throughout the seven weeks. You've done the final exam. I hope you've learned a lot. I know you've accomplished a lot in terms of writing programs. I hope you've learned both techniques and theory that will help you as you progress as a computer scientist. I know I've really enjoyed being a part of this class and learning from the students as we've gone along, and I hope to see you in the future in another class. [Norvig] This homework assignment has to do with games that have more than 5 cards. So in games like 7-Card Stud or Texas Hold 'em, players have more than 5 cards. Sometimes some of those cards are in common-- that is, all players share some of the cards. But that doesn't matter. What you're asked to write in this program is this function best_hand, which takes a hand with 7 cards in it and returns the best 5 card hand. So in other words, each player out of their 7 cards has to come up with the best hand that they can make according to the hand_rank. What I want you to do is write your code for the function best_hand to return a 5 card hand that's the highest ranked. And here are some tests. I'll give you a hint, which is a lot of the functionality can be found in the preexisting Python modules. One thing that's interesting to look at is the itertools module. [Norvig] And here is the answer. Look. It's only 1 line of code. Isn't that great? What we did is we took the combinations function from itertools, and that takes the combinations of a list taken n at a time. So we go through the hand--and here we didn't even use the fact that the hand is 7 cards, so it could have been 8 or 9 cards or whatever-- and we generated all the combinations up from them 5 at a time and then we just took the maximum of that according to the hand_rank. And that function does exactly the right thing and passes all the tests. [Norvig] There's an old saying that there's a joker in every deck. In this exercise we're going to allow for jokers. In fact, we're going to have 2 kinds of jokers. There's going to be a black joker and a red joker. The idea is that if you have a joker as one of the cards in your hand you can replace it with any other card of the same color. So if you get the black joker, you can replace it with any spade or club of any rank, and the red joker, you can replace it with any heart or diamond of any rank. And what you're asked to do is write a function, bestwildhand(hand), that tries all possibilities for jokers and comes up with the best 5-card selection. Like before, hand might be more than 5 cards--it could be 7 cards-- and you still have to come up with the best 5-card answer that substitutes in one of the appropriate cards for any jokers that exist in the hand. Here are some tests. This test says here's a hand where we're doing pretty good. We already have a straight--6, 7, 8, 9, T--but we also have a wild card, and we can use that wild card, that joker, and replace it with a jack rather than a 10, and now we get a slightly higher straight. We have a straight with a jack high rather than a 10 high. Here's an example where we have two 10s but we have 2 wild cards, so we can add in 10s for both of them, and we end up with four 10s, four of a kind. And here's an example where we show that even if there aren't any jokers we still come up with the right answer. And I should say that the hint still holds--that itertools is still your friend. [Norvig] Here's my answer. First I defined all the ranks. That had been a constant that we had in the program before, but I'm going to have to refer to it a couple times, so I called it out and gave it a name. Then I defined all the red cards and all the black cards. Those are what we're going to substitute for the various jokers. And then here's bestwildhand. So what I did is I said let's apply this function replacement to each of the cards in hand. Here's what replacement does. Replacement takes a card and replaces or comes up with a list of possibilities for that card. So if the card is a black joker, then it can be replaced with all the black cards. If the card is a red joker, it can be replaced with all the red cards. Otherwise it can replace only with itself, and we'll make that a list because the interface here is that you give me 1 card and I give you a list of all the cards it can be replaced with. Now, what am I doing here? This looks a little bit tricky. What I'm saying is I'm calling itertools.product. Let me explain to you what product does. The product function takes any number of lists, or in fact they can be iterables, and here we're just going to try 2, so the product of ([1, 2, 3] , [100, 200]. Product stands for cross product, so we'd have all ways of taking 1 item from this list and 1 item from this list. So that would return a list, and the pairs of items are put into tuples, so it would be [(1, 100), (1, 200), (2, 100), (2, 200), (3, 100), (3, 200)]. So however many lists it's given, it picks out 1 element from each, puts that into a tuple, and does that for every possible combination of elements from a, b, and whatever else there is there. So what we've done here is we've called replacement on each card in the hand, and that gives us a list of possibilities for each of the cards. If the card is not a joker, that list will be 1. If the card is a joker, then it will be all the red cards or all the black cards. So now we have the product of that. So for all the 7 cards in the hand we've got this big product, and we go through and we take all the possibilities and then for each one of those possibilities, h, we pick out the best hand using the process that we did before, and that gives us a set of possible hands. And then we go through those hands using hand_rank. These hands are now the 5-card hands determined by best_hand, and we take the maximum again according to hand_rank, and that gives us the best out of those 5 cards. For both of these solutions to the homework problems I was able to come up with a small amount of code because I knew about existing routines in the standard Python library. If you didn't know about those routines and if you wrote a lot of lines of code rather than just 1 or 2, don't feel bad. You got the practice doing that, and I'm sure your code was good and did the right job. So you should feel proud that you got it working, but you should also learn this lesson-- that you should try to familiarize yourself with the tools that already exist and use them when appropriate. In this homework assignment, I want you to modify the function compile.formula so that it rejects any formula where there is a zero as the leading digit in a word. Now, in our first version of solve we took care of that, and we had to because Python would have interpreted 012 as an octal number. In the second version where we use compile.formula, we didn't work about that. Now we want to put that test back in. If YOU is a word in the formula and the function is called with Y equals 0, the function should return False, even if the arithmetic works out. What I want you to do is modify the following code in any way you want, so that the function that you build up as a string and then compile with a vowel is a function that will correctly return false in this case. Here is my answer. I found all the first letters, which are the first letter of a word where there is at least one other letter, because it's okay to have a zero by itself. You just can't have a zero followed by another digit. I found all those first letters, and then for each first letter I added in a letter not equal to zero, conjoined them all with and and put that into the body. Here's an example. For YOU equals ME-squared, I have lambda with the variables just like before and this result just like before, but I've added in Y not equal 0 and N not equal 0 and the old value. In this homework assignment, we have a puzzle, which is similar to the zebra puzzle. I'm calling it the floor puzzle. We describe a five-floor apartment building in which there are five residents, and there's various constraints on them. What I want you to do is just write the code to return the proper floor assignment for each of the five inhabitants in that order. Here is my solution. You can see it looks pretty similar to the way we solved the zebra puzzle. We did the same technique of assigning something to each of these numbers-- bottom to 1, top to 5. These we left unassigned. Then we have this for loop. I chose not to use a generator expression here, because I thought this looked pretty readable in a simple for loop. We have this extended if statement, where each of these clauses corresponds to one of the original constraints of the problem. For example, we know that Hopper doesn't live on the top floor. Key is not on the bottom. Liskov isn't on the top or the bottom. Perlis lives on a higher floor than Kay. Richie and Liskov do not live on adjacent floors, so the absolute value of their difference must be greater than one. Likewise with Liskov and Kay. When we return this and run the function, we get our solution--3, 2, 4, 5, 1. This means that Hopper lives on the 3rd floor, Kay on the 2nd, Liskov on the 4th, Perlis 5th, Richie 1st. In this homework you're going to solve the subpalindrome problem. Now, if you took 101, you saw that a palindrome is a string that reads the same forwards as it does backwards. R-A-D-A-R. R-A-D-A-R. We're going to allow palindromes where the case of the letters can be different. This would be a good palindrome even though there is a capital R here and a lowercase r there. Now, some people allow palindromes where the spaces and punctuation don't count. You can throw them in anywhere. We're not going to allow this. We're going to only allow cases where there is an exact match. This would be a palindrome. It has spaces, but they read the same forwards and backwards. That's a good one, and this would not be a palindrome, because the space does not occur in the same place forward and backward. Now you know what palindrome is, but the problem is to find a subpalindrome. Here is a string. We want to find the longest palindrome. It turns out that it occurs from here to here. Now, how would you find that? There's one obvious way to do it. It's to try every possible substring, so try every starting location--here, here, here, and so on-- and every ending location--the string "w" by itself, "wh," "whe," then "h" by itself, "he," "her," and so on. Try every single one and check to see if they're a palindrome. Now, that would work, but it would be slow. If there are N characters in the string, then there's N starting locations and N ending locations, and each of those substrings can have up to N characters. To check all of them out would be an order N-cubed operation. There'd be roughly N-cubed checks that you'd have to make to see if two characters are the same. What we're asking you to do is to come up with a solution that's faster than that that takes in the worst case, roughly N-squared rather than N-cubed comparisons, and in most cases will do better. When I say operations here, what do I count as an operation? I want you to write your routine so that all you do is pick out characters, so we pass you in a text and you pick out a character--text sub i, text sub j-- and then you can do anything you want with the characters you pick out. You can convert them to uppercase to make it easier to compare if they're the same. You can compare two characters. All those operations will be free, but we'll be counting how many of these operations you do. Now the trick is to find a good way to go through the text and look at the characters. I'm going to tell you a bad way to enumerate through them, and you're going to have to come up with a good way. Let's say that we knew that text from i to j is a palindrome. Maybe that's abcba. If we then said let's try to expand this text and look at the next two characters, we could do that test, but we wouldn't have learned anything about whether or not this is a palindrome given that this is a palindrome. We'd have to do the whole test all over again. We haven't gained any advantage from what we know about a partial result to expand it to a bigger result. What we want to do is find some way of saying I know something about a palindrome somewhere in the string, and that's going to help me more efficiently figure out a bigger piece of the string. That's what you're being asked to do. I'm going to call our function longestsubpalindromeslice. A "slice" meaning what I want you to return is the i and j indices of the start and the end, and j should be one character after the end so the same conventions that we use normally in Python such that text[i, j] is the longest palindrome. Why did I return the indices rather than the text itself? Because you might be interesting in where in the text the palindrome occurs. If you have i and j, it's easy to pull out the actual palindrome, but if I give you the actual palindrome, it's harder to find where it occurs. Here what I'm doing is making an abbreviation for this function. "Longestsubpalindromeslice is just a variable which names a function. Now I'm just assigning another variable L to be equal to that. Now these two refer to the same function. I can go ahead and do that, and I can fit more tests on one line by using the shorter name rather than the longer name. Write your function so that all the tests pass. Add any other tests you think are useful and make sure you do it through an efficient recurrence relation. The first I'm going to talk about the strategy for my solution, and then I'm going to show you the code. Now, I said before that a bad strategy would be to start at the front and then when we find the palindrome, try to extend it by extending onto the end. Why is that bad? Because just knowing that the first characters of a substring is a palindrome doesn't tell you anything by expanding it by adding characters onto one end. There's another way to look at it where it does work. If we start in the middle, then we can expand and then every time we move out we are gaining some information. Let's say that instead of starting here we started here. We say is c by itself a palindrome? Well, yes, it is, because every one-character string is a palindrome. Then instead of going only forward, we go 1 character in both directions. Now we're looking at bcb, and say is that a palindrome? Yes it is. Now we can go out again in both directions. Abcba--is that a palindrome? Yes. We keep on growing the solution out from the middle in both directions. We keep on going as long as we can and find the longest palindrome that's centered on one of these positions. As soon as we find something that's not a palindrome-- let's say if instead of a here there was an x--then we can stop. No matter how long the string is, no matter how many characters are here and here, we know that nothing centered on the c is going to be a palindrome that's any longer than that. We can eliminate a lot of the work. That's the advantage of doing this. What about the starting positions? Well, we've got to start with every character being the center, and then we also have to start with between every character being the center. Maybe the longest palindrome in the string is just a two-character sequence. If we only looked at the first one and then went out to the side we wouldn't find it. If we start by looking in between them--in other words, start not with "b" but with the empty string-- then when we move out in both directions from the empty string then we check "bb." That's my approach for the strategy. If you didn't get the question right, why don't you try it again. Try to implement this strategy before you look at my solution. Now I'll show you what I did. The key to this function is the grow function. How do you grow a potential palindrome from the middle out? Grow is going to a text, a start, and an end position, which the end is going to be either 0 or 1 more than the start, then we keep on going until we hit the end. While the start is greater than 0, the start of the string, and while the end is less than the end of the string and while they match, while the character 1 to the left is equal to the character 1 to the right, but we allow for one of them to be in a different case. If that's true, then we grow by expanding the start to the left and expanding the end to the right. We keep on doing that as long as we can and then we return the start and the end. That's the grow function. That'll find you the longest sequence that is centered on a particular text with a particular start and end. Then longestsubpalindromeslice just goes through all the possibilities. It tries to grow for every possible start and end location. Then we just take the maximum length out of all of those candidates where the length of a slice is just the different between the two. In this homework you're going to be asked to write a grammar that will allow us to write a parser for the JSON language. JSON is a data interchange language for JavaScript that allows JavaScript programs to pass values back and forth and pass them on to other programs. What I'm asking you to do is to write this grammar. You can look at JSON.org to see the definition. There is a little grammar there on the right-hand side. It's not quite in the right format that we expect here, so you're going to have to translate it into the right format. Then you should be able to parse. A top level is called a value in JSON. You should be able to parse that with your grammar. Here I've given you some examples that you can test out to see if they make sense. See if you can translate the JSON grammar into our format, and see how easy that is. Here is my answer. There is a lot of variation in exactly how you want the grammar to look. But I just went through the grammar on the json.org webpage, started to write it down, made sure I wrote it in the correct order. They had things like members goes to pair or pair, members, and I had to make sure to put the longer element first, because that's the way our parser works. Other than that, it was straightforward. I abbreviated a little bit. I didn't get into spelling out the individual digits. I kind of stuck them together into longer regular expressions to take advantage of that rather than break it out all the way. But either way you did it, if you get it to parse, you've done the job and congratulations. In this homework we're going to show the power of functions as tools by computing inverse functions and doing the work just once, rather than having to do it for each function. What do I mean by that? The square function for squaring numbers is easy, right? We just return x times x. But if we wanted to define the square root function, that's a lot harder. Assuming we didn't have the exponentiation operator built in, if we wanted to define it in terms of elementary arithmetic, that's a lot of work. Isaac Newton came up with a way to do it, but he's Newton. For those of us who aren't, wouldn't it be great if instead of having to write all this code to define the square root, we could just say "sqrt" is the inverse of square and be done with it? Well, in this homework we're going to do just that. We're going to do it in a slightly restricted sense. We're only going to deal with functions that are defined on the non-negative numbers and are monotonically increasing. They have to keep on going up. That way they have a defined inverse. Functions that are non monotonic don't have a single inverse, because there's a two-to-one mapping. Here's my definition of inverse. I'm going to give you a simple version and then ask you to write a more efficient one. What does inverse do? It takes a function f and returns a function f_1. The way it figures out what to do is it says let's start at zero, because we said this is the function defined on the non-negative numbers, and ask is this f(x) greater than the y that's being passed to f_1. If it is, let's increment x by a little bit--a little bit being delta, which here I've defined as 1/128, but you can define it as what you want when you're asking for the inverse. Keep on going until we find an f(x) which is not less than y. Now x is too big. It's greater than or equal to y, and y minus delta is too small. It's less than y. We're somewhere in between the two, and we want to pick the closest one. That's what this expression does. It says we know the result is somewhere in there, and we want to choose which one is closer. How does that work? Well, we can define square. We can ask for the square root of 100. I guess I missed a step in here where I have to say that sqrt is equal to inverse(square). Now when we ask for the square root of 100 we get exactly 10.0. That's the right answer. When we ask for the square root of 99, we get 9.95-something. That's pretty close, although there are more accurate representations that the computer could come up with. When we ask for the square root of 100 million, we get 10,000 exactly, which is exactly the right answer. But it took a little bit too long. It took almost a second to come up with this result. I'd like it to go much faster. So that's what I'm going to ask you to do. I want you to modify inverse so that it has a run time closer to the logarithm of the input to f_1 rather than to linear in the input to f_1. I'll give you two hints of things to consider. One is binary search, and the other Newton's method. So do some research on those, and then modify the definition of inverse so that when we say sqrt = inverse(square) the whole function runs faster. Here's my approach to the problem. Here's our axes. Here's my function, f(x). Now, the problem is I'm given some value of y, and I want to find the value of x that corresponds to that such that f(x) equals y. The strategy we had before was to just start at the 0 point and go out step-by-step-by-step, but that's going to be slow if there are lots of steps. My approach is going to be--first I'm going to take one step forward, and then if the value of f(x) is still below y, then I'm going to double how far out I go. I'm going to keep on doubling how far out I go and checking-- 1, 2, 4, 8, 16 units out--until I've got bounds. Here I have this value that I doubled. F(x) was less than the desired y. When I went all the way out to here, f(x was greater than the desired y. I know that the right x has to be somewhere within this range. That gives me the low and the high that I get by doubling. Now I'm going to find the exact value or close to exact value within low and high by halfing. First doubling, now halfing. I look in here, say what's halfway between low and high. That's at this point. F(x) there is still too high. Now I know I must be somewhere in this half. I go halfway there. That's still too high. Now I know I must be in this half, and I keep on doing that process until I zero in on the right value. That's the strategy. Now let's see what the code looks like. Here's my function "inverse." I'm going to have my smallest delta--the smallest amount that I move out--be 1/1024. That's going to get me to within three significant digits. I'm going to build up this f inverse function. I was given y = f(x). I'm going to build up x = f_1(y). I do that first by finding the low and high bounds-- it's got to be somewhere in there--and then doing a binary search somewhere in between that low and high to find a value that's accurate to within delta. Here's how I find the bounds. I start off, and I just keep on doubling until I find a value that's high enough. What I keep on doing is narrowing down the interval between low and high until they come out to be the same--until the interval has disappeared. If I'm too high, then I change the low. Otherwise, I change the high value. That makes the interval smaller and smaller. If I hit it exactly, I go ahead and return the x value. If I haven't hit it exactly, then I know I'm somewhere in between the two, and I just check out which one to do. Now, I've defined some functions here to help me test what I've done. I've defined the square and the 10^x functions. Now I define those inverses. The logarithm is just the inverse of the power of 10, and sgrt is the inverse of square using the function I defined. Can also do a cube root as the inverse of the cube function. Then I'm defining some tests. For these sets of numbers, I'm going to test these functions--sqrt, log10, and cuberoot, and I'm going to test them against the correct mathematical functions as defined by Python. These are the ones I've defined with inverse. These are the ones Python defines, and here's my individual test. Here's what I get when I run the tests. For each of the numbers and for each of the functions here is the result I compute with my inverse function. Here is the actual results, and you can see the differences are all in the 0.001 or less. That's true for small numbers, and it's true even as we go up to bigger numbers like 10^8. Now, if you took CS101, you had to find HTML tags within a document, and you did that mostly using the string.find method, which works okay, but it's fragile and doesn't quite get everything quite right. The code you wrote was not completely robust to having spaces and lines feeds and other things anywhere in the text, so we'd like to do something that's a little bit more robust. Your problem is to find these HTML tags, and in particular what I'm looking for are start tags. Things like we'd begin, and then a would be a tag, and table would be another one and so on. I'm not looking for the end tags, so don't worry about those. Just the start tags. Then something like a and then a set of attribute value pairs. Then a closing angle bracket. We're looking to find all the instances that look like that. This whole thing--angle bracket, tag, optional set of parameters--parameter equal string. These will have to be a string, and they have to be enclosed in double quotes. You can rely on that, and there won't be any double quotes within the string. That simplifies it a little bit. Then the closing bracket. But there can be spaces anywhere and so on. I want you to write a function--call it "findtags"--which you pass it a text, and then it returns a list of strings that look like that that come out of the text. You could use whatever tools you found. You can use the regular expression module "re." You can use the regular expression parsers that we built. You can use the context-free parser that we built. Whatever you think is appropriate. Here's my solution to the findtags problem. I decided to do it just using regular expressions. Why don't I make that explicit and import the regular expression module, but then I broke up my regular expression, because they can get long and complicated. I said there is a part where I'm parsing the parameters, and that's one or more word characters, an equal sign, and then a quoted string. A quote character, 0 or more non-quote characters, followed by a quote character. Then that whole thing we can have zero or more parameters. The thing that made it complicated is I've got to throw in optional spaces in multiple positions-- " \s* " means zero or more spaces. That defines a set of parameters. Then the tag is the angle bracket, maybe some spaces, word character-- like the a or the table tag, then the parameters, then maybe some more spaces, and then the close. The close is an angle bracket. I allowed an optional slash-angle bracket there. Now that I've defined this regular expression in tags, then I just re.findall of the tags in the text. ﻿Now we showed how useful it is to have an API for regular expressions that we can say for example plus an option, alternative of literal A, literal B and these function calls are convenient to manipulate but that’s an awful lot to type, especially when the string notation for regular expressions is so much simpler, we can represent this as this simple string, and so what I want you to do in this homework is to write a grammar and a parser that maps from this string to this expression. So you should first define regular expression grammar using the tools that we’ve provided, build the parser for that, that’s going to give you a tree, so when we parse let’s say, RE is our main symbol, then some text with this grammar then that’s going to give you some sort of tree, but it’s not quite this API form, so then I want you to write another function to convert from the tree to the API, and so here’s what it looks like. You are going to define your grammar, RE is going to be the main left-hand side symbol to parse the regular expression that’s given for you, you parse it and convert it and then you have to convert this to make that cause into the API. This homework is about refactoring the bridge successor function. I want you to write a new function. We'll call it bsuccessors3, which takes a bridge state as input, but we're going to represent the states in a different way. We're going to represent them not as a set that included the light, because in the old bridge successor function--bridge successor 2-- it just seemed kind of complicated that I had to deal with the special case of are the elements of the sets on the here and there side-- are they people or are they the light. It just got a little bit overly verbose. I think maybe there's a better representation, so we're going to try a different representation. We're going to try one where there is a set of people on the here side, a set of people on the there side, and then the light is going to be an index. It's going to be 0 if the flash light, the torch, is on the here side and 1 if it's on the there side. Then the tuple for the actions is going to be a little bit different. It's just going to be a set of people--the travelers that are going--then followed by the arrow. Here is my solution. I think it is a little bit simpler. The total number of lines of code is not that much different, but I think it's easier to follow this way. What I said is let's pick out the light from the state, and let's take all the travelers a and b from within the state indexed by that light with 0 being here and 1 being there. Let's find the individual successor states that results from those two travelers, or they might be one and the same--a and b traveling from that state. I broke out this single successor function. That just says we start where the light is, and we go to where the light isn't. If the light was on side 0, then we go from the start to the destination, and the light now is on side 1, and we're going in that direction. Otherwise, we're going in the other direction. This homework I call "More Pour." We did the glass-pouring example where we had two glasses, and we could pour between them. We're going to do the same thing here, except we're going to allow an arbitrary number of glasses. For example, here I've drawn four of them. Let's say they're capacities are 1, 2, 4, and 8, and let's say we set ourselves the goal of having 5 in one of the glass. How could we achieve that? One solution is we could fill up this glass with 8. That would be the first action. Then we could empty out or pour 1 into here. Now we'd be down 1 and be at that level. Then the second action would be to pour into here. Now we'd be down 2 more, and we find we're at 5 here. That would solve the problem. An alternative solution would be to fill these two glasses with 4 and 1 and then pour both of them into 8 to achieve 5. Your task will be to define morepourproblem, which takes a tuple of capacities of glass--any number of glasses-- and then a goal, which is a single integer that you're trying to achieve. Alternately, you can have a start state of what is the current level of the glasses are. If the start state is None, that means zero for all of the glasses. Your task is to return a path which achieves the goal or return the empty path or failure if there is none. The paths, like before, are an alternation between states and actions where the state is just a tuple of current level, not of capacities but of current levels. Then the actions can be either fill, empty, or pour, and we're going to describe the glasses by their index numbers. In this list of capacities the first number in the list-- we'll call that glass number 0, the next one glass number 1, and so on. When we filled up the tallest glass that was the last glass out of four--glass number 3-- so the action would have been fill 3. Here we have a test that says the problem I just solved for you by drawing it out. The actions are fill glass number 3. Pour glass number 3 into glass number number 0. Then pour glass number 3 into glass number 1, and then you're left with 5 in glass number 3. Here are some more test cases to check things out for you, see if you can solve those by writing your program. Use what we have seen before. You'll probably want to use one of the search procedures we've already defined, and you'll probably need to write a custom successor function, which understands the current state and the capacities. Let me just say I've seen some discussion in the forums about, oh, can I find a one-line solution or two-line solution? Don't worry about that. The solution will be whatever it is. The set up to solve the problem should be a call to a function we've already defined. That will be one line, but the successor function-- that might be a dozen lines, maybe a little bit more or a little bit less. Don't worry about minimizing it. Worry about making it clear. Here's my solution. I got rid of the doc.string just so that the whole function would fit on the page. In general, I should bring that back. The doc.string is an important part of the solution. Here is what I do. The heart of the function i just a call to shortestpathsearch. Start at the start state. We have successor function and a goal function. That goal function just asks is the goal number, that integer that we're trying to achieve, anywhere in the state. Is any one of the current levels of the glasses equal to the goal? Here is a successor function, and I'm going to build up this dictionary of results, which I call "succ" for "successor. It's a dictionary of state-action pairs. I go through all the indices. That's equivalent to the glass numbers--0, 1, 2, 3. I've invented this function called "replace," and replace takes a tuple, an index into the tuple, and a value that we want that index to be. Now, why did I need that? Because tuples are immutable. Mostly this is saying replace state sub i with capacities of I, but I can't say that for a tuple, so I needed a function that's going to do it for me. Take that tuple with state sub i, replace by the capacity. That's the same as the action of filling an i. Replace it with 0. That's the action of emptying. Now, the action of pouring, which we have over here, is a little bit more complicated. We have to go through all the glasses twice, pouring from i into j. We have to make sure that we're not pouring into yourself. Then the amount that we pour is the minimum of how much we have. We can't pour more than we have in the glass that we're pouring. We also can't pour more than would fill up the glass that we're pouring into. That's the amount we're going to transfer, and then we subtract that amount from the glass we're pouring from, and we add that amount from the glass we're pouring into, and we make that a pouring action. Then we just return the result. Then there's one little statement here that says if you didn't specify the start state, make that be the tuple that contains all zeros and whose length is the same as the number of glass we have. So that's the whole solution, except here is my replace function. Replace in general takes any sequence-- but it's really most applicable for tuples that are immutable, makes that sequences into a list, mutates it--because we are allowed to mutate lists, and then puts it back together again. So what am I doing here? This might look a little bit unusual. But what I'm doing is I'm saying tell me the type of the original sequence-- a tuple, could be a string, could be a list-- and then call that because types are functions. In this case it's going to be tuple. Then call tuple on this list s and make s back into a tuple. I made it general like this so that it would also apply to lists and string. Finally, here are the test cases, and if we run them it turns out it works. This next exercise involves planning routes on a subway system. This is a map of the subway system for my hometown of Boston. We're going to have a representation of this map, and then we're going to be able to ask questions of what's the shortest path to get from A to B. Now I'm going to show you what I decided as the format for how I represent the subway line and the functions I want you to write. I'm going represent it as--we call this function "subway," which builds up a data structures and assigns that-- we're going to assign it to the variable "boston." And the arguments to this function are a bunch of keyword argument. Blue is the list of stations separated by spaces-- just regular words separated by spaces. The orange line, red line, and green line are similar. Now, here is the signature for this function subway. It takes this double-asterisk parameter name notation. If you haven't seen that before, what that means is that these are the keyword arguments. Two asterisks means everything that's left is going to be a keyword argument. I'm not going to tell you what they are. They can be anything. Collect them into this parameter called lines and make that be a dictionary-- a dictionary where in this case the keys of the dictionary would be the strings blue, orange, green, and red, and the values of the dictionary would be these corresponding strings. That's what lines is. Then you do whatever you want to lines and return the result. If you want, you just return the lines dictionary as-is. That would be fine. But if you did that you'd probably need to do more complicated processing on the values later one, so you might want to do some of the processing up front and return some other type of data structure for subway, because you're going to need it down here. Down here we're going to write the ride function that says how do we get from here to there. Here and there are going to be stops. For example, how do we get from Oak Grove to Downtown Station or stop? Those are just strings that represent the stops. The system, which in this case defaults to Boston-- the subway system that we previously defined. You write your code there. Presumably, you're going to have some sort of call to a search function. You're going to need to define a successor function that'll be appropriate. So you need to decide what is the representation you'll come up with for subway that will be useful to the successor function that you're going to use here. Then just for fun, let's also write the function longest_ride, which takes as input a subway system such as Boston and tells you what's the longest ride you can get. >From all the pairs of stations going from one to the other, what's the longest one? And I helped you out a little bit here by writing just a small number of test cases. You can try that out. You can also write more test cases on your own. Here is my solution. For subway I decided I'm going to return something that looks just like the successor function, only it's going to have all possible successors. It's going to be the dictionary of this form for any station that you ask me for. Stations are states in this problem. All you need to represent a state in this problem is what station am I currently at. Each of those I'm going to give you a dictionary that looks like a successor function. That is it has a combination of state-action pairs. The state is just going to be the neighboring station. Then the action is the line that you take. For example, if I'm at Bowdoin, then one of the states I can arrive at is government. The action I take to get there is follow the blue line. How do I do that? Well, one thing is I import the collections module. I use collections.defaultdict. I'm saying successors is a dictionary, and by default if there's a value that isn't there, the default is going to be a dictionary. Here's what successors look like, and the default value-- if I ask for the value of a station and there's nothing there, make it be an empty dictionary. The line items are a set of line stops pairs. I'm going to go over those--line, name, and stops. Then I'm going to look at all the overlapping pairs--Bowdoin-government, government-state, state-aquarium--that I get by splitting up the stops into a list on spaces. Then I'm saying a successor of going from a to b, from Bowdoin to government-- you can do that along a linename--and similarly going from government to Bowdoin. You can do that along the linename here, blue. Then return the successors. Overlapping_pairs takes any sequence and just gives me those pairs. If you give me this sequence of this turned into a list, the overlapping_pairs are first bowdoin-government, then government and state, then state and aquarium. This is useful here, and it's useful in general. Here's my ride function. It's now very easy. It's the shortest path search. That makes sense. I don't need lowest cost search, because there are no costs here. I'm just going from one station to the next. I start here. Where am I trying to get to? Well, the goal is to get to there. I'm trying to get to someplace where--and I just put the function in-line here rather than defining it separately. You could have done it either way. Because the functions were short, I decided to put them inline. But naming the function would also be fine. Lambda s--"s" stands for state or for station or for stop, and we ask "are we there?" Then the successor function. Well, we've already built up the successor function in this subway system--Boston-- so we just say looking into boston, that's a dictionary and look for the station that I'm currently at, and that will give me a list of successors. Then shortestpathsearch does the rest. What does longest_ride do? First, I have to find all the stops, and that's a little bit complicated, because I've hidden them away in this dictionary for the system, but I can go through with this generator expression to come up with a set of stops. Then I just iterate through all possible stations a and b, look for a in all possible stops and for b in all possible stops, generate the ride--the shortestpathsearch between them, and then take the longest out of all those shortest paths, and that's my longest ride. This homework is about improving on the optimal strategy function. It may seem like that's impossible. How could we be better than optimal? And in fact, we can't in the sense that we can't come up with a function that produces better results, but we can come up with a function that's faster. One thing that bothered me about the optimal function is a big part of it was defining this probability of winning from a given state. And if we give it some random state like, say, 0, 7, 13, 19, it turns out that the value of this state--whatever that is-- is exactly equal to the state where the other player's turn is to play. So here Player 0 goes first, here Player 1 goes first, but the probability of winning for an optimal function is symmetric because we're assuming that the opponent is also playing optimally. So if 0 goes first against an optimal opponent or 1 goes first against the optimal opponent, that probability of winning is going to be exactly the same. But the way we define Pwin, it computes both of these and stores both of these. That's wasteful. So in this exercise, we're going to get rid of that waste. How wasteful is it? I'm going to do a timed call for the Pwin function, and I'm going to pass it a state and pass it this starting state. And so the first time you pass it the starting state, it has to do the complete computation to get all the way to the end. So that's going to be a lot of work, and it turns out that it takes about 他 of a second to do that work when the goal is 40, and the probability that's returned is 54%. So there's a slight advantage--over 50%--for going first. That tells us about the time. How about the space? I can look at the cache that the memo function has computed. It stored it at Pwin.cache. I can compute that length, and it works out to 86,000 entries. So I should be able to cut this time down, and I should be able to cut this size of the cache roughly in half by working more efficiently and having a better version of Pwin. We're going to do that by defining a function Pwin2 which is going to have the same signature as Pwin. It performs the same function, only it's going to do it a little bit better. And the way it works is it breaks out this state, throws away the player to play because we know it's symmetric--we don't need that-- and then it calls Pwin3, which we name because it takes 3 arguments-- the only ones that matter--my score, your score, and the pending score, and that's what I want you to do. Go ahead and write the code for Pwin3 that will efficiently do this computation. Make sure here that you don't get stuck in an infinite loop. Take care when the value of pending is 0. That's a special case to deal with. Remember that the probability that I win from a position is always 1 minus the probability that my opponent wins. You may need that in your definition. And here's my solution. It's pretty much just copying out the version from Pwin and making sure it fits with this new definition of the parameters. So if me plus pending is greater than goal, then the probability is 1. Otherwise, if you wins, the probability is 0. Otherwise, we compute the probability of winning by rolling. And if there are no pending, then we better roll, because if we try to hold, we'll get stuck in an infinite loop. So the return value is just the probability of rolling if there's no pending, if pending is 0. If there is a pending, then we want to take the maximum result of either rolling or dealing with holding. How did we do? We've defined our new Pwin2 function. We can call that on the same initial state, and that will do all the computations and cache them. And it turns out it takes just about ¼ of a second, so it's 3 times faster than the previous version that took ¾ of a second. And if you see the probability that it computes, it's exactly the same. And just to be sure, you should probably go through and pick out a bunch of other states and test those. I actually did it for all states and showed that all of them compute exactly the same function. Then we can look at the size of the cache and see that that's about half as much-- a little bit less than half as much--and that's where we're getting our speed-up. We're only computing half as much, so it goes a lot faster. And there's always a choice. When you get a speed-up like this, you can put it in the bank or you can spend it. So we can put it in the bank and say, "Now we can do in ¼ of a second "what previously took ¾ of a second." Or we can spend it. Here I'm spending it by increasing the goal to 60 rather than 40. So much more computation to do. Then I reload all my code so that the caches are flushed and do a timed call again, and this time it's about ¾ of a second, and I can do in the same amount of time--which I could only handle a goal up to 40; now I can handle a goal up to 60. And note that the probability is a little bit lower than it was before. If the goal is farther away, then the advantage of going first is a little bit less. This exercise involves doubling in the games of Pig. What is doubling? If you're familiar with the game of backgammon, which is a gambling game with dice, doubling is a way to end the game early. And the idea is that when we start out, each game is worth 1 point. But in the course of the game, if 1 player is winning, then he can propose to double the stakes of the game so that it's worth 2 points--that it, say, costs $2 that the winner wins from the loser rather than $1 or â‚Ź2 or whatever currency we're playing with. Then when the player makes that move of doubling, then the opponent has a choice. He must immediately either accept or decline. If the opponent accepts, then we play the game and it's worth 2 points. If the opponent declines, then the proposer of the double immediately wins 1 and the game is over. In backgammon, doubling can go on infinitely from 1 to 2 to 4 to 8 to 16 and so on. For Pig we're only going to allow 1 round of doubling. So the game is going to start off being worth 1 point and can go up to 2 points but no more than that. So we're going to define a whole new game. The top level function will be called playpigd--d for double-- and all our functions will end in that d. A state in this game will be just like before, with 1 new value for the doubling amount. So a state will have the player to play, the score for me, the score for you, the pending score, and an extra field for the double. And the double can either be 1 or 2-- and we said we're not going to allow it to go higher than that-- or it can be the string double. It takes that value only at 1 point during the game. When the first player proposes a double and then the second player has the choice of accept or decline, that player will see double in the state field and then will have to reply. So what I want you to do is write these 2 functions: pigactionsd, which takes a state and returns all the legal actions from that state, and here's the description of what they can be; and I want you to define some strategy function, strategy_d, that gives a state which is a state in the doubling Pig game and returns a good action. What do I mean by good? It's got to be better than this strategy function, hold20d, which holds at 20 and always accepts when offers a double, never doubles, and holds it at 20 or rolls otherwise. You should define a strategy that's better than that. If you want, you can try to define the optimal strategy, but you're not required to do that. I have defined for you the main function, playpigd. It's similar to what we had before, except the result that's returned is 2 values now-- both the winning strategy and the value of the game, which will be either 1 or 2. And then the other difference is we got rid of the roll and hold functions, and now we replaced it with just 1 do function, which takes an action and a state and it passes along the die rolls and then does that action. So this is really the definition of how the game works where the actions can be rolling, holding, doubling, declining, and accepting. Then die rolls are as before. We define the clueless function, which just takes a random choice from among the legal actions. You should definitely be able to beat that, but you've also got to be able to beat the whole 20 strategy. Here's my solution for pigactionsd. If you were challenged with a double, then the legal actions are accept and decline. If there's something pending, then you can either roll or hold. If there's nothing pending, then you can only roll. That's my initial description of actions. And then I add in if doubling is 1, then we append to whatever we computed before-- that we're allowed to do the double action--and return that. I didn't describe my strategy function because there were so many good ones that people have come up with. There's lots of different choices. So I think the best thing is just look in the discussion forums and then you can see some options for ways to go for figuring out a good strategy. This homework is about a card game called Foxes and Hens. There happens to be another game called Foxes and Hens which is a checkers-like game, but this one is different. This one is a card game, so there should be a deck of cards. We're going to simulate those on the computer. Here's the scenario that the game is trying to talk about. We have a yard into which some free range chickens can roam. I'm going to give up on my drawing skills and go to a schematic. So a chicken walks into the yard, some time later another chicken walks into the yard, and at some point a fox may come. And when the fox arrives, it eats all the chickens and everything is gone. So this deck of cards, each card has either a fox or a chicken on it. We flip the cards over 1 at a time to see who arrives next. We're playing this game as a 1-person solitaire version. The way the game works is we're going to take the whole deck of cards, flip them all over, and before we flip each card, the player has a choice. The player says, "Should I gather up the chickens that are in the yard?" That will be 1 possible action. And if I gather them up, then here there's 2 chickens. I would get 2 points. But the card that gets turned over, whether it be a fox or a chicken, that animal would get scared by my gathering action and would run away and be lost forever. The other action I can take is wait. So I just watch the chickens in the yard, wait for the next one to arrive, and if it's a chicken, then I'm in luck and there's 1 more in the yard. Once they're in the yard, I spread out enough chicken feed that they won't leave, so they'll always be there. I can wait for more chickens to accumulate within the yard, and then when I gather them I'll get a higher score. But if I wait too long and a fox arrives by flipping over the card and getting a fox, then I lose all the chickens. And so my choice then is before each card is unveiled, either gather or wait. Then we see what card is unveiled. We get a new state. Now, if you're familiar with playing blackjack in Vegas, you'll know that if you try to count your cards, you get in big trouble and you get kicked out. But here, counting cards is legal. At the start of the game, you know exactly how many cards there are, how many of each kind there are--foxes and hens-- but of course they are randomly shuffled, so you don't know which one is going to come up next. The state of the game then is defined by a score-- the number of chickens I've gathered so far-- the number of chickens currently in the yard, and the complete collection of cards that haven't been dealt yet. So we're assuming you have perfect memory for counting cards and you know exactly how many cards of each kind are left, but of course you don't know which one is going to come up next. This is a partnership, so I've written some and I'm going to call on you to write some. Here's the top level function. We call it foxesandhens. It takes a single player strategy, and it takes the number of cards of each type in the deck. Here we have a 52-card deck, of which there are 7 foxes. It creates that deck as a string of F and Hs. And the initial state then is the cards is a string of 52 characters, the score is 0, and the number of chickens in the yard is 0. And then we just go through the whole deck. We're going to be popping off a card from the deck each time, and we ask the strategy function for an action, and then we're going to define--and I'm going to ask you to define-- this do function, which does an action to a state and returns the new state, and that's going to be the score, the yard, and the cards. And we keep going until the cards have gotten down to 0. So every time you do a do action, there's going to be 1 less card in the state that gets returned. And at the end you get the score. I don't think I mentioned this rule yet, but at the very end you automatically get together all of the chickens that are left in the yard if there are any remaining. So your score should be the score you've accumulated so far plus whatever is in the yard. I want you to write this do function. Remember that there are only 2 actions: gather and wait. So do has to apply those. It has to pick a random card out of the cards, figure out what to do with that according to the action, and then return the new score and yard and the set of cards without that card-- the set of cards with that card removed. And the cards have to be represented as a string rather than as a Python set. I've given you a sample strategy for playing the game. I call this strategy take5. I wrote this function. There's no truth to the rumor that Paul Desmond and Dave Brubeck wrote it. The way it works is it waits until there are 5 hens in the yard, and then it gathers them up. Here's a function for computing the average score of a strategy over N number of games where N defaults to 1000. And what I'm asking you to do is to write your strategy function here, a strategy function here, that takes a state and does whatever you want here. I've added just return something, but you should alter your code to do the right thing. And we want you to make sure that your strategy is superior. What does superior mean? It means that your strategy's average score compared to the average score of take5 must be 1.5 points better on average. So keep working on your strategy until you can come up with one that's superior. If you want, you can try to figure out how to define the optimal strategy, but you don't need to do that as long as you beat take5 by 1.5 points. Here's my answer. Here's the definition for the do function. I make a random choice of the cards, and I replace that card in the deck with the empty string. I do that once, and that gives me the cards left without that 1 card. Then if the action is gathering, I add to my score the number of hens that were in the yard, and there's no more hens left in the yard. If the action was waiting and a hen shows up, then I add that to the number of hens in the yard. And if the action was waiting and a fox shows up, then, oops, I don't add anything to my score and the yard goes down to 0, and I've still got those cards left. Then if something went wrong, if the strategy function returned a bad value or something, then I just don't do anything and I return the state. And since we didn't specify what to do, you're free to do what you want in that case. You could have raised an error. That would be a reasonable thing to do. But the easiest is just to return the state. Here's my strategy function. I didn't bother writing out the optimal function, although you certainly could do that. What I did is first I said, "We're counting cards." "We better take advantage of that to some degree." "If there are no foxes left, then we might as well wait "and gather up all the rest of the chickens." So I made sure I did that. And then I tried all possible values of how long we should wait for and found that 3 was the best. So we wait until there's 3, then we gather them, and if there's less than 3, then we wait. Is this strategy superior? The answer is yes, it is. By how much? By almost 3 points. Take5 averaged 29.57, and my strategy averaged 32.3. This homework concerns anagrams. Now, an anagram is a rearrangement of letters in a word or phrase to form new words or phrases. For example, an anagram of the phrase ANAGRAMS could be-- we'd start pulling out letters and we could say AN, and then maybe ARM, and then we're left with GAS--or we could write that as SAG. This phrase is an anagram of that one, because it uses all and no more of the letters. It's okay to have extra spaces in between the words here. There could have been extra spaces between the words here. It could have been a multi-word phrase. Spaces don't matter. Just that you use up all the letters. Your task is going to be to write the function anagrams(), which takes as input a phrase, which is a string like the string ANAGRAMS or it could be a string with multiple words separated by spaces, and then an optional argument saying what's the shortest word you're going to accept in the answer? Here we allow two-letter words and up. If we wanted we could say we'll only allow three letter words and up or so on. This is going to return a set of phrases which may be multi-word phrases like that. Now, we'll be generating all possibilities from the words in the dictionary, so these words are all in the dictionary. But notice that for these three words, they could appear in any of six possible orders-- 3! possible orders--and it would be kind of boring and repetitious to see all of those. We're only going to show out of each of those six possibilities-- or N! possibilities for an N word phrase-- only show the one that's in alphabetical order. Here the word AN is alphabetically before the word ARM, which is alphabetically before the word SAG, so that's the representation we've shown out of the six possibilities. I want you to generate that set, and you can use things that we've had before like the set of words and prefixes that we've already defined. You might find it useful to reuse functions such as find<u>words().</u> Here's a skeleton of the function with its signature. It's going to return a set of words and here are some examples of calling anagrams(), checking to see some of the results are a member of the set, and here we've listed the complete set against our small dictionary of works for anagrams of the words PYTHONIC. I notice here that we have HYP NO TIC, but not HYPNOTIC, because HYPNOTIC happened not to be in our dictionary even though HYPNOTIC is an anagram of PYTHONIC. Go ahead and write your code here and feel free to copy and paste whatever previous code you need. Here is my solution for anagrams(). I chose to write a helper function called find<u>anagrams().</u> That takes the letters in the phrase with all the spaces removed. I'm calling find<u>anagrams() with the spaces replaces by nothing,</u> so we get rid of the spaces in the original phrase, and then I want to make sure that the anagrams I find--the words are in alphabetical order. The way I'm going to do that is by passing into find<u>anagrams() the previous word</u> on every recursive call. For the first call, we can just say the previous word was the empty string. Then I find I have to also pass in the shortest allowable word we're looking for. So what does find<u>anagrams() do?</u> It's got the same kind of structure that we say before. We initialize an empty set. At the end we're going to return it. Then we use the previously defined find<u>words function.</u> Remember for Scrabble, we take any letters in our hand and find all the possible words. Let's do that. For the words that come back, are they long enough? Are they greater than what were allowed for shortest, and are they in alphabetical order? Are they greater than the previous word? If so, then use the previously defined removed function to tell me what the remaining letters are. If there is no remainder, then lets just add that word into the results and we're done. Otherwise, let's recursively call find<u>anagrams() with the remainder</u> and then add in that result with a space in between them. This is how we're finding anagrams that are longer than just one word long. With this homework we're back to Scrabble, and we're tackling the problem of blank tiles. You probably thought this was coming. We talked about blank tiles as we were trying to design the program. If you remember back to playing poker, I threw the problem of Jokers at you. Blank tiles are similar to Jokers. They can be played, and any letter can take the place of the blank tile. You get to choose which letter you want to replace this with. But we can't use exactly the approach that we used with Jokers of saying well let's just try all 26 possibilities one at a time without changing the code and then just take the maximum play over the those, say, because the scoring rules are different. Suppose we wanted to play the word SWAY. We could use the blank tile to form a Y, but if we had a real Y tile, that would worth 4 points, whereas if we have a blank Y tile that's worth zero points in terms of the letter score. We can't just replace it as-is. We have to keep track of the scoring. We have a question of how we're going to represent the blanks. Now, I'm going make some of that choice for you. I'm going to say that in the hand, which is the string of seven characters, the blank tile is going to be represented by an underscore. On the board, when you finally decide what you're going to play-- let's say you decide that the blank is going to be represented by a Y-- we're going to go ahead and represent that as a capital letter Y, because once it's played, it fully takes on the affect of the letter it replaces. So somewhere from going to the hand to going to the board, the blank changes from an underscore to a capitalized letter, but in between it's up to you. Now, as the program progresses, we call best_play, which calls all_plays, and at some point we're going to call calculate_score. It's up to you to decide what format and what type of data you want to pass to each of those functions. One possibility is you can maintain the underscore as representation for a blank. At some point you might want to swap over and use the capital letter that you've chosen to replace it with. You also have the option of using a lowercase letter, and that has the advantage of, one, it tells you what letter I've chosen, but also it distinguishes the lowercase letter, which represents a blank and would score zero from the uppercase letter which does not represent a blank and would score 4. You decide which combinations of these you want and which functions you have to modify in order to successfully make the best play, the best choice for using a blank or not using it if the best play is to not use a blank in your hand to score the maximum number of points. Here are some examples. Here's the directions for what you should do. Assume that all the code is loaded, and just write the functions and maybe updates to variables that you need. Then make sure you can pass at least these tests, but you probably should try out some additional tests of your own. Make sure that you haven't broken best_play() and that it still gets the same result for the test that we did before. When one letter is a blank you actually score a little bit less, Because the A scores no letter points. Now, I've chosen to show here the lowercase letter to indicate where the blank is played, but your function that returns best_played doesn't necessarily have to return a representation like that. It could have returned a blank character there or something. As long as we know that the score is correct and the best play is correct. When there are two blanks, we could have continues to create BANKBENCH with two blanks in it, but it turns out that another play-- making KiCk and taking advantage of some triple bonuses scores higher. Here is my solution to the blanks problem. What I've decided is I'm going to represent blank tiles by the lowercase letter as long as I can--keep it in there up to the moment when I place them on the board. Here is the list of points that we had before, the points dictionary originally had a value of 0 for the underscore character. I've taken that out, because I'm not going to use the underscore character. I'm going to immediately translate the underscores into a lowercase letter. I have to figure out what are my lowercase letters? I get them by lowercasing the letters I already had, and then I went through the lowercase letters and I said the point value of a lowercase letter of a blank used as that lowercase letter is zero, updating the points dictionary. Now, my plays are going to be words that include lowercase letters in them. The best play might be something like this where we have the score, the location, the direction, and the word includes a lowercase letter. Because I've taken that approach and because I've defined the value of a to be zero, it turns out I don't have to change calculate_score at all. I can leave that alone. The only things I need to change are find_prefixes and add_suffixes. Let's look at find_prefixes. A lot of it is the same, but there are two places where I make a change. First, here before I was checking to see if the input pre was a member of WORDS or a member of PREFIXES. Here I created the new variable capital PRE and ask is that in the WORDS, because the thing I'm going to be passed in could look something like that. It could have a lowercase a in it, and that's not going to be in my dictionary of words. So I have to uppercase it before I can test. Like before, I test to see if I'm in the words. Then if I have a good prefix, then I go through my letters in the hand. Here's the second change. If the letter is a blank, then I go through all the possible lowercase letters, and try to find a prefix by replacing the letter, taking out the blank from the hand, and adding on the letter C onto the prefix. Otherwise, I just do what I did before. If it's not a blank, I remove the letter L and add it onto the prefix. That's find_prefix--very simple change. Now for add_suffixes. Again, two very similar changes just like we saw before. When we're looking up in the dictionary we have to look up an uppercase version of the prefix rather than the original prefix. While we're going through the hand, first we have to say is the letter one of the possibilities, one of the allowable results for the anchor. If that's the case, then go ahead and just use it. Otherwise, if we have a blank anywhere in the hand, then it's possible to use that at this point. We consider all the possible letters that might occur in this point. Before we iterated over the letters in the alphabet, but here we're iterating over the possible acceptable letters that the blank could stand for, and for each of them take away the blank, add on the prefix, but make it be lowercase to indicate that this is going to be represented by a blank. Let me just reformat that, because it's going off the page. This homework is to play the word game Boggle. Now, Boggle is played with a set of letters that are arranged into an n x n grid--here 4 x 4-- but you should accept other size as well, and your task is to find all the words that can be found in this grid. Now, you can simply take ones across, so PLAY would be a word. They don't have to go all the way across. So LAY would be a word as well. They can turn corners and go in any direction. Starting at T we could go T-O-W. We can continue from there T-O-W-A-R-D-S, and in general we can go to any adjacent square horizontally, vertically, or diagonally. We can't duplicate, so H-I-S is a word, but we can't do H-I-S-S, because S is not a neighbor of S--so HIS but not HISS. We could do S-I-R, but not S-I-R-S, because each letter can be used only once. We can't come back and repeat on ourselves. Now I'm going to ask you to write the function boggle<u>words(),</u> which takes as input a representation of the board, like this, and a minimum length of the words that count. Three-letter words at least. Two-letter words don't count, so don't both returning them. It returns a set of words, which again are taken out of our WORDS dictionary. Now, because I'm going to pass in the board, I have to give you the representation for that. I'm going to make a slightly different choice than I did for Scrabble boards, just to show you the range of options we have for representing two-dimensional objects like this. Now, we're trying to represent this two-dimensional array, and in Scrabble we chose a representation like this--a nested list of lists. If we assign board to this list, then we can access an element with two integers subscripts like that. In our representation of Scrabble, we also made a small change so that we didn't have to worry about going off the board, which is that we introduced these border markers-- the vertical bars to mean a boarder at the ends of every row, and we also had a top row and a bottom row which consisted entirely of bordres. It's as if we took this game here, and we just extended it by making a border all the way around. This 2D representation would work fine in the Boggle case, but I just want to show you another possibility, which is a one-dimensional representation where instead of saying board[ j ][ i ] for position we only have to say board[ i ], and we get that representation just by concatenating together all the elements. We take all the elements in the first row and then add onto that list all the elements in the second row, all the elements in the third, and so on. Now we have a one-dimensional array. Why is that better? Why is it better to have a one-dimensional array to represent an inherently two-dimensional object? Seems like a step backwards. Well, one thing is that now we can have a position in the array represented by a single object, by an integer, rather than by a pair of integers that have to be broken up to subscript into the board. That's one advantage. Secondly, it's easier to enumerate over them. We can just say "for (i, s) in enumerate(board)"--remember enumerate takes a sequence and returns the elements of the sequence in turn. That would be the s's--the contents of each square, which would be the letters like P and L. And also an index into them--the integer i, which would be a integer 0, 1, 2, and so on. It's easier to enumerate over the entire board in this 1D representation rather than in the 2D. Both representations work fine, but I wanted to give you a little experience using this alternative. Let's do an example of this representation. Here's a simple board. It looks like that. Now we want to add on border cells, so we'll do that all around. It looks like that. Now, we just put that together into a string, and so the final string would look like this. Now, in terms of the indexes into the array, right here would be index number 0, and we could just enumerate them out. Since it's a 5 x 5 array, the indices go from 0 to 24. Now, let's say we want to find all the neighbors of this central square, the W. So the neighbors would include basically all the letters here would be a neighbor of W. The index of W is 12. If we say that the length of a side of this matrix--we'll call that N--is equal to 5, now we want to know all the neighbors of a cell. Let's say we're looking for the neighbors of i = 12, then it's 6, 7, 8, 11, 13, 16, 17, 18. Here is i--11 and 13 are easy. That's i - 1 and i + 1. The 7 is just i - N. The 17 is i + N. Then you can fill in the others. You see starting from i, it's easy to generate the eight neighbors just by adding and subtracting Ns and 1s. It's a little bit simpler doing it this way than it would with the two-dimensional representation. Here's what I'm asking you to write--this function boggle<u>words()</u> given a board and a minimum length for each of the words returns a set of words. Here are some test for you. First the board function, and I've written that so don't worry about it. We'll see it below. Here's a simple test--not many words you can find in there. That should be the whole set. I've defined for you a function neighbors, which takes a square location-- square number 20 in a 6 x 6 board--and tells you want the neighbors are. Then here's an example of playing this word game. Here's the set of answers, and for this bigger board with more letters on it, there is 317 words in our small dictionary that was found. Here's our representation of board, using the single string representation that I talked about. Here's a simple function to display that. It doesn't actually print it, but returns a string, which is easily printable. Then this part--the words and prefixes--you might find very useful. That's unchanged from before. Here's my answer. I chose to do it as a single function, which has an embedded function that it calls. There are two parts to this. We have to first iterate over all the squares in the board. Then for each of the squares of the board, we want to find all the paths that generate words and follow all possible paths but cut them off when we have to stop. Here I said we can enumerate over the locations and the letters that are in the board, enumerate over them if the letter is not a border character, then we want to extend the path starting with that letter and that location. Extend_path says I have a prefix so far, which may or may not be a word, and I have a path where path is defined as a list of locations that I've visited so far, and I need that because I can't have a path circle back on itself. I can't use a location twice, so I need to know where I've been before. This is similar to the structure of find_words, but it's constrained to looking on the board through the neighbors. So what do I do? I say if the prefix is in the words, I've already found a word, and the length of that prefix is greater than the minimum length that I'm looking for, then I add it to the results. Here that won't have happened because I'm just looking at the first letter-- say the letter P in location i. That's not going to be a word. It's not going to be greater than the min length, so I keep going. If the prefix is in my set of prefixes, then I look for every neighboring square j, which is a neighbor of the last element of my path, so my path is going to be I start in this location, go to the next location, go to the next location. The last element of the path is where I was last. I want to expand out from there to all the neighbors. If that j is not in the path, if I haven't circled back yet, and if the contents of that j is not a border square, if it is a valid letter, then I just extend the path. I add that letter onto the prefix. I add that location onto the path and continue, recursively call, and eventually I'll add all the possible words. Now, part of the Zen of Python is that flat is better than nested. Why did I nest here? Well, it's a judgement call. You certainly could have pulled this out, but if I did pull it out, I would need to pass in this parameter N, the board, and the result. There'd be three more parameters that I'd have to pass in, and I just though it seemed a little bit simpler to only have to call it with two--here and here-- and only receive two here, rather than add in those three additional arguments. I guess I should say because extend_path is only seven lines long, I felt it was justified to have it be nested. If it grew much more than 10 lines, then I'd be very reluctant to have it be nested. I would probably pull it out. Hi. This is the Python glossary. There's going to be a lot of new and potentially confusing functions and techniques that we use in CS212. When that happens, I'm going to try to record something to help you all out. This is the place where I'm going to post that. I might not be able to get to every single function that's covered in the course, but if there are any that are particularly confusing to you, you should let me know in the forums. Remember, if there is anything that I don't cover, you should check out the Python or just do a search. The set is an important tool in Python, and today we're going to talk about it. A set in Python is simply an unordered collection of elements with no duplicates. This unordered and no duplication--these are important clauses. The sets used by Python are just a programmatic version of the sets used by mathematicians. Let's talk a bit about set theory. Let's say we have a basket of fruit, and let's say it contains 5 apples, 3 oranges, and 2 tomatoes. These I suppose would be the apples or maybe the tomatoes, but we don't have to worry about that. If we want to represent this as a set, we wouldn't care about this quantity. The fact that there is 5 apples doesn't matter. In fact, I could just write apple, orange, and tomato and label this set "fruit." The elements of this set "fruit" are simply the entries apple, orange, and tomato. Let's say we also have a set called "vegetable." Some of the elements in this set would be broccoli, carrot, and tomato. When I was coming up with this question there was some heated debate in the office about whether tomatoes are fruits or vegetables. Let's just include it in both. That means that when I draw the circle that encompasses this set, it actually has an overlap with the set fruit. In set theory, this overlap is called the intersection. I'm going to mention these set theory terms, but you don't have to worry about them too much. This diagram I've drawn here is known in set theory as a Venn diagram. They can be very useful for visualizing what's going on with sets. Here comes the interesting part. We can create new sets by taking subsections or performing operations on these sets. For example, if we want to know what elements are fruits and vegetables, which like I said before is called the intersection, we could write "Fruit &amp; Vegetable," and we could see the only element would be tomato. I should point out that this symbol and the other symbols I will be using are not what we usually use in mathematical set theory, but since they're what we use in Python I'm going to be sticking with this convention. We could also ask what elements are fruits but not vegetables, which is known as the set difference. The only element that are fruits but not vegetables are apple and orange. We could ask which elements are fruits or vegetables. Here I've used the vertical line to indicate that. This would give us all of this entries. All of these entries are either a fruit or a vegetable or both. The last operation I'm going to talk about is asking which elements are fruits or vegetables but not both. This is known as the symmetric difference. Here we've used the caret to indicate that, which is not the same as this carrot. This is just all of the entries except for tomato. Okay, so now that you've seen an example, let's do a quiz makes things a bit more general. For this quiz we have two sets--A and B. A is represented by the blue circle, B by the red. I want you to match the set operation, and these are the four set operations. to the appropriate Venn diagram. I've shaded in in each of these diagrams a section, and that section corresponds to one of these operations. I want you to enter the appropriate number into the appropriate box. This is the answer. A minus B corresponds to 3, because this is all the elements that are in A but not B. We haven't filled in this area. A or B is number 2. All of the elements are either in A or B. A &amp; B is number 1. I filled in this middle area corresponding to both sets. The symmetric difference of A and B is 4. All the elements that are in A or B but not in both, and I've left out this region. Okay, so now that you understand the basics of set theory, we can implement this in Python. If we want to define the set Fruit like we did before, we can write the following, and when I print Fruit I get the following. Notice that I could have included apple twice, and when I print I get the exact same thing because sets don't take duplicates into account. I can also print the set Vegetable and notice that the order that I defined this set in is not necessarily the order that it gets printed in. Sets don't care about order. Once we've defined these sets, we can check for membership. For example, maybe I want to know if apple is in the set Fruit, and when I run this statement I get a true. Apple is in Fruit. Sense apple is not in Vegetable, this statement gives me False. For a quiz, what's going to be the output when I print this statement: fruit--with a vertical bar--vegetable? Select the best option. When I run this, we remember that this is the or operator, so we get the set that is all of the elements-- tomato, carrot, apple, orange, and broccoli. Great. Now I think you have a good understanding of what sets are. This is a powerful programming tool, and we're going to use it throughout CS212. There are other set operations, which you can read about in the link below this video. Unit 1 introduces a lot of new list methods that you may never have seen. Let's talk about count, sort, and reverse. List.count(x) returns the number of occurrences of x in the list. Here we've just called it list. The way you would use this is you would write the name of your list here and whatever element you want to count. I should mention that I've basically taken this description straight from the Python documentation. List.sort sorts the list in place, and I'll talk a little bit more about what "in place" means later. List.reverse does what you would think. It just reverses the elements of the list, and again it does so in place. Now, let's try using these methods. Let's define a list of the Udacity professors. In this list I've included all of the professors of the six classes, and you'll see that Dave's name comes up twice. This is because Dave teaches two of the classes. Also, it makes this problem a bit more interesting. Let's say we want to know how many times Steve's name shows up on this list. For this example, it's pretty easy to count ourselves, but let's have Python do it anyway. We'll define a variable called "steve_count" and set it equal to this. Here the name of our list.count, and I'm counting the occurrences of Steve. If I print steve_count, I get 1--just as I'd expect. We could also count the number of occurrences of Dave. When I run this I get 2, as expected--Dave and Dave. Okay, now let's see what happens when we sort this list. We'll define a new variable called "sorted_profs" and set it equal to udacity_profs.sort. When I print sorted profs, I get None. Wait. What happened here? I would have expected a sorted version of this list, and this is where that "in place" comes from that I was talking about before. Methods that work in place only modify the existing list. They modify udacity_profs. They do not create a new list. In fact, since we've just sorted udacity_profs let's see what happens when we print udacity_profs. Now you can see that they've been sorted in alphabetical order. Isn't mutability just wonderful? Now, poor Wes is alway at the end of these sorted lists. Let's give Wes some love by reversing this list. Just as we'd expect, this is the same list but sorted in reverse alphabetical order. There is plenty other Python list methods. Feel free to check out the link below this video to see them. We saw generator expressions and functions in Unit 2, but some people in the forums still seemed a bit confused. Don't worry. This is understandable. The generator is an entirely new object, and it can be confusing. In the next few videos, we're going to answer three questions. How do we use generators? I think this is actually an easier question to answer than the second. What is a generator expression/function/object? We'll also talk about when and why do we use generators? Let's start with a problem. We want to compute the sum of the squares of the integers from 1 to 1 million. That would be 1 + 4 + 9--and I probably shouldn't write all of these out. The question is how would you do this? If you came from CS101, your answer is probably to start with a function. Maybe your function would have looked something like this where we make an empty list, append all of the squares to that list, and then return the sum of that list. Then you would have called your function with an argument of 1 million, and you would've gotten your answer. First let me say this is a find solution. It gets the job done, but it has some problems. Keeping in mind that we just want to make this calculation once, what do you think is the biggest problem with this solution. Do you think it's messy, and it unnecessary clutters up the program? Do you think it uses memory when it doesn't really have to? Do you think it runs to slowly? Or do you think the code doesn't work? You may have several problems with this, so it's somewhat subjective. Just choose whatever you think is the biggest problem. For me the biggest problem is that it's messy. Why would we want this function hanging around, clogging up our program, if we're only going to use it once? We're going to rule out function as our best solution, because it was a bit too messy. But we learned in week ione that we have this incredible toll called the list comprehension. Let's try that. Using list comprehensions, we can solve this in one nice, elegant line of code. This solution creates the exact same list that we created with our function, and then it spits out the sum. Not bad, but it's not perfect. What's the biggest problem with this solution? Choose the best of these four answers. And for me the problem is that this solution uses too much memory, uses it unnecessarily. We quit this gigantic list with a million elements and actually a million and one elements and we don't ever use it again. We just use it once to calculate the sum. That seems like sort of waste to me. And this is exactly the motivation for generator expression. We don't want to create list that we're never going to use. So if we want to solve this exact same problem with the generator expression, it's a simple as converting brackets to parenthesis. Actually, we could do away with one set of parenthesis here but I'm going to leave them in and running gives the exact same result. Interesting aside here since range is actually creating a gigantic list as well, we can use Python's built-in xrange function-- basically, this prevents us from generating this entire list. Okay. So now we know how to use generator expressions. Let's poke around a bit and figure out exactly what's going on inside of them. Okay. Let's just run this. I was getting sick of writing out 1,000,001, so I'm just going to do 11 now. So you see when we run this, we get what's called a generator object. It says "genexpr," and that's a memory location. We've created a generator object. Let's see what we can do with it. Let's actually make an assignment here. Now g is this generator object, and basically all it means to be a generator object is that this object can be iterated over, which basically means we can call this next function on it. If I call next on g, hit enter, I get zero. That's zero squared as I would expect. If I do it again, 1, which is 1 squared, and so on until i get to 10, which is the last number is my range, and then of course stop iteration as you saw in class. But next isn't the only function that does this sort of iteration. Let's reassign g, because now that we've gotten to this stop iteration g is sort of spent. So we've reassigned it, and let's take the sum of g. Sum performs the iteration for us. We could also do a for loop, and that does exactly what we'd expect. How else can we get one of these generator objects besides using a generator expression? Well, we can define a function. This function "gensquares" does the exact same thing as our previous generator expression. Note this yield statement. This is interesting. This is what makes it a generator function and not a normal function. Of course, if we call gensquares right now, we'll see that this is a function. But the reason why it behaves differently is because of this yield statement. Basically, the main difference between yield and return is that when a generator reaches a yield statement it suspends execution and remembers the state of all local variables. That's really important. This memory of the local variables allows it to pick up where it left off when we call, for example, next on it again. So we have our generator function. How can we get a generator object out of that? Well, we just have to call the function. Let's call it with an argument of--I don't know--let's say 11. There we go. There's our generator object. Just like before, we can call next. Here we get zero as expected. If I call next one more time, what do you think the output will be? Do you think the output would be 0, 1, 4, or 121? The answer is 0. The reason is because calling gensquares on 11 actually made this object again. So we've sort of reset everything and calling next just gives us our first item, zero. If we want to keep incrementing--0, 1, 4, and so on-- we'll need to make an assignment. Now we've assigned G to this generator object by calling gensquares. I can find next--0, 1, and so on. Just like we expect. We decided that the function was too messy to solve our original problem. List comprehensions were okay, but used a bit too much memory. The best answer was really the generator. We showed how to use a generator expression and how to use a generator function. The generator is a really powerful tool to add to your arsenal of Python techniques. I hope that you understand it a little better than you did before. The purpose of this segment is to talk about scope which is a concept that we've been using in the course but haven't actually talked about specifically And so if you've been getting confused by decorators which decorate decorators or functions, calling functions, return functions, and so on, this video is for you. So when we talk about a variable scope, we're talking about the region in the program in which we can access that variable. This is a concept that can go from being very simple to quite difficult. So let's start with something basic and build from there. Here we've got some very simple code, x=2, y=3, print the sum and of course, we get 5. In this example, x and y are what's called global variables and then later what we call the global environment which I'm going to represent with this box and in this environment, x is bound to the value 2 and y is bound to the value 3. The global environment is also where all our primitive operators are bound. So for example the plus sign is bound to some object which carries out addition and we won't go into too much detail about what's going on there. So let's make things a bit more interesting--so here I've just defined a function called add_nums and it returns x+y and when I run it, I get 11. So what's happened here is that our function has created a new scope and this scope is local to the function and so what happened when we defined add_nums was we made this binding between this name and the function object. Now that's fine but as soon as we call add_nums by saying print the result print add_nums, we created a new environment Now I'm going to call this environment add_nums, and in this environment, we made an assignment. There are two assignment from x to 5 and from y to 6 and when we call add_nums, Python prefers to choose variables within its local scope. If it can do that, it then moves up following this pointer to what's called its enclosing environment since this add_nums environment lives inside of this global environment and lives there. If after following all these paths up into the global environment, it still doesn't find the variable it's looking for that's when we get an error-- specifically a name error. Now let's see if we can maybe break Python. I don't think I can, but I'll give it a shot. And I'm going to try and break Python by taking out this assignment, so now only the y assignment is made inside the function add_nums. And I'm going to ask you a little quiz here. In my quick run, am I going to get 8, 5, or name error. Well, let's see and the answer is 8. So here what's happening. Python is looking for x and y. It finds y inside the local scope of add_nums. It doesn't find x inside that local scope so it moves up into the globe of variables and it finds x there. It makes use of it--6 + 2 is 8. Okay, so this is fairly basic so far. What is all this have to do with CS212. So in Unit 3, we introduce this memo decorator and the question that's still popping multiple times in the forums whereas how can a memorize function or specifically, how can multiple memorize functions all maintained their own separate cache when it appears that cache is defined here and so let's talk about that. And as a reminder, memo gets past the function f and returns a new function which we've called _f that contains this cache and this cache basically prevents us from repeating calculations, and so the best way to learn anything in programming is still do some experiments. So I've written a couple of simple functions here filled in square. Just as a reminder, let's take a look at what our main space or our global environment looks like like now. And now what we've done is we head to the global environment bindings between memo and its respective object and likewise, we filled in square. Know that we haven't created any new frames yet, any new environments because that doesn't happen until we actually call a function and we haven't called any of these functions. All right, so what I'm going to do now is I'm going to memorize these functions by adding the memo decorator and remember, this is the same--adding this decorator and memo is the same as saying fib equals memo of fib. This is just some nice syntactic sugar to put on the element, looks like a little nicer. And so before we start calling fib and square, I'm going to introduce this print statement into memo so that we can try to get an idea of what's going on. So here I'm going to print fib(4) and we can see the cache getting updated as we would expect. By the end, we will get the result 5 and also have this dictionary contain fib(3), (2), (1) and (0). So the cache is behaving as expected. Let's see what happens if I run now while making to print commands to fib(4) and this is interesting. The memorization now occurs in the first print statement in the first time we make these calls. By turning at the second call to fib(4), we already have our cache. We don't have to do all of these calls to fib. We just get 5. Great! Now, the big question--is this cache the same as the cache in the square function up here. You've probably have a good guess at the answer but let's just confirm. So same thing except when we call square twice and you can see, when I call square the first time, it's not telling me that the cache is the cache associated with fib-- telling me it's empty as we expect, and when I call the second time, of course, we're all set. We have this mapping 4 to 16. Good. Now, how does this happen? Well, the trick is--a new environment isn't created until we call a function. So what happened here is we called memo and we set at_memo--so when we said at_memo of fib, we created a new environment what I'm going to call memo. In this environment, there was a binding from fib to the associated object. Actually, since I didn't do the update wrapper step that we did in class, this function name is actually still called _f, but again no separate environment for _f yet because we didn't call it yet. Likewise, when I plugged the decorator to square, a new environment was created with its own _f though this one points to the square function object. I almost forgot the important part--both of these have their own cache. Now, when I called fib, that's when this environment was created, and when we called fib, that's when we created this new environment. And we can see that when fib goes looking for cache, if it looks in its local environment and doesn't find one, it moves one step of the hierarchy, finds the cache associated with this call to memo, uses that, and doesn't care at all about this cache over here. Just because these have the same name, they live in totally separate environments, and since fib only has access to everything over here and square could only access everything over here, there was no correlation, no conflict at all that these both have the name cache and we can use the memo decorator exactly the way we want to. Thank you Python. Now, this is a lot to cover in a few minutes. If you're still confused, feel free to check out the links below on scope and closure, which is the topic that we didn't get to today--good luck.