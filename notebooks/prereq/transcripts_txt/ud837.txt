Welcome to the coffee break challenge. During this challenge I'm going to ask you a series of ten questions. If you get the question correct be sure to check the question feedback. It'll give you a clue that you need for your final prize. Now there are no answer videos for these questions. So you can't really cheat, but hints are provided in the instructor notes if you need help. All right. Let's get our mental loading bar on the screen. As you complete questions, the loading bar will get filled. When it's full, you've completed all the questions. Okay. First question. If I want to show a picture on my phone, what XML element should I use? You can put your answer here. Okay, good job. Next question. Android:layout_width, android:text, and android:src are all examples of what? You can put your answer here. You're doing well, but we're just warming up. Next question. Write the sentence, I like practice sets the best, in camel case. Put your answer here. Okay, good work so far. Next question. Relative layout and Linear layout are known as what? You can write your answer here. Nice. Next question. I always need to blank and blank my tags. Write your answers here. Alright your halfway done, let's go on to the next question. What are the names of the two instructors? You can put your answer here and here. Any order is fine, just spell them correctly. Alright, great work. Let's do some coding questions. Look at the code here. One of these lines has an error on it. Find the line with the error, and write the line number here. For example, if you think the error's on this line right here, then you can read the line number here, which is six, and enter the number six here. Hint, it's not on line six. Alright, hopefully that wasn't too bad. Let's do another coding question. Look at this code and tell me, what is the width of the text view? You can put your answer here. All right, you're onto the final stretch. Let's look at the next question. Here's some code with two attributes missing inside of the button tag. Complete this code so that the button is positioned here on the phone screen. Excellent work. All right, final question. Assume you are using the XML to the left and you have a screen that has 600 dp tall. What is the height of the ChaiTea text view? Write your answer here. Woohoo. Excellent work. You are done! But, consider you've been collecting all these clues, I've got one final little question. So tell me. Who am I making this coffee for? You'll need the clues to get the correct answer So, Katherine, we've been working on this course for a while. I know, Kunal. And it's about to launch so I'm really excited. Right. It's been a couple of months that we've been designing this course, and I want to be in perfect synch with you. Okay. Around who the learner or the student of this course is. Yeah. So I think the learner is someone who's never programmed before. Wait. When you say never, you mean no lines of code. Zero. Zero lines of code. Yeah. Wow that's going to be a tough course for us to design but it's going to open up the gambit for everybody to take this course. Absolutely. I think that's why it's so powerful. because at the end of this course, I think they should be able to build a couple of simple Android apps. Wait, let's backtrack a little bit. So, we're saying no lines of code, no programming experience but we're still saying you need a computer and you need an internet connection. Yeah, and to have some familiarity with using a computer and a smart phone. So you browse the internet let's say on a smartphone or a computer? Yeah. Okay, well let's say this is where the student is right now, right? And this is where a professional Android developer is, right? This is where they're making apps, they're making money, they're changing the world. Let's say this is where we will get them at the end of our course. I think we can get them to here. Okay, so in this journey that the student is taking with us, what sort of apps are they building here? Yeah, so the first app is a birthday card app. Wait, you said first app, so there is more than one app? Yeah, so first there's a birthday card app, where they can make it for someone that they love. I like that. People have birthdays. Sometimes they even have half birthdays. [LAUGH] Yeah, and the second app should be a coffee ordering app. So you say, I want two cappuccinos, and two cappuccinos appear magically from the phone? Not quite. But it captures what the user wants to order and then it sends it off in an email. Okay. So in this journey that we've been sort of dreaming up, how long will it take the student so they can budget their time appropriately? Hopefully, 20, 25 hours. I think that's about right. It'll take a lot of deliberate practice. They'll make a couple of fun apps. But what they can do is they can take this 25 hours and split this up into 4 or 5 weeks worth of their time. Yeah, I think that sounds good. So that's as much about the course and about us. At this point, I want to ask our students a question. Tell us about a time when you were learning something new and you had to struggle. Okay, Katherine, if you're going to ask our students to share their vulnerable stories on the Internet. Yeah. We have to lead by example. Okay, fair enough. You go first. Okay. [LAUGH] Well I've been learning to play the piano for about eight months. Oh okay. And the toughest bits for me have been getting one hand right and then getting the right hand right and then putting those two things together. But, when it comes out just so beautiful its like [SOUND]. Oh, that sounds really good. I've been playing with my friends, it's really fun. Wait, you haven't played for me. Well, we'll see if we stay friends till the end of this course Okay, then. Your turn. I've struggled with learning Chinese my whole life. Wait, you speak Chinese? Yeah. [FOREIGN] Wow. It's no big deal. [LAUGH] So, I think the hardest part of learning Chinese has been trying to learn all the vocab words and trying to put them together in complete sentences without tripping up. You know this story of yours is reminding me that learning how to make an Android app is like learning a new language. Okay, I could see that. So, you're learning a new vocabulary, and you're putting those things together, and programming sentences, and creating an app. Mm-hm. Okay, well those are our stories. Now I want our students to share their vulnerable stories. Tell us about a time when you learned something new and it was a struggle. Okay, we just signed up for a lot. We have so many things to teach them. What should we cover? Hold that thought, I need something. Where are you going? Here, this is for you. Thank you. Let's just pour out some beans. What are you doing? Well these are not our bean but lets imagine they are for a second. Okay. Okay. I just want to create a little coffee trail which is going to be a symbol of the journey our students will take with us. Okay, I like that. So let's just say this is our student and this is where we are beginning. Oh, and this can be where they end. Right, which is where they are an Android developer, right? And we're focusing on just this part of our course right now, so this is where we are. So I'm just going to clean it out and zoom in into the main part of the course. Okay, well, let's say there are three big lessons in this course. Only three? Let's say there are three for now, yeah? Okay. So, this is lesson one, two, and three. Let's talk about lesson one. I'm just going to zoom in there and clean up the dust,yeah. Well, I'm going to split this further into three sections, and you might guess what my favorite number is at this point. Which is? Two. Three. [LAUGH] Okay. [LAUGH] What is the first thing we should do in lesson one? I think they should learn about views. Oh, views, things that you see on the phone, so like a check box, a radio button, an image, a text of some sort. Yeah, exactly. So we introduce them to that here. In the second part of lesson one- Then they can learn to customize those views. Oh, okay, so you're changing the color of a font or size on an image. Exactly. Then this part three, we should teach them how to position views on a screen. So it's like bottom left or top right or where is it going on the font screen. Yeah. Good, so let's begin at the beginning. The first thing in Android you need to know is something called views. Views. Step one is about picking the views that you want to use. First I should explain what exactly a view an Android is. Simply put, a view is a rectangle on the screen that shows some content. It can be an image, a piece of text or a button or anything else that the app can display. Now these individual views make up what we call the layout of the screen. Everything about what you see and interact with in your app is called the user interface, or UI for short. There are different types of views with different names. A view that shows some text is called a TextView. Here are some examples. A view that shows an image is called an ImageView, and these are some examples. A view that shows a button is called, well, a Button. These are some examples. Now, there are many other types of views in Android which are really helpful to use, but we're going to focus on these three first. Earlier I mentioned that every view is a rectangle on the screen, but where are all the rectangles? Well, technically they're invisible, but I will draw them for you so you can see where the bounds of each rectangle is. As you can see, every app can be broken down into the individual view that make it up. In other words, a view is the basic building block that you use to build up the layout for your app. To help you understand the idea of views being rectangles on a screen, here's a situation you may be more familiar with. If you ever use an application like paint or Google drawings then you may have added a text box to the canvas, then you type in your text. If you click outside of it though, you don't see the bounds of the rectangle but they are there. And bounds actually do start to matter when you start to do things like adding a background color or adding a border around it then it does matter how big the rectangle is. I also want to point out that the format of these view names is in camel case. Camel case means that there are no spaces in-between words, and the beginning of each word is capitalized. The reason why it's called camel case is because the outline of the word goes up and down like the humps of a camel's back. You're going to be seeing camel case more throughout this course. Okay, let's practice what you learned. This is a screen shot of the new email app from Google, called Inbox. Can you identify the different types of views here? To help you, I've highlighted the individual views. For example for A, can you tell me if it's a TextView, an ImageView, or a Button. Do the same for B, as well as the rest of the views. Let's go over the solution together. First, at the top of the screen, we have this blue envelope with a check box. This is an image, so this is what we call an ImageView. Next, we have these three pieces of text, and they're three different text views, because they each have different font styles in terms of font size and font color. And they're also positioned in three different places on the screen, so we mark these as TextViews. The last one here is a button that the user can tap to sign in, so we choose Button. Good job if you got those answers correct. But if not, no worries, we're going to practice some more. Now, you know about a couple of different views, like TextView, ImageView and Button, that you can use when making Android apps. But now, I have another challenge for you. The YouTube challenge! Okay. This is a screenshot of the YouTube app when you first come into it. Look at it for a moment and can you imagine where the view bounds would go? You can pause the video while you think for a second. Okay, so this is where I would draw them and now I want you to identify whether each of these views, is it TextView, an ImageView, or a Button. Okay, so looking at this screenshot, there are two TextViews at the top, and I can say this because they have two different text styles. For example, this one is a little bit bigger and a little bit bolder. And now we have the YouTube logo which is this red icon, and so we use an ImageView to display it. And then, last but not least, we have two buttons at the bottom that you can tap to skip or go to next, and we're done, so we can move on now. Hey Kunal, what are you doing? I just need a minute. What you writing. Well, why are you looking at my email? I just want to see what you doing. Okay fine. I'm sending an email to a friend to- Okay. Which has instructions on how to feed Chloe. Who's Chloe? Chloe's my office plant. You name your office plant Chloe? Yeah, Chloe for chlorophyll. Clever. [LAUGH] Look, here it is. Okay. You know what this reminds me of? What? These instructions are similar to how you write code to tell a computer what to do. Everything reminds you of how to write instructions or code, Katherine. [LAUGH] It does. But I'm serious. This time it does, it's sort of like. Like here, this line where you're saying that you need to water the plant exactly on Tuesday at 10 o'clock. Right, so when I'm giving specific instructions on Tuesdays and Thursdays water the plant. Or make sure the water is lukewarm. Those specific instructions are like writing code. Exactly. Okay. And you know how you're writing this letter in an email app? Yeah I'm using Gmail. Good choice. We also need a space to write our code. Sure. And that space is called an IDE. What does that stand for? It stands for Integrated Development Environment. I am more confused after listening to the full form of that acronym when I was when I heard the acronym. Well, don't worry about what it stands for. In Android, all you need to know is that we're going to use Android Studio. Is that on this computer? That software? Yeah, it's right here, let me show you. And this is what it looks like. Yeah. You know, I must admit that this looks a little bit intimidating. It has a lot of buttons on it. It is, there's a lot of things going on but we'll get there. By the end of the course, the students will know how to operate this. Yeah. Okay, good. Cool, so back to your letter. Okay. You know how you're using English to write this letter? Well that's a great observation. I thought you said you were not reading my email, but yes, I am using English. Okay. Well, we have to use a certain language to talk to the computer, to give it instructions. What are we using? We're going to start with XML. You know, Katherine, you're a fan of three lettered acronyms, it seems. [LAUGHS]. First IDE, now XML. What does XML stand for? It stands for Extensible Markup Language. Extensible Markup Language? What does Extensible ML do? [LAUGHS] It is a way to describe how your Android app is going to look. Okay. So we can use it to build layouts. Okay, so where are you going to place things, what things you're going to place on the phone. Exactly. Okay, well there's a lot going on in this video so let's just do a quick recap. We're talking about how writing code is like writing instructions. Really specific instructions. Right. Right. We're also talking about how we need a space in which to write that code. And that space will be Android Studio. And we also identified the programming language we will be using. Which is XML. So let's write our first line of XML. Yeah. Okay. Now we're going to start looking at code. This is going to be for the TextView, which displays text on the screen. If I write this block of code, then the phone looks like this. Now, I know this may look a little funny to you, because it's not like normal words and sentences that we're used to every day. We're going to go over this in a little bit, but first I want you to make some observations about this code. Write at least three things you notice about the code. Include things that make sense, as well as things that are strange or confusing to you. Thanks for your response, there's no right or wrong answer here. So let's talk about a couple of observations that you may have made. First you may have seen that there's these weird angle brackets at the start and end of the code. There's also this weird forward slash. But it only happens at the end and not the beginning. And then it says TextView, which we recognize because we introduced it earlier. And it's showing up in camel case format, with the T and the V capitalized. And then you might see something about android: text. And the punctuation might be a little weird here, to have a colon and then a equal sign. Then we see something that says Happy Birthday. And this is showing up like exactly how we see on the phone. So somehow they may be related. So this can be an observation as well. Then we see something a background thing some color that's darker, gray. And the TextView does have gray background, so this could also be linked. You made some good observations in the last quiz about the XML that we showed you. Now we're going to talk more formally about the XML syntax. Syntax means the rules that define what valid XML is. If you write invalid XML, then it won't even show up on your phone. This is the code for the XML element called TextView. We always start with an opening angle bracket, followed by the view name. This could be image view, button, or any other type of view. Then we have a list of attributes here, one per line. And then we have a forward slash and a closing angle bracket. There's a lot of symbols and characters here. To help you remember it, you can think of an opening angle bracket. [SOUND] And then the view name. [SOUND] And then the attributes [SOUND] and then the forward slash [SOUND] And then the closing angle bracket. [SOUND] So all together it's [SOUND]. If you miss any of these symbols, then you're going to get invalid XML. Here's the reasoning behind what seem to be arbitrary symbols. For every XML element, when you start or open up a tag, you always need to close it. It's kind of like putting a period at the end of a sentence, but for XML Instead of a sentence, you need to make sure you close each tag. Because we start the tag here and then close it right away, this is called a self-closing tag. Instead of a self-closing tag, you could have a separate opening tag and a separate closing tag. Here's an example where it'd be useful. This is for the LinearLayout view which is what you going to learn later in this lesson. But just know that this is the opening tag and this is the closing tag. The closing tag is the same, except it has an open angle bracket, a forward slash, the name of the view and then a closing angle bracket. So the difference between the opening and the closing tag is this forward slash. And you'll also notice that in between, we have two TextView XML elements. These are also called children XML elements within the parent LinearLayout. You can imagine that if you had a self-closing tag up here for LinearLayout, then you would have no idea how many children it contains. But now that the closing tag is down here, you know exactly that you have two children. In our case, for the TextView, there are no children XML elements, so we can just do a self-closing tag right away because that saves us from having to write open angle bracket slash TextView closing angle bracket. You notice that we have a bunch of additional text inside this tag. These are called attributes. Attributes are characteristics that determine the behavior or the appearance of the view on the Android phone. For example, we can think of it with this analogy. A person have attributes like black hair, and brown eyes. A text too has attributes like width, height, background, text among many others. Looking more closely at the format at each line, we have the attribute name the left hand side. Underlined in yellow here. And on the right hand side, we have the actual value. It's important to note that the attribute values should be put in quotation marks as part of the syntax for XML. Then we have an equal sign in the middle to say that the attribute name on the left is set to the value on the right. So the text for the TextView is Happy Birthday!, and the height is 75 density independent pixels. All of these attributes have default values, and there's attributes that we didn't even list here. That's because the TextView has default values for all of it's attributes. If you're okay with the default values then you don't need to set them here. You should only write lines of code here that you want to be different than the default values. For example, the default background color for a TextView is the transparent color. But, we want to set it to be a darker grey color, so that's why we have this line of code here. One more important note. Humans are pretty smart, if I write phrases like this, you probably know what I mean, even if I'm not using proper English punctuation or grammar, or even real words. However, computers are not as smart, so you need to use the precise symbols and names that they recognize, otherwise they won't know what you mean and there will be errors in your code. Here's an example. For the name of the view, we can't spell it TxtView, or Textview with a lowercase v, or text view with a space in it. These are all incorrect and the computer won't know that we actually mean TextView. if we want TextView we need to spell it exactly the same way with a capital T and a Capital V for camel case. Attribute names need to be spelled out this exact way with a colon after the android. We need to have an equal sign and then we need to put quotes around the values. One more time so you don't forget its [SOUND]. Now that we've gone over the syntax rules of XML, can you answer these questions for this XML element? First, what is the name of this XML element? Then, can you list all the attribute names separated by commas? Not the attribute values. Then, on what line number is the tag closed? To help you, I've written down the line numbers on the left hand side. The answer to the first question is that the XML element name is here, TextView. It follows the open angle bracket. Then, all the attributes are below the XML element name, and I've underlined the attribute names here. They're on the left hand side of the equal sign. They include android:text, android:textColor, and so on. If you put the attribute values, like Happy Birthday or the color/white or black, that's incorrect, because those are the attribute values, and it's asking for the names. The last question is, on what line number is a tag closed? Then we see the forward slash and the closing angle bracket on the last line, which is line 6. This means that it's a self-closing tag, because we open the text view tag here and then we close it right away. Okay, so we've seen TextView code for the first time. But it's kind of hanging out in limbo. Right, we do need a space where we can house it. Yeah, that space is an IDE. There's that acronym again. What does it stand for again, Catherine? Integrated Development Environment Right, and we are going to be using Android Studio in this class. This is what it looks like. Still a little intimidating. Yeah. I think we might need something that will help our learner ramp up a little bit easier. Right, so we've been working on developing something that is Android Studio on training wheels, in the tradition of really convoluted acronyms in computer science, we are calling it XMLV. Which stands for XML Visualizer. So you write a little bit of XML? You get to see the output. You write some more, you get to see more output. Yeah. So let's go use it. Okay. Since this XML visualizer was created specifically for this course, it won't provide all the functionality that Android Studio supports. But eventually in the problem set of this lesson, we'll get you into Android Studio so you won't need this website anymore. A link is in the instructor notes If you want to follow along. For this code, the text says Happy Birthday. So when I look at the device it says, Happy Birthday. Now let's try to change the text to Happy Birthday, Kunal. And then when I zoom in on the device preview you see that it now says, Happy Birthday, Kunal. And what happens by trying to stand the width and the height. I'll pick some arbitrary values like the 300dp for the width and 500 for the height. And now in the preview pane, you see that the TextView is a lot bigger. The text though, however, is still the same size in the top left corner. Notice that for the width and height values of 300 and 500 is followed by dp in each case. This is a unit of measure like centimeters or millimeters, that we use to describe the size of views on Android. As well as the distancing between views. The unit dp stands for density-independent pixels. Let me explain why we need that. Say these beautifully drawn rectangles represent different devices. They're the same physical size, but they differ in terms of resolution. This is a medium resolution device with a medium number of pixels on the screen, high resolution and extra-high resolution device. When I say pixel, I mean a phone screen is made up of many tiny squares, which are pixels, and they light up based on what you're looking at. So if I define the size of a view, for example, a button, to be 2 pixels tall by 2 pixels wide, this is what it would look like on a medium resolution device. On a high resolution device, it would also be 2 pixels by 2 pixels. But it's a little bit smaller, because there's a lot more pixels trying to be packed into this device, and then on an extra high resolution device where there's tons more pixels packed into this space, this button is actually pretty tiny. I can barely tap on it with my finger. I have to use edge of my finger or my fingernail to reach it. Just because I have extra high resolution device, doesn't mean I have a smaller finger. I still want to be able to tap the buttons on the screen. And that is why we have density-independent pixels. I can define my button to be 2dps tall by 2dps wide. This is what it would look like across the different devices. It is the same physical size, but under the hood Android is mapping it to a different number of pixels. You don't have to worry about any of that logic, all you need to remember is that you need to define your sizes in terms of dp values. When designing your apps, we recommend that all touch targets like buttons should be at least 48dps tall and wide. Notice that it says 48dps and not 48 pixels, otherwise it would be really tiny on this extra high resolution device. This will make your app easy to use for everyone. So with all of this knowledge, I want you to try and change the TextView code now. You're going to be writing your very first lines of XML, how exciting. So first try to change the text in the TextView. And then try to change the sides of the TextView. Then I want you to try to create an error sad face. And then I want you to undo it, happy face. All right, so first we load up the webpage that was linked in the instructor notes. We see that it's populated already with some code for the Happy Birthday TextView. And then on the right, we see the preview and the device. To change the text that appears here, we need to change the value of the attribute called Android:text. So in between the quotes here we can change the message. Can change it to, hm, Happy Birthday to my pet hamster! Then on the device, we can see that the text has now been updated, woohoo! To change the size of the view, we can modify the width and height attribute values. The in between quotations, we can delete that and change it to something like 250dp. And then for the height we can change it to like 450dp. And now, we see that the text view with the gray background is now a lot bigger. Cool. So, the last part of the quiz was to try to create an error. So, if I delete the forward slash and the angle bracket, then, I get a bunch of errors that show up on the bottom, here. Also, the device greys out, because there's no valid preview to show on the device anymore. These errors can help you fix your code, and since we know what we need to do to fix it, we can just hit Ctrl+Z to undo the changes we made. The undo shortcut is really useful to use, so it's Cmd+Z on a Mac, or Ctrl+Z on a Windows. We can create other errors as well, such as deleting a quotation mark and we see the error down here. We can hit undo to make it come back. Or we can change darker grey to parker grey, which apparently Android doesn't recognize, unfortunately. So we can just switch it back. The reason why we asked you the last question about creating an error and fixing the error is because an important skill of developers is to be able to get past errors. There's no developer who writes code perfectly the first time. If you think about it, the whole Google search product was not written in one day perfectly. It was a lot of iteration over many years, and it continues to be. So, regardless of whether you're a new developer or you're an experienced developer, in order to get to the end goal, it's not exactly a straight path. You'll run into obstacles along the way, and you have to be really creative in terms of trying to come up with other solutions to go around that obstacle. So once you get around it, then you'll run into another obstacle and so on. And you just always want to keep thinking of ways to get around that obstacle. And eventually, after a lot of work, you finally find the path to the goal, and even though it was super challenging, it was totally worth it in the end because you feel empowered and confident and just really proud of your work. So the really good developers know how to rebound from an error and continue with their work. So here are some habits and strategies that they use to debug, or fix, their errors. First they read the error message. When you're writing a document in Google Docs, for example, if there's any misspellings, then it will tell you with a red underline. Similarly in Android Studio, if you have typed XML incorrectly, then it will have a red, squiggly underline, or it will be highlighted in red. Also, in this bar on the side here, it will show you the message if you hover over the red bar. But in our XML Visualizer, there's also helpful error messages. So if I create an error, like removing this quotation mark, it will tell me that there's an uneven number of quotes and that I need to fix it. Sometimes, it also tells you the line number that the problem is on. The line numbers are on the left hand side here. So, on line six, we know that there's a problem. This helps narrow down the problem space instead of having to read through all your code and trying to figure out what the problem is. If you still don't understand the error message, try to identify words that you do understand and the words that you don't understand. You can always Google search for the words that you don't understand, or you can just copy the whole error message and paste that into a Google search. The other technique is to use working code samples and compare it to what you have to try to figure out what went wrong. We've already given you some code to look at in the last few videos, and another good resource is the Common Android Views cheat sheet that we'll provide you. Here, we see the names of different views, and we also have code snippets as well as a preview of what they would look like on the device. You can always compare your code to what we have here and see if there's any differences. The third technique is to use undo. If you're paying attention when you type, you should be able to see pretty quickly when you type something wrong. Try undoing the last few keystrokes to see if any of those fixed the error. As we showed you before, you can hit Cmd+Z to undo a change or Cmd+Shift+Z to redo a change. On Windows, it's Ctrl+Z to undo and Ctrl+Shift+Z to redo. Or in the XML visualizer, we have these nice handy buttons for undo and redo. If you really don't know what to do, you can always hit this Reset Code button, which brings you back to the original code that we gave you, which should work. The fourth technique is to just ask for help. You can reach out to other students on the peer chat in the lesson or on the forums. Oftentimes, just talking to another person will help you work out your errors. Don't be afraid to ask for help. There's a lot of really nice Android developers out in the community who are willing to help you. In fact, being able to ask for help is an important skill for developers. There are no bad questions. The more you practice the better you'll be at knowing who to ask and what to ask them in order to help you get to your answer faster. You can also take a screenshot of the work that you're doing, whether it's on the phone or in the XML Visualizer, and share that along with the code on the forums or in chat so that people know the context in which you're asking. Check out the instructor notes for more details. Okay, so here's a chance for you to practice some of those techniques. I have some code here that has errors. If you click on the link below, it will bring you to the XML Visualizer with this code already populated in there. There's a bunch of error messages, so I want you to try to read them and try to resolve the errors. Then come back and describe at least two problems that you saw. For extra credit, tell me if you discovered all four problems. Let's start by reading the first error. It says on Line 1, the Tag Text, is not a supported opening tag. So if we look at the line numbers, line 1 corresponds to this one. And indeed we see that the view name should be TextView without a space there, and it should be camel case as well. So, the capitalization is correct, but we need to get rid of the space, so now it recognizes that TextView is what we're talking about. That reduces one error. Cool. So, now, three more to go. The next error says that the tag TextView should be self-closing. This means it should end with a forward slash and closing angle bracket. So, if we check the code, there should be a self-closing TextView tag, but we only see the closing angle bracket. It's missing the [NOISE] so we add that in. There you go. And now we're down to two errors. Cool. So the next one says, The attribute androidlayout_height does not support the value 150, which is on line 4. So we go to line 4, and then we see that this code is incorrect. We may not know what's wrong with it, though, so we can compare it to the layout width line above since width and height are pretty similar. Here we set the width to be 150dp. We remember dp from our earlier discussion of it. And indeed we're missing dp for the height, so let's add dp. Woo-hoo, and now we're down to one error. And the last error says, The color @android:color/darker_groy is not supported. Did you type it incorrectly? In my mind, darker groy is not a color, but darker gray is, so that is a typo. So I'm going to erase the O, type an A, and yay, our device now updates to show a preview of the TextView. Oh, there's one more thing. This Happy Birthday text is actually spelled incorrectly, but there are no errors for that misspelling. That's because the text for TextView can be anything inside these two quotes. So you can misspell anything that you want or you can spell it correctly. It really doesn't matter and it will just show up like that. When you're creating your app, we're not checking for the rules of English, we're checking for the rules of XML Syntax. Okay, so you've had your first attempt at writing code and fixing errors. This type of experimentation is a critical part of learning Android development. Let's talk about the size of views now. We know that the width and height are expressed in DP values, or density independent pixels. This makes it look good across a range of different devices. However, there's still room for improvement in this UI. If I change this text here to be something longer, for example wait, today's your birthday? Notice the text updates here, but it wraps to two lines. Ideally it would all be on one line, because there is plenty of screen real estate on this side. The reason the box didn't change sides, is because we gave it a fixed width and height of 150dp. When you set a very specific value for width and height like this, this is called hard coding a value. It's generally considered not a good practice, because if the text ever changes like this, then it looks funny. We have to go and change the width to something like 200, so that it fits all on one line. But it would be such a hassle to keep updating the width and height, based on what the text is. You might not know what the text is until later. For example, if you have an app that's showing news articles, the title of each story may change. And you don't want your UI to break, if you have a really long title or if you have a really short title. So in Android we can solve this problem by setting the width to be a special value called wrap content. This address, the width of the TextView, so that it's precisely the width of the content inside of it. It's not too short and it's not too large. It's just right. Similarly for height instead of setting it to 150 dp, we can set it to the special value of wrap content, then the text view will update, so that the size of the text use only as tall as the text inside of it. Now, setting wrap content for height and width is very powerful, because you might have content decided on the right here, which will now be shifted over, because you don't have this excess space in the text view. And similarly, if you have other text views below this, now they can shift up to right below this first text view. Back to the news app example, if this was the story title, you wouldn't want the story description to be all the way down here, 150 DPIs away. Instead, you'd want the description to be right up under the story title. Zooming back out, let's try a shorter string. Okay, it's time for you to practice now. We want you to change a couple things with the code. Change the width and the height of the TextView to wrap content. Then change the text to be a really long, long sentence, or paragraph, so that it displays more than one line of text on the device preview. You can even type out the full birthday song if you wanted, that's pretty long. The code to get you started is linked below. So the quiz said to change the width and the height to be wrap content. Now these device don't have to match every single time, so I can set one to be wrap content and the other to be a fixed value like 150dp. And then you see it update here. And then we see that happily the text view size has now shrunk to fit the content inside of it. So, its only as wide and tall as the happy birthday text inside of it. Great. So now the second part of the quiz was to change the text that it's a lot longer than just one line of text. We want it to go to two lines of text on the device here. Let's change the text inside that quotation marks here. I'm going to pick the Happy Birthday song. So happy birthday to you, happy birthday to you, happy birthday dear Jennie, happy birthday to you. Jennie's our teammate, who keeps us on track and makes sure that we're shipping this course to you on time. Okay, so now we see that the text view, and just marked by this great background, has now expanded in height because now there's more text inside of this text view. That's pretty cool. It did that automatically without having to change the width manually. If you haven't already noticed, the text is kind of tiny on this device screen. I mean, my eyesight is terrible, so I really need it to be a lot bigger. Luckily for us, there is an attribute that we can declare to change the text size. Oh, but wait there is an error down here. It says the computer wasn't able to understand my XML. Double checking the code I see this new line that we added is actually appearing in black font, whereas everything above has blue for the attribute name and red for the attribute value. So there's something wrong with this line. Oh wait, I see it now. Forward slash in the closing angle bracket are on this side up here. This is actually a common beginner mistake to add the attribute after the tack has been closed. Technically, this is hanging out in XML limbo or something because it's not tied to an XML element. What we really want is to copy these symbols and move them down here. That's better. There's no error, and this is valid XML, and then our font is bigger. Woo hoo! It's much more readable now. Note how the text size is set to be 45 sp. Sp stands for scale independent pixels. It is a unit of measure similar to dp which makes the app look consistent across different devices of different densities. Sp is only used for fonts because it adjusts based on the user's preferences and settings for text size. Let's look at that now. Let me show you where the setting is. Go to the settings app, then tap on display, and there's an option for font size. If you click on that, you can see the different font sizes. If I click on huge, and it increases the font size of everything. So always use sp to declare your font sizes so it will scale up or down according to the user's preference. In a moment you'll change the text size of the text view. However, I first wanted to show you one thing. This is the material design spec. Material design is a new design language developed by Google to help people create consistent and beautiful apps across different devices and platforms, like web and mobile. The design specification, or design specs for short, highlights the best practices for designing your app. It provides guidance on the layout of your app, visual style, imagery, animations, and much more. There's also a section on typography, or fonts. It lists a whole bunch of information here that you can read later. But the most important thing is this guide here, that talks about the recommended text sizes. If you're displaying a really big header, you can use some of these text size values. If you're trying to do a title or some body text or a caption, you can use some of these sizes. This will help guide you on what types values you can pick depending on what your use case is. But be careful, because if you pick too many type sizes or styles in your app, it can be very overwhelming for the user. So just pick a couple of styles to display the information that you want. When you change the text size for the TextView, try a couple of these values here. Go ahead and change the TextView font size using the material design spec. And then if you're up for a challenge, you can try learning about the text appearance attribute from the Google+ Android Dev Protip that I've posted below. And then you can try this in the XML Visualizer as well. The link to the XML Visualizer with the code for you to get started is linked below. Okay, I'm going to choose a really big font, and then I'll try a really small font. So I picked display three here, which is 56sp. And remember to, add an attribute before the tag is closed. So I'll hit enter here and then add textSize attribute. Cool. And then the text is giant over here. Now I can try a smaller size, of maybe some body text which would be 14 SP, so I'll erase this and then say 14, and then it's tiny again, cool. Okay, so we finished the first task. The optional challenge was to try learning about the text appearance attribute on your own from the Google Plus protip that I included a link to. Let's open that up now. So, this is an Android dev protip that was written by yours truly, for the Android developers Google Plus page. If you haven't already, you can follow the Google Plus page for Android developers, to get the latest news on Android development. Or if you'd prefer Twitter, you can follow our account there. So basically in this short pro tip, I talk about again how too many font sizes can be visually distracting for your user. So you can use the recommended font sizes in the Material Design spec, or you can also choose from a standard set of type sizes, provided by Android, which is small, medium and large. So instead of text size, you said the Android TextAppearance attribute to be androidTextAppearanceLarge, or you can set small or medium. These TextAppearance values map to these SP font sizes. So with these ever changing Android then your code will automatically get the new value. Using text appearance is grea,t because you don't have to worry about specific SP values, and you can still be consistent with other apps on the device. For example, for a title you can use large, for a list item you can use medium, or for a caption you can use small. So these are good buckets to work with. You can try the mat in our code by copying this line here. You can use cmd+Ccor you can use ctrl+c if you're on a Windows machine. Go over to our code here. I'm going to delete this text size line, because we're going to add text appearance. Hit command V or control V. So now android text appearance is text appearance large. And you can see that the preview has updated to have the larger font size. That's pretty neat, right? And you can also change this to be medium or small. So in general, this is really useful to know, if you don't want to declare specific SP values. So if you have no idea which SP values you want to use, you can just pick from small, medium, large. You are doing awesome let us look at one more thing you can change. Notice how this says android:color and it says darker grey. I want to change it to something like black. Or maybe something like white. And we see the device updates on the right here. How about if we change it to my favorite color? Blue. Hm, so it does not exactly work because blue is not a supported color. There's a limited set of colors provided by Android, but you can still access a whole range of other colors by specifying the exact hex color code. You can find those, again, in the material design spec for color. So each of these colors is given a name from the material team, like 50, 100, 200. So let's choose this blue here, and double click to copy it, and then go over to the code, and then instead of blue, I'm going to replace this with # and then the hex color code. Cool. So now the background of the text view is this blue color. It looks pretty nice. So now you might be wondering if you can also change the text color. And yes you can. So add it right here. Android textColor =, and I can specify in quotations the hex value. So go back to the color guidelines and pick a random color. I like green, so this color will do. Copy that and then paste that here in between the quotes. #, and the hexcode. Cool. Now the device shows the green text color on the blue background. Now it's your turn. Change the color of the background and the text of the TextView to two different colors from the Material Design spec. This is linked below, as well as XML visualizer that has your starter code. Have fun. Okay. So hopefully you picked some colors from the Material Design Color Palette. I like this purple 500 color, so I'm going to go ahead and copy it. And I'll go over to the code and then change the background color to be # and then the hex code. Then the background of the textview updates to the purple color. Cool. Now let's change the text color and I write android:textColor with a capital C and then put double quotes. Okay so, then I'll go back to the color guidelines and pick something like maybe this yellow looks good. Over here and then paste it in between the quotes. Oops, I forgot the pound sign, and it says this color is not supported. So, I need to put the hashtag symbol in first. Cool, and then we got yellow text on a purple background. It looks pretty awesome to me. We played around a little bit with TextView. And the other view we want to learn about now to make our birthday card is the ImageView. Now here's the XML for ImageView. Let's look at the lines one at a time. The XML element starts with an open angle bracket, ding. And then the name of the view [SOUND] and then the list of attributes, [SOUND]. Then it's followed by a forward slash, and then a closing angle bracket. [SOUND] Boom. When we wrote the XML for TextView, it displayed text on the screen. So now, when we write ImageView here, it displays an image on the screen. The first attribute is something we haven't seen before. It says android:src equals at drawable/cake. This is saying that the source for this image should be found in this file here. The file name is called cake. We use the at symbol to say that we're referencing a resource in the Android app, and drawable is the resource type. A drawable is like a graphic that will be shown on screen in Android. And again, cake is the file image name. We don't include the file extension. You don't need to say if it's a JPEG or PNG image. Just say the file name. If you're wondering where this image came from, well we handle this a little bit differently in the XML Visualizer compared to the app. But basically, we loaded in a bunch of images beforehand so that you can use them to practice in XML Visualizer. When you build your app in Android Studio you're going to have to add images manually into your app, into the drawable folder. Now, if I try to reference an image that doesn't exist, for example, the toys image does not exist. Then there will be an error because toys is not a valid image. So make sure that you only reference images that are available. So let's change it back by hitting undo. Now we have the width and height, which are set to be wrapped content. So that the image view is only as big as the cake image inside of it. Lastly, we have this attribute called Android:scaledType and it's set to be center. Scale type tells the device how to scale up or scale down, based on the bound of the ImageView. Let's see what that looks like. Now you can see the cake image showing up on the device. The cake image is actually pretty large, and it's larger than the screen size. So when we say scaleType, it doesn't change the size of the image, it just centers it. So we see that the cake image is actually really big, but this is the center of the cake image. We can set other values for scaleType, such as centerCrop. This scales down the image to fit the height and width of the view. In this case, we're constrained by the sides of the screen. We also maintain the aspect ratio of the original image so it doesn't get distorted. Once we scale it down, we also center the image, and then crop it so that it fits this ViewSize. When displaying photographs, I like to use center crop. This is because it's typically okay to crop off the edges of the photograph in order to achieve this edge to edge look. When images go edge to edge without any white border or anything, this is what we call a full bleed image. We use a lot of full bleed images in the material design guide. Here are some examples. You see how the images go edge to edge here, and it give it a nice immersive feel. Okay, now it is time for you to try. Specifically, we would love for you to be able to change the height and width of the image view to be a fixed dp value. Try something like 100dp. Then change the scale type between center and center crop, and you can also adjust the height and width of the image accordingly. For example, what happens if you change the height and width of the image view to be greater than the sides of the device, or what happens if you set the height and width to be something smaller than the size of the device? In those cases you may see different behavior for center and center crop Also, try to change the image to something else by checking the Available Images link. We've included a small version of the cake image, as well as a larger version, so that you can try the different scale types. We also included an Android icon. Use the link below to get to the XML Visualizer. The documentation for Android, it's on a site called developer.android.com. It contains a lot of helpful information, such as code samples, tutorials and articles. You can think of it as an instruction manual for how to build apps. I use this site daily, and often times I get to it using a Google search. I'll show you what I mean. Let's look at the documentation for text view. So I search for textview android. The top link that comes up is a developer.android.com site, so I click on that. This is what we call the reference documentation for TextView. I know there's a lot of information on this page and it can be overwhelming. But usually when you're looking at reference documentation, you're trying to solve a specific problem. So you can actually filter out all the unnecessary information that you don't need. When I come to this page I check that it is indeed for TextView. I may read the class overview, and then I can scroll down. This is the interesting part. It lists out the XML attributes. These are all the possible XML attributes for TextView. It also includes a nice description on the right-hand side for what it does. Now you don't need to memorize all of these attributes. In fact, I haven't used some of them. I usually work with a small subset of them on a regular basis. But I know that if I ever need something special, I can always come to the TextView documentation to find that specific attribute. Here's one that we recognize. Android:textSize. So we click on it, and it links to the description of this attribute. It says that this controls the size of the text. And the recommended dimension type for text is sp for scaled pixels, for example, 15sp. Cool, so we learned this earlier. And if you ever forget you can always come back to the TextView documentation and look up what the attribute is. Now say for example I don't know what the exact name is. In your web browser you can use the find feature to search the page. The other way to open up this Find window is to use Cmd+F on Mac, or Ctrl+F on Windows. Then I can type in what I'm looking for. Say, for example, I'm looking for a way to capitalize all the letters in a TextView. This might be useful for example, if I'm trying to show tabs like this, or if I'm creating a snack bar at the bottom of the screen, like this UNDO text here is in all caps. Buttons are also in all caps. Going back to the TextView documentation, I can search for caps. I can browse through all the search results, but these look pretty good. It says that there's an XML attribute called android:textAllCaps, and this description says to present the text in all caps. If I click on it and read the description, it sounds like what I'm looking for, and it says the possible values for this attribute are either true or false. So I can try this out in code now. So going back to the XML Visualizer, say I have this TextView on screen and I want to change it to be all caps. According to the documentation, I can add an attribute here that says android:textAllCaps, and then I can set it to be true or false. If I set it to true then look, it's all in caps, cool. The nice thing about this attribute is that I don't have to go and change the text. Like, oh the possibilities, and capitalize everything. Instead I can leave the text as is, and all I need to do is just toggle this attribute to change it from true to false. Now, it's your turn to practice. Being able to look at documentation and then update your code accordingly to try it out, is a really useful skill to have. That means you don't have to memorize everything you could possibly ever want to do in Android. It's only a Google search away and you can find it when you need it. So first, I want you to Google search for textview android to find the reference documentation for TextView. Then I want you to use the Find feature in your web browser to search the page for the XML attribute that makes the TextView text bold or italic. We haven't covered this XML attribute before, so this is an opportunity for you to learn it on you own. Once you find something that might work, go ahead and try to use it. If that doesn't work then no problem at all. Just keep going back to the documentation until you find the one that works. Okay, so I asked you to search for textview android. Usually, when I do a search, I always add the word android at the end of it, so that it only shows me android results. The first link is for TextView, and it's on developer.android.com site so I'm going to click on it. I can ignore most of the information on this page except I do want to verify that this is indeed for TextView. I can read the class overview but the most important thing is down here, the XML attributes. So I can manually scroll the list, but that will literally take forever. So, I'm going to use the fine feature that I talked about earlier. The quiz question was about finding an attribute that would change the text to be bold or italic. So I'm going to search for the word bold. Cool, so let's look at this description. It says Style (bold, italic, bolditalic) for the text. That sounds pretty good, so I can click on this attribute. For android:textStyle, it seems that the different values are normal, bold, or italic. Let's try it out. The documentation says that if I add android:textStyle attribute, then I can set it to be bold, italic, or normal. So let's try bold. Nice, and it bolds the font. And let's be adventurous and try italic as well. Awesome, it italicizes the text. So this was an example of how you can look at documentation to find new attributes that you can set on your TextView. In the future, when you're working on something and you get stuck, or you don't know how to do it, remember they can always use documentation as a resource. My name is Kirill Grouchnikov, I've been at Google for the last five years, and I do client work, UI work, on the Play store. Okay, awesome, and what do you like about it? Well, I always liked writing code and seeing pixels light up on the screen. So this is the Play App, Google Play App. Starting from top to bottom, we have the search box, and we have these, what we call quick links, to go to various subsections of the app, and of the store. And then we have different content here, so we have clusters of cards. We have this, we call a banner, that gets you into some other place in the app. You can go into the details page of a certain item, let's say Angry Birds Telepods, and this is what we're showing here, kind of the mix of information that the developer has provided. We have the video of the app. Then we have the short description of the app's screenshots. Then we have the user provided content, reviews and ratings of that app. A little bit more related content. And then here, a couple of links. And you can go also from the details page. You can start the install process. This is the permissions. And then you go and accept them. And it starts. So you can see over here, it starts installing it. So the students have been learning about text views, image views, buttons. Can you point out a couple of those in apps? Yeah, so back to the cards, if we look at this Star Wars Rebels. So the card itself is an extension of a view group. But it can be as simple as a extension of our elegant layout, and then we have this thumbnail is an image view. Then we have this, Star Wars Rebel is a text view that goes to a maximum of two lines. Rating bar is, well, rating bar. The free is text view, and the overflow dots is an image view with a source set to a certain PNG that looks like three dots, and then the same for the quick links, so it is a relative layout with the image view on the left. And then the text view in single line mode going to right of that image view, and extending however much it needs. And it has its background set to a certain drawable that has a green background with rounded corners. So essentially, as you say, it boils down to taking these very basic building blocks, text views, image views, sometimes rating bar, progress bar, spinner, check box, radio button. And combining them based on what your design shows on a particular screen. Yeah, that's so cool because the students are learning this in their very first lesson of Android and you're using this every day in the Google Play app. You mentioned working with a designer. So can you describe what that process is like? So, it starts from the product people, and then it goes into discussions with design and engineering on what are the screen surf we are talking about and how, hopefully, already at that point of the design site, we start thinking about how we'd adapt to smaller screens, to larger screens. And after that, we do these kind of iterations on putting something on the screen, and start validating the overall approach. Because sometimes you have a static mark or maybe a motion mark from after effects or whatever tools the designers are using. And you see it on your desktop screen, and then you put it on the phone and it feels quite different. Because you have a smaller screen. Or because it's a tight interaction, or maybe because you are depending on all these great big images, but the network is slow. And so, you start with this screen that five seconds doesn't display anything. And so, hopefully throw out this iteratic process, where. We put something on the screen, not necessarily pixel perfect, then we can go back into the product level discussions and see, okay, what do we need to tweak? So, for developers who don't have a designer to work with, do you have suggestions on what they can do to make their app look better? I would suggest to going to the website for material design and get acquainted. Not necessarily with the finer parts of motion arcs or all those interpolators, but focus on the bigger picture. So to have consistent grade across the entire app, what we call key lines or what the design calls key lines. Vertical and horizontal, where elements align to certain visual rhythm and they don't feel just randomly thrown onto the screen. And so you have your toolbar. You have, maybe other parts of your Chrome, like the navigation elements on your screen. And then you have the content itself, so it's great when it all aligns to the same grid, and you have a little bit of margins on the sides. And things are not too close to each other. Then you have typography. Which is a great way to visually convey the relative importance of different things. So if you talk about something like inbox, or Gmail, or an email app. So if everything has the same typographical language. If everything is the same color, the same size and the same style, then it's not really easy to scan it. So maybe you would want the RQ make the sender. A little bit bigger, like the sender name, or maybe the title, or the first few words of the subject to be bold. And that would allow the user to more quickly scan. It depends, once again, on your content. But I wouldn't recommend necessarily going with too many styles, or too many sizes. Three, four styles used consistently across multiple screens allow the user to kind of get, even on a subconscious level. To get kind of a picture of how to get things done in your app, and necessarily fight to understand where the information is that he or she is looking for. And the last thing, colors. Use a little bit of, especially with material. It kind of leans toward using big splashes of saturated colors, which looks great, especially if it goes into the status bar on Lollipop devices. Identify what we call the accent colors and primary colors. Identify a couple of colors. And use them to, kind of, you know, to style the chrome of your app, so like status bar, action bar, maybe a little bit in the navigation drawer. And use and highlight so X sends for the floating action button or maybe to draw attention to a certain,very important element, what you consider a very important element. And I think these three go along way towards emphasizing a little bit more the visual style of the app. And of course, if you have an opportunity to team up with a designer, that's always great. Remember the coffee bean trail, Katherine? How can I forget? I know. You spilled it all over me. [LAUGH] [LAUGH] So we talked about how there would be three big parts to Lesson one. Mm-hm. And we spoke about image and TextView. And then we learned how to style those views. Yes. Where are we going next? Well, I was thinking. Since we only have one view on the screen right now. Yeah. It's a little boring, so we should add more than one view. Right. And if you think about it, all of the fun apps that we use, YouTube, OkCupid, what's another one that comes to mind? Gmail. Gmail, they all seem to have more than one views packed in very neatly on the screen together. Yeah. And the way they do that is through view groups. Mm-hm. So we'll learn about that next. And that gives us the power to also position views on the screen where we want them. Right. So lets talk about view groups next. So far we've only had a single TextView or a single ImageView on screen. If we want to add another view below it we could try to just copy this and paste it below it. But then we get an error. It says the XML document has more than one root view. There can only be one root view, and it should enclose all of your other views. If we want both of these TextViews to appear on screen and not be lonely anymore, then we need to put them in a View Group. The View Group will then be the single root view for the layout. View Groups are also views and they are rectangles on the screen. For example the red and orange rectangles here are all View Groups. They can have a width, a height or a background color, or other attributes. Background color here is orange. Orange. But it could also be transparent so the View Group isn't even visible to the user. Instead of holding some content like text for TextView or an image for an ImageView, the content that a View Group holds is other views. You can think of a view group as being a container for views. When a view contains other views, we call it the parent of these views. So this is the parent. This is the parent. And this is the parent. When a view is inside of a View Group, we call it the child of that View Group. So this is a child, and this is a child, and this is a child. Same here, there are two children here, and two children here. Continuing with the family language, if there are multiple children, then each of those children are siblings to each other. These are sibling views, and these are sibling views. Okay, that was a lot. To help you remember all the terminology around parent and child and view and View Group, I want you to meet a very nice family called the Views. You've already met Tommy TextView. He's pretty great at displaying text. You also know his sister, Ivy ImageView, who displayed very beautiful images. And now we're meeting their parents. It's always nerve racking to meet the parents. So we have Laura the LinearLayout and Ray the RelativeLayout. These are both View Groups, which we mentioned before are called Parent Views. Then the Children Views are positioned based on their parent. Let's look at an example of one parent. A parent may tell their child to sit or stand in a specific place and not to move. Let's ignore the possibility that the child might want to get up and run around. Because that's just an edge case. On a device this means that a parent has control over where to position its children. For example, one child Text View can be at the top of the screen and then a second child ImageView can be below that. Or, if the parent wishes, they can rearrange the children in a different way. The child ImageView can be on the left, and then the child TextView can be on the right. We're going to talk about view groups in more detail in this lesson, but to make sure that you've understood what we've covered so far, please answer these questions. For the screenshot on this device, can you tell me how many views there are? Number 2. For the mountain image, is it a child or a parent of the red view group. Number 3, is the red view group a child or a parent of the hiking text view. Number 4, which of these views are siblings of each other. And you can just list them here. Okay, so how many views are there in this screenshot? Well, we have two text views and one image view. So that makes three views. But then also remember that a view group is also a view. So that's actually four total views. So we write that in here. Sorry, I know that was kind of a trick question. But now you will remember it next time. Next, the mountain image is a child or parent of the red ViewGroup. If I draw in the faces, hopefully you will remember that the image view is a child of the red ViewGroup. So I circle this one in. Number three, the red ViewGroup is the child or parent of the Hiking TextView. If I draw in more faces, then we see that the red ViewGroup is the parent of Tommy Textview. So we circle this in. Number four, which views are siblings of each other? Well, the three of these views are siblings of each other. So, we have the mountain image view and the two Text Views. Okay, great, so now we know about how ViewGroups can contain views. Each ViewGroup has specific rules on how it will position the children inside of it. First, let's look at LinearLayout. This ViewGroup can arrange children in a vertical column like this. Notice how we're not limited to just one TextView and one ImageView. We can put as many of them as we want in here as well as other types of views. So this is Tommy, and this is his brother Timmy. And this is Ivy and her twin sister Irene. Or the LinearLayout can arrange its children views in a horizontal row like this. Hey, if you want to say no boys allowed, that's totally fine with me. This is Ivy, Irene, and Isabella. Okay, and that's it for a LinearLayout. Pretty straightforward, right? You can arrange children in a vertical column or in a horizontal row. And then we have dad, the RelativeLayout. The RelativeLayout, again, has its own rules for how to position its children within it. For example, it can position children relative to the parent. So if this is the parent ViewGroup, we can have a child TextView aligned to the bottom of the parent and a child ImageView aligned to the top of the parent. This also works for aligning to the parent's left and right edge as well as the center. The other useful capability of RelativeLayout is that you can position children relative to other children views. So, if this is the parent ViewGroup, then you can position an ImageView on the left edge of the parent and then position a child TextView to the right of that image. And then, this child TextView is positioned to the right of the ImageView but also below this first TextView. So you see how some of these children views are aligned relative to the parent or relative to each other. That was a really quick overview of LinearLayout versus RelativeLayout. You can see how you might pick one over the other depending on the type of layout that you want for your app. Now let's look at the XML for how a ViewGroup contains other views. In this example, we'll start with a ViewGroup that contains two child TextViews. This is a little more code than we're used to, but I want you to make some observations about this code. As a hint, the parent code is in red, and the child TextView code is in blue. We've linked that code below so you can take a look at it and then write down three observations here. And here are some observations that you may have made. There's no right or wrong answer here. We just want to get you in the habit of identifying things that you do or don't know in some code. So you may have noticed that this starts with a opening angle bracket, and then the name of the view. Ding [SOUND]. And then there's a bunch of attributes. [SOUND] And then a closing angle bracket, boom. But there is no forward slash, that may come later. You may recognize the values of width and height, which means the sides of the view group will shrink to wrap the content inside of it. Then there's this new attribute that you haven't seen before, android:orientation="vertical". You may make some connection with the way that these are vertically in a column. Then there are these two TextView elements. >From looking at the attribute text, it seems like Guest List is here and Kunal is here. Looks like it's a party for one. Then we have this funny group of symbols down here. You may or may not recognize it from earlier, but this is a open angle bracket, forward slash Linear layout and then close angel bracket. This is the closing tag, and this is the opening tag. You get brownie points if you remembered that from the beginning of the lesson. Cool. So let's look at more code examples, and dig into this more. Okay, so we saw how this linear layout contains two children text views inside it. By the way, these background colors are just a teaching tool to help you understand that these two children text views are inside this parent. The red and blue colors actually won't show up on the device unless you specifically set them as background colors on these views. To show you what I mean let's go to the XML Visualizer. If we drop in the code to the XML Visualizer, this is what it looks like on the device. So first we have a LinearLayout viewgroup, and this is transparent because there's no background color set on it. The first child is a TextView that sets guest list, so that shows up at the top here. The second child is a TextView that says Kunal and that shows up below the first TextView. Now, if I copy this TextView and paste it below this one, what do you think will happen? Yup, we have another Kunal that shows out right below the first one. Okay, so the pattern seems to be if we add more TextViews, here, then they'll just show up one after the other in this list. Now let's look at the code more closely. It starts with an opening angle bracket and then the view name, which is LinearLayout. Then it lists a bunch of attributes and then there's a closing angle bracket. Notice that there's no forward slash because this is just the opening tag of the LinearLayout. The closing tag is all the way down here, because we want to insert children elements in between the opening and the closing tag. But for example, for this test view, since there are no children within that, then we can just use a self closing tag for it. Same for this text view here, and this text view here. So when we say a view group contains children views, then we need to inset them in between the opening and closing tags. Now, the other thing you may have noticed is this attribute called Android orientation equals vertical. We haven't seen this before, so let's look at the Android documentation like I showed you earlier. I open up a new browser window, and then I type in android orientation. The first result is about a LinearLayout, and it's on the developer.android.com site. So let's click on it. Just like the textview documentation, it was a little overwhelming. We can ignore most of this text. We just need to verify that this indeed is the page for LinearLayout, and then we scroll down and look at the XML attributes. Now, we're looking for the attribute that is called Android orientation, and here it is. So let's click on it to look at more details. The description says that this attribute determines whether the layout should be a column or a row. The value of this attribute should be horizontal for a row, where the value should be vertical for a column. And then it lists those two values here. Cool, so our code currently says that the android orientation is vertical. So that explains why the views are showing up as a column. Now, to satisfy our curiosity, we should also try the other value. Let's set the orientation to be horizontal and see what happens. I'm going to go into the code and erase the vertical value. I'm going to type horizontal, and look, now the views are in a horizontal row. I don't know about you, but I don't really like to read my guest list horizontally. But there are still many other useful cases where you would want a horizontal linear layout. For example, if you're creating a list item, you might want an image on the left hand side, and then a description on the right hand side. I'm going to let you try this out on your own in a second, but first I want to point out this additional line of code. This is the XML namespace declaration. We use this namespace in order to specify that all of these attributes here belong to android. That's why they all start with android colon. This is essentially short hand for this specific URL that's unique to android. You can actually create your own custom attributes. So to prevent name conflicts, where two attributes are named the same thing, but actually have different behaviors, we always add this prefix here, android:, to signify that these are android attributes. So basically, always remember to add this XML namespace declaration in the opening tag of the root view of your XML file. Now it's your turn. We want you to be able to experiment with the linear layout code now. Try to add more TextViews so there's more items in this column. Who would you put on an exclusive guest list for your party? Also try changing the linear layout orientation attribute. Remember that it can be set to vertical or horizontal. If you open up the link to the XML visualizer, that we provided you in the instructor notes, then this is what it would look like. We have a linear layout with a text view that says Guest List and another text view that says Kunal. The first task was to add more text views to create the guest list. So let's copy and paste this XML element. Cool, let's add some other people besides Kunal. Let's add Kagure and also Lyla. Awesome. So now Kagure and Lyla show up under Kunal's name. We can also change any of the existing text use. We change to the VIP list. The second task was to change the orientation attribute to be horizontal. This immediately changes all the text views to appear side by side instead of one on top of the other. We've been making a guest list so far for the party. Wait, this is the guest list for the birthday party, right, Catherine? Yeah. I really hope I'm on this list. Well, we'll have to see about that. Wow, I feel really small about that. Well, speaking about small, let's talk about the size of views on a screen. Oh, we've used the fixed written height, which is the dp, right? Yeah, the width and height. And we could also set, wrap content, with view. Right, which is a strange way of saying that the view is going to wrap itself around the content. So the content grows large, the view grows large, the content is small and the view grows small. Yeah, and there's actually a third one which is called, match parent. That seems a little strange. That sounds like a dating website for single parents. Not quite. Match parent means that the view will be As wide or as tall as the parent. Oh, so that makes sense. I am a view, I have a parent and my width and height is going to be the same as my parent. Okay. Exactly, so that's to summarize, the different values that you can set for a size of a view is width. Fixed dp for width and height. Correct, you can also do wrap_content. And the next one we're going to try out is match_parent. Here are some examples of how setting different widths on the child views in a linear layout can affect the final user interface. In this example we set each child view to have a fixed width of 200 dp. If the content inside each view is greater than 200 DP then you run risk of cutting some content off like this. In this example we set each child view to have a width a wrap content. Now all the content content is shown, but the width of each view really varies based on what's inside each view. In this example, we set the width of each child view to be match parent. Now you see that the width of each child is as wide as the parent view group. Regardless of the content inside of it. Now those same values can also be applied for the height of each view. In this example we set the height of this child text view to be 200 dp. If the content inside it is taller than that. Then you run the risk of cutting off some of the content. In this example, we set the height of the child text view to be wrap content. That way all the content will be displayed on screen and nothing will be cut off because the size of the text view is dependent on the content inside of it. In this example, we set the height of the child text view to be match parent. That way the child view is as tall as the parent itself, regardless of the content inside it. Let's open the XML visualizer now and try to be more like our parents in the code. We're providing you a link to the XML visualizer with some starter code in the instructor notes below. In this case, the LinearLayout is the root view of this layout because it's the first and outermost view. If we set match_parent for the width and height of this root view, and we set this as the main layout of our app, then this linear layout will be as tall and wide as the device screen. I can show you by setting the background of this linear layout to be a non-transparent color. If I set a gray background color on this linear layout Then, you can see how the gray extends the full width and height of the device. Now, what happens if I try to change the width or height of these text views to be match parent? To make it clear where the bounds of each view are, I'm going to set a background color on each of the views. Now I'm going to change the height of this text view to be match parent. By the way, you spell it match_parent. And now you see that this text view takes up the full height of the parent. Unfortunately, it pushes everything else off the screen, so we don't really want that. So let's change it back to wrap content. Okay. So let's change the width now to be match parent and see what it does. Now the width of the TextView is as wide as the parent, which in turn, is as wide as the device screen. If I change the other TextViews to also be match_parent You can see that it also starts to take up the full width of the parent. I also want to point out one more thing. Every time you see an attribute that starts with layout underscore, like layout height or layout width, these are actually view group layout parameters. These are used by the parent view group to determine the size and the position of these views. Meanwhile, the other attributes like background, text size, and text are handled by the TextView in terms of styling its own view. But these view group layout parameters are handled by the parent. Now it's your turn to try different width and height values. For the link to the XML visualizer with some starter code, see the instructor notes below. Try to change the width and height values of each TextView. You can set a fixed dp value, wrap-content, or match_parent. Remember that for each view, the width and height values don't have to match. When you're done, check this box to continue. In a previous video, I showed you what happens when you set match parent for the width of each of these child views. The text view ends up extending across the full width of the parent. There's no right or wrong solutions for how you experimented with the code. Here's another thing you could've tried. If you set the linear layout to have an orientation of horizontal, then the views will be displayed in a horizontal row. If you set match parent for the width of the VIP list, then it unfortunately knocks off the other views off the screen. If you set match parent for the height of the text you, then you see that the VIP list text view is now the full height of the parent linear layout. The same can be done for the other children views, or you can set a fixed height. In the previous video, we showed you what happens when you set matched parent for the width of each of these child text views. The text view extends to the full width of the parent linear layout. If you set a fixed height on the TextView, like 300 DP, then this is what it will look like on the device. There's no right or wrong answers for what you tried out. Let's review. So far we've learned that a linear layout can have an orientation that's horizontal or vertical. But now let's think about whether these views are taking full advantage of the screen real estate. When I say real estate, I mean the available space on the screen. For our Nexus 6 phone, say we have a vertical linear layout that has three child text views inside. Tom, Tim and Todd. When we hold the device in portrait mode like this in our hand, then all the text views are grouped in the top left corner of the screen. There's all this blank space left unused. Similarly, if we rotated the device to Landscape mode, then the text is on the top left corner and there's all this blank space left. It's even more noticeable on a tablet device, where the screen is a lot bigger. We're only using a small amount of the screen real estate, and the rest of it is blank. We're going to learn about how we can more equally spread out these views across the screen to take up more of the available room. This applies to other views as well. You can have bigger images across the screen for a better experience, instead of having them really tiny in the top left corner. Same with buttons, you could have bigger buttons so that it's easier To tap on those buttons. For the purposes of our example, we're going to stick with text views. So let's go to the XML visualizer to figure out how we can spread out these views. So here's the code for Tom, Tim, and Todd. I have three text views within a vertical linear layout and this is what they look like on the device. Now, I want to show you how you can spread out these three text views. So that Tom is up here. Tim is here. And Todd is down here. Clearly, setting height for wrap_content is not doing the job. The other thing we learned is to set a fixed dp value for the height. So I'm going to set the height to be, for example, 200dp. Cool. So that left a lot more space for Tom. If I do the same for the other TextViews, then they also spread out more evenly across the screen. But this solution will only work for the sides of a device. If I have a tablet like I showed you earlier, then these views are still going to be grouped in somewhat of the top left corner. The other option for setting height is match parent which we learned earlier. When you set match parent for the Tom TextView it takes the height of the whole parent which is a whole screen. That pushes the other text views off the screen so you can't even see them. So let's not do that. Well now we're out of ideas because we tried wrap content for the height, which had a fixed DP value. And we tried match parent. And none of those give us the right spacing across all different devices. Let's Google search for a potential solution to this problem. We're using a linear layout view group. And we want to equally space out the children views. So let's search for that. Okay, so there's a bunch of search results, but let's click on this first one. This is a link to the Stackoverflow site. It's a Q&A site where you can post questions and get answers from other Android developers. I use it all the time when I'm stuck and I need help on a problem. Often times other people will have already asked a question that I'm having. So this question here is about how to evenly distribute buttons across the width of a linear layout. This is similar to what we're looking for, except instead of buttons we're working with text views. And instead of the width of the linear layout we're trying to spread it across the height of the linear layout. We can read through the question or we can skim it. Usually I just skim for the answer. So this solution received 88 votes and has a green checkmark on it. It talks about how you can set layout_width to 0dp and set the layout_weight for each of the buttons to be 1. And that splits the available width equally across the buttons. You may not fully understand the answer at this point, but that's okay. One key phrase that we saw is this linear layout_weight. We haven't encountered this before, but it sounds important to the answer. So lets copy it and Google search for more information Information about layout_weight. So let's search for linear layout layout_weight. The first result is an article for linear layout and it's on the developer.android.com site, so let's click on it. So this is an article about the Linear Layout. We already learned the stuff at the top about the Android orientation attribute, but then there's new information about something called Layout Weight. There's also an example at the bottom of the screen here with some code and a screenshot. I could summarize all of this for you, but first I want to give you a chance to read this document. And try to figure it out on your own. This is going to be a lot more similar to how you're going to solve problems after this course is over. You'll look for some information online and try to figure out how that can be used to solve your problem. Okay, so this is the layout that we have now on the device. And this is what we want to achieve. The three texts are spread-out evenly across the height of the device. To solve this problem, I want you to read the Linear Layout article that we linked below. It's perfectly normal for you to not understand everything that's in the article. Often times you just want to have some vague understanding of how the concepts in the article may be able to help you in your work. Then I want you to provide some ideas on how we can build this desired layout in XML. You don't need to provide the full XML layout code because we're going to walk through that together in the next video. But here you could write a couple sentences or bullet points on how the information in the article could relate to our problem So I asked you to try your best at reading this article on linear layout, knowing that you probably would run into concepts and terms that you may not understand but that's totally okay. Hopefully, each time you read the documentation, you'll understand a little more each time. We're going to spend the next few videos learning about layout weight in more detail. But here's one thing that could be useful to our problem at hand. This section is called Equally weighted children, and it talks about how we can create a linear layout where each child is given an equal amount of space, whether it's a vertical layout or a horizontal linear layout. For a vertical linear layout, we would set the layout height attribute of each child view to be zero dp. Then we would need to set the layout weight attribute of each view to be one. I'll show you what this looks like in the next video. In the last quiz we were trying to figure out how to give the Tom, Tim, and Tod text views a little more personal space by spacing them out equally vertically across the height of the device. We tried setting a fixed dp value, but that wouldn't work if we switch to a taller device like a tablet. Then we tried match_parent, but then that made the Tom text view really big. But then it knocked the other two textees off the screen. So then we started researching about linear layout weights. In the documentation, it said that for a vertical linear layout, if we want to equally space out the children, we need to set the height to be zero dp and a weight value of one for each of the children. Assigning a weight value to a child view is like assigning an importance value to it. The higher the weight value, the more space it may get if there is available space in the parent left. For example, for this vertical linear layout, it fills down vertically this way. It turns out that this linear layout has a lot of extra space, and that will be distributed to the children that have weight values. If a child has a very high weight value, then more of this available height will be given to that child. If a child has a very tiny weight value, then less of this available height will be given to that child. I can show you what it looks like. I'm going to set the height of this child to be 0dp and then give it a weight of 1. The linear layout first lays out Tim and Todd TextViews, because they have a fixed height based on the content inside of it. And then there's this Tom TextView that has an initial height of 0dp, but a weight of 1. None of the other children have a weight value, because the default weight value is zero if it's not specified. So this is the only child with a weight value. So the parent gives all of the remaining height of the screen to this Tom TextView. And that's why you see the Tom TextView is so giant. Let me try assigning weight values to the other children now. So now each child has a height of 0dp and weight of 1. This is the process that the linear layout would go through. It would try to figure out the height of each of these views. The height of these views starts at 0 dp. So that means the available remaining height in the parent is basically the whole height of the screen. It divides the whole height of the screen by the weight sum, which is three. And then it gives one-third of that available height to Tom text view, one-third of the height to the Tim text view, and one-third to the Todd text view. These will still be evenly spaced across the height of a device even on larger screen devices as well because of this weight value. If I change the weight value to be something higher, then the parent will give more available height to the Tim TextView. I can change it to an even higher weight value, and you can see how it continues to get more available height. In this case, the Tim TextView has a weight of 8. Tom has a weight of 1, and Todd has a weight of 1. So the weight subtotal is eight, nine, ten. So the parent divides the available height divided by ten. And one-tenth goes to Tom, eight-tenths goes to to Tim, and one-tenth goes to Todd. So for a vertical linear layout, say we have 3 child TextViews. We set the initial height to be 0 dp. So they're all stacked up at the top of the screen with 0 height. That means the parent has all this extra height available. If I set a weight of 1 on each child TextView, then the available parent height will be distributed equally across each of the children. The same would work for horizontal linear layout. Say we have 3 child text views. We start with a width of 0 dp. That means the parent has all this extra width available. If I assign a weight value of 1 to each child view, then we're going to take the available width left in the parent and distribute it equally among each child. And again, it doesn't have to have a weight of 1. It could be to three or any other value. Or it could even have a weight of zero. If a view has a weight of zero, that means that it won't change depending on the available space left in the parent. It will basically stay the width and the height that you give it. One thing I want to point out is when to set the height to be 0 or the width to be 0. If you have a vertical linear layout, you're filling the linear layout vertically this way. So you don't know what the height should be, so you set the height to be initially 0 dp, and you give it a weight value. Similarly for horizontal linear layout, you're filling it horizontally. So you don't know width yet of the child views. So you set the width to be 0 dp, and give it a weight value. Essentially, you can think of assigning a weight value to a view as being able to stretch it out depending on how big the parent view is. This is good for filling in the available space within a small device or a large device. Here are a couple examples in real life where layout weights are really useful. This is the Google Hangouts app. You can use it to chat with your friends or send sleepy penguins to them. In this bottom part of the screen here is where you send your message. Let's look at this layout down here a little more closely. It's a horizontal linear layout because it's laid out in a horizontal row. It's made up of an ImageView, an EditText field where you can enter text, and another ImageView. Now the height of each of these views is actually wrap_content because it wraps through the content inside of it. The width of these two image views is wrap_content because it's only as wide as the content inside of it. We give it a weight of 0 because we don't want it to be any bigger than this, even if there's lots of space in the parent left over. Setting the weight of 0 ensures that it will only be wrap_content for width and height, and it won't change. We want it to stretch so that it's a little bit bigger on the larger screen devices, and we want it to shrink if it's on smaller screen devices. So we set the width to be 0 dp and the weight to be 1. That means that the parent linear layout will try the layout this image first and then this image. And then any remaining width in the device will be given to this view. Here's an example in the maps app. This is a detail page for a location. There are three buttons here, Call, Save, and Website. Let's look at them more closely. You can actually build these as TextViews with icons attached to them, and you can see the instructor notes for more details. But that's really a tangent point. For this exercise, let's assume that these are text views. The height of each TextView is going to be wrap_content because it wraps to the height of the content inside of it. Now, the width is a little bit trickier. We want each of these TextViews to be spread out equally across the width of this screen, depending on whether it's a small device or a really large device. We don't want all three text views to be grouped into the left-hand side of the screen. So to space children out equally, we give them equal weights. We set a width of 0 and a weight of 1 for each of them. That way the available width in the parent will be spread out equally across the three children. And the last example is an email app. This is a compose screen in Gmail where you can write a new message. It's a vertical linear layout, because the items are in a column. And it's made up of four different EditText fields. Now, the width of each child is match_parent because we want it to stretch across the whole width of the device. For height, we set these three edit text fields to be wrap_content so it wraps the text inside of them. We set the weights to be 0 because we don't want them to increase in size even if there's available height in the parent. But for this last EditText field, this is where you write your message, and we want to give the user lots of space to write a really long letter to Grandma. So we se the height to be 0 dp, and we give it a weight of 1. So if the parent has any available height left, it will be given to this child EditText field. On a larger screen device, the compose email field will be a little bit taller, and on a smaller device it will be a little bit smaller. Now it's your turn to practice. We want you to go ahead and build this layout in the XML visualizer. You can start with the XML that we've provided below. Here are a couple of tips. When you try to tackle something like this, try to first determine the width of each view, and then go ahead and try to determine the height of each view. Also make sure that the image takes up any remaining height in the parent linear layout. So on a smaller screen device, it will take up less height. On a larger screen device, it will take up more height. Okay, go for it. Check this box when you're done. So to build out this layout, I like to first think about it conceptually to make sure I have an idea of what I'm going to do before I start coding. First, we notice that it's a vertical linear layout because the items are in a vertical column. We have three children views. We have an image view, a text view and a text view. The first hint that I gave you was to first determine the width of each view. Since the whole layout takes up the full width and height of the device, this Vertical Linear Layout has a width and height of match_parent. Then for the image view, we want it to also be as wide as the parent, which in turn is as wide as the device. So we set that to be match_parent. Same for the two textviews. We want them to match the full width of the device, so it's match_parent. Then we work on the height of each view. These two textviews are easy because they wrap to the content inside of them. So we set wrap_content for the height of each textview. We also set the weight values to be zero because we don't want these values to change even if there's available space in the parent. Now the imageview was the hardest part. We want the height of the image to grow or shrink depending on the available space in the parent, which depends on the available screen size of the device. We use weights to accomplish this. We set the height of the image view to start at zero dp but we give it a weight of one. Since none of the other children have weight values then any available space in the parent will be given to this image view. And the reason we set the height to be zero dp is because it's a vertical linear layout. So it fills itself vertically. And we don't know the height yet until the weight value determines it. We gave you this link in the instructor notes and it had some code already in it. The positioning of the views is incorrect, though, so let's fix that. Let's start with the text views first because those are easy. You can see that these text views don't stretch across the whole width of the device. So we need to change that. The width should be match_parent. That's better. So now the greenish-bluish background goes across the whole width of the device. Same for the bonfire at the beach textview. Cool. And the height is that content which is correct. Now we have all this extra vertical space in the vertical linearlayout. Oh, by the way, the width and height of the linear layout is set to be match parent so that the layout will eventually extend the whole height and width of the screen. So to use this extra height in the parent we want to give it to a child that has a weight value. So let's change the imageview so that it has a weight value. First, we can set the width to be match_parent so that it also extends across the width of the device. Then we set the height to be 0dp and the weight to be 1. And that's the desired screenshot. Good job. Note that if I change the weight values to be a really high number like seven or ten, it doesn't really change the device preview. That's because this is the only child with a weight so it doesn't matter if it's a really high weight or a really low weight. All the extra height in the parent will be given to this child. So let's just change this to be one. Okay, good job. So far we've learned that a linear layout can have a vertical orientation, or a horizontal orientation. We've also learned that individual views can have weight values to fill up the extra space in the parent. Now we;re going to spend some time learning about the relative layout view group. This will help you build even more flexible layouts. Do remember Ray the relative layout. He's the dad, and he's represented by this view group here. He helps the children views, be positioned within this container. With the relative layout, you can position children relative to the parent, such as the top of the parent or the bottom of the parent. The other option is to position children views relative to other children. Like this. Let's focus first on the case where views can be positioned relative to the parent. For this example, this parent relative that is set to have with a batch parent, and height of match parent, so it's as big as the device. The children inside a relative layout, can be positioned relative to the parent's left, top, right or bottom edges. This is the code for it, on the child view x amount elements. For example for the emoji or TextView, you would add these attributes. The attribute name follows this format android:layout_alignParentTop. This attribute determines whether the Child view is align to the parents top edge or not. So the possible values are true or false. If it's true, then the view should be aligned to the parent's top edge. If it's false, then it shouldn't be aligned. There are attributes for all the other edges as well. For example alignParentBottom, for aligning to the parent's bottom edge. There's align parent left, for aligning to the parent's left edge. And then there's align parent right, for aligning to the parent's right edge. You can mix and match, and use multiple of these attributes at a time. Take this image view as an example. We would set the attribute align parent top to be true, because it's aligned to the parent's top edge. It's also aligned to the parent's left and right edges. So we set left to be true, and right to be true as well. It's not aligned to the parent's bottom edge, so we set that to be false. And so the this text view down here, it's aligned to parent's bottom edge, right edge and left edge. So alignParentBottom would be true, alignParentLeft would be true, alignParentRight would be true, but alignParentTop would be false. In addition to positioning a child at the top portion, or the bottom portion of the screen, you can also do specific corners. If we want to position the birthday text view in the top left corner, we say align parent top to be true, and then align parent left to also be true. To position a view in the top right corner, we want to align it to the parent's top edge and right edges. So align parent top equals true, and align parent right equals true. For the bottom left corner, we're aligned to the parent's left edge and bottom edge. So we say align parent bottom equals true. True, and a line parent left equals true. These values are false, and they're false by default, so you don't need to include them in the XML code. And then for the very last corner, it's aligned to the parent's right edge and bottom edge. So align parent bottom and align parent right are equal to true. The other two are false. So we can leave them out of the code. Believe it or not there's even more attributes that you could set. You can also center the view horizontally, so you said, android layout under score horizontal to be true. And you can also add it to the existing attributes we learned before. So if this is a line to the bottom, and it's centered horizontally, it would look like this. The last one I'm going to show you is layout_centerVertical. If this is set to true, then it centers the view vertically within the parent. The reason why this TextView is aligned to the left edge of the parent, even if we didn't set this value, is because all views that are added to the relative layout, are positioned by default in the top left corner of the view group. All of these attributes are called view group layout parameters. Even though they're declared on the child XML elements, they're used by the parent view group to know how to position the children. Thus, they all start with layout underscore. This also follows the pattern of layout underscore width, and layout underscore height, which you are already familiar with. Those two attributes are also view group layout perimeters, because they are used by the view group parent, in order to position and size the children. And here's the XML for relative layout and its children. You can follow along in the link below. We have an opening relative layout tag, and we have a closing tag at the bottom here, and all the children are in between. The width and height of the RelativeLayout is set to be match_parent. Since this is the layout for our whole app, it's going to take up the whole screen. There are three child texts used inside the RelativeLayout. The first one is a TextView that says Happy. The width and height are wrap_content, and we have these additional attributes to help the relative layout, know where to position this child text view. We tell it to align it to the parent's right edge, and to align to the parent's top edge. So that puts the happy text view in the top right corner of the screen. For the birthday text view, the width and height are also wrap content. Then we want it to align to the parent's bottom and left edges. So the bottom and left edges leads to this corner down here. This last text view that says, To You, doesn't have any specific attributes specifying where it is relative to the parent. All we know is that the width and height should be wrap content. As I mentioned earlier, if you don't specify where a child view should go, by default, the relative will add it to the top left corner of the screen. All right, now it's time for a quiz. In the instructor notes below, I'm going to provide you with a link to this code. This is the XML for a RelativeLayout. I want you to read through it. Try to imagine what it would look like on the device. I know that you're fully capable of copying and pasting, so I don't want you to put it in the XML Visualizer because then that will do all the hard work for you. In this course, we also want you to be able to practice reading code. That means looking at some code and then figuring out what exactly it will translate to in your app. Experienced developers become quite good at this because then they don't need to actually run it on a device to know what it would look like. They can just modify the code here and just keep working on it, knowing in their head what it would look like. For you, since you're starting off, I want you to carefully read this as best as you can, and then you can draw it out on a scratch piece of paper if that helps you. Then tell me if the device would look something like this or like this. Go ahead and click on the option that you think best represents what would happen on the device for the XML that we gave you. The layout starts with an opening tag for a ReativeLayout. The closing tag is all the way down here, and the children XML elements are in the middle. The width and height of the RelativeLayout is set to be match_parent. Since this is the only layout for our app, this is going to take up the full width and height of the device. Then we have our first Text View that says I'm in this corner. It's aligned to the parent's bottom and left edges. That puts it in the bottom left corner of the screen. Going back to the quiz screen, the TextView I'm in this corner is in the bottom left edge of the screen. The next TextView says No, up here. This is aligned to the parent's top and left edges. That puts it in the top left corner of the screen. And indeed, we see that No, up here is in the top left corner of the screen. The third TextView says Wait, I'm here. This is aligned to the parent's bottom and right edges. This puts it in the bottom right corner of the parent. And we confirm that's it in the bottom right corner. For option B to be fully correct, the last TextView should be located in the top right corner of this screen. And it should say Actually, I'm here. And indeed the last TextView says Actually, I'm here and it's aligned to the parent's top and right edges. When positioning children relative to other sibling views, you can add constraints on their position. For example, one TextView must be above another TextView, or one ImageView must be to the left of another TextView. All these constraints remind me of making a seating chart for a dinner party. We do have our birthday party celebration coming up, so let's look at the seating chart for that. We invited all these people over for dinner But there are constraints on where people want to sit. Some people must sit next to their best friend. Other people have what you might call frenemies. So, they might not want to sit next to certain people. So, taking into account all of that, I came up with this proposed layout. Kunal, Ben, and Kagure are up here. Natalie, Lyla, and me are down here And Amy, Omoju and Jenny are in this corner. So could we build this seating arrangement in XML using TextViews and a relative layout? We know how to position views in corners. So the Lyla TextView would be aligned to the parent's left edge and bottom edge. The Jennie TextView would be aligned to the parent's right edge and bottom edge. For Ben we would align them to the top edge of the parent. By the way, we're assuming that the parent is the full width and height of the screen, so we've set match parent for width and height. So back to Ben. He's aligned to the top of the parent. We also want to center him horizontally. And formerly, you might call these three views the anchor views. Because everyone else is positioned relative to these people. And these people won't move, regardless of where everyone else is sitting. So let's add another person. We have Kunal here, who's located to the left of Ben. But how do we express that in XML? Well, there's no specific attribute that says that a view should be to the left of a view named Ben. All the Android attribute names are general so that it works for any use case that you'd want. We want to position Kunal to the left of Ben, but we don't know of any existing attribute names that can do that. Luckily though, RelativeLayout has an attribute that says android: layout_toLeftof. This means that the Kunal text view should be to the left of some view. And the way that we specify some view is to use view IDs. We can assign view ID names to any view. They don't have to be specifically addressed for RelativeLayout. They could be located within a RelativeLayout, or a LinearLayout, or any other view group. So on the Ben TextView, we can add this attribute, android:id. The value of it is the ID name. The format starts with @ symbol, @ refers to a resource in our Android app. We've also seen this @symbol for referring to images in our app. For example app Drawable. Then we specify the resource type. In this case, the resource type is an id. We also add the plus symbol because this is the first time we're declaring this id. Then we have a slash and then we have the name of the view. This is the name that we chose for the Ben TextView. We call it ben_text_view. The basic requirements are that the name can't have any spaces. That's why we use underscore symbols here. It needs to start with a letter and it can't contain any of the weird punctuation symbols. Numbers are fine though. So in this case we give Ben the ID of ben_text_view. That way we can refer to it later. So on the Kunal TextView we can add the attribute layout_toLeftof and we can say it's to the left of the Ben TextView. We refer to the ID for the Ben TextView using @id. We don't need to use the plus symbol because We've already defined that ID. This is the second time we're using the ID. When you come up with view ID names, make sure that they're all unique names. Usually, picking something related to the content inside of it is helpful. Okay, cool, so that's how you position Kunal to the left of Ben. Now, say, for example, we want to position Omoju above Jennie. Since we're going to need to refer to Jennie, we should create an ID for Jennie. On the Jennie TextView, we specify this attribute and give it this value. The ID name is jennie_text_view. On the Omoju TextView, we add this attribute. This says that Omoju should be positioned above the jennie_text_view. And this is the ID that we created up here. Let's look at the XML layout. We have a relative layout where the width and height are match_parent. Then we have the lyla_text_view. It's aligned to the parent's bottom left corner, and that's what we see down here. Then we have the jennie_text_view. It's aligned to the parents bottom right corner. So that's over here. Then we have the ben_text_view. And it's aligned to the top edge of the parent. It's also centered horizontally. These are the anchor views and now we can position the other views around them. Notice that for each of the views I already went ahead and added an ID. So this is the Ben TextView ID. Then we can position the Kunal TextView to the left of Ben. I align Kunal to the top of the parent, and to the left of the Ben TextView. I use the view ID for Ben right here. Then we position the Omoju TextView above Jenny. Omoju is aligned to the right edge of the parent, and above the Jenny TextView. Okay cool. So there's more friends to position correctly in this layout. In the instructor notes below we've provided you a link to the XML Visualizer with some initial code already in there. Go ahead and modify the XML so that we can achieve this desired layout for everyone. Some of the views are already positioned incorrectly, so you'll need to fix those. By the way, we just introduced a ton of new attributes. But don't feel like you have to memorize all of them. You can always look them up at any time. You can just search for a relativelayout, layout params. If you click on this first link, you go to the documentation for this. So these are all the XML attributes that you can put on a child view within a RelativeLayout so that the RelativeLayout knows how to lay it out. Here are some that you're already familiar with. Layout_above, alignParentbottom, alignParentright and so on. Note that for teaching purposes, the XML Visualizer may not support all of these attributes. However, when you're developing an app in Android Studio you should be able to use all of these. Okay. We gave you a link to the XML Visualizer with this initial layout. >From the device preview we can see that Natalie, Kagure and Amy are positioned incorrectly. First let's try to position Kagure in the right place. She should be located to the right of Ben and aligned to the top of the parent. So I'm going to search the XML for the Kugare TextView. Here it is. Currently it's aligned to the parent top which is correct. But this is incorrect, we don't want to align her to the parent's right edge. Instead we want to position her to the right of the Ben TextView. So now she's located to the right of Ben. Notice that I use @id/ben_text_view. There's no plus symbol because the Ben TextView ID was already created up here. Next, let's position Natalie. She should be located above Lyla and along the left edge of the parent. Here's the Natalie TextView. It's located by default on the top left corner of the parent. Let's move her so that's she's located above the Lyla TextView. And the reason why I use this name is because it was defined as Lyla's view ID name up here. Okay, great, so Kunal, Ben and Kagure are positioned correctly now. And so are Natalie, Lyla and me. Next we just need to move Amy from here over to here, so that she's above the Omoju TextView. Here's the Amy TextView. Currently she's aligned to the parent bottom. But instead we want to align her to the right edge of the parent. So, let's change that. Then we want to position her above the Omoju TextView. The reason why we know to use this ID is because it was defined as the ID for the Omoju TextView. Cool and now it's in the right place. Now let's look at a more realistic use case for a relative layout. For example, this is a good ViewGroup to use when you're building a list item like this. We've provided a link below with some XML for you to get started with. Go ahead and modify it so that you can build something like this. As a hint, first try switching from a linear layout to a relative layout. This is the original XML that we provided you. It was a vertical linear layout. And the items were appearing in a vertical column. According to the image in the quiz, we want the item to look more like a list item using a relative layout. Here's the solution. We've changed the layout so that the photo is on the left and the three text views are on the right hand side. In order to build this layout I changed the root view to be a relative layout instead of a linear layout. Since this is the opening tag, I also had to update the closing tag at the bottom. Between the opening and closing tags we have four children views. I also removed the vertical orientation attribute because that belonged to the linear layout. There's no orientation attribute needed for the relative layout. The photo was already positioned correctly. The first child of a relative layout is always positioned by default in the top left corner. And that's what we want for our list item, so this stays the same. Next we have the TextView that says Pebble Beach. We want to position this TextView to the right of the ImageView, so we need to add the attribute layout_torightof and then reference the image view. In order to reference the ImageView we had to add an ID attribute, to the ImageView. I just called it photo, but you can call it something else if you wanted. That correctly positioned the image, and the first TextView. The next TextView is for showing the text California. The California TextView has to be positioned to the right of the photo and must be below the Pebble Beach TextView. So, first we add attribute layout_toRightof and reference the photo. Then we add another attribute layout below and then we reference the first TextView. That required also adding an ID for this first TextView, we just called it name. Cool, so that position, the ImageView, and the two TextViews. Lastly, we have the TextView that shows the distance, 10 miles away. It's positioned to the right of the image and below the California text view. Thus, we had to add the attribute layout_toRightof in reference to the photo, and we also had to add an attribute for layout below, and then reference the location TextView. This involved adding the ID for the location TextView as well. I also added an ID for the distance TextView. Even though we're not referencing it anywhere, it doesn't hurt to add an ID to a view. In the case that you do need to refer to it later, it's already there. Good job so far. You're well on your way to building really great layouts. However, I do see a problem with almost all of the layouts that we built so far. The views are right up against the edge of the ViewGroup or up against the device. For all of the layouts that we've built in this lesson so far, we could add a little more visual polish to them, so that they're more beautiful by adding a little bit more white space. We'll do this using the concepts of padding and margin, which we'll cover in this video. For example, we could add a little more white space here, here, or even at the top, so that the views aren't crowded up against the edge of the parent and up against the edge of the device. It's really a design decision though, because sometimes you do want it to go edge to edge, like for the full bleed image effect that I was talking about earlier. But in any case, you can use white space to add a little more breathing room, so that the content is a little bit easier to read and scan. I'll show you the effect of adding padding or margin to a view. Let's start with a TextView that says Hello. If we add eight dips of padding to the view, then it makes it bigger by eight dips in every single direction here. If we add layout margin of eight dips to the TextView, then this is what it would look like. In order to add a margin, you need to put it inside a ViewGroup, so that's why I have it in this linear layout here. The linear layout is the one that takes original TextView and pushes it by eight dips. >From the left and from the top. And also from the sides as well. So even though you declare padding or margin on child TextView, the padding gets handled by the TextView itself. Whereas the margin gets handled by the parent ViewGroup. If you both of these on a real device, and you didn't have a background for the TextView, then technically both would look the same. the text would start eight dips over from the left, and eight dips below the top of the device. However, if you do have a background color for the TextView, then the user would be able to see that the TextView is this big. Whereas, on the other device, the TextView would only be this big. Here's a code for displaying padding on a view. On the TextView XML Element, you would declare a new attribute that says, android colon padding equals eight dips in quotation marks. You can choose whatever size you want for the padding, as long as it's a dip value. When we specify eight dips of padding, it adds eight dips to the left, top, bottom, and right edges of the TextView. Instead of using the general android padding attribute, you can also split it out to left, right, top, or bottom. Essentially, these four lines of code do the same thing as this one line. However, these fine grained controls allow you to have different padding values for left or right, or top or bottom. You don't have to have an equal padding value for all four directions. The default value for padding is zero, so if you specify left, right, and top padding, but not bottom, then that will be zero dips of bottom padding. To specify margin, you add an attribute again to the TextView. The name of the attribute is android colon layout underscore margin we can set it equal to, for example, eight dips. This moves the child TextView eight dips away from the parent on all edges. If there was another child TextView at the top here, then having a margin would push this TextView eight dips below that first TextView. You can think of having a margin as having a little force field around this view. No other view can enter this eight dip region around it. Or you can also split out layout margin into each of the four directions, layout marginLeft, layout marginRight, top, and bottom. If you don't specify any of these values, then it will default to zero. To remember that the ViewGroup is the one that positions these children based on margin, you can look at the attributes. They all start with layout underscore for margin. That way, you know that the ViewGroup is the one who's handling the position of these views. Padding and margin can apply to all views. Let's put the attributes we just learned about into practice. Here I have three TextViews in a linear layout. They're all squished up against the left edge of the screen, so I want to add a little more space. Let's start by trying to add some margin. Cool, now there's more space around this TextView. I'll do the same for the other two TextViews. Interesting, so this is 16 dips up here, but this is actually 32 dips because it's getting eight dips of bottom margin from the first TextView and eight dips of top margin from the second TextView. If we want the spacing to be consistent, so it's always 16 dips in between each view then we have to change the margin here. I can break it out in to individual margin values. With this code, I have a left margin of 16 dips and a top margin of 16 dips. There's no bottom margin from this first TextView, so this space in between is now correct at 16 dips. The same will go for the last TextView. Cool, now all the vertical spacing is equal. Earlier when I said we're adding white spaces to the edges of these views, technically that space is transparent. You can see through it, to what's behind it. In this case we have a gray background on the ViewGroup. The layout would look the same on the device wether we use margin or padding, because in this case we have no background color on the TextView. Let's add it and see where the bounds of each view are. Okay, now there's a background color on this first TextView. When we added the left and top margin, we see that the ViewGroup just pushes the TextView over by eight and down by eight. We can change this to padding, and now we see that the TextView is larger and takes up that 8 dips of space on the left and top. So visually, things would look different on the device, whether you have padding or margin. If there is a background color on this TextView. We can do the same for the other views so you see that it's well. Adding padding and margin values isn't just restricted to these children views, you can also add it on the ViewGroup. If I add a padding value for the linear layout. Then you can see that it shifts the views over by 16 dips in all directions. I mentioned that you could set any value for a padding or a margin. But how do you know which value to pick? Well, the material design guidelines recommend that you use increments of eight dips. This is a little bit more advanced knowledge, but essentially we want our components to line up on the screen along this eight dip square grid. Now the squares don't actually show up on the screen, but if you want to position text here, you might want to move it over like two squares to the left. Two squares on this Grid would equal 16 dips. On this email screen, all the icons are lined up to this line. They're positioned 16 dips over from the left edge of this screen, and all this text here is positioned 72 dips over from the left edge of this screen. So you can kind of imagine that the content is starting to follow certain lines here. Here's another way to visualize it. In this screenshot from the Google I/O app, we have the content lined up to this 16 dip line, as well as this 72 dip line. It's essentially 72 dips over from the left edge of the screen. And on this edge, the content stops 16 dips before the right edge of the screen. On the tablet, you have more screen real estate, so you can have a little more padding. It can be 24 dips over from the left edge of the screen, and so on for the other values. The reason we recommend these values is to make your content easier to read. For example, if this title was shifted over by a couple pixels, and the Subtext was shifted over to the right by a couple pixels, there would be a jagged edge here. And it would distract the user from actually reading your actual content. So by lining everything up, it makes your app easier to read and use. Here are a couple of real life examples of using padding in margin. In this Google Calendar app screenshot, we see some text here that's shifted over by a little bit here. There's also a little bit of space between these calendar events. If we implement it using padding, then this background image would probably extend into that blank space. Instead if we use margin, then it adds a little buffer zone around the view, so it's probably margin. Here's another screenshot of the detail page for a calendar event. There's a lot of text here and there seems to be larger gaps than others. We can create those larger gaps by adding padding. To add this gap here, you can either add bottom padding to this TextView, or you can add top padding to this view. Either way would work. Or you could even implement it using layout margin. You really can't tell the difference between using layout margin or padding in this case, because the background of the text used is transparent. Now it's your turn to practice with setting different padding and margin values. We've provided some initial code for you to get started using the link below. Once you're comfortable with padding and margin values, go ahead and try to build out this layout. By the way, this text is located 16 dips from the edges here. But it's ony eight dips in between the two TextViews. When you're done, check this box. To build the desired layout, the image actually goes edge to edge, so let's get rid of this padding that we have on the parent view. Cool, now the image goes edge to edge. Let's fix the text down here. We mentioned that we want 16 dp of padding all around the edges here. Okay, well, I tried to add 16 dp of padding to this TextView, but we originally wanted only 8 dp of padding here. So we should break this out into individual values and set the bottom padding to be 8 dp. Okay, now we have top, left, and right padding equal to 16 dp, but the bottom padding of this TextView is 8 dp. Cool, so now this last text you should also get 16 dp of padding. But wait, now that increases the amount of space in between the two TextViews. Let's also add 16 dp of padding to this last TextView. This makes the left and bottom and right spacing correct. But now there's too much space in between the two TextViews, so let's break this out into individual values. And we'll stop right there because we don't want any top padding on this view. The correct spacing is coming from the bottom padding of this TextView above it. Cool, so that looks correct. The only thing that's missing now is the fact that we need to get rid of this white space here. We don't need a bottom margin on this ImageView, so let's delete it. Great work, we finished building this layout. Do you have an example of using a linear layout in your app? Well, even here, this cluster of three cards is a horizontal linear layout where we just add child views like three cards. And then we set layout width to zero dp and layout weight to one. And essentially, it instructs the linear layout to take however much weight it has at run time and distribute it evenly based on other relative weights are distributed evenly between all the child views in that group. So that's one example. And another example would be over here, that you have new and updated games. And the more button which is a cluster header, it's also a simple horizontal linear layout. So when things are simple, you don't necessarily want to start writing custom layouts. Don't just use relative layout everywhere because it's more versatile than linear layout for example. That's just overkill for simpler things. So when a designer gives you a mock, how do you go about starting to build that app? So hopefully at that point, like we talked, we have not just one mock. But rather, at least two or three that show how the design scales between small screens and large screens. And then I want to identify building blocks. So, if we talk about sometime like a card which appears in a lot of places in the app, I wouldn't want necessarily to start implementing a lot of variants of the same card. Based on if it needs to show a small image or a big image or maybe show a one line title, instead of two line titles. So I'm trying to identify these blocks and implement them as stand-alone classes, stand-alone layouts and then start building on top of those. So you start from text view, image view, spinner, and whatnot to build smaller blocks. And then hopefully you're able to keep on taking those small blocks and build larger blocks while reusing the same basic set of blocks. And what's nice about it is even though you spend maybe a little bit more time up front, it becomes easier especially if the design is consistent in how it applies its language to evolve the app and to add new features. If the design is consistent, then you keep on seeing the same blocks being used in different configurations again and again. And then that's where your initial investment starts paying off where you don't treat implementation of a new screen as a brand new thing. But rather, maybe 50, 60, 70, however much percent is already there, maybe it needs a little bit tweaking with color, so maybe typography or whatnot. But hopefully, if the design is consistent, then the implementation is also easier to move forward if you already built for that. And it also becomes easier to apply redesign, just on the visual level. If you want to tweak colors, if you want to tweak typography, if you want to add maybe like we did in Lollipop where you have this ripple effect when you press something. If you have a few pieces that you keep on reusing, your styles, your layouts, then you do that visual refresh in a fewer number of places and then hopefully they get applied consistently everywhere. So for me I want to place the focus at the beginning on getting the data right, especially for an app that is getting its data from external sources. And then do closer to the pixels, refine the pixels once you have the data to do the grid, to do the typography, colors, animations, transitions, whatnot however much time you have to spend on that,. And I think it would be the same if you had something like a Twitter client. You could start by pixel-perfecting your layouts with some fake data. And then you discover that you know nothing about fetching the data from Twitter, and it takes you the next three months just to fetch the data. Or, just an example, so I prefer to start from the data. I think about this as an iceberg where you see the pretty pixels as maybe 5%, 10% of above the surface, and then there's a lot of work going below the surface, if you will, to support that. You mentioned the tip of the iceberg is what people see. So what exactly is going on below the surface? How do you see the Google Play App? So what happens below the surface is first of all to get the data from the network, so you can authenticate to be on a server and get the data. And then maybe to cache it locally so that the next time you go from the stream into the details page and back into the stream, we should be using cached data, cached images. So that we don't put too much strain on the battery. And also the app already shows the information that it has. Then you have support from multiple accounts. Then you have maybe persisting a few bits here and there in the database. Then we have the billing flows, which is, most of that work is done on the server to integrate with different payment methods. And then there's the work on the client as well. And another big part of the Play store is downloading and installing apps and games. We are, on the Play store side, we are in charge of downloading, installing, updating apps. And so that's another big chunk of, once again, pretty much all of these have their surface bits, which are pixels on the screen. And then there's a lot of work going below the surface to bring that information for the right account, and to put that on the screen. It's clear that you've worked on many different iterations of Google Play app. How do you keep up to date with the latest news in Android? There's a lot of information on Google+ from very active Android developers who put out a lot of tutorials. And, Just from different blogs, and sometimes I don't necessarily go and read deeply a certain series about recycler view or a view page or what-not or how to configure the tool bar and action bar. I kind of try to put it like that I know that there's a lot of information in there. And then when I do need that deep level of information, then I go to those resources. Well thank you so much for your time, Cyril. I think our students will really enjoy hearing your perspective on what it's like to be an Android app engineer. Kunol, we missed you in the last interview with Krohl. I know, I should have been there. I'll do the next one for sure. Okay. But you know what? What? We finished lesson one. No. Yeah, we're done. You're telling me we're one-third of the way through the course? Yeah. Oh, that's great. And you know what we should do now? No. We should recap. We should. So the first part of the lesson we learn about how a screen is made of different views. Yep, image view and text view. And we learned how to style those views. So if you want to change the color of a text for instance. And in the final bit, what we did was took different views and put them together. So we call them view groups. We use linear layout, relative layout, we use margin and padding. Yup, so we're done now. And that's Lesson 1. All right. [SOUND] Nice. I got a chilled raspberry fruit loop tea for Kunol, and green tea for Catherine. You know, they haven't even really talked about Android Studio. Let's fix that. So we're done with lesson one, right? So if this is our student, she is now at IT and at the end of lesson one. What I do is I just want to take all of this thing together and not focus too much on lesson one anymore, if that's okay? Yeah, we can move lesson two over. Okay. Let's say all of this is lesson two. What should be some of the big ideas in lesson two? Well, I think we can split it up into two parts. Okay. And what do you think we should do for the first part? Well, right here we should add some interactivity to the app, right? So, say there's a button on our app, you press the button, boom, something happens. Yeah, that sounds good. And then in the second part we can go into details of what exactly is happening and also learn about variables and methods. So all of the technical jargon that sounds like magic right now, but will not be magic at the end of this lesson. Exactly. And we can do this by building up the new app. Wait, what? We're making a new app in lesson two? Yeah, it's going to be a coffee ordering app. Wait, can we call it just Java? Okay, I get it. [LAUGH] [LAUGH]. Yes, let's get started. Let's begin by creating a new project for our app. It will be similar to the hello world app that you created with Laila early on in practice set one. See if you can remember how to set it up on your own. Use these settings for app name, package name, etcetera. So that your code will match ours for the rest of this lesson. Once it's done being created. Make sure you can run the app on your device. It should look something like this. The name of the app is shown at the top in the app bar and below that, we have the words, hello world. Here's how you create a new project in Android Studio. First, open up Android Studio. Then click Start a new Android Studio project. As we mentioned in the quiz, set the App name to be Just Java, and the Company Domain to be android.example.com. This way your code will match our code. This automatically sets the Package name to be com.example.android.justjava. This will uniquely identify our app. For the project location, feel free to select any spot on your computer to save this app, then hit Next. For the minimum SDK, we can set it to be Ice Cream Sandwich, which is API level 15. This means that our app will run on Android devices running Ice Cream Sandwich release or later. This will target 90% of the devices that are active on Google Play. Cool. So this looks good so let's hit next. These are the different templates for creating a new activity. Let's just choose blank activity template and continue. Here we have an option of changing the default names for our main activity and our layout and our menu, but these defaults are fine, so let's just hit finish. And now we wait while our project is being created. If you run into a rendering problem here regarding the action bar, you can simply change this setting to be 21. So that the device preview here will be using API level 21 This is just a temporary fix until the bug here is fixed. Then, when you ready, you can hit the screen play button to install your app on the device. I had my Nexus Six device connected so I can choose to run it on this device. And, I also click use same device for future launches so this dialogue doesn't keep popping up, then hit OK. And, this is what it looks like running on the device. It says Just Java across the top in the app bar, and it says Hello world!, down here. This is what we're going to cover and in lesson two. First, we're going to show the quantity and then an order button. Then, we're going to show the price as well. Next we're going to add a plus and a minus button so that when you tap on either of these the quantity changes. After that, we're going to take these buttons and rotate them horizontally so they show up like this for the quantity picker. And lastly, we're going to adjust the way that the price is displayed and we'll also move the order button down to the bottom of the screen. This is what the app is going to look like by the end of Lesson two. Along the way we're going to learn about Java concepts like variables and data types. That way when we click on the plus or the minus button we'll be able to update the quantity or if click on the order button we'll be able to calculate and display the price here. Now we're going to just focus on the first stage of our app and then slowly build up from there. I'd like you to plan how you're going to build up this layout. The app displays quantity 0 and then an order button. If you're stuck try going, through the three steps for creating a layout that we went over in the practice set. Select the views you want, position the view, and then style the views. In this planning stage, I'll ask for you to write a couple words for each of these. It's generally a good habit to plan out how you're going to build something, before you actually go and code it. Otherwise, you might get lost in all the details of the code. Which views do we need here? Do we need text views, image views, etc. Step two. For positioning the views, which view group will be the root view? Feel free to add other comments about how to position these views. Finally for step three we need to style the views. Is there anything we need to do here? Write your comments below, on how we need to change the view so that they look like this. Looking closely at this screen shot, we have two text views and one button. The reason why I say we have two text views is because they are styled a little bit differently. For example, the text color is different for each of these. So let's fill that in for this first step. The second step is position the views. The question asks which view group will be the root view. >From this screenshot it looks like the views are shown in a vertical column, like this. So, from what we learned in lesson one, a vertical linear layout would be a smart choice. So, I wrote down that we need a linear layout as a parent view group with three children views and we'll set the orientation to be vertical. If you said relative layout here, that's okay. That would work as well but it would just be a lot more code to have to define view IDs for each of these and then position them relative to each other. So for our use case a vertical linear layout would be a little more concise and easier to use. Lastly, for step 3 we want to style the views. For the most part these views look pretty standard but we can make some slight adjustments. For example, we notice that the quantity header here is in all caps. The quantity number down here is in black font color as opposed to the grey default color. We also notice that there's a little bit of space in between these views. Which can be accomplished with padding or margin. Now that we've thoroughly planned this out, go ahead and build out this layout in your app. You'll need to find and modify the activity_main.xml file. The activity_main.xml file should already be open when you first create your project. If it's not already open, you can find this file under the layout folder. Under res under app in the project view of your app, which lists all the files in your app. The design pane is open by default, where you can drag and drop widgets from this palette here over onto the app. However, I want you to use the text pane so you can write your XML here. At any point, when you modify your XML, you can always select this content and reformat it. Across the top of Android Studio you should see a bunch of menu items. Click on Code, and then you'll find an option to Reformat Code. And here's the keyboard shortcut if you're on Mac. You can reformat the code and selected text is fine. Just click Run and then it automatically reformats your code to fix the spacing and the tabs. You can also select Rearrange Code. It modifies the order of the attributes here so that it's in the preferred order according to the Android code style guidelines. And now the code is a lot easier to read in this format. If you want a preview of what this code looks like, you can click on the Preview button here. And this shows what it would look like on a device. But this isn't a substitute for running it on your device, so you should always run it on your device periodically. Once you build out this layout, please also assign a view ID name on this second TextView here that displays a 0. Give it a view ID name of @+id/quantity_text_view. Use this exact name so that it will match our code later on. Remember that we learned how to assign IDs to views in lesson one. This example was for relative layout, where we had a dinner party for our best friends and our frenemies. Also, the reason why we give this view an ID but not the others is because we will want to later refer to this TextView so that we can update it to increase or decrease the quantity. For styling the views, there's a couple small changes. This TextView here should have a text size of 16sp and use a black font color. You can use the black system font color like we showed you in lesson one or you can use the black hex color, which we've included below. There's also 16 dp of space in between each of these views. I know that this is the first time that you are going to be adding a button to your XML layout. This is a really great opportunity for you to practice your Google search skills in order to figure out how to add a button to your layout. If you really get stuck, you can check the hint in the instructor notes. As you build this up, periodically run the app on your device to check that it's working as expected. When you're done with all of this, answer this question. What happens when you click on this button? To build this layout, I open up the activity_main.xml file. I know that I need a vertical linear layout to put each of these views in a vertical column. So, I'm going to first change the relative layout into a linear layout. Immediately, it shows an error saying that the opening tag does not match the closing tag, so I can just copy this over and then paste it down here. Now the tags match. Next, I can add in the views. First, I have a quantity text view. So I'm going to take this text view and then change the text inside to quantity. Next, I have a text view that says zero. So I can copy the first text view and paste it below it. I'm going to change it so the text says zero to match the screenshot here. The last child in this linear layout is a button. We haven't added a button before in our layout, so let's Google Search that. If you open up a browser you can search for button android. This first link looks good, it's a developer.android.com site. And here's the documentation for button, we can ignore most of this text here. We scroll down to read the class overview. It talks a little bit about some Java code, which we haven't learned yet but down here we have some xml for a button. We can copy this and see what it does in our code. In our layout I'm going to add a button below these two text views. I'm going to paste the code from the documentation here. And now instead of the self destruct string, I'm going to go for something a little friendlier like order. This last line we can also delete because we don't need it. Cool, so now you have a quantity text view, a text view that says zero, and an order button. Let's run it on our app, to see what it looks like, by hitting the green play button. We can see down here that it's still building. Oh, this isn't what we wanted. It appears that our linear layout is actually horizontal instead of vertical. So let's make sure that we add the orientation attribute. We're going to change this to say android;orientation="vertical". That should fix the problem. So let's hit run again. Okay, that's better now. The three children are showing up in a vertical column. Now we just need to style these fields so they look a little bit more like the screenshot we were given. >From this screenshot we see that the quantity text view is in all caps. In lesson one we learned about an attribute called android:textAllCaps, and it's showing up here in the auto-complete. If it shows up like this, you can just hit enter and it automatically adds it in the code here for you. We set that value to be true because we want it in all caps. The reason why it's better to use this attribute to capitalize the text is because if we ever want to change the UI so that quantity is in lower case, like this, all we need to do is just remove this attribute instead of going and changing this text. Next, for this text here that says zero, we should use a text size of 16sp. Let me add that now and it shows up in the auto-complete suggestions so I just hit enter and then I choose 16sp for the value. We also want it to be a black font color. I'm going to use the Android system color for black, which is referred to like this. Cool, that takes care of both the quantity and the zero text views. The order button is fine as is, it will automatically capitalize the text for you in a button and the height and width are wrap content. We do have a need to resolve this vertical space here. We want 16dp of padding or margin in between the quantity and the zero text views. We also want also want 16dp of padding in between the zero and the order button. You can implement this in many different ways, I'm just going to choose to add it as layout top margin for this button. And I'm going to add it as a bottom margin for this quantity text view. Feel free to do it a different way as long as it looks the same. The reason why I chose to do a bottom margin and a top margin is because I know that this middle area here is going to change later. We're going to change it to be a quantity picker with a plus and minus button, and I still want to have 16dp of space between the quantity title and the picker. Same for the button. Okay, let's run it again now on our device. Cool, and it looks just like we wanted. The quantity text view is in all caps, the zero text view is in black font color, size 16sp, and we have the order button here. We also have 16dp of space between these views. Good job. Oh, and I almost forgot. The quiz also asks for what happens when you click on this button. Well, actually it does nothing, for now at least. Keep watching to find out what happens next. All right, enough talk. Are you ready to look at your very first Java file? Well you actually have already done some work to create that file. Let's go back in time. Remember the Wizard we used to create our project? We chose the Empty Activity template which automatically created a new activity for us. It prompted us to provide a name for the activity and we just accepted the default name of MainActivity. An activity represents a single focus thing that the user can do. Sometimes an activity is one screen and an app. Other times, a single activity can have multiple screens. Essentially an activity is how you can display your layout and interact with the user. In this case we also accepted the default name for the layout, which is activity_main, which is an XML file. So this MainActivity is displaying this layout file. In the Gmail app, for example, we have a ConversationListActivity. This activity displays a list of conversations. If you click on this hamburger icon, it opens up the navigation door, and you can switch to other views like the social emails, the promotion emails, or updates. Even though these go to different screens, they're all part of the ConversationListActivity. They all revolve around viewing emails. Gmail also has another activity called Compose Activity. This activity is for the user to create a new email. So you can see how each activity is focused on a certain thing that the user can do. Here's another example. This is the sunshine weather app. This is actually the project that you can build up in the Android fundamentals Udacity course. The main activity is the main screen which shows the list of weather forecasts for the whole week. The detail activity shows the details for the weather forecast for a single day. And then the settings activity is where you can go to change the location or temperature units. So you can see how each activity is focused on a certain thing that the user can do. In our coffee ordering app, we're just going to have the MainActivity. Speaking of our app, the main activity for our app is defined in a file called MainActivity.java. Notice that the file extension, or the suffix here, ends in .java. That's how the computer will know that it's a java file. By the way on your computer it'll look something like this. This is simply a new file extension that you probably haven't seen before. Other file extensions you may be familiar with are .xml, for the activity_main xml file, or png or jpeg for image files. You can find this file in your computer by navigating through the files in your app in Android studio. A lot of these files were automatically generated for us. So look in the app folder under Java and then com.example.android.justjava. Justjava is the name of our app. There are also other files if you expand out the gray arrows but we don't need to worry about them now. Okay. And then we can find MainActivity. Just double click on that to open it. I'm going to slide this view over so that I can see MainActivity better. Now here's all the code the Android studio automatically generated for us for the MainActivity. Seeing Java code for the very first time can be scary and overwhelming. So don't worry, it's totally normal to not understand any of this. I felt confused when I first started off. And I still get confused when I look at files that I have never seen before. When you see this you may just see a bunch of random symbols everywhere. With blank spaces in weird places. Some words might be recognizable in English, while others, just don't mean anything to you. Don't worry though, we're going to understand all of this code soon. What we will do now is modify the code that Android Studio gave us, so that our app does something when the order button is clicked. The new code for MainActivity is included in the link below in the instructor notes. We want you to copy over all of this code here, and then in Android studio go ahead and select all of this and delete it. Then paste the new version that we gave you. In the code that you just copied, notice that we included some comments as well. A comment follows the following format. It starts with these symbols and it ends with this, and it can go on for as many lines as you want. The purpose of a comment is to describe the code in some way. And you can describe it using plain English or any language that you want to use. And it doesn't have to follow the format or the rules of the programming language. So we have a comment up here to describe the purpose of the MainActivity. And we have comments on these methods here to explain what the individual methods do. If you want more information on writing comments in Java, just Google search that. It's aimed to help the person who's reading the code, either you or other people, better understand the intent behind why that code was written. It's also really good habit to always comment your code so that when you go back to it, it's easier to read. If you want to learn more, feel free to click on any of these links. So feel free to read the comments that we left here. Now, in order to make the order button do something in our app, we also need to make one more change to the activity_main layout file. We need to add an extra attribute to the button XML element. The attribute name is onClick. And the value will be submitOrder. Use this exact name so that your code matches ours. Also remember the o, because this method name is in camel case with no spaces. Don't worry about what this means for now. We'll learn more about it in the next video. Also, if you haven't already done it, make sure that this TextView here has an ID of quantity_text_view. These changes will make your layout work with the new main activity Java code that we gave you. Go ahead and make these changes now. Modify the activity main layout file, and then replace the entire MainActivity.java file with the one that we give you. And then also run the app on the device to make sure that it still works. After all of this, if there are no errors, then can you tell me what happens when you click on the button? Write your answer here in this text box. After you've modified the activity main layout file to add the on click attribute here, and you've copied over the new version of the main activity code, then click this green Run button. When the device chooser pops up, this option is correct. And I'm going to click Use same device for future launches. And now we have the app running on our device. To answer the quiz question, what happens when you click on the order button? Well it actually updates the quantity value here to be one. Exciting. Now lets understand what's going on behind the scenes to produce this change in the UI. Hooray! You just made your app interactive for the user. Before, when you tapped on the button, it didn't do anything. But now, with some code changes, when you tap on the button, it actually updates something on the screen. Great job! Let's try to dig deeper into what you just accomplished. First you added a new android:onClick= attribute on the button XML element. This means when the button is clicked on, then it will try to perform or execute as we say in Java a set of instructions that have been named submit order. Okay. Going into the main activity file that we gave you. I know there's a lot of weird symbols and words on this screen. But all you need to know now is that this is a method and its name is submit order. A method can contain multiple lines of java code. And this translates into a set of instructions that the device can understand and perform. If there are multiple lines of code in this method, the device would perform the first line first and then the second line and so on until the bottom of the method. The reason why we give methods a name is so that we can easily refer to it later. For example, in the XML we can refer to the method submitOrder now. It's sort of how I have a name, you have a name. If you had a pet, you would also give it a name so that you can easily refer to it. So in code, if we have a bunch of statements that we want to refer to, we can put it inside a method, and then give the method a name. So remember in lesson one how we told you that XML has very specific syntax rules that determine whether something is valid XML or not. Well, Java has similar types of rules for determining what is valid Java code. For methods, the statements inside of them must be contained within this opening squiggly brace and this closing squiggly brace. Up here, this is also a method called onCreate. The statements inside this method are contained within this opening brace and this closing brace. And, lastly, there's this method, which is called display. The code statements inside of it are marked off by this opening brace and this closing brace. You also notice that there's also an opening and closing brace for the MainActivity. All the functionality of the MainActivity is defined within this opening and closing brace. So far, this MainActivity contains three methods inside it. So after you declare a method, which means defining the method, then you can actually use that method. In this example, we declare the display method, and then we use it on this line of code, where we call it by its name. So this is where we declare the method and this is where we call the method. So to summarize, when the button is pressed in the UI, then it triggers the submitOrder method to be called. Then we execute each line of code in the submitOrder method from the top of the method to the bottom of the method. In this case, there's only one code statement in there, so we just run that. Okay, now let's look at this line of code here that says display one. The reason why I picked this line of code is because it seems like the number inside the parenthesis is what gets displayed on the screen here. So, when I click on this order button here, in the UI, then it triggers the submit order method to be called in the main activity. Then we perform this line of code here that says display 1. And that updates the screen to show 1 here. So if I change this to be 2 here, what do you think will happen? Let's run the app to find out. And now when I click on this button, it shows 2. Clicking on the order button triggers the submit order method to be called. And then we perform this line of code that says display 2. And that's what updates the screen to show 2. Now it's your turn. Can you try changing this number here in parenthesis to a different number? You can pick another small number, a big number, or even a negative number. Once you've experimented with this line of code in the main activity then check this box when you're done. Okay hopefully you had a chance to experiment with different numbers. Earlier I showed you how to change it to display two on the screen. Now let's try this big number. Cool. So now when I hit the Order button, I have so many cups of coffee, I don't even know what to do with. Now that you've modified your first line of Java code, lets see what else we can do. We can actually do some math expressions. And if you don't like that thought of math, well the good news is that Android actually does the math for you. You just have to come up with the problem. Say you have two people and each of those two people wants two cups of coffee. Now this will display the total amount of coffee that you need to get them. We run it on our device and then we hit Order and then we see four. So you see how we can type in math expressions and it will automatically solve it for us. We can also do even harder math expressions like things we wouldn't even want to calculate in our head. For example, say there's a whole group of Android developers and they're really thirsty. Say they each want to drink three cups of coffee each, because they're not morning people. And then we also want to throw in some extra cups as well. That's a lot of coffee. Let's see how much that actually turns out to be. You hit the Order button and it says 59. Interesting. I guess developers do write better code when they have a lot of caffeine in them. In a moment I'm going to have you type in your own math expressions here. As a heads up, if you run into any errors, for example, if you type a letter accidentally, then you will see a red error show up on the right hand side here. The error says it cannot resolve the symbol a because a is not a valid number. Here's another possible error if you accidentally type the multiplication symbol multiple times you would get an error here. In this case it would be more helpful to to hit undo and then your code would work again. As we mentioned in lesson one, you can try to read the error message first. Sometimes, the error message doesn't exactly pinpoint the problem. You can also compare it to working code. We just showed you an example of a math expression that worked. You can also try to hit undo to retrace your steps. Or, you can always ask for help. Okay, now it's your turn to try to come up with a really hard coffee order for the device to try to calculate. You can experiment with different math expressions. Here's an example of one. As you can see, you can use different symbols here or addition, subtraction, multiplication and division. These are what we call arithmetic operators. If you ever need to refer to this later, you can alway search for arithmetic operators java. This page lists the summary of all the different operators in Java. And here are the arithmetic operators listed. If you want you can always learn about other operators as well. For this quiz though, we are just going to focus on the arithmetic operators. The reason why we call this an expression is because it's a bunch of symbols and numbers that eventually evaluate to a single value. And this expression is evaluated according to order of operations which you might have learned in math class. If there's anything in parentheses, it evaluates that first to be four. And then it does the multiplication and division parts from left to right. I don't actually know what this evaluates to, but you can try it in your app. Once you've become comfortable with trying different math expressions, try this problem. I want you to display the number of coffees that you would need If there are 77 Android developers who drink two cups of coffee each and then one straggler walks in late and needs a cup of coffee, too And here's the solution. We call the display method, and then in parentheses, we put the math expression. We want 77 people, times 2 for the total number of coffees for the 77 Android developers, and then we want to add 1 for that straggler. We also remember the ; at the very end of the line. Now I can enter this into Android Studio. I'm going to highlight what was all ready in parentheses and delete that, and then I'm going to type 77 * 2 + 1. Then, I'll run the app. When the app launches, then I just hit the Order button and then it automatically tells me how many cups of coffee I need for all those developers. I want you to build up this layout on your own. You'll add one text view for the price header here and then another text view to show zero dollars. Also assign this second text view a view ID of price_text_view. The reason why I ask you to add an ID is because we're going to need to reference this view later so we can update the price. And while you're at it, also make the style of these two text views similar to the quantity text views. In terms of vertical spacing, we also have 16dp in between these views. In order for the price field to also update, we're going to need to make some changes to the main activity Java file. We'll give you a little more help with that. We're going to provide you with a new method that you can add in the main activity Java file. Open up the gist in the link provided in the instructor notes. By the way, a gist means a snippet or a short region of reusable code that you want to share with others. In this case, we went to the GitHub Gist webpage, and we created a new Gist with this code that we wanted to give you. And now we can just share this link with you, and you can get the code. For this snippet, we're going to select the whole thing, and then copy it. Remember to include the comment up here, which is a note to the reader and this closing brace down here. Now we're going to paste it in the main activity Java file. I love free code. Make sure that the braces still line up after you paste it. Braces are a pain whether they're in your app or on your teeth. You can get a ton of errors if your braces don’t line up.. For example, if I paste this code block right down here, then I get an error saying class or interface expected. The reason is because this method is hanging out in the middle of nowhere. Really, we want it to be inside the main activity between the opening and the closing braces of the main activity. So, let's copy this and put it before the closing brace of the main activity. And that's better. Another potential error is if you forget to copy the closing brace, and you just grab this top part of the method. In that case, you would get another error that says that the closing brace is expected. So you would need to add that back in. The other potential error you might run into is if you accidentally add the method right here. This is before the closing brace of the display method. So now this whole thing is inside the display method, which is not what we want. We want it to be beside the display method, right out here. You get the idea, there's a million combinations. You just want to be careful and make sure that your braces line up. Another good way to check is if you put your cursor right here, right after the opening brace you can see that it highlights the closing brace that matches with it. Same here, if I click on this, the closing brace that matches with this is right here. Same for submitOrder method and onCreate method and even the MainActivity. This is the opening brace for the MainActivity, and the closing brace is highlighted in blue all the way down here. Now unfortunately, we still have another error here. If I look in the side bar here it says cannot resolve symbol number format. Number format is actually something provided by Android in order to help format numbers. In this case we're trying to format the number which is the price so that it has a dollar sign, or whatever local currency you're using. We need to add an import statement for this, because currently Android Studio can't recognize what this is. To resolve this I'm going to show you how to turn on auto import. In the menu across the top of Android Studio, click on Android Studio > Preferences. This opens up the preferences for Android Studio. There's a ton of preferences that I've never changed, but if you ever need something I just search it using this search box. So I'm going to type in Auto Import. Now, it shows the settings for automatically importing things in XML and Java. I want to check this box here that says, Add Unambiguous Imports on the fly. This phrase may not mean anything to you, but that's okay. This phrase probably sounds really confusing. All it's doing is telling Android Studio that it's okay to automatically add some additional lines of code in our app. Specifically import statements, if it knows what we're referring to. Let me show you. Well actually, it already did it for us. It assumed that when we said number format, we meant this one and it is correct. So it solved the problem for us automatically. Which is great. Okay. At this point, if you run the app, then when you click on the Order button then the quantity changes, but not the price. We need to modify the submit order method so that it updates the quantity as well as the price. So let's add another line of code. I'm going to call the display price method and I'm going to say that the price is two cups of coffee times $5 each. The reason why our coffee is $5 each is because we've imported Arabica beans from Ethiopia. But anyways, we're going to let the device do the calculation for us, because we have two cups of coffee at $5 each. By the way, when I refer to dollars in this lesson, feel free to swap it out for your own local currency. There's no dollar sign in this math expression. It gets added on later in the display price method. But don't worry about the details of the display price method, we're going to be going over that in lesson three. For now just focus on the math expression that you're going to use to calculate the price. Also remember the semicolon at the end of each statement, otherwise the semicolon monster is going to come and get you and give you a red error. For example, when you remove the semi colon, then you get an error that says, that the semi colon is expected. Oh, and to be extra, extra clear, the semi colon key, is this one right here. It's not the colon, it's the semi colon. All right, so when you finish everything, you should have two more text views added for the price here. You should have modified the main activity to include the new method we gave you. And you would've also modified the submitOrder method to add a new line of code to display the price. When you run it on your device it should look something like this. It starts off at zero quantity for $0. And when you tap on it, there's now two coffees ordered for $10. Feel free to experiment with different values for quantity and price. If you want to charge $10 for a cup of coffee, you can go right ahead. Make sure you switch it back to two cups of coffee at $5 each so that it matches our code going forward. Check these boxes when you are done. First we need to modify the activity main layout so that we can add the text views for price. If the device preview isn't showing already, you can click on this link here that says Preview in order to make it appear. Now, when we change the XML, we can just see it update automatically, here. In this screen shot we provided for you, the price was presented in a similar way to the quantity. We have a header, as well as a text view, to show the value. So we can just copy over these two text view elements and then paste it beneath it. Now we just need to tweak the values to fit our scenario. Instead of quantity, it should say price. And, we should also change the ID to be price text view. You can have two views with the same ID. But, anyways, in the quiz, we told you to change this to be price text view. So, it would match our code. There. And that makes the error go away. Okay, looking at the preview, we have the price header, and zero beneath it. We also want to just change this just to be zero dollars. And you can use your own currency symbol if you want. The header is in all caps and the actual price value has the text size of 16 sp and a black text color. That looks good so far, except I do notice there needs to be a little more vertical space between the price header and the quantity value. I'm just going to change all the views so that they have a margin top, value of 16dp. And then instead of margin bottom here, I'm just going to do, margin top, 16, and that actually fixes it. Cool. Now all the views are evenly spaced apart. Once you think the XML is in a good state, then you can just run it on your device. Cool, and that looks good. Let's work on the MainActivity file now. If this Android DDMS window pops up, you can just collapse it using this arrow. In the MainActivity, we asked you to copy and paste the displayPrice method that we gave you. Hopefully, you also modified your Android Studio preferences to automatically import things if they were unambiguous. That would help resolve the problem of it not knowing what number format referred to. But now with the import statement, the app knows that number format is something that's provided automatically by Java to help format numbers. Then for the last step, we modify the submit order method, so that when the button is clicked, we display the quantity and also display the price. Okay Katherine, our app is coming along, but there is one major problem with it. What's the problem? Well it only orders two cups of coffee. What's wrong with two cups of coffee? Well three is better than two, four is better than three, sometimes I need more. Okay I get it, you need more coffee. So what I can do is just change the code, so that instead of two it just says three. Okay, so in our code here, we will need to change the number of cups of coffee Here and here. So what if I want ten cups of coffee for myself and my friends later on? You have that many friends? Oh. Well, we need something else, then. Yeah, we need a better solution. How about, oh, I know, we can use variables. Variables? As in something that varies? Yeah, a variable doesn't have a fixed value. You can think of a variable like a box [SOUND] like this. Okay. Yeah, so this is a variable. It's a box and you can put a value inside of it. It says int. Yeah, int stands for integer. Okay, so you can put an integer, or a number, inside of this box. Exactly! And you can even give it a name. Let's call it number of cups of coffees ordered. Okay. You had to pick a long name. Ordered Barely fits. Okay. Okay. So now we can refer to this variable using this name in a code instead of putting the value two. Okay. Later we can also update it if we want. Let's put the value inside now. How are we going to do that? Well, I have some Post-its. Where did those come from? Let's call the number of cups of coffees ordered to be 2. Why only 2? One for me and one for my friend, Katherine. Thank you. [LAUGH] So now we have a variable that is called numberOfCoffeesOrdered and it holds the value 2. Let's implement this in our code. Before we were using a literal value to represent the quantity of coffee cups ordered. A literal means a fixed value, like the number 2. Technically the 5 and this 2 are also literal values but we're just talking about using literals for the quantity right now. So if we say the quantity is 2 cups of coffee ordered, then when we calculate the price, we have to do 2 times 5, since each cup is $5. If we want to charge the customer for a paper cup because they didn't bring their own cup and they like to waste trees, then we charge them $2 per cup. So that's 2 cups times $2. When we use a literal, you can see that it's not ideal because we have to keep repeating the quantity number over and over again. On the other hand, we can use a variable to represent the quantity of coffee cups ordered. So if we say the quantity is this variable called numberOfCoffees, then when we calculate the price, we can just use that variable name, numberOfCoffees, and multiply it by $5 a cup. To calculate the charge for the paper cup, again we take the variable name, numberOfCoffees, and we just multiply it by 2, for $2. So the difference between these two is that instead of the actual literal value, we use a variable. And then the value of that variable will be substituted when we actually evaluate this expression. So when we go and calculate the price, we just have to go check what this value is before we multiply by 5. The one additional step that you need to do when you use a variable is, in the beginning, to set the variable, numberOfCoffees, to have an initial value. In this case we set it to an initial value of 2, which is also a literal. But this time we only use the literal in one place instead of in multiple places. The end result is still going to be the same, because of numberOfCoffees will map to the value 2. So the quantity will still be 2, the price will still be 10, and the paper cup charge will still be 4. The real advantage to this approach is that you can change the variable value at any time. Say I want to change the numberOfCoffees to be 3. I just need to change it in one place here and then everything else is still accurate. The quantity is still the numberOfCoffees, which now has a value of 3. The price is now numberOfCoffees times 5. And the value is 3 times 5, and the paper cup charge is still numberOfCoffees times 2. Which is now 3 times 2. If we were using a literal, then we would have to change the quantity to be 3 here. We would have to update the price calculation to be 3 times 5. And the paper cup charge to be 3 times 2. So when we use a variable, we don't have to refer to the specific value each time. We can just refer to the variable name and that will automatically get us the latest value in that variable. We can look more closely at what the actual code would look like for creating and using a variable. To create the variable, we say int numberOfCoffees = 2. This creates a variable for us with this name numberOfCoffees and it puts the value 2 inside that variable box. These next two lines use the variable that we created on the first line in order to update this screen. We can display the number of coffees, which involves looking at that variable and checking the value inside, which is two. So we show 2 here. To display the price. We look at the value of the variable, numberOfCoffees, which has 2 inside. So, we say 2 x 5 equals 10, and so the price is $10. I can easily change this code, so that the numberOfCoffees ordered is 3 instead of 2. For the box that represents our variable, numberOfCoffees, now we put 3 as initial value inside this variable. These two lines of code don't have to change though, because we are using the variable name. When we called display numberOfCoffees. The value in this variable is 3. So we show the quantity 3. To display price we look at the value for the numberOfCoffees which is 3. And we multiply that by 5 so that gives us $15. This is what the code change would like in Android Studio. Currently it's using the literal value of 2 for the quantity. Instead let's create a variable, I'll type int numberOfCoffees 2. So now I have a variable with the value 2. By the way, this text is grayed out and it says variable number of coffees is never used because I never referred to it again, but I am about to use it now. Instead of displaying the literal value 2, I'm going to switch it to use the variable name. It pops up as an autocomplete option, so you can just hit Enter and it fills it in automatically for you. Then this variable name is no longer gray because now we've used it in at least one place. I can do the same for displayPrice. Instead of the using the literal value of 2, I'm going to change it to be the variable numberOfCoffees, and I just hit Enter to auto complete. Technically I could also create a variable for the price value of 5. However, it's only used in one place so I might as well just leave it as a literal value. Okay, now let's save the code and run it on the device. And this is what it looks like on the device. When you hit Order, the quantity is 2, and the price is $10.00. This is exactly the same behavior as before, but now our code is more robust. Robust means that the code is less prone to errors in the future. For example, if someone else is trying to change this code, and they were trying to use the quantity in many other places, then they would have to change the number 2 in so many different places. Instead if we used a variable, numberOfCoffees, then we only have to change it in one place and then everything will automatically update. This way someone won't mistakenly miss a line of code that needs to have the latest numberOfCoffees ordered. They only have to change it in one single place. Now before you go ahead and do this in Android Studio, I want you to to first practice doing it in this quiz. Go ahead and type out this line of code right below it. This line of code will create a new integer variable, and these two lines will use the integer variable. The reason why I want you to practice this first is that you can pay attention to every single character when you type it. Otherwise, if you miss a character, you may get an error in Android Studio, and it may be hard to read the error message. So go ahead and type it exactly as you see it. This is helping you become aware of every single character here, whether it's a capital letter or a lower case, or if there's no spaces or if there is a space. You'll also start getting used to the rules of Java in terms of creating a variable or using a variable, and as you learned before, every Java code statement also has to end with a semicolon. If you type this incorrectly, for example, the variable name, that would give you an error in Java. However, other things are more conventional and best practices. For example adding a space before and after operators like this. If you don't follow this spacing, it won't give you an explicit error however it's just better programming practice to follow these code style conventions. That way it's easier to read your code, when you're done typing this out go ahead and continue to the next video. Hopefully you were able to type that in okay. In Java, variable names, data types, method names, they are all case sensitive, so it's important to pay attention to whether a letter should be capitalized or not. Another potential mistake when you're creating a new variable is that you might forget the data type or you might forget the semicolon. By typing this out, now you've had experience creating and using variables. In the video, we'll explain a little more about what you actually just typed. This line of code's responsible for creating a variable. Remember that a variable is like this box, number of coffees, with a value of two inside. We'll talk about each part of this line of code and then we're going to create more variables in this lesson. You may have noticed there's specific rules for how to declare a variable. When I say declare a variable it means the same thing as defining a variable or creating a variable. This is the line of code that we've seen so far. It follows a very specific format for how to declare variables in Java. You could think of it almost like a formula. First, we need to say what type of data can go inside the variable. In this case, it's an integer, which we call int for short. Next is the variable name. In our case, the variable name is numberOfCoffees followed by the initial value. In this case it's 2; for 2 cups of coffee ordered, and this code statement ends with a ; according to the rules of Java. Let's break down this line one piece at a time. The first word is Data type, this is a type of data that's allowed to go inside at this variable. In this case we only let integer numbers. Gets stored inside the variable. As I mentioned earlier int is short for integer. An integer is a whole number. Basically any number including zero and negative numbers that are not fractions or decimals. 0, 5, 145, all of these are examples of integers. The number of coffees ordered should only be a whole number like one, two, four, et cetera. We don't want the customer to order 1.5 cups of coffee. If they want more than one cup, they're going to have to buy two, then they can give the remaining half to a friend or something. As for negative numbers, it doesn't make as much sense in our case. There's no data type in Java that only allows positive numbers. So later in the next lesson, we're going to learn how to add code that prevents negative numbers from going inside the variable. The next part of the declaration is the Variable name. In this case it's numberOfCoffees. Notice that it's spelled camel case. It starts with a lowercase letter and since there are multiple words, it capitalizes the start of each other word. You can think of it as putting a name tag on the variable. You can refer to this variable with this name. And here I've drawn it out like this as well. This variable box has this name. If you want to know what this value is. Or change it, you need to use the name. Choosing an appropriate variable name is actually up to you the developer, depending on what the variable is used for. In this case, since the variable is storing the numberOfCoffees ordered I just picked this variable name. You could have picked other names, like coffee count or number of coffees ordered or ordered coffees. Really it could be anything, as long as it's easy for other people to understand what this variable represents. When I say that the variable name can be anything, there's actually a couple of rules that Java has about variable names. Let's look up those rules now. Let me type in variable names Java. This first link looks good. This is official Java documentation from Oracle. This top part talks about variables, which you can read in your infinite free time. Down here is what we're interested in. It talks about naming for variables. It can be any length, but a really long name is not very practical. A really short name, on the other hand, can be good, but if it's only one character, like N, you may not know what n stands for. So you want to strike a balance between a descriptive name and one that isn't a pain to type out every single time. There are a bunch more details here that you can read if you want. But the main point is that if your name only consists of one word then spell out that word in all lower case letters. Like cadence, speed, gear, things like that. If the variable name consists of more than one word then you want to capitalize the first letter of each subsequent word but it needs to start with a lower case first. So gear ratio is an example or current gear. Our example of number of coffees also follows this rule. The next part of the declaration is Assignment operator or the = sign. In math class, you're used to seeing things like one plus one equals two. But in Java, equals means a different thing. Equal means assigning a value to a variable. In this case, we're assigning the value 2 to the variable numberOfCoffees. Using our box metaphor, we put the number 2 inside the variable that represents number of coffees. So whenever you see the equals sign, think about grabbing what's on the right-hand side of it and putting it inside the variable on the left-hand side. We already talked a little bit about this, but this two here is the initial value of the variable. So you put the 2 inside this variable. Remember that this initial value must be of a valid type according to this data type. In this case only integers are allowed in this variable. 2 is a valid integer so it's okay for it to go inside this variable. And last but not least, we have this ; at the very end. So to summarize, when you declare a variable, you need to specify the data type, followed by the variable name, and then an equal sign, and then an initial value, and then a semicolon. In this case, we're creating a variable called numberOfCoffees. The data type is int, so only integers can be stored in this variable. And we're assigning the value 2 to be the initial value of this variable. Or you can change the variable name according to the rules we talked about. And you can change the initial value as long as it's the same data type. You can't change this data type, it needs to be spelled int, I-N-T. We're going to be learning about other data types as well, and those have to be spelled a specific way. Now any time you need to use a variable, just refer to it by it's name, and then it will be swapped out for the actual value later when the app is actually running. Now I want you to go ahead and add these lines of code to your app, please don't copy and past though, because I want you to practice typing out, creating and using a variable. Then go ahead and run the app on your phone. Make sure that when you hit the Order button, this is what you see. After that, I want you to do a little bit of experimenting. Try to assign a new initial value to the variable. Then go ahead and try to assign a new variable name. Instead of numberOfCoffees, try something else like quantity for example. A common beginner mistake is to think that you typed it out correctly because your eyes are scanning over the whole thing really quickly. But if you look individually at every single character you would notice that there might be a problem. This will take you some time to finish but take your time and pay close attentions to each character that you type. If you run into problems, try reading the error message. For example, this error message says cannot resolve symbol numberOCoffees. Java doesn't recognize what numberOCoffees is because the variable name was actually numberOfCoffees. Hopefully you can figure out from the error or you can hit undo and that sometimes resolves the error as well. Or you can go back to code that you know works, like the code that we gave you. When you're done, check these boxes and continue. If you typed out the code that we gave you, then when you run it on your phone, when you hit the ORDER button, then the quantity is 2 and the price is $10. Now let's try to change the initial value of the variable. Instead of 2, let's make it 5 cups of coffee. It's just one of those days. So when we say display(numberOfCoffees), it's going to display 5 as the quantity. If we say displayPrice, then numberOfCoffees is 5, and 5 times 5 should be $25. So, let's run it on our phone to see if that's what happens, and yes it does. Now, let's try to change the variable name. I'm going to delete this variable name, numberOfCoffees, and I'm going to change it to quantity. It's a lot shorter name so I like it better. Immediately the variable name is grayed out, and we get a warning that says, variable quantity is never used. That's because we never actually refer to the variable quantity. We just create it but never use it. But not for long. We're going to use it. We need to change these two lines of code to use the variable quantity. Right now there's an error because it cannot resolve the symbol numberOfCoffees, because that's not a variable anymore. So let's copy over quantity and replace those references to numberOfCoffees with the new variable name. Cool, now there's no more errors. Let's run the app. When you hit the ORDER button, the quantity is 5, and price is $25. This is the same behavior as the last time we ran the app. When you change the variable name, there's no visible difference to the end user. The variable name is just for us developers to use when we're writing our app. Since quantity is a shorter name and it's still accurate in terms of the information that it holds, quantity of coffee cups ordered, let's continue using this variable name going forward. A crash in an app is when it unexpectedly quits and shows a dialogue message saying that the app has just stopped. It happens to Android developers many, many times a day. Even the most experienced ones. Sometimes the problem is due to a typo in their code, or a silly mistake. Other times it can be due to a fundamental misunderstanding of how to write the code for a certain feature. While your reaction may be to panic, the voice of reason inside your head should tell you yo go ahead and try to debug the app. In this video we're going to learn how to debug Android app crashes. To debug means to identify and fix bugs or errors in your app. If it's a really obvious error like a java syntax error, then Android's DU can catch that for you and show a red error before it tries to install the app on your phone. This is called the compile time error because it will fail to create any app to even install on your device. If you want to try creating a compile time error, go ahead and just delete this parentheses or this semicolon and then you'll see the error pop up. This is like in lesson one when we tried to create an XML error intentionally. And then we read the error message and then we undid the change. Other potential errors are if I try to delete this opening brace, then I'll get an error, or if I forget this closing brace, then I also get an error. But sometimes the error only happens when you start using the app. This is called a run time error because it happens when your app is running. Let's intentionally create a crash in the app and figure out the steps of how to solve it, so that when you have a real crash, you'll know how to tackle it on your own. This is actually based off of a real crash that I saw a student encounter. So it's very likely to happen to beginners. I'll first walk you through all the steps and then you'll have a chance to do it yourself. To intentionally create a crash in the app, I'm going to modify the MainActivity Java file. I'll change the name of this method to be submitOrders with a s. Then I'm going to run it on the device. Everything looks fine at first, but then when I click on the ORDER button, it crashes. It gives me the message, unfortunately, the app named, Just Java has stopped. And the only option that I have is to hit OK to exit the app. Fortunately, we can use Android Studio to figure out what actually happened. When you run the app on your device, you may see this Android DDMS window pop up at the bottom of the screen. This show you information to monitor your Android device. All the stuff that goes on behind the scenes that users don't see. If it's not already open, you can click on this tab down here that says Android, and that should open up Android DDMS for you. You can adjust the height of this window by dragging this arrow. If you drag this arrow to the right, then you'll see a list of devices that are connected to the computer. Right now I only have my Nexus 6 connected. And I also opened up the Just Java app again, so that's why it's listed here. Let me drag this to the left again so I have more space to see the logs. This right hand side is where the log messages are shown. If you click on this drop-down and say no filters, then it shows you the log messages for the whole system and other apps. It talks about things like activity manager, audio, sound, microphone, and all these other things. A system log is kind of like a diary that your phone keeps about what's happening on the device. We also call it logcat. If you Google for what is logcat, then a definition pops up from the Android Developers webpage. It talks about how logcat is the Android logging system, where you can collect and view Debug output. Going back to the logs, the most recent events happen at the very bottom here. So if you want to look back in time, you may have to scroll up to see what you're looking for. Let's change the filter back to our app, Just Java. This significantly narrows down the amount of log messages that are just relevant to our app. This makes it a lot easier to read. When a crash happens on the device, the description of what the phone was trying to do gets printed to the logs. Here's our crash in the red text color. This is known as looking at the stack trace, because it traces back to where the error originated from. We know that it's our app because it's our process, which is com.example.android.justjava. For our app, the process name matches the package name, but it doesn't always have to match. We haven't really learned about processes, but, essentially, this is just identifying that this is our app. Now, there's a lot of text in this stack trace. And you don't have to read all of it. We just want to scan for the information that would be relevant to help us solve our problem. We should look for anything in the stack trace that's talking about either the methods or the files that we're working on. So we'll keep a lookout for the file name, main activity. So let's start reading the error message. I skip over this part and just read, IllegalStateException, Could not find the method submitOrder. The error message goes on to further explain why it was in an invalid state. And the reason is because it could not find the method submitOrder in the activity, MainActivity, for the onClick handler on the view class button. There's a lot of words in that sentence and it may not make a lot of sense. But there's a couple of good clues here. It mentions button and we only have one button in our app, so we can assume that it's probably related to that button. Then it talks about not being able to find a method, submitOrder, in the activity. Looking back at our button code, we did specify that when the button is pressed, it should trigger a method called submitOrder. So let's look at that now. I'm going to drag this The DDMS window down and open up our activity_main.xml file. So here is the button XML element. And indeed we said android:onClick should trigger the method submitOrder. If I go back into the main activity, then I see that submitOrder is no longer a method, instead, we changed it to submitOrders, so that's why the problem is happening. If I go ahead and erase the extra s, now there's a submitOrder method in the main activity, and the app should work again. When I run the app again and I and I hit the order button, then the app doesn't crash anymore, woohoo. Go ahead and try to create this crash in your app by changing the name of the submitOrder method. Then check the logs for the stack trace, and then read the error message carefully. Then go ahead and fix the error so that your app works again. Check this box when you're done. Hello. You all know Catherine. We've been making the course together. Today, we have a really special guest for you. Alice works for Google and has been working there for- 11 plus years. 11 plus years. So, we're going to talk about Alice's journey in terms of her first interview, how she solves bugs, and some advice Alice would give herself, from way back when, when she was wanting to learn programming. Shall we begin. So, Alice, can you tell us about your role at Google now? Sure. So, right now, I'm a TL for a new project. TL is for tech lead. Oh, okay. For a new project on Android. It's in the very early stages so I can't really talk about exactly what the project is. [LAUGH] Wow. But I can tell you a little bit about what I've been doing the last few years. So, let's start at the very beginning. The very beginning. So, you come in and what happens the first few years. So, the first six years at Google, I was in AdWords, AdWords front end. So, AdWords is basically how Google makes money. So, when you do a Google search, all those ads that pop up on the right hand side. So, I worked on, and AdWords back then, it was like the first group at Google who was doing Java, all the other engineers were C++ engineers, like on search. Oh, I didn't know that. Yes, so, we were the first Java team. And we set a lot of standards about how Java was going to, setting the Java coding style, for example, and what tools to use. So yeah, it was very fun. I think it was, back then, it was small. I remember carrying the pager for AdWords. On weekends, all the engineers take turns carrying the pagers. So, if a server goes down, you have to be prepared to log in, reboot the machine. It was before we had SREs. SREs means site reliability engineers, I believe. Okay. So, yeah, it was very different from- I had never imagined that when a server goes down there are literally pagers going off- Oh yes. In the background where people are sort of hustling to try and get the machine up again. Yes, they can go off like any time of the day, 4:00 AM. Mm. So, it's kind of like a doctor being on call. Mm-hm. I'd imagine that as thrilling as it was for you to get the job, some parts of the job may be stressful. Like this idea of this pager is going to go off and interrupt the fun that you were perhaps having. Do you recall any instances where you felt like this is really stressful and hard work that we are doing? So, I think when I was on Android Gmail, I think that was actually pretty stressful time of being TL. Okay, so we moved on from AdWords, so you're now doing Gmail, but for Android. Android, yes. Okay. So, actually, Catherine and I worked together on Android. Oh, nice! That's how we met, that's [INAUDIBLE] together. But, yes, so, Android is very different from AdWords. I think mainly because it's a consumer product, so it's just a different set of users, it's a lot more users. And on Gmail particularly, because it's one of the most used apps on Android, just the pure number of bugs that we get is just insane. At Google we have this thing called dog fooding. That means if your app is ready to release, your new version, then you test it internally, among all the Googlers. So you kind of dog food your own products, eat your own dog food. And for Gmail, every time we dog food a new version people will be so passionate and found so many bugs. We move one button from top right corner to the bottom right corner, and there will be like 20 people complaining about it changes their work flow, for example. So I think making those decisions was really tough, because it's hard to find a solution that pleases everyone. So, it may be surprising for some of our students to understand, but this idea of feeling frustrated because a bug has been encountered, is not something just the novice programmers are feeling. Even expert programmers like you Alice can get bogged down by them. Do you have a strategy or tool you follow when you say come across a bug? So, it depends on the type of bug. So, bugs can be very different, the most I guess important or high priority bugs are crashes, for example. Your app is just not functional. And those are probably ones that will get looked at first. They'll flag that as P0s or P1s, and also it depends on how reproducible it is. P, in that stands for priority, I imagine. Priority, exactly, yes. P0, P1, P2, An engineer who received the bug, think of a bug, and what would be your strategy to going about fixing something like that. Bug fixing is one of the most, it's like a very easy way, or quick way to feel like. You fix this bug and it's very rewarding because I can mark it as fixed and it's like I accomplished something. I think usually, first off, is trying to reproduce it. So, if it's reproducible, then it's much easier to fix. Mm-hm. The hardest bugs are the non-producible ones, something that on Catherine's Android device you saw, but then on my phone I was never able to reproduce. So, that's much harder. So, if it's reproducible, then I can easily just look at the logs, ADB logcats on Android devices. And then see what happens. If it's a crash then there would be a very obvious stack trace. So, you're like an investigator, you're looking at clues for why this thing might be breaking? Exactly. Yes. And Android bug reports are actually notorious for being really cryptic and hard to read. Yes. It's not just us. [LAUGH] Oh no, yes. I find them to be very verbose and cryptic also. Yes, I think it's one of the big challenges actually. So, that's where experience comes in. So, if you're an experienced Android programmer, you know exactly which keywords to search for. It's impossible to just read line by line by line. I usually just like prep for or search for certain keywords. I see. So, you're scanning through the entire log and you're looking for keywords that you can Google. Yes. Okay, why are you Googling these things? Well, I do a search locally, just like a find. But Google comes in handy because often if there is an error and it's something I'm not familiar with, it could be like Android Framework doing some illegal state exception or something that I've never seen before. Mm-hm. So, the first thing I would do is actually Google it. Okay. And yeah, and usually on let's say, stack overflow, there's almost always somebody else who has encountered the same. Is to follow similar processes. Yeah. Where they find a bug, they try to identify a key word that they can search on Google? Yes. And try and interpret those results, and try and fix the bug. Now, what's really satisfying, at least for me as a teacher, here to learn is that the process that we're teaching our students is being followed by an expert 11 years into their program. Yeah, yes. [LAUGH] And you mentioned a statement which was really emphatic to me, which is, if I don't know something. Mm-hm. And that's really important to understand, that even after 11 years of expertise, there are so many things that one might not know. Yes, it's impossible to know everything. And, yeah, I realize, there's something new to learn every day actually, and at my job I feel like I do indeed learn something new every day. I think you're ready for the next step of building the quantity picker. In our order form we're going to add a plus and a minus button so that we can increase and decrease the number of coffees ordered. Each time you hit the plus button, it will increase the number of coffees by one. And each time you hit the minus button, it will decrease the number of coffees by one. Then when you hit the order button, it will update the price according to the latest quantity value. Building up all of this functionality properly will take multiple steps. For the first task we're going to add the plus and the minus buttons to the layout. And we'll also hook up the buttons so they actually update something on the screen. And even later in the lesson we're going to fix the order button so that the price updates properly. First, build this layout by modifying the activity-main layout XML file. You'll add the two buttons and also please change the initial value of the quantity to be 2 and the initial price to be $10. You can make these changes in the XML as well. You can adjust to your local currency where applicable. The reason why I'm choosing two as a quantity is so that when you hit the minus button, it doesn't go negative. When you add these buttons to your layout you'll notice that they appear to be a little bit bigger than they are showing up here. You can achieve this look by setting the width and the height to be 48 dps. Then hook up the on click behavior. When the + button is clicked, call the increment method in the main activity. When the- button is clicked call the decrement method in the main activity. Within the main activity add an increment method. Inside that method create a quantity variable and initialize it to the value 3. When I say initialize it just means to set the initial value of the variable to be 3. Then go ahead and display the quantity to the screen. For the third step in the main activity also add a decrement method and create a quantity variable that's initialized to the value 1. Then go ahead and display the quantity to the screen. After you've completed all those steps this is what it should look like on the device. When you open the app it should have a quantity of 2 and a price of $10. If you hit the plus button, it increases the quantity to 3. If you hit the minus button, then it decreases the quantity to 1. Technically, that behavior is incorrect because it should've gone down to 2. But for now, just make the plus button always change it to 3 and the minus button always change it to 1. In a later coding task, we're going to fix it so that every time you hit the plus button, it will keep increasing to 4, 5, 6, etc., and same for the minus button. For now, you can leave the price and the order button as is. Right now, my version just updates the quantity to 5 and the price to $25, but you can leave it as whatever you had before. We're also going to fix this later. As a helpful tip, if you ever want to go back to how the app was when it first launched, you can always kill your app. In the system navigation bar, there's a couple of buttons, back, home, and recent tasks. If you hit this recent tasks button, it shows all the recent tasks that you are doing on your phone. If you swipe to the left or right it kills your app, that means it stops it from running. If you go into the all apps screen and then click on your app to launch it again, then it shows the initial state of the app The first step is to modify the activity_main XML layout so that the app looks something like this. Let's go into Android Studio and look at that file. Here's our activity_main XML layout file. And we have the preview on the device showing up on the right-hand side here. I can click on this magnifying glass to zoom in to the device. There that's better now. To build the desired layout I want to first add a plus button in between the quantity header and the quantity value. We already have a button in our layout which is for the order button down here. So I can just copy this code and then I'm going to paste it in between the quantity header and the quantity value. Now I see the button appearing in the right place, but I need to change the text so that it says plus instead of order. Cool! And I'm also going to remove the margin top because we already have 16 dps of margin from the bottom of this text field. So go ahead and delete this. The button is pretty big and in the quiz we asked you to change the size of it to be 48 dps tall and 48 dps wide. So I'm going to edit the button XML here. Nice. Now it's the right size. Now I can copy this XML and paste it below the quantity value so that we have the minus button. I deleted the white space because according to the Android code style guidelines, you shouldn't have extra white spaces in your code. Now I'm going to change the text of this button so that it says minus. It already has 48 dps width and height. Now the plus and minus buttons are in place. We mentioned earlier that we also want the initial quantity to be 2 and the initial price to be $10. So let's make that change now. This is what our layout looks like so far. Let's go back to the quiz image to check on our progress. We've successfully changed the layout, but we also need to modify the plus button so that when it's clicked it calls the increment method. And when the minus button is clicked we need to call the decrement method. Back in Android Studio, I'm going to modify the plus button so that the value of the Android onClick attribute is increment. That way when the plus button is clicked on it will call a method called increment in the main activity. Similarly for the minus button, I'm going to modify the onClick attributes so that the value is decrement. I'm going to save this, and then run this on the device. The layout looks good, but if I hit the plus button, then it crashes. Do you remember how I showed you to look at the logs for the stack trace of the error? The log's already opened by default, so let's drag this arrow up so that we can see more of the message. If we scroll up we see that this is our error. This is our app justjava and it says illegal state exception. If I scroll to the right I can see more of the error message. The error message says could not find a method increment in the activity, MainActivity. This looks very similar to the error that we had in the previous video. Basically there's no method called increment in the main activity. And that's actually expected because we didn't make that change yet. For the second step, we're supposed to add an increment method to the main activity, create a quantity variable that's initialized to 3, then also display the quantity. To do this, I open up the main activity Java file. Hooking up the behavior for the plus button is going to be very similar to how we hooked up the behavior for the order button. So let's copy this method here that handles the order button. Immediately I get an error that says submit order is ready to find in the main activity. You can't have two methods that are exactly the same in the main activity. But that's okay, because I'm going to change this to be the increment method anyways. And now the error goes away. I'm going to modify the comment because now this is a new method. I'm going to update the comment to refer to the plus button instead of the order button. Within the increment method, I'm going to create an integer quantity variable. I'm going to initialize it to a value of 3, as the quiz requested. Then I can display this quantity to the screen. I don't need to update price in this method so I can delete that line of code. That looks good so let's test this now. Now when I click on the plus button It actually updates to 3. That's pretty cool. But if I hit the minus button, then it crashes. Let's check the logs, I'm going to scroll to the bottom to get the most recent logs, and then scroll upwards to see the last error. For our app, there was an IllegalStateException because it couldn't find the method decrement in our activity. This is also expected because we didn't add the decrement method yet. Let's go ahead and do that now. I'm going to copy this method and then paste it below it. I'm going to rename this to decrement. Now this comment needs to be updated. This method is called when the minus button is clicked. To figure out what we're suppose to do within this method, let's go back to the quiz. We've finished two steps so far. The last step is for the decrement method in the main activity. We want to create a quantity variable and initialize it to 1. Then we're going to display the quantity to the screen. In the decrement method we've created an integer quantity variable. I'm going to initialize it to a value of 1 and then display that quantity to the screen. Now let's run it on our device. Okay, cross your fingers that it doesn't crash this time. If I hit the minus button, then, yeah, it decreases to 1. If I hit the plus button, it increases to 3. So, these buttons are working as expected, at least for this stage of our app. Ideally, as I mentioned earlier, we want this to increase to 4, 5, 6, and we want this to decrease to 2, 1, 0. But that will come at a later stage in the lesson. Great job so far. We're making really good progress so far. As we continue to build more challenging things for our app, we're going to have to improve our debugging skills. In this video, we're going to learn about how to use a tool called the debugger. We'll access the debugger using Android Studio. And the debugger is meant to help us identify and fix errors in our code. The great thing about the debugger is that we can pause the app at a certain point in time, and then we can inspect the whole state of the app more closely. Normally, when the app is running on our device, all the code gets executed very rapidly. Within milliseconds, it can respond to button clicks, update the screen, calculate the price, and etc. But with the debugger, we can pause at a specific line of code in our app, then we can step through our code line by line as quickly or slowly as we want. If you want to learn more techniques on how to debug your app in Android Studio, just search for debugging Android Studio. This first link is good. It's a developer.android.com page, and it has a bunch of techniques on how to debug your app. Together, we're going to learn about how to work with breakpoints. After this course, you can always come back to this page to refresh your memory. In this exercise I want to show you that your Android device does run each line of code one at a time from top to bottom within a method. We'll also verify that clicking on the plus button does trigger the increment method, and clicking on the minus button does trigger the decrement method. First add something known as a breakpoint. A breakpoint marks a specific line of code where the debugger should pause when it reaches here. The red circular dot indicates that the breakpoint is on this line on line 25 of our main activity file. You can add breakpoints to as many places as you want in your code. But for now, I'm just going to add one on the first line of the increment method. Then I can hit this bug icon to run the app in debug mode. The app will only pause on these breakpoints when the app is running in debug mode. If you run the app normally with this green play button, then it won't pause at these breakpoints. For a brief moment, on the device, you may have seen a dialog that says, waiting for debugger. There's also a button to force close the app, but don't click on that. Just wait for the debugger to attach and the message will go away soon. Then the app starts like normal and you can interact with it. Now, in debug mode, this window will pop up and show the status of the debugger. If you don't see it, you can click on this tab down here called debug. If I hit this plus button here, I expect the increment method will be triggered and that the app will pause at this breakpoint. Let's see what happens. Cool. It stops there. In the debug pane, we see a list of variables. This reflects the current state of the app where it was paused. We don't see our quantity variable yet, because it hasn't finished executing this line of code yet. There's a bunch of options on how to proceed with debugging. But I'm going to click on this option that says step over. This will step over the current line of code to the next line of code. Now the app is currently paused at line 26. We finished executing line 25, so that's why we see the quantity variable showing up down here. This list of variables also shows the current value of each variable. We can also verify that the quantity variable has a value of 3, which we assigned up here. We know that the app is currently paused at this point, because normally when you hit the plus button, it would automatically update the quantity to be 3. But since the quantity is still a 2, we know that it hasn't finished executing the increment method yet. We can click step over to go to the next line. At this point, the method is done. And we're not really interested in how it actually updates the screen, so let's just hit resume program. All we care about is that it actually does update the screen. If you're interested, you could have clicked on these other options to look at more details of how it actually updates the screen. At this point, the app is running normally, but the debugger is still attached. So if I hit the plus button again, it will stop at this breakpoint. If I want to detach the debugger so that it doesn't always stop on this line when I hit the plus button, I can just click on this red stop button. Now whenever I hit the plus button, it responds immediately and updates the value to 3. Now I want you to try it on your computer. Go ahead and add a breakpoint to the increment and decrement methods. Then run the app in debug mode, and then on the device, try to trigger each of these breakpoints. Then step through each line of code, making sure that the quantity variable shows up with the right value in the variables list. You can click on this play button to resume execution of the app so that it runs as normal. Or you can hit the stop button to detach the debugger. Together we walk through how to add a breakpoint for the increment method and how to trigger that breakpoint. Hopefully you were able to reproduce that on your computer. For the decrement method, if we want to add a breakpoint, I can just click here on line 33 to add a breakpoint. Then I click on this green bug icon to launch the app in debug mode. I'll see the Waiting For Debugger message, and then it will go away shortly. To trigger this breakpoint, I'm going to click on the minus button. The app pauses at this line, and I know that because the quantity value hasn't updated to one yet. I see the list of variables down here, but the quantity variable hasn't shown up yet. I click on this button to step over this line to go to the next line. Then I see that the quantity variable shows up, and the current value is one. At this point, I can step over this line of code to the end of the method and then just resume execution of the app. Because I have two breakpoints in my app, if I click on the plus button, it triggers the breakpoint in the increment method. Then I can hit play to resume. If I click on the minus button, it triggers a breakpoint in the decrement method, and I can hit play to resume. If I don't want the app to stop at either of those breakpoints, I can just hit stop, and it detaches the debugger. Then the app just runs as normal where it updates the screen immediately when I click on the button. Hey. Hey. What's going on? Just wait for it. Okay. Okay. So, you know how we have a variable called number of coffees ordered in our app. This box. Yeah. And we had the value two in it. Correct. If I hit the plus button in the app now. Beep Then what is the number of cups of coffee we have? Well, that would be, increment by one, so the new value should be three. Yeah. So I'm going to throw out this old value and put in this new one. Okay. If I hit the plus button again- Beep! Then how many cups do I have? Well now we will increment that to four. Yep. So throw this out, add four in. Okay. Now, if I hit the minus button- Beep beep beep Then how many cups of coffee do I have? But Catherine I thought you said there would be no math? It's one. Write that down. Thanks. Okay. Here it is. One. Yep. Let me give that to you. Thank you. Let's add all of this into our app now and we're going to work on your math later Let's look at the pseudocode for how clicking the plus button in the app can increase the number of coffees ordered. Pseudocode is a high level description that explains the steps of what the app will do. We can write it out as if we're describing it to someone, because it's meant for people to read, not computers. This helps us put our thoughts into a linear flow of what needs to happen one step after the next. When writing pseudocode we don't have to follow any specific structure or format, we just need to include useful details that would help us write the code later on. For our scenario, we want to create a quantity variable to keep track of the number of coffees ordered and we initialized the value to two coffees. If the plus button is pressed, we can update the quantity variable to three. If we hit the plus button several more times we can increase the quantity to four and five. Once we have a conceptual idea in our head of what the code should do, then we can focus on writing the actual Java code. At this point then we can worry about the syntax of Java, the capitalization, the symbols, the spacing and other specific rules about how to write Java code. The real code would look like this to create a quantity variable and set it to two, we would have int quantity = 2 followed by a ;. This is what we covered in the last video. To update the quantity variable to 3 we just need to say quantity = 3 followed by a semicolon. If we update the quantity to 4 and 5, this is what the code would look like. For this quiz I want you to practice typing out these lines of code in the text fields provided. This will give you practice in creating an integer variable and updating it in Java. Pay close attention to each character and symbol as you type this out. When you're done, do you have any observations about the format of the code that you just typed out? For example, do you recognize any patterns? Enter any observations in this text field here. Hopefully you typed it in all right. A common mistake is to forget the semicolon at the end of each statement. Or you may have misspelled the quantity variable in subsequent lines of code. The variable name must match the same spelling and capitalization as the very first time that the variable was originally declared. Also int has to be spelled specifically in this way. Otherwise java won't recognize that this is supposed to be an integer variable. For best practice, remember that we always add a space before and after any operators. In this case, we only have a sign operator, so we add a space here and here, in all these cases. Thanks for making some observations about the code. There's no right or wrong answer here. One of the observations you may have made is that int is only used on the very first line of code, right here, but not on subsequent lines of code. Let's talk more about that next. In this video we will apply what we learned about updating a variable within the context of the Just-Java app. Once a variable is created we can update its value using assignment operator, that we learned earlier when creating variables. The format is to have a variable name on the left, followed by the equal sign and then the new value. The statement also ends with a semi-colon as always. This line means that, we're assigning the new value of 3 into the variable called quantity. Going back to our box analogy, int quantity equals 2 creates a new variable called quantity, and puts the value 2 inside. When we say quantity equals 3, we set a new value of 3 inside the variable. We also take out the old value, because the variable can only hold one value at a time. When we say quantity equals 4, then we put in a new value of 4 inside the variable. We also remove what use to be in there, which is the 3. Then when we say quantity equals 5, we assign the variable a new value. Note that we only need to specify the data type of the variable, which is integer in this case, once. On subsequent lines of code where we refer to the variable, we don't need to specify that data type. If we did write int again on that 2nd line, then the computer would think we want to create another quantity variable. However, we're not allowed to create two variables with the same name and the same method, that would give an error. So when you declare a variable, that's when you specify the data type. When you update it, you don't need to specify the data type. Now I'm going to open up the main activity Java file and modify the increment method to take advantage of the ability to update variables. When the plus button is clicked it will trigger this method, and I'm going to initialize the quantity variable to be 2. Then I'm going to add a new line of code that updates the quantity variable to 3. Then we display the latest quantity value to the screen. When we run it on our device, if I click on the + button, then it updates to a quantity of 3. This is because the latest value in the quantity variable is 3 by the time we try to display it on the screen. How do we know that the app didn't just skip to setting the value to be 3? Well, we can use the debugging tool that we introduced earlier, to check the value of the quantity variable at each line. Let's add a break point in the first line of the increment method. Then I can run the app in debug mode. Okay, Android Studio says that the debugger has been connected. I can click on this Debug tab to open the debug window. Now when I click on the plus button, it triggers the increment method and the break point at line 25. At this point the first line has been executed, so we've created a quantity variable with a value of 2. If we skip to the next line, then quantity equals 3 would have already been executed, and then we do see that the quantity variable has been updated to 3. At this point it should display on the screen, and we can just hit Resume, to resume the app. And then you see that the screen has updated to the value of 3. I'd like to show you more examples of updating the quantity variable. Even though it doesn't make much sense from a functionality point of view of the app to have the plus button increase the number of coffees by more than one cup. >From a code perspective if you wanted to, you could add additional lines of code to update the variable several more times. Then run the app in debug mode again. If I click on the + button, then the break point will be triggered. If I step to the next line then this first line has finished executing, and we've created a quantity variable with an initial value 2. We go to the next line then quantity updates to a value of 3. At the next step quantity variables updated to a value of 4 and then 5. If I hit resume execution, then the screen will finally update to show the latest quantity value, which is 5. Now on your computer make these changes to the increment method in the main activity file. Then use the debugger to step through and verify that the quantity variable is being updated as expected. Then repeat the above steps but for the decrement method. Within that method, initialize the quantity variable to 2, and then update it so it goes down to one cup of coffee. When you run it on your device, the app should open and start with a quantity of two. If you hit the minus button, then it changes down to a quantity of 1. If you hit the plus button it changes to a quantity of 3. The quantity picker isn't working exactly like we want yet, but we're just learning concepts one at a time and slowly building up to the right functionality. For now you can leave whatever behavior you currently have hooked up for the order button, because that will eventually change. When you're done, check this boxes to continue. We showed you how to do the first two steps. If you still need help with those, that's no problem at all, you can just watch the previous video again. Now I'll show you how to update variables within the decrement method. We ask you to initialize the quantity variable to 1, and update it down to 1 cup of coffee. I'm going to make the code change in the MainActivity.java file in the decrement method. We're creating a quantity variable and initializing it to 2. Then I'm going to add another line of code that updates the quantity variable to be 1. And lastly, I displayed this new value to the screen. Let's run the app to check that it works. If I hit the minus button, then it decreases down to 1. I can add a breakpoint here and run the debugger to show that the quantity variable is being updated. I'm going to click on this debug tab to open the debug pane. I click on the minus button to trigger the breakpoint here, and then step through each line of code. At this point, the first sign has executed, so the quantity variable has a value of 2, and then it changes to a value of 1. And then I can just resume the app and the app should update to have a quantity of 1. And there it goes. All right, I think we've nailed the concept of how to update an integer variable to a new number and verify its value in the debugger. This is still limited, though. There are actually other ways to update a variable aside from just setting a fixed literal value. Okay Katherine. Mm-hm. So when we hit the plus button in that app. The number of cups of coffee goes up. Yeah it goes from two cups to three cups. And what happens when we press the plus button again? Well it actually just stays at three. Yeah. So no matter how many times we press the plus button in that app, the number of cups of coffee stays at three. Yeah. Why is that happening? Well, I think it's because, in our code, we only update it to three. And we never go beyond that. Right. That number is hard coded right there. Yeah. You know what this remind me of? What is it? Well, [LAUGH] my computer science professor in college used to say. Yeah? When you submit your final project. Yeah? Please, no magic numbers. Wait, what's a magic number? Well, three's kind of a magic number. Okay. It's a magic number because, we are doing the addition in our head, but then to the computer. We're telling it the right answer. Okay, yeah, it would be better if the computer actually calculated itself. Wait. When you talk about calculation in math. Uh-huh. I need to start writing things down. Okay. Let's write some pseudocode. Let's write the pseudocode for this. Assume that we've already created quantity variable and set it to two. When the plus button in the app is pressed, we're going to take the current quantity value which is two. Add one to it to make it three, and then store that as the new value inside the quantity variable. If we hit the plus button again, then we're going to take the current quantity value which is now three, and add one to it which makes it four. And then store that as the new value inside the variable, and here's the actual Java code for it. We initialize a variable first. If the plus button is pressed again, then we're going to take the existing quantity value, add a one to it, and then store this as the new value for the quantity variable. When you read these lines of code, you can imagine the boxes in your head. Even though we're used to reading things from left to right, I always start with what's on the right hand side of the equal sign first. In this case, we have the current value of quantity. Which is two, and then we add one to it, and that makes three. Then we store the three inside the variable, like this. The righthand side is an expression, which we learned about earlier. And an expression can be made up variables, operators and literal values, and more. If we click on the plus button again, then we can say quantity = quantity + 1. At this point the current value of quantity is three, then we add one to it, and that makes four. Then we store four as the new value inside the quantity variable like this. Essentially we've have reduced it down to a common pattern, that the computer can repeat each time the plus button is pressed. Instead of having to write a new line of code that says the explicit value of the number of cups of coffee, we can just do quantity = quantity + 1, and continue to build off of the existing value of quantity. This is a lot more flexible. Say you You wanted to change initial quantity to 3, then the rest of the lines of code wouldn't have to change at all. Because we would always use the latest value of quantity, whatever it is, which, in our old approach, if we wanted to update the quantity value to 3, then after you hit the plus button, you would have to write a new line of code that says quantity equals 4 and update this to be quantity equals 5. When we update the quantity to a completely new literal value each time, it's hard for the computer to know what the pattern is between them. Instead if we update quantity based on the current value of that variable and we increment it in a predictable way, then the computer will be able to do this every single time that the plus button is pressed. This approach will work a lot better for our coffee ordering app. Each time we hit the plus button, we can just increase the existing quantity value by 1. Practice writing out each line of code by typing them into the boxes we've provided here. Pay attention to each character and symbol. This is the first time you're updating a variable, using the variable itself, so make sure you type out this variable name correctly. When you're done, fill out this column that represents the current quantity value after each line of code is executed. Okay, hopefully you've absorbed that pattern into your fingers. So now you know how to type at updating variables. We hope this reduces your errors when you're adding this code to Android Studio. Here's what the value of the quantity variable is after each line of code is executed. It starts off at 2 and then you add 1 to it, so it becomes 3. Then you add 1 to that again, and it becomes 4. Then you add 1 again and it becomes 5. So after all of these lines of code are executed, the latest value of the quantity variable is 5. Now that we understand these lines of code and have practiced typing them, go ahead and add them to the increment method within the main activity. Remember that a common beginner mistake is to specify the data type again. You only need to specify the data type once when you declare the variable. After that, you can just use the variable name. If we add a breakpoint on Line 25 and then run the debugger, we can check what the quantity variable value is at each step. If I click on the plus button, then the breakpoint on Line 25 is triggered. I'll click step over to go to the next line of code. Now we see that the quantity variable has been created with the value of two. If I click step over again, then we see that quantity variable has been updated to three. This is because of the quantity equals quantity plus one line. Then we can hit play to resume the app and we can see the latest quantity value being shown on this screen here. Do the same thing in your version of the app. Modify the increment method to update the quantity variable using quantity equals quantity plus one. Then use a debugger to step through and verify the quantity variable value at each step. After that, feel free to experiment with different expressions for updating the quantity variable. You could do quantity plus one, or one plus quantity. Or you could use the variable name twice, or as many times as you want, or you can do other arithmetic operations. You can run this on your device to see what happens. When you're done experimenting, go ahead and revert back to what you had before, so that we can continue with the lesson. Check these boxes when you're done. We covered the first two items in the last video. Feel free to re-watch those if needed. The task to experiment with the code was a little open ended, so these are a couple of things that we tried. There's no single correct answer for this one, though. If I set the quantity to equal two times the quantity, then if I hit the plus button, then it will double the number of coffee cups we have. When I tried it on a device, indeed it does double the number of coffees from two to four. I can also use the variable name twice or as many times as I want in the expression that will be evaluated to store as a value for quantity. Let's run this to see what happens. This is essentially three times quantity, so if the orignal quantity is two, then when we hit the plus button, it should bump up to six cups of coffee. Even though it doesn't make sense to update quantity so many times within the method, I just added more lines of code so that you could see what would happen. First I run the app in debug mode, then I click on the Debug tab, and I can trigger the breakpoint by clicking on the plus button. First I see that the quantity variable has been initialized to two. And then we take that quantity variable and double it and then add another two. That makes six cups of coffee, which is the value down here for the variable. If I click step over again, we're going to take the current quantity value and add two. Since the value was six before, six plus two equals eight. Then I'm going to take the existing quantity, which is eight, multiply it by three to get 24, and display that on screen. If I click resume, then the screen updates to 24. Now let's revert back to what we had before, so it matches the rest of our code. Once you've become comfortable with how the increment method is working and how to update a variable based on the current value of that variable, then do the same for the decrement method. In the decrement method, initialize the quantity variable to two cups of coffee, then decrease it by one cup. I bet you never thought you'd be doing so much coffee cup math, but it's helping us learn Java, so it's worth it. Also use the debugger to step through and verify that the quantity variable is being updated as expected. Once you become more comfortable with variables, you can eventually skip this step of using the debugger because you'll be able to keep track of all the values of the variables in your head. But since you're starting out, if you like seeing the concrete value in front of you at each step in the code, then go ahead and continue to use the debugger. Check these boxes when you're done. In the MainActivity.java file, we modify the MainActivity decrement method. First we create an integer quantity variable and initialize the value to two. Then we update the quantity variable to have a value equal to the current value of quantity minus one. In this case, the current value of quantity will be two, so two minus one equals one. So when we display quantity, it should have a value of one. When I click on the minus button, then it updates to one on the screen. I can add a breakpoint and run the app in debug mode. If I click on the minus button, the breakpoint is triggered. I can click step over, and then I immediately see the quantity variable is down here with a value of two. If I click step over again, then quantity has been decreased by one, and now quantity equals one. If I click resume, then the screen updates to one. Awesome. Now we have all the small pieces in place. In the next video, we're going to finish hooking up the quantity picker so that it works when you tap it more than once. Okay Katherine. Mm-hm. We hit the plus sign. [SOUND] And the number of cups of coffee goes up from two to three. Okay. But we keep hitting the plus sign. [SOUND] Again. [SOUND] And again. [SOUND] And the number of cups of coffee just stays at two, it's not going up. Okay, well I think it's because we're missing one concept, and that is variable scope. Variable scope? Yeah. Care to explain? Variable scope means that when a variable is declared in a method, it can be only used in the scope of that method. [SOUND] Pay attention. Katherine. Yeah. We're talking in gibberish. Someone needs to give students in this class a medal for getting this far ahead. Okay. Let's slow down and explain clearly. Sorry. Okay, I can explain. Okay, so we hit the plus button. Mm-hm. And the increment method inside a code gets called. Yes. And then what happens? Well, we create the quantity variable. Right. It is initialized to value two. Right. And we update it to three cups of coffee. And then when the increment method ends, then what happens? Well, then the variable gets destroyed. [SOUND] Okay, so when I press the plus button again [SOUND] the increment method gets called in our code- And then we create a quantity variable. Oh, wow. Another one magically appeared. Yeah, a brand new one. Okay. And it's initialized to two, and then we update it to three. And then the increment method ends again, and then what happens? The variable gets destroyed. [SOUND] What we really need is a global variable. Oh, yeah. A variable that can be accessed by any, and all, pieces of code inside our app. Exactly, like any method, the increment method or the decrement method. Mm-hm. So we create a global variable like this. It's still the quantity variable. Mm-hm. But now it's global. Mm-hm. So after a method finishes executing, it doesn't get destroyed. Okay, let's use this in our code next. The problem in our app is that if I hit the + button a bunch of times, the number of cups of coffee never increases beyond 3. The reason is because the + button triggers the increment method. In this method, we always create a new quantity variable, and initialize it to 2. So when we update the quantity, it's always set to 3. This method has no memory of the fact that I already called it before by clicking on the + button, and that I'm already displaying 3 cups of coffee. It has no idea that I want 4 cups now. In the old code, we declared a local variable for quantity in the increment method and a local variable for quantity in the decrement method. The reason why we can declare a variable with the same name twice is because they are in different variable scopes. This is the scope of the quantity variable declared in the increment method. Within these bounds we can refer to the quantity and update the quantity. But outside of these bounds, other methods would not know about this quantity variable. You would get an unresolved symbol error because other methods wouldn't know about this variable. Similarly, this is the variable scope for the local quantity variable declared in the decrement method. Within this method, you can display the variable and update the variable, but beyond the bounds of this scope, you can't reference it. In the updated code with a global variable, this is what it would look like. Instead of declaring the quantity variable in the increment method, we've pulled it out to be declared at the top of the main activity. It's declared within the opening and closing braces of the main activity. So anything inside the main activity will know about the quantity variable. This is the variable scope for this global quantity variable. All the methods and other variables in the main activity can now refer to the quantity, and also update it. So the increment method updates the quantity variable, and also displays it. And the decrement method also updates the quantity and displays it, and the quantity always refers back to the global variable here. The advantage of pulling it out into a single global variable is now we have a single source of truth for how many cups of coffee the user wants. Even if we've increased the number of coffees a bunch of times, then if we decrease the number of coffees, then it'll just use the last known value of the quantity. Before it was weird that we had two quantity variables, because those two variables could get out of sync, and the user ends up only seeing one value. So it makes sense to have one single source of truth, a global variable to keep track of the number of coffees ordered. You might wonder why we don't just make everything be a global variable and have it solve all our problems. You really don't want to make a variable global unless there's a real need that other things in the main activity need to reference that variable for. If you only need to use a method within the context of a single method, you should just keep it a local variable. It's sort of like having a secret. You only tell people on a need to know basis. Similarly, you only want to reveal variables that other people absolutely must know about in order for the app to work. In the MainActivity in the increment method, I'm going to copy this line of code that declares the quantity variable. I just hit Cmd+X, or it's Ctrl+X to cut. And then at the top of the main activity class, I'm going to paste it. This will be pasted right after the opening breaks of the main activity. Notice that it is outside the braces of other methods. Otherwise, if it was inside the braces of a method, it would be considered a local variable. Quantity is now a global variable within the MainActivity class. We'll learn more about classes in the next lesson. The MainActivity is a class that contains methods and variables. Now, any method in the MainActivity can refer to this quantity variable. So this increment method just updates the quantity and displays it. Notice that a global variable has a purple font color for the variable name. If it's a local variable, the font color is black for the variable name. So that's how you can tell the difference between local and global variables. Speaking of local variables, we want to get rid of this local variable in the decrement method, because we want to use the global quantity variable. The variable name in these methods must match the global variable name, exactly. If I said quantities here, it would give an error because quantities is not defined as a local or a global variable anywhere. And I'll undo that so that it works again. If I run the app, let's see what happens. The app starts off at a quantity of 2. If I hit the + button, it actually increases. If I hit the- button, it actually decreases. That's pretty awesome. We've succeeded in building our quantity picker. Now, I want you to be able to build this on your phone so you can increase it or decrease it as much as you want to your heart's desire. We've included a link to the MainActivity code for you to reference. I'd rather have you type it out yourself by following this video instead of copying and pasting the code. That way, you'll be able to create global variables on your own in the future. I'm going to attach the debugger so we can see carefully what's happening with the quantity variable. I'm going to add breakpoints in the increment and decrement methods and then run the debugger. When I hit the + button, then this breakpoint triggers. Before this line of code has even executed, we see that the global quantity variable already exists with a value of 2 because of this line of code up here. If I set to the next line, then this line has finished executing and we've increased the quantity up to 3. I can hit resume so that the app updates to a quantity of 3. If I hit the + button again, then before I've even executed this line of code, we already have the global quantity variable set to a value of 3. That was the last known quantity we had before, and it sill remembers it. If i increase the quantity by 1, then the global quantity variable has a variable of 4 now. I can hit resume to update the screen with 4. Now, we can see that every time the increment method is called ,we can actually continue to build off of the existing quantity value. Let's see how it interacts with the decrement method. If I hit the- button, then this breakpoint triggers. The global quantity variable has a value of 4, which is what we last left off with. If I decrease the quantity by 1 than it goes down to 3 cups of coffee. And I can display that on the screen and it changes to 3. With a single global variable for quantity, the increment and decrement methods can now increase or decrease the number of coffees by 1 based on the latest value of quantity. Now, it's your turn, go ahead and replace the 2 local variables with 1 global variable. Then, use a debugger to verify that the quantity variable is actually updating as expected. Once your quantity picker works, go ahead and do a little happy dance. And then you can try to experiment a little bit. What happens if you have a different initial quantity value, like 0? Or try doubling the quantity each time the + button is pressed. Or halving the quantity each time the- button is pressed. Feel free to experiment with whatever you're curious about. If you ever wondered, what would happen if I do this or that? Those are sometimes some of the best learning moments, because they're unexpected. When you're done check these boxes to continue. We've already walked through the first two steps in the last video. Now I'm going to show you a couple of things you could have experimented with. I would like to change the initial quantity value so that when the app launches it shows up as zero instead of two. The way I can do that is to modify this global quantity variable to be initialized at zero. Then the increment and decrement method should work just fine. When the increment method is called, it will use the latest quantity value and just add one. When the decrement method is called, it will just decrease the quantity by one. Let's go ahead and try this out now. That looks weird. I wanted it to show up at zero. If I click the plus button, it's weird, it goes to one, which seems to have decreased it, but now it starts to increase. So it seems like these buttons are working, but for some reason the initial value was wrong. Oh, we forgot to change the activity main layout file. In this layout we have a text view that says the initial text quantity value is two. That should fix our problem with the two showing up when the app launches. Cool. Now it shows up as initial quantity of zero. Then if I hit increase, it updates properly. If I hit decrease, it also updates properly. You can see that it's a little tricky that we have the initial quantity value in two places. Having two places in the code that represent the same thing can be a source of bugs in the future, like we just saw now. An advanced way to solve this problem is to have the main activity actually display the quantity of zero immediately when the app launches, instead of relying on the layout to have an initial value. That way the single source of truth would be this global variable. But don't worry about that now. That's more of an advanced thing that you can do after Lesson 3. The other way we can experiment with the code is to have the plus button double the number of coffees ordered each time and have the minus button half the number of coffees each time. Let's start with an initial quantity of two, so that if we hit the minus button first, we can at least cut this in half once. When the increment method is called, we want to double the number of coffees ordered. We should take the current quantity and then multiply it by two. That gets updated to be the new quantity value and then we display that to the screen. On the other hand, we have the decrement method. For the decrement method, we want to cut the number of coffees ordered in half. So we can take the current quantity and then divide it by two. That will be the new quantity value. And we display that to the screen. Let's try it out. You can see how it can be a source of error every time you want to change the initial quantity value. You have to change it in both places. Let's run the app now. Okay. It starts off at an initial quantity of two. If I hit plus, it should double the quantity each time. Cool. And it does. If I hit the minus button, it should cut the number of coffees ordered in half each time. And it works. If I run it in the debugger, you can see how it updates the variables each time. The quantity value starts off at two, and then it updates to four. And then the quantity starts off at four, and then it updates to eight and so on. I'm sure you came up with much more creative ways to play around with this quantity picker. Hopefully that helped you better understand the use of global variables. But if I hit the order button, it doesn't show me the price for that number of coffees ordered. Let's fix that in the next video. Next, we'll fix the behavior of the Order button. Once I change the quantity to something like six, if I hit the Order button, the price should update to $30. However, when I click the Order button, it always changes the quantity back to five and the price to $25. So this behavior is incorrect. To test your understanding of everything we've learned so far, I want you to go ahead and fix this bug on your own. I'm confident that you can do it. This is a very common occurrence during app development. You build out more functionality of your app, like this quantity picker, but then it can have ripple effects on the rest of your app. And it may break something, like this Order button. So you have to just go back and fix that later. Once you've completed this task, this is what the app should look like. If I increase the quantity to something like six, and I hit the Order button, then the price changes to $30, which is correct. To help you tackle this problem, first identify all the things that are wrong with the current state of the app. You can look at it on your device, and so it will be easier than looking at this screenshot. This screenshot shows setting the quantity to six and then hitting the Order button and seeing the result on the screen. I want you to describe in words the gap between what we have now and what we want. Be as detailed as possible by writing your answer in this box. The more specific you can get about all the things that are wrong with the app, the easier it will be to fix the problem because you'll have almost a task list on how to get to the ideal solution. Then after you've planned how you will attack the problem, go ahead and implement those changes in your app. Once the Order button works as expected, pat yourself on the back, and then check this box to continue. There isn't just one correct way to answer this question. It really depends on what's most useful for you to identify the difference between the incorrect app behavior and the correct app behavior. Here are some of the thing that I noticed. In the incorrect app behavior, when you click on the order button the quantity changes to the same value each time and it shouldn't change. Next I also notice that the price was correct for this quantity value, but really the price should be for the last quantity that was selected in the quantity picker. Again, this is related to the fact that quantity shouldn't change. Let's look at the existing code for why this is happening. In the activity_main layout file, We have the Order button declared here. When the Order button is clicked, we're going to call a method in the main activity called submitOrder. In the MainActivity.java file, here's the submitOrder method. This is old code from a long time ago that we haven't changed yet. But we create an integer quantity variable and initialize it to 5. We display that to the screen. We also display price as the number of cups of coffee times $5 each. Already this code don't make a lot of sense, because as we're trying to submit the order we're trying to update the quantity. And another problem is that we're creating an integer quantity variable when we already have a global quantity variable that's supposed to keep track of the number of cups of coffee. In the MainActivity we already have a global quantity variable, so any method inside here can refer to this quantity variable. However, in the submitOrder method we're creating a new local quantity variable. Technically you can have a local variable called the same name as a global variable. This just means that in the context of this method, after this variable has been declared, whenever you refer to quantity, it actually refers to this local quantity variable with value 5, not the global quantity variable of value 2. So display(quantity) and displayPrice(quantity *5) both refer to this quantity value. This is the scope of this local variable. Outside of this scope, whenever you refer to quantity it means this global variable quantity. If you think about it, though, it doesn't really make sense that when you submit your order, you would create a new quantity and then display that on the screen. What you really want to do is just use the quantity that we've been keeping track of as we've been increasing and decreasing the number of cups of coffee. So that's what we should calculate our price off of. To fix our code, we should not declare a local quantity variable. Instead we should just use this global quantity variable. We should also stop trying to update the quantity on the screen. The plus and minus buttons already handle updating the screen with the proper quantity value. We do, however, want the submitOrder button to still update the price. But this time we're going to calculate the price as quantity * 5 using the global quantity variable. I'm going to update the code so that it reflects what we just talked about. Notice that the quantity variable has turned into a purple font color, which means that we're using the global quantity variable in the MainActivity. When the button is pressed it will trigger the submitOrder method. This will display the price on the screen, where the price is calculated as the global quantity variable times 5. This looks correct, so let's run it on our device. Okay, now for the ultimate test. I'm going to change the quantity to 6 and then click on the Order button, and yay, it's $30. Let me try other values as well so I know it's not a fluke. That looks correct. That looks correct. Cool, it works! You just fixed your first bug. You did really well on that task. The functionality of our app is working really well. But I have to admit, the UI is a little bit ugly. In particular, the quantity picker could use some UI love, so let's work on that next. Hi Katherine. Hi Kunal. How are you feeling? I'm feeling a little tired. How about you? Me too, me too. I suspect that some of our students are perhaps feeling the same way. Probably. And that's okay. It's a really long lesson too. Yeah, it is. And this is a great point for them to, at the end of this video, take a little break and walk away from the computer. Yeah, and while you're doing that you could actually also show someone the app you've made so far. Yeah, talk to your friend about the new ideas that you have learned in the Android world and come back and share that conversation with us on the discussion forum. Yeah. Thank you for taking the time to reflect on what you've done so far. Being able to teach others about what you've built feels rewarding, but it's also a core skill in being able to communicate with teammates that you may work with on a software project. With that in mind, let's keep moving forward so you can go back to those people soon and share your progress. So far the functionality of the quantity picker in our app is working well. So now we can spend a little bit of time making it look a little better, a little sexier. We want to move closer towards our end goal. This is what we have now, and this is what we want. The buttons in our app currently work, but they're not in the ideal layout. This layout leads to a better user experience, because we're going to be adding more fields to the order form in Lesson 3. With this layout of the buttons, it's easier to scan through the list of fields in the order form quickly. In the current layout, if you want to scan through the form quickly, you would read quantity plus two minus price and so on. So it's faster to scan through the form if the buttons are laid out like this. This updated layout also takes advantage of more of the horizontal space on the screen, instead of squishing everything into a very narrow, vertical column. The challenge becomes identifying the gap between what we have now and what we want. Can we repurpose the views that are already on screen and move them into the new position for the new layout, or do we have to add views or remove views? Before we get lost in the details of changing the XML, I want you to first plan out how you're going to approach building this layout. In your own words, describe your thoughts on each step that we've taught you for how to build layouts. You don't need to write XML at this point. You can just plan out your strategy. These notes are going to help you actually write the code at each step, so be as detailed as you want. The first step is to select the views. Which views are you going to need in terms of text view, image view, button, et cetera? The second step is to position the views. Can you describe how these views are positioned on the screen? Which view groups are relevant to building this layout? Step 3 is to style the views. Is there anything we need to do to change the visual look and feel of each of these views? When planning how to build this layout, we're going to start with the assumption that we're going off of what we currently have in our app. We're not building this from scratch. For step one, selecting the views, we actually already have all the views that we need. There's no need to add or remove views. We should have three buttons and four TextViews in our layout. For step two, positioning the views, I first describe what the layout looks like to me. I see a header followed by a row of buttons and a TextView. Then I see another header and another TextView. And, lastly, that it's followed by an Order button. >From this observation, I notice that we can't just use a vertical LinearLayout because this item here is made up of more than one view. We could potentially consider RelativeLayout, but I'm going to leave a question mark by that. For step three, we want to style the views. The style actually remains pretty much the same as we had before. Although I do notice that this quantity value has a little bit of space between the minus button and the plus button. So we might want to achieve this with either padding or margin around this TextView. When discussing how to position views in the last quiz, you may have mentioned using a relative layout. I know we did. But I want to introduce you to another way that you can build the layout for our app that would be more ideal, using nested viewgroups. Nested viewgroups means putting viewgroups inside other viewgroups. That way you can build more interesting and complex layouts like these. Let's see how you would build up one of these layouts. Say, for example, you have a vertical linear layout with three views, an image view and two text views. What if you wanted to overlay some text on top of this image? Well, with a linear layout, you can't overlap views. But with a relative layout, you can, so we can replace this child with a relative layout instead. Then, we can put the image view inside this relative layout. This image view is now aligned to each edge of the parent relative layout. So, there you see an example of a relative layout that's contained within a larger linear layout. You can have many combinations of view groups within other view groups. For instance, you can have a relative layout as a root view for an app. That can contain a couple of views like an image view and two text views. You can also add a linear layout as a child of this broader relative layout. This linear layout itself can contain other children like two image views. You can nest as many view groups inside other view groups as you want. However, be careful because the more nesting that you do, the more expensive it will be for your app to lay out on the screen. The relative layout, in particular, is a very flexible layout but it can be very complex to calculate the position of each of these views relative to others. So it's recommended to not have too many layers of nesting within a relative layout. I pulled some examples from real life Google apps to show you some cases where it would be useful to use nested view groups. The Google Now app shows you cards of relevant information based on your current situation, like the current time or current location. If you like a certain team like the Red Sox, good choice, then it can show you the score for the latest game. To build out the layout for this card, you can imagine using a vertical linear layout because the information is displayed as rows. However, the first item in this vertical linear layout is not just a single text view, it's made up of multiple views. In fact, you would build this first item as a horizontal linear layout, made up of an image view and two text views. Same for the second item in this vertical linear layout. You would build it with a horizontal linear layout containing an image view and two text views. Another card in the Google Now app shows relevant stocks that you may be interested in. I wish the Google stock was still at that price. Anyways, you can also build out this layout as a vertical linear layout, because you can imagine the rows here. Except these middle entries aren't just a single text view, they're made up of multiple text views. For this line item relating to the Google stock price, you could use a horizontal linear layout and fill it with four text views. Same for the other stock prices as well. These horizontal linear layouts are children of this broader vertical linear layout. In the Google Play music app, you can, of course, listen to music. While this looks like a complicated layout to build, you can actually break it down into smaller view groups that you recognize. This pattern feels like a vertical linear layout with three different children. This first child can be built using a relative layout, because the views are relative to each other. The second child can also be built using a relative layout, because the views are overlapping each other. And this third child here looks like a horizontal linear layout made up of five different buttons. Again, we can use nested view groups to build out this screen. This is just one way to build out the layout. You can build it in many other ways as well. In the Google Maps app, earlier we saw that there are detailed pages for individual locations, like restaurants. You can't build out this screen with just a single linear layout or a single relative layout. You need to nest a bunch of view groups together. On a broad scale, we can see that the information is almost organized into rows. So, we can use a vertical linear layout as the parent view. One child could be this whole layout here. Another child could be this row of buttons. Another child would be this description and so on. But within each child is not just a single view. We have multiple views. This child in the broader linear layout is made up of three individual views. So you can use a horizontal linear layout with equal weights to each view so that they get spread out evenly. This child in the broader vertical linear layout can also be made up of a horizontal linear layout with an image view and a text view. If you keep scrolling this page, you see more information on the restaurant. Again, I can imagine the individual rows of information here. Using a vertical linear layout for all this information still works, and, again, some rows are more complex than just a single text view. This row shows a bunch of available times where you can make a reservation, and it's made up of three different buttons that you can arrange using a horizontal linear layout. This row of pictures can be built using a horizontal linear layout as well. And actually, within this horizontal linear layout, this first child is not just a single image view. It's an image view with a text view. So you could use a relative layout to build out this first child. So you could see how there can be view groups, within view groups, within view groups. There's actually more view groups beyond just relative layout, and linear layout, there's also frame layout and grid layout. We're not going to have time to cover those in this course, but I definitely recommend that you go out and learn about them on your own because sometimes those would be better than just using a relative or a linear layout. Let's look at how nested ViewGroups would apply to our app. The information in our app looks like it's arranged in a vertical column. So we can use a vertical LinearLayout for this. This looks good so far because we have one view per row in the vertical LinearLayout. But when we get to this row, it's actually made up of multiple views. We can use a horizontal LinearLayout to build out this row composed of a button, a TextView, and a button. So this LinearLayout would be the second child in the bigger vertical LinearLayout. In a moment, I'm going to show you three different XML layout files, and I want to ask you which one you think accurately builds up the layout that we want. The catch is I don't want you to copy these files and run them in Android Studio. I want you to make an educated guess based off of reading and understanding this code. You can find this link in instructor notes. It has three options listed, Option A, Option B, and Option C. One of these options correctly builds out the layout that we want. This is going to be challenging because we haven't previously encountered XML with nested ViewGroups. We're going to split this challenge across two quizzes, so I won't ask you to make a decision yet. For this first quiz, I want you to sketch out the view hierarchy diagram for each of the XML files. Here's a quick spiel on what view hierarchy means. You'll need paper and something to write with in order to sketch out these diagrams. The way that Android organizes all these views on screen is in a view hierarchy, or a tree structure of views. This is simply a diagram that represents the view hierarchy. It shows the parent and child relationships among the views. The root view of this whole layout is a LinearLayout. It has three children, a RelativeLayout, a TextView, and another TextView. And then this RelativeLayout in turn has its own children, an ImageView and a TextView. For our Puddles the Pig app, this is the view hierarchy that gets created by Android. We have a RelativeLayout as a root view, and it has four children, an ImageView, a couple TextViews, as well as a LinearLayout. And this LinearLayout, in turn, has two ImageViews as its children. Now you understand what a view hierarchy diagram is. By sketching out the diagram for each of these XML layouts, you'll better understand which view is the parent view, who the children are, and whether those children have children views or not. If you still need a hint, here are some examples of how to go from XML layouts to drawing a view hierarchy diagram. In this layout, we have a root view of a LinearLayout. By the way, I added these dots here because I couldn't fit all the code here. With a root view as a LinearLayout, you draw that at the top of the tree. And then it contains two children TextViews, so you draw those as children underneath that, and that's it. This is a more complicated layout. We have a root view that's a LinearLayout, and it contains three direct children, two TextViews, and a RelativeLayout, and then inside that RelativeLayout, we have an ImageView and a TextView as children. When you're done drawing out the view hierarchy diagram for each option, then go ahead and check these boxes to continue. In the following quiz, I'll ask you to make a selection on which option is best, but for now, you don't have to make a decision. I'm going to draw out the view hierarchy diagram for options A, B, and C. We'll start with option A. It contains a LinearLayout as the root view. So let me draw that. Then I want to figure out the next layer of the view hierarchy, which would be the direct children of this LinearLayout. I'm going to scroll through the XML file to figure out the direct children of this LinearLayout. We have a TextView, a LinearLayout, another TextView, another TextView, and then a Button. So let me draw that in. Cool, that looks good, but we actually skipped over a bunch of XML related to this LinearLayout. This nested LinearLayout contains a Button, a TextView, and a Button. Let's draw those in. This is the view hierarchy diagram for option A. At a high level, there is a parent LinearLayout as the root view. It contains five children views, and one of the children actually is a LinearLayout that contains three more views. Great, let's move on to option B. In option B, we have a parent LinearLayout as a root view again. Now, we can figure out the direct children of this LinearLayout. We have a TextView, a LinearLayout, another TextView, another TextView, and a Button. This nested LinearLayout also has more children. We have a Button, a TextView, and another Button. Hopefully, you're getting the idea of how to read an XML file by looking at the outermost parent first and then going inwards from there. And last but not least, we have option C. The root view is a LinearLayout again. Let's look for its direct children. We have a LinearLayout followed by a TextView, a TextView, and a button. Okay, good, so this is a view hierarchy diagram for option C. This looks a little bit different than the other options, so let's compare them side by side. Here are all the options side by side. A and B have very similar view hierarchies whereas option C has a different view hierarchy. This LinearLayout has only four children as opposed to five children in the other cases. Also, since A and B look very similar, we're going to have to look more closely at the XML to determine what the difference is between the two. In the next quiz, you'll look more closely at the XML for each option. Then I'll ask you to decide which option you think best accurately describes the layout that we want to build. With the pen and paper still in your hand, go ahead and sketch out what each option would look like on a device. You can refer to the view hierarchy diagrams that we created in the last quiz, if that helps you. Also, as you're reading through each XML file, make sure that you read each attribute carefully, so you don't miss anything. When you're done with those three sketches, I want you to decide on which option gives you the desired layout that we want. These are radio buttons instead of check boxes, so you can only pick one. Good luck. I'm going to draw out the different options for you. For Option A, we have a vertical LinearLayout as the root view. I'm just going to draw a big old rectangle. And I'll keep in mind that as I add views to it, it needs to be added in a vertical column. The first child is a TextView that says Quantity, and it's in all caps because it's a header. So let me draw that in. Next we have a horizontal LinearLayout. I'm going to draw it over here and add children horizontally. The first child of this LinearLayout is a minus button, so I'm going to draw that here. The second child of this horizontal LinearLayout is a TextView that has the text two in it. The third child is a plus button, so I'm going to add that here. All these children are added horizontally, and this whole horizontal LinearLayout is a child within this vertical LinearLayout. Next, we have a TextView that says Price, and it's in all caps. It's followed by another TextView that says $10, and lastly we have a Button that says Order. Nice, that actually looks like what we want. But we'll hold off on any judgements, and we'll keep looking at the other options and sketch them out first. For Option B, remember that the view hierarchy diagram was very similar to Option A. By looking at the XML more closely, let's see if it actually looks the same on the device. We're going to start with a horizontal LinearLayout as the root view. As I add children, I'm going to have to add them horizontally here. The first child is a TextView that is the quantity header, so let me draw that in. Next, we have a nested LinearLayout with orientation vertical. I'm going to draw that right here so it comes horizontally after the quantity TextView. As I add children to this LinearLayout, I'm going to add them vertically as in a vertical column. The first child is the minus button. Let me draw that. Below that we have a TextView that says two. And below that we have a plus button. That finishes this nested LinearLayout. We also have a price TextView, the $10, and also an Order button. Taking a step back, this doesn't quite look like what we want. So I'm going to take a wild guess and say Option B is not the correct answer. Let's move on to Option C. Option C had a very different view hierarchy in that it only had four children under the root parent LinearLayout. This parent view is a vertical LinearLayout. That means the children will be added vertically one after the other. The first child is a horizontal LinearLayout. That means I have to add the children horizontally, one after the other. The first child is a TextView that says quantity. Then I have a minus button, the text that says two, and a plus button. That also looks funny, but we'll keep going. After this plus button is the closing tag of the LinearLayout. So after that, these children are part of the vertical LinearLayout. So this price TextView needs to go vertically underneath this horizontal LinearLayout. The price TextView and the Order button are also part of the vertical LinearLayout, so they need to go underneath the price. This is what the layout looks like. As you can see, this quantity TextView has been made a child of this horizontal LinearLayout. So the quantity picker is showing up here but also the quantity header. This difference in layout is all because we moved the TextView to have a different parent. In the screenshot of the desired layout, we have the quantity header on top of the quantity picker, not beside each other. So we need to move this quantity TextView to be a child of this vertical LinearLayout and not a child of this horizontal LinearLayout. Here are the sketches side by side. Clearly, Option B is not what we want, and Option C is correct, except for the fact that quantity and the quantity picker are in the wrong spots. They should be on top of each other. That leaves Option A, which does actually build the desired layout. Whoa, that was a tough concept, but you handled it really well. This unlocks the ability to build some really awesome layouts in Android because almost all screens contain some type of nested layouts, which Correll was actually mentioning earlier in the Google Play app. After all of that prep work, now we're ready to go back into Android Studio land to implement the changes for an improved quantity picker. In case you're wondering, Katherine, what if I'm trying to build a layout and I don't have three options of XML layouts magically appear before me that I have to choose from. Well, that's a fair question. So far we've practiced being able to read XML and draw a view hierarchy diagram. We've also practiced reading XML layouts and drawing a sketch of what the screen would look like. But now it's time to practice seeing a design of what we want to build and being able to write the XML from it. I do realize that I gave you the solution XML in the previous quiz. I was somewhat paying attention, but I don't want you to look at that solution. I want you to practice the skill of seeing a screenshot or a mock of what you want to build and then being able to write the XML for it. Normally, we would start with the desired screenshot of what we want to build. You can get this from a designer that's working on your team who's designing the app for you. Or if you're working without a designer, you could also sketch this out on your own. Then you would imagine how to break this down into views and ViewGroups. You can mark it up and then try to draw out the view hierarchy diagram for the relationship between the children and the parent views. After you finish this diagram, you can start writing out the skeleton for what the XML layout code would look like. I'll leave these parts as an exercise for you. You'll make your changes in the activity_main.xml layout file. Aside from writing your XML here and seeing a preview of it, you can also click on the design pane here. This is Design tab as opposed to the Text tab. The Design pane allows you to drag and drop views onto the device. You can also see the component tree in the top right corner here. This is, essentially, a tree of all the views in your hierarchy. Currently we have vertical LinearLayout, that's the parent view, and all these children views inside of it. If you had nested ViewGroups, they would also show up here. Now go ahead and build this layout in Android Studio. After you've selected and positioned the views, remember to style them so it looks like this. The style of the views is mostly the same, except note that there's eight dp of space in-between the minus button and the two and in-between the two and the plus button. As mentioned earlier, avoid looking at the code and try implementing it yourself. When you're done, check this box to continue. First I look at the screen shot and decide that since the, these are in rows, it looks like a vertical linear layout. The second child though is not a single view, in fact that's a horizontal linear layout of three views. This is what the view hierarchy diagram would look like. We have a vertical linear layout as a root view and five children under that. The linear layout itself has three children as well. Once we have the diagram it's easy to create this skeleton of XML code now. The root view is a linear layout and it contains a text view as its first child followed by a linear layout which has a button, text view, and button inside of it. And this is the closing tag for the linear layout and then we have the text view, another text view, and a button. Which are all children of the parent linear layout. >From this XML we can go in to Android Studio and modify our existing layout to look more like this. In Android Studio I open up activity main XML layout file. We're going to make the changes in place in this file so that they match more closely to our desired layout. The first child is a TextView. That we already have. And it's supposed to be the quantity header. Next we should have a nested linear layout that contains three views inside of it. We don't have that yet, so let's add it. I'm going to hit Enter and then just start typing LinearLayout. It also shows up as one of the auto complete options. So I can just hit okay. Then it auto populates the attributes that I should fill in. Because width and height are required. I set the width to be match_parent, which will in turn match the width of it's parent, and this will match the width of the screen. For layout height, I don't want to set match_parent, otherwise, it will push the other views off the screen vertically. So I'm just going to say wrap_content here. That way the LinearLayout will only be as tall as the two buttons and TextView inside of it. Now, this closing tag should be moved after all the children of the LinearLayout have been added. So that will go down here. When you have children inside of a view group, you should indent the children by four spaces. I'm going to add a space here too because I like to have a blank line in between each XML element. One more thing we're missing is setting the orientation of this LinearLayout. Earlier we decided that the LinearLayout should be horizontal so that the buttons and the TextView appear horizontally. Cool. Now that matches what we wanted. Next we have, two TextViews and a Button which we already have in our layout. So I think we're done. If you wanted to check the design pane, this is what it would look like. We have a vertical linear layout with five direct children and this linear layout has three more children. Let's run it on our device to see what happens. So, this looks close to what we want but not quite. The quantity picker is appearing horizontally, which is a good sign. But we want the minus button on the left hand side and the plus button to be on the right hand side, as shown In the screenshot of the desired layout. Also, these buttons are tightly squeezed up against the edge of this TextView. If I remember the screenshot correctly, we also want eight dips of space on the left-hand side and right-hand side of this TextView. So let's add that now. Going back to the XML, I'm going to move the plus button to be after the TextView. And then move the minus button to be before the TextView. In a horizontal row, we should have the minus button, followed by the two, followed by the plus button. We also want to add padding around this TextView. We could either add it as margin or padding, but I'm just going to do padding. And we'll set the value to be eight dips. Okay, great. Now I have a hunch that there's a bunch of extra white spaces and the ordering of our attributes may be incorrect, according to the android code style guidelines. So, in the menu at the top of your screen, click on code and then click on reformat code. And also rearrange code. And that should rearrange all the attributes and fix up all the formatting for you automatically. Okay, great. Let's run the app again. There. That's better. Now there's space around the two and the minus button is on the left-hand side and the plus button is on the right-hand side. [SOUND] it looks good. And then we also check that it still works. So, I'm going to pick an arbitrary quantity and then order. And that looks correct. [SOUND] that was a long journey to get this quantity picker on the screen. All right. The app is looking really good. But so far, I've only showed you how to show numbers on the screen. What if you want to show text on the screen? Keep watching to find out. So, far we've built a quantity picker. Right. And the next place to go in the app is the price. Yes. The price is right. So, price is an integer so far, but we want to move beyond that and use strings. You mean, this type of string? No I mean like this type of string. Huh. So a string is just a sequence of characters. So wait. How does this work with the price then? So we're going to change the screen so that it says total. And then $15. So it's not just a number, now it has some text with it as well. Numbers and text. Yeah. Isn't that awesome? This is from the party that you may or may not have [LAUGH] been invited to. Over the next few videos we'll talk about using strings in our Just Java app. Specifically, we'll learn how to create and update string variables in the app. Then we'll change the app so that under the price header it says total, $15 or whatever the price is based on the quantity ordered. We'll also show the text, Thank you, because we're excited about having any customers at all. You might be wondering why don't we just put all of this text inside the XML layout? Well, we could, but the problem is that the quantity can change and when we hit the order button, we want the price to be updated here. So this text needs to accurately reflect the price based on the quantity. By using a string variable, we can change the value of the text while the app is running without having to hard code it into the whole XML layout. Here's an example from real apps that you may recognize. When you receive an incoming call you see the person's name at the top of the screen. We can't put this name directly into the XML layout because it will change depending on who calls you, unless all your family and friends are called Britta Holt. The best thing to do is to store this name in a string variable. That way you can update it depending on who calls you. Then when we show this screen we can just display the latest name that is stored in that variable. In the News and Weather app, we see a list of the top news stories. When we build the XML layout, we can't just specifically hard code these specific news stories into the XML layout. As much as I love reading about the Winter Olympics, I do want to see other news articles as well. So we can store the information for each news story, like the article title, as a string variable, because that can change. For the next task I'm going to provide you with some code and I'm going to have you make those changes in your app. Then you'll run the app and then observe what happens. I'll ask you some questions to see if you can try to figure out what's going on. The first change is to modify the submitOrder method. You can remove the code that's already in between the opening and closing braces and then replace it with these two lines of code. Adding this code will give you an error, so I want you to also add the displayMessage method, which we've provided in the instructor notes. In the instructor notes, you'll find this Gist of code. Go ahead and select the whole thing, from the comment all the way to the last closing brace. You can treat this method like a black box, you don't have to worry about what's going on Inside of the method, you just need to know that you want to add it to the MainActivity so that you can use it. Back in Android Studio, in the MainActivity.java file, I'm going to paste in this new method. I can paste it anywhere in the MainActivity, but I'm just going to put it right after the displayPrice method. And I'm going to put it after the closing brace of the displayPrice method. Notice that it's also inside of the closing brace of the MainActivity. The MainActivity has an opening brace right here, and everything inside of it is contained within the MainActivity. And then you have a closing brace for the MainActivity here. Once we've added the displayMessage method in, we can now modify the submitOrder method. I'm going to erase the code that we already have inside the submitOrder method. Then according to the quiz image, I'm going to add the new code here. Intentionally I'm not giving you too many details on what I just did. I want you to try it out in your version of the app, run it, and see what happens. After that I want you to answer these questions. What happens when you click on the order button in the app now? If you take a look at the submit order code more closely, we actually created a string variable. Even though we haven't gone over the code for string variables, I want you to make your best guess as to, what do you think the variable name is? And what do you think the variable value is? When you are done go ahead and continue. At this point, you should have modified the submitOrder method and also added the displayMessage method within the main activity. Then you can hit run to see it on your device. First, I'm going to change the Quantity, and then I'm going to hit the Order button. Now the app says free for price. That answers the first question. When the ORDER button is clicked, then the price text field now says Free. For the second question we talked about creating a string variable in the submitOrder method. Even though we haven't seen code for a string variable before, I ask you to guess what you think the variable name and value would be. The answer is that the variable name is priceMessage, and the value is Free. To arrive at these answers, let's look more closely at how we create string variables. Earlier in the lesson we learned about how to declare or create an integer variable. We're going to follow the same format to create a variable, but this time the variable holds text because it's a string. This is the code we added to our app. This creates a new string variable called priceMessage. And the value that it holds is the text Free. It follows a specific format according to the syntax rules of Java. First, we specify the data type. In this case, it's a string. Remember that a string is just a sequence of characters. Then it's followed by the variable name, which is priceMessage in this case. Then it's followed by an equal sign, initial value, and a semicolon to indicate the end of the statement. Saying that the data type is a string limits what type of information can go inside this variable. Only one string can be stored in it at a time. A string can be made up of letters, numbers, or symbols. You may recall that a variable name is the name that we give this variable, so we can refer to it later, to get the value out or to update the value. It's like giving the variable a name tag. When you're picking a variable name, it's important to choose something that's descriptive, that describes what type of information it will be holding. I could call this variable name Catherine, but it really does not reflect the information inside of it. It makes my code harder to read as well, because no one knows why there's a string variable called Catherine. On the other hand, a variable name like priceMessage is a little more helpful, because you know there's a message inside of it that's related to the price probably. We looked at this earlier, but there are naming conventions for variable names. If you forget what those are, you can always look them up. I just search for variable name Java in Google Search. I can scroll down here to where it talks about naming. It says that variable names are case-sensitive, and you usually start with a lowercase letter. And then you use camel case if there's multiple words. Next we have the assignment operator, or the equal sign here. This operator is in charge of assigning a value to a variable. So you take this value on the right-hand side and you assign it into the variable priceMessage. We specify the initial value of this string to be some text and double quotes. This is called a string literal, because a literal has a fixed value. We first heard about literals when we were learning about integer variables. A fixed value like two or five or ten are all integer literal values because they don't change, as opposed to a variable which does change. Going back to our box analogy, the value, Free, would go inside this variable. And last but not least, we also have a semicolon at the end of the statement. Now that we understand this line of code a little better, go ahead and try to experiment with different values. You can try to change the initial value here or change the variable name. For example, you can use a short string like Free or change it to be a longer string. You could make it a completely empty string as well, which leaves no characters in between the two quote signs. You could add a space, or you could add numbers as well, or you could add symbols. When you're creating your string literal, just be careful that there are certain characters that you need to deal with specially. For example, if you use the quote sign in your string, then you're going to run into an error that says, can't resolve symbol dollar and a semicolon is expected. This is because the compiler doesn't know that the whole string is supposed to be this whole thing. To solve this problem, let's do a Google search. In Google, search for Java escape characters. And scroll down to a section called escape sequences. In Java, certain characters mean special things. The start and end quote symbols are to denote a string in Java, but if you want to actually put a quote inside your string, you'll need to use an escape sequence. An escape sequence is a character preceded by a backslash, and the Java compiler will interpret it in a special way. If we use a backslash with a double quote, that indicates that we actually want to use the quote symbol, not the quote that means it's a text string. Let me show you what I mean. In Android Studio I can add a backslash before each quote mark that I actually want to appear in the text. Now, the whole initial value of this variable will be this whole string, because it's marked off by the certain end quotes. And inside that text string, I also want to use quotes, but I mark those by using a backslash in front of each quote. If I run on my device, I see the quotes around one dollar, but I don't see the quotes around the full thing ,which is what we expect. Another useful escape sequence to know is this backslash n, which inserts a new line so that the text will continue on to the next line. You can try this one out in your code as well. Remember that the semicolon should always be at the end of the statement. Even though in English it's grammatically correct to put the punctuation inside the quote, you want to put it on the outside of the quote. Anything in between here is part of the text string. And you need to put the semicolon on the outside for the Java compiler. You can also modify the variable name. If I change this to something like message, then this gives me an error here, because it can't resolve the symbol price message. So I just need to copy it and put it down here as well. And this should run on your device. You can't change the data type, though. It must be spelled string exactly like this. String is capitalized here because it's an object. We'll learn about objects in Lesson 3, but for now just type string with a capital S. When we were working with integers earlier, we would declare integers with a lowercase i for int. It's lowercase because it's a primitive data type, where primitive means it's one of the basic Java data types. Experiment with different variable names and initial values until you're comfortable with creating string variables. Then I want you to tell me what's incorrect about each of these string declarations listed below. I want you to point out the error in each of these lines of code. I asked you to determine the bug in each of these lines of code. Hopefully, you were able to do it by just looking at that line. For this solution video, I'm going to enter these lines of code into Android Studio so that you can see what error Android Studio would give us, and we're going to fix it as well so that there are no errors. I temporarily commented out this line of code using the double forward slash so that it doesn't show that there's a red error every time. We'll switch back to the code we had before, but I just wanted a place where I could add these test strings. If I type in string title = "Today's Specials", I get an error. It says that it can't resolve the symbol string. That's because Java doesn't recognize the type string with lowercase s. It needs to have a capital S. Now it recognizes this data type, and there's no errors. There's an error on the second line, but I'm going to comment it out with a double forward slash. That way the computer won't try to compile that line. Technically this string isn't going to go into our app, so we don't need it to work with the rest of our code. If I type in specialOfTheDay = "Cafe Latte", I also get an error. It says cannot resolve symbol specialOfTheDay. That's because this variable was not created earlier. This is the first time we're using it, and so we need to specify the data type in front of it. So we'll say String specialOfTheDay = "Caffe Latte", and that fixes the problem. Now I've typed in String nutritionInfo = "500 calories or less. Under the string here, I get a red underline that says illegal line and in string literal. I was trying to create a string literal here, but I forgot the end quote. So we need to add that, and that fixes the problem. The last one is String drink name = "iced coffee". The word name is highlighted in red, and I get an error saying it cannot resolve the symbol name. The reason is because a variable name should be in camelCase with no spaces. So I need to get rid of the space here, and if there's two words, you can just capitalize the beginning of the second word. And that fixes the error. For the name of the drink, you might want to capitalize the I or the C here, but it's really up to you. Anything you put in the double quotes is your choice, and the Java compiler won't complain about those types of errors. Great, you've really mastered how to create strings in Java now. When dealing with strings in Java, an important concept to understand is string concatenation. Now that's a really big word, but it just means we're joining character strings together end to end. If this is a string and this is a string, you can combine them by concatenating them to make an even longer string. To concatenate these strings together, we use the plus operator. This is the same addition symbol that we know from math. Just like you can add numbers together, you can concatenate strings together. Let's look at an example. Say I have three different strings, one string literal says I need, another string literal says 2 cups of coffee, and another string literal says on Monday. I can use the plus symbol to concatenate all these strings together. That forms a ginormous string that says I need2 cups of coffeeon Monday. Whenever I see something like this, I imagine the plus symbols are gone, and I imagine the quotes are gone, and I just imagine literally squishing all of these things together. And when I say squished, we're really squishing them together. There's even no extra space in between this string and this string. If you want to add a space here, you would have to explicitly add a space in this string literal at the end of it, or you add a space at the beginning of this string literal. Same with coffeeon Monday. I want a space here, so I'd have to either add it at the end of this string or the beginning of this string. I added a space here and a space here, so when I concatenate all of this together, I squish them together, and the sentence comes out correct like this. There's a space here and a space here. Adding spaces in the right place is a little bit tricky because you have the quotation marks everywhere and the plus symbols, and there's even spaces around the plus symbol. But these spaces around the plus symbol don't contribute to the overall display string. The space must be inside the double quotes. Here's an example of string concatenation in our app. I'm going to change the text so that it says "Amount due " + "$10". I'm concatenating this string literal with this string literal. When I run it on my device, and then I hit the order button, then I see Amount Due $10. You can also concatenate strings with integers like I have here. Before, the ten was in quotes so that was a string representation of the number ten. But here I just have 100 without quotes, so this is the integer value for 100. If I concatenate a string with an integer, then it immediately turns this whole thing into a string. If I hit the Order button, then I see $100 showing up on the screen. In a moment, I'll have you play around with string concatenation to try different values. You could get compile errors, so be careful of those. If I forget a closing quote, I could get an error. In a moment, I'll have you play around with string concatenation and try different values. According to Android code style guidelines, we should have a space before and after each operator. And this string concatenation operator counts as an operator. Now it's your turn to practice in your app. Experiment with combining different strings using the plus operator. You can also combine it with integer literal values as well. Once you feel comfortable with string concatenation, I want you to answer these questions. Let's go over the answers to these quiz questions. Each of these lines of code creates a string variable and I wanted to know what is the value that goes inside the string variable. That means we need to evaluate this expression which includes string concatenation. Part a says, String orderNumber = "Order number:" + 23. The value that gets stored in this variable is Order number;23. Notice that there's no space after the semicolon because the end quote is right after the semicolon. Since this is a string literal concatenated with a integer literal, then the whole thing just turns into a string. For part b, the right-hand side of the equal sign evaluates to the string You were served by Jack. There's a space here because there's a space right before we have the end quote. For part c, this string evaluates to You are2cups away from a free drink. The number 2 is an integer literal value here because it's not in quotes. It's just a plain number 2. Since we have an integer concatenated with a string, it just becomes a string, and all these parts are combined together, so we pretend to squish them together. And that's why there's no spaces right here, because there's no space after the are and there's no space before the cups, so are2cups is all combined with no spaces. In the last video we saw how we can take string literals and combine them with integer literals using the concatenation operator. This expression evaluates to the string, I need two cups of coffee on Monday. The powerful thing about concatenating different parts of the text together is that you can swap out different parts if they need to change. For example, the number of cups of coffee might change so instead of a literal value here, we can change it to be a variable. Now I've removed the two and replaced it with a quantity variable, so when we evaluate this expression, we'll always get the latest value of the quantity variable. If the variable is holding the value 2, then it'll pronounce something like, I need 2 cups of coffee on Monday. So these parts of the string stay constant and they don't change, whereas the quantity is free to change and will always get the latest value. I'm going to try it out in Android Studio. Since quantity happens to be a variable that we already have declared in the MainActivity, I can just use it directly in submitOrder method. I'm going to make up a string like Total Item Count, and then add quantity, and then coffees. This isn't really related to price, but I just want to show you that you can concatenate strings with variables. Let's run this to see what it looks like. If I change the quantity and then hit the order button then it shows total item count, 3 coffees. I forgot to add the space right after the 3, but before coffees, so we should go and add that in. I am going to add a space here so that it appears right after the quantity. Notice that quantity here is not in double quotes, if it was then it would literally show quantity on the screen, but we want the value of this variable so we don't put it in quotes. Now that it has an extra space here let's try to run it and make sure it's correct. Now when I change the quantity to 3 and hit the Order button it says, Total Item Count 3 coffees. It correctly has a space before and after the quantity value. Taking a step back, when you look at this line of code it can be a little overwhelming because there's quotation marks everywhere and plus signs and spaces in weird places. Just imagine that the plus signs disappear and everything in the quotes gets squished together and that the quantity variable gets replaced with an actual value. Because it's not that easy to read, it's common to have mistakes here. You might miss an opening or closing quotation or put the plus in the wrong place or accidentally put a variable in quotes. Just read through your code carefully to make sure it's doing what you expect. You can also do math expressions. You can have quantity times five in parentheses and this will turn into a single integer value and that will get concatenated to Price. A string plus an integer turns into a string and that gets stored in the variable priceMessage and that gets displayed on the screen. When I run this on my device It shows up as Price 15. If you want the dollar sign or the currency symbol to show up, you need to make it part of the string literal, like this. The integer only holds the number part, not the currency symbol. If I run this on my device and then hit the Order button, now I see the currency symbol. Following the pattern that I've been showing you, go ahead and modify the submitOrder method so you can practice displaying different messages on the screen. First, try to display Amount Due $10 on the screen when you hit the Order button. Once you get that working, then change it so that you display this string when you hit the order button. Repeat the same for each of these different strings. You should only see one of these strings on the screen at one time. Remember to concatenate the strings with variables so that the quantity and price values are accurate based on the quantity picker. So, if I change this to quantity of five cups of coffee, then the amount due should be $25. First, I'm going to change the app so when you hit the Order button, it's going to show Amount Due $10 or whatever the price is. Since there's going to be a lot of combinations where I'm going to need the price, I'm just going to create an integer variable to hold the price. Notice that the int is lowercase i because it's a primitive data type. Now I can just refer to the price variable whenever I want the price number. Now, I need to change the string so it says Amount Due. So, I'm going to write "Amount Due ", add a space, and then concatenate that with the price variable. Oh, and I forgot the dollar sign as well. The dollar sign should be part of this string literal, and I want it to be after a space, so I'll put it right here. Now I'm going to run it. If I change quantity to three and then hit the Order button, then it correctly shows Amount Due $15. First one done, that wasn't too bad. Next, we want it to say that would be $10, please. I'm going to change this text to start with That would be, and then I want a dollar sign, the price, and then I want some more text after that. I should say " please" and a period. I add a space here because I want a space after the price. Let's check to see what that looks like. On the device, if I change quantity to three, hit the Order button, it says That would be $15 please. Now the second one's done. We're on a roll. The third one says, You owe 10 bucks, dude! I'm going to change the start of this string to be You owe, and then I'm going to remove the dollar sign because we just need the price, and then we're going to add " bucks, dude!". That looks correct. Let's run that. I'm going to hit the Order button. It says, You owe 15 bucks, dude! The fourth one is a little tricky. We want to say 10 dollars for 2 cups of coffee. Pay up. I see a need for two variables here, the price variable and the quantity variable. We're going to start with the price, which is ten. And then we're going to say " dollars for ", and then I need to put the quantity and then " cups of coffee. And then Pay up.". Let's run that. If I hit the Order button, then it says 15 dollars for 3 cups of coffee. Pay up. That looks really good. This was tricky because we had two variables here, concatenated with two string literals. Fortunately, we added spaces in the right place so that it would look like a normal sentence. That was the hardest one, and now we can do the last one, that says Total: $10. I'm going to erase this whole thing here, and say "Total: " and then the price. Oh, but I also need the dollar sign, so I'm going to put that inside the string literal. Oh, and I forgot the plus sign, too. There, now let's run the app. I change quantity to three, hit Order, then it correctly says Total: $15. Woo hoo! You got through all of these different combinations of string concatenation with variables. Now move on to the next video for your last coding task of this lesson. Just like you can change the value of an integer variable after you've created it, you can also change the value of a string variable. You can update it to a completely new value. In our Just Java app, say we wanted to display a special drink of the day. Then we could use a string variable to store the name of that drink. Here we declare a string variable called drinkOfTheDay and we initially set it to the value Latte. With our box analogy this is what it would look like. We have the Latte value stored inside this variable. On another line of code we can say drinkOfTheDay equals a new string value. Now the word Espresso is stored in this string. We don't need to specify the data type string again, because it was already declared as a string up here. On the next line of code if we say drinkOfTheDay equals Green Tea, then we store Green Tea into this variable now. Here's another example where we might want to display the store hours within our app. We can create a string variable to store the text that should be displayed on the screen. The initial value is Open today from 8AM to 5PM. On a different day we can update the string variable to say Open today from 8AM to 2PM, because we want to leave early to go to the beach. Or on another day we can update the store hours to say Closed today, because we don't work on Sundays. If our app had a running list of all the drinks that the user wanted then we could create a string variable called drinksOrdered. We could start it off with one drink, like 1 mocha. In the variable we would store the text 1 mocha. And then if the user wants another drink, then we can just concatenate the new drink onto the existing drinksOrdered. This gets stored inside the variable drinksOrdered like this. If I want to add another drink, I can just concatenate that onto the existing string drinksOrdered. This expression evaluates to one long string that says 1 mocha, 1 cappuccino, 1 macchiato. All of that gets stored into this variable like this. It might look a little funny to have a comma and a space at the beginning of this string, but that just makes the list look nice with commas in between each item. The reason why I didn't put a comma at the end of cappuccino is because I can't be sure if there's going to be another drink coming after that or not. If there's only two drinks, then I will say 1 mocha, 1 cappuccino and that looks fine as is. If there's another drink coming, like a macchiato, then I can just add a comma because I know another drink is coming. Go ahead and try this out in Android Studio. Add another line of code that updates the string variable to a new value, or you can update it to the current value plus some more stuff. Once you're comfortable with knowing how to update string variables in Android Studio, then go ahead and implement this final behavior in the app for lesson two. When you change the quantity and hit the Order button, it should say Total and the price, and then Thank you! Technically you don't need to update the string variable in order to build out this functionality. However, I'd still like you to do so if you can. In the next lesson you're going to need to update string variables more often, specifically because there's going to be more fields in this order form and we're going to need to build up the order summary. When you're done, check these boxes to continue. This is the last coding task of the lesson, so good luck. So far the message already says "Total: and the price, and we just need to update it so it also says thank you. I'm going to update the string variable because I want to practice that. So I'm going to create a new line of code that updates the price message. And I'm going to just add on to whatever's in the price message string. And I'm going to add Thank you! Let's run this on the device. Okay, if I change the quantity and I hit order, then it says, Total $15Thank you! And it all runs together without any spaces. But the thing is, I don't really just want a single space. I really need it to go on the next line. If you remember earlier in the lesson, I mentioned escape characters in Java. Escape sequences are a character preceded by a backslash, and they mean something special to the Java compiler. Before we used it to insert a double quote in a string. Now we can use it to insert a new line in a text. In the code, I'm going to add \n so that it creates a new line right before it says Thank you! When I run the app and change the quality and I hit Order, then it says Total $15, and then it adds a new line and then it says Thank you! Yay! And thank you for doing all the coding tasks in lesson two. So our students have been learning about variables and data types in this lesson. Particularly about integers and strings. Are there examples in the apps that you've worked on of these things? Yes, there are plenty. So, strings and integers are everywhere. In Gmail for example, when you first open your email it tells you how many unread messages that you have, so that's a very, very important number. And we actually have these very subtle bugs, that the number might not match exactly how many unread messages you have. So. [CROSSTALK] I've never had encountered that, have you? That's good. [LAUGH]. That you've never encountered that. So, yeah, but these are, you know, it's an interesting problem to solve, because for Gmail, we actually sync that number first. Like sync means like, I'm fetching my data from the Cloud to my Android device. So, that data is actually, that number, is synced separately from your actual email. So, they could potentially go out of sync. That is one of the very trickier issues. Okay, so we were established that the number of unread emails is a variable. It's data type would be. It would be an integer. It would be an integer. It's value is being calculated across devices. And it's value is changing based on the use case of the scenario. I use it as experience. Yes, exactly. And another use of integers, so that's an example of a variable integer, basically it could change. Another example is ID's. So for ID's it's actually very important that the integer stays the same. So my email ID, particularly. Okay. Exactly. So the email ID on the server that represents that email needs to be exactly the same as the ID that's on the client. Because that's the way we uniquely identify this email everywhere across all your devices. So this is for our conversation email, not like an email address. Yes, for our conversation, so for in Gmail for example the whole thread. So the email thread which has multiple messages in it, the whole thread we call a conversation, it has a conversation Oh, okay, I see. And then each message itself also has its own unique ID. Okay, and each one of these ID's is stored in a variable who's data type is? Integer again. Okay. Yes How many emails are going out in a day. Do you know? This is a lot of numbers. Yes, I do, I do not know on top of my head how many emails. I'd imagine that if each message in a conversation is unique and each email is unique across all emails that are going. Yes. That should be a very large number, right? So that's a very good question. So instead of int actually for these we use logs. Okay. Because it's a 64 bit. So then we will never. [CROSSTALK] So long just gives you more space to hoard a larger number, right? That's really the difference between Inter Long? Okay. How about any strings? Strings. I'd imagine it's subjective. A string, or how is that stored? Yeah, everything. Yeah, subject is a string itself. Okay. And obviously email addresses are strings. That's very important. And almost everything that you see in any app, like virtually everything that has text will be a string. And I think a good engineer doesn't have to know everything. But you really, you have to be good at like figuring out like, you know where the answer is. You can probably look for, there's a lot of good tutorials out there for, just have to know how to look for the right key words. Search for the right key words. If you also ask people for help. Oh yes, that is actually very important. I think almost always I regret not asking people earlier. You know I could like try to fix something, for like a whole day, and at the end of the day, said okay, maybe I should have asked whoever wrote this component. So yeah, I think reaching out to people early is definitely valuable, to save very valuable time. And also just being more aware of what other projects are going on at Google. I think the, or at your own, around you. I think the really good engineers, they're not only focus on what they're doing, but they we have these things called tech talks at work. Which are available publicly for people to view, at least some of them are. Yes. Some of them are, yes. So their often know what the latest technologies are, from these tech talks or announcements that are sent to the entire engineering org. So, just being on top of. And let's go back to the time when you were actually learning to program. If you could talk to the Alice at that time, what advice would you give her today? Wow. That's a very interesting question. I feel like I should have had more fun with programming. So, I think the way I learned to program, and I think it's very different now, because I grew up in, originally I'm from China. So I think it was very academically focused. Like, I went to these extracurricular classes that tlike taught via teacher, and then we'd get assignments like you learn to solve them, and learn to solve this problem. And I think, looking back, I wish I had like done more fun-type projects. Would you make a birthday app? A birthday app? [LAUGH] Yeah exactly, like, these type of apps I think I could learn a lot more. Because it's not just about there's one right answer. But in like doing an app like that I can learn about design if its a birthday app. I learn about different UI components its not just about, okay you need to send this data from here to here. And then solve it more efficiently. I think in real life that is what, you know, engineering is more about. It's about not just solving a technical challenge, but also creating a great product. Sort of like being driven by your own curiosity. Yes, exactly. Yes. Well, Cathy and I want to thank you for your time. You're very welcome. I think our students will benefit a lot from your perspective. Yeah, okay. Our student just learned Java. That's amazing. It's huge. It is huge. They also learned how to add a button on the app. Click on the button, something happens magically. It's called event-driven programming. Oh, yeah. You know it, we know it, they know it, now. Yeah, now they know it. And we also learned about variables. Mm-hm. Which is what makes the quantity picker go up and down. Correct. Alice, the Android developer, made a guest appearance. Oh yeah, Alice. She was talking about how she gets unstuck when she comes across a bug. Mm-hm. Those are some good tips. Right. Yeah. So, do you know what that means? We're basically done. We're done with lesson two. Nice. You done with that? Yeah. I think so. because we closed an hour ago. Oh, sorry. Oh, sorry. I'll take it from here. So how did you get to work today? I have a bike, works out just fine. How about you? Okay. I drive. Oh cool, how's that car working out? It's good. Yeah? Do you know how it works, underneath the hood? No, I don't need to. I just need to put the key in, and then I drive it. You know, this is kind of like writing code. In what way? Well, everything is kind of like writing code. Okay, yeah. Stick with me for a second. In previous lessons we gave students a bunch of code. Yeah. We gave them methods like the display method and the display price method. Right. And we kept saying, well, don't worry about this. We'll talk about what it does later. Well that later is now. Okay. Okay. So much like you know how a car works. You can use it. Students were able to use that method. Okay. Right? But we wrote the method, so we were the designers of the car in that case. I see. So the main idea is that you can define the method somewhere. So that's like building the car. And then later you can call that method. That's like driving the car. Yeah. So let's use those ideas next. Sounds good. Within the MainActivity.java file, this is where the display method is defined. And this is where it's getting called, within the increment method and within the decrement method. The instructions of the display method take in a number and then display it on the screen. Like this right here. Instead of defining a method we can also just take the instructions inside of it by copying it and then pasting it where we called that method. And since number is not a variable here, we're going to change it to quantity. If we want to do the same for the increment method, we'd copy this code and then paste it up here. So this code works the same as we had before, but now we don't need the display method. The disadvantage to this implementation is that we have duplicate code in both methods. Instead, if we define the display method and then we just call it by its name, then we can have less code which is better for the app. I also want to show you something else that's cool. Anytime you see a method, you can click on it and then right click. And then go to declaration, or Command + V if you're on a Mac. This scrolls the file to where the method is defined. This is useful because then you can see the actual instructions that are contained within that method. For other methods, it may open up a declaration in the Android framework code. This was written by the Android team, the TextView.java file. This shows that, even though things may look like magic, you can always trace it back to the lines of code where it was defined. Either by you or by someone on the Android team. To help you understand the difference between defining versus calling a method, let's modify the main activity. We're going to change the way a method is defined by changing the name of the display method to the name displayQuantity. Then for calling this method, do we need to change anything about that code? If these changes cause an error in your app, make sure to address that so that you can run the app on your phone again. Check these boxes when you're done. Let's do the first task. I'm going to change the name of the display method to displayquantity. Now this causes some errors in our app. If I scroll up I see an error that says cannot resolve method display int. This is actually related to the second task, where we asked if you need to change the way that the method is called. The answer is yes, because when we change the name of the method, we need to change the way that it's called. So, in the increment method, I'm going to change this to say displayQuantity, and then decrement method, I'm going to change this to say displayQuantity as well. Now there's no more errors in our app and I can save this and then run the app on the device. And the app works as expected. There's no user visible change, but internally, in our code, we did change the method name. Earlier, we saw that we could pass a number into the display method. Let's talk more about the different inputs and output of a method. Let's look at the submitOrder method in the MainActivity as an example. Say you have a bunch of lines of code in that method. When the user clicks on the Order button, it will trigger this submitOrder method to be called. The Android device will execute each of these instructions from top to bottom, and when it hits the calculatePrice method call it will jump over to where the calculatePrice method is defined. Say that this is defined at the bottom of the MainActivity file. The Android device will execute each of these instructions from top to bottom of the method, and then it will jump back to the submitOrder method. Then, it will continue executing these instructions until it hits the end of the method. When the calculatePrice method is called, we can pass a bunch of inputs over so that when we're executing these lines of code, we can use these input values. As a result of this method, we can pass a single output value back to the caller. That way, the output value can be used in the subsequent lines of code. In Java, we call the inputs to a method input parameters, and we can have zero or more input parameters. In Java, we call the output a return value, and we can have zero or one return value. An example of an input parameter is passing the quantity over to the calculatePrice method. That way, this method can use the quantity to figure out the total price of the whole order. Then, we can pass that total price back as a return value. And then in the submitOrder method, down here, we can use this total price to do other things, like display it onscreen, or create receipt, or anything like that. So to summarize, this is where we define the calculatePrice method, and this is where we call it. We want to create a method to calculate the price of a coffee order. Currently, we calculate the price directly in the submitOrder method, but the logic to calculate the price is going to get a little more complicated. So let's move it into its own method. Then we can call it as many times as we want without copying and pasting the code everywhere. As you gain more experience in Android development, you'll gain better judgment on when to create a new method for something or when you don't need to. This will just come with more experience and more time. So, this is the first time we're going to be creating a new method in the MainActivity on our own. Instead of starting by writing it from scratch, we want to start by learning to recognize what is a correct method by reading some code snippets. So in the instructor notes, we're going to provide you three options. Read over these three code snippets and determine which option correctly implements the method to calculate the price of the order. When you click on the link in the instructor notes, you'll see this just has code for options A, B, and C. The goal here is for you to become comfortable with reading code that you've never seen before. We haven't gone over the exact rules for what makes a valid method, but I want you to make your best guess on which option you think is most correct. I also encourage you to Google search for more information on how to define Java methods. As you click through the different search results, you'll come across information in the documentation that you don't understand. But I want you to become comfortable with not understanding everything on those pages, because it's perfectly normal to not understand everything. All you need to do is just skim the articles for what you understand and what you think is relevant to the problem at hand. So, go ahead and read the code for these three options, look up some information online, and then make your best guest on how to correctly define the calculatePrice method. The correct answer to this quiz is option C. It's okay if you didn't get the answer, though, because it was covering topics that we haven't learned about yet. At a high level I will quickly go through why each option was correct or incorrect, but we'll learn more about all these terms in the following videos. Let's look at our three options here and look for differences between them. First, you may have noticed that the lines of code inside each method are the same. Right here, right here, and right here. Also the comment above each method is also the same. And the comment is just what describes what the method does. And the method is supposed to calculate the price of the order based on the quantity. Another similarity is that they all start with the word private. We don't know what that means yet, but that's okay. The next word here is int. It doesn't say int though in Option B, but it does say int in option C. So, for some reason, it's different here. Let's move onto the next part. Here it says calculate price and it's two words. In Option B, CalculatePrice is smushed together as a single word in camel case. In option C it's also in camel case, with no spaces. Then moving along we see an opening parenthesis and then int quantity. There's no closing parenthesis though, which is a little weird. In Option B, we also see opening and closing parentheses and int quantity. In option C, we see opening closing parentheses, and int quantity. Then, we see there's an opening brace here, and a closing brace. But not in option B. And they do show up in option C, though. So we notice a bunch of differences among the different options. Let's look at an example of what a valid method should be by doing a Google search. So I'm going to open up a browser and then search for define java method. You could have searched for a different query and that would have worked as well. This first link looks good. It's from the official Oracle documentation on Java. I'm going to click on it. If you haven't seen this page before, feel free to pause the video now and click on the link in the instructor notes to skim through this page. While this doesn't match our code exactly, you could try to pattern match the components of this method declaration with our code. This other sentence here is helpful. It talks about how the required elements of a method declaration are the method's return type, name, a pair of parenthesis and a body between these braces. Now, I just mentioned a lot of new words and you can read about them below. But, we'll talk about them in more detail later. Let's try to use this information here to help us narrow down our options. If we compare this option with the proper method declaration on the documentation page, this option is actually incorrect. There is an opening parentheses here but there's no closing parentheses. And in the documentation, it says that we need a complete pair of parentheses, like right here and right here. The documentation also says that a method name has to follow the same rules as the naming for a field or variables, and that means we need to use camel case and not have any spaces in the name. So it's not option A, let's go on to option B, here we're missing the opening and closing braces, which the documentation said were required. Option B is also missing the method's return type which is suppose to come before the method name. So right here we should have the word int, because we want to return the price as the output of this method. So Option B is also incorrect for two reason. So let's hope that Option C is better. Here we have a return data type which is correct, and then we have a method name that is correctly spelled in CamelCase. We also have an opening and closing parenthesis, as well as an opening and closing braces. So this one looks really good. Option C has all the required parts of a method. Let's talk more about this next. To figure out why option C was the best on the last quiz, let's review the actual syntax rules in Jjava for defining a method. This is also known as the method signature. This is the method signature for the calculate price method that we saw earlier. You might be wondering why the order of the words are a certain way. Well, they follow a specific format, and it looks something like this. I know this looks really overwhelming, but don't worry. We're going to go through each one, one at at time. The first part in this method signature is the word private. This is known as the JAVA access modifier. It determines who has access to this method, calculatePrice. The most common access modifiers that you'll see are public or private. This method is marked as private, that means that calculatePrice can only be called within other methods of the main activity. Outside of the main activity, like another activities, you won't be able to call this method. It's private to the main activity. On the other hand, if you mark this as a public method, then anyone could call this method, whether you're inside the main activity, or you're in other activities. It's kind of like this analogy. If you're celebrity and public, then everyone knows about you. If your private and you live inside your house all the time, then only a couple people know you. So for the calculate price method, we are going to keep it private, so it is only used within the main activity. Next we have "int" which is the return data type. Do you remember our diagram from earlier? Where we said that when you call a method you pass it inputs and you get an output back? Well the return data type is a type of data that is returned in the output. And the data types we've learned about so far are Int and String from the last lesson. This can also return an object data type, and we'll learn more about objects later in the lesson. In our case, this calculatePrice method is returning the total price of the order, which is an integer. In a social media app, if I had a method to get the number of friends I have on Facebook, it could return an integer, which is the number of friends. Next we have the method name, which is calculatePrice in this case. Just like how we can refer to variables with their name, we can refer to methods with their name so that we can execute the instructions in this method. In the same documentation about defining method, we can scroll to the bottom and see a section about naming methods. You can read about this in more detail later, but basically it says that method names should begin with a verb like run or get, or compare or set. It starts with a lowercase letter and then use camel case if there's multiple words. After the method name we have the list of inputs which are denoted within the opening and closing parenthesis. You can have as many inputs as you want. If you don't want any inputs, you just have an empty set of parentheses. If you have one input, it looks like this. If you have multiple inputs, you just separate them with commas in between each input. Let's look at the case where we have one input, which is also known as an input parameter. We define an input parameter by specifying its data type and a variable name that we choose for it. So from the diagram of inputs and output, this is going to be the first input to the method. Within this method, then you can refer to the quantity variable. And it's just like any other variable, where it already has a value inside of it. The value comes from when you initially call the method and you pass that input in. If we want to modify the method signature to add a second input param, we have to specify the data type and the variable name for that second input param. Then within this method we can refer to the quantity or price of one cup variables just like the regular variables. When you call this method you have to remember to pass the right number of inputs to the method that it's expecting, and the inputs must be of the right data type and in the right order. You can't flip the order of these. Otherwise, the method is going to interpret them incorrectly. After you list out your inputs, add a closing parentheses and then an opening brace. This starts the list of all the instructions within your method. After all of that, then just add a closing brace, to mark the end of your method. Going back to our documentation, now this method declaration will make a lot more sense. First we have the access modifier. Then we have a return data type. The method name, followed by the list of all the inputs. In this case there are four different input parameters. And they each have a data type and a variable name. And then we have an opening brace. The list of all the instructions inside of it. And then a closing brace. And this is a method declaration. In this quiz you'll have a chance to practice identifying the different parts of method declaration. We're going to provide some code to you in instructor notes. The code contains a bunch of methods that could appear in any app. For each case, can you tell me what is the method name? The list of input parameters? And the return data type. Let's do the sample together. Here's an example method. The goal is to create a custom greeting message based on the given name. The return value is going to be a greeting in the form of some text. Now let's ignore the comment for now. First we have the method name, which is in camelCase here, and it says createCustonGreeting. Next we have the list of inputs. This is the first input parameter. The data type is String and the variable name is firstName. Next we have the second input parameter. This is the data type, and this is the variable name. And the two inputs are separated by a single comma, and they're enclosed within the opening and closing parenthesis. Then we have the output here. The data type of the return value is String, because we want to return a greeting, which is a string, and this is what it looks like filled into the table. Now, go ahead and fill in the blanks for the remaining three methods. Let's walk through each of these methods and then fill in the table. This is the gist of code that we provided to you in the instructor notes. Let's start with Method 1. This method is meant to create a reminder message for a particular calendar event. The message will be composed of the event's name, and event location as well as how many minutes away the event is. So the method name is createCalendarEventReminder in Camel Case, and then the list of inputs is in between the opening and closing parentheses here. There are three input parameters, the first is String eventName, then String location, and then int minutesAway. The output of this method or the return value is the reminder message, which is text. So that's why the return data type is a string. And this is what it looks like filled in the table. Technically, this should all be one word without any spaces, but it just doesn't fit in this box. And this is the second method. The goal of this method is to deduct a certain number of points that were used from the overall number of points, which is 100. So, it returns the remaining number of points. The method name is called deductPoints and there's one input parameter in between this opening and closing parentheses It's called pointsUsed, and the data type is int. The return value is numberOfPoints remaining, and that's a number, so that's why the return data type is an int. In the table, this is what it would look like. And this is the third method, the goal of this method is to create a text string that says the sum of all the individual trip lengths the method name is findTotalTripLength. Then we have to scroll to the right to see all the parameters. We have three input parameters here in between the opening and closing parentheses, and they're separated by commas. The first is Int distanceOfFirstTrip, the second is Int distanceOfSecondTrip, and Int distanceOfThirdTrip. So, within this method, we can refer to each of these variables. Since they're integers, we can add them all up to the total length of the trip, which starts at two miles. And then we can concatenate that to this string message. Since this message is text, the return value of the method is string. And this is what it looks like in the table. Wait. What's wrong? When did this turn into a cooking show all of a sudden? Since we had to talk about methods? Care to explain, Rachael Ray? [LAUGH] Well, have you ever baked a cake before? I have eaten a cake before. Okay. Well, then you're fully qualified for this. Okay. All you have to do to bake a cake is to put in flour, sugar. The ingredients. Okay. The ingredients. Yeah. And then you follow the instructions of the recipe. Okay. And then out comes a cake. Like this? Yeah. Okay. Well connect the analogy to the methods one more time. Okay. Sure so for a method you can put in inputs. Like we did the quantity for the display method? Yeah, and then you execute the instructions of the method. Okay, almost like the recipe for making a cake? Mm-hm. Then you can have the output value returned. Outputs, they are delicious. [LAUGH] Let's look up more information about input parameters for methods. I'm going to do a Google search for Jjava method parameter. The first link looks good so I'm going to click on it. Now this article talks about passing information to a method. Here's a code snippet that computes the monthly payments for a home loan. It has four input parameters, loan amount, interest rate, future value of the loan, as well as the number periods of the length of the loan. And then inside this method we see that we can use these input parameters simply as variables to do our math calculations. When we call the compute payment method, we have to make sure we pass in the inputs in this specific order. So the loan amount has to go first, and then the rate and so on. For the quiz in this section, you'll have the chance to review this article in more detail. Within the main activity of the desk Java app, we're going to be modifying the display quantity method and the input parameter to give you some practice. Notice that in the decrement method of our app, what we call the display quantity method, we're passing the quantity variable over as input to this method. But the input parameter is called 'number', so whenever we want to refer to this input, we just have to say number. Now technically we could have used the global quantity variable within this method instead of passing it as an input parameter. but for the purposes of teaching you about input parameters, let's just leave it like this. I can change this call to the display quantity method so it passes input, the number 30. This is valid because it still matches the input data type. So in the decrement method when we call it display quantity, it will jump down here and it will execute these instructions, and the variable number will have the value of 30. I'll run it on my device to show you, so now when I run the minus button on my app, it will display a quantity of 30 here. So let me try that. There. And it actually happened like that. I can also create a different variable and pass that as an input to the method. Here I've created a local variable called some quantity, and I initialized it to 100. I passed this variable as input to this method, and now the number variable inside here has a value of 100. Let me run this on the device. Now I expect when I hit the minus button the quantity will update to 100. And it does. These are just some things you can do to experiment with passing in different inputs to a method. As you work with input parameters, another term that you might come across is arguments. When you call a method, the inputs being passed to that method are called the arguments. Now this is kind of a funny word. Because when you think of arguments, you think of people yelling and cursing at each other. But this is not like that. Arguments are simply the inputs being passed to a method. Input parameters are the actual inputs in your method declaration and those are the variables that are used within your method. So that's a slight difference between input parameter and arguments. In any case, go ahead and read the article and the instructor notes about method parameters. Then go ahead and experiment with the code in your app. First try to rename the number input parameter within the display quantity method declaration. Just simply give it a different variable name. Then go ahead and fix any errors, and then run the app again. For the next test, go ahead and change the data type of the number input parameter from an int to something else like String. Observe what happens and then go ahead and undo the change. If you want to experiment with other things, go right ahead. For example, if you have a question, what would happen if I do x, then just go ahead and try it. Let's do the first task. We're going to rename the number input parameter to have a different name. This is the first input parameter, int number, and all I need to do is just change the variable name. I'm going to change this to, for example, numberOfCoffees. It can be any name that you want. Now, I immediately see a warning and an error. The warning says, the parameter numberOfCoffees is never used, because nowhere in this method do I use this variable. Then I see that there's an error that says, cannot resolve symbol number. Now, there's no variable called number. There's no local variable called number. There's no global variable called number. And it's not an input parameter, either. instead, I need to switch this so that it's called numberOfCoffees. And there you go, that fixed the error. So I'm going to run it on my device now. And this is what it looks like. The quantity picker works as expected. There should be no visible change to the user because we just modified the name of an input parameter. Also, we didn't have to change the way that the method is being called. We can still say displayQuantity and then pass in anything we want. It doesn't matter to the caller what this input parameter name is. The second task is to change the data type of the input parameter from int to string. So in the display quantity method, I'm going to change the input so that instead of a integer data type, it expects a string data type, like this. And now, there's a couple errors in our app. When I scroll up, I see that there is a red squiggly underline in the increment method and in the decrement method. The error message says, displayQuantity string in MainActivity can't be applied to something int. What it's saying is that we can't pass the quantity variable into the method anymore because this is an integer, and it's expecting a string. This mismatch in data type is causing an error, and the app won't even run on our device. This is a compile time error. There's a couple ways to fix this. Either we have to change what's being passed into the method so that this is actually a string. I could put 100 here and put it in double quotes so that it's a string, and that would match the right input type here. But what we really want is for quantity to still be an integer so that we can do math on it to increase it by one or decrease it by one. So I'm going to leave this as quantity. And then this should be changed to be an integer. And then our app should work again. Cool. So so far, we've seen an example of a method with one input parameter. But what about examples of methods with zero input parameters, or two input parameters, or more? I'm going to walk you through an example of a method with a different number of input parameters. I started by creating a new app from the project wizard in Android Studio, so this is completely unrelated to the Just Java app. I added this method in the main activity. It's called createWeatherMessage. There's no input parameters, and the return value is a string. This method is supposed to create a new message that specifies the city name and the temperature. You can think of a method as being a template of instructions. So I can make temperature be an input parameter. And it's a number, so I'm going to say, int temperature. And then I can use this right here. So, this is a string literal, and then it's concatenated with the temperature integer. And then it's concatenated with another string that says degrees Fahrenheit. So now the message can be customized based on the temperature because it's an input parameter. Oh yeah, I forgot to mention this earlier, but in the onCreate method of the main activity, which is called when the activity gets created, I can call the createWeatherMessage. Before I passed in no arguments, but now we have one required parameter. So I'm going to pass in 77 for the temperature. Now that makes the error go away, and this method call is correct. The other thing I should modify is this comment on the method. I'm going to add a blank line, and then I'll start to describe the input parameter which is temperature here. I'm going to type @param temperature, and then I can add a description saying that this is the temperature of the city. Sometimes the parameter names are a little hard to understand, so that's why the description is useful. Other times if your method is public then other people will be able to call this method, and they might not know what are the instructions inside this method. So reading this java doc and the description of the parameters is really useful to them. I mentioned earlier that a method is like a template. So, what if we want to change the city so that it's not always San Francisco? I can make city be an input parameter. So I can just add a comma here. And since city name is text I'm going to make it a string data type. Then I can delete San Francisco and replace it with a variable city name. And remember to add a space before and after here as well. Cool, so now this method can create a message that's customizable to a certain city and temperature. I also remembered to modify the java doc so that it has this extra parameter and description for a city name. Since I changed the method signature, now I have an error up here. The method no longer works with just one argument. I need to pass in two arguments. So I add a comma and then pass in San Francisco string. Now the error goes away. So when I call createWeatherMessage(77, it's going to be value of temperature, and San Francisco will be the value of city name. And it will create the proper string here. Now we're going to go back to the calculate price method, and we're going to modify the method signature so that it has a different number of input parameters. We're going to define it with zero input parameters, one input parameter, and lastly, try it with two input parameters. You'll see how changing the method signature here to have a different number of input parameters with affect the way that the method is called. Normally when you're building your app, you will just define it one way with a certain number of input parameters. And usually that number of input parameters is going to be determined based off of what's happening inside the method. The best practice is to only pass input parameters that you're actually going to need inside this method. There's no point in passing over more information if you're not going to use it inside here. Here are the instructions for this task. First define the calculate price method in your app in the main activity. See the instrructor notes for a code snippet that you can start with. We're going to modify the calculatePrice method so that it only has one input parameter. Then in the submitOrder method call calculatePrice and pass in quantity as the input. Then try to modify the calculatePrice method to have two input parameters. That way in the submitOrder method you will call calculatePrice quantity and then you can pass in the price which could be $10 for example. And lastly, try changing calculatePrice so that it has zero input parameters. That way in the submitOrder method you would just call calculatePrice like this. Let's do the first one together so you understand what I mean. I'm going to open up the link in the instructor notes. In this gist we provided code for the calculatePrice method. So go ahead and select everything and then copy it. In Android Studio, I'm going to paste in this method. I'm just going to paste it in right below submitOrder, and I'll make sure that there's a blank line in between each method here. That makes it easier to read. Then I can call this method from the submitOrder method. I'm just going to insert the call at the very bottom of the method. Later we're going to integrate it with the code up here. But for now, this is good. Oops, I forgot that we have one input parameter, so I need a pass quantity. Now do the same for the remaining two tasks by modifying the input parameters here. To complete this task, if you need examples to reference, you can always do a Google search for Java methods. We already did one input parameter together. This was the code for the calculatePrice method that was already included in the instructor notes. Now let's do the case of two input parameters. In the submitOrder method, we want to call calculatePrice (quantity, 10). Where 10 represents $10 per cup of coffee. So let's first make this change. In the submitOrder method I'm going to call calculatePrice(quantity, 10). I'm passing in two arguments to this method. There's an error because it doesn't match the method signature here. And I'm about to update that. Inside the parentheses I'm going to add a comma. And then type in int price because we're passing in price as the second input and that's an integer. Immediately it says that there's an error because it doesn't match the method signature here which only has one input parameter. I'm going to change it so that it has a second input parameter. So inside this opening and closing parenthesis, I'm going to add a second parameter. Since this is the price per cup of coffee, I'm going to call it price per cup, and it's a number, so I'm going to say that the data type is int. The name of the parameter type can be anything you want. It should be descriptive to the information that it's holding. Whereas the data type needs to be a specific java data type. So int string and other ones that we haven't learned yet. I also updated the java doc to describe this second imput parameter. When I look inside this method, we're taking quantity and multiplying it by 5 for $5 for a cup of coffee. But now the price per cup has changed to a variable. So let's use price per cup instead of hard coding to value 5. Now the total price of the order is going to be quantity times price per cup. If you think back to the template analogy that I was talking about earlier, now quantity and price per cup are swappable for different values because their input parameters. You could call calculate price with a different quantity and a different price per cup and this computation would still work. Now let's do the case of zero input parameters. In the submit order method, we should call calculate price with empty parenthesis. In the submit order method, when I call calculate price, I'm going to remove the arguments. Now we don't pass any inputs into this method. There's a red underline immediately because there's a mismatch with the methods signature, so I'm going to go ahead and erase all these input parameters. This is also complaining about an error because these parameters don't exist so I can go ahead and delete this. Now we get an error saying that it can't resolve the symbol price per cup. It's no longer an input variable, so we need to switch back to the hard coded price value which is $5 or you could pick any other price. The computer doesn't complain about quantity because it's actually a global variable, and you can reference this quantity variable from any method in the main activity. Sorry. I should have picked a name other than quantity for the input parameter. But you get the idea, without any input parameters, you could only refer to global variables. You can use hard-coded values or if you create local variables here, you can refer to those. We just finished calling a method and passing in inputs. Oh wait. Are you referring to passing in quality to what was it, the calculate price method? Exactly. And now we want to get a return value out of it. I love return values. [LAUGH] What is it going to be? I think a price? Because it's the calculate price method. Yeah the total order price is going to be the return value. Okay, let's do that! Okay. Do you need a fork? Do I? In Java, the output of a method is known as a return value. In code samples, you may have seen the word return inside the method, or seen the word return In the comment above it. Let's look up more information about the return values for methods. I'm going to do a Google search for Java method return value. The first link looks good. This article talks about returning a value from a method. It says that a method is finished being executed when we've completed all statements in the method or all lines in the method. Or when we've reached the first return statement, whichever one comes first. A method will also end if we've thrown an exception or an error, but we're not going to cover that in this course. We're mostly going to focus on the first two cases. So in the code, you might see something like return semicolon. That means the method should end and any line of code that comes after this won't be executed. Alternatively you might see something like this. Return and then a value, semi-colon. This is returning an output value from the method. Here's an example. This is code for the getArea method. It's supposed to compute the area of a rectangle, which is defined as width times height. So inside the method we have the word return followed by the return value. The return value is the variable width times the variable height. And this equals a single number. And that number is returned as the output value for this method. Unlike input parameters, where you can has any many input parameters listed inbetween the opening the closing parentheses, you can only have a single return value. And the data type of that return value is specified here. So we could have returned any other number, as long as it's an integer. For example, you can't return a string, because that doesn't match the entered data type. You're probably realizing by now that Java has a special meaning for the word return. You can't use it for the name of variables or methods. These are called Java key words. I can search for the Java keywords list. This is the list of all the Java keywords. You'll notice that some of the words we've already seen before, like int, public, and private. It's a pretty short list. And all these words have a special meaning in Java when you put them in your code. So that means you can't use them for identifiers, like variable names, or method names in your app. And you'll also notice that return is a special Java keyword. This is reserved for when you want to return an output value from a method. Going back to our earlier example of creating a weather message. We can create a string and then return it by saying return message. The data type of this variable is string. What would happen if I added a line of code after this return statement? Well then I would get an error that says unreachable statement. Because the computer won't get to these lines of code after the return statement. because it would have ended the method at this point. So delete any lines of code that come after your return statement. What if you don't need your method to return any output value? Well let's look at a couple of examples in the MainActivity of the JustJava app App. The increment and decrement methods are examples where there is no return value. When you call the decrement method, it does all of its hard work in updating the UI in the displayQuantity method. There's no output value to return. And same with the increment method, all the hard work is done when you call displayQuantity and it updates the screen. You might be wondering where the return statement is, then. Well, the method will finish executing when all the lines of code have been completed, or when it hits the return statement. So, I could've added return; like this. That way, the method would finish as soon as it hits this line. This gives me a warning in Android Studio. It says, return is unnecessary at the last statement in Avoid method. Since I'm not returning anything, I can just delete this line here. This is less lines of code and its easier to read, so I prefer it like this. To indicate that there is no return value, It's important in the method signature to say that the return data type is void. Void just means that there's no return value. Java has a special way of representing this, so that's why this is a Java keyword. Let's look back at our Java keyword list and, indeed, we see that void is in this list. So, if you don't have a return value, make sure you don't just leave it blank like this. because otherwise there's a java syntax error. Just type void with a lower case V. Go ahead and read this article on your own now. You can skim it for the information you do understand, or Google search for more information online. Once you've learned a couple of things from this article, you can move on to the task. And then check your notes. You'll find the link to some code for four different methods. Each method contains an error. And the task is for you to find the error in each of these methods. Since there's multiple ways to fix the code, assume that the javadoc comment at the top of each method is correct. And we want to make the code match that. This is what the methods look like. Identify the line number that the error is on. The line number is located in the left-hand column here. Then write a short description on why that line has an error. So line number goes here, and description goes here. When you're done, you can continue to the solution video. The first method is about getting the email account name. The method should return a string, which is the name of the account. So far, the method signature looks good. We have the access modifier, the return data type, and the method name, and no input params. You have a opening and closing brace as well. The first line of code looks correct. It returns a string in quotes, and then it has a semicolon. So, this is the return value. However, the problem comes on a second line when we see another return statement with another return value. We learned earlier that you can't have lines of code after the return statement because those will be considered unreachable by the computer. So in this case, this method has an error on line 8. Okay, so let's do Method 2 now. The second method is about adding $4 of tip onto the current bill. The current bill is an input parameter, and the data type is integer. The return value of the method should be the total price of the bill with that $4 of tip included. So let's check the method signature first. We have a access modifier. We're missing our return data type, so that's weird. And then we have the method name and one input parameter. So the return data type is a red flag, but let's keep reading. Inside the method it says return bill +4 and semicolon. So this is the return value. Bill is a variable and we add four to it, so this evaluates to a single value. And then that is an integer which should get returned. So we're missing the word int right here. And this is on line 6. So in the table we say that Method 2 has an error on line 6 and we're supposed to specify the return data type of int. Let's look at the third method. This method is about setting up the app for our current city. We don't have the code for the other app. But let's just look at the code for this one method. The method signature starts with private access modifier. And then it says nothing, which is weird because we haven't seen that before. And then the method name is called setup. There's no input parameters and we have an open and closing brace. Inside the method we see that there is a variable, it looks like a global variable city name and it's being set to the string London. Okay, well, from everything that I've observed there's basically no return data type specified in the comment here. It looks like we're trying to return nothing as the output, so remember that the Java keyword for returning nothing is the word void. So I think the error is on line 4 here when we need to say void. Okay so I added that to the table. Now let's move on to Method 4. This method is about getting the number of students in a class. The return value is the number of students which is an integer. The method starts with an axis modifier of private. And then the return data type is an int so, so far it's looking good. The method name is getStudentClassSize and there's no input params. Inside the method, we have the return keyword and then it says 20 in quotations, but this is weird because this is a string and we want it to return an integer. So the error is on line 7, where we have to return 20 without quotations. And this is what your table should look like. Let's go back to the calculate price method. Once we call this method it's going to return the total order price. And we can store this value inside this variable called price. Then we can display it on the screen. To integrate the calculate price method into our app we're going to need to use return values. Let's look at the pseudocode first. Within the submitOrder method we want to call the calculatePrice method. It's going to compute the total price of the order. And it's going to return that as the output. So we're going to store that output into a integer variable called price. Then we're going to take that price, and then display it on the screen. Let's look at the actual Java code for that. In the submitOrder method, we would add this line of code. Do you remember the assignment operator from lesson 2? Whenever I see this, I evaluate the right hand side first. The calculatePrice method returns a single value which is the order price. And that should get stored inside this local variable called price. Then we can call another method, displayPrice. And the input to that method is going to be the price variable that we just created. This is the first time we're seeing how a method can be used as part of an expression. For example, we can call this method, and the value that gets returned from that can be added to other numbers or, if it was a string, we can concatenate it to other strings. All that matters is that the whole thing on the right hand side gets evaluated to a single value and then gets stored on the left hand side variable. But for the Just Java app we're just going to use calculate price directly and show that on screen. For this coding task you'll be making sure that the calculate price method is getting defined and called properly in the Just Java app. First focus on how the method is defined. Modify the calculatePrice method to have the correct return data type in the method signature. Also assume that there's 0 input parameters. The next step is to modify the inside of that method. Make sure that it's returning the correct price of the total order, which is the quantity of cups ordered times the price per cup. You can assume that each cup of coffee costs $5 and you can just hardcode that directly into this method. Once that is all done, then you can move on to how the method is getting called. Call calculatePrice from the submitOrder method, and you can use the code that we talked about earlier. Then, go ahead and display this price on the screen. Now, you could use the displayPrice method, but you did a lot of work at the end of Lesson Two to show some text on the screen as well. It also said, thank you, so if you could try to integrate this price value with that text, that would be most ideal. It should look something like this. So if you change the quantity and then hit order, then the price shows up here along with the text. When you're done, check these boxes to continue. First we're going to modify the calculatePrice method signature to have the correct return data type. We're also going to assume that there's 0 input parameters. This is where the calculatePrice method is defined. The purpose of this method is to calculate the total price of the order and then return that. The price should be an integer so we should change the return data type from void to int. That takes care of the first task. The quiz also said to make sure that there's no input parameters, and that's what we have here. Now the second task is to modify the inside of the method to make sure that we're computing the correct price for the order. And assuming $5.00 for a cup of coffee. Inside this method we're taking the quantity of cups ordered. And we're multiplying it by $5 per cup of coffee. This equals the total order price. So this line of code is cracked. But there's two issues that I see, the variable price is never used and there's an error that says missing return statement. It's expecting us to return an integer, but we're not returning anything. Right now our code is the same as if we just said this. We need a line that says return and then actually put a value here and the value on return is a price. So, I'm just going to put price, which is a variable we defined up here. Cool, so now all the errors go away. We should also modify the Java DOC. So that we specify that we're turning the total price. That way when someone's calling this method, they know what to expect. Okay, so now we finished all the parts for defining this method. Now, let's move on to where the method is getting called. Within the submitOrder method, we should call the calculatePrice method. Currently calculate price, is floating in the middle of nowhere. I'm going to copy it, and I'm going to paste it up here. Because before we would calculate the price of the order in line, in the submit order method, but now we have a method for it. So I'm going to paste this here. Now get rid of the extra semicolon. You'll notice that price is a local variable in this method, and also in this method. It's okay if they have the same name, because these are different variable scopes. So the price variable here is totally unrelated with the variable here. They're updated and created independently from each other. And once this method finishes executing, this price variable is gone. Okay back to our submitOrder method. So we calculated a price and stored it in a variable, and then we can use it to create the price message. So, actually, all of this code can stay the same. We're concatenating the integer, price, to the string total with the currency symbol. Then we concatenate "Thank you!" and then just display it on the screen. So I'm going to erase these extra, blank lines, and save it, and then we can run it on our device. Okay, so I changed the quantity, and hit ORDER, then it correctly shows $25 as the price. Awesome, it worked. But how can I be sure that calculatePrice is actually working because there's no user visible change compared to our app from before. Here are a couple of techniques that you can do to verify that your code is actually running. I could have it return a really crazy number, like 700. Save my code and then run it. Now what I expect to see is if I change the quantity and hit the ORDER button, it should saw that the price is $700. That way I'll know that this calculate price method is actually getting called. And it does, cool. Now I can revert this change. Another way to check that this method is getting executed is to add a break point here. So I'm going to click on this little bug icon and then our apple enter debug mode. If I change the quantity and I hit order, then I expect that the app will pause at this point. And it does. So now we're in the calculate price method. There is a global variable, quantity. And if I step over to the next line then I see that there's now a local variable, price And it's set to be $15 because quantity is 3, 3 times 5 is 15, cool. So, it's going through the calculated price method, and if I hit Resume, then it updates properly on this screen. Guess what time it is. Time for more cake. No. It's time for the students to define and call their own method. Wait, were asking them to define and call a brand new method. What's it called? It's called create order summary. It's going to take a summary of everything they entered into the app and then output that as text. Do you think they're ready? I think so. I think it's time for our little birds to spread their wings and fly. [SOUND]. Now we're going to change the app so it looks like this. If I change the quantity and then hit the order button, then it prints out a longer summary of the order. This is what will happen in the main activity at a high level. When we click on the Order button in the app, we'll call this method, and then inside of this, we're going to call the calculatePrice method. We're going to call the method with no input parameters, we're going to execute these instructions here, and then we're going to return the price. Once we have the price in the submitOrder method, we're going to be able to call the createOrderSummary with that price. So we pass in a price to this method and then we execute the instructions inside of it. And then we're going to return the summary text. And then in these lines of code we can display that summary onto the screen. To implement that in code, we're going to create the Order Summary Method. This is a screenshot of what the final app should look like. It's the same as what I showed you earlier. The first task is to create this as a new method in the MainActivity. The method will be called createOrderSummary. It's going to take as input the price of the order, which is going to be a number. Then it's going to return this message. Feel free to use your own name, or any other name. And make sure that quantity and total are accurate based on what user selected in the quantity picker. Then just add thank you. The second step is to then call this new method from the submitOrder method. Once you get this string back in the submitOrder method, then go ahead and display it on the screen like this. Check these boxes when you're done. Let's do the first step together, of adding a new method to the MainActivity. You can pick anywhere in the file to add your method, as long as it's outside of the braces of a different method. I'm just going to add it right below the other method we defined, which was calculatePrice. I'm going to say private for the access modifier, because the only things that need to access this method are within the main activity. Then I'm going to say, string for the return type, because the createOrderSummary method should return a string. And then the name of the method is createOrderSummary. And then it should take as input a price, which is a number. Okay so we got the method signature done, but now we have to implement the method so that it returns this message. The message starts with the name, a quantity, a total and then, thank you. So, I'm going to go ahead and copy this and then, I'm going to paste it in the createOrderSummary method. Now, we can start with some base code. The difference though is now, the order summary should start with a name, not with the total price. So, I'm going to move this to the next line and save it for later. I'm going to initialize the price message variable to Name, and then Kaptain Kunal. And then, on the next line, I'm going to update the price message. I'm going to append to the existing message, so I'll say price message, plus, and then the new text, and I want to add quantity and then add the quantity variable. Since quantity is a global variable, we should be able to access it within this method. Okay, so now we have name and quantity. On the next line I'm going to update the priceMessage again and add some more text. Actually this text is supposed to be the total price, so I can just use what we had before. Okay, and then on the last line we update the priceMessage again. Take the existing value of that string and then add, Thank you!, to it. This all looks good, but there's still an error here. And it says missing return statement. Since we're supposed to be returning a summary string, then I need to add another line of code that says, return. And then the return value. In this case the return value is priceMessage. And I add a semicolon at the end too. Okay, now the error's gone. It looks like our code is good, so I'm going to run it and test it. Okay, so now if I change the quantity to three, and I hit the order button, it doesn't work. Let's see what's wrong. Looking at the code more closely, I see what the problem is. There's a warning here that says that the private method createOrderSummary is never used. I forgot to call it. Let's go back to the quiz slide. Okay, so we did the first task successfully but now I have to call the createOrderSummary method from the submitOrder method. Going back to Android Studio, I need to fix the submitOrder method. I've calculated the price, which is correct. But now I have to pass it into the createOrderSummary method. So I'm going to do that right here createOrderSummary with the price variable. The return value of this method is going to get stored in the priceMessage variable. I don't need this line of code anymore because "Thank you" is already in the text down here. So I can delete that. And then to update the screen all I have to do is call displayMessage with the priceMessage variable like before. And now let's try to run the app again. If I change the quantity to three and I hit the order button, it's still not working. Most of the text is on one line when it should be on multiple lines, so let's go back and fix our code. Looking at this code I realize that I forgot the new line character. I added it properly for Thank you but not for the others. So I'm going to add it to the other lines now. Okay, let's try to run it again. And it works. Awesome. Now Kaptain Kunal can have his three cups of coffee. I want to show you some other optimizations you can do to your code. Notice that you could have called the calculatePrice method within the createOrderSummary method instead of passing it in as an input parameter. So you could have done calculatePrice right here. That would have worked as well. But I wanted to show you that you can take the output of one method and pass it as input to another method. So we'll leave it as we had it before. Within the createOrderSummary method, the other thing I would have done is use the += operator. This is shorthand, and it means the same thing as priceMessage = priceMessage + all of this. So if I change all of this to be +=, it will be the same as what I had before. This just requires less typing so your code is more concise. In the calculatePrice method, the other thing I would've done is just return the value immediately instead of storing it in a local variable and then returning it. This also leads to more concise code. And then up here, in the submitOrder method, instead of creating the order summary and storing it in a variable and then using it right after, I could have just called createOrderSummary and then call displayMessage on that. This leads to the same thing. The return value of the createOrderSummary method is a string, and that will get passed as an input argument to the displayMessage method. You can leave it like this if you want, if it's easier to read. All of these tips and tricks lead to the same logic anyways. And before I forget, also remember to add a Javadoc comment at the top of this method to describe what it's supposed to be doing. Technically you don't need a Javadoc comment for a private method, but it's just good practice to write a description of a method so that other people who are reading your code will also understand what you're trying to do. The description of this method is that it creates a summary of the order. The input parameter as the price of the order, and it returns the text summary. All right, we just learned a lot about methods. Now it's the time for you to take a break. You can do some jumping jacks, you can go take a walk outside, you can even go to a new browser tab. When you're ready, you can come back here and then we're going to look into the display message method, one of my favorite methods. In the next coding task, you're going to modify the app so that instead of saying price here, it's going to say order summary. This is a better name because if you change the quantity and then hit order, then the summary does show up here, it's more than just the price. This is a small UI change, but in the process, you're going to be modifying the display message method, which we gave you in Lesson 2 without explaining what it really does. In the coming videos, we'll start to understand more about all the different parts that are going on inside this method. You'll begin by experimenting with changing some of these values and seeing what happens. When you make the change it will cause an error in the displayPrice method, so you can actually delete this method now. You even get a warning now that says that this method is never used. So, go ahead and delete it. The overall goal is to change the price section to be called the order summary section. There's a couple of additional changes we'll be making along the way. In the activity_main layout file, go ahead and change the price header to say, ORDER SUMMARY. Then find the TextView for the price value, not the header, but the actual value. Change that view to have an ID of this. The view ID used to be something like price_text_view, but now that we've changed it into an order summary section, we're going to update the ID as well. Then, in the main activity file in the displayMessage method, go ahead and change the variable name from priceTextView to orderSummaryTextView. And lastly, go ahead and change the reference to R.id.price_text_view to R.id.order_summary_text_view, with the underscores here. When you're done check these boxes. Then take a moment to step back and make any observation about what's happening in the displayMessage method. Do you have any guesses about what's going on or what the connect is between xml layout and the Java file? Let's start with the first step which is to change the price header to say order summary. First I open up the activity_main layout file, and then I go and find the view that controls the price header. And I put my cursor here, then I see that this view gets correctly highlighted. So now I can go ahead and modify this string here. I'm going to erase this and type in Order Summary. It correctly updates in the preview window. Notice that I spelled it with a capital O and a capital S instead of in all caps. If we ever decide to change our UI and set all caps to be false, then my text will still be fine. So I prefer typing Order Summary like this and then using the attribute textAllCaps = true. Okay, so the first item's done. The second task is to find the price value TextView and change it to have an ID of this. If I move down to the next TextView after the order summary header then this is the price value TextView, and it's highlighted here too. As requested, I'm going to change the ID to say order_summary_text_view. Cool, so those are all the XML changes in the layout. Let me run the app to make sure that it still works. Actually, it doesn't work. I get an error saying that it can't find the symbol price_text_view in the Java file. Looks like we need to go to the next steps before we can get our app to compile. In the Main Activity display message method, we are supposed to change the variable name from priceTextView to orderSummaryTextView. Within the main activity file in the display message method, I find the priceTextView here. I'm going to delete this and then type in orderSummaryTextView. It's going to be in camelCase and start with a lower case o because it's a variable name. Immediately I get a warning that says the variable is never used. So I'm going to copy it, and I'm actually going to use it on the next line here because there's an error saying priceTextView is unresolved. And then delete this, and then use the new variable name here. Cool, and that makes the error go away. But I still have another error here, and I think it's related to the last task. The last item here says to change R.id.price_text_view to R.id.order_summary_text_view. I'm going to double click on this error in red, and I'm going to delete it and type in order_summary_text_view. There, and now the error goes away. And now the app works without any errors. The initial layout is correct. Instead of saying price, it now says order summary, and if I change the quantity and hit order, then the summary shows up here. Let's talk about any observations that you may have made. Remember there's no right or wrong answers. First you may have noticed that for the price TextView, when we gave it an ID of order_summary_text_view, the similar format appeared again later in the Java code when we were modifying the displayMessage method. You also may have noticed that by changing price to order summary it seemed to have a bunch of ripple affects on other parts of the code. Now some of these changes are required in order for the app to run again, but other changes were more nice to have just for convention so that we didn't have any old, lingering references to price. In looking more closely at the displayMessage method, you may have noticed that there's only one input parameter, string message. And there's no return value. That's why we don't have a line in this method that says return something. You also may recognize the word TextView which we saw in the XML in order to add a text view to our layout. It's spelled exactly the same way as here. Also, this line of code here looks like the assignment of a variable, where we have the variable data type, the variable name, and then, having an initial value here. This is similar to how we declare integers and strings. And if you were looking really closely you may have thought that this looks like a method call, findViewById followed by an opening parentheses, some stuff in the middle, and then a closing parentheses. Similarly with setText here, there's an opening parenthesis, something in the middle, and then a closing parenthesis. So this may also be a method call. In the upcoming videos, we're going to take a look more closely at what exactly is happening in these lines of code and start to understand what they actually mean. In the last quiz I asked you to modify a bunch of things in your app. You may not have understood what you were doing, but that's okay. We're going to talk about it now. Specifically, we're going to talk about resources in your app. Resources live under the res directory of your app. Res is short for resources. On the other hand, java files live in the java folder. And we have MainActivity.java located inside this folder. An Android app is mainly made of resources and java code. The java code consists of files like MainActivity.java. Altogether it handles what should happen when the app is running like responding to button clicks or other events. Then you have resources that live in the res directory of your app. This includes images, text strings, colors, dimensions, like for width and height, xml files like for menus and layouts, as well as raw media files like for audio or video. One of the major advantages to separating out the java code and the resources is that we can provide alternative resources to make the app look better on certain devices. So if we want a different layout on larger screen devices, we can provide that by just swapping it out. Or, if we want to translate these strings into another language, then it makes it easier to swap out the strings in just the centralized location instead of having it scattered all over the code files. Now that you know what Android resources are, and that you can put them in different folders. Let's talk about how you can actually access the resources that you saved in those folders. When your app is compiled, there's a tool in Android called AAPT. And that generates the R class. This is simply an R.Java file, and I'll show you an example next. It contains the resource IDs for all the resources in your S directory, so for all the resources that you've added, there's an ID to refer to it. The ID is in a format that is based on the resource type, so for all Java resources which are graphics it would follow the format of R.drawable. For all strings that are resources, it would follow the formula R.string.resource name which is hello in this case. Note there are two ways that you can access a resource. In Java code it follows the format of R.resource type.resource name In XML though, it follows the at notation, so it would be at and then the resource type would be string slash, and then the resource name, which is hello. Here are more examples of different resource types and how to access them. These are just a couple of the common resource types, but there are many others. You always start with R, a dot, and then resource type, a dot, and then the resource name. And the name is whatever you assign it. And then in XML you have @ and then the resource type, slash, and then the name of the resource. Let's take a moment to find all the resource IDs in our main activity Java file. I'm going to open up the find command in Android Studio. I'm going to use Cmd+F, or you can use Ctrl+F if you're on Windows. It pops up a search field here. I'm going to search for capital R dot, and then click on match case, so that it only grabs the capital R cases. The first thing it finds is this r.layout.activity_main reference. This is interesting because we're referring to the activity main layout file. This is actually how the main activity knows to load up this XML file. Isn't that cool? Let's look at the next reference. Okay. In the displayQuantity method, we have a reference to R.id.quantity_text_view. So this is referring to a ViewId. Specifically, the TextView that displays the quantity. Hopefully some of the puzzle pieces are coming together. By referring to this view in the Java code. We can update it while the app is running to show this numberOfCoffees. Let's go to the next occurance. OK in the displayMessage method we see a reference to R.id.order_summary_text_view. Here it seems like we're trying to refer to this text view which displays the order summary, so that we can update it with this message. Now we know that we can refer to XML resources in the Java code. But what exactly is the relationship between the resources and the Java code? How do they come together as part of a full app experience? Let's start at the point when you click on the JustJava app icon. It opens up the Main Activity. Now you don't see anything yet because it's still being initialized. Thankfully, a lot of the complexity involved in initializing the activity is handled automatically for you by Android. The important part that we care about is that in the Main Activity file, the onCreate method gets called automatically. This is when the activity is getting created. There's a bunch of work and then we have an important line that says setContentView and then the resource ID for the layout file. It's R.layout.activity_main. This means that the content view of the activity should be set to the layout as specified in the activity main XML file. This is the method call and the input parameter is this resource ID. Once you set the lay out that you're going to use for the content view, then the android device can go ahead and start parsing this XML layout file. Parsing is like reading this file and trying to interpret that like oh this is a linear layout. Oh this is a text view. These are the attributes, and so on. So it's trying to understand what this file contains. The Android device starts by reading at the top of the file. It recognizes that there's a linear layout here. Then it inflates a Java object to represent that linear layout. Then it goes to the next line and sees that we need to add a TextView as a child to that linear layout, like that. This is starting to look like the view hierarchy from lesson two. What I didn't tell you earlier is that this is actually a hierarchy of Java objects. We're going to be learning more about Java objects in the coming videos so it's okay if you don't fully understand it yet. When we get to the next line we see that we need to inflate a linear layout Java object. That gets added as a child to this root LinearLayout. Then we see a Button element. So we add that as a child to the LinearLayout. So we continue down the file until we've inflated all the views that we need for our view hierarchy. Once we have this view hierarchy of Java objects, then we can manipulate them and change them while the app is running. An object like the TextView here contains state information. Like the text, the text color, the text size. The object also has methods so we can call those methods and change their internal state. So for example, we can change the text while the app is running. Interacting with all these objects is called object oriented programming. We will cover this in more detail in the coming videos. So to summarize, in the main activity when we call setContentView to this layout, then we read this layout and then inflate a bunch of Java objects. These Java objects make up the view hierarchy of the app. The MainActivity holds on to this view hierarchy, and then as you interact with the MainActivity, it can update these objects. Do you remember the boxes? What boxes? These boxes. Huh! You do remember them? Oh yeah, yeah. I do remember them. They're variables, where you can put the value inside. Yeah, and you can combine multiple of these variable to create a larger Java object. Oh, so you can take two or more variable and make into a something bigger. Exactly. Okay [SOUND] Like a TextView. Yeah. So, we can have an integer variable. This is for the font size. Exactly. Okay. [SOUND] And then you can also have a string variable. And the string variable for the actual text itself. Yeah, and those can go inside the TextView as the state of the TextView. And then we can interact with those things using different methods that we're going to play with next. Exactly. Okay. Let's do that. As we mentioned earlier, showing a TextView on the screen like this is actually controlled by a Java object within the app. This is an example of a TextView Java object. It's like a box, and inside of it, it holds state. The state is made up of a bunch of fields. A field is a variable, like in lesson two, when we learned about global variables. We can have a text field to store the today string, which is going to be the text that's ultimately displayed on the screen. We can also have an integer field to store the font size of this text. There's also a bunch of other fields, like text color, font family that make up the state of the TextView. I just didn't draw them in this picture. To interact with this Java object and change it while the app is running, we can call methods on the TextView. We learned about methods earlier in lesson three. Some example methods on a TextView are setText and getText. You can also have methods like setTextSize or getTextSize, and so on. Each of these methods just executes a list of instructions. You can have more complex methods like onDraw, which handles drawing a TextView onto the screen. So overall, this TextView object holds state information on what this TextView contains, and you can call methods to interact with this TextView, such as to modify the state, or to do more complex actions. To show an ImageView on the screen, we actually have a Java object for ImageView inside of the app. This particular ImageView contains state information, like which image should be shown, as well as the scale type, like center crop. Again there's a bunch of other fields that make up the state of an ImageView, I just didn't draw them here. There's methods like setImage, setScaleType, and even more complex methods, like onDraw, to handle drawing this ImageView onto the screen. Note that, as developers, we don't explicitly have to call onDraw to tell it to draw onto the screen. Android handles calling this automatically for us, but it is useful to be able to call these methods to change the ImageView, for example. So how do we know what all the fields are inside the state of an ImageView, and what all the methods are of this ImageView? To answer that question we have to look at the class definition for that object. It's a file called TextView.java, similar to how we defined MainActivity.java. Inside this class TextView file, we have a bunch of code that talks about the state of the TextView as well as the methods. Now it doesn't say state and methods exactly, but it just contains information on the state and it contains information on the methods. You can thank of this as defining the rules of how a TextView behaves. This object instance can hold specific information like the text string today. Or the text size 18. You can also use this class to create even more TextView object instances, and these could have a different text string value. I think this one could hold text that says hello, and this one could hold text that says goodbye. They could have different font sizes, different text colors, etc. However, they're all based off of the class template. You may find it hard to distinguish between a class and an object instance, but that's okay. It takes some time to get used to. Here's an analogy to help you. You can think of it as creating a floor plan for a house. You can use this floor plan to create the actual homes. Each of these homes can be slightly different. But they're all based off of this base floor plan. It's important to note that the floor plan is not a house itself. It's just the plan. Similarly, the TextView class is used to create these object instances. So these instances are the ones with the actual text values, text color values, and text sizes. So what does one of these classes look like? We've created a simplified version of the TextView class which would be saved in the TextView.java file. We simplified it so it would be easier for you to understand what a class would look like. First, it starts with an access modifier. It's marked as public so that other things like inactivity can use this TextView class. Then we have the word class. This indicates to java that this is a class definition. Then we have the name in a class. The name of a class in Java starts with a capital letter and it's in camel case. So there's no spaces and it capitalizes subsequent words. There's some other text here but we'll look into that later. The important thing is we have an opening brace and then at the bottom of the definition we have a closing brace. Now inside this TextView class we have a bunch of variables here. Each of these represent a field in a TextView, so we have a field for the text of the TextView and a field for the text color of the TextView. There are other fields as well, but remember, this is a simplified version of the TextView class. You also have a variable to store a reference to the context of the application. You can read more about context in the instructor notes below, but it's basically a way to access information about the app, like for example you can access resources in the app using the context. And these are the methods of the TextView. The setText method takes as input a text string. Then it updates the global variable mText to use this new value. Similarly the setTextColor takes as input a new color and it updates the internal state to have this new color value. There's also methods like getText and getTextColor, which return the internal text string, or the internal text color. One more thing, you may have noticed that these global variables here all start with the lower case m. M stands for member variable, and these are all member variables of this TextView class. Member variable is just another way to say field or the state of the TextView class. Here's a simplified ImageView class. You would find it in the ImageView.java file. It starts with public class and then ImageView is the name of the class. And then we have opening and closing braces. This makes up the state of the ImageView. Normally it would have more fields than this, but I just want to show you an example. This is an integer variable and it's called mImageId, m for member variable. This stores the resource id for the image that should be shown in this ImageView. Down here, we have the constructor which is used to construct a new ImageView object. And it takes this input of Context. And then it initializes these variables. Then we have a method. It's called setImage and it takes this input, a resource ID, for the new image that should be shown in this ImageView. Inside this method, we update the internal variable for image ID. Again, we created the simplified TextView and ImageView classes to help you understand the concept of classes. Now let's look at the real version of these classes inside the Android framework. To see the code for the Java classes in Android, you can install this Chrome extension. If you're not using the Chrome browser, you can see the instructor notes below for how to access these files. Okay. Once that Chrome extension is installed, then when I search for, something like TextView Android, and I go look at the reference documentation for this class, then there's going to be this extra link here that says view source. This is really for advanced developers. If you're curious about the code that is used to create this TextView. This is the TextView.java file that was defined by someone on the Android team. As you can see, it's really long and complex. But it still has the main parts of a class. It starts with public class and then TextView, the name of the class, and then this is the opening brace and the closing brace is all the way at the bottom here. At the top of the class, we see a bunch of fields here, and this makes up the state of the class. For example, we see that TextColor is a field, we also see that text is a field. And here's the constructor for TextView that takes this input a context. If I hit Cmd+F, or Ctl+F if you're on Windows, then I can try to search for setText. And here's the setText method. This method is going to set the string value of the TextView. And if I search for GetText and I also see this method returns the text that the TextView is displaying. You get that idea, and you can browse through this on your own if you want. If I search for the ImageView documentation page, then I can click on view source to view all the code for the ImageView class. The file says public calls ImageView, and then these are the fields that make up the state of the ImageView, and then there's a bunch of methods at the bottom of the file. The code in this file is pretty complex as well, and it's also thousands of lines of code. The best part about object oriented programming, though, is that you don't need to know about all these details. As a developer, you can use TextView and ImageView in your app without knowing about all the gory details of what's going on inside of it. In the last video, I briefly mentioned that a constructor is defined within the class, and it's used to actually create the object instances. So, we call the TextView constructor to create this instance, and we call it again to create another instance, and so on. Let's look at the code for how to actually call a constructor. Do you remember how we created a new integer variable named quantity and we set it to have an initial value of two? Creating a new object and storing it inside a variable is going to follow a similar format. It'll look something like this. Instead of the int data type though, we have an object data type. The object data type is whatever we call the class name. In this case, it's TextView. It can be anything as long as it follows the conventions for variable names. So, we just call it priceTextView. Then we set it equal to new object. But we can break down this right hand side further. The right hand side follows the format of new followed by the object data type, which is TextView in this case. This is calling the constructor defined in a TextView class so we have parentheses with the input arguments to the constructor. So, if the constructor requires a context object, then we need to pass a context here. Remember that the context object helps you access application resources and other things about the application environment. So, altogether this is creating a new TextView object by calling the constructor and then it's storing this new object inside a variable called priceTextView. And this variable can only hold a single TextView object as defined by its data type. Here's another example of creating an ImageView object and storing it inside a variable. The data type is ImageView, the variable name is coffeeImageView. And then we have the assignment operator followed by new ImageView. This is spelled the same exact way as the object data type here. Since we're calling the constructor and we have to pass in any inputs, we have parentheses and then we put the inputs in there. Here's a third example that creates a button object and stores it in this variable. The date type is Button, the variable name is submitOrderButton, and then we say, new Button to call the constructor. You can even define your own object data types. Say, for example, I created a class definition for CatView. Then I could use this line to create a new CatView. In this case, the constructor requires an input string for the name of the cat so that's why I put Tiger in parentheses and pass that in to the CatView constructor. To determine what to pass as input to these constructors you have to look at either the class Javadoc file or the class source file. All these cases use the word new to create a new object. If we go back to the Java keyword list, then indeed we do find that the word new is in that list. Sometimes when you're looking at the documentation, it may advise you to use a factory method to create an object. That is instead of a constructor. Here's an example. To create a new MediaPlayer, the documentation advises you to use the method MediaPlayer.create. And this returns a MediaPlayer object that can be stored inside this variable. It follows the format of object data type, the MediaPlayer with a capital m dot and the factory method name, which is create in this case. Then you pass in the input arguments to initialize that media player. Here's another example of how to create a Toast. A toast is a message that pops up temporarily in your app and then disappears. So the code starts with Toast with a capital T because this is the object data type. And then we have a dot and then makeText which is the factory method name. And then we pass the input arguments to create this Toast. To know what the factory method name is and what the input arguments are, you have to check the documentation for the Toast class. In general, in order to know whether you should create an object using a constructor or with a factory method, you can just Google search for how to create that object. Using a constructor is the most common way to create a new object. It's less common that you would need to use a factory method, but to know for sure which one you should use, you can just Google search for how to create that object. Here's a chance to practice with creating objects. In each of these lines of code, there's an error. Figure out what the error is and then write the correct line of code in these boxes below. Let's do the first one, it says TextView = new TextView, and then we pass context in as an input parameter to the constructor. The problem with this line of code is that we're creating a new object but we're not storing it properly in a variable. We're saying that the variable should have data type TextView but we forget to give it a variable name. So the correct code would look something like this. TextView followed by a variable name and then equals new TextView. You can call the variable name something else but we just chose to use textView with a lower case t. So in this case, the error was missing variable name. Let's do the next one. It says, image view img = new ImageView. The problem here is that this is not a valid object data type. Android defines a class called ImageView with a capital I and a capital V and it's squished together into one word. A valid class name can't have any spaces in it. The variable name looks okay, and then creating the new image view looks okay as well. So the only error was that it had an incorrect class name. In the third statement, we're trying to create a new toggle button. It says ToggleButton button = create ToggleButton. We're calling the ToggleButton class here, so we need to use the Java keyword new, not create. And this is the correct code. It says ToggleButton button = new ToggleButton. The problem here was not using the Java keyword new. New is the keyword that indicates that we're trying to create a new object. In the fourth statement, we're trying to create a new toast. You could've Google searched for how to create a new toast and then compared it with this code here. The problem here is that toast needs to be spelled with a capital T, because this is a class name for Toast. This is using a factory method like we talked about earlier. This creates a new toast object and then it gets stored in this variable. So the error here was just an incorrect class name. So now that we know how to create objects, how do we use these objects? Let's go back to the display message method that we were looking at earlier. We were trying to figure out what exactly is going on in here. >From what we've learned so far it looks like there's a TextView object, and the variable name is called orderSummaryTextView. Then it says a bunch of code that we don't really recognize. But on the next line, we use that variable prderSummaryTextView, and we try to set the text on it to be this message. Let's find out more about how to call methods like this on objects. When we call method on object it has to follow this format. First we write the Object Variable Name in this case it's titleTextView then we add a. Then it's followed by the method name, which is setText, in this case. This method is defined exactly this way in the TextView Java class. The method declaration also specifies that there's an input parameter of a string, so we put parentheses and then pass in a string as input. Then, we end the statement with a semicolon. When you write this line of code, it modifies the titleTextView object so that it displays this on the screen. The reason we use the object variable name here, is because there could be multiple TextViews in your app. So make sure you're calling the method on the right object instance. When you're specifying input arguments make sure you're specifying the right arguments in the right order according to the method declaration. So if there's no inputs, you would just have an empty set of parentheses. The way we pass inputs to a method is the same as we learned earlier in lesson three. And remember to separate the object variable name and the method name with this dot. Here's another example, on that same titleTextView object, We're going to call a setTextSize method on it. This method takes an integer as input for the new text size. So in this case, we just pass 18 as the next text size. When the Android device executes this line of code, it's going to change this titleTextView to have a larger font size of 18. In this example, we're calling a method on the TextView object that is called warningTextView. The method is called setTextColor, and it takes as input a new color. Notice that the color is specified as Color.RED. So if we look at the documentation for the color class then, we can scroll down and see that red is defined here. There are a bunch of other colors that you can use here as well. So, when you call a setTextColor, you could call Color.BLUE or Color.BLACK. And lastly, here is an example of calling a method on an ImageView. This ImageView object has a variable name of welcomeImageView, and we call the method setImageResource on it. This method takes as input the new image that we should set on this ImageView. We specify the new image as a resource ID, in the format of R.drawable. And this is the file name, this is just another use case of using resource IDs in Java code. To get the full list of methods that you can call on a TextView object, just open up the TextView Android documentation page. You can get to it by just searching for TextView Android and clicking here. This is a page we already recognize, and we already know about the XML attributes that are listed on this page. If I scroll down further then I can see a list of all the public methods in the text view class. If you want to find something, you can just use Cmd+F, or Ctrl+F if you're on Windows. I'm going to look for the setTextColor method which we used earlier. Here's the setTextColor method and it takes an integer color as an input param. All these methods were declared as public methods in the TextView class. That's why we can call these methods now. If they were declared as private methods, we wouldn't see them show up here. When you're calling these methods, make sure you're checking what input parameters it requires and you're passing in the inputs in the correct order and of the correct data type. When you're looking at code, sometimes you might not see the dot notation when calling methods. The difference matters whether you're inside a class or outside of a class. Let's look at an example within the TextView class. We have the setText method defined, as well as some other method. Say that you want to call the setText method from this other method. You can do so by calling setText and then passing in the input param. But where's the dot and where's the object variable name? Well this line of is actually sort for this.setText("Hello"). This refers to the current object instance and then setText is being called on this object. This is a format we're more familiar with for calling methods on objects. However the this.part is implied and it's optional, o to make our code more concise, we can just call setText("Hello). So notice the difference between calling setTexts within the class and calling setTexts outside of that class. When you think about it, this makes more sense, because it's very clear which TextView you want to set the text on, in case you have multiple TextViews within this class. Here's another difference between bring inside the TextView class, versus being outside of the TextView class. Within the TextView class, you can access private variables and private methods. If you're outside of the TextView class, you can't use methods that are private and you can't access private variables. Within the MainActivity class, you can only access public methods and public variables from the TextView class. In this quiz you're going to practice creating a text view object and then call methods on it. Since this is just for practice, we're going to do this in a new Android app outside of the JustJava app. That way we don't mess up the JustJava app. Open up the project wizard in Android Studio by going to File > New Project. Then you can accept the defaults for all of these. Make sure you have blank activity template selected, then click Finish. Once your project gets created go ahead and run your app on your device. The default behavior should be to see the words Hello World show up here. But now we're going to do something a little different. In the main activity class, we're going to modify the on create method. Instead of calling set content view on this activity main XML layout, we're going to create our own text view and set that here. On the Android Developers site, there’s a Training section where it talks about building your first app. Specifically, I’m looking at the Display the Message part of the tutorial. It tells you that in the activity onCreate method, we can create a TextView. And here's the code we recognize from earlier in this lesson. We're creating a new TextView and we're storing it in a variable called textView. This constructor requires a context as an input parameter. And passing (this) as an input parameter, because (this) refers to the current activity. And an activity is also a context, so this so this will correctly create a TextView object for us. Then we can call methods on this TextView object. Remember that this is a textView variable name, not a TextView class. That's why t is lower-case here. We can call textView.setTextSize and textView.setText as an example. When you scroll down it says to call setContentView and pass in this textView as an input parameter. If you scroll down further it actually shows you a code sample of the onCreate method. We don't need this part. We're just focused on this part where we're creating a textView and then we're setting that as the contentView of the activity layout. Back in Android Studio in the MainActivity class, I'm going to modify the onCreate method. I'm going to insert some blank lines here. First I'm going to create a new TextView object using the constructor. I'm going to give it a variable name of TextView, but feel free to call it something else as long as it's appropriately descriptive of what this is. The text you constructed requires a context, so I'm going to pass in this to refer to this activity. And then on the next line of code, I'm going to call a method on the textView object. As soon as I hit dot, it's going to show me all the possible methods that I could call on this textView object. If I start to type then it will filter down these auto complete options. You can see the options have narrowed. I'm going to choose setText so I can hit enter to use this auto complete. Then I can put in a string as an input argument. And the last step is to change the set content view line. So instead of using this XML layout file I'm going to just paste in textView. I'm going to save this and then run this on the device. What I expect to happen now is that the screen will show a new text view that says Wow on it instead of hello world. And it does. It's a little underwhelming though. So I want you to make it a little more interesting. I want you to call other methods, on this textView object, like try to change the color, or the text size. If you're even more adventurous, you can try calling up other methods on the textView object. Look at the online documentation for textView. In order to figure out what the other possible methods are. When you're done, check these boxes to continue. Earlier I showed you how to create a new textView and then call a method to change the text on it. What if I want to change the text size? I can just call textView.setTextSize and hit Enter. And then just pick a random value like 56. And then I can run it on my device. And this is what it looks like. Wow, that's big. Then I can change the text color as well. I can do textView.settextcolor and then pass in a color. I showed you the possible colors earlier. So let me just pick one like green. When I run this on the device, it shows up in neon green. If you look through the textView documentation, you may have found other methods you can call. For example, you can call textView.setMaxLines. This limits the number of the lines that the text view shows to only two lines. If the text is longer than that, then it just gets cut off. To test this, we'll need a really long string here. And, actually, in order to know whether this is working properly, I should comment this out first. I'm going to run the app to make sure that this string is actually longer than two lines of text. Okay, we verified that it's actually two and a half lines of text. Once I uncomment this line of code to set the max line limit to 2 then when I run the app then it should truncate this to two lines here. And it does, cool. So hopefully you got some good practice in with calling methods on an object like textView. It's actually uncommon to call a setContentView and then pass in a single view like this. Normally the content view of your activity will be a lot more complex. And so that's why we would normally leave it as setContentView and then passing in the resource ID of an XML layout. Let's go back to the JustJava app for just a moment. Let's look at the MainActivity class displayMessage method. Things are starting to make a little more sense in here. We already recognize that we're creating a variable called orderSummaryTextView. The data type of this variable was TextView. We didn't understand this part yet though. On the next line, we call a method on this text view object. We use the same variable name as declared up here. So we call orderSummaryTextView.setText. Then we pass a string as an input to the method. This string message originally came as an input parameter to the display message method. Now let's dig in to this part of the code, which we don't understand yet. It looks like findViewById is a method call, though. Because its preceding these parenthesis with what looks like an input argument. But, what's weird is that this method isn't defined anywhere in this class. If I double-click on this name and then hit command F, or control-F if you're on Windows, then we can try to do a search in this file. I only see two occurrences of findViewById, and they're used in similar ways. But I don't see any method that's called findViewById. Speaking of which, earlier in the main activity class, we see a call to setContentView, but if you search for this in the file, it's also not defined in the main activity. So, where are these methods defined? Well, MainActivity is actually a pretty short file. It's only about 90 lines long, but there's actually more to this class than meets the eye. The code says, extends AppCompatActivity. This means that the main activity is an extension of the functionality in the AppCompatActivity class. On your computer if you see action bar activity here, that's okay, that's just an older version of this. The latest version that you should be using is AppCompatActivity. And AppCompatActivity gives us backward compatibility support on older Android devices. The AppCompatActivity is part of the Android support library. It allows us to use the latest UI features on Android, while still working on older Android devices. By extending the AppCompatActivity class, we're getting all the functionality, all the state and the methods from here within the MainActivity for free. We don't have to copy and paste any code from here. We can just simply extend that class. If you're interested, you can find out more information on AppCompatActivity by googling for it. Here's the reference doc for the AppCompatActivity class. Since I have the Chrome extension installed, I can view the source as well. And this is the code for where the AppCompatActivity class is defined. You can see that there's a lot of functionality here, but the key message is that you don't have to understand how it's implemented. All you need to know is that when you extend AppCompatActivity, you get all of this functionality for free. At a high level you can visualize it like this. This is a class definition for MainActivity. And say you have some methods defined here. When you extend AppCompatActivity then we can access the state and then the methods from AppCompatActivity. Now, they're not physically added to the main activity class, but you can imagine that they're there, because you can still reference the state and the methods as well. And that's how our code can refer to things like setContentView or findViewById. Because we inherited those methods, we didn't define them in the MainActivity. The MainActivity is shown as a screen on the device, but we didn't write the code for that in the MainActivity, we inherited that as well. We don't have the state and the methods from AppCompatActivity directly in the class, but now we know that they're there and we can refer to them. Speaking of inheriting things, there's good and bad parts about that. Sometimes we'll want to inherit behavior but other times we might want to modify it slightly. If you want to change some of the behavior from this inherited class, you can override certain methods. You can add this @override text on top of a method so that the computer knows that you don't want the version of the method from the AppCompatActivity. But instead, you want this version that you've defined here. This is a tricky topic, and it requires a lot of practice. But we have seen one example of overriding a method from the AppCompatActivity class. And that method is the on create method. By overriding the on create method in the MainActivity, we're specifying our own implementation for what should happen when that method is called. Don't worry if you don't understand this right away. I'm just giving you a brief overview of a bunch of object-oriented programming concepts. It's absolutely expected that you would still have lingering questions. And still need to read up more these topics in order to fully understands them. Another way to visualize the relationship between the MainActivity and the AppCompatActivity classes is to draw a Class Hierarchy Diagram. This is different from a View Hierarchy Diagram, because the View Hierarchy Diagram shows a tree of views that are shown on a screen. The Class Hierarchy Diagram shows the relationship between different Java classes. We have AppCompatActivity as superclass. Since MainActivity extends from AppCompatActivity, then this is known as the subclass. So whenever you see this class definition whatever you extend is known as the superclass. This would be the subclass. So if you created another activity called detail activity and you extended AppCompatActivity, this would be the subclass, and this would be the superclass. Here's another example of Java class inheritance. If you think about it, the text view, image view, and button views all have some common aspects to them. All of these views have a width and a height on the screen. We haven't learned this yet, but they also have a visibility state. So they can all be made invisible or visible. There are a couple of other properties as well, that are common among them. Instead of writing out code for these properties within the text view class, and then copying it over to image view, and then button class. We can do something a little smarter. We can create a view class. We can extract the common properties among all of these views and then put them inside this view class that way the code only has to be written once. But then how do we make the connection between the text view class and the view class? If you're thinking inheritance, you're correct. In the TextView java file we're going to define the text view class. That way we'll inherit all this data and the methods from the view class. Then we won't have to have as much code in the TextView class because part of the functionality is already written in the view class. The same would apply for the ImageView and Button classes, we don't have to write as much code. In these files, we only have to write about what's different about the ImageView compared to the View class. I think of this as specifying a delta, so the ImageView class only has to specify what's different about the ImageView compared to the View class. If we don't want to inherit certain behavior from the View class, we can just specify the updated behavior within the ImageView class, or any of these classes. To remind you of the terminology, in this case, TextView would be the subclass, and View would be the superclass. If we go back to the documentation for the TextView class, we actually understand this part now. It says TextView extends view. Now we know that it means that we're inheriting the state and the methods from the ViewClass. And down here is a class hierarchy diagram. It shows that the TextView class is inheriting from the ViewClass. And in turn, the View class inherits from the Object class. If you explore around, you can find other classes, like the EditText class, which actually extends from the TextView class. So it takes the behavior form the TextView class and then adds a little more specific functionality to it. So EditText extends from TextView. And TextView extends from View, and View extends from Object. And this is the class hierarchy diagram. There's a lot going on, and you can look at it for hours. But let me just show you one thing on the TextView documentation page. I want to show you the method for SetVisibility. Here's the Java method for SetVisibility within the TextView class. This changes whether the view is visible or not. If I click on this method, it actually brings me to the View class. And then it describes what this method does. So you can see that a TextView object has a set visibility method. But it was actually inherited from the View class. So we got this functionality for free, from the View class. Okay, we just covered a ton of new concepts. Normally this would be spread out over a semester of a computer science course. We're going to do a little bit of practice now and hopefully it will start to connect the dots for you. But know that it will take a lot more time and practice until you fully grasp these concepts. Okay, first exercise, I want you to create another new Android app, because we don't want to mess up the just Java app. Once you create the project, then run the app. Once you create your app, you're going to see a MainActivity file. That MainActivity file will extend from AppCompatActivity. In your version of Android Studio, if the MainActivity extends from ActionBarActivity instead, that's okay too. That's just an older version of AppCompatActivity. By removing this method override, we're going to fall back to the way that onCreate method appeared in the AppCompatActivity class. The presence of this method says we want different behavior in the MainActivity for the onCreate. So removing it brings us back to the original behavior in the AppCompatActivity class. When you run the app, what do you notice is different compared to when you first ran the app? Write your answer in this text box. Okay, I just created a new project in Android Studio using the project wizard. When I run the app on my device, it just says, hello world. Now I'm going to remove the onCreate method. I select the whole method from the method declaration. To the opening and closing braces, as well as the @Override text here. Then I run the app on my device. Hm, interesting. Now I see that the app is blank. The hello world text is gone. If I hit undo, then I can take a look at the onCreate method again. It appears that by overriding this method, we're actually causing the hello world text to appear on the screen. And that makes sense, because when we call set content view, this is actually setting the activity main xml layout onto the content view of the activity. So now we're starting to see why it's useful to override the default behavior in the super class. When we override the onCreate method, then we can actually use the layout that we want. Okay, let's leave this deleted. That was the second task. Moving on to the third task, I asked you to delete the onCreate options menu method. So we can select all of this here and then delete it. And now I'm going to run it on my device. Okay, it looks almost the same. The content area is still blank, and there's still an app bar with the app title. It's kind of subtle, but you may have noticed that the three dots here actually disappeared. The three dots were for the overflow menu of the app. And apparently, if I hit undo, then the onCreate options menu code was actually controlling those three dots showing up here. To show you what I mean, I can add that code back in and then run the app again. Okay, so if we override the onCreate options menu within the main activity, then these three dots appear again. And then I see a menu item in there that says settings. So again, in the MainActivity it's valuable to override the onCreate options menu, because then we can provide our own menu items, instead of just having no menu. Even though we're altering and overriding some of the behavior from the AppCompatActivity class, it's still extremely valuable to inherit from this class. It has a lot of complexity behind the scenes, but we don't have to worry about any of it, we just have to specify a few lines of code to customize our activity. Let's go back to the main activity of our Just Java app. Specifically we were looking at the display message method and trying to figure out everything that was going on in here. Even though the findViewById method is not declared within this class we know now that it's actually defined in the super class in the AppCompatActivity. Same for setContentView. This is defined within the AppCompatActivity class. But what exactly is happening in this method, and why do we need to pass in a resource ID? Why do we have extra parentheses here? To answer that question, I'm going to summarize everything we've learned so far and lead you to why this code exists here. Do you remember this diagram? When you click on the app icon on the device it opens up the main activity. Within our code the onCreate method of the main activity gets called by the system. Within this method we have a method called to setContentView with the resource layout ID. In an earlier exercise we passed in a single text view for set content view. But we want more than one view for our app. So we pass in a layout resource ID. This maps to an XML file. Once we set the content view, the activity goes and finds the XML layout file and then reads through each line. For each view, it inflates, or creates, a Java object for it. It goes through the XML file, and then builds up this whole hierarchy of Java objects. When it's inflating each of these views, it's actually calling the constructor, NewTextView or NewLinearLayout, and then it's passing in all these attributes into the Java object, so that it can be set up properly. Notice that we didn't have to write code for NewTextView or NewLinearLayout, and to set the font size. All of it was handled by the inflation process of the activity. To interact with these views while the app is running and to change them, for example, to change the text or to change the buttons, then we need to find these Java objects. Once we find them, we can store them as variables in the main activity. Remember, we're not creating new TextViews from scratch, we're just finding the existing ones in this view hierarchy. These are the variables we've used so far in the main activity. We have a variable for quantity, price, and price message. This is a mix of local and global variables. To interact with the views in the view hierarchy we should create variables that reference these specific views. For example, we can create a variable called quantity text view, that would refer to this TextView here. If you click on the plus or minus buttons in the UI, then you can change the TextView text to show a different number. We can also have a variable called orderSummaryTextView that points to this TextView. When you click on the order button then the orderSummaryTextView will change its text to show the new order summary. So you can see how having variables that point to some of these views would be useful for changing the UI when the app is running. But how do we make the connection between this variable here to this TextView? And how do we make the connection between orderSummaryTextView, here, and this TextView? Back in the layout XML file, remember that we assigned view IDs to certain views? For this TextView, we gave it a view ID of quantity.text.view. For this view we gave it an ID order.summary.text.view. It's optional to assign IDs to views and you only should assign a view ID if you need to refer to that view later. For example you can assign view IDs to everything, but that's unnecessary. We only really need to refer to these two views later in our Java code. So let's just assign IDs to these two views. Okay, we've established that views have view IDs so that we can refer to them later in the Java code. We also established that we want variables that point to these views so that we can manipulate these views. But we still don't exactly know how to make the connection between this variable and this specific Java object. And same for this variable and this Java object. In the AppCompatActivity class, I want to show you a specific method. It's called findViewById and it takes as input a resource ID. The findViewById method finds a view that corresponds with the ID that is passed as an input. And the activity searches for this view in the view hierarchy from the XML that was processed in the onCreate method. So like I was mentioning earlier, the activity onCreate method sets up a view hierarchy and then the findViewByID method goes and finds a view within that view hierarchy. The return value of this method is an object of type view. This left hand column shows the return value for all of these methods. This means that within our activity code we can call findViewById, pass in the resource ID of the view that we want, and then it will return a view object and then we can store that as a variable within the activity. The MainActivity Java code would look like this. We can call findViewById and then pass in as an input the resource ID of the view that we want. We gave this TextView an ID of order.summary.text.view. So here we reference it as R.id.order_summary_text_view. This method will go and traverse the whole view hierarchy and then look for the view with this ID. Then it will return this Java object as a return value of this method. We can store the return value into this variable on the left-hand side, called orderSummaryTextView, and this is a variable of type View. So, this returns a view and we store it inside a view variable. Later in the MainActivity, we can also call findViewById and then pass in this resource ID, R.id.quantity_text_view, which refers to this TextView here. This is the TextView in the quantity picker. When this is called the activity will search through the view hierarchy and then try to find the view with this ID. Then it will return this view and then we can store that in a variable called quantity_text_view. This variable also has a data type of View. This explains how you can have quantityTextView and orderSummaryTextView variables within the MainActivity and that these variables can connect to these Java objects in the view hierarchy. By the way, I listed the data types here of each of these variables in the left-hand column. So these two variables have a type View as declared here. I added the code that we were just looking at into our app. It says View orderSummaryTextView = findViewById, then we pass in the resource ID for the order_summary_text_view. But this causes an error in Android Studio on the next line. It says it cannot resolve the method setText. If I add another line of code here, I can show you the types of methods that are valid on this variable. So, we just created the orderSummaryTextView variable here, and it's a TypeView, and so on the next line, we should be able to call methods on it. But if you look at the autocomplete suggestions, these methods are actually View methods. There's no TextView specific methods. For example, there's no setText method. That's why we get an error down here when we try to call setText. You also can't set text size, or set text color, or any of those. So where are all those methods? Well, the thing is that a TextView is a more specific type of View. So if we want to call TextView methods on this object we need to make sure that this is a TextView object. Okay. Now the variable is a TextView object. But then I get another error that says incompatible types, because a TextView is required on the right hand side, but we're finding just a regular view. That's because the findViewById method returns a View. So how do we reconcile this? Well, since TextView is a more specific type of View or put another way, a TextView is a subclass of view, we can actually use something called casting. Casting in Java means that we can take the View returned by this method and actually treat it as a TextView. So now this right hand side is actually a TextView object, and then we can store it inside this orderSummaryTextView variable. I know that this must be really overwhelming because I just mentioned a ton of new concepts. Let me try to explain again. The findViewById method turns an object of type View. By writing this notation, parentheses with the desired object data type in the middle of it. We're casting this View into a TextView. So the whole expression here evaluates to a TextView object. Then, we can store that in the variable, on the left-hand side, which is orderSummary TextView, and it has a type TextView. Now, on subsequent lines, we can call TextView methods on this object. Do you see now how all the text methods are showing up here? setAllCaps, setTextSize, and more. So I can just erase this now, because setText should work, and there's no more errors. So if we want to be able to call TextView methods, we need to have a TextView object. In order to have a TextView object, We need to call findViewById, and then cast this View object into a TextView. The reason why casting works is because this View here in the view hierarchy is actually a TextView. If we we try to cast it into something like a radio button, that wouldn't work, because the orderSummaryTextView is actually a TextView, so we have to cast it into the appropriate type. Similarly, in the displayQuantity method, we're calling findViewById and we're passing in this resource ID for the quantity TextView. This returns a View, and we cast it into a TextView, and we can store that inside this variable called quantityTextView. This variable has type TextView, and so, on subsequent lines, we can TextView methods on it, like setText. Here's the updated MainActivity code using casting. We can cast these Views into TextViews so that we can store them in variables that have type TextView so in this list of MainActivity variables, now quantityTextView and orderSummaryTextView are type TextView. We can call TextView methods on these, and we're not just limited to treating them as Views. And now we can call TextView specific methods on these variables. For example we can call setText on the orderSummaryTextView, and we can call setText on the quantityTextView. As you can see, you have to be careful about what data types are being used where. So far, when we've called methods, we haven't worried about the return value, because the setText method actually has no return value. Same with the imageView.setImageResource method. This has no return value. But other methods can have return values. For example, in the TextView class we have a getTextSize method. This returns an integer, so we can store the result of this method in a variable called size of type int. Here's another method that has a return value. In the Button class you can call the getHeight method, and this returns an integer value, so you can store it inside a variable. If you tried to store this result inside a string, for example, you would get an error, because this method returns an integer. In order to know what type of data needs to be passed into a method and what data type gets returned back from a method, you should check the documentation. And for example, in the TextView class, if you call any of these methods, it returns a value of type int. The return value data type is in the left-hand column here. For other methods, you might get void as a return value, or booleans, which we haven't learned about yet, or floats or longs and etc. This documentation page also shows what are the expected data types for the inputs for each method. For example, the setTextColor method requires an integer as input and the return value is void, so there's no return value. So check the documentation to know what data types are expected. Otherwise, you'll get errors in Android Studio saying that the data types don't match. Now it's your turn to practice. Below are four different code examples. Some of the code may contain errors relating to data types not matching. If you find an error, describe how you're supposed to fix it by writing it in the boxes provided. Otherwise, you can just write No error if the code is perfectly fine. This is going to be challenging quiz because we just covered a lot of concepts, and this code is still pretty new to you. Take your time and check the documentation for these methods. Make sure that the inputs and the return values are correct and that, if we're declaring variables, that we have the correct data types here. Also, look up the documentation for these method calls to make sure that we're using the methods correctly. Let's look at number 1. Before I reveal the answer, I'm going to copy this code and paste it into Android Studio. I want to show you what kind of error would come out. Now when you were solving this quiz, you didn't need to use Android Studio, you could have solved it by just looking at the code here and then writing in the answer. So, whether or not you use Android Studio, it's fine with me. To make the code work, I created a new project and then I modified the activity main layout file so that it would have a bunch of views with these ID's that we're going to be referencing. I'm not even sure what this layout would look like, but I just wanted to put the views in here with the corresponding view ID names. That way, my code will work here. So for number one, I pasted the code here, and I see that there's an error. Android Studios says it cannot resolve the method setText. If you remember from the last video, I mentioned that setText is a TextView method. That means you can only call this method on TextView objects. In this case, we're calling it on nameTextView. A nameTextView is declared to be a view object, we need to change this to be a TextView object. Then we get an error saying there is incompatible types. A textview, an object of type TextView is required, but instead it found an object of type view. That's because find view by ID returns a view, and this left-hand side requires a TextView. That means we have to add this to cast the view returned by findViewById into a TextView. Then we can store this whole thing, which is the nameTextView, into the left-hand side variable. Then the error goes away, and we can set text, "Laura" on this TextView. The error is on line 1, so I wrote the correct code right here. The general explanation is that we need to cast this view into a TextView and then store that inside a nameTextView variable. That way, we can call nameTextView.setText, which is a TextView method, on the next line of code here. Let's move on to number two. I'm going to copy this code and put it into Android Studio. Here's the code I pasted in. The first line of code seems to be correct, there's no errors. But the second line has a red underline and it says there's an incompatible types error. It says, a string is required but instead it found an int. To understand this better, we should look up the method getMaxLines within the TextView documentation. In the TextView documentation, I'm going to search for the getMaxLines method. And here it is. There's no input parameters, and the return value of this method is an integer. So that's why Android studio was complaining, because this method, if it's returning an integer, but we were trying to store it into a String variable. As a result, I need to change this data type of the variable to be an int. Then the error goes away. So, the return value of this method is an integer. So, we can store it inside this maxLines variable. There is a warning still remaining. Saying that the variable maxLines is never used. But this is just a code snippet. I assume that if this was in a regular app we would actually want to use this variable later. So, the error's on line two and here's the updated code. The general explanation is that the return value of this method should be an integer. Let's move on to number three. Here's a code for number three. I copied and pasted the code for number three in Android Studio. There's an error message that says incompatible types. An ImageView was required, but instead it found a view. This is similar to the error we just saw with the TextView. This method returns a view. And, on the left-hand side, we're trying to store it inside an ImageView. So we need to cast this view object into an ImageView. This is valid because the view with the ID icon actually is an ImageView, so it's okay to cast it into an image view. Now that the right-hand side evaluates to an ImageView, we can store that into the variable on the left-hand side. This variable has a data type ImageView so now everything matches up and the error is gone. On the next side, we can call an ImageView method, SetImageResource, onto this IconImageView object. There is one remaining error saying that it cannot resolve symbol logo. That's because I just didn't add an image in our app with the name logo. If I added that, then the error would go away, so our code here is correct. Here's the correct code where I cast this view into an ImageView. Lastly, we have number 4. I pasted the code here in Android Studio and surprisingly there's no errors. The code is trying to find a view with the id title, and that should return a view, and that gets stored in this variable called TextView. TextView has a data type of View, so that matches with the right-hand side, so this whole line of code is correct. On the next line we're taking this object, which is a View And we're calling a setVisibility method on it. The method takes in one input parameter which is View.GONE. I can check the documentation to verify why that is. In the documentation for the view class, I can search for the method setVisibility. I can see that setVisibility is a method within the view class. It takes this input, an integer that represents the visibility state. The possible visibility values are VISIBLE, INVISIBLE, and GONE. Since setVisibility is a method within the view class, this is a valid call here. There's no need to cast this into a TextView because the method that we're calling is a method of the view class. Now if we were trying to use a TextView method, then we would need to cast it to a TextView. So for this question, you should put no error, because setVisibility is a View method, and it's okay to leave it as a View object. These were hard questions. It's okay if you didn't get them correct. In the next test, you'll have a chance to practice this more. Let's go back to our app now, and add a check box. This will allow the user to select if they want the whipped cream topping on their coffee. It will look something like this, and then you can check this box. Go ahead and add a check box to the app now. This will allow the user to add a whipped cream topping on their drink if they want. When you click on this check box it should automatically animate to this state. Also add a header that says toppings. There's only one topping now, but we're going to add another one later. If you click on the order button, the order summary shows, and it's still the same as before. Eventually, we're going to modify it so it shows whether you have the whipped cream topping or not. For this next coding task, just focus on adding this check box and this header. You haven't added a check box to the layout before, but here's your chance to learn. You can look up online how to do this or you can check out the Common Android Views cheat sheet, which is linked in the instructor notes. Whichever way you decide to figure it out, when your app launches it should look something like this. Also note that I would like 24dp of space in between the box and the text whipped cream. Also use a font size of 16sp for the whipped cream text. By the way, when I draw out specific metrics like for spacing or font sizes or font colors, that's actually called red lines. Red lines are very detailed specifications about how the visual appearance of the app should look like. If you’re a developer working with a designer, you’ll probably get a set of red lines for different screens in your app so that you can build according to these specs. The red lines may include values for colors,size of views, spacing, font sizes and font colors. These are the red lines for the sunshine app in the developing Android apps Udacity course. Keeping this in mind, go ahead and start planning how you're going to build out this layout. Remember the three steps that we taught you in lesson one for building any layout. First, select the views that you need. Then position them, and then style them. In the text boxes provided, write down what you need to do in each step. Once you've planned it out, then go ahead and add this to your app. Ironically, I don't have a check box for you to check when you're done with this task. To build out this layout let's first think about the views that we need. I'm going to assume that all of this is already built, and we're just going to talk about the new things that we need to add to our layout. The two new views that we need to add are a TextView for Toppings and CheckBox view for the Whipped cream item. You probably didn't know that this view existed in Android, but hopefully doing a Google search helped you find this answer. Moving on to Step 2, we need to position the views. Assuming these views are already correctly positioned, we just need to add Toppings and Whipped cream, vertically, in the same row. Since the root view is a vertical, linear layout, we can just add these two Views at the top of it. For the third step, we need to style the views. The style at the Toppings header is the same as the Quantity and Order Summary headers, so we'll be able to just copy and paste the headers that already exist. The CheckBox view is new though so we need to style it accordingly. We should allow for 24 dp of space in between the box and the text, and we should change the font size of Whipped cream to be font size of 16 sp. Let's make these changes to our app now. To add a Toppings header that looks like the Quantity header, I can just copy and paste this code. I copy it and then add it to the top of this vertical LinearLayout. Okay, so now it says Quantity twice here. I'm going to change the text so that it says Toppings. I also copied the margin bottom over so that there's some space in between this header and the content below it. Now we haven't added a CheckBox to our app before, so I'm going to Google search for how to do it. I'm going to search for checkbox android. Remember to add android because there could be checkboxes for other platforms, like for the web or other mobile platforms, this will help you get to a specific result for Android. Let's try the first link. This is the reference documentation for the CheckBox class. I scroll through and I see a nice class overview and then it goes straight into the XML attributes. What I'd really like though is an example of some XML for CheckBox. So let's go back to the search results. Let's click on the second link. Cool, now it shows some pictures of Checkboxes. And here's some XML. This looks pretty good. It has two CheckBoxes within a LinearLayout. I'm just going to copy this first CheckBox, and then I'm going to paste it into our app. Back in our app, I'm going to paste it after the Toppings text, but before the Quantity text, so right here. I'm going to modify the XML because it doesn't exactly quite fit our use case. I'm going to remove the id and also the text here. Instead of meat, because our coffee shop doesn't sell meat, I'm going to type in Whipped cream. By the way, what you saw before, @string/meat, was referring to a resource string in the strings.xml file. We'll talk about that a little more later, but for now, you can just type the string in directly here. And look, the preview updates, so now we have a Checkbox that says Whipped cream. What's cool about the Checkbox view is that it gives you a box, as well as some text, so you don't have to add another text view here. We also don't need this line here that talks about onClick. All we care about for this coding task is making the CheckBox appear here. The other way you could've arrived at this XML is by checking the common Android views cheat sheet. This cheat sheet lists a bunch of common Android views and it has examples for the XML as well. Here's the CheckBox view and here's an example of what it would look like and the corresponding XML. You could have copied the XML from here and pasted it into the app. Going back to Android Studio let's run the app to see how it looks. And here it is. It looks pretty good. We have the Toppings header and a Whipped cream CheckBox. We also get this cool animation when we check the box. The only problem I see though is that the spacing is off. For example, it's too tight in between the Quantity header and the Whipped cream CheckBox, and there's also not enough space in between here. Going back to the red lines that were provided, we should add 24 dp of space here, and change the font size to be 16 sp. First I'm going to change the font size. I'm going to type in android:textSize and then put in a 16sp. I'm going to open up the preview here to check that it actually increased in font size, and it did. If you're not sure if it refreshed or not you can always hit this button. Okay. Now to figure out the spacing I actually got it to work by doing a bunch of trial and error. I tried to set the margin values and then I tried to set the padding values, and it turned out that paddingLeft does control the spacing in between the box and the text here. Let's add the padding now. Cool, the text moved over. I still see one more problem, though. There's enough vertical space here, but there's not enough vertical space here. I either need to add bottom padding, or bottom margin to this CheckBox view, or I need to add top padding, or top margin to this Quantity header. Either way would work, I'm just going to add a top margin to this Quantity header. There, that looks better! Now things appear more equally spaced. I'm going to run this app on my device. And here's the app. It looks really good. Great job. When you need to add more UI changes to your app, you can follow this pattern of Google searching for the information online and then applying it to your app. If I check this box in the app then it'll add the whipped cream topping to our coffee. That will make the coffee more delicious. Yeah. And perhaps more expensive. True. Eventually we're going to have to learn how to create an order summary and then send it off. Oh, so when we send the order summary, that's when we get the coffee. Right? Yeah. That's good. The problem is we don't exactly know if the box is checked or not Wait, you just checked the box. I know you checked the box. Well it's easy for a human to see, but it's hard for the phone to see. Who you calling a human? Anyways, when you add the CheckBox to your app, then it's actually creating a Java object. [SOUND] Like this. How many of these boxes are out there? Many, because in fact, inside the CheckBox object we have a variable. Okay. A Boolean variable. Boolean? Haven't heard that word before. Well a Boolean just means that there's two states here. Like New York and California? No. It's more like a light switch. [SOUND] Damn it. How do you do this? Anyways. So you're saying when we created a CheckBox, we had a Java object. Inside of that we have a variable of type Boolean. Right. And the type of that variable is either on or off. The value of it is yeah, on or off. Okay, so I can turn the value from on to off. I can't see anything. Can you turn it back on? We're not done yet. Oh, okay. Okay, so Boolean can have two states, true or false. And that represents the checked state of this CheckBox. Whoa, that's a lot of checks in that statement. Let's just back up. I'm going to summarize. Tell me if I got this wrong. So when we create the CheckBox we created this Java object. Inside of that Java object we have a variable. Its type happens to be Boolean, and that type of variable can hold two values, either on or off, one or zero, true or false. Exactly. Okay. So let's play with the Boolean. [SOUND] Okay. it's time to take that away from you. [LAUGH] Let's look at what the documentation says about Booleans. I'm going to Google search for Java data type. That's because Boolean is one of the primitive data types in Java. Primitive, meaning basic data types. I'm going to scroll through this list of primitive data types until I find Boolean. And here it is. It says the Boolean data type only has two possible values, true and false. It's used for simple flags that track true and false conditions. Then it says that a Boolean takes up one bit of information. This is about how much space it takes up on a computer. Anyways, the important part is that a Boolean has two possible values. You might think that true and false are actually string values because they're text, but actually, they're not in double quotations, so they're not strings. They're actually fixed literal values. Do you remember how fixed literal values are zero and one or specific strings like hello or today? That means that when you create a Boolean variable you can set it to one of these two values. Going back to our box analogy, if we have a variable called isChecked and it stores information on whether a CheckBox is checked or not, then inside this Boolean variable we can store the value true. Then we can interpret this as the CheckBox being checked. Or we can store the value false inside this variable. Then we could interpret this as the CheckBox not being checked. A Boolean is great for having two possible states. Then it's up to you as a developer to interpret what true and false maps to. If you need more than two possible states then you can't use a Boolean. You need to use something else like a string or an integer. Declaring a Boolean variable is very similar to declaring an int. It's not as complicated as creating an object variable. It follows the format of Boolean hasWhippedCream = true. We have the data type, which is Boolean, followed by the variable name, which can be anything we want, and then the initial value which is true or false. Here are a couple of other examples. This is where I set the same Boolean to be false. And here's a different Boolean called isRegistered, and I just initialize that to false. For example, this variable could represent whether a user using our app actually has a registered account with us. Here's another example. Boolean isOrderForPickup = true. This variable could represent whether someone putting in an order for some coffee wants to pick it up at the store or have it delivered. While our app doesn't support these features, you can imagine how using Booleans could be useful because these things have two possible states. Also notice the way I named these variables. A Boolean variable name has to follow the same conventions as other variable names. However, it's common to start with something like has something or is something. When you see names with has or is, it's likely a Boolean but not always. What I'm about to show you is a little more advanced and optional. So if you're interested you can follow along. This is the documentation page for the CheckBox class. I'm going to click on view source to look at the source code for the CheckBox class. This code is saved in the CheckBox.java file. I want to show you that there's a Boolean variable inside of this CheckBox class. But I don't see it here, so let's check the super class. If this value is true then the CheckBox is checked. If it's false then the box is not checked. You'll notice that this name doesn't contain the word has or is, but if you go down here you'll see that the other Boolean variables do have the word has in it. It's all a matter of preference for the developer. In this case, it's probably pretty clear that this is a Boolean for the checked state. And while this Boolean is not found directly in the CheckBox.java file, since we're inheriting from the CompoundButton class, we get this checked Boolean for free. In general, looking at the source code for the Android classes isn't required at all. To develop Android apps, all you need to know is how to look at the documentation pages. Okay, so in this video we learned about how Booleans can store a value of true or false. In this quiz, practice creating a Boolean variable and updating it by typing out the lines of code in the boxes provided. Type this line exactly in here and same for the other boxes. Then I want you to think about other good use cases for storing information in a Boolean. Think about what has two possible states. Do you ever use alarm clock on your phone to wake up? Well chances are that when you turn your alarm on or off, that that's actually getting stored as a Boolean variable. Another possible Boolean variable is whether you want to repeat an alarm or not. In the Gmail app, if I really want to star this special message that I got from the Gmail team in 2011, then I can star it, or I can unstar it. Since this has two states, it could be stored as a Boolean variable. A possible Boolean variable name for that could be isStarred. You could also use a Boolean variable to keep track of whether an email is read or not. This email is unread, whereas this email is already read. Speaking of YouTube let's go to the YouTube app. In the YouTube app, when it displays a list of videos, if I've already watched it, then it shows this little text box here that says watched in the top left corner of the thumbnail image. The fact that I've watched or not watched the video could also be stored as a Boolean variable. I just showed you some use cases for Booleans, so try to come up with your own here. You can browse existing Android apps for some ideas. After you type it out, it should look something like this. Hopefully you also thought about what each line of code was doing. This line of code creates a new boolean variable called hasWhippedCream and the initial value is false. On the next line, we take that same variable and then we update it to have a true value. And then we update it again to have a false value. You can update it as many times as you want, just like you can update the integer or string variables as many times as you want. As for use cases, I showed you a couple on my phone already, so hopefully you found some on your own. Now that we know that we can use a bullion to represent the check state of this check box, let's modify the order summary so that it reflects whether or not we want the whipped cream topping. If I say that I want the whipped cream topping and then I click on the order button, then it should add a line to the order summary that says whether or not I want that topping. It says true if I check the box to add the topping. And if I uncheck the box and click on order then it should say false. Android already handles checking this box and we already have code in our app to handle clicking on the order button to create an initial order summary. The part that's left for us to implement is adding this line of text here that says add whipped cream and we need to put in the right value based on whether this box is checked or not. Before we start diving into the code, let's think about the pseudo code first to help solidify the main ideas of what we want our code to do. When the order button is clicked, we should do these steps. The first step is to get the checked state from check box, and then store it in a variable. So, that's this checked state. Once the Android device knows if this is checked or not, then we can pass this information into the order summary method, the method that creates this text. As the third step, we can change this text to include this line here about whether the whipped cream topping should be added or not. There are a couple of steps along the way. To make sure that you're on the right path, you can actually log this variable value here to make sure that it reflects the actual checked state. We introduced logging earlier, but here's another example for you. You can write log.v, and then use the class name, which is MainActivity, and then put in a string message that you want to print out to the logs. By printing out the price here, we're verifying that after step one, the calculatePrice method does return the expected price. When you run the app on your device, you should be able to check the logs with this tab to see this message. I use the technique of logging messages often when there's a problem and I'm not sure which line of code has the problem. And then after I figure out the problem, and everything works as expected, then I just delete the log message. So, temporarily, if you want to add a log message to print out the checked state, you can. The reason why I delete log messages after I don't need them anymore, is because the log is a limited length. If you fill it with a bunch of unnecessary messages, then it will cause the important messages and errors to disappear sooner. Once the checked state information is showing up in the order summary on the device, they you really don't need the log messages anymore. When you're done, check this box to continue. The pseudocode starts with, when the order button is clicked. This indicates that we should add our code in the submit order method. Then, we need to get the checked state from the checkbox. In order to call any methods on a view, in the view hierarchy, we need to first find view by id. The first thing I need to do is assign a view id to this check box view. In android studio in activity main layout I'm going to find the check box layout view. Since my cursors here it highlights this view in the preview. Then I'm going to add a line to send a view ID to this view. Now in the Java code, I can refer to this view, and then try to extract the state from it. Let's go into the main activity. I'm going to put my code in the submit order method. I know that I need to find the CheckBox Java object in the view hierarchy. I start by creating a variable, whippedCreamCheckBox, with data type CheckBox. Then I can call the findViewById method within that activity. This will find a view based on the given ID. I'm going to pass in the ID (R.id.whipped_cream_checkbox), which I just assigned in the other layout file. This gives me an error immediately because the required type is CheckBox, because this is what the variable on the left-hand side is. However, the return value of this method is of type view. So, just like we learned earlier, we need to cast the return value of this method. I'm going to cast it to be a CheckBox object. The reason why I can cast it Is because CheckBox is a subclass of View. Okay, now I have the CheckBox Java object that represents the checkbox in the UI. In order to figure out whether the box is checked or not, I need to call a method on the object. You may not know which method to call on the CheckBox object. And that's perfectly fine. So you can just Google search for it. Search for CheckBox Android, and then click on the first link. And to reinforce what I mentioned earlier, checkbox is a subclass of view. There's other views in between, but ultimately it's still a subclass of view. This class overview is kind of interesting because it has some Java code here. It has this line of code which we already have in our app, we're doing find view by id, given an id and then getting a check box item back. This next line is even more interesting. It says check box, which is the name of this variable, dot is checked. This looks like a method call with no input arguments. This appears to be telling us whether the box is checked or not, and returning a true or false value, but let's check the check boxes guide to be sure. Let's scroll through this We see some checkbox xml code, and some more Java code. This method looks like it's called when the checkbox is clicked. This method name matches the method name specified in the xml. I'm assuming that the view that is being passed in is the check box view. And, we cast it to CheckBox, and we also called IsChecked, and the return value is a boolean. The comment also describes it further, it says is the view now checked? So I think this is exactly what we need. Let's try to use the method IsChecked. First we type the variable name of the CheckBox object. It's whippedCreamCheckBox. Then I add a dot to call a method on it. I can start typing isChecked, and it pops up here. So I can hit Enter to use this suggestion. On the right hand side here, it says what the return value of this method is, and it says it returns a boolean. So after I use this suggestion, I'm going to go to the left hand side of this method call and then I'm going to store this result in a boolean variable. I'm going to call this boolean variable hasWhippedCream, then hit Enter. To recap, we're calling a method on the whippedCreamCheckbox Java object, and the method is called isChecked. This has a return value of a boolean and it's being stored on the left-hand side here. In this variable called hasWhippedCream. This completes the first task. I also mentioned that you can log this variable so you could verify that you're on the right path. So, on the next line, I'm going to add a log message. The first argument is a tag name. And I'm just going to use the name of our class, which is MainActivity. Then I'm going to put my own message. I'm going to say Has whipped cream. And then add in the boolean variable. By concatenating this string here with the boolean variable, it will turn this boolean value into a string as well. So then the text will say has whipped cream true, or has whipped cream false. Now let's run the app on our device, and check that this is actually printing out the right log message. I increased the size of the log window using this control here. Now when I click on the whipped cream check box and then hit the order button, I'll expect to see a message down here that says, has whipped cream true or false. I'm going to scroll this over so that I can see the actual message. Okay, let's see if this works. I'm going to check this box and then hit order. Okay, I think a new message got printed out and it says Main Activity. Has whipped cream: true. That's correct because the checkbox is checked. If I uncheck this box and then hit the order button, I expect it to say false. And scroll to the right again, and it says has whipped cream: false. Okay, so it looks like our code is correct so far for finding the checkbox view, and then getting the check state out of it. Now let's continue to the second task. Okay, now we need to pass this boolean variable into the order summary method. If I want to pass another argument into the createOrderSummary method, I'll just add a comma here, and then pass the variable, hasWhippedCream. Immediately I get an error that says, It can't be applied to the method createOrderSummary, because that just expects an integer parameter. So let's scroll down to where createOrderSummary is declared. Now I need to modify the method signature of the createOrderSummary method. Instead of taking in one input parameter, it needs to take in two. So I'm going to add a comma and then specify the second parameter. The data type should be a boolean, and I'm going to call it addwhippedCream. You can call the input parameter whatever name you want, but I just want to show you that this name does not have to match this name here. Since we modified the method's signature here, we have to update the Java dock as well to specify what this input parameter is about. Okay, that completes the second task. The third task is to change the order summary text to include whether or not the user wants whip cream. Essentially that means we need to use this input parameter here to modify our order summary message. In the screen shot the whip cream topping line appeared below the name. So let's add a new line here. I'm going to type out price message plus equals to modify the existing price message. And then add the line Add whipped cream? I'm going to add a space, and then add the boolean variable. Again, I can catonate a string literal with a boolean value, and this will turn this whole thing into a string. Cool, now let's try it on our device. If I click on this check box and then click on the order button it should say add whip cream topping true. And it does, except again, I forgot the new line character, so I need to modify that now. Well since I'm here I should just check the other case. So I'm going to uncheck this box and hit the order button. And it says false. So it's correctly reflecting the state of the checked box. Now let's add the new line character and run the app again. if I click the check box and then hit the order button then it's says true. If I uncheck it then click on order, it says false. Awesome. That handles both cases. The later parts of this task were easier. Because once we verified in the logs that we were getting the right check state, it was only a matter of showing on the screen. Since things are working inside the app now, I can remove the log message because it's not needed anymore. And then run the app one final time. Okay, great work. Let's move on to the next task. If you start to add too many things to the order form, then the content can get cut off at the bottom. Like this could get pushed off the screen and then you wouldn't be able to see it. A vertical linear layout doesn't scroll if it extends beyond the edge of the screen. You need to add something specific in your app to make it vertically scrollable. This is a silly example, but I basically copied the views that we have in our layout and then pasted it right after each other. And you can see that even though there's more content beyond the edge of this screen, it still doesn't scroll. This is especially a common problem when you switch your phone to landscape mode and the screen is shorter compared to in portrait mode. That's where it'd be really convenient if this could scroll. And now I'll leave it to you to figure out how to do this. When you're done, you can describe how you did it here. You can write it with your feather quill, or just use your keyboard. Let's Google search for how to do this. I'm going to type in how to scroll in an android app. Let's check out the first result. The question is, how to make my layout able to scroll down? That's pretty similar to what we want. I skip down to the answer part and this has a green check mark and lots of up votes. So this could be a good answer. It says, just wrap all of that inside a ScrollView. And then it has an example, ScrollView, and then it specifies name space and then it says. Fill_parent for width and height, and then it has an ending tag here, and in this comment it says, put the rest of your current view inside of it. For background knowledge, fill_parent is actually the same as match_parent. It's just an older version of it, but they mean the same thing. On this next line it says that ScrollView can contain just one item. It looks like this was someone's original layout, and then to put inside of scroll view then they just made scroll view be the parent view and the linear layout be the child's view. Okay that was a helpful response so let's go back and see if there's any other solutions. This person is describing the same thing. They have XML lay out and I think they want to make it scroll. Usually, I don't read the full question in detail. I just get to the answer part. This person says, have you tried to include all of your XML into a parent ScrollView? And then they give an example of ScrollView, and then the child is a RelativeLayout. And then they have a closing tag for ScrollView. That's all they have in this thread. But it looks like the two search results here gave the same advice of using a ScrollView. So let's change our search query to search for ScrollView android. Awesome. So it is a view in Android. And there's a description here. There's a lot of text here, so I'm going to skip reading it, but if you want to skim it, you can. Then I'm going to hit Back. I prefer looking for a code example. So, the code examples that we had earlier were good, and this one is good as well. So let's go back to Android Studio. All of those XML examples started with ScrollView. Immediately there's an error that says I don't have the required width and height of the view. So, I just added those in and specified them to be match_parent. If I add a closing bracket, then I immediately get the closing tag here. So, I'm going to copy that and then paste it at the bottom of this file down here. That means the existing linear layout is now a child of this ScrollView. I'm going to select all of this and then try to indent it by four spaces, so it's easier to read as a child of this ScrollView. In Android Studio, if I click on the Edit menu, I can go to Indent Selection, and that will indent it over by four spaces. There. Now that looks better. Oh, but I still have an error here. It says, namespace 'android' is not bound. I can click for more information. It says, this inspection checks for unbound namespace prefixes in XML. If you remember way back in lesson one, I said that Android colon comes from this name space right here. So I think we need to copy this and then put it up here. You should also move the tools name space up here. The tools name space is to provide additional attributes that you can add to your XML to help you debug and build your app. Okay, I'm going to run this on my device now. Okay, there's no visible difference to the app because there's not enough content in the order form to make it need to be scrollable. To really test this, I need to add more views to this layout. I'm going to do same trick as before. I'm going to copy all these views and then paste it into the layout so that we have a really long order form. Okay, now the order form is really long and it scrolls. That's exciting. If I rotate the device, then it also scrolls. Now I can undo those changes and go back to our original order form. I'm still going to leave the ScrollView in, though, because our app will work better across all devices. For users with devices that are shorter than this, they'll still be able to scroll and see all the fields. We've come a long way in this course. Yeah. Some of our students may be feeling ecstatic that they built these couple of apps. Yeah. Although some of them may be feeling a little bit pensive because they realize that there is a lot to learn. There is, and I can empathize with that feeling. When I first started at Google, I felt out of place. I didn't know why they hired me. I just felt like an impostor. Like impostor syndrome? Exactly, but then I realize that other people also feel the same thing, and that made me feel more at ease. Wow, thanks for sharing. Let's do the same thing for our students next. Okay. Here are some Googlers sharing their stories of feeling out of place. Invariably, you will land on a project where you don't know much about what's involved. It's completely okay to say, you know, I have not the slightest idea how to solve this problem. This is very normal, and it is normal for every single person. I remember still just, just starting full time work. And realizing, wow, I'm not sure I know how to work with big code bases. Or, I don't know this language, and it's frightening. And there's a lot you don't know. Find a little nugget you can take on, and take it from there. There's a lot of times when you run into areas where you just don't know what to do, and you feel like you can't make it all come together. And the most important thing is to not get caught up in that. Sometimes the best thing you can do is actually just take a little time off of a problem, and then circle back a little bit later when you have a fresher mind, and then it'll be easy. Imposter syndrome is the feeling that you're a fake. And somehow you snuck in, and you don't deserve to be where you are. There are so many times at work, where I get projects, to work on, and internally I feel like, there's no way I can do this. I'm totally going to fail at it. The only person expecting me to fail is myself. And so if I can get over that I can gain more confidence and do anything that I want to do. You have just asked me to code up something or to fix a bug. I don't even know where to begin, the best people I know learn to live with uncertainty, fear, doubt, confusion, and they just plow right ahead. Failure is It's going to happen if you take risks. And taking risks is important to succeed. I have a few tips on how to cope with that. Number one is try to see the silver lining of failure. Number two is, I think preparing is really important. It will help you a lot in Taking the risks that are more manageable and being able to succeed more often. I think it's absolutely vital that when you go into building something you accept that sometimes you're going to be wrong. If I had an opportunity to sort of go back in time and tell a younger version of myself, just say I was getting started. What should I do? I honestly think the main thing would be to experiment more. And just always trying, be learning new things. You don't have to have all of the knowledge right now, but just realize that you can always learn it. And the whole coding process is a learning process. So, if you're in a class, and it's been a while, and you made progress, first of all be proud of that progress. And you find yourself now feeling a little stuck, it's okay. Being overwhelmed is not a bad thing. That's my first advice. It means there's a lot of information coming your way, and you're so lucky that that is the case. We just heard some great stories from Googlers about how they deal with uncertainty. And now you're going to get a chance to deal with uncertainty too. In this next coding task, you're going to add a text field into the app so that someone can enter their name, like Larry or Kevin, into the app for their coffee order. At first you might not know how to deal with something like this, but that's okay. You can Google search for it online. And, like my mom always says, you can just take it one step at a time. The app should look something like this and here's the name field. There's a special type of view in Android that can handle text input. So when you tap on the field, then the keyboard pops up. When the field is blank, it gives you some hint text to tell you what you should type here. As soon as you start typing, then that hint text goes away. When you're done typing, you can just hide the keyboard. You've probably seen this view many times before in other apps. For example, in chat applications, you type your message into a field and then send it off to someone. This is actually quite a complex view, lots of things are happening behind the scenes, but luckily, Android handles all of that for us. Okay, go ahead and add this field to your app, then make a change so that when the user hits the order button, the name also appears there. First, plan out the steps that you need to do. You can write your answer here. As you do each step, you can Google search for how to do it and find example code for it, or you can look at the common Android views cheat sheet for ideas. You can also use logging to verify the value of variables along the way as you do each of these steps. When you're done, answer these questions on the right. What view did you end up adding? And what Java method gets you the text that the user entered? And lastly, what's the return data type of this method? Write your answer here. All right, that was a really challenging coding task. It had many parts to it and it involved a view that you've never used before. Let's walk through the solution together. To start, I asked you to plan out the steps that you need to do. The first step should be to add this text field so that the user can enter in their name. The second step is that when the order button is clicked, we want to get the name from the text field and store it in a variable. Then the third step is to update the order summary to actually show that name. Let's dive into this first step. We haven't added a text input field in our app before, so let's Google search for how to do this. Since we're trying to get input from the user, I'm going to search for user input android. The result is a developer.android.com site, so that looks good. This page describes best practices for user input. It talks about touch gestures, as well as keyboard input and game controllers. Keyboard input is what we want, so let's click on the first link. I start by scrolling through the page quickly. I see a bunch of XML examples, which will be helpful. I notice that there is an opening angle bracket and then the view name. In this case the view name seems to be EditText. If I scroll through the other examples, I also see that it's an EditText view. So, it seems like this view that takes in keyboard input is called EditText. Another approach is to use the Common Android Views cheat sheet. The EditText is also in this list of views and this album description example is similar to the name field in our app. Let's copy this XMLand add it into our app. We want the name field at the very top of our order form, above the toppings header, so let's add it here. Immediately, there's an error saying that it can't resolve this symbol for hint. This references the album description text, but that was for the cheat sheet. Let's delete this and replace it with our own hint, which is Name. Since we want the name field at the top of our order form, above the toppings header, let's paste it right here. It'll be the first child in this vertical linear layout. Now let's make sure that all the attributes are set the way that we want. First, we have the view ID. And it's called album_description_view. This is referring to the cheat sheet example, so let's change this to a more appropriate name. Let's call it the name field. Next we have width and height which are familiar attributes. Currently, the width of the edit text field is set to match parent. That means the field will be as wide as the parent linear layout. Next, we have height. Height is set to be wrap content, so it will be as tall as the content inside of it. These two values seem reasonable, so let's leave them as is. Next we have hint. We haven't worked with this attribute before and there's an error saying that it can't resolve this string. Let's look up the documentation for EditText android to figure out what this attribute means. By searching for edittext android we can find the documentation page for it. There's a quick class overview here and then a list of the XML attributes. It turns out that the edit text class inherits from text view and view. So, that's why we have these inherited XML attributes. Once they're expanded we can search for android hint. All right this was the attribute we were looking for. If we scroll over to the right it says that this is the hint text to display when the text is empty. This helps the user know what they show type in to that field. In that app that I demonstrated to you, the hint text said name. So in our code, we show erase this string and type in name. Next we have the inputType. This is also a new attribute, so let's look at the documentation. Now I'm going to search for Android input type. It's listed here and the description says, this is the type of data being placed in the text field. It's used to help an input method decide how to let the user enter the text. This is a bit of a vague description, so let's click on this attribute for more information. Here’s the full description of InputType. These are the possible values that we can set. In the example from the cheat sheet, the XML said textMultiLine. Apparently this means that the edit text field can allow multiple lines of text. We don’t expect someone’s name to be really long, so one line of text should be good enough. Let’s just use text as the input type. If I erase textMultiline and start typing text, then I get a list of all the options as auto complete suggestions. I'll just select text and hit enter. Now I'm going to run the app on the device to check if the EditText field shows up. When the app launches, I see the name field. Awesome. And I can type in to it as well. But actually, it starts with a lowercase letter. When I type, I want it to start as a capital letter. To fix this, I can modify the input type here. Let's look at the other options here. There's textCapcharacters, textCapwords, textCapsentences and a whole bunch of things. The ones about capitalization look promising. After reading through these descriptions, I think textCapwords could be a good option to try. So, let's copy this and use it. And so, instead of text I'm going to use textCapwords. Let's run the app again. Okay, now the keyboard starts with the letters capitalized, so then I can just start typing the name, and if I add a space, then the next word is capitalized. Awesome. The last thing I notice is that we need a little bit of space in between this name field and the toppings header. We've been adding 16 dp of vertical spacing, so let's do the same here. I could add it as bottom margin on the EditText field, but I'm just going to choose to add it as top margin on the toppings header. Okay, now the spacing looks and the name field is correct already. That took care of all the XML changes for step one. Now we need to modify the java code. For step two, when the order button is clicked, we want to get the name from the text field and store it in a variable. It's easy for our human eyes to see the name in this field, but the Android app doesn't know that we want to put this name in to the order summary here. It's still using Lyla's hard coded name. We need to switch it to use this name. This is just like how we had to figure out if the check box is checked or not in order to update the order summary. We haven't learned how to read text from EditText field, so let's Google search for that. I'm going to search for how do I get text from the EditText field Android. The first result looks good. It's a stack overflow question. I can read the question but I'm mostly looking for the answer. I can scan through quickly to see if this page is helpful or not. This answer has a green check mark by it and has a lot of upvotes, so I can read this more carefully. I start with the code snippet. It looks like this code would go inside an activity class because we're calling FindViewById method. We're trying to search the view hierarchy for a view with this ID. Once we find this view, we're casting it to an EditText view and then storing that in a variable called text. On the second line we're trying to declare a string variable called value. And store this inside of it. Now this has a lot of parenthesis, and dots, and words, but you might be able to guess that we're trying to get the text out of this EditText field. And we're trying to store it inside a string variable called value. Let's copy and paste this code in to our app to see if it works. In the MainActivity class I'm going to add the code in the submitOrder method. I chose this method because this is where the order button is getting clicked and this is where we want to read from the name field. I'm going to paste the code from the stack overflow post into the top of the method. Immediately there's an error that says it can't resolve this symbol. We need to replace this with the ViewId for the name field. Switching back to our layout.xml, we gave the EditText field a view id of name_field, so in the Java file, I'm going to change this to be R.id.name_field. There's no more errors, so I can try to run the app, but how will I know if this code is actually working or not? I could add a log message here to verify that value actually holds the name in this field. And here's the code for the log message. I'm printing out name colon and then the value string. Value is a vague name for this variable so I'm going to switch it to be called name. That would be a little bit more of a descriptive name for it. Speaking of which, I'm going to change the variable name for EditText to also be name field. Text could be confused with other things within our code. Now let's run the app and check for this log message. Okay. If I fill out the order form and then hit the order button, then I can check the logs here. I see a new message for MainActivity that says Name: Antigravity Anthony. So, it worked. This code actually did pull out the name from this field. Cool. Now that we have the user's name in a variable, and we verified that with logging, that it's the correct name, then we can update the order summary to show this name. In order for the order summary to show the correct name, we need to pass it as an input parameter to this method. That means when we call the create order summary method, we have to pass this name variable in as an input argument. Let's make that change first. If I add name as an input argument, I get an error because the method call doesn't match the method signature. Scrolling down to the method definition, I can add String name as an input parameter. I'll also update the Java doc as well. Now, inside the createOrderSummary method, I can use this variable. I'm going to erase the hard coded name and then concatenate this name variable. So, to recap, we're getting the name from the name_field and then passing it as an input to the createOrderSummary method. Inside this method, we can append the name to the order summary. Let's run the app to check our code. Once the app launches, I can type in a name, select some toppings, and then change the quantity. Then I can hit the order button. Now I see that the order summary contains the name that I typed in earlier. Woohoo! If I change the name and then hit order, then it updates again. That's exciting. Now that everything in the app is working, I can remove this log message. I can run the app again one more time to make sure that things work. Now let's go back and answer these quiz questions. The view that we added to our app is called EditText. The second question asks what Java method we called to get the text from this view. We can answer this by going back to our code. We search the view hierarchy for theEditText java object that represented the name field. We store that in a variable called nameField. And on that object we called the method. We called the getText method, which takes no input arguments and it has a return value of another object. That leads us to our third question. What's the return data type of the getText method? The answer is editable and I figured this out by looking at the Android documentation. For the Edit Text Class, if you scroll down you can see all the public methods. GetText is listed as a method as returning the text that the text view is displaying. The return data type is editable. This returns an editable object, and we can call another method on this object by adding the dot notation and then the method name. So in this case we're calling the toString method on the editable object, and the toString method returns a string, so that can be stored in the name variable. This is a more advanced concept, and it's called chaining method calls. Because we're calling one method, getting the return value and then calling another method and if this returns an object, you can call another method on it. And you can keep calling methods one after the other. The reason we chain method calls is because getText method returns an editable object. An editable object cannot be stored inside a string variable, as seen by this Android Studio error saying incompatible types. So, if we add the toString method, then the return value of this whole thing is a string, and that can be stored in the name variable. We can verify this by checking the documentation. The getText method returns an editable object. If I click on this, in the editable class, we should find a method called toString. Scrolling down, in the public method section, I don't see toString listed here. But there are inherited methods. So, if I open this drop down, then I see that toString is a method. And the return value is string. So, to hammer it home one more time, this method call returns an editable object, and then we can call the toString method on it. The toString method returns a string and so this whole thing on the right hand side here, returns a string. And that can be stored in the string variable called name. Wow, that was a really long coding task. You can take a quick break now and then come back because we need to figure out how to change the price based on what the user ordered. We're going to do this by learning about control flow. The next thing to do in our app is to change the price of the coffee in case someone orders a topping, like whipped cream or chocolate. That's a good idea. If they order whipped cream, then we'll just charge them $1. If they order chocolate, then we'll charge them $2. Right. Let's figure out how to do this in the app. Here are a couple of examples in other Google apps, where the behavior can change based on certain conditions. In the Inbox app from Gmail, here's a screen shot of the list of emails. For a single email, if there is a reminder attached to it, then the app knows to show this icon, this label and the reminder text. If an email has image attachments, then the app knows to show those images in line here. If an email mentions a trip, then a travel card shows up with the flight information. In the Google Now Launcher app, we have more examples of how the app behavior changes based on certain conditions. For example, if the stock price is increasing, then the delta or the increase in the price will be shown here in green font color. If the stock price is decreasing, then the difference will be shown here in a red font color. For this weather card, if the temperature is good and the weather is sunny, then we show a sun icon. If the weather is windy or cloudy, then we show different icons. We'll be modifying our app shortly so that the price changes based on the toppings ordered but first, I want you to become familiar with control flow. Normally, the code in our methods gets executed from top to bottom, line after line but with control flow statements, you can change that instructions are executed in. For example, you can skip certain instructions if certain conditions are met. We're going to do this by learning about if/else logic. You haven't seen code for if/else statements before but I'm going to throw you in the deep end and see how you do. In the next couple of challenges, you're going to read some code snippets on your own, and these are linked in the instructor notes. Then you're going to try to guess what this code does and try to determine the output. You'll have several options to choose from so you can choose the best one that matches this code. When I say output, I'm referring to the log statements that get printed to the log cat. Remember that you can access log cat from this Android tab right here, and it shows all the messages from the system, and from our apps. The code snippets that we're providing to you are going to be writing messages to the log here. Let's do a sample question together. You can find this link in the instructor notes. Assume that this is a code snippet from a WeatherActivity.java file within a weather app. The first line of code creates a boolean variable called isRaining and the initial value is true. Then we have this if/else statement. If is raining is true, then we write this to the logs. It says, It's raining, better bring an umbrella. If is raining is false, then we go into this else case and we write, this message, It's unlikely to rain. Since is raining is true, then we fall into this case and we write, It's raining, better bring an umbrella. Because we fall into this case, we can skip the else block, this line of code lives outside the if else statement so it always gets executed. It says, Thank you for using the Whetherweather App. Let's look for an option in the quiz that shows, It's raining, better bring an umbrella., immediately followed by, Thank you for using the WhetherWeather App. That's exactly option B. Now here's a different problem for you to try. Check the notes for the code snippet and then make your selection. I'll be going over these answers pretty quickly, but we're going to go into more detail about if else statements after that. For this code snippet in the weatherActivity.java file, we create a boolean that's called isRaining and we initialize it to false. Then we go to the next line of code, which prints out a log statement that says, thank you for using the weather weather app. Then we have an if else statement. If the isRaining boolean is true, then we should run the code in between these opening and closing braces. Otherwise if the isRaining boolean is false, then we should do the code inside these opening and closing braces. Since isRaining is actually false, as shown up here, then we skip this if condition and go all the way down to this else case. Within this else block of code, we have one log message that prints It's unlikely to rain. Reading through all of this code, it should say, Thank you for using the whetherweather App. And then it should skip down to here and say, It's unlikely to rain. That leads us to answer C. Continue on for more practice. Assume that this is a code snippet from an InboxActivity.java file within an email app. Now there's a lot of code here with concepts you haven't learned before. So it's okay if you didn't get this one correct. Let's walk through it together. First, we create an integer variable called numberOfEmailsInInbox. We initialize the variable to have a value of 0. Then we create another integer variable called numberOfDraftEmails. And we initialize that to have a value of 2. Next we create a string variable called emailMessage. And the value is you have blank emails, where blank is actually a variable referring to numberOfEmailsInInbox. So this evaluates to you have 0 emails, because this variable has a value of 0. Next we have another string variable called draftMessage. The value is You have blank email drafts. Blank actually refers to numberofDraftEmails and this has a value of 2. So this right hand side maps to You have 2 email drafts. So far we have four variables and nothing has been printed to the logs yet. Now we have an if statement. There's no else block of code down here, and that's perfectly fine. This statement reads if the numberOfEmailsInInbox = 0, then perform the code within these opening and closing braces. We remember that numberOfEmailsInInbox is equal to 0, so this code in the opening and closing braces would get executed. It simply updates the email message variable to say You have no new messages. Okay, so we know that the latest value of email message is You have no new messages and the latest value of draft message is up here. You have 2 email drafts. Let's continue reading. There's another if statement down here. If the numberOfDraftEmails equals 0, then perform the code within the opening and closing braces. However, numberOfDraftEmails has a value of 2. That means this condition here is false and we can skip this block of code. Therefore, the draftMessage variable stays at the value of You have 2 email drafts. It does not update to this new message. Finally, we're back in a regular execution flow of the method. There's no more if statements, and we can run this line of code which prints to the logs. It prints the emailMessage to the logs and then next it prints the draftMessage to the logs. At this point in time emailMessage says, You have no new messages, and draftMessage says, You have 2 email drafts. Looking at our choices, option C is what we want. Option A is incorrect because we don't print out the message at every point in time. We only have two lines of code that print to the logs. Option B is incorrect because the emailMessage string gets updated within the if statement. And there's actually 2 email drafts, not 0 email drafts, so the second log statement is also incorrect. That leaves the remaining correct choice, option C. I love smoothies. Let's look some code from the SmoothieActivity. First, we create an integer variable called numberOfSmoothiesTillPrize and we initialize that to a value of ten. Then we have an if-else statement. It spans from line two to line seven. If the numberOfSmoothiesTillPrize is greater than nine, then do the code within the opening and closing braces here. If this statement is not true, then do the code in this else block right here. Since the numberOfSmoothiesTillPrize has a value of ten, and ten is greater than nine, then we fall into the if case here. We print out a log message that says, 'Congratulations, you get a free smoothie!". Then we update the numberOfSmoothiesTillPrize variable to be this new value. This evaluates to ten minus ten, which is zero, so we essentially update this to have zero smoothies. That makes sense, because once you've reached ten smoothies, and you get a free one, your count goes back to zero and and you have to buy ten more again. So this has a value of zero, let's continue. Well, we've reached then end of this if block of code, and we skip over the else lock because we only do one or the other. And so we immediately go down here. In this last code statement, we add a log message that says, you currently have blank out of 10 smoothies needed for your next free smoothie. This blank here is actually a variable called numberOfSmoothiesTillPrize. And this currently has a value of zero, because we updated it here. So this message would say, you currently have zero out or ten smoothies until your next free one. Therefore, the answer is C. By stepping through the code, we got the message, Congratulations, you get a free smoothie! And we also saw the message, You currently have 0 out of 10 smoothies until your next one. Option A, is incorrect, because we definitely did get a free smoothie. Option B, is incorrect because we updated the number of smoothies count back to zero. Nice job trying to recode that you didn't understand before and trying to pick the answer. Continue on to learn exactly what is going on. In the previous quiz questions, you used your intuition to read through some if else statements. You figured out what different messages would be printed to the logs based on certain conditions. Now let's look into these statements more formally. If/else statements are called control flow statements. It's named this way because instead of a linear flow of code where one line of code is being executed after another, the control flow statement actually allows us to jump to different parts of the code based on certain conditions. So if this condition is true, meaning the Boolean variable was set to true up here somewhere, then these statements will be executed. And it will skip this block of code. If this condition is false, then we execute these lines of code, and then resume the normal linear flow of code after that. Looking at our vocab word glossary, we can look up the phrase if/else statement. One way to think about this is to use an analogy of a train track. A train track has a switch so that given a certain condition, the train will go one way or the other. Similarly in the if/else statement, if this condition is true, then we'll execute one path of code. If the statement is false, then we'll execute a different path of code. And then afterwards, we're going to resume the normal flow of code. The if statement is the simplest control flow statement. Notice the syntax here. We start with the word if, and then we have parentheses around the condition. And then we have an opening brace, and then a closing brace at the end of that if block of code. In this example of a pizza ordering app, if the user wants the order to be delivered to their home, then we're going to adjust the price to add five extra dollars for the delivery charge. Otherwise, if the order is not for delivery, then we just skip this line of code, and we don't add the extra charge for delivery. Then in these subsequent lines of code, we can use the totalPrice variable with the correct value. Now the if/else statement is a little more advanced. If the condition in the parentheses is true, then we execute these lines of code. Then we skip this and then continue with the rest of the code. So in this game app, if the user has zero points, then we're going to update the textView to say Loser. And we're going to update the imageView to be a sad face. However, if the condition is false, the person has, for example, 100 points, then we're going to skip this block of code, and we're going to go down here to the else case. We're going to update the textView to show the word Winner, and then we're going to update the imageView to show a happy face. Then we're going to continue with these lines of code here. As you can see, the code inside the if statement can contain as many lines of code as we want, similarly with the else statement. If we want more than two possible code paths, we can use an else if statement. You can have as many else if blocks as you want, and then you could just end with an else at the very end. But again, all these else if and else blocks are optional. In our code here, we can fall into one of three possible cases depending on the value of the integer variable itemCount. itemCount just represents the number of items in the shopping cart in our app. Let's start with the first condition. If itemCount is 12, then 12 is greater than 10, so that is true. And then we would execute the lines of code within this block of code. We would create a Toast message that says, You get 20% off, and show it at the bottom of the screen. Since we fell into this case, then we skip this block and this block, and then we continue with the rest of the code. What would happen if the shopping cart only had two items in it? Well, then itemCount would not be greater than ten. So this would be false, and we would skip this block of code here and then jump down to the else if statement. Then we would check if two is greater than zero, and it is, so then we would fall into this case. We would show a Toast message that says, Thank you. Since we fell into this case, we're going to skip this one, and then we can continue with the rest of the code. And lastly if our shopping cart had zero items, then this condition would be false because zero is not greater than ten. This condition would be false because zero is not greater than zero. And then we would fall into this else case here. And we would show a message that says, You have an empty cart. If you ever need a reminder of the syntax of any of these statements, you can just check the official Java documentation. It tells you about the if statement, and here's an example. And then it also shows you that if else statement and here's the example. And lastly there is an example with else if statements. Based on everything that I've shown you so far, you're probably realizing that Java has a special use for the words if and else. They're Java keywords and they're used to control how the code is executed. So you can't use these as variable names. >From the examples that I showed you, you also may have started to realize that we put different expressions in this test condition here. Any expression is valid as long as evaluates to true or false. So we can put a Boolean variable in the test condition or, for example, we can compare two values. We can compare two values using any of these equality and relational operators. We can test that two images are equal to each other, or not equal to each other, or greater or less than equal to each other. And here are examples of different test conditions. Now here's a chance for you to practice typing out the syntax for a control flow statement. For this given block of code here, I want you to type it out exactly into this blank box. Write out the Java keywords if and else properly. And remember to include the parenthesis around the test condition. And then remember the braces as well. When you're done typing it out, go ahead and answer this question. If we assume that the variable number of guests has a value of ten at the start of this statement. Then after it's executed this statement. What is the ending value of the variable tip? Hopefully, the act of typing out this block of code made you feel more comfortable with writing if else statements and gave you a sense of how you can use it to introduce some interesting logic when you create apps. As for this last question in the image of variable number of guests has a value of ten. Then this first condition will be false because ten is not less than six. So we skip this case. We go into the second condition We check if the number of guests 10 is less than 20. And this is true so we set the tip to be 100. Since we fell into this case we can skip all other cases that follow it and then the ending value of tip is just 100. Let's add the code now to our app. We're going to start by calculating the base price of a drink. The base price is composed of two parts. The price of the coffee, which is $5 plus any toppings. So $1 for whip cream, or $2 for chocolate. We're going to take this base price, and then we're going to multiply it by the quantity of cups ordered. That will brings us to the total order price. Let's calculate the price for a sample order, where the user wants 3 cups of coffee with whipped cream, like this. The goal of this course is not to test your math skills so let's walk through the calculation together to make sure that you understand it. The real goal will be for you to translate this logic into code. In this sample order the user wants 3 cups of coffee with whipped cream, like this. First, we can start off by calculating the base price of 1 cup of coffee. We start with $5 for the coffee cup plus $1 for the whipped cream topping. That brings us to $6 per cup. Then, we need to find the total order price. Since the user ordered 3 cups of coffee, we multiply $6 per cup times 3 cups. That equals $18 total for the whole order. In this sample order, we have 2 cups of coffee and each cup has whipped cream topping and chocolate topping, like this and this. First, we calculate the base price of 1 cup. A cup of coffee costs $5, and then we add $1 for whipped cream and $2 for chocolate. That brings us to a total of 5, 6, 7, 8, $8 per cup. Then we find the total order price since the user ordered 2 cups of coffee. We take the base price of $8 per cup of coffee times 2 cups and that brings us to $16 total for the whole order. This is what our app should look like. We can enter in a name, choose a whipped cream topping and then change the quantity to 3. If we hit the Order button, we expect the price to change to $18. And there it is. This is exactly what we calculated earlier by hand. If I add the chocolate topping, change the quantity to 2. Then the total price becomes $16, also just like we calculated where we have $8 per cup of coffee. Now, go ahead and plan out the steps that you need to do in order to add this functionality to our app. I wrote down the price of the toppings here for reference. And here's a screen shot of what the app should look like with the adjusted price here. After you've planned out the steps then go ahead and implement this in your app. Then, can you tell me what method did you end up modifying? In order to calculate the correct price for the order summary, we should pass the information about which toppings the user has selected into the calculatePrice method. I'm choosing to do all the heavy lifting and calculation within the calculatePrice method, so it centralizes all of this related logic. By consolidating everything into this method, if there's a problem with how the price is calculated, we can check the code in a single place. It's a lot more manageable. Then, within this method, we're going to figure out the base price of one cup of coffee. This is just like I showed you earlier. If the coffee should have whipped cream, then add a dollar. If the coffee should have chocolate, then add $2. Then take the base price of one cup of coffee and multiply it by the quantity ordered to determine the total order price. First let's pass in the information about the whipped cream and chocolate check boxes into the calculatePrice method. I'm going to pass in the booleans hasWhippedCream and hasChocolate. There's no point in passing in the actual CheckBox objects, because all we care about are these boolean values for calculating the price. Android Studio tells me that there's an error because the method signature doesn't match. I'm trying to call a method that has been defined to have zero input parameters. Let's go down to where the calculatePrice method is being defined. I'm going to change the method signature so that it takes in two input parameters, a boolean called addWhippedCream and a boolean called addChocolate. You can call these input parameters whatever name you want. I just chose to use a different name than what was passed in, just to show you that these names don't have to match. I also updated the Javadoc to describe these two new input parameters. That way someone calling the method will know what to pass in. Next, within the calculatePrice method I have to do all the logic about changing the price based on these toppings. First, I'm going to calculate the base price, so I'm going to create an integer variable called basePrice. I'm going to start the value at 5 because a cup of coffee cost $5. Then I'm going to create an if statement. If the boolean addWhippedCream is true, then the user wants whipped cream. That means we should add $1 onto the base price of one cup of coffee. Okay, that should handle the whipped cream case. Now, let's move onto the chocolate case. I'm going to create another if statement. I don't need an else block of code, because if the user doesn't want whipped cream, I don't have to do anything at all. In fact, if I wanted to type an else case, this is what it would look like. I would just have a comment that says, do nothing. Android studio is smarter than that, though, and notices that the else statement has an empty body. Their advice is that this type of code of confusing, and can be the result of a typo. It's also extra lines of code that we don't need, so let's just erase the else block. Now we can move on to the chocolate case. The chocolate topping is completely independent from the whipped cream topping. It doesn't matter if the user chooses one or the other, they're not dependent on each another. So I'm going to create a separate if case. If the user wants chocolate, then we need to modify the base price to be basePrice + 2. Again, we could have an else block of code, but it would do nothing. If the user doesn't want chocolate, we don't have to adjust the price at all, so let's just delete this code because it's unnecessary. Reading through our code, we have a base price of $5 per cup of coffee. If the user wants whipped cream, then we need to increase the base price by $1. Then if the user wants chocolate, then we need to increase the base price by $2. Then to calculate the total order price, we need to multiply quantity times the price of one cup of coffee. Okay, this code looks like it should work. I also added inline comments above each block of code, so that when we come back to this code later, we'll remember what we did. Now, let's run the app to check that it works. Okay, let's test the cases that we went over together earlier. If we choose the whipped cream topping and a quantity of 3, Then each cup will be $6. $6 times 3 is $18, and it calculates 18, nice. If I add the chocolate topping, then each cup of coffee will cost $8. If I have a quantity of 2, then the total price will be $16. We tried just using a whipped cream topping and we got the correct answer. We tried a case with both whipped cream and chocolate topping, and we got the right answer. Now let's try just choosing the chocolate topping. I'll change the quantity to 1, and then hit Order. This looks correct, because we have $5 for one cup of coffee plus $2 for chocolate, and that brings us to $7. If I change this to 4, then the total updates, assuming $7 per cup of coffee. Awesome. It looks like it works. I ran through those test cases pretty quickly. What I was trying to do, though, is make sure that all the possible code paths were run through. For example, if we run the app, and we never select the whipped cream check box, then we would never test whether this code in here works. So we need to pick conditions that will cause all parts of our code to execute. So we selected the whipped cream topping and we also selected the chocolate topping to make sure that this code also executed. To be even more thorough we should test for all the combinations of these two boolean variables. All these combinations will result in different behavior in this method, so we want to make sure that our code works in all those cases. Since the base price is being calculated as we go along, we can also use log messages to make sure that it's being calculated as expected. Anyways, these are just things to keep in mind as you write code that gets more complex with these control flow statements. In our app if you hit the- button too many times we get a negative number of cups of coffee. That's a problem, because what does that even mean? We probably shouldn't allow this to happen in our app. And the earlier we deal with it within our app, then it will cause less headache for us later on. For example, we don't want to submit a bunch of orders to the coffee shop with a negative number of cups of coffee. And at the other end of the spectrum, there probably should also be a maximum number of coffees that we allow the user to order in a single time. We can't really serve 10,000 cups of coffee at a time. Now that we've identified the problem, let's decide on a better behavior for our app. How about if we only allow the customer to order between 1 and 100 cups of coffee? In our app when the user tries to press the- button and it's already displaying 1 cup of coffee, then the quantity shouldn't go below that. Likewise, if there are 100 cups of coffee and the user continues to press the + button, the quantity should stay at 100. We can do this by something called input checking. By checking what the user inputs into the app, we can recognize bad input as soon as possible and then prevent the app from continuing the normal flow of execution. For this quiz, make this change in your app. Assume that the app always starts at two cups of coffee when you first launch it. To find the right place to make the code change, think about when the problem first occurs. What button does the user press, and what code is triggered by that button? Since the app has different behavior depending on whether the number of cups of coffee is valid or not, think about using a control flow statement like an if else statement. That way, the logic in the app can be different based on a certain condition. If the user is trying to order a number of cups of coffee outside of these bounds, then figure out how to stop the app from continuing. Once you make these changes, answer these questions. Which method did you modify so that the quantity does not go below 1 cup of coffee? Write your answer in this box. Then, which method did you modify so the quantity doesn't go above 100 cups of coffee? Write your answer in this box. As a hint, it may be useful for you to know that you can put a return statement anywhere inside a method and that will cause you to exit the method early. Then the rest of the code after that will be skipped. Check the end chapter notes for more details. As a challenge, you can extend the app to also add a toast message that explains to the user why the quantity isn't updating when it hits these bounds. This is what the toast message could look like in the app when you've hit the lower bound. If I hit the- button a bunch of times to try to go below 1 cup of coffee, it shows this toast message. You cannot have less than 1 coffee. By the way, if you want to test that the upper bound works, instead of tapping the + button 99 times, you can just make a temporary change in the code. You can change the initial global quantity variable in the Java file and the initial quantity value in the XML to start at a higher number like 99 instead of just 2. Then, you'll only have to hit the + button a couple of times to go over 100 cups of coffee. I highly recommend testing this to make sure that your code works as expected for the upper bound. When you're done with all of this, go ahead and continue. We're going to start by looking at the lower bound first. The only way you can get the app to go below one cup of coffee is by pressing the minus button when there is one cup of coffee. Remember that the minus button triggers the decrement method in the Java file. So we need to modify the decrement method and prevent the app from updating the quantity on the screen. I open up the code in the Java file for the decrement method. Once we're inside this method, we don't want this line to be executed if the quantity is already 1. Otherwise, this line of code is going to cause a quantity to change to 0. I'm going to insert some code at the top of the method. I'll create an if statement, because I only want this logic to be executed if quantity is equal to 1. Remember in Java that if you want to check if two values are equal to each other, you need to use the == sign. The = sign means something else. Anyways, going back to the code. If the quantity is not 1, then we'll just skip this whole block of code and we'll continue with updating the quantity. Inside this if statement I'm going to write the return statement. This was the hint that I gave you earlier in the quiz. If the method's return value is void then you can just say return; with no return value. This means that we should exit the method immediately without executing the lines of code below it. So we skip updating the quantity variable and showing it on screen. If the quantity is not 1, say the quantity is ten, then the test condition is false and we skip over this block. We continue with this lines of code. Now, let's look at the case where the upper bound. The only way to hit 100 is by pressing the plus button when there is already 100 cups of coffee. The plus button triggers the increment method. So we need to modify this method to prevent the app from updating the quantity to a 101 cups of coffee. Within the increment method we add some additional logic like we did for the decrement method. If the quantity variable is currently at a 100 then we should exit the method early. Otherwise we should continue by incrementing the quantity by one more cup of coffee and then displaying it on the screen. Let's run this on our device to see what happens. Okay, if I hit the minus button a bunch of times, then it just stops at 1 cup of coffee. In order to test that the upper bound works, I'm going to change the initial quantity variable in our Java file to be 99 cups of coffee. I'm going to make a similar change in the layout as well. Nine cups of coffee is $195. Now I'm going to run it on the device. If I hit the plus button a bunch of times, you can see that it stays at 100 cups of coffee. Nice! Our code works. If you chose to do the challenge problem, here's the solution code. Within the increment method, if the quantity is already at 100 cups of coffee, then we show this toast message before we exit the method early. To create a toast message, you call Toast.makeText and you pass in three different input arguments. You pass in a context, which is this activity, you pass it a message, which is you cannot have more than 100 coffees in this case. And we also specify how long it should show up on screen. We're just saying the toast message should show for a short amount of time. All this code creates a single toast object, and then we call a method show on that object. Similarly within the decrement method, if the quantity is already at 1 cup of coffee then we show and error message right before we exit the method early. Again, this statement creates a toast object with this message and then we call the method show on it. By the way, we use this site to help us figure out how to display a toast message in our app. Here's some sample code that you could have used. In general, it's a good idea to let the user know what's happening, with an error message or some other indication in the user interface. Otherwise, they might think that the app is broken and not responding to their button clicks. Now that we have the order summary, we need to send it off in an email so that we can actually get our coffee. This is what it would look like when we hit the Order button. It opens up an email app on the device with a prepopulated message containing the coffee order and a custom subject line. In order to accomplish this, we need to understand a new topic in Android called intent. And intent is a message that requests some type of action to be performed by another app component, such as an activity in another app. This is a powerful part of the Android framework. Because our app can leverage functionality that other apps provide like sending an email, opening the camera, reviewing a map. It lets us be efficient and smart as developers, because we're not reinventing what other apps already do well. Think of sending intents like tossing a ball to someone. In the same way that a person can toss a ball to another person, an app component can send an intent to another app component. Here are some examples from apps that you might recognize. In the Google Keep note taking app, a user can hit the camera icon to take a photo. While the Google Keep team could have written their own camera functionality, instead they get it for free by sending an intent to open up the camera app on the device. Similarly, in the Yelp app, clicking on the location of a business sends an intent to open up a maps app on the device to provide turn by turn navigation instructions to the user. And lastly, for a restaurant page in the Google Maps app, clicking on the Call button sends an intent to launch the Dialer app so that the user can make a phone call to the restaurant. The coolest part about sending intents is that you don't have to know precisely which app is capable of handling it. There could be multiple apps on the device that could handle the intent, but ultimately only one needs to handle it. Using our analogy, when you throw the ball, you don't have to know who you're throwing it at, as long as someone catches it. Let me show you what I mean. For a restaurant listing in the Google Maps apps, clicking on Websites sends an intent to display the restaurant website. Now, the Maps app actually doesn't care which web browser handles the request. If the user only has one web browser installed on their device, then that app will automatically handle the request. However, if the user has four web browsers installed on their device, then the Android framework will pop up a window to ask the user to just pick one. This is what it looks like. The pop-up window is known as a disambiguation dialog. Once the user makes a choice, then the system sends the intent to the selected app to handle the action. And in this case the restaurant website is displayed. Now let's move on to talking about what's contained inside this ball that represent an intent. You can think of an intent as a message specifying some operation to be performed. It contains two primary things, the general action and some data to act upon. You can also specify additional information such as category, component, and extras, which is literally extra information. All of these things are used by Android to determine which app component can actually handle the intent. For example a maps intent would contain the action ACTION_VIEW, and the data would be the latitude and longitude coordinates of the location that we want to see. The rest of the fields can be blank. Then, any app that's capable of displaying latitude and longitude coordinates can be used to handle the request, which is probably any maps application. Another example is to use an intent to dial a phone number. In this case, you would compose an intent where the action is ACTION_DIAL and the corresponding data is the telephone number to call. Notice that the format is in the form tel, colon, followed by the number. This formatted string is called a URI, short for uniform resource identifier. This is a standardized way to structure data so that it can be properly processed on the receiving end. Think about it like a mailing address, it follows a structure so that it can be delivered properly. In case of sending an intent, a URI is needed so that the data can be properly passed to the receiving app component. Depending on the data encoded in the intent the scheme may change, such as this case or the geo case that we saw earlier. In this coding task, I want you to use an intent to send an order summary to an email app. But first, take some time to experiment with writing code for different intents listed in the Common Intents guide. See the Instructor Notes for the link. You can also do a web search for common intents, and it's the first link that pops up. There's a really useful article that you can use to find out what's possible on Android. For practice purposes, let's try creating a maps intent. The documentation had some useful information on the action and the data URI scheme that you should use for a maps intent. Again, it shows geo:Latitude,Longitude. If you scroll down, you see some example code. I'm going to select this and copy it. Now to run this code, let's just paste it inside the Just Java app. We could create a brand new application to paste the codes so we can run it there, but since Just Java's already up and running, let's just use that. I'm going to highlight all this code within this method and just comment it out temporarily. I did that by hitting Cmd+/ on a Mac, and on a windows it would be Ctrl+/. Now none of this code is going to be executed. When the order button is clicked I want to send a maps intent. In this line of code, we're creating a new Intent object using the new keyword in Java. We're calling the Intent constructor, and passing it a ACTION_VIEW. Note that when you see something in all caps in Java, it means it's a constant. A constant is a variable whose contents, once set, never changes. In this case, when composing our Intent, we use official intent actions, such ACTION_VIEW or ACTION_SEND, which are defined as constants within the Intent class. So to recap, this line of code creates a new object instance called Intent. And then on the Intent object we can call different methods like setData. We want to set the data URI to be a certain set of latitude and longitude coordinates. Currently this variable is unrecognized in our app, so I'm going to replace it. This part of the code creates a URI from this string here. And then this URI is set as the data field within this Intent object. Now we have our maps intent created. Down here, we have some code that looks a little bit confusing. There's a lot going on, but essentially we're just preventing the app from crashing by checking to see if the Intent can be handled. In terms of our ball analogy, it means that if no one is available to catch the ball, then the ball drops and there's an explosion, [SOUND]. Because the system doesn't know what to do next, and that's why we need this line of code here. We're checking to see if there's at least one component on the device that can handle this Intent. If so, then this condition for the if statement is true, and then we execute the line of code here within these braces. We go ahead and start the activity with this Intent. If there's no app component on the device that can handle this Intent, then this test condition is false. And we skip this block of code and we do not send the Intent. After you've finished experimenting with i ntents go ahead and extend your app to have this functionality. We're going to use an intent to send the order summary to an email app. And then we're going to populate the email message with this text and this subject line. Be sure to also remove code that displays the order summary within the Just Java app. Once it shows up in the email app, we don't need to anymore in our app. As a reminder, this is what the app should look like. There's no more order summary field anymore. And when I hit the Order button we go straight into the email app. Now all the user needs to do is populate the To field and then they can send the message. Hopefully, you had a chance to experiment with using different intents from the Common Intents guide. For example, I showed you earlier that I modified the submitOrder method. I commented out all the existing code and then, added the maps intent code. When I run the map on my device, when I click on the order button, instead of uploading the order summary, it'll actually send an intent to the maps app. The Google Maps app receives the intent and then updates the map to show the location that we requested in the intent. Even if using these intents doesn't make sense in the context of our coffee ordering app, It's a good place to practice creating intents. Let's undo this change and then get back to our real tasks. In order to add this feature to our app, we need to use an intent to send the order summary to an email app. If you had no idea how to accomplish this, you could do a web search. I did a search for email intent android. A bunch of useful links pop up like a Stack Overflow post and a tutorial. But the common intents guide pops up and says it's from the official Android Documentation, I'm going to click on that. In the side by here there's a link on how to create an email intent, so I'm going to click on that, this shows you how to send an intent to compose an email with optional attachments. Looking through the documentation there are two code examples. After reading this comment we want this second code example. This is because we want our intent to be handled only by an email app and not by a text messaging or social media app. Let's select this code and copy it, and then we're going to paste it into our app. Looking at the code for our just Java app where should we actually paste this code snippet? Well, we want to send the order summary off to the email app as soon as we have the complete order summary. And the place that we have the complete order summary is after this line of code here which creates the order summary and then stores it in a string variable called priceMessage. So I'm going to add a new line here, and then insert our code. Notice how we're creating a new intent object using the constructor with the new keyword in java. We're passing in one argument as input into the constructor to initialize this intent object. The argument is this constant called Intent.ACTION_SENDTO. Remember the convention is that when you see something in all caps in Java it means it's a constant. A constant is a variable who's contents should never change once it's set. In this case when we're creating our intent we're using official intent action. ACTION_SENDTO which is defined as a constant in the intent class. Then we call some methods on this newly created intent object. We set the data to be a URI of this format, "mailto:", that way all the email apps will handle this intent. Then we add some extra data into the intent. We don't need to specify the two field of this e-mail so I'm just going to delete that line. We do, however, want to specify the subject of the e-mail message. So I'm going to replace this with actual subject line. Just Java order for, and then add the persons name. Then these next couple of lines of code check if there's an activity on the device to handle this intent. If there is then it's safe to send the intent and recall start activity using this intent. If there's no activity on the device to handle the intent, then we skip this block of code and we skip sending the intent. Now, let's run the app on our device. Now when I click on the order button, it sends an intent to an email app on the device. By default, the Gmail app is going to handle this intent. In a code since I specified a custom subject line, it shows up here as just Java order for Kaptain Kanal, which is the name that I entered into the app. Now, the original quiz question asked us to populate the email subject line, as well as the message body with the order summary. So let's go do that now. Looking back the the documentation for the email intent, I'm going to scroll up to look at the intent extras. We need to add an intent extra for each additional piece of information we want to provide about the email. For example, we could have an intent extra about the recipients of the email And we can have an Intent.EXTRA about the subject line of the email. But this is what we really want. We want to add an Intent.EXTRA to specify the body of the email. Again, Intent.EXTRA_TEXT is a constant defined in the intent java class. If I click on it you'll see more information. It's defined as a string in the intent class. And the constant value is this string right here. In the Just Java app when we create the intent And we're going to populate this extra, containing the body of the email message. When the email app receives the intent, they'll know to check for this intent extra to find the body of email and then they can populate that. Into the user interface. Let's make that code change now. I'm going to select this line of code, that puts one extra into the intent for the subject of the email. On the next line, I'm going to paste the code. Now we're putting a second extra into the intent. The extra is going to correspond to Intent.EXTRA_TEXT so that we know that it's for the body of the email. The second argument to this method is going to be the actual body of the email. The body of the email should just contain the order summary and that's sorted in price message so I can just copy this variable over to here. To recap, for the intent object we're calling a method putExtra to specific the email subject. In the same intent object we're calling the put extra method again to specify the body of the email. And the body of the email is the order summary. Now let's run the app on our device. once I complete order, I can click the button to submit. We send an intent to the email app with the email subject populated and the summary shows up now. Woo hoo! For the third step of this task we're going to remove the code that displays the order summary in the Just Java app because now it's going to show up in the email app. I'm going to start by modifying the activity main layout to remove the order summary text views. At the bottom of the layout, I'm going to delete the header as well as the TextView that would show the actual order summary. I'm going to save that and switch to the Java file. In the main activity Java file, I no longer need this display message method, which would update the order summary text view because this view with this ID doesn't exist anymore. Since I deleted the display message method, Android studio now gives me an error saying that this method doesn't exist, so I'm going to delete this. Looking back at our code, this makes sense because when we click on the order button, It's going to call the submit order method, we're going to do all this code, which also sends an intent to the email app. There's no need to display the order summary within our app any more. Let's verify that the app still works. When you delete large amounts of code, it's easier to check immediately that it works and undo the changes if there's a mistake, rather than trying to find it out later. And the app still works. Nice job. You added an intent to the just Java app. Intents are one of the core parts of Android, but there are still many more Android components that can help you build better apps. I recommend that you check those out on your own after you finish this course. When we put an app on the Google Play store. We'll have a whole range of users. It's hard to anticipate, what type of device our app will be running on. Maybe a phone or a tablet, maybe an older version of the Android platform, or maybe a different language than what we're using. There are many best practices that you can follow when building your app. To make it work well for all these types of users. One best practice, is to localize your app. There's a handy localization checklist that you can refer to. Localization means, adapting your app to different locales else. Meaning language and country combinations to make it a positive user experience for all types of users. At the surface level, this can have an impact on the design of your app, as well, as the texturing that appear in your app. For now, we're going to focus on how we can make your app support different languages. First, let's look at the device experience from a user's perspective. If I prefer to use a different language, I can go into the Settings app and then tap on the Language an Input setting. If I tap on Language, then I see the whole list of languages that are supported on Android. It includes character based language,s like Chinese and right to left languages like Arabic. I'm going to change the language to Spanish, and just like that all the text is now showing up in Spanish. You can see this across the whole Settings app. If you check the other apps on the device those will appear in Spanish, if the developer chose to support that language. However, when you open up our Just Java app, it's a jarring experience because everything in this app is still in English, while the other apps in the device are in Spanish. So how do we make our app support Spanish? So far, we know that our app can contain Java files and Resources. We can provide default resources for our app, but we can also provide alternate resources depending on the user's physical device size, language setting, version of Android, or number of pixels on the screen, to name a few. In our gesture shove app, we can provide default text rings in English. We can provide alternate text strings in other languages. So if someone has French as a default language on their device, the system will automatically load the French Translations instead of the default English ones. This article explains how you can support multiple languages in an app. Scrolling down we can look at the project structure. Within the res directory you can add another subdirectory that contains resources for a certain language. This is the default values folder and when choosing to put all the English text strings here. In the values es folder, we have all the Spanish text strings. In the values dash fr folder, we have all the French translations. If the user chooses Spanish as a language on their device, then the system will load these resources from the values es folder. If this folder don't exist, then the system which is fallback to the default resources. If the user has French as a default language on their device, then the system will load these resources. By the way es is the language code for Spanish and fr is the language code for French. Android uses the ISO language codes. Here are some examples of languages. And the two letter language codes that correspond with them. Let's go back to implementation details. In order for the system to switch out different translations for the text in our app, we need to isolate all the text from all the other logic in our app. We do this by creating a string set XML file in the values folder. This is an XML resource file that contains a list of all the string resources that are visible to the user. This is the first time we're seeing XML be used for something other than defining a layout. This is defining a list of resources. This is one string resource, and the name that we used to refer to it is called Title and the value of this string is my application. This is another string resource and we referred to it using, hello underscore world and the actual value is hello world. Then in the values es folder we can create a strings dot xml file, but now these have the Spanish translations of those same strings. This string resource still goes by the name of title, like here, but now the value is the Spanish translation of my application. The same applies for the hello world string resource with the Spanish translation here now. And this is one more example of the French translations of the strings dot xml file. Once our strings are declared as resources, we can then refer to them in the XML or Java using the appropriate syntax. In the Java code, we refer to strings like this. In the Java code, this is how we reference string resources. Firs,t we call the method getResources to get the apps resources. And then, we call getString and we pass as input the resource ID of the string. In this case, it's R dot string dot hello underscore world. String is a resource type and hello underscore world is the name of the resource. All of these on the right hand side, ends up becoming the hello world string and it's stored in this string variable. This whole expression evaluates to hello world and gets stored in this variable. By the way, this is similar to how we refer to image resources in the Java code. You can add dot drawable dot photo or whatever, the name of the image is. In the XML, we can refer to the strings using the add string notation and then the name of the string resource. Now, the XML and the Java code can stay the same, regardless of what language the user has chosen on their device. We don't need a different layout file that has the Spanish translation for the text attribute here. Android will load the correct translations depending on the primary language selected on the device. It's pretty awesome? Let's walk through each of these steps, so that you can see how to localize the strings in your app. First, we want to extract all the hardcoded strings from the XML and Java files into a default strings dot xml file. Then we're going to update the XML and Java files to refer to the appropriate string resources. And then, we're going to provide alternate translations in another language. Let's start with step one: interactivity main layout. Let's look at the strings that are currently hard coded into our layout. We have a text view that displays the word toppings as a header in the ui. Currently the English word is hard coded into the layout, and we even get a warning from Android studio talking about it. And it recommends that we use a at string resource, so let's do that now. When I delete this and then type in @string/toppings as the name of the resource. But now, I get an error saying that Android Studio doesn't recognize this resource. I need to go into the strings dot xml file and define it. Looking at the file structure of our app, I can go into the res values folder and look for the strings dot xml file. There are a couple of strings that are already populated here and I'm going to add another one. I just declared a new string resource with the name toppings and the value is the English word for toppings. The name of the string resource isn't going to change. But that chance added value will change depending on the language. Notice, that I added a comment here to describe where the string is being used in app. This will help the translator or the translation service who's helping out, to understand the context in which this string is being used in our app. We also specify a character limit. This is also helpful for the translator, when space in the UI is limited. For example, the translator won't pick a really long translation if they understand that we have limited screen real estate. Going back to our layout file, now the error is gone because the string resource exists. Now, how about hard coded strings within our Java files? Let's take a look at our create order summary method, which has a bunch of English strings hard coded in. Let's start by moving the phrase, thank you to the strings dot xml file. And, here's a new string resource with the name thank underscore you. Then we can update the Java statement, to refer to the new string resource by its name. We're using the getString method within the activity class, which takes as input a string resource and returns a string. The thank you string is then added on to this whole message. In certain cases, you might not want to translate part of a text string. For example, you might want to create a string and then leave spots that can be filled in later with variables. In that case, you want to mark off the spots that shouldn't be translated with an x lift tag. It wouldn't make sense to translate the user's name, but it would make sense to translate name. S,o when used properly this whole string resource would show up as named colon and then the person's name like Amy. With the x lift tag, you give it an id which is name and then you can specify an example like Amy. Inside the xliff tags, you would put the string that shouldn't be translated. In this case, where using the percent s formatter symbol, which specifies that a string will be substituted in here later. If you're wondering why we don't just add the strings using the plus symbol in the Java code. The reason is because declaring it as a string resource allows the translator to decide if this is the right format for the text. The translator may decide to flip the order of some of these words so that it makes more sense in the local context. The translator only has control over the words in the strings dot xml file. They don't have control over the Java code. For the xliff tag to be recognized you also want to add this thing to the resources tag in your strings dot xml file. Now, the Java code we're going to replace this part of the order summary with our string resource. Now, we're using the order summary name string resource and we're filling in the blank using the name variable. Normally, this gets string method in the activity would take as argument one input, which is just the string resource. But now it takes into arguments, because we want to pass in the name variable and have that be inserted into the blank spot in this string. If your string resource had two spots that needs to be filled and then you would pass in two additional inputs here, so that would be a total of three inputs to the method call. And so on from there. If you want any more clarification on how to use xliff tags, you can check the Localization Checklist, which is linked in the instructor notes below. So far, we've covered these two steps, and now we're going to look at providing alternate translations in another language. So in Android Studio, there's actually a neat little tool called the translations editor. You can access it by clicking on Open editor or you can right click on the strings dot xml file and then click on open translations editor. There's a column for the name of the string resource, and then the default value, which is the English translation right now. Each row corresponds to another string resource that we defined in our strings dot xml file. If we click on the globe icon here, we can add a new language. I type Spanish and add Spanish. You can click on the cell here to provide the Spanish translation for the string resource thank you. I'm going to type in gracias, which means thank you in my terrible Spanish accent. We can do the same for our toppings header, and this is the Spanish translation. I'm not even going to try to pronounce that. Now, let's rebuild our app. My device still has Spanish as a default language. And when I open up our app, wow I see that the toppings header is translated in Spanish. The rest is still in English because I haven't finished it yet. And then, when I click on the order button, then I see Gracias. It's awesome, that it worked. Behind the scenes the translation editor did a couple of things for us. It created the Spanish version of the strings dot xml file. When you click on that you can see that it automatically added the translations in. If we didn't provide Spanish translations, then it doesn't appear here. As a developer, you have the option of modifying the strings file directly or using the translations editor. If you want to add more languages, you can simply click on the globe icon here. Cool you have just finished all three steps for localizing a couple of strings into Spanish. Now, there are a few other hard coded strings that we missed, but this time, I'd like you to take the lead in localizing them. You'll find Spanish translations for these text strings in the instructor notes below. But you're welcome to pick another language of your choice. At the end, your app should look like this assuming that you chose Spanish. And then when you hit the order button, the email subject line and the message body are both in Spanish. Awesome, at this point you have completed localizing the text in the just Java app. Hopefully you've seen that with just a few modifications, you can open up your app to whole new audiences. Let's review our solution. Here's the strings.xml file where we pulled out all the possible strings in our app. For each string resource we provide a comment and a character limit to help the translator figure out the right translation. In our layout now we refer to string resources. There are no more warnings from Android Studio about hard coding strings in our layout. And here's a Spanish version of the strings.xml file with all their Spanish translations. If you open up the translations editor you can see the name of the string resources, the English translations, as well as the Spanish translations. Then in our layout file we can refer to all of these string resources. And now Android Studio doesn't have any more warnings about hard coding strings in our layout. Within our Java code we also refer to these string resources. Note that we also get the local currency with this line of code here. This is a utility function that formats the input price into the current c for the current local. All of the solution code is linked in instructor notes below. Gran trabajo, great job. Now let's explore further about what else can be done with resources in Android. Great work. Now we're just going to do a little more visual polish on the app. This will include learning about Android resources, styles, and themes. In the app, you may have noticed that all the headers have the same visual style. And you may have noticed that in the XML, that you had to add the same attributes to each of these headers, the Toppings header, the Quantity header as well as the Order Summary header when we used to have it. If you have a lot of views with the same visual style, it's good practice to try and reduce the repetition. By defining it in only one place and then referring back to that single place. That way if the designer you work with wants to change how all of the headers in her app look you can just change it in a single place and then it'll be updated everywhere. To do this we need to learn about defining styles in our app. A style is a collection of properties that can be applied to a single view. Properties can include height, width, padding, font color, font size, and more. Let's look at an example. In a layout file this text used specifies a bunch of different attributes. But we can replace all these attributes with a single line that refers to a style. One advantage to using a style is that you can separate the design of the view, how it looks, from the actual content of the view. And in the end, both of these tech's views would look the same on a device. Let's look at where the CodeFont style is defined. You can define the style within the styles.xml file, which is located in the res/values directory of your app. Now in this XML file, the root node has to be the resources XML element. Within that, you can specify as many style XML elements as you want. For example, this is one style, and you could add more below this. For a given style XML element, you need to specify the name. In this case, it's CodeFont, but you could have picked a different name. Then you can add a list of all the different properties that should go in this style. A property is defined using the item XML element. For a given item, you have the name of the property, and then the value of the property is in between the open and the closing tags. If you want to create a style that builds off of existing styles, you can specify the parent attribute here. But you don't have to specify a parent. This is optional. You can just define the style. And then add in the properties that you want. Then in your Layout File, you can simply refer to this style CodeFont. This is similar to how we refer to other resources in our app, like drawables, with the at drawable notation. Here's we're using @style/ the name of the resource. Also note that we specify the style using style equals and not Android: style. Let's go back to our app for an example. Say we want to make all of the headings a dark purple text color, font size 20, and make it italicized. We could set the same attributes on each of these header text views or we could define it once in a single style, give it a name, and then refer to that style every time we need it. To define a style, go to the Resources, Values directory and find the Styles.XML file. If it doesn't exist you could always create it by right clicking and going to new resource file, and then creating a style on XML file. As we saw earlier, this XML file, like the strings done XML file, doesn't define a layout. It's a resources file. In this case it defines a list of style resources, while the strings on XML file define a list of string resources. By the way, this is a comment. So you can put anything you want in between this opening symbol, and this closing symbol. And this is just supposed to describe the XML below it. I've just defined a style called CustomText. It contains three properties within it. These are three attributes that can be applied to a TextView. So we have the android text size property, android text color and then android text style. The value for each of these attributes is shown here in between the item opening and closing tags. We have the 20sp font size, the purple font color, as well as the italic text style. The possible attributes here depend on what view you are applying the style on to. If you're going to use a custom text style on a text view, then all of the text view attributes that you're already familiar with can go here. If this style would be used on an image view, then the image view attributes would be valid here. Let's copy the name of this style and then use it in the activity main layout file. For the toppings header, I'm going to apply a style onto the text view. I'm going to refer to the style using @style, slash, and then the name of the style. Then I can delete any attributes that would have already been defined in the style. For this example I don't want the headers to be capitalized, so I'm just going to erase this. If I had a different text style or a different font color specified here, I would also delete that, now that I have this style here. Now I'm going to apply this style to the other header. For the quantity header, I'm going to delete this. All caps, attribute, and just replace it with this style. This is what the app looks like with the new style applied to the header text views. I could have put additional attributes inside the style, but it's really a trade-off and it's up to your own preference. Sometimes you want to leave the attributes inside the layout file, and sometimes it's better if it's inside the style. All right, so the example I just gave you is not the style we actually want. Instead, you'll need to use these attributes. We want our headers to have a height of 48dp with text vertically centered within that and with the text capitalized, as well. These values came from the material design spec, you can see the instructor's notes for more details. We haven't covered the gravity attribute in depth but this just means we're centering the text vertically within the text field. So I want you to make a new style in the styles.xml file called Header Text Style. And it should contain these five properties. Next apply the style to all the header text views within the layout. Make them all refer to this header text style. Be sure to remove any unnecessary XML in the layout file. For example, you don't need to set the text sides of this header text view any more because the text size is specified within the style now. This is what the app should look like when you're done using a single style for the headers. Check these boxes when you're done. In our apps res values folder we modify the styles.xml file. We added this style called HeaderTextStyle. It contains five properties as specified in the quiz. This is the attribute name for the text view and this is the value. Then in the activity main layout file we can modify all the header text views to use this style. We specify style="@style/HeaderTextStyle". And this is the toppings header. We do the same thing for the quantity header. Now, if we ever want to modify how the headers look on our app. We can just update in a single place. When we run the app we can verify that all the headers look the same. The app is looking great. Now there's only once more co change that we need to do, and that is to select colors for the theme of the app. We just finished building the Just Java app. How do you feel? I feel great. I feel ebullient. Kunal. I feel like a butterfly on a flower. Kunal. I feel slightly awkward. Kunal, I was actually asking the students. Oh. Take some time now to share with us on the discussion forum how your journey has been. I grew up not seeing particularly well, and I didn't know that I wasn't seeing very well, but what I did know was I wasn't doing well at school. I got my first pair of glasses and suddenly the world changed and I could start to see the board at school, I started to do well in my exams. If my situation were different this may have never happened. I wanted to make sure that that wasn't the case for anyone else. Peak Vsion was owner of a challenge. People who can provide eye care tend to live in cities and towns and people who are blind tend to live in very rural difficult to reach areas, particularly in low income countries such as Kenya. And so the real vision was to try and connect the two using mobile technology. Initially, we moved out to Kenya to do some research, which was setting up 100 clinics. I looked at all of the stuff that I was having to cut around in this eye clinic, which is over $150,000 worth of care. I thought can we try and transform this into a technology that's really portable and accessible. So we went about redesigning every one of the tests that were in the clinic with either a small phone app or piece of clip of hardware that could sit on the small phone, and allow it to be all performed on a smart phone by a technician, so without having to have expert healthcare training using a configuration of lenses and all sorts of complexities that would make it possible to hold your smart phone up, point it at someone's eye, and get a view of the retina. So we have a suite of Peak applications here, I'm going to show you the vision test. So what we do here is, it'll give us some on-screen instructions to stand two meters from the patient, and they'll get a letter E to look at. They'll point in the direction of the E, so this way it's going like that, so we swipe on the phone accordingly. Now the advantage here is the tester doesn't need to see what's going on on the screen, so they're just going to swipe whichever way the patient is pointing, even if they're giving the right or wrong answer. If they were to shake their head and say they can't see, we can just shake the device, now recorder not seen. And once the test is finished I get a vibration alert and a reading on screen. And so what we can do is then view their world based on our vision test using our sight sim application, which gives you the detected vision and the normal vision, and it allows you to walk around that person's visual world and really understand their level of sight impairment. The initial build of this were designed to be used within the study that I had moved to Kenya for, but one of the big things that we learn if you create a tool that's easy to use, it's low cost and is intuitive, it's likely to be adopted in any market. We often focus on impact in terms of economics in the sense of, how can I make money, or how can we take money out of this, whereas there's a huge economic value in terms of giving somebody their sight back. What we repeatedly saw in our clinics in Kenya, is we'd have young children supporting old parents or grandparents who should've been in school. So for that child it means they're like to never break out poverty. So moving the measure away from, what can I take out of this, to what could I put in, is a real way of actually assessing the economic impact. Then there's a huge number of areas where mobile developers can add value. I think it's almost limitless in terms of the way we could improve things. And by being able to contribute to making other people's lives easier or more efficient, you can then have a huge knock-on effect on hundreds, thousands, millions of other people. Kunal, we're done with lesson three. No way. Yeah the is right here now. So you're saying we're done with all three lessons in the course? All of it. Done. Congratulations to all of us. Awesome. [MUSIC] Hey there. Welcome to the first practice set. After every lesson, you're going to have practice sets with me to review what you learned in the lesson, and make some cool stuff. I bring four practice exercises to instill what you've learned so far. So first, you're going to install Android Studio, which is a program that professional developers use to make Android apps. Following that, you'll make your very first Android app and load it up on your phone. Once you're done with that, I'm going to walk you through how to make a simple birthday card application. Finally, you'll make you own custom card app and show other students your design process. Well, no time like the present to get started. So grab a cup of coffee [SOUND] and get to code. Writing code in an Internet browser is fine, but you're probably wondering what kind of tools professional developers use and how you get something like this actually onto your phone. This installation comes in two parts. First, we're going to install something called the Java Development Kit and only once we're done with that, then will we install Android Studio. I want you to think of Android Studio like a workshop. And this is a pretty special workshop because it's specifically designed for making Android applications. One where we have automated help that makes creating apps easier. The thing is, that while this workshop is great, it's pretty useless without tools and that's where the Java Development Kit comes in. Before we set anything else up, first we'll install the Java Development Kit. Essentially we're grabbing our tools. Then we set up our app making workshop by installing Android Studio. Now it's important that you do these steps in order and complete them correctly. If you don't have your tools ready then you won't be able to do anything in your workshop. The whole process of setting both of these up, should take you about 30 minutes to an hour if your Internet connection is fast. Okay, let's get started. Now you're going to install the Java Development Kit, but a few quick notes before we begin. So we've been calling the Java Development Kit like a toolbox. And what we mean by that is that the Java Development Kit is software that allows your computer to read and work with the Java programming language. This is sort of fundamentally different than a software program, because it's more like an upgrade for your computer. So as you're installing the Java development kit, it might seem a little bit intimidating. But what I want to tell you right now is do not worry about it. You're not going to break your computer. And we're going to go super slowly through the steps and explain what you're doing very explicitly as you do each step. That said, sometimes students run into problems. So I want to give you some additional tools to help you resolve those issues. If you do run into a problem, I've got three resources for you. First is the troubleshooting document, linked in the instructor notes. Second, is the forums and chat, where you can ask fellow students for help. I'll be checking in once in a while to see what problems students are finding and update the first document accordingly. So if you do happen to solve your problem, consider posting about your experience in the forums. When you're talking about an error, it helps to copy the text of the error. You can also take a screen shot of the error by using the keys Ctrl+Cmd+Shift on the Mac or the screenshot key on a Windows machine. Finally, when I run into errors, I often Google them. Nine times out of ten, you're going to immediately find somebody who's run into the exact same error that you have. And by the power of the Internet, a lot of people are going to have come together and help them resolve that error. So you can follow the exact same steps that they've followed to resolve your problem. Now if you're trying to figure out what to actually search with. My suggestion is to copy the error message that you're getting and add a word like Java or or Android studio to the end of it. Okay. Let's dive in. Now we're going to actually install our workshop, which is the Android Studio program. I suggest you watch me so that you can have a sense of what the process looks like, and then follow the text version instructions at your own pace. Also, keep in mind that these are large files. You're going to want to have a strong and stable Internet connection. For students with slower and more unreliable Internet, you might want to consider finding a wired Internet connection. Also, if things are taking a while to load or download and you're getting bored, feel free to go to the next node, which has a quick review quiz game that you can do while Android Studio is downloading. I've created the walkthrough for how to download Android Studio on two different operating systems. I have instructions for Windows and instructions for Mac computers. I'll give you a moment. Go ahead and click on which one applies to you. Okay, I'm going to be installing Android Studio on a Windows machine. Please note that this screen cast was done on April 7, 2015 and I say that just because sometimes the screens or the icons that you might see while installing Android studio could change depending on what version it is. We're going to give you a text version to go along with the screencast. Since it's easier to change the text version than to go through re-recording an entire screencast, that will be a little it more up to date than the screencast will. All right, so to start off, go ahead and open a web browser, and go to the Android studio website. It's linked in the instruction notes, you do not have to type this in. All right, so once you've arrived on the site, you should see a big green button that's pretty obvious that says Download Android Studio for wWndows, so go ahead and click that. All right and that's going to take you to the License for Android Studio. You're welcome to go ahead and read that. I'm going to scroll to the bottom, sign my rights away, and then click this Download Android Studio for Windows button. All right, we did want to download this, so we do want to keep it. I'm going to press Keep. Okay, and if you look right here, this is a little bit less than a gig of data. And that's about equivalent to downloading a movie file of reasonable quality. So you can judge how long this will take based on your Internet connection. Okay, once it's finished downloading, go ahead and double click the file. We did in fact want to run this. So click Run. Yes, we did want to allow it to make changes. All right, and now we're at the Android Studio Setup Wizard. This is going to guide you through a collection of screens to set up Android Studio, and pretty much always we're going to just select the default. All right, so I'm going to hit Next, I want all these boxes checked. Note that this requires 3.8 GB of space, and we only download about a gigabyte, so after this, there's going to be even more downloading. I'm going to hit Next. This is a license agreement here, you can go ahead and read it if you'd like. I'm going to go ahead and hit I Agree. Oh yes, I agree more. Okay, I'm all right with all of these standard install locations. All right, going to say next on the emulator setup. We'll talk about this later. Sure, let's make a Start Menu folder and I'm going to hit Install, which will bring me to this screen. Of course, if you like staring at loading bars feel free. All right, it looks like it completed. I can go ahead and look at the show details. And I'm not seeing anything here about huge errors, so that's good. All right, I'm going to go ahead and click Next. Okay, so the install looks like it finished, we click finish. This is the little loading screen for Android Studio when it starts up. Okay, now this is asking me if I have some settings from a previous version of Android Studio, and I'm pretty sure that you don't. So you probably want to hit the I don't have a previous version of android studio, or I don't want to import my settings, and go ahead and hit OK. Just going ahead and downloading a few more components for me. Now once you see this screen, you know you've got Android Studio up and running. But the real test to see if you did everything correctly will be if you can make your first app using it. All right, so this completes the installation video. And now you're going to do this process on your own. All right, I'm going to download Android Studio on a Mac. Note that this screen cast was done April 6th, 2015. And the reason I'm saying that is because sometimes, this process will change. We will always provide you with text instructions for the install process, and we will keep those instructions up to date. So things look a little different here and there. Don't worry, check out the text install instructions and with that little mini note lets get started. The first thing you're going to do is click at the instructed note below to get to the Android studio homepage. Don't try typing this out, just click the link in the instructor notes. Once you're here there's going to be a pretty obvious button that says download Android studio and it should say for Mac, go ahead and click it. At this point you'll see a license agreement, you can read it if you like. And then go ahead and scroll down, click that you've read it and then click this download Android Studio for Mac button. Okay, so it's started downloading here for me. Now you should be able to see that this download is a couple hundred megabytes. Once it's downloaded, go ahead and double-click it. You should see this big beautiful screen that says Android studio. And as with most applications, you're going to go ahead and click Android studio and drag it into your applications folder so it'll copy over. After you've successfully done that, you can go ahead and double click Android Studio, which will actually try to open Android Studio. You might get a warning about it being a download from the web. But we did mean to download this and we did mean to run it so go ahead and click Open. This little screen should appear to load up the installation process. All right, and here we are at the Welcome Wizard. What follows is going to be a series of screens and licenses and you pretty much just want to keep the defaults. And you click Next. This is a screen asking me where my Java development kit is. Now, we just installed that and it's actually making a guess about where it is. If it isn't guessing, you can click the Detect button. And if that isn't working, you can try navigating your file system to go exactly to where you downloaded it. If you're having trouble with this step, It probably means that there were issues with downloading the Java Development Kit. You might have downloaded the wrong file or just something might not be configured right. Try going through the instructions again or checking out the troubleshooting documents. Everything seems to be working here so I'm going to go ahead and click Next. Now we're not doing anything too crazy so I'm going to choose a standard installation. Here are some of the licenses that I was talking about. Go ahead and click on this first license and say, Accept. That'll accept all these licenses down here. You'll have to click on the next license set here, and also hit Accept. And this will let you finish the Android Studio Setup Wizard. Okay, when I click Finish, it's actually going to download a lot of stuff. And what all of this entails is downloading a couple gigs of data, which is sort of a huge amount of stuff to download. So be patient, this might take some time. If you're getting bored of staring at a loading bar, you can go ahead and click to the next video, where we. We have a little review game to go over some of the stuff we've already learned. As you see this window, go ahead and type in your password, and the candy cane strips here mean this is close to done. Awesome. And once you're done, you see this screen. Hopefully there's a lot of positive language like successfully, installation pass, successfully created. If you see any errors here it could mean that there are errors with the installation. But things look good so I'm going to go ahead and click Finish. Now once you see this screen, you know that you've got Android studio up and running, so great job. But the real test is going to be seeing if we did everything correctly enough that we can create out own apps using it. All right, so, now you've watched me do the steps once. I want you go ahead and download Android Studio yourself. If the downloading is taking awhile, but you still want to be doing Android stuff feel free to move onto the next node where we have a review game to pass the time while things install. Well, that loading bar's going to take a while. Why don't we load some information to our heads while we're waiting for all that Androidy goodness to download onto our computer. What's going to follow is a series of quiz questions. Answer them correct, and you'll get a prize. Okay, you've got Android Studio up and running, awesome work. Now, you're going to participate in an important programming tradition. Making a hello world app. This is the basically the first step towards becoming an Android developer. And at the end of the lesson, you're going to take this hello world app and you're going to change it into the birthday card app. So, you might be wondering what exactly is a hello world program. Well, typically in programming languages, one of the easiest things you could do is print out some words to the screen. So therefore, usually the first program that will make it in a programming language is a program that will do exactly that. Print some words out to the screen. It's kind of like when you're studying a new human language, how you learn words like thank you or please or excuse me where's the bathroom? A sort of your first building blocks of that language. Okay, let's build the hello world app. A quick note before we get started. This video was recorded April 6, 2015. Now, my suggestion to you is that you don't follow along with the video. Instead, go ahead and watch the video through once. After you're done with that, we've provided some text instructions on the instructor notes. >From time to time, Android Studio is updated, which means that menus or screens can look a little bit different. And while the video might be out of date, the text instructions will be updated a lot more regularly. Okay, so, if you've closed Android Studio, go ahead and reopen Android Studio. You should be starting at this screen. I'm going to go ahead and click on this aptly named, start a new Android Studio Project button. All right, that should take you to this screen, where we have a couple of different options. The first one is the application name. This is the name that you'll see in the app bar at the top of the app as well as the all app screen of the device. Preemptively, I'm going to go ahead and they name this happy birthday. Okay, right below this we have company domain. And if this looks similar to a web address, you're right. Normally if you owned a web address, you type it in here. Now, at one point in my life I owned lylaujiwara.com. So, if I was making an app for myself, instead of a demo app for all of you, I will go ahead and change this to lylafujiwara.com. Now, you might be wondering why. Well, if I was planning to distribute my app on Google Play, this package name down here is something that I need to uniquely identify my app. Meaning, that across all of the people in the world who are making apps, this needs to be completely unique. Now, if we look a little bit more at the structure of this, the package name is actually the company domain reversed. So, instead of lylafujiwara.com, we have com.lylafujiwara. Followed by the application name with no spaces. So while there might be a couple of different app developers that make a happy birthday app, you're not going to have a bunch of app developers that all own lilafujiwara.com and are making a birthday card app. And in the way that the Internet is set up, if I buy lylafujiwara.com, that means I should have complete control over what is shown there and nobody else can buy that domain name. And if I own it and it's specific to me, then, that helps ensure that this package name is completely unique. So, I know that you only know about package names right now. You might not know what a package is. We'll talk about that more a little bit later. But the thing that you just need to keep in mind right now is that a package name needs to be unique so that Google Play and your phone has a unique way to identify your application. Okay, but you're not me and you don't own this domain. And since we're all practicing together and I want us all to have sort of the same set up for this app, I'm going to change this to android.example.com. And you should go ahead and use the same company domain name because I know that some of you won't actually own website domains yourself. Also, it will be back our code. And if you look below, you should see that it says com.example.android. Again, that's the reverse of Android example com. And that it says happy birthday after it. Okay, so the next thing that you can change is the project location. This is where all the files that have to deal with your app will be saved on your computer. Now, usually Android Studio will create a folder for your Android Studio projects. And the default is to just put your app inside this folder. And you can see that the name actually matches the name of the folder that it will be in. This is a pretty good default location, so unless you have any strong reason to change it, I'd go ahead to just click next. Okay, now this is a fun screen. It lets us pick what phones and devices that we're going to actually make our application for. Now, you're making an app for a phone and a tablet. And you're not trying to make an app for TV wear or glass. So, we're going to leave these all unchecked. The drop down right here shows us the version of the Android operating system that our application will support. We're going to go ahead and scroll up. You can see that the first public and widely used release of Android was called cupcake. With this release, Google started a convention where they would continue to go alphabetically. But name each operating system off of desserts or sugary treats. Cupcake was followed by donut and eclair. And this is why you'll see words like ice cream sandwich, honeycomb, and KitKat in the dropdown menu. Now below this dropdown, you'll see this handy help me choose link. This graph shows some helpful percentages of how many people who have Android phones use the different operating system versions. Looking at it, we can see that most users, at least of the time of this recording, are using the deliciously named KitKat. The percentages, show the percentages of people in the world using Google Play who will be able to use our app if we pick one of these as our minimum supported version. So if you pick the newest version of the operating system, which is Lollipop, at least at the time of this recording, only users with new phones would be able to download your app. And that would mean you'd only have about 0.1% of all of the phone users actually able to download your app. So you might be asking, why not make an app for all phones by picking the oldest version of the operating system? Here's a picture of the first commercially available Android phone. The T-mobile G1, which is also known outside the United States as the HTC Dream. It was released in 2008 and ran Android 1.0. Obviously a lot has changed since then. For example, apps like Google Wallet, which let you pay for groceries with the wave of your smartphone, require a Near Field Communication. A Near Field Communication or NFC, was actually a type of hardware that didn't make it into Android phones until 2010. So if you're making an app that requires NFC, there's no reason to even try supporting older phones like this that are running older versions of the Android operating system. Anyway, for the purposes of your app, I want you to use API 15 which is ice cream sandwich. This should work for about 90% of the phone users out there. All right, go ahead and click next. I want to interrupt here for an important update. Since filming the original video, the activity templates have actually been updated and changed. So, your screens are going to look a little bit different than what you're seeing in the video right now. If you're using Android Studio Version 1.4 or newer, you're going to see these screens instead. And instead of selecting blank activity, what I want you to do is select the empty activity template. This will generate the correct files that will allow you to follow along with the rest of the course. On this screen, you're given a bunch of starting templates you can choose from. Depending on what you're trying to make. You're going to go ahead choose blank activity, which is already selected, because it's the sublist one. And I'm going to click Next. Finally, this screen gives you the opportunities to name a couple of different files that are going to be automatically generated for your application. As you'll soon see, an application is composed of all the picture files, sound files, XML files, Java files, and more that are required to make the app. Basically, there are a lot of files that work together to make your application. We'll talk about this all soon. For now, take a look at the layout name. You've been working on XML layout files. So this is the name of the file we'll be editing in just a little bit. I'm actually not going to change any of these defaults. So you can go ahead and click finish. Now, depending on your computer speed, it might take a moment to set everything up. If you look down here, you'll actually see a little loading circle as well as a loading bar. And we can see a loading circle down here as well, meaning that it's continuing to think about things. So, take a break. Go ahead, stretch. And get some tea. I mean coffee. When you started programming, you used the XML visualizer. The things you can do in the visualizer, you can also do in Android Studio and a lot, lot, lot more. As such, Android Studio might look a little bit complicated. But to start making a application, you actually only need to know a few of the core functionalities. So really don't worry if you don't know what every single button does. I still look things up, and I sure don't know what every single button in Android Studio does. Okay, I'm going to go down here and click the Text tab. Looking at this middle part of the screen, I want you to think of this as being something similar to a document editor such as Google Docs. In Google Docs, you open a file, and you edit that file. In Android Studio, you open a project which contains many files, and you can edit any of the files within the project. If we go over here to the left-hand side, we can see all the folders and files that are inside of our project. If I go over to a folder and click it, it shows me the sub-folders. If I double-click a file, it opens a tab for that file. Here's where you could edit the file. And the tabs across are for switching back and forth between different files. I'm going to go ahead and close this file that I just opened by clicking the little x up here. As you're editing things in Android Studio, it does the work of automatically saving your work. Now if I do something really disastrous, like whoops, I accidentally select all this and then delete it, always remember that you can undo and redo in Android Studio. I'm going to undo that by going up here to the menu bar, and clicking Edit > Undo. And you can see right below it that we have Redo. Alternatively, if you don't want to use the menu bar, you can use the keyboard shortcut Ctrl+Z, or on Macs, Cmd+Z. And to redo, it's Cmd+Shift+Z or Ctrl+Shift+Z. Let's take a closer look at the left-hand side here. Everything here combined makes up your app. An app or an application on Android isn't a single file. It's a collection of images, layouts, and other code. Note that if you go up here, you can select a few different ways to view the files and folders in your app. Project, in particular, shows you what the folders actually look like on your computer. I'll click down a bit so you can see. All right, not to scare you, but when you made your app there's actually a ton of folders and files that were generated for you. To simplify things, I usually just stick with the Android view which is a little easier to navigate. Now back when you made your project, you chose where the project was going to be saved. If you ever forget, you can look up here at the menu bar, which reminds you where your project is saved. And if you're feeling particularly brave, you should feel free to even take a peek at what this folder structure actually looks like on your computer. For example, on a Mac machine, I could go to my home folder > Android Studio Projects. And then I see this HappyBirthday folder, and this contains all of the project files and folders for the application. So if I were to delete this folder or move this folder, it would really mess up things for Android Studio. Okay, so what we're going to be working with is the activity_main.xml file. It's located in the layout folder because it contains XML that has the design or layout of your application. I'm going to double-click. Now the contents of this file should look pretty familiar. It's very, very similar to the sort of XML that we were writing in the lesson. One big difference are these two attributes here. The xmlns attribute says that we're working with attributes that are specific to Android development and making layouts. XML is also used with websites, storing data, and other applications. So we use this xmlns attribute to specify that we're making things particularly for Android development and particularly for layouts. The fact that we use the word Android here is also the reason that we put android: in front of all the attributes that we use. If you'd like to learn a little bit more about the xmlns attribute, you can check out the instructor notes. The important thing to know is when you make a new application, these two things will be automatically included. And you should include them in any other layouts you make, otherwise your application won't work. All right, now down here, you're going to see two tabs, the Design tab and the Text tab. And the Text tab is actually the tab that you're usually going to be working with. Over here on the far right, you'll see that there's a button that says Preview. If you click on it, it'll remove the picture of the phone, and if you click on it again, it'll bring the picture of the phone back. This is a preview of what your XML looks like on a phone. It's very similar to the XML Visualizer. I'm actually going to go ahead and change the text attribute here to say, Goodbye World. Now if you do this on your own machine and you zoom in here, let me do it now, you should see that the text updated to say Goodbye World, pretty cool. If you click on the Design tab, you'll see a drag and drop interface for designing phone layouts. So for example, I could drag things over into the application. Over here in this area called Component Tree, it's going to list all of the different views that I have. If I click on a particular view, down here in Properties, it shows me all of the different attributes or properties that I can change. This list can be pretty helpful for discovering new layout properties. Also, if you right-click on any of these properties, such as this alignStart, it'll give you an option to see the documentation. This design view is pretty helpful if you're trying to quickly build a layout. But you get a lot more control over exactly where different elements go if you understand and know how to write code. Since we don't really need any of these additional options, and don't know what a lot of them do yet, it's easier to just stick with the Text tab. That concludes a quick tour of Android Studio. Next, we'll work on running our first app. Right now we see a picture of a phone. But this isn't actually on our phone. This is pretty similar to when we were working with the XML visualizer. Now we actually want to see our app on our phone. To participate, you're going to need a USB cable like this. Now this USB cable should fit your Android phone, which you will also need. What do I mean by fit? Well, I can pick up my phone and plug this cable into it. Now if you don't have these things, there's a slightly more complicated way you can get up and running. Which I'm going to talk about in the next video. But, if you have both of these items, I really encourage you to use a real device, its a lot more fun that way. All right. First things, first. Your phone is not set up to let random code from your computer run on your phone by default. So you're going to need to do a few steps to prep your phone. Okay, so the first step is to become a developer. This sounds a little funny, when would you know when you're a developer? Well, what this actually means is changing around a couple of settings on the phone, which will alow you to access developer options. Once your phone's set up, you'll connect your phone to your computer using the USB cable that I talked about before. Now if you're using a Windows machine, the third step for you, in Windows only, will be to install a driver. And a driver is an extra little bit of software that will allow your phone to communicate with your Windows machine. With Macs, this just works by default, so you don't have to worry about it. And finally, you'll install your app. Alright, let's stop doing these steps. On newer phones, running Android 4.2 and later, you'll need to tell your phone you're a developer. This is a pretty simple process that I'll show you right now. The way to do this is to navigate to the Settings menu. Once you're here, scroll down to the bottom and click on About phone. On this menu, also scroll down to the bottom. You should see something that says Build number. Okay, so take the build number and click it 7 times. Cool. So now suddenly, you're a developer. Wasn't that easy? Once you're done, go ahead and hit the back button. Now because of your new fancy title as a developer, you should notice that the phone has provided you with a new option, the developer options. Go ahead and click on that. Okay, now in developer options there's a bunch of fancy sounding options, but what I want you to do is scroll down until you see USB debugging. And then go ahead and click the little check box next to USB debugging to turn it on. And say OK. By checking this box, it's allowing your computer to put applications onto your phone. Awesome. Now that you've enabled that, you can take your handy dandy USB cable, plug one end into the phone, and take the other end and plug it into your computer. If you're on a Windows device, there's one more step to set up your phone and computer. Your Windows machine needs some software called the driver to communicate with your phone. I'll start by downloading the driver. For most phones besides Google Nexus phones, you can navigate to the Android OEM, which stands for original equipment manufacturers, driver website. A link is provided in the instructor notes. I'm going to scroll down to the bottom. Here I have a list of drivers for different phones, and I will go ahead and download the appropriate one. In my case, I have a nexus phone, so I'm going to go up on the page, and click google USB driver. This is again, for Nexus phones. Okay, so for me, I'm going to go ahead and download the google USB driver, Unzip it, I'm going to move this to my desktop. So at this point, I've downloaded the driver, i've unzipped it and I've put it on my desktop. What you need to do next is double check that your phone is actually plugged in. Okay let's look at our task bar. I'm going to click on the start menu and go to computer. In Windows Explorer I'm going to right-click on the word here that says computer. And then I'll go to manage. In this left pane here, I'm going to select device manager, so looking through this list, go ahead and find the thing that says other devices and expand it. Now you should see something here that refers to your phone. For example, NexusS, or ADB, which stands for android debug bridge, interface. OK. Okay, so I'm going to right-click and select update driver software. This is going to launch a wizard that looks like this, and I want to select the one that lets me browse my computer, because remember, I just downloaded it to my desktop. I'm going to do browse computer, and I'm going to go ahead and click browse. And I'm going to go to my desktop and hit OK and hit next. I might see some security messages like this. Go ahead and say, install. All right. Cool. So, this autoplay just popped up with my Nexus 6, so that's a good sign that now the computer's communicating well with my phone. I'm going to go ahead and close this. And the final window of the wizard, says that Windows has successfully updated your driver software. So that sounds awesome. Go ahead and click close. Basically at this point, your phone is ready to accept the application from your computer. Another way of saying that you can now install apps that you've built on your computer, onto your phone. Finally, were going to install our Hello World App from the computer onto the phone. To do this, you're going to go up to the top of Android Studio to this green play button, and click it. It will take about ten seconds or so for the next window to pop up so be patient. At the bottom of the screen, you should be able to see that there's some process being executed. Now, if everything went as planned, your computer should detect your phone and list it here. Make sure you have the Choose a running device radio button clicked and not the Launch emulator radio button selected. If you can't see your phone, try unplugging it and re-plugging it in. And then try restarting the phone. If that also doesn't work and you're on a Windows machine, you might have installed the wrong driver. If none of those solutions seem to solve your problem, we've created a troubleshooting document, which is linked in the instructor notes. And you can always try asking your fellow students for help on chat or in forums. Okay, but hopefully things are working. You can select your phone and click the OK button. After about five seconds you should see your phone looks like this. You've now successfully run your first android application on a phone. Awesome work. As we start thinking about our birthday card application, I want you to think about a friend who's having a birthday that's coming up. Now, my challenge to you is to change the app that we currently have to say happy birthday and then that person's name, and then to run that app on your phone. Remember, you'll need to change the main activity .xml code file the same way we practiced changing code in the Internet browser. Right now the text says hello world, but you should be able to find the correct attribute to change it to say, Happy Birthday and then your friend's name. After you've done that, press the green run button and install the app on your phone. Good luck. Okay, so that last practice question actually came in two parts. The first part was to go into activity_main.xml and change around the code in a very similar way to how you were changing code in the browser. The next part was to actually run this new app on your phone. So I'm going to go ahead and do the first part. I'll go over here, inside the res folder, layout folder, and then I see activity_main.xml. Double-click to open it up. Okay, now I'm looking at a TextView child view inside of a RelativeLayout parent. Now it's the TextView that I'm interested in. Okay, so I should ask myself am I changing something in the RelativeLayout, in the TextView, or both? And the answer is I'm changing something in the TextView. Another question is which attribute or attributes do I need to change? And to change around the text of the TextView, that is the android:text attribute. So I'm going to go right here. I'm going to delete the current value but of course leave the quotes, and then I'm going to type Happy Birthday Ben! All right, cool. So this point, I've done the first part of what I need to do, which is change around the activity_main.xml file. Now, I need to write it on my phone. And that was a pretty simple process. I go up to the top here and over to the green play button which will install the app on my phone. Now press play, wait about five seconds, and at that point, this Choose Device window pops up. As I just showed you, I'm going to select my phone, and then I'm going to hit the OK button. And it's a little bit hard to see, but Happy Birthday Ben appears on my phone. So, you might be wondering if you don't have a phone, what you can do. Well, Android Studio has actually provided a way for you to simulate a phone on your computer. This simulated phone has a fancy name called the Android Emulator. To start the Android Emulator, go ahead and go up to the Run button and press Run. You'll see a small loading circle down here. Now, whereas before I told you to select the Choose a running device radio button, you're going to want to choose the Launch emulator radio button. And here is a drop down of all the different types of phones you can simulate. Right now you should only have one, and it's most likely going to be a Nexus 5, which is the type of phone, and API 21 refers to the operating system level. And x86 refers to a particular type of hardware configuration. Anyways, this is the name for your simulated phone. And I'm going to go ahead and click OK to start the phone. Now after about ten seconds, you should see a black phone appear on the screen. You'll also see this window here appear, which will show any sort of error messages or activity messages from the phone. Okay, so here's my black phone, and I'm waiting for it to load. After a moment of that, I'm going to see this Android loading icon. After a little bit more time, you should see this welcome screen appear on the phone. To go ahead and start the phone, swipe up from the bottom. Now it's trying to simulate an actual phone, and the first time you load up an actual phone, you get all these help icons and dialogues. I'm going to just click OK. Now, if all goes well, your app should appear on your phone. It didn't for me, so I'm going to go ahead and try to run it again. Okay, since the emulator's already running, I can see it now under my Choose running device. So I'll go ahead and click it. And I press the OK button. All right, and it loaded up my code on my emulated phone. Now you should know that sometimes these simulated phones don't always work correctly the first time. For example, you might have this issue that I had the first time when I ran my simulated phone where it would just show the black screen or would just show the Android loading symbol, and it wouldn't go beyond that. These are actually fairly common errors when trying to start a simulated phone. And one of the reasons that we suggest using a real device. That said, for the most part they're solvable problems. So, if you are running into those issues, go ahead and look at the instructor notes for how to deal with these situations. We've provided a link to a troubleshooting document. Finally, since I have your attention, if you're having difficulty with your simulated phone, sometimes you have clues in this error output over here. All right, now we're going to take everything you've learned and make a simple birthday card app. The apps going to look like this. It's a digital card that you can show and share with a friend or family member. Then at the end of the practice set, you'll be making your own custom holiday card. So what I'm going to do for you right now, is breakdown the process of turning a drawing like this into code. And this is going to take three easy steps. And when you're designing application layouts, these are good steps to follow if you're not sure how to get started. Okay, so step one is to take the layout and select the correct views to use. Step two is to then take those views and position them on the screen. And basically, you do step two by choosing the correct view group and then selecting the correct positioning attributes. Finally, we add all of the stylistic touches in step three. This is where we take the views and add things like color or font related attributes. One thing you'll notice is that this card says Happy Birthday Ben, and >From Lyla. Now your name probably isn't Lyla and maybe you don't have a friend named Ben, so you can feel free to change this text around as we go through the example. All right, so we're going to go ahead and jump right in, let's start with step one, which is selecting the views. Given this application, what views do you think are included? Okay, so I see some text here, and I see some text here, which probably means that we're going to have some TextViews involved. Now, they're fairly separated on the screen and positioned differently, so I think these are two separate TextViews. Now in the background, I can see the Android party picture, which is an image, so this right here, I'm going to label as an ImageView. Great. So you've actually finished step one. Now that we have these two TextViews and this ImageView, we should decide roughly how we're going to get them to the correct place on the screen. All right, so on to step two, positioning. When you're thinking about positioning, the first question you should always ask yourself is what View Group you should use. Speaking of which, what View Group should you use? You only know about two of them, so which is it, Linear Layout or Relative Layout? Also, go ahead and back your opinion up with facts. Tell me why your choice is the best choice. To answer this question, let's compare the two so that you can choose. LinearLayouts are great for aligning views in rows or columns. They're a good way to divide up one space using layout weights that will expand or shrink views depending on the size of the display. On the other hand, RelativeLayouts are great for positioning elements relative to one another. For example, putting B below A, or putting C in the lower left-hand corner. RelativeLayouts also make it easy to overlap views. For example, here view A is overlapping view B. For our card, we don't really have a line of horizontal or vertical views. And as you can see, some of these views overlap. So in this case, a RelativeLayout makes a lot more sense. And with a RelativeLayout, I can use specific attributes to position these two TextViews. Instead of talking about all that here though, you'll tell me what do in the next few questions. Okay, so at this point we've got our drawing or layout. We've identified the views, and we've started our thoughts of positioning by picking a relative layout as our view group. This is a great time to start coding. Okay, so what I have opened here is the code that we were working on before, which is activity_main.xml located in the layout folder. Now it's first creating the views. We already have about half of the work done. We have a relative layout and we have one text view that says Happy Birthday Ben. To get all of the views you need your going to make an image view. You're also going to make one additional text view. Adding the additional text view should be pretty easy. The image view requires a little bit more work because you actually need that Android part of your picture. In the instructor notes, we've included a link to that picture so that you can download it. Okay, so I've downloaded the picture and I've saved it to my desktop. It's saved as androidparty.jpg. Now you might recall before when we added images our XML, we said that we'd saved them in a folder on the computer called the drawable folder. Also remember how our app has a bunch of files and folders associated with it, which we can see in the directory structure on the left. These include layouts, pictures, sometimes music, and so on. A lot of these types of files are going to be housed in the res directory, which is short for resources. The res directory contains sub-directories for all the image, text, layout, and other resources the app might need. And as we said, for images, there's this folder called drawable. For this app, all images should be placed inside of the drawable folder. Once you've put the image into the drawable folder, you can use the source attribute of an image view, and give it the value @drawable and then the name of the image. Note, when you're writing the image name you do not need to add the file extension. Okay, so now I'm going to show you how to actually put a picture into the drawable folder. Okay. This image is in the Instructor Notes. Go ahead and download it to your Desktop. Next, I want you to open Android Studio. In Android Studio, you can go over here and Right-click the Drawable folder. >From there, you should see something that says reveal in finder or reveal in explorer. Here I can see the Drawable folder. So right now I'm going to move the androidparty.jpg into the drawable folder and I'm just going to do that by dragging it over. Okay so make sure you're starting with the correct XML code. And if you don't have the correct code, you can go ahead and copy and paste it from the instructor notes. All right, first things first, download androidparty.jpg. Then take androidparty.jpg and move it to the drawable folder. Once that's done, go ahead and add the TextView that says, from and then your name. And after that, add the ImageView with the source attribute as android party. There's actually a lot of default padding in the code that you're working with. So you can go ahead and delete that. What do I mean by default padding? Well, it's this paddingBottom, paddingLeft, paddingRight, and paddingTop. You can go ahead, And just delete it. Finally, click the green arrow to run the app on your phone. When you've finished all of these steps, your app should look like this. Note, it's a little bit hard to see on this screen, but the text views are actually overlapping. That's completely normal and something that we're going to deal with next. All right. So during the last video, I already showed you how to download androidparty.jpg and how to move it into the drawable folder. If you're having difficulty with these two, go ahead and rewatch the videos, or go to the forums and ask other students for help. The rest of these, we're going to go ahead and do in Android Studio right now. Okay, so this is my happy birthday application code. Specifically, I'm looking at the file activitymain.xml, which is inside of the layout folder, right here, so make sure you're looking at the same file. Now one of the things that we needed to do was remove the padding, and I showed you how to do this in the video but I'm going to do it again. These four attributes right here, I'm not really interested in having right now. Okay, so that was pretty easy. The next I want to do is go ahead and make another TextView. That should be super easy because I already have a TextView right here that I can model it off of. I'm in fact going to go ahead and copy this TextView and paste. Now the TextView I'm adding is supposed to say from, and then your name. So I'm going to change that right now, and I changed this specific attribute because it's the text attribute. Okay so I've done two out of the four things. Now I'm going to go ahead and add the ImageView. Now I don't have an ImageView to copy off of, so I'm just going to start typing. If you don't remember what an ImageView looks like you can go ahead and check out the XML cheat sheet that we've provided for you. One of the neat things that Android Studio does is when you start typing something it'll pop up with a little auto-complete menu. Since what I wanted was an ImageView I'm going to go ahead and click on it. Well this is super helpful, because it gave me the android:layout_width and android:layout_height attributes without me needing to type them. I'm going to go ahead right now and just make these wrap_content just like the TextViews. And you can see how I don't even need to finish typing, I can just click on it. Okay, now if we go over here and look at the phone preview, I can see that it says Happy Birthday and I can just barely see that it says from Lyla. So, these two TextViews seem to be displayed somewhat correctly but I'm not getting any sort of image down here. That's because I still need to define the source attribute of the image view. After all, I haven't said what picture I actually want to show. So I'm going to go ahead and start typing that right now. I'll start with android, again, the auto complete pops up with src, so to save on typing I'll go ahead and click it. The auto complete even guesses what should come next. And if you remember from the lecture, I need to type @drawable. Now the question is, what comes after here? Well what comes after here is the name of the picture that I want to display, and more importantly that picture has to exist in the drawable folder. So over here, inside the rows folder, inside the drawable folder, I have androidparty.jpg, which is the image that I moved over. This is the image that I want to use. It's in the correct place. All I need to do is type the name without the file extension, which would be androidparty. Okay, and almost immediately you should see that the picture appears. Now this is looking pretty good, so great job so far. But before you move on, you should always, always, always, actually run your app on your phone. So I'm going to do that by coming up here to the green run button. And clicking on it, it's going to think for a little bit, and I could see that it's processing down here. Okay, and once this window pops up, as long as my phone is plugged into my computer and everything is set up like we showed before, I should be able to select the phone, and then hit OK. Okay, so this is actually pretty awesome. Our phone looks a lot like the example phone that we have down here. We got ImageView, we got our two Text Views up here. And we pretty much confirmed everything's working as expected at this point. Just going through the checklist items I've added a TextView that says, >From Lyla. I've also added the androidparty ImageView right here. I went ahead and removed that extra default padding and I click the green arrow and ran my app. Neat. So at this point you're ready to move on and fix this pesky little problem where our views are overlapping one another. All right, positioning. So this is what we have right now and like I said before, for the most part things are in the right place. The image seems to be pretty much centered in the screen, happy birthday is in the upper-left corner. Really, the only thing that's an issue is that From Lyla is not in the correct place. It should be in the lower-right hand corner. You can see here at our goal, we've managed to move it down here. Let's go ahead and fix this and turn it into this. To start, select the attribute or attributes that you need to position >From Lyla in the correct place on the screen. Namely the lower left-hand corner. Here's a list of attributes and you can go ahead and check next to the ones that you think you need. Once you've done that, submit your answer to see if it's correct. Once you know the correct attributes to use, open up your code and go ahead and add those attributes to the From Lyla text view. Okay, so let's look at the solution. If you said either layout_width or layout_height, those wouldn't be bad guesses. It's really important to choose these values carefully as as they affect the space that your element takes up. For example let's talk about layout_width. Suppose that I have a text box that says, hi. And I set the layout_width to be wrap content. By default, this will just stick that text box into the upper left-hand corner. Then, if I use another attribute to push it over to the right, the text box will be here. If instead, I use match parent, by default, hi will still be in the upper left-hand corner. But if I then try to set an attribute to push it to the right, it'll try to push this text box to the right. But it already is as far right as it could be because it's expanding to match the parent and fill the whole view group. In the case of using match parent, we can see that the hi text hasn't actually moved. So one thing that's hopefully clear for this example is that we're going to want to set both layout_width and layout_height to wrap content. So it wraps exactly around the content and then when you tell the TextView to be either to the right, left, above, below, it'll actually move that text to that location. Okay, so both layout width and layout height are important. TextStyle is an attribute for bolding or italicizing text, and it really doesn't involve positioning or spacing. Orientation is an attribute used specifically with linear layouts, to determine whether they are going to be vertical or horizontal. Because we're using a relative layout this also doesn't make any sense. Layout_weight is really useful for spacing out elements evenly but again, this is a linear layout attribute. Which leaves us with these attributes. All of these attributes have to do with relative layouts. Now these attributes layout_to Right Of and layout_below are categorically different than the layout_alignParent either Bottom left or right. These attributes take two child views and position them relative to one another. For example, we could say position from Lyla to the right of and below the happy birthday Ben TextView. Let's see what that would like like. Okay, so if we did that and we just looked at the two TextViews, this is the code that we would use. With the happy birthday Ben TextView, I've created an ID here. And then I refer to that ID from the from Lyla TextView with the layout below and layout right of attributes. Here's a picture of what that actually looks like in the app and unfortunately, that didn't really do what we wanted. The From Lyla view is in fact to the right of the Happy Birthday Ben TextView. And it is also below, but it's not in the lower right-hand corner. So these two aren't correct. Okay, so that leaves us with these three attributes, which will take my TextView and align them in relation to the Parent, which happens to be the whole screen. Now I want From Lyla to be down here. Which is in the lower right-hand corner of the parent. So I'm not going to be using layout_alignParentLeft, so in fact I will be using layout_alignParentRight and layout_alignParentBottom. Let's see how this all comes together in the code. Okay, so first things first. I'm going to find the From Lyla TextView and iIm going to make sure that the layout width and the layout height are both set to wrap_content otherwise, even if we position our textview correctly it might not actually move. Next I'm going to add the additional attributes. For the value, I go ahead and put true. This is affirming that I want this TextView to be aligned to the Parent's Right. The other value I could put here is false, but that would mean that it is false that it aligns to the Parent Right, which is not what I want. So now I'm going to type the other attribute to put at the bottom. And I will also set this to true. All right, so for those of you at home this might be a little bit hard to see but it seems like we've positioned our view down here correctly. That said, let's see if it actually shows up correctly on the phone by pressing the green Run button. Okay, I select my phone and I click OK. Okay, awesome. So up here I have my Happy Birthday, Ben, and down here, I have From Lyla. And with that, everything looks like it's pretty much in the correct position. You are blazing through these steps. So at this point, we've done step number one where we've selected the correct views. We also went ahead and did step number two and we roughly positioned the views correctly on the screen. So now it's time to move on to step number three, styling the views, and to do that, we're going to have to figure out what attributes we need to change. All right, so what I want you to do is take a look at where we are right now. And take a look at where we want to be at the end of the app. Try to figure out what the difference is between these two states are and then write those differences down in a list in this text box. This will help us choose what attributes we're ultimately going to change. Okay. As I'm comparing what we have now and our final goal, I see a number of differences. The first of these differences, is that the text of the goal is much larger than what we have right now. Also the final font that we're using is different from the font that we're starting out with here. Similarly, the text here is black and the text here is white. Now if you take a look at the image here versus the image of the goal screen, we also see that the image has actually expanded, to fill the entire screen of the phone. Now this last one is a little bit more subtle. If you look over here at the text that we have right now, it's smushed right up against the corner of the screen. Whereas the text of the goal has this space here. Between the side of the screen and the text itself. And those were all the differences that I saw. So let's go ahead and work through these one by one, adding attributes and setting them to values, which will turn this into this. Listing out those difference gives us a good starting point. >From those, I can make a to do list of what I need to change. So now, you're going to go through each one of these and slowly transform this into the final goal. We'll start with this first step, which is making the text larger. And here's the app once you're done coding. At each step, make sure to run the app on your phone so that you know that it looks good on a real device. All right, let's get started. Here's a list of attributes. Make a check next to the attribute or attributes, and then submit your answer to see if you're correct. Once you've selected the correct attributes, go ahead and change them so that the text is 36sp for both text views. When you're done, your app should look like this. All right, so it's actually the appropriately named textSize that will make the text larger. Now maybe you thought it was textStyle. TextStyle is actually an attribute that's used for changing text to either bold or italic. But it doesn't change the size. You might have been looking at textAlignment, which does things like puts the text to the left of the view or the right of the view, or centered in the view. But it is actually textSize, so once we've determined this, let's go ahead and make the changes in the code. All right, here I am, in my code. I'm looking at activity main.xml like I always have been and I'm going to scroll down so I can see my two TextViews. Okay, So let's go ahead and add the attribute. Put Android, the name of the attribute equals. Okay, and now I have to put the value. And if you remember from the quiz question the value should be 36sp. As always, remember to have quotes around your value. And you're going to need android: before the value textSize. Oh yeah, and don't forget the equals sign. Once you've done this, you should be able to go over here to the preview screen and see that the text has actually gotten bigger. Let's go ahead and make this text larger as well. Okay, great. And I've typed my textSize="36sp" here. And I see that it in fact, updated on the phone. But, in reality, this isn't your actual phone. So you should always, always, always run it on your phone to make sure it looks correct. To do that, I go up here to the green run button, select my phone and hit OK. And good work, you've done it. We no longer have small microtext, we have big and beautiful 36 sp text displayed on our phone. And just like that, we can check off text is much larger on our list. Okay, now that we have large text, let's move on to changing the font. Okay, start off by checking the box next to the attribute or attributes that you need to use to change the text font. Once you think you've got the right attribute or attributes, go ahead and, as before, hit submit to see if you're actually correct. And then, once you know which attribute to use Go ahead to your code and change it to set the value of the font to sans serif light for both of the text views. When you're finished, the screen should look like this, with a thinner sans serif light font for both of the text views. fontFamily is the attribute that you would use to set the font for a TextView. Since we want the actual font to be Sans Serif Light, sans-serif-light is the value that we use for the attribute fontFamily. To make that a little bit more clear, let me show you in Android Studio. Okay, I'm back here in my lovely activity_main.xml and let's add some more attributes. I'm going to start with the Happy Birthday, Ben TextView, and the attribute I am adding is android:fontFamily. Okay, and the fontFamily that I wanted to use if you remember from the last slide is sans, that's with an s, -serif-light. And as always, it's nestled between two quotation marks. Now, this is a little bit hard to see, but the preview view has updated to show us the thinner, San Serif Light font. You can see it best if you click on something that's not the TextView, and sort of compare these two look like, since this is the old font and this is the new font. A couple of things to notice, or problems that you might have run into. These things here are dashes, they're not underscores. So make sure you get that absolutely right. And make sure you spelled sans-serif-light completely correct. For example, the computer won't recognize sans_serif_light with underscores. You can see here it has reverted back to the old font. Also note, that when you hover over the text, you might get this message. Attribute fontFamily is only used in API level 16 and higher, current min is 15. If you remember back to when we made the project, we set the minimum SDK to 15, or Ice Cream Sandwich. What this is telling us is, to use this attribute, you need one higher version. This isn't a huge deal but basically what it means is that on older phones you're going to see the old chunkier font and on newer phones you'll actually see the Sans Serif Light font. Okay, so I'm going to continue on and add the attribute to my other TextView. Let's scroll down. android:fontFamily. Okay, and now on the preview screen everything looks correct, but always run it on your phone. I'm going to hit the green run button. I'm going to wait a million years. I'm going to hit the phone, going to hit OK. All right, and when you load it up on your phone, you should be able to see that you have a little bit of a thinner Sans Serif Light font. Excellent work, two down, three more to go. All right, now let's go ahead and change the text to white. All right, as before, select the attribute or attributes, using the check boxes that you think will change the color to white. Check your answer by hitting submit, and once you know that you've got the correct attribute, I want you to change the value to @android:color/white. And go ahead and do this for both TextViews. Now in this intermediate stage, your app might look a little bit funny. Namely you've got a white background, and you're putting white text on it. So it might be kind of hard to see your text. Don't worry we'll fix that in the next video. Okay, hopefully this wasn't too difficult. You used the textColor attribute. Now, just as a little bit of a reminder of what this value is, we use @android:Color to get access to the standard Android colors, and then /white specifies that we're looking to use Android's white color. Really, there aren't a lot of standard Android options. If you want a specific color, it's a lot easier to use a hex code, like we talked about in the lesson. A good resource for hex codes is the material design color web page from the Android developer website. That web page is linked in the instructor notes, if you'd like to take a look at it. But enough about color. We're using Android's white, and let's go over to Android Studio to take a look at what that looks like. All right, we're back at our trusty old activity_main.xml, and you're probably used to adding attributes right now, so I'm just going to go ahead and start typing in the Happy Birthday Ben TextView. Again, the attribute I'm using is textColor. All right, and the drop down actually gives me some options. It's @Android:, then color/white, and almost immediately my preview updates, and it's white, so it's kind of hard to see. But again, that's what we wanted it to do. All right, let's do the same thing to the other TextView. going to click here, android:textColor="". Quotations, important, important quotations, @android:/color. And once I'm finished typing this, I can see that, well, this TextView disappears as well. Again, expected, because it's a white text on a white background. But I can see from the vew outline here and here that the text does in fact still exist. And for the sake of thoroughness, let's go ahead and run it on our phones. Okay, now those of you viewing at home might find it a little bit hard to see, but I can just barely see my white text on my light gray background. So it looks like we did a good job. That's one more off our list. Let's move on to the next step. All right. So, as I mentioned, this white text here is a little bit hard to see, but that's going to be fixed in this next step where we're going to expand the image view so that it fills the entire screen and then we'll able to see our white text just fine. Okay. This quiz is going to be a little bit different. So, like before, I want you to select the attribute or attributes that you think you need to use to expand the image like this. But don't worry about changing them just yet. Just go ahead and pick which one you think it is. You don't have to modify the code in this quiz. We're already displaying the correct image, which is this Android party image, so there's no need to change the source attribute. Similarly, the position isn't really incorrect. The image just needs to be larger, so all of these layout aligned parent attributes, we're not going to use them. Using the id attribute in and of itself doesn't actually make any changes to the layout. It just give the view a name so that you can refer to it later. Now there's actually a way to use the background attribute to achieve the effect we're trying to achieve. But it doesn't involve an image view. So if you chose background, you're technically correct, but we're going to go about it in a different way. The way that we learned about in the lesson. This leaves us with layout_height, layout_width, and ScaleType. ScaleType will change the size of the image within the view box that surrounds it. While layout_width and layout_height will actually change the size of that view box. In this case, the image is large enough that the view box expands to fill the entire screen no matter if it's wrapped content or matched parent. Because it doesn't matter in this particular case whether we put matched parent or wrapped content you don't strictly need to change these, in this case. That said, because we are trying to get the view to expand to the entire screen, it would probably be good to set these explicitly as match parent. Then, if we end up using a smaller image, it will still expand to fill the entire screen. But while layout height and layout width are sort of optional in this case, scale type is the actual attribute that you're absolutely going to need to use to make the image fill the entire screen. The question is, we've chosen the attribute, but we don't know the value to set scale type to. And that's what I want you to figure out in the next question. Alright, so at this point we know we're going to use Scale Type to expand our image. So, now what I want you to do is actually expand the image to fill the entire screen. Now a couple of hints on how to do this. Hint number one, now there are actually a lot of different values that you can set Scale Type to, but in the lesson we only taught you about two, so let's stick with thinking about those. The values that we know about are center and center crop. Knowing what you know from the lesson, which one of these do you think we should use? Now once you've used scale type properly to make the image expand to the entire screen, there's a possibility that your text will disappear. If this happens to you, try changing around the ordering of your views. Okay, if you've got it, great job. And if you didn't, good try and keep watching for the answer. All right, so here I am in Android Studio. And I'm looking at the TextViews right now. But I'm going to scroll up to look at the ImageView. Okay, so a little bit about what I was talking about before. If I put my cursor somewhere in this ImageView, it's going to give me a blue box that shows me how big the ImageView is. And it's pretty much the entire size of this phone screen. Now I'm going to go ahead and add scaleType, and the two options that I'm looking at are center or centerCrop. Now center doesn't actually scale the image, it doesn't change the size of the image. So it makes it a pretty straightforward that I need to use centerCrop. Okay, and you should see that the image now expands to fill the entire ImageView space. You might notice here that at the bottom there's a little white strip where the image doesn't expand to. If I go up here, which let's me choose between different devices, and I choose say a tablet like a Nexus 10, we can see that this image is not filling the entire space. Now this is bad because it means if you're viewing this on a tablet you're going to get this weird boxy image with this white space around it. Although it might look fine on a phone. The reasoning for this is because I've put wrap_content instead of match_parent. Let me change these to match_parent. Now when I change these to match_parent the image expands to fill the entire view. So the point I am trying to make is that layout_width, layout_height, and scaleType all work together. Let me draw you a picture to show you a little more detail about what I mean. Okay, so let's say you are a bit curious about what's actually happening when we use centerCrop. If you go to the Android Developers website, you will see that the documentation says the following. centerCrop scales the image uniformly, meaning that it maintains the image's aspect ratio. And what this means is that it does this so that both dimensions, the width and the height of the image will be equal to or larger than the corresponding dimension of the image view (minus padding). Okay, so one thing I can say about scaling uniformly, if you've ever tried to scale an image, scaling uniformly means that it keeps the image from getting stretched out either horizontally or vertically. So it does that scale, and then it makes the image large enough so that both the width and height are going to be equal to or larger than the corresponding dimensions of the image itself. Let's look at a picture. Okay, so here's your phone. And on our phone we have an image view. Here's the picture for the image view, and here's the green box representing the actual size of the image view. What's centerCrop will do, will scale this image up so that without warping it, it fits in the box. Okay, so without changing the dimensions I've scaled this image up to make it fit in this green box here. Now because the image is this long rectangle, it actually expands over the edge of the phone. centerCrop will center this image in the view, and then as the name implies, it'll crop off the excess parts of the image. Okay, so I want to talk about one more problem that you might have run into. Views can overlap each other much like playing cards can overlap each other. And the order of these view tags here determines the order that the views get placed on the screen. So since view A is first, it would get placed on the screen first, followed by view B, and then view C. Now because of the ordering that I put in this XML, I can't really see my text very well in text view A. Let's try changing the XML and see how it rearranges my screen. Okay, so I've switched things around so now I have view B, A, C. This will then draw view B first. Then it will draw view A. And finally it'll place view C. I've just reordered the views. Everything is placed in the same position, but the ordering of how the views stack on top of each other has changed. And because of that, now I can see my text. So you might have run into a similar problem with your card if you put your two text views here and then you drew your image view. Because it would draw your first text view, then your second text view, and then the image, which takes up the whole screen, would have covered both of them. So just make sure that you got the ordering correct. Let's take a look at what that looks like in code. Okay so here's my working code. But I'm just going to show you what I mean by the ordering of views. Right now my ImageView is placed first, then my two TextViews. And we can see the text easily on the screen. Now if I instead, cut this ImageView, I'm going to scroll down, I'm going to past it right here. All right, and now I have TextView, TextView, ImageView. Well, it draws the "Happy Birthday, Ben!" TextView, and then it draws the "From, Lyla!" TextView. And then it draws this Android party image over the other two TextViews. If I select the TextViews, I can see that they're still there, they're just being covered up by the ImageView. All right, I'm going to switch it back. That's much better, my TextViews are on top now. Okay, and as we always do, let's go ahead and run this on our phone, just to make sure that everything is working with the match_parents and the centerCrop. Okay, awesome, this is looking pretty great. We have our image expanded to fill the entire view, we can see our text views. There's one tiny little problem that we still need to fix, but great job so far. All right, you're doing a great job. Only one more attribute to change, and then we're going to have our final birthday card. We've got one small issue that I'd like you to solve. Right now all the text is smushed up in the corner of the phone screen, both in the upper left corner and the lower right corner. In our end version we want to give it a little bit more space. In the same style as before, select the attribute or attributes that you need to change to make room between the side of the phone screen and the text. Once you've selected the correct attribute or attributes, make this space 20 dp on all sides. All right, so were actually two correct answers to this question and they were padding and layout_margin. So you could have select either one of these but you don't need both. Let me show you why. In practice, a lot of times, a view that uses padding will look very similar to a view that uses layout_margin. Let me actually draw the view borders for you. Once you draw the view borders, you could actually see the difference between these two situations. In the case of padding, you're making the actual view larger by adding space inside of The view. In the case of layout_margin, you're adding space around the view, but not actually changing the size of the view. Now, you might be wondering when does this even come into play? Why have two different attributes? Well, if I were to do something like add a border or a background color to both of these views, they'd actually look pretty different. In our case, though, we're not adding a border or background color, so you can pick either padding or layout_margin. It just wouldn't make sense to pick both. Since we can choose either, I'm going to go ahead and, a bit arbitrarily, choose to add padding. Let's see what this would look like in Android Studio. All right, here we are back in activity_main. Now the padding attribute is something that we want to add to the TextViews to move them farther away from the side of the screen. Padding and layout_margin add space on all four sides. All right, let's go ahead and add it. And remember, I said that I wanted there to be 20dp on all sides, so that's what I'm putting right here as the value. My preview is updated to show the added space, I'm going to go ahead and scroll down. All right, and I'm feeling a little bit playful, so I'm going to go ahead and add layout_margin to this TextView instead of padding. All right, and that also scooted the TextView out. Notice, though, that the TextView's size didn't increase when I changed the layout_margin, whereas up here in this TextView, the size of the actual TextView has changed. Now what happens if I add both layout_margin and padding. Let's take a look. Well, now my text is 40dp away from the wall. It's 20dp here and then another 20dp of padding here. All right, but we don't want 40dp away from the wall. So I'm going to go ahead and delete this. Okay, 20dp of padding in the From, Lyla TextView. And 20dp of padding and the Happy Birthday, Ben text view. Awesome, let's run this on our phone. All right, and may I present to you the finished Birthday Card app. Let's get some jazz hands. And with that, we complete the last thing in our to-do list. Cool coffee beans, you've made your first app, but don't take my word for it. Make sure that it runs on your phone. So now I've taken you through three steps to show you how to take a drawing to an app. Let's recap a little. The first step was to choose your views. A great place to start with this step is to circle the different views. And then decide which view tags you need to use. Katebin Kanal taught you about two view tags, imagery and text views. And they also mentioned a view called a button, which we'll be using in the next lesson. As you begin to feel a little bit more ambitious, you can discover new views in the documentation. All right once you're done choosing your view, you move on to positioning. And the question you need to be asking yourself at this stage is what view group should I use. Now, view groups have a lot of control over how and where you position your views. If the views are aligned horizontally or vertically, you probably want to use a linear layout. And if the views are aligned relative to one another, then you probably want to use a relative layout. Now once you're made this decision, if you're using a linear layout, you're going to think about things like orientation and layout weight. Layout weight in particular is a little bit complicated but pretty powerful. It allows you to sort of equally distribute your views across the screen which is a really great feature. If you're using a relative layout, you'll will be thinking of how to position your views relative to their sibling views, and to their parent view. Now, this will be done using the align parent attributes, and attributes like to left of and to right of. Step three is the fun step, where you get to style your views. During this step you'll look at things like the text, and the color, and the font, and decide what you want them to look like. Will the text have a background color, how will the pictures fill up their space? Once you know the attributes you're going to change, then you need to now the correct value you're going to change them to. Finally, you'll look at the more subtle spacing issues between elements. And you can tweak the spacing between elements using padding and layout margin attributes. Once you're able to master these steps, you should be able to take any simple drawing that you come up with, and turn it into an Android app layout. Good work. Thank you for adding your video to the card showcase. It's really going to help the next generation of Android students to see what you did, and then try doing it themselves. As for me, I'm going to show this to someone special. Hey Ben, Hey, how's it going? Happy Birthday! Thank you, so much. Yeah, actually I made this for you Oh, I remember this picture. I'm glad you like it. Actually, making this card, it really helped me learn a lot more about view groups and layouts and it really helped our students too. You know who would love this is my mom. I'm going to go show this to my mom. Wait, wait Ben, that's my work phone. My name is Gene Gurkoff, and I'm the founder of Charity Miles. Charity Miles is a free app that allows people to earn money for charity whenever they walk, run, or bike. I was a finance lawyer for a number of years, and when I was in law school, before that I started running marathons to raise money for Parkinson's research, in honor of my grandfather who has Parkinson's. And I figured if I got enough people together, then collectively we would have the clout of a celebrity. And then companies would want to sponsor us. The first technological project that I worked on was actually while I was still a lawyer. And I thought it would be really cool if we could make something where we could crowdsource what we think the law should be and it totally failed [LAUGH]. But it was a really good experience. If you're going to create an app or you're going to be an entrepreneur, in any field, I think there are many moments of failure. How you spin those failures into a learning lesson or a success that I think are the most important. I never would have thought of Charity Miles if I hadn't had failures. Before I got the engineers I talked to a lot of people. Just ran the idea by them just to see what they thought. Then I got the developers and we worked on wireframing and designing everything. All these features that, you know, we had in there, crammed in there, we are going to take that out, take that out, so we ended up with something that just did one thing. We just choose from over 30 world-class organizations from Wounded Warrior Project to Feeding America to World Wildlife Fund, ASPCA. I'm going to choose the Michael J Fox's Foundation for Parkinson's Research, in honor of my grandfather. And then we're going to go for an outdoor walk, and now thanks to Johnson & Johnson, we're able to earn money for Michael J Fox Foundation for every mile that we walk. And this little mile counter down here shows us how far we have walked and if we press this we can see more so we can again see how far we've walked. And we can also in real time, the amount of money that we've raised for the Michael J Fox foundation. And you know, every mile really does matter. So, as you continue to walk, you'll be earning more money to cure Parkinson's. And if you scroll down, you can get a little bit more information about Johnson & Johnson and the other things that they're doing to support great charities. And when you're done, you just press the stop button and finish, and that's it. Very simple. Whether you're a social good app or just an app, try to create value versus hype. Try to create an app that makes people happy, that makes people healthy, that improves life somehow. You're going to have to tell investors about it, you're going to have to tell your family about it, you're going to have to tell your friends about it. And if it's not something you love then it's going to be really boring. I never get tired of talking about Charity Miles because I love it, and I feel good about being able to share this with people. So I think it would be great if the next generation of entrepreneurs could use apps to harness the power of crowds to drive major advances in science. The phone has so much on it from the accelerometer to the GPS that it's monitoring all this data about us all the time. And that data is super critical for Alzheimer's, for asthma, for heart disease those being able to use phones and apps to crowdsource. That type of scientific is going to change the game. I would tell potential developers to do something that they love. It's the thrill of a lifetime, they should do it. Okay, you're about to do some shorter warm-up problems before we code an app. While you're working on these problems, you might want to copy over code examples into an application and actually try running it. Now you might be thinking about putting this sort of random Java code that you're testing out into your Just Java app, but this could get a little bit messy. So instead of potentially messing up your Just Java app, I humbly suggest making a new app. Okay, so you'll want to click on the Start a new Android Studio project, and then you can use these specs to create your new project. If you get stuck, you can watch the solution video, or I'll quickly get up and run it. If you want a slower moving video, I've provided a link to the video from practice set one, where you set up the happy birthday project. All right, get to it. Don't worry, I'll wait for you. Okay, so like you've seen before, we go ahead and we click Start a new Android Studio project. So I'm going to do that. Okay, and then we'll see a screen that looks like this. Now it said to name this project Practice Set 2, so I'm going to do that right now. And I want to use the same company domain that I've already been using for all of my other projects, which is android.example.com. Now, as long as you didn't do anything funny, this should have stayed the same, so you probably don't need to change it. Now just double-check that the project is being saved wherever you want it to. In my case I'm putting it on the desktop, but you might want to put it in your documents or somewhere else on your computer. All right, now I'll hit Next. This screen looks pretty good. I do want to make something for a phone and a tablet and I don't want to make something for a TV or that I'm going to wear on a watch. So I'm not checking these boxes and I have this box checked. In addition, I said that you should be making something for API 15, so I have API 15 selected. If you don't, you can always click here and change it. I'm going to click Next. Okay, and on this screen we're also going to stick with what we know. Go ahead and select Blank Activity and then click Next to go to the next page. And there's no need to customize these or change these around. You can just keep the defaults. And once you're done with that, go ahead and click Finish. Okay, and after a little bit you should see that your app loads up like this. Good work. You're going to start by practicing identifying errors when creating new variables. Now if you want to use some technical verbage, what your actually doing is finding errors with declaring and initializing variables. Declaring your variable means creating a new variable. It's like making the box for a variable, and it looks like this. Right now, there's no value involved, it's just the data type, the name, and a semi colon. Initializing on the other hand, is when you set an initial value for a variable. It's that act of putting something inside the box. And in code it looks like this. Total = 10. Now oftentimes you'll combine the two, both declaring and initializing and write a code statement like int total =10. This both creates the box and puts the value inside the box all in one statement. So you're going to be looking at statements like these, which either are both a declaration and an initialization or just a declaration and identifying when an error has been made. Now, these errors are bad enough that they're considered compile time errors. And what this means is that Android Studio won't even let you run your code, because it can't understand what you're trying to say. Let's take a look at an example of what the Part 1 problems are going to look like. Okay, so this is the first of the Part 1 problems, and I'm just going to walk you through it a little bit. Okay, so the problem states, unreadEemails is a variable storing the number of unread emails for an inbox app. And we're going to go ahead and assume that there are ten unread emails. So now you're going to look at these three different initializations/declarations. Some or all of these will have errors. You're just looking at the single line by itself. This is not a block of code. So you'll look at the first one and decide whether it's properly written in a way that it both declares and initializes the variable unreadEmails. If it does move on to the next one. And if you don't think it does then put a check right here in this check box. Now if it has an error I also want you to come over here and describe what you think is causing the error. Okay but i'm not necessarily saying this one has an error that was just for an example. Okay, so you'd go through these and check the ones that you think have problems and then describe what the errors are here. If you'd like, I've provided the code for each of these exercises in the instructor notes below. So you can try copying them over, one at a time, and putting them into the app that you just created for yourself. Once you're done, I highly encourage you to go through the solution video. I'll explain the logic behind which ones had errors. Okay, so for the first one, this part right here, which is the declaration, looks fine to me. The initialization is a little bit funky, why? Well, we use quotes, and if you remember from the lesson, quotes specifically have to do with strings. And it really makes our computer see this text as a string. Because of that, the computer is going to complain about there being a mismatch between this type, integer, and this value here which is a string. Okay so this one definitely has a problem, so i'm going to put a check in it. Okay let's look at this next one. The declaration here looks fine. And ten without any quotes is an integer, so this one actually looks perfectly okay. One note that I would make is when we write variables we tend to use camel case. You can see that we're using camel case right here. So technically this is okay, but it doesn't really follow programming conventions. To follow programming conventions, you would change that to a capital E. But I'm not going to put a check next to it. All right so let's look at the third one. Now the biggest difference you'll notice between these two, is that there's no space here. Spaces, it turns out, are critically important. Without the space, the computer can't know that you're actually trying to declare a variable here. In fact, what the computer will interpret this as is that you have a variable called intunreadEmails which you haven't given any sort of data type. Okay, so this one definitely has an error. All right, and that's it. Go ahead and try practicing these skills with the next few problems. Okay, so before I start talking about these variable declarations, the first thing I want to point out is that none of these are particularly good name for a variable. And none of them are particularly good names, because it's easy to confuse names like number, int, and integer with the data type that comes before. That said, two of these declarations won't even work. Let's look at the first one. So, we have here the word integer, which is in the position where the variable type should be. Now, in this lesson we've taught you about two types, string and int. So the computer will recognize int as an I N T lowercase. But it's not going to recognize the word integer. Your types must be exactly spelled and capitalized as we showed you them. So this one is incorrect. Okay, so looking at this next one the word int is correct here, since we just talked about that. This is a valid data type, but the problem here is that you can't name a variable the same name as a data type. There's certain special words in Java that have a meaning for the computer, beyond just what they say such as int. These special words are known as keywords, and in Android Studio they're colored blue. Now you can't name your variables the same as any of these keywords. Okay, so this one also has an issue, okay so this third one, it looks like our data type is declared correctly. Now technically this would work, you've gotta type here that the computer will recognize, and you've got a name, that is something that fits all the variable rules. That said, the name integer is a pretty vague name. And it could easily confuse someone else if they're just reading your code. So because it's technically not wrong, I'm not going to mark it. But you should consider a better variable name, such as numberForCalculation. Which is a little bit more specific as to what its use is. Okay, let's look at these guys. Now remember, these aren't instructions that are meant to be followed together, they're different ways that you can substantiate the declare currentlyPlaying. So, let's look at each of them separately. Okay, the first one, everything is almost perfect but there's one tiny thing missing and it's the quote that matches this one here. Much like our curly braces, parentheses, and XML tags, you always need to put quotes at the ends of the string. Okay, let's look at this next one. As we discussed in the last problem, capitalization matters. And there's something wrong here. String is always a capitalized data type. Now we'll discuss this a little bit in the next lesson, but String is not a primary data type like int. It's actually something called a object. Again we'll talk about it more later, but with String you always need it to be capitalized. And once you capitalize String, this would work fine. And here, this one is almost fine, there's just one tiny problem. Can you see it? All right. Hopefully you caught it. There should be a semicolon at the end here. As always, you should remember to finish your Java statements with semicolons and close all of your strings with quotes. You don't want something bad to happen. Okay, let's look at each of these. So here we have our type, and here we have our name, but we don't put a space, we put a dash here. And honestly, that's really no different than just writing something like, stringname. Java won't be able to see these as separate words, and will cause an error because it thinks you're trying to declare a variable without giving it a type. Oops, and apparently we also forgot a semicolon, that's no good. So this has a lot of problems. Okay, let's look at the next one. String is a correct data type, so that's all good. But over here, the variable name. We're breaking our variable naming rule. Variable names really can't contain miscellaneous punctuation like these quotes, here. Whoever's just declared this variable, might be confusing the variable name which is just a typed word, with the value which is a string and must be surrounded by quotes. So, variable names can't have weird punctuation in them. Strings require you to surround them by quotes. Okay, on this last one, the data type looks correct. And now we have name on profile. Well, this is actually breaking one of the variable naming rules, which is in your variable name you can't have spaces. Java's basically going to see the word name and expect to have some sort of initialization off of it, or semi-colon, or something. It won't expect for the name to continue after there's a space. So how do we solve this? Well, usually if we want a name like this we'd just write it in camel case. So you could write something out like name on profile with the O and P being capitalized and no spaces in between. And this is a great variable name, especially if you want to be able to include all of these words. In the next set of quizzes, I am going to be showing you how variables are actually used. All the programs that you are about to do in part 2, will compile. Which means that the computer can understand the code that's been written for them, and we'll be able to create an app. Now, while the programs will be able to run on the phone, there's a chance that they might not do what the intended goal was. This is something known as a logical error. A logical error means that there's something wrong with the logic which you used to write the code. Let's look at a short program and an example scenario and I'll walk you through how you solve one of these. Okay, so here's an example. Each of these programs will have a goal, which will be written out here. The program itself will be in the green box. Okay, so the goal of this program is to calculate something called sleep debt. Now, how much sleep you need varies a little bit by age, but on average, people need about eight hours of sleep a night. So what this program is trying to do is calculate the sleep debt in one week. The user of the program will go ahead and estimate how much they sleep on an average weekday, and how much they sleep on an average weekend day. For this example, we're assuming the user sleeps five hours on a weekday and nine hours on a weekend. The code for this task is here in the green box. And the first thing that you're trying to do is read through this code and decide whether or not the goal was accomplished. Then what you're also going to do is go through each of the statements that happened in the code and decide what was actually displayed to the screen. Assume that these method calls here, the things that look like display and have parentheses and something in between them, will display content to the screen. Now, some of these problems will have multiple pieces of content that they need to display, so you might see display1, display2, display3. Okay, so if you're still watching this video, you're probably wondering how to solve one of these problems. This isn't the first time you're interacting with multiple variables, the values of which might change a few times during the problem. So let me do the first one with you before I set you loose. Now I'm going to use a technique called hand simulation and what this technique involves is trying to figure out what the computer is doing, but without just sticking it to the computer. For us really it's just an organized way to keep track of what's going on with the variables. Okay, now you're going to go line by line so let me start this with you. In the first line here I see a declaration of a variable, so I'm going to go ahead and write the variable name which is weekday. It's also initialized to a value which is 5, so under weekday I'm going to put the value 5. This is representing that the variable weekday currently stores 5. Okay, so that was the first line, I'm going to move to the next line. We have a variable called weekend, so I'm going to write that out, and the value of that variable is 9. Okay, so that's looking good so I'm going to move on to the next line which is a declaration and instantiation of the variable optimalHours, so I'll do the same thing. Okay, so I'm not going to write the value 7*8. I'm actually going to calculate that out because that's what gets stored in optimalHours. So, with a little bit of mental math, 7 times 8 is 56. Okay, we have another declaration here. We make a variable called actualHours, so I'll write that out. Well, it's equal to the value of weekday, and this is the current value of weekday. It's not some past value of weekday or future value of weekday. Now, we're keeping track of what the current value of weekday is over here. And so I could just look here and see that it's 5. So I should really think about this as the number 5. So it's saying int actualHours is equal to 5, so I'm going to go ahead and write that there. OK we'll move on to the next line. So now we're changing actual hours again to be equal to the current value of actualHours plus weekend times 2. So I can look over here, the current value of actualHours is 5 and the current value of weekend is 9. And now I have this little equation here. So, I do the multiplication before the addition, so, 9 times 2 is 18 and then I add 5. And with a little bit more mental math, 18 plus 5 is 23. Okay, so this all equals 23. And what I have to do is cross out the old value of actual hours, and write in the new value of actual hours. Okay, so that's done. Let's move on to the next line. We have n solution, so that's a variable declaration. And it's being set equal to something, but I'm going to write out the word solution first. And solution is equal to optimal hours minus actual hours. So let's go over here, optimal hours is 56 and actual hours is 23. Now it's okay to use your calculator, I happen to do that earlier and I know that 56 minus 23 is 33. Okay, and then we move on to the next and final line which says display solution. So, we can look over here to see what the value of solution is, which is 33. So it is going to display the number 33. So that is how I, or you, or anyone, could figure out what this program just did. But the real question is, did it do the right thing? Is there a logical error somewhere in here or is somebody who sleeps five hours on a weekday and nine hours on a weekend night going to have thirty three hours of sleep debt at the end of the week. And I want to know what you think. All right, quick side note, now you've created this practice set 2 app, so I'm just going to show you how you could also put the code into the practice set 2 app if you wanted to test it out. I really recommend hand simulating first, because it's going to give your brain a better grasp about what's going on. But it's also go to be able to put the code into Android Studio and play around with it a bit. So my suggestion is that you copy and paste the code for the problem, which will be provided in the instructor notes, into the onCreate method. That's the first method you'll see in your main activity class here. Okay, just to be very clear, here's what your onCreate looks like before it's modified and then you can paste over the code, like I've done. Okay, the other thing you're going to need to copy and paste over, which will make this line of code work, is down here. It is this code, and I've also included this in the instructor notes. The one final thing that you'll need to do is go to your XML, and make sure your that your text view has an Id/display_text_view, and this should exactly match what's shown here. Ok, as long as those two things match when you run this code, you'll get the value printed out to the screen. It's a little bit hard to see but it says 33 right there. Okay, and with all of that, then I'll try to hand simulate and some help with getting it up and running on your phone. Go ahead and try to figure out is this program doing what it's supposed to do. So the number that is displayed here is 33. Now the real question is was the goal accomplished, yes or no? I'm going to remove all this down here and just figure out what should the answer actually be, should it be 33? Okay, so here's just the result problem. Now to figure out sleep debt, you should be taking the amount of sleep that you need and subtracting the amount of sleep that you actually got. So what is the amount of sleep that you need? Well we're assuming that you need 8 hours of sleep in a night. So we have 8 hours, and we should multiply the number of hours that you need in a single night by the number of nights in a week, which is 7. Okay, and that number is 56. So the next question is, how much sleep did this person actually get? Well, on the average weekday night they slept 5 hours. Well, how many weekdays are there in a week? There are 5. So I'm going to multiply the 5 hours they slept each night by the 5 week days there are in a week. Now on the weekend, this person got a little bit more sleep and they slept 9 hours. Saturday and Sunday are the two weekend nights where they averaged 9 hours, so I'll multiply the 9 by 2. Now you're going to need to add the weekday sleep that they got. And the weekend sleep that they got, to get how much sleep in total they got for the entire week. 25 plus 18 is 43. So now we have the sleep that they got and the sleep that they need. If we take the sleep that they need and subtract out how much they actually got we'll see how many hours of sleep debt that they acquired. Basically, how many hours of extra sleep that they should be getting. Now 56 minus 43 is 13, which is bad if they need 13 extra hours of sleep. But it's not nearly as bad as the 33 hours that our program calculated. Okay, so what went wrong? Well, let's remember the calculations we did here and go back to the code and see if it's basically doing the same thing. Okay, so here's the numbers that I calculated in my head before. Again, I need 56 hours of sleep, on weekdays I'm getting 25, on the weekend I got 18, which equals out to 43 hours total sleep which is 13 hours of sleep debt. Issue is, here I'm printing 33. So what went wrong? Well. I started things off well by saying that a week day, I get 5 hours a sleep, in a weekend I get 9 hours of sleep. That matches up. And then, I also calculate the number of optimal hours correctly, by taking the 8 hours that the user should be sleeping each night and multiply it by 7. The issue here is the calculation with actual hours. It's kind of a mess. I am calculating the number of weekend hours I get correctly. I'm taking weekend, which is set correctly up here, and multiplying it by 2, so this is good. But I'm not doing really this calculation where I take the number of weekday hours I need and multiply it by the number of weekdays there are. There's no multiplication by five here. This line of code actually isn't very helpful. I'm going to remove this line of code. Now I haven't declared actual hours anymore, because I just removed it. So I have to put the end here. To actually properly declare actual hours. And then this shouldn't be actual hours. It should be this calculation over here. The amount of sleep that I need in one weekday, which is stored in the variable weekday. Multiply it by 5. And the solution is again the subtraction of the optimal hours, minus the actual hours that I got. Which is the same sort of calculation that I'm doing here, and it should be 13. So let's see, with this change, if it actually works. I'm going to hand simulate again. Okay, looking at the first line, as I'm hand simulating, weekday is equal to 5. And then we have weekend equal to 9 and optimal hours equal to 7 times 8. Okay, I removed this line of code, so I'll go down here. We have a new variable, actual hours, and this is equal to the value of weekday times 5 plus the value of weekend times 2. The value of weekday, if I go over here I see that it's 5 and the value of weekend, I see over here, is 9. 5 times 5 is 25, 9 times 2 is 18, add those two together, we get 43. And then we have a new variable solution. And solution is the optimal hours minus the actual hours. Optimal hours is currently set to 56. Actual hours is currently set to 43. I do 56 minus 43 and I get 13. And that basically followed the same order of steps that I did mentally when I was trying to solve this problem. Okay, looks correct, looks good. Again, we looked at sort of two powerful tools here, the first of which was using hand simulation to kind of get a general sense of what the code was doing. The other thing that we did was look at the goal for the program and sort of think about the steps that we ourselves as humans, thinking humans would do to come with the answer. And we compared the two. What was the code doing? What would we do? And in this case, where there are differences between what the code was doing and what we would do, we resolved those differences by changing around the code. And that fixed things. So let's move on to the next problem. You're going to be seeing a lot of problems in this format and I highly suggest that you use both hand simulation. And sort of calculating itself in your head to help solve these problems. Okay so you're going to get a lot more practice in part two. Go ahead and move on to the next exercise. Okay. I'm going to just jump right in and hand simulate what's going on here. These first three lines we just declare three variables and set them to initial values, so I'm going to do that. Okay, so that's what that would look like. And then here in display, I'm saying display this arithmetic here. Let's look and see what the values of day 1, day 2, and day 3 are at this point in the program. Day 1 is 15. Day 2 is 22 and day 3 is 18. Now, this might seem a little bit silly that I went off here to the side and started keeping track of these variables, but as the programs get more complicated and variables kind of change and get modified in this space, it's really important to be keeping track of things. Anyways, the key insight for this problem is that you're doing both addition and a division here. Now, if you remember from when Katherine was talking about order of operation, division always comes before addition. Meaning the first thing that's going to happen is this division right here. So, 18 gets divided by 3, which is 6. And then we have 15 plus 22 plus 6, which equals 43. So, it's going to print out 43. So, is that correct? Well, what we're trying to do is find the average. Finding the average involves adding up all the numbers and then dividing by the number of numbers you have. But we did the addition too early, we do it before we've added up these three numbers. Really, it should be 15 plus 22 plus 18 then divided by three. So 43 is not the correct answer. And to make this code do the correct thing, you should be surrounding these three variables with parentheses. Then, you'll add 15 plus 22 plus 18. And then divide it by 3, which will give you the correct answer of about 18.3. As always we're going to start with a hand simulation. I'm going to look at line one first. So, we declared a new variable called raspberryPrice and set it to 5. Okay, now this one's a little bit interesting in that we have three display areas this time, display1, display2, and display3. And we're just going to pretend that there's three different text boxes. Okay, so in text box 1 we're going to display 1 box: $ and then whatever the current value of raspberryPrice is, which is 5. Okay, in the next display area, we're going to say 2 boxes: $ the current value of raspberryPrice, 5, multiplied by 2, which is going to be 10. And in the third text box we're going to say 3 boxes: $, the current value of raspberryPrice times 3, it's going to be 15. So again, this is going to print 1 box: $5, 2 boxes: $10. It doesn't print any of this math, it just prints the end value. And then 3 boxes: $15. And since raspberries are $5 a box, well, that seems to work out. So it looks like this code is correct in this case. There's one important thing that I want you to note though, which is really that there's only one way to change the value of a variable, and that's using the assignment operator. In these cases where we're displaying some sort of math, we're not actually changing the value of raspberryPrice. So throughout this program, the value of raspberryPrice remains at 5, even though we're printing 10 and 15. That's because we're not using the assignment operator anywhere but here. All right, let's look at the next question. Okay, this problem's goal is exactly the same as the last one. So really, it's just the code that's changed, and let's see what's different. To start off with our head simulation, we're initializing and declaring a variable here called raspberryPrice, and we're setting it to 5, and this next line here is the first time we're display something, and we're saying 1 box: $ and then whatever the current value of raspberryPrice is, which right now, is 5. So this is going to print out 1 box: $5. Seems pretty good. Now, in the next line, things change up a little bit. We're taking raspberryPrice and we're changing its value to 10. Note, that doesn't change what gets displayed here. This is already displaying 1 box: $5. In area 2, we're saying, 2 boxes: $, and then the correct price of raspberryPrice, which is ten. So, 2 boxes: $10, looks good. Now we move to the next line, which is going to be displaying in textbox 3. It says 3 boxes: $ and then raspberryPrice, which is currently 10, times 3, which would make this 30. That's a little bit problematic, because now we're saying 3 boxes is 30 dollars, where it should be 15 dollars. So we see this difference arise, because unlike the previous example, we are changing the value of raspberryPrice in the middle of the program, and hand simulating sort of helped us see this. This is an example where it's so important to keep track of your instructions, and exactly what's going on. If we didn't really record the fact that the variable had changed to 10, we wouldn't have seen the error here. Many phones have currency conversion apps which are pretty useful when you're traveling. This exercise deals with an example one. In this case, we're converting US dollars into Japanese Yen. And the rate is 1 US dollar to 119 Japanese Yen. And we're going to assume that we're converting 40 dollars. Okay. Let's hand simulate to see if it does what we expect. In the first line, we're declaring and initializing a variable called dollars, and we're setting the value to 40. This variable is probably storing the amount that we're trying to convert. Okay. On this next line, we have a variable called dollarsToYen. And we're setting that to 119. This variable probably represents this conversion rate up here, that $1 is 119 yen. Next we're declaring and initializing a variable called yen. Now let's calculate the value that we're initializing it to. So here we have dollarsToYen, which is 119. And we're multiplying it by dollars, which is 40. I used a calculator for this one. The result here is 4,760. In the next line, that's what we display 4,760. So, did this do the right thing? Well we know that $1 is 119 yen and if we have $2 it's going to be two times whatever $1 was. So it'd be two times 119 and if we had $40 it would be 40 times 119. Which is the exact calculation that we do here. So it looks like, yes, this is correctly calculating the number of yen. What this program here is part of is a program that shows an email directory for the Just Java Coffee Shop. And employees of the Just Java Coffee Shop all have email addresses that are their last name and then a period, their first name @justjava.com. Now what the program should be printing is the employee's name followed by their email address in this format. Let's see if it does that. Okay, so the first line here is making a variable called first name and setting it's value to Lyla. All right, good. And then the next line is has a variable called last name which its creating and it's setting that to Fujiwara. Okay, and now we're creating a variable called contactInfo, and setting it to something a little bit more complicated. Let me just make the variable right now. Okay, so we're setting it equal to the concatenation of the value in firstName plus a space, plus the value in lastName. So, first name is Lyla. Last name is Fujiwara. And this is going to be Lyla space Fujiwara. Okay, looks pretty good. Now for this next statement, I want to just say that these two bits are actually all one line. So we're taking contact info which we've already declared, and resetting its value equal to this. So let's figure out what this is. Well last name is Fujiwara, the value of first name is still Lyla. Okay so what this is doing is erasing what was in contact info before, and now setting it equal to opening bracket, concatenated with Fujiwara, concatenated with a period, concatenated with Lyla, concatenated with @justjava.com and then a closing bracket. So this is the current value of contact info. And on this next line here we display contact info, meaning that we're going to display this here, but this string right here is not the same as this string right here. In fact it's only part of the string, this part. We're missing the Lyla Fujiwara. Now, before we changed the string, it was storing Lyla Fujiwara, but we sort of overrode it in this line here when we said it equaled to a completely different value. What we really want is the concatenation of these two. So if you wanted to fix this program, you could add right here contactInfo+, and then all of this. That would have taken the current value of contact info, Lyla Fujiwara, and concatenated it with the email address in this format. One other short note, I am making an assumption that for our email addresses @justjava.com, it doesn't matter if this is a capital or lowercase F or if this is a capital or a lowercase L. For many email services that consumers use, this is true. For example, for Gmail, this is true. You can leave this as lower case or upper case and it will still reach the same person, but if you were worried about the difference here, that's definitely a good catch. As I've said and I'll say it again, case really does matter a lot of the time when we're talking about anything to do with computers. You've just seen some tricky situations involving multiple variables and interesting ordering. Here, hand stimulating to figure out what the computer does is key. Now let's talk about scope. I've linked the video on scope if you don't remember what I mean by variable scope. Scope is what differentiates a local variable from a global variable. A local variable is stuck in the block of code that it was defined in, usually a method. Whereas a global variable has a little bit more freedom to go to different parts of the program. Let's look at a few different questions to see if you understand the difference. In these exercises we're going to look at longer code examples. All of these examples will either have no errors or it will have an error involving scope. Here's the first example. In this scenario let's say you're a market researcher, and you've made an app to figure out which sugary drink consumers prefer, UdasiCola or Pepcity. You'll talk to people on the street and hand them two drinks. And then ask them to vote with the app to say which one they like better. Let's look at the code that goes with this. These ellipses here and here mean that there's more code that I'm not showing you. But I'm showing you the important code that has to deal with voting. When you click the Udacicola button, it'll call the voteUdacicola method, which adds one to udacicolaVotes, a variable that's meant to keep track of how many people have voted for Udacicola. In the same way, let's say that you've programmed the XML so that when you click on the Pepcity button, it call the votePepcity method, which also adds one, but instead to the number of Pepcity votes. Then, for the sake of argument, let's say that there's a third secret button which only you can use. Which will show the votes. That button will call the showMeVotes method, which will show the udacicola votes versus the pepcity votes, so you can compare the two for your research. Okay. So let's start thinking about the scope of some of these variables. We'll look at the udacicola votes variable first. >From what you see here in the code right now, is udacicola votes a local variable or a global variable? Now this doesn't mean should it be a local variable or should it be a global variable. Look at the code and tell me, is it instantiated and defined as a local variable or as a global variable? After you answer this there's going to be one more additional question. So the first thing that I asked you, is whether udacicolaVotes is a local variable or a global variable. And you should have determined that it was a local variable. Well, to figure this out, you go to where the variable is declared, which is here, and you know it's declared, because the data type is right here. And you see is it declared Inside of a method, meaning between between the two curly braces here, or is it declared outside of the method? Now, if it's declared inside of a method, that means that it's a local variable, and we can see very clearly that it is in fact declared inside of a method. So it's a local variable. Well, what does that mean? We should also be asking ourselves, if I declared something as a local variable, should I have? Let's think about it in this case. Here's our phone. And we've been talking about udacicola, so let's only focus on when we click the udacicola button. When we click this button, this method starts. It sets udacicola votes to zero, and then it adds one to udacicolaVotes, which is zero. So udacicolaVotes becomes one. Now, because udacicolaVotes is a local variable, at the end of this method, it actually sort of dies, or gets deleted. The fact udacicolaVotes is trashed, or gone, at the end of this method because it's a local variable, causes a couple problems. So why is this a problem? Well, you would think that if three different people voted for udacicola by clicking on the button, that udacicolaVvotes should be three. Well, what actually happens is the first time you click on the button,udacicola becomes zero. It gets one added to it, becoming one. And then it gets trashed. It doesn't exist anymore. The second time that somebody clicks on udacicolaVotes, well udacicolaVotes is made all over again. It's declared again. Because remember, the first time it had essentially gotten trashed. So it needs to be remade. And when it's remain, it's set to zero. Now we add one again to it, but remember the value is zero. So udacicolaVotes is still one, even though the button's been clicked twice. And the same thing happens when it's clicked the third time, it still is one and it's actually trashed again at the end of this method. So that's the first problem. It's not really saving the state between button clicks. About how many people have voted for udacicola. But another problem is down here, this code's actually going to throw an error. And the reasoning for that is because remember I said that udacicolaVotes sort of comes into existence or its scope begins right here. And then at the end of this voteudacicola method. It is trash, it's out of existence. Which means when I come down here, udacicolaVotes doesn't really exist. More technically, we say that this variable is out of scope. Its scope was here It got declared here, and it ended here. But we're trying to use it down here. And it can't be used. Having udacicolaVotes be a local was not a correct decision in this case. And I can summarize why with these two points. It's not saving the vote about between button click, and it's not in scope for the show me votes method. So this will actually cause errors. So this will actually not compile. Okay, so let's look at the other variable in this program. All right. Hopefully this wasn't too tricky. This is actually a very similar situation to the udacicolaVotes. pepcityVotes was also made a local variable. And similarly, its scope is limited to just the votePepcity method, meaning that it gets created here, and then, in this next line, after adding 1 to its value, it gets trashed. That's something you might have noticed is how pepcityVotes doesn't have the initialization to 0 that udacicolaVotes does. This is actually a pretty big error, and will cause your code to not be able to compile, meaning it won't be able to run on the phone. Local variables must be initialized, meaning that they must be given some sort of initial value like we're doing here with the udacicolaVotes. Then we have the same problems that we had Udacicola. Between button clicks it's not actually really counting up how many votes that Pepcity has, and when we do the showMeVotes method, because the scope ends here you actually won't be able to use the variable value down here. So if you said that this has the same problems as the udacicolaVotes does you'd be correct. Okay, let's look at another problem. In this scenario, you're working on an app called Health Check, and what HealthCheck is is basically an app that administers a quiz, and that quiz can tell the person who's using it how healthily they're living. The questions appear in this box here, and the user can answer either Yes, Sometimes, or No, and let's say there's about 100 different questions, and they range from things like, do you exercise more than three times a week? Do you drink less than two caffeinated drinks a day? Or, do you have a supportive social network? Now, the questions are phrased in such a way that when you say Yes, that always means you're more healthy and when you say No, it means you're less healthy. Sometimes is sort of an inconclusive answer. And what the app is doing is really keeping track of a score. When you hit Yes, it adds 1 to the health level. When you answer Sometimes, it remains unchanged, and when you answer No, it subtracts 1 from the health level. Also, once you've selected one of these options, it'll show you a summary of what you just answered and what your current health level is before giving you the next question. We're just going to look at the interaction between clicking one of these buttons and showing the summary of where you're at right here. Let's look at the code. Okay, so here's the code, and I've also provided it in the instructor notes, if you want to take a look at the sort of text version of this. Again, it's not the complete code. These little ellipses here mean that there's code before and after the methods that you're shown here. So how does this work? Well,.when you hit the Yes button, the yes method is called. This increases the healthLevel, makes a message, and then displays that message. Similarly, when you hit the Sometimes button, the sometimes method is called. The only difference here is that instead of adding 1, you add 0, which means that the variable value doesn't really change. And the format is similar when you hit the No button. The no message is called, 1 is subtracted from the healthLevel and a message is printed. Okay, we have two variables in this program, healthLevel and message. Let's look at message first. So my first question to you is, from the code that you see here, is message a local or global variable? Now, you should have determined that message is a global variable. And you can tell this from looking at where it's declared, which is up here. It is not declared in any of these methods. It's declared, in fact, outside of any methods. It is, though, declared between the curly braces of what we've been calling the main activity class. Okay. So the next question is, should message be a global variable. Well, whenever we use message,we see that we set what message is, and then we immediately display it. When we set what message is, we don't look at a previous value of message. Global variables are good for keeping track of a previous value between things like button clicks or other events you might have in your app. They're a way to save the state of an app. What they're not good for is when you're using a variable as a sort of intermediate value. Remember, when you're executing the code inside one of these blocks called a method, you do each statement sequentially. If your variable is only needed within the sequence of those statements then it doesn't need to be a global variable. It's being used locally. It's being used just in the method. And that's the case with message. It's a kind of intermediate value used just at that moment. So, message should not really be a global variable. Now, will the program not work because it's a global variable? No, it'll work just fine, but let's say I forgot to type this line here. Okay, so if I click the No button. What it's going to do is, well first it's going to take healthLevel and subtract one from it. Now as a side note you might be wondering what the value of healthLevel is. And well, we'll talk about that in the next video. But for now let's just assume it's zero. So we take zero, we subtract one. Their healthLevel is at negative one. And well, we don't have this line anymore, so we just print out whatever message is. Well, what is message? When a global variable is created and it isn't given an initial value, it's given a default initial value. For strings, the default initial value is the empty string, which is basically is a string that has no text in it. This would mean that the user doesn't see anything when the no message clicked. That's not great, but not entirely unexpected behavior. When things get really kind of funky, is let's say that you hit the Yes button first. This will make it, you answered yes, current healthLevel is one, and show it on the screen here. Let's say then after that, you hit the No button. It'll subtract one for the health level making the health level zero again. But it won't set message to another value because let's say we deleted this line. So message will have the old value from up here. You answered yes, current health level is one. And it will display that again. Again, this all happens because healthLevel now exists between multiple methods. So whatever value was here before, if we don't change it here, we'll still be there. And no sort of compile error will be thrown. Now if message was a local variable, when you forget to set it to anything here, it will complain and actually not let you run your app. But because you've made it a global variable, it won't complain. It will just print out what it had before from the previous method. Which is wrong. So to summarize, message should not be a global variable. Why? Well it's not really used in between methods. Or it'll have some value from another time that the variable was used in another method. Because a global variable will have a default value set, or it will have an old value from when it was used in one of these other methods. Now it's only if we make an error, and we forget to set it to the correct thing, but we shouldn't make our job any harder for ourselves. Okay, that's only one of the variables in this example, so let's look at the other one, healthLevel. For the rest of this practice set you're going to gets build some apps. You'll work with me through a basketball scoring app, and then we'll give you a few optional apps that you could try if you want to hone your skills a bit more. Okay, the basketball scoring app. This app is called court counter and the purpose of this app is to keep track of the score of a basketball game. Now they end up is going to look like this but will build it up in stages. For the less athletically inclined, and for our international audience, I'll go ahead and explain how scoring and basketball works. The first way to score a point is within the three point line which, is a circle around the basket. It's the most common way to score and it's worth two points. The second way to make a basket is behind the three point line which is this line right here. It's quite a bit harder but it earns you three points. Finally the last way that a team can score is something called the free throw. When a player is fouled such as kicked in the shins, they get to try to make one free basket behind the free throw line Players will be lined up along either side, but nobody will stop him or her from trying to make that basket. A free throw is worth one point. With the court counter app, you can see that you have a team A and a team B. You also have the option to give three two or one free throw point. If you click on the buttons to award team points as they score. And if you want when the game's over you can hit the reset button. Okay, so to start off we're going to make a new app. You've done this a couple times before so I'm just going to give you the major checkpoints that you need to hit to make your new app. Make sure that you call your new application court counter and that you give it the right company domain. Set the minimum SDK to A.P.I. 15 and choose the empty activity template. You can go ahead and accept any other defaults. Then you should be done and ready to get going with this app. Okay, we've done this a couple times before, so I'm going to move pretty quickly. But I've linked to the original video if you want a slower walk-through. All right, click Start a new Android Studio project. Our app is going to be called Court Counter. And as long as you haven't changed anything, your company domain should be the correct android.example.com. And then I'll let you decide where you're going to locate your project. Downloads is probably not a good place, so I'm going to change that for myself. Okay, we'll put it in Documents. As with before, we're designing only for a phone and a tablet, and we're going to use API Level 15. And we'll stick with what we know, use Blank Activity, and keep these defaults. All right, it's going to load for a little bit. Okay, great, and there's my new Court Counter app. Move on and we'll make this more than just a Hello World app. Remember, when you're making XML, there are three steps that you can follow to help create your layout. Step number one is to select the views. Here you're going to think about which views you're going to use and how many you'll use. To help you plan, I want you to tell me how many TextViews, ImageViews, and Buttons you plan on using. If you don't plan on using one of these views, just go ahead and put zero in there. Next, step two is positioning the views, and, if you remember, this has to deal with view groups. I want you to tell me which view group you think you're going to use for this layout and why. And hint, really we've only learned about two view groups, so it should be pretty easy to figure out which one it is. And finally, step three is to style the views. And this is where you think about what kind of attributes you'll use to change things like text color. And really the attributes here that I want you to pay attention to are attributes that will help make the app readable. We're going to make it pretty in the final stage. So think about things like margin and padding. There's also two helpful attributes, layout and layout gravity, which help you align and center views. I've provided a link to their documentation in the instructor notes so that you can read more about these two attributes. Okay, and finally, when you're done, go ahead and click this check box right here. If you forgot what the app looked like, it looked like this. Go ahead and use this picture to help you answer these questions. Okay, I'm going to answer these questions before jumping into the XML. First thing's first, is selecting the views. I'll draw boxes around the ones that I see. Okay, so there are five different views, not including the view group, which is technically considered a view. But anyways, these five views are two TextViews up here, followed by three buttons. And there are no ImageViews really here anywhere, so I'd say no ImageViews. Now you might be wondering why I decided that these were two different TextViews, well in the final product the styling of team A and the score look very different. So I've decided to keep these as two separate TextViews. Moving on to step two, which is positioning the views. I'm going to select which ViewGroup I want to use here. And the two that are on my mind are linear layouts and relative layouts. Now this is a vertical column of views. So it's pretty clear to me what I want, and that is a linear layout. Okay, finally I have step three which is style the views. And I'll tackle that one as I'm working with the XML. Okay, so let's jump over to the XML. Okay, I want to be looking at the Text tab. Okay, so the first thing I'm going to do here is just delete some things that I don't need. So I'm going to go ahead and start by deleting this TextView. And all of this paddingLeft, paddingRight, paddingTop and paddingBottom, I'm also going to delete. Being very careful not to delete anything I don't mean to. Okay. Now we had said that the ViewGroup we're going to use is not a relative layout but a linear layout, so I'll go ahead and change that now. And inside of this linear layout I'm going to have two TextViews followed by three buttons. So I'm going to start making those. Now I'm not going to be too specific right now about what the width and height of this TextView are going to be. For now I'm going to just leave it as wrap_content, which will put the box of the TextView right around the text. I'll go ahead and set the text for this TextView as well. And this first TextView's just going to say Team A. Okay, lets see what this looks like in the Preview. Okay, I can see a little TextView there that says Team A. Now let's build out a couple more. So the next one below that is the score, and that's a TextView as well. So we're going to start typing Text. Okay, I see the word TextView, so I press Enter. And I am also going to make this wrap_content. And I'm going to add the text. Well the score usually starts at zero, so we'll have it start at zero. Okay. Now my Buttons. So I'm going to start typing the word Button. Go ahead and wrap_content for these as well. Okay, now the first Button is going to say +3 Points. I'm going to go ahead and copy this and paste it once, paste it twice to get two more Buttons. And we'll have a Button that says +2 Points and a Button that says Free Throw. Okay, let's see what that looks like in the Preview. Well, I seem to have three Buttons. I can see Team A and zero. So I have all my views, but this doesn't really look like what the end goal is supposed to look like. Remember, they're in a vertical column. So I think I have to change the orientation of my layout, so I'm going to go ahead and do that. So I'll start typing orientation and I want it to be vertical. Okay, that's looking a little bit better. Now these Buttons were actually expanded to sort of fill the width of the window. So I probably don't actually want to do wrap_content for the Buttons, instead I'm going to do match_parent. So, let me change that right now. Okay, so the widths of all my Buttons are now match_parent. Let's go to Preview. Okay, that's looking better, they expanded out. All right. Well, my text is still kind of squished into the corner, and to fix that I'm going to use something called gravity. Okay, here I am with a Google Drawling, now let's make a text box in Google Drawling. Okay, so this is a lot like the bounds of a view. I could type the word Team A, and by default it'll be in the upper left corner. And this is the same with TextViews, when you put text in a TextView, by default it'll be in the upper left corner. Now, with Google Drawings, I could select this text and use basically the equivalent of an attribute, called a line, to get it to be centered horizontally inside the text box and centered vertically inside the text box. Pretty cool. Taking the content of the view and moving it around inside of the view boundaries is exactly what layout gravity does. And if you're thinking this might be similar to some of the alignment methods that you can use with relative layouts, it is, but you can use the gravity attribute with linear layouts, which is what makes this powerful. We'll take a look at it in code. So, I'm going to take my first TextView and I'm going to start typing gravity. Okay. With gravity, I have two options, layout gravity and gravity. I just told you about the gravity attributes. So that's the one we're going to use. Okay. And then I have a bunch of options here, and I think I want it to be horizontally centered. So, that's what I'm going to use. And I'm going to go ahead and see in the Preview what that did. Doesn't look like it did much, but actually there is a reason for this. So if I click here, and let's zoom in since it might be hard for you to see. Okay, so here we have Team A, and you can kind of see the view boundary around it. Well, if I were to tell you that this was centered inside of the view, you really couldn't argue with me. It does seem to be centered inside of the view, the view's just very small. Going back to our Google Drawing, it's kind of like if I decrease the size to be just the size of the text. It's centered, but it doesn't really look very different from if it were pushed to the left. Okay, so if I wanted to center within the phone, I need to make the view stretch the length of the phone. Which is going to require us to change the width. Okay, so back here I'm going to close my Preview. And I'm going to go to the width here. Instead of doing wrap_content, I'm going to do match_parent. Okay, let's look at our Preview again. Zoom out. Okay. And that's looking a lot better. It seems to be centered up. So let's do the same thing with the score here. Okay, so I'm going to add gravity to this as well, and gravity in all the layout gravity. center_horizontal and I'm going to change the widths to match_parent. Okay, let's check it out again. Cool! So, everything is centered up. It's looking pretty good. Except it's all really kind of squished together, there isn't a lot of breathing room between these elements. I'm going to give each of the TextViews a padding of 4. I'll start typing padding, I'm going to do 4dp. Remember the dp? And I'm using just padding, not padding bottom or anything like that. And that'll provide 4dp around the entire TextView. Let's see what that looks like in the Preview. Okay. That gives me a little bit more space. I'm going to do the same to the Score TextView. Okay, now I'm going to try to do the same to the Button. Hmm, well that didn't seem to do too much. What if I make it a little bit bigger, like 8? 20? Hmm, interesting, so it seems to be making the Button itself larger. I don't want the Button itself to be larger, I want the space around the Button to be larger. And actually, that's a better job for layout_margin. Remember, padding is actually adding padding inside of the view, whereas margin puts space around the view. So we're changing this to layout_margin. I'm going to do 8dp. Well that looks better. Now there's space around the view in between these two views. So let's go ahead and do that with the other buttons. Margin, not padding, layout_margin. Okay, so that's looking pretty good. Now if you chose different attributes than I did, like maybe you had the padding five instead of four, that's okay. Remember, at this point I'm just trying to make things readable. We'll worry about all the font sizing and pretty colors at a later stage. Okay. And awesome work. You are done with that step. So our layout's looking pretty good, but when I press these buttons, nothing's really happening. What you're going to need to do is associate the XML and the Java so that when you press a button some sort of event happens in the Java code. Now you've done this already with the Just Java app, so you're going to do some similar steps now. Okay, so the first thing you're going to do is copy and paste over the displayForTeamA method, which I've provided in the instructor notes. I'll show you how to do that right now. Okay, so here I am in my XML code, but we actually want to be in the Java code for this. Now, you might have Main activity.java opened in another tab, but if not, go ahead and head up to the Java folder, and then click on the first of the two, and you'll see main activity there, you can double click to open it. Now, this is the main activity class and it contains these code chunks called methods. What I want you to do is paste it inside of the main activity class, but not inside of any of the other methods. So let's look at where the main activity class starts. It begins up here, and I'll scroll down a little more slowly, and it ends down here. Right before the last curly brace, so not within this method, but right here, so now I'm going to paste the code using Command+V. I'm on a Mac, if you're on a Windows, you can use Control+V. Now I'm seeing a lot of red, and that's actually because I don't have auto-import turned on on this computer. So I'm going to do that. If you're also seeing red here, that means that you're probably having the same problem. Catherine showed how to do it in lesson two and I've provided a link in the instructor notes if you need to watch that video again. Okay, much better. I've still got a little bit of red. Let's resolve that right now. Okay, so I've done step one. The next thing that you need to do is change the ID of the score text view to be team_a_score. I'll also show you how to do that right now. For this one, I'm actually going to go over to the activity main XML, and now we're in our XML and I'm going to look for the TextView that displays the score. Here are my two TextViews, and it's this TextView here that has the text zero, which is displaying the score. I'm going to set the ID for that, I'll just go ahead and start by typing ID, and I do want an ID. Okay and now it's giving me different options, but i'm going to use the at symbol plus id. And then i'm going to type my id in. Which if you remember it was team_ a_score. Okay cool. All right and it should be typed like that exactly. And what you're looking for is that this word right here, team a score matches exactly with this word right here, team_a_score. And once you do this, this should change from a unhealthy red color, to a healthy purple color, and your display method is going to work for you. If you want to test it out, you can actually go up in your Java code to the onCreate method. Now early on in the lesson, Catherine had mentioned that onCreate occurs right when your app starts up. So I can actually add the code here, displayForTeam A, and give it whatever your favorite number is, mine happens to be eight, and I should be able to see that immediately the score will get updated to eight. So I'm going to go ahead and run this, and see if that is true. Okay, so here's my app, and it's very small, but you should be able to see that this is 8 and not 0. So I did the first two steps correctly, and you should test, too, to make sure that you did those first two steps correctly. In the next lesson, you're actually going to learn about how this code here works, but for now, just revel in the magic. Okay. Now, for the fun part. So, I'm not going to give you instructions about how to do this, but I will link you to some videos where Catherine did very similar things. I want you to give the following behavior: when the plus 3 points is clicked it should show three. When plus 2 points is clicked, it should show two. When free throw is clicked, it should show one. Here I'll show you on my phone. Okay, so here is what I mean. I have my app I click the plus 3 points, 3 is shown, I click plus 2 points, 2 is shown, and I click free-throw and one is shown. Now when I click plus 2 points again it just shows two. Its not adding anything yet. Now I know this isn't the final functionality that I was looking for, but it's a good intermediate state. It's important to take intermediate goals to get you closer to the final goal. You do something small like you already know how to do, check, make sure it works and then modify it to get what you need. So, we'll start with this, and when you're done go ahead and check this box. To start solving this problem, I'm going to write some methods first. Methods are little blocks of code between curly braces and I can get my buttons to trigger my methods. So I'm going to have a method for each of the buttons. I'll start with the plus three points button, I'm going to type public void, now this is when you would type the method name. And you should feel free to name the methods whatever you'd like. And I say that as long as it makes sense. So I'm going to try to name this method very explicitly what's going to happen when you click the plus three points button. This method name is going to be addThreeForTeamA. And again, you could name it something a little bit different, like addThreePointsForTeamA. Okay. Now after that, I'm going to type the method parameters. And you don't know too much about this, but you'll learn about it more in the next lesson. It's going to be view with a capital V, and then the letter V. And then, I'm going to make an open curly brace and Android Studio is smart enough to give me a closed curly brace to close my method. And now any statements that I put in here are going to be what happens when this method gets called. So what I want to happen is for it to display for team A, and then I'm going to give it the number that I want it to display, and I want it to display 3. Now this hasn't been associated to my buttons yet, so I have to go back to my XML, and I'm going to go to the button that's plus three points, this one right here. And I'm going to add an onClick attribute. And in this onClick attribute, I'm going to give it the exact same name that I gave the method in my main activity. And actually Android Studio's jumping the gun a little bit. It's even trying to suggest that I should put in here, addThreeForTeamA. Because it kind of sees all the methods that are available in main activity and this one seems to fit the bill. So sure I am going to click on this. Okay, now I have the onClick attribute here. With this button that says +3 Points, and it's going to trigger addThreeForTeamA, and I could go back to my main activity and see that inside of addThreeForTeamA, it says displayForTeamA(3), which will make 3 appear on the screen for the score. Let's make sure all of that logic is Okay, here's my app, and I'm going to press the +3 points. Yay, and it says 3. It might be kind of small on your screen, but believe me, it says 3. These other buttons don't work, though, so that's as expected, because we didn't change any of the code for them. All right, let's keep working. So, now that I know that that worked, I'm going to go ahead and do the same thing for the other two buttons. In fact, I'm going to do such the same thing that I'm going to copy this and I'm going to paste it twice. And I'm just going to say, addTwoForTeam A, and addOneForTeamA. And here, I'm going to change this to displaying 2 and this to displaying 1. Okay. So that's pretty much the same thing for 2 and 1 that I did for adding 3 points, but I also have to remember to go over to the XML, so I click to go over here. Okay. And I'm going to add two more onClicks. So for my +2 Points button, I'm going to do a onClick, and oh, how nice of it. It's giving me three different options now and I want to make sure to select the right one. So, this is +2 Points, so I'm going to select addTwoForTeamA. And now I'm going to come down here. Type onClick. And select the addOneForTeamA. Okay, so, I'm feeling pretty confident that that's going to work. I'd bet some money on it, but I should still run it to test it out. Okay, so, I press +3. Still works. I press +2. Oh, cool. It says 2. And now I press free throw, and it shows 1. So, awesome. I've completed the task. And because I've completed the task, I get the honor of checking this box off. Okay, so here's where we left off with the app in the last exercise. It's interactive, but barely. Partially because it's not really saving any information. Sounds like we're going to need a variable, or variables, and I want you to help me plan what variables that you'll need. Now in this simple version of the app, there's no ability to reset, and we're only talking about one team, Team A. Given that we know that when you click a button we want the score to increase here. Can you tell me what variable, or variables, that you think we need to create for this app to work? I've given you a number of options to select from, check which of these you think we need a variable for. Do we need a variable to keep track of the number of points for a 3 point shot, or a 2 point shot, or a free throw? Do we need a variable for the number of shots attempted, a variable for the number of fouls, and/or a variable for the score? Really the only thing that you absolutely need to keep track of is the score. You might be wondering why. Well, between button clicks we want some way to save the value that's been accumulating for how much Team A has scored. Well, we don't really care about the number of fouls. There's nothing on the screen that represents that, or does a calculation with that number. Nor do we care about the number of shots attempted. Now, the other three possibilities are for the amount of points that you get for each shot. These numbers won't vary. A user isn't inputting a different value. And the three point shot isn't suddenly going to become worth five points in the middle of a game. This means there isn't a huge amount of necessity in making these guys variables. Now, that said, it is perfectly reasonable for you to say, I want a number in my app that doesn't change, but that has a name. like a variable. Now what I've just described is called a constant, and a constant is kind of like a variable. It has a name and a value. The thing that's different though is the value is, for sure, never going to change. Now we won't be using constants in this app, but I've provided some documentation in the instructor notes if you're interested in learning more about them. You've decided like you need to create a variable to keep track of score. And for now, that's the only variable that you're going to need. Now, you might be wondering why I don't just call this score. Well, it's because I'm thinking ahead to a time when I might need to keep track of more than just one score. And, it will be a little bit confusing if I have a variable named score, and another variable or five named something else. So, we're going to be very explicit, and call this score Team A. Now, in a fair basketball game, both teams start with 0 points. So, when you're creating this variable, I want you to initialize it with the value 0. Before you get started though, you should think about this a tiny bit. For example, should this new variable, score Team A be a local variable or a global variable. Once you've decided that, you can go ahead and declare it, and initialize its value to 0. To make sure you did it correctly, go ahead and type the code here that you used to make this variable. We are looking for the exact spelling and capitalization shown here, so make sure that you use it. Right, the first question. Should scoreTeamA be local or global? I'm going to answer this before even moving onto the code. Now, you had a little bit of practice with this in the earlier exercises. Given then the score needs to be saved and modified for a longer period of time and in between button clicks, it should be global variable. Okay, so I'm going to go ahead and define it now because I have a little bit of a better idea of where I should define it because I'm making it global. Okay, here I am in the code. I'm going to go over to the Java file, and you might see that a couple things changed. Actually, really, the only thing that changed is I added some comments here to say what each of these methods does. Besides that, everything's the same. Okay. So, I need to define a global variable. I'm going to scroll up, and the reason that I scroll up is because by convention, when I have global variables, I put them right here at the top of the class. The difference in location of where you define a global variable versus a local variable is that local variables will be defined within methods, whereas global variables will be outside of the methods. So I'm putting it outside right here. Well, I know it's a number, and because you're always going to score at least one point, and you're not going to score 1.5 points, this number isn't going to include decimals. So, a type of integer is actually a pretty good choice here. So, I'm going to type int. Okay, and after the data type comes the variable name, and I'm going to use scoreTeamA. Okay, and if I was just doing a declaration, I'd be done. But, I was also told to initialize this to zero. So, forget the semicolon for now. I'm going to write the equal sign also known as the assignment operator and I'm going to set it to zero. Oh, and don't forget the semicolon. Okay, so, there's the answer for that. Good work so far. Okay, we made a variable but nothing about the functionality of the app has changed yet. The next thing that I want you to do is to make it so that when you click the +3 POINTS button, the score goes up by 3. Meaning that if I click this multiple times, it should be adding. These other buttons don't have to work yet. It's fine. Now again, I want to stress planning. So, before you actually go ahead and write this in Java, you're going to write it in English. Or at least you're going to write it in a special kind of English that Katherine talked about in the lesson called Pseudocode. So, let's say your goal is that when the +3 POINTS button is clicked you want two things to happen. And I'm making this kind of a multiple choice problem. So the things that you can have happen during Step 1 are, you could display scoreTeamA. You could change the value of scoreTeamA to 3, or another way of saying that is set the scoreTeamA to 3. You could display the scoreTeamA plus 3. Or you could increase the scoreTeamA by 3. And then for Step 2, you have these same options. So just randomly, if you want your two instructions to be, Display the scoreTeamA, Set the scoreTeamA to 3, you would select A to first Display the scoreTeamA, and then B, set the scoreTeamA to 3. Okay, you tell me, what do you think the two steps are? Okay, so the answer to this is that we'll update the score to be 3 more than it was before and then we'll display it. Another way to say update the score to be 3 more than it was before is to say increase the score by 3. So Step 1 would be D and then to display the score is Step 2. So, I'll select A. Okay, so these are the correct two choices. We need to be clear that we're increasing the score, which means that we're taking the old value of the score and we're adding 3 to it. Okay, so let's look at this with a little bit more detail as to why this will correctly work. Okay, so my score starts at 0. And then I click the +3 button. According to my Step 1, I first increased the score by 3. It's currently 0, I add 3 to it, it becomes 3. Okay, so far, so good. And then, in the next step, I display it to the phone screen. Let's draw a little phone. Okay, so there's my phone, and it will display the score, which is 3. Looks pretty good. I press it again, it goes and looks at the current score, and then increases it by 3. Making it become 6. And then, it displays it to the phone. And I can see pretty quickly that as I keep pressing it, the pattern will repeat itself, it'll update, it'll display. So that seems pretty good. Now, one of the things you might have gotten wrong is maybe switching the order of these two. So let's see how that would work. Okay, so here's the step switch. If I click the +3 button, the first thing that I do in this ordering is to display the score. So it looks at scoreTeamA, and it's 0, so it removes whatever was there before and displays 0 to the screen. Then I increase the score by 3. Hm, okay, well, so it's displaying 0, but the score's actually 3. When I hit this again, remember, at this point, the team has scored six points. It goes and looks at my score which is 3, and displays it, and then it increases the score by 3. Hm. Okay, so in this case it seems that my score is always three points ahead of what's actually being displayed on the screen, and that's no good. Okay, so let's look at this scenario. I press the +3 point button. And Step 1 is to set scoreTeamA to 3. And then, Step 2 is to display that score. Okay, that looks pretty good. I press +3 Points, and it's displaying 3. Now, I press it again, though. And Step 1 is to set scoreTeamA to 3. Kind of silly, but that's what you told it to do. And then display scoreTeamA. So as you might be able to see, I could keep clicking +3, but it's going to just remain at 3, because it'll keep setting it to 3 and then displaying 3. This is actually essentially what we're already doing right now with the app. But instead of simply saying display 3, we're using a variable that's value is always 3. Okay, let's look at another example. Now, you might have found this option very alluring. After all, it's saying display and it's saying to add 3, and that just seems like it's right. Now, I'm not even going to put anything in for Step 2 right now. I'm just going to see what happens if this is the only step that occurs. So, I press +3 Points. And then it displays the scoreTeamA +3. So I look at the score for Team A, which is 0, and then I add 3 to it. So it's going to display 3. Okay, that's looking pretty good. Press it again, and it's going to display the score for Team A, which is still 0, and then add 3, which is 3. Hm, so this has the same problem as the last one, it's just going to keep displaying 3. And this is because when I say display scoreTeamA +3, it's not actually changing the value that's inside of scoreTeamA. It's just using that value to do some calculation. Now, there is a way I could actually get this to work. Okay. Let's look at this one. So I press the +3 points button, and it goes to Step 1, which is to display the scoreTeamA +3. ScoreTeamA was 0, so 0 plus 3 is 3. And then, it increases the score of Team A by 3. Okay. I press the button again, it looks at the score of Team A, which is 3, and it adds 3, so it displays 6. Then, it increases the score of Team A by 3. So, this is looking pretty good, and it actually is technically a correct answer. It will do what you want it to do, but it's a little inefficient and strange for a couple of reasons. First, you do the same calculation twice. Here you're adding scoreTeamA +3 and when you do the increase you have add scoreTeamA +3 which uncovers how it's generally just a little backwards the way that were doing things. This ordering seems a little bit more difficult to understand, it's also just a little bit more complicated because you added that extra step. So, increasing the score by 3 and then displaying is a more straightforward answer, and the one that I'm going to go with. So, we've talked in detail about what the PseudoCode for this looks like. So, now what I want you to do is translate the PseudoCode to code code and add that to your app. So, to be a little bit more explicit, these are the instructions that we've written out in PseudoCode. And, you've actually already transformed this PseudoCode into code code. This is roughly equivalent to Setting the onClick method for the 3 Points button to relate to the addThreeForTeamA method. And then, coding in the Java code the addThreeForTeamA method. You've already done this. Now, what you need to do is translate these other two lines of PseudoCode into code code. And then, add them to your app. You could go ahead and type them here first, if you'd like, to see if they're correct. Or, you could add them in your app first,and then paste them back here, to certify that you've done them correctly. Whichever you prefer. Okay, so let's figure out what these two steps would look like in code. So the first one is you're taking the score for team A and you're changing it. And I'm just going to say changing it for now, and we'll figure out what we change it to in a second. You'd have this variable. And whenever you want to change the value of this variable, you need to use the assignment operator. And then you can figure out what you're changing it to. Well, you're increasing it by 3. Which means that you're taking whatever is currently in Score Team A and adding 3 to it. So two things are analogous. Increasing by 3 and taking the current value and adding 3. So, if we take the current value and we could get that by just writing the name of the variable. Addition symbol and 3. We are increasing the current value of Score Team A by 3. And of course, end with a semicolon. Now I'm not putting an INT here because this variable has already been declared. We did that a few videos ago. It'll be more clear when we look at the code. Anyways for now let's quickly do this next step. So to display the score I need to use the display method that I copied over. So before I was just telling it to display 3. But I don't want to display the number 3. I want to display whatever value is in Score Team A. So what I actually should put here is Score Team A. Okay, and I don't want to forget my parenthesis or my semi-colon. All right, let's put this in the code and make sure that everything works. So here I am in my java code. And I'm going to go scroll down to this addThree forTeamA method, because this is the code that happens whenever I press the plus three button. All right, I'm going to remove this for now because this is old code. And I'm going to perform my two steps. The first one was to take the variable scoreTeamA and set it equal to its old value plus 3. Okay, this is the increase by three step. And then the second step after that is to display it and when I say it, I mean the variable score, Team A. Okay, so there are my two steps. Okay, moment of truth, let's hit plus 3 points. Okay, it increased to 3. It's kind of small but it increased to 6, 9, 12, 15, okay, awesome. This seems to be working. Now, these other ones don't work, but we didn't expect them to. Okay, so you changed around the code so the +3 Point button would actually add plus three points, and continually increase. Now, I want you to do it for the +2 Points button, and the Free Throw button. Take a moment to think. Do you need to create any additional variables to do this? Yes, or no. After you've answered this, go ahead and update your app. The correct answer as to whether you need to create any additional variables is, well, no. You have a variable keeping track of Team A's score. These two buttons are simply going to affect the value that's stored in that score, and there's no other variables that are needed. Alright, let's see what this looks like in code. We can actually model this pretty closely from off of what we did for addThreeForTeamA. Whoops. I see a little error. Let's add a space here. Sorry, where was I? Yes, we can do the same thing for one and two as we did for three. In fact, I don't like typing. I'm going to just go ahead and copy this. And I'll paste it here, in the addTwoForTeamA and here in the addOneForTeamA. Okay. So now for example, in addTwoForTeamA, it's adding three to the score and then displaying the score. But I don't want it to add three, I want it to add two. And here, in addOneForTeamA It's adding 3 to the score, but I actually just wanted to add 1. But in both cases, I still wanted to display the score. I'm just changing it by a little bit of a different number. Let's run this to see if it works. Okay, moment of truth. Okay, looks like it's working. Okay. You're doing a great job. And your app is looking pretty good. Unfortunately, right now, it only really works for a pretty one sided basketball game. What we really want is for it to be able to keep score for two teams. Let's start with the xml, and then we can worry about the Java. Okay. So you're going to be adding another column for team b. And remember we're just focusing on the XML right now. If we remember the design for this first side. It's a stack of views all within a vertical linear lay out. Now the side for team B looks pretty darn similar. Try as we might though, you can't have two root views. So you're going to need to use nested lay outs in this case. You should be thinking of each of these linear lay outs, kind of like a view in itself. So if we think of this all as just one view, and this all as just one view. And if each of these two views need to take up equal amount of space, so basically half of the screen. What parent view group would we need to use? Put your answer to that here. Now, once you've got this right, hopefully that will give you enough information to start coding this out. Give it a try, you can always watch the solution video if you get really, really stuck. Now, once you've coded it up, it should look like this. So, Team A, well that side should still function okay. Team B though, might have well, a bit strange behavior. That's because we haven't really coded up the Java for that side. So don't worry about it, just try to get it to look like this. Before I begin coding, I'm going to answer this question. I really still know about only two view groups, LinearLayouts and RelativeLayouts. Now the key word right here was that these two have to take up equal space. Using layout weight is a really easy way to do this. Okay, let's go ahead and look at the code. All right, I'm not working in Java anymore, so I'm going to go ahead and go over to activity_main.xml. And here's my XML file. So I'm going to start by putting all of this code to another LinearLayout. And this is the parent LinearLayout for my two mini LinearLayouts. And I'm going to move these two lines up here, because they need to be attached to the root view, add a closing brace. Okay, Android Studio automatically made a closing tag for me right here. So, I'm going to go ahead and cut this closing tag, scroll down to the bottom, and paste it. Okay, now I got a red squiggly line, and if I look at the error, I can see that it says I need to have layout_height and layout_width defined. Whoops! All right, let's do that. So because this is the root view, I'll go ahead and make this match_parent. Okay, so I have one LinearLayout surrounding a child LinearLayout right now. And if I go to the Preview, it looks pretty much the same. Okay, so what I'm going to do, is I'm going to copy everything in the Team A LinearLayout, and right below Team A, I am going to paste it. And this is going to be my Team B LinearLayout. So, now things are beginning to look a little bit disorganized. So I am going to do a Cmd+A, or a select all, and then I am going to use the keyboard shortcut Cmd+Option+L to format my code. On Windows, that's Ctrl+Alt+L, that looks a little bit better. Now, I just want to make sure that you understand what's going on here. Scrolling to the top, I have a root LinearLayout here. It starts here, and if I scroll all the way to the bottom, it ends here. Inside of that root LinearLayout, I'm going to scroll up again. I've got one child layout here, which starts here. I'll scroll down slowly. And it ends here. This is for TeamA. And I have another child LinearLayout, which starts here. Scroll down slowly, ends here for TeamB. All right, now I noticed some red up at the top, so I'm going to scroll up again and see what the error says. Wrong orientation, no orientation specified, and default is horizontal. Yet this layout has multiple children, where at least one has width match_parent. Hm, well I do want it to be horizontal, but let's go ahead and specify the orientation. Again, this is not technically needed, because the default is horizontal, but it's good to be explicit. Okay, and it was saying something about children covering each other up. I'm going to click on Preview. Hm, And this doesn't seem to have really changed very much, even though I went to all the trouble of copying and pasting another LinearLayout. This might have had to do with the error that I just looked at. It was saying that it's a horizontal layout. So it's trying to lay these two LinearLayouts next to each other, but that the LinearLayout has a layout_width of match_parent which fills up the screen. So basically my first LinearLayout is filling up the screen, and then the other LinearLayout is getting placed next to it somewhere off screen. So let's think about what we actually want to have happen at this point. We want to have the two layouts taking up equal space and next to each other. So this when we're going to need to bring in layout_weights. I'm going to take the first LinearLayout and give it a layout_weight of 1. I'm also going to set its width to 0. Okay, so we can see already that we do in fact have two LinearLayouts, they're just not really being displayed properly. But this is a bit better. So I have to put a layout_weight also on my second LinearLayout, this one right here. So I'm going to scroll down. Here's my second LinearLayout. I'm going to do exactly the same thing. I'm going to say that it has a layout_weight of 1 as well, so now they have equivalent layout_weights. And then I'm going to set the width to 0. Okay, and the reason that I set the width of both of them to 0, is basically, that if both of these sides aren't taking up any width. Then, it's going to take all the extra space, which is the entire screen, and divide it up, giving half to one and half to the other, because they both have the same layout weight. If that's at all confusing, I've linked to a few videos in the instructor notes that talk about layout_weight. Okay, but this is looking pretty good, except it says Team A. I'm going to scroll down to change that here, change this to Team B. Now you might have noticed that there is also an error here, and that error occurs because, well, we have a duplicate ID. Remember, I just copied and pasted the code. So, we basically have two things that are trying to have the same id of team_a_score. So, I'm actually going to change this to team_b_score. Okay, this is looking pretty good. It's a little hard to see. I'll zoom in. But, it says Team B here. And I got all the correct buttons, and all the correct text views. So I'm going to try to run this on my phone. Okay, and this looks pretty good. Now if I press the Team A buttons, it's updating so that's great. If I press the Team B buttons, well, it's also updating. That's special. But remember, we just wanted to get the XML right. We didn't really care about the Java. But now that we got the XML working, why not fix the Java? Okay, our XML's looking pretty slick, but we still have to add the interactivity with Java. Now, using the previous exercises as an example, you're going to make the right side update for team_b. Before doing anything else you're going to copy and paste the code for displayForTeamB from the instructor notes into your own code. And you're going to update the text view ID for Team B to team_b_score, if you haven't already. I'll show you how to do both of these now. All right, here we are in our Java code. I've got the display for Team B code copied, I'm going to do this right below, not inside but below, the displayForTeamA and paste. To make it not inside, you want to make sure that it's after this bracket right here. And you know that the two curly braces match up because when you put your cursor next to one of the curly braces, the other one highlights. Okay, so I've pasted this code here, good. Now I need to go over to my XML code, get rid of the preview, okay. And I'm going to scroll down to this TextView here, and I actually already updated this in the last video, but if you need to update it, I'm going to pretend I didn't, you could type id and set the id attribute. And remember, you want the @+id/ and then you type the id that you want, in my case, I want team_b_score, okay, cool. Okay, and now you're pretty much ready to start hooking up the Java. I'm not going to give you too, too many instructions, but, if you're feeling like you might get stuck, here's some things to consider. Think about how you're going to associate the buttons with running some code in, Java. This was one of the first steps we did for the team a side. Next, consider hat new variable or variables you'll need. Hint, you're going to need at least one. Finally, think a little bit about what's going to happen when you click on each button. Now, I just want to point out that these steps loosely relate to the steps we used to make the team a side. So if you're feeling really, really stuck, reviewing those videos again might be helpful, and then, once you're done, you have the satisfaction of checking off this box, okay, get to it. Okay, let's consider these questions. So, how will you associate buttons and methods? Well, we're going to make some methods first, and then we'll associate them by using the on click attribute of the buttons. Okay, so the next question is what new variables will you need? Well, you're actually only going to need to make one more variable. And this is to represent Team B's score. Team B's score needs to be a variable, and it needs to be a global variable, for similar reasons that Team A's score needed to be a global variable. And these reasons are basically, that you want to save the score between button clicks, and you want to be able to update the score. Now, you can't use the same variable for both. If you did that, then the score would be the same. Meaning that whenever Team A scored a point, Team B would also be scoring a point. It's not much of a game that way. So it's important to have a separate variable that isn't affected by changing the score for Team A, which brings us to the next question. How will these scores actually be changed? Well, it's going to be similar to Team A. The scores will change when you click buttons. So, you click a button. This triggers a method that you've associated with the button. You'll add some amount to the score variable for Team B, and then you'll display it. It's very similar to the Team A side. Okay, let's see this in practice. OK, so here's my Java code. And I've scrolled up so that I could see the three methods that allow me to update the scores for Team A. So I want a pretty similar one for Team B. I'll start with just making the free throw one. Okay. So I'm going to go ahead and just start typing, public void. And we'll call this, add, and it's free throw. So I'm adding one point. OneForTeamB. Add one for team B. And I'll put view v in there, curly braces. Okay. Now, hm, what should I do in here? Now I want to basically be doing the same thing, taking a variable, updating it, displaying it. But I don't have a variable yet for team B. I guess I'll go up and make it right now. So I'm going to scroll all the way up to the top. Now right before the variable score team A. I'm going to make int scoreTeamB, and I'll also set it to 0. I'll go ahead and add a similar comment to the one for TeamA. Now I"m going to scroll down. All right, and now I have a variable to work with. So I'm going to say that the score for team B, well I've clicked the add 1 for Team B so it's going to be equal to its current value plus 1, because I'm adding 1 to the score for Team B. Okay, and then I'm going to display it. Now I need to make sure to pick the display for Team B method and not the display for Team A. And I will print out Score Team B, and not the score for team A. Well that looks pretty good. The only thing now, is to make sure that clicking the button will actually trigger this code. So I'm going to go over to my XML. And go down the free throw, for Team B. So, it looks like I'm in Team B. This is the score for Team B. Okay, here are the buttons. It's three points, two points. Free throw, okay, good. So, I actually already have an OnClick attribute here, because I copied and pasted. But I don't want to be adding one for Team A, I want to be adding one for Team B. Maybe I'll change these as well. Okay, well, I'm not done, but it should work for the Free Throw button. So let's try this code. Okay, so let's just make sure that Team A still works. It's looking good. All right, now let's see if the Team B free-throw button works. Yeah, awesome. It looks like it works. Okay, let's try pressing plus two. Hm. Well, that wasn't so great. Let's see why. So, if I scroll up, I can see an error here, that says it couldn't find the addTwoForTeamB. Oh, right. So, I changed these methods to say addTwoForTeamB and addThreeForTeamB. But if I go back to my main activity Java, I don't actually have the corresponding code here. I just have add one for team B. Let's solve that by copying add one for team B and pasting it. Because one, two, three here, so I'm going to addOneForTeamB, addTwoForTeamB, addThreeForTeamB, and we'll actually have to change what it does to add to And to add three. Okay. Then, and I kind of like these comments here. So, I'm going to copy this comment, and paste it here. And it says Increase the score for Team A by three. But this method is actually increasing the score for Team B by one. I'm going to copy it again, paste it, increases the score for TeamB by two. This increases the score for TeamB by three. Okay, so I think that might be everything I need. I'm going to try running it again. All right, moment of truth. Team A still working fine. All right, Team B scores two points. Yes. Scores three points, awesome. Scores two points again. Scores a free throw, free throw. Three points. Cool, looks like it's working. Okay, you're doing a great job. And, the functionality for the app is almost finished. We've got one more thing to add before styling the app, and that's adding the Reset Button. The functionality of the Reset Button is this. So, I can start making a score. Let's say that the teams have some points. When the game ends, you could hit the Reset button, and both of the scores will go back to 0. You can then add more points, and they'll add from 0. Before you start coding, I want you to plan out what you're going to do in PseudoCode. Here's a space for you to do that. To make this a little more challenging and true to real life, I'm actually not going to tell you the PseudoCode that I would use after this. Instead, you'll jump right in to transforming your PseudoCode into your actual Java code. Okay, so write your thoughts here. Okay, so hopefully you've planned out the logic for your Reset button. I want you to take a stab at coding the Reset button yourself. This is a fairly freeform and challenging task compared to what you have been doing, but I think you're ready for it. If you're feeling a little bit nervous, here's some advice. You're going to need to change both the xml and the Java. As far as which one to do first, you should start with XML. This will involve actually making your button. Don't worry about it functioning. Just get it to appear on the screen in the right place. And getting it to appear on the screen in the right place, is going to require a bit more nesting with views. After you've gotten you're button on the screen. You can function on making your button work. This will involve taking the pseudocode that you just wrote and turning it into code code. And once you're done, here's a check box, to check this one off your list. Okay, so here is our picture of our court counter app, or at least how we want it to look. Now, I'm going to follow my own advice and start with the XML first. Let's think about the view situation right now. So, we still have all these views, and these views are in vertical and linear layouts. We have a linear layout for team B and a linear layout for team A. and you can't just have two root views so furthermore, these are wrapped in a linear layout, which happens to be horizontal so that these two child linear layouts can be next to one another. Okay, now we want to add a reset button down here. For the sake of your brain not exploding thinking about all these different layouts, I want you to think of everything inside of this horizontal linear layout kind of like a single view. And now you're just trying to lay out this horizontal linear layout right here and this reset button. You're trying to lay out two views. One view is at the top and the other view is at the bottom of the screen. So the question now is what view group would allow you to have a view up here at the top and a view down by the bottom of the screen? And it turns out that a relative layout is a pretty good candidate for this. I can have my horizontal linear layout here, match the parent for the width, and then wrap content for the height. And I can have my reset button right here, align with the center and bottom of the pairing. Okay, so you have a Relative Layout, and that Relative Layout has a Button child and a Linear Layout child. And the Button child is this Reset button, and the Linear Layout is the Linear Layout here, the horizontal one. Furthermore, this horizontal linear layout has two children, and those children are also linear layouts. They are the linear layout for team A and the linear layout for team B that you see here. The linear layout for team A has two text views and three buttons. The same is true of this linear layout for team B. Five children, two text views, and three buttons. This portion of the layout you've already made, you just need to add this, all right, let's do it. Okay, I'm here in my XML code and so the first thing I'm going to do is is I'm going to make the Root Relative Layout that you saw in the diagram. So here going to type RelativeLayout, and I actually want to cut and paste these two lines because they need to be in the root layout. So I'm cutting them and I'm pasting them here, in my root layout. Okay, now I'm going to close off my RelativeLayout here and I'm going to move this closing tag all the way to the bottom. Okay, so what I essentially have right now Is this part of the diagram. All right, looks like I have some errors as well. Let's see, yes, I haven't defined a height or a width, so let's do that. Now my relative layout had the button at the bottom center of the screen. So, to do that, it's probably going to need to fill the whole screen. So I'm going to do match parents on both. Okay, now I need to add the button. I'm going to scroll down, right here, to where the linear layout closes, but I still am inside the relative layout, and I'm going to add a button. And I'm going to go ahead and wrap content for that button, because it's not a button that expands to fill the entire bottom of the screen or expands to fill the entire screen. And now the parent of this button is the RelativeLayout, and we're going to set the text of this button to Reset. Let's see what this looks like. Okay so my reset button's up here, that's not exactly where I want it to be, but it's parent is relatively out, that fills up the entire screen. So I can align it to the parent. I want to align it to the parents bottom, and I want it to be in the center of the parent, horizontally anyways. Cool, my button seems to be in the right place. I'm going to select everything here. And I'm going to do a command option L on Mac. Which is the same thing as Control-Alt-L on Windows to just reformat the code and get it to look nice. Okay let's go back to our Java code. Now I've got my button but it's not doing anything. Let's start by making a method for it. I'm going to make this right above the display methods, here, public void. I'm going to call this method resetScore, because that's what I intend for it to do. Scroll up, I'm going to make it match these other methods with the View v, and then, curly braces. I won't worry about what's going to go in here for now. I'm going to go back to my XML code And I'm going to do the second part of the hooking the button to the Java code by adding a onClick attribute here for resetScore. Okay, so now when I click this button the code here will be run, but there isn't any code here. Let's figure out what I need to add. Okay, let's go back to this discussion of pseudoCode. When I hit the Reset button, what do I want to happen? Well, I want both of these two scores to show 0. Furthermore, I want the variables for score team A and for score team B to go back to zero. Remember, when I click on any of these buttons, I'm adding two and then displaying the variable. So, if I don't put the variable back to zero, it's going to show an incorrect number. So here’s what I came up with pseudoCode-wise. The first thing I want to do is set the score for Team A to zero. Then I want to do the same thing for Team B. Now both of the scores are zero, but nothing's been displayed yet, which is why in Step 3 I'll display the score for Team A, which has been set to zero. And to be a little bit more specific, I’m going to display the score for Team A here, and then I'll display the score for Team B here. And because in Steps 1 and 2, I've ensured that they're set to zero, they will display zero here and here. Then when I click any of these buttons to update ScoreForTeamA or ScoreForTeamB, it's going to be updating but starting with a score of zero. Okay, so in reset score I'm going to type my pseudo code as code, code. So the first thing I'm going to do is take score A and set it's value to zero using a assignment operator here and the value of zero. Oh and don't forget the semi colon of course. I'll do the same for score B. After that, I'm going to display in the team A spot, the score for team A. And then I'm going to display in the team B spot, the score for team B. I'll also go ahead here and add a comment. Okay, this all seems reasonable. And it's been a while since I've run anything on my phone, so I'm going to press the Run button, okay, cool. I have a RESET button. Let's see if it works. Good, it sets to zero. Let's click a little bit more, just to make sure that everything's still working. Cool, and it looks like it is, awesome. Now this was a little bit of a tricky one. So let me show you what happens if you were to switch around the order, do something a little bit differently. What if I switch these two around? Well, let's just see what happens. Okay, so here it is, let's see what it does. Okay, so I'm going to add some points. Now for the moment of truth, Reset button. Huh, doesn't seem to do anything. Let's try clicking, huh, interesting. Well it's kind of hard to see, but the score before said 19, I hit the reset button nothing changed. But then when I hit free throw it showed one. Lets try with the other side, if I hit plus two points. Oh, it shows two. Lets look at the code again for why that might be the case. So I switched around displaying and setting the score. Just to see what kind of error behavior I might get from that. Let's say TeamA has a score of 30 and TeamB has a score of 40. When I say displayForTeamA it's going to show 30 and when I say displayForTeamB it's going to show 40. Only after that, will it actually set these values to zero. But since it displayed first it's not going to show the values of zero. But the variable will be zero. So when I press something like addThreeForTeamB, it's going to take the value of zero that I set down here, add three, and then display three. So to us, it would look like TeamB went from having a score of 30 then to after clicking the reset button, a score of three, which is kind of a weird jump. Now one way I could fix this besides swapping it back to how it should be Is I could put display zero here. And you can test this out on your own, but this would actually work. It's just a little bit counterintuitive. I like showing examples like this because it kind of shows the beauty and subjectivity of code. Now, in this case, I happen to think fairly strongly that the first way that I had the code was better. But you might start seeing scenarios where there could be two different ways to write the code, and both of them are technically correct. Since there isn't always one right answer, you shouldn't feel constricted to do it the exact correct way. Try coding up something that works your way, see how other people do it, and then compare, who's more efficient, whose code is clearer. These kind of discussions could be a really helpful learning experience. Okay, but I'm going to revert the code back to the state that it was before which was working and now I have all the functionality of my app but it's not pretty, let's fix that. Right now, our app has all the functionality that it needs. It just doesn't look very pretty. So, I'm going to be walking you through how to make those changes. So, the first thing we're going to do is modify something called the Styles file. And that's located in Values, and then it's right here, this styles.xml. So, I'm going to double-click. Okay, now this is a file that you've never really touched before. And I'm not going to go into the details of exactly how this works. We've provided you with some code, which will change your buttons to orange and also change your action bar to orange. And this code will do that because the Styles file is responsible for controlling the basic default styles of your app. Whereas right now in our XML, if we wanted to change the color of a background, we would do it for each element. But if you do it in the styles file, it will do it for the entire layout. Okay, so I'm going to paste the code that I gave you over. This color primary here is the color that the action bar will be. And this color button normal is the color that your buttons will be. Now a quick note. Because of API updates, this colorButtonNormal tag will actually only work if you have API level 22 and above. So, what this means is that if you have a newer phone, you will see the orange buttons, and you can check it out in the emulator. And if your phone's a little bit older, you'll still see gray buttons. Now, there are ways to get around this, but I don't want us to get too caught up in the weeds of how to color our buttons. Okay, let's go back to our activity_main.xml. Okay, cool. So we can see now that it actually updated to show that our buttons are orange, and our action bar is also orange. Our status bar also became a light gray, which is due to us changing this parent attribute right here to AppCompat.Light instead of AppCompat.Dark. It gave us a light theming instead of a dark theming. Okay, let me go back to the XML. So, the next thing on our list is to make a nice little divider bar right here. Okay, so if I click on this linear layout right here, we can see that it's sort of this view that lives here. If I scroll down a little bit, I'll see the other linear layout, when I click on it, is this linear layout right here. So if I wanted a bar in between the two, I would put it right here, after which the first linear layout closes, and before the second linear layout opens. And because the parents of both of these two linear layouts is another linear layout, I'll scroll up to show you. This linear layout right here. Which has an orientation of horizontal. When I put the bar right here, it's going to show this linear layout, the bar, then this linear layout, all in a horizontal row. Okay, let me go down. If you just want to make a colored square, which is essentially what a line is that runs down the center here, we can use a view called, well, View. Okay. Now, just like other views, this view needs a width and a height. Now, we want a thin line, so the width of this view should be one DP. This is what the thickness of the line is going to be. And what I want is for this line to be just as tall as all the text in the buttons in the linear layout for Team A, and the linear layout for Team B. So, I'm going to make the height match parent. Now, this view is basically a box that has one DP in width, and has the height of the parent linear layout of all of this. But we can't see it because the background color is white. So, I'm going to change the background color to dark gray. Okay, so now we have a dark gray line that's going down the center of the screen. But, if we zoom in, we'll see that it's actually going down the entire center of the screen, even through the reset button. And we actually want it to stop right about here. So the way that we're going to do that is we're going to start telling things to wrap content instead of match parent. Specifically, for the Team A and Team B linear layouts, instead of having their height being the entire screen, we're going to have it wrap content for both of these, so that the layouts will end right at the bottom of the buttons. And then, for the parent layout, the horizontal layout that's laying out all of this, we'll also tell it to wrap content. Which will wrap the content up tight against the bottom of the team B and team A linear layouts. And that should make the line the same height as both of these layouts. So, let's make those changes. I'll start with this linear layout right here, which is the linear layout for team B. And I'm going to change its height to wrap_content. Okay, good, it's wrapping the content of the buttons right now. I'm going to click on the Team A layout and I'm also going to change its layout_height, instead of match_parent to wrap_content. So now both of these layouts here are wrapping the content of their children. But the line down the middle is still extending towards the bottom. And that's because the parent of these two linear layouts is still taking up all this space, because it has a height of match_parent, which is the entire screen. So now, I'm going to tell this, as well, to wrap_content. So now the gray line ends here at the bottom of both of these linear layouts. Okay, cool. Now, I didn't want the gray line to extend all the way up here, but that's an issue that can be resolved with padding and layout margins, so we'll do that in a little bit. Right now what I want to do is go through and get all the appropriate text sizes, colors and the correct fonts. So, we're going to just start at the top and make those changes. What I've been told for this first TextView is that it's going to have a font family of Sans Serif Medium. And it's going to have a text size of 14sp. And finally, also that its text color is going to be the hex code 616161, which is a nice light gray text color, okay. So that's the font, the size, and the color for this team A text view. I'm going to move on to the team A score. Now, for the score, the font family is going to be Sans Serif light. The text size is going to be a large 56sp, so that our score is nice and big. And the textColor is actually going to be black, which in hex is represented as 000000. Okay, cool. I'm going to zoom out. So, for our buttons, we actually don't change anything about the text styling or text size or text color. These are fine. But I do want to change the other side and I change it exactly as I change the first side. So, let me do that really quickly. Okay. So I just updated so that these two are exactly the same now. And our text sizes, text sizes, colors, and font families are looking pretty good. So really, the only thing left is to work on the spacing issues that I'm seeing. Okay, we'll start with the first text view here. Instead of a padding of 4dp, we're going to change it a padding of 16dp. Now here in the score text view, instead of a padding of 4dp, we're going to change it to padding bottom of 24dp. And that's because with the 16dp padding here, We already have enough room between these two lines of text. Okay, now for the buttons. Now, our buttons are looking a little bit wide. I don't want to give them a specific width, but I do want them to be a little bit farther away from the edges. Now, we can't use padding, because remember, padding is space added inside the view, and button views have a background color that extends throughout the view. So we're going to be using margin, here. Now, right now, I have a layout margin of 8. But what I'm going to do is change this to a layout margin bottom of 8. And then a margin left and right of 24, which will keep the same spacing, vertically, but will push in the sides of the button. So let's do that now. Okay, so that button's looking a little bit better. I'm going to do the same thing to the other two buttons here. And I'm actually copying and pasting to do this. All right, cool. Now, I don't want to bore you, so I'm just going to make the same changes to this side that I just made to Team A. So, give me one second. Okay, great. Now my two sides look the same. The only other real margin that I have to deal with is the margin for this grey line here, and the margin for the reset button. Let's do the reset button first. Okay, so i'm going to give the reset button a bottom margin of 8dp, and i'm going to give it a left a right margin of 22dp. Okay, now I'm going to scroll up to the grey line. Okay, that's this view right here. And basically, I don't want the grey line to be touching the app bar right here. I want to give it a little bit of space. And I'm going to be using margin instead of padding for the same reasons that I did on the button. Because this is a gray background, so any padding that I use actually is not going to really change anything. But margin, which is space around the view, will. So let's do that right now. Margin top, and we'll do 16dp. Yeah, there we go. There's a little space above the gray line there. Okay, now my code's looking a little bit sloppy because I was just kind of adding attributes willy nilly. So I'm going to do a Cmd+A. Or if you're on a Windows device a Ctrl+A to select all. And then I'm going to do a Cmd+Option+L. And if you're on a Windows device, that's a Ctrl+Alt+L. And that will automatically reformat the code for me. It'll look really nice and pretty. Just as pretty as our new Court Counter app. Now, I kind of want to see this on my phone, so I'm going to load up my phone right now with this newly skinned app. Remember, if you have an older phone, it's going to show the buttons as a different color. But you can always use the emulator. Woo hoo! What a stylish looking app. Now the question is. Is it still working? Well, I didn't touch any of the Java code, so yeah. And the scores are nice and big now. And I've got these wonderful colors for my buttons. Awesome work. While I was working as a Fire Chief, working hard around cardiac arrest survival, training people in CPR in our community and putting AEDs in the community, but I was out to lunch one day. I heard a siren in the distance. It grew louder and ended up pulling right in front of a deli where I was eating, that's when I learned that somebody right next door had suffered a cardiac arrest, and I wasn't aware of that until that ambulance got there. That event made me realize that even though somebody's trained, they're not always in the exact right place and the exact right time, and maybe we can bring technology in, where firefighters are alerted with radios, maybe we could use people's cell phones, who are trained in CPR, even our off duty professionals, make them aware of the events that they were close too but couldn't see. We're crowdsourcing good Samaritans, that's really the purpose of the Pulse Point app. The solution that we have, only can exist with a mobile app, where you have push notifications, you have location based services, you have people carrying phones who have the sophistication to do this. We have an entirely volunteer development team. So Android being so widely adopted, it's a platform when we put our development time into that, we know it's going to get into the hands of a lot of users. As a fire chief I didn't have app developers, no programmers on my staff. But we understood the problem very well. So we ended up turning to a university, NKU, Northern Kentucky University, who had an app development school. And we brought out a number of interns and sucked them up here in the Bay area, and prototyped using interns. Once we've proven the concept, that's when we turned to deductial and workday and they sort of helped take the concept and make it real. When you first load the application, it shows you all the emergencies that are happening around you, not just cardiac arrests. If you want to be notified of cardiac arrests, you just go into the setting screen and you select the CPR notification. Once you've done that, if a cardiac arrest occurs within walking distance of you, you'll be notified. And you'll receive a map, and it'll show you where you are, where the patient's located, and any nearby public access defibrillators. The app also provides CPR instructions. So reminders, and also a metronome that can help you set the proper cadence of your chest compressions. You can't solve this upfront on a white board. It's a constant iteration, learning from your users, getting experience in the field. And you have to be in the game. You have to actually be solving the problem to be able to learn enough to make a difference. We had somebody playing soccer, at a local school, collapse with cardiac arrest, 911 is called, and we have an EMT who's home with his family that lives across the street from the school. Gets notified, just runs across the street to do CPR, an event he would not have been aware of but very close by, and saved the gentleman's life. So it's actually seeing the app save lives, those are where you say, we really made a difference in these people's lives. And we have so much potential to do it again, and again, and again.