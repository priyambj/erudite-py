Hello, and welcome to intro to the Linux shell. I'm Phillip, and in this course you'll learn the basic of how to use the Linux shell or a command line environment. And I'm Carl. The goal of this course is to give you the basic command line tools you'll need to start working with Linux servers. Now, you might have used other command lines before. If you've used JavaScript, you've probably seen the JavaScript console in your browser. Or maybe you've used an interpreter in Python or another language. Or perhaps you've used the command line on your own computer. These are all examples of command line interfaces. Command line interfaces all work in about the same way. You type in a command then they system runs those commands and displays the output then you can type another command and so on. And the idea of a command line interface goes back to the mid 20th century and one of the earliest ways that people had for communicating with a computer, the computer terminal. Now today, terminal usually means a piece of software. But it originally meant a physical piece of hardware for interacting with a computer. Before terminals, people put programs and data through computers using punch cards. Loading a batch of data into the computer all at once. The terminal, by letting a user directly send commands to a computer program and immediately see responses was a huge step forward in user interface. And it's an interface that we're still using today for a lot of reasons. A command line interface is programmable. It's efficient in terms of network bandwidth and you can use the terminal edit files in the distant system without having to first copy them to your local machine. In general, you can be much more expressive with a text based interface than you can by just pointing and clicking. One of the uses of the shells is to administer servers. Machines that might be far away on the network and that probably don't have a graphical environment. For the rest of this course, you're going to be working on a system very much like that. So first, you'll need to set up your own virtual Linux server to work on. Fortunately, that's a lot easier than it sounds like. So let's get started. Okay, so now you can log into your Linux machine, awesome. You've got a screen full of stuff, and at the bottom you've got a line with a $ at the end. That last line is the shell prompt, and it means that the system is waiting for you to give it a command. So just type something, it doesn't matter what. It can be anything. Just type something in and press Enter. Huh, you probably got an error saying, no such command, or that program isn't installed, or something like that. And after that, you got another shell prompt. So just type in some random junk, see what happens. See if you can find anything that doesn't make the shell prompt come back. And when you do find something that makes the shell prompt not come back when you press Enter, describe what it is you did here. Now did you get something maybe like this, with a right angle bracket? That'll happen if you type something with a single quote mark, or with a parenthesis, or brace. In order to get your shell prompt back, with an arrow message, you have to type the matching quote mark, or parenthesis, or brace. Then you'll get a command not found and you get your show prompt back. Now, if you typed exit, or if you type Ctrl+D, you logged out. No worries, you can just log right back in like you did before. And if you got into some other sort of weird state where you're not sure what's going on, you can usually type Ctrl+C or look for instructions on how to exit back to the shell. In any event, errors are okay. Weird stuff is okay. If you get a message from the shell that doesn't really make sense, you can try looking it up in your favorite search engine. And if that doesn't work, post about what you did and what you saw in the discussion forums. So, you've seen two or three different error messages from the shell by now. Let's try a command that actually works. Well, here is probably one of the best known Unix shell commands, ls. ls is an abbreviation for list, and it gives you a list of items in your current directory. We'll talk more about files and directories later on in the course, but for now, you can think of this as listing the files in the folder that the shell is currently looking at. Except, since we just logged into a freshly installed system, there aren't any files in the current directory. It's pretty common for commands that don't have anything to do to just exit with no message at all. There are no files because this is a brand new server and you haven't put any on it yet. Let's fix that. See if you can guess what this command will do. Will it send all of your money to Karl so he can buy more of these silly t-shirts? Will it curl your hair., put stuff in it, and snag in the zipper? Or will download a file from the web? Okay, maybe that was a silly quiz. This command isn't going to send anyone all of your money, and it's not going to put stuff in your hair. Curl is a command for downloading files from the web. Go ahead and run the command. Pause the video if you need. I'll wait. And after curl finishes try ls again, to see that it now prints the name of one file, things.zip. You can think of the terminal as an alternative interface to your computer. The terminal interface uses text instead of graphics, but that doesn't mean it's fundamentally less capable. Many of the things you use a computer for don't really require a graphical interface, it's just that graphical interfaces are the most common interfaces for desktop programs. And some things are even easier to do in the terminal. So, given what you've seen thus far, which of the following activities do you think can be done readily using the terminal? Can you edit and run a program? Is it possible to find files on your computer that have particular names? Do you think it's possible to download a file from the web, if you know its URL? Could somebody edit a major motion picture using the terminal? Could you start a web server on your own computer? Could you start a web server in the cloud? And lastly, could you break the entire Internet? Mark the boxes for the ones of these things that you think could be reasonably done using the terminal. So let's go down this list. Editing and running a program. Well, programs are text files and they're a perfect fit for the terminal's text-based interface. People have been editing and running programs in the terminal for a long time. Finding files on your computer that have particular names. Files names are also text. The terminal interface makes sense here too. Downloading a file from the web, if you know it's URL. You can definitely do that. Although some files contain graphical content, the process of downloading a file can be done from a text-based interface. We'll actually see that later on in this course. So you can use the terminal for some media editing tasks, but you really do need a graphical view for somethings. You probably don't want to edit a major motion picture using only the terminal. Starting a web server on the other hand is definitely possible. The server has a specific kind of program that you can run in a terminal. Really, you can run any program that doesn't need a graphic interface. Starting a web server in the cloud is possible too. You can send commands over the internet to control remote computers, all from within the terminal. And lastly, you cannot break the entire internet using your terminal. If you really tried, you might break your own computer or maybe a computer next to you, but nobody could take down the entire Internet. There's some variety in the way that terminal programs look, but the actual contents of the terminal don't change much. It typically shows informational messages, output from previously run commands, and a prompt for entering new commands. Command prompts can be configured differently on different systems, but it's common for prompts to include the login user's name, the host name, or name of the computer you're logged into, and maybe some other information too, like the current time or what folder the user is in. You can enter new commands after the prompt, and after hitting enter your command runs and the output is printed to the screen. After the output is printed, a fresh prompt is added at the bottom of the terminal, ready for your next command. In this quiz, see if you can identify the parts of the terminal interface. Label the interface elements of this terminal. The items to label are a shell command, that command's output, a current prompt, a previously used prompt, the cursor, and a login message. Enter the number that corresponds to each label in the text box. This first line of text is the log in message. When a new terminal is opened it's common for some informational message to be printed. The exact contents of this message depends on the particular system you are using and how it's configured. On the next line we see a command prompt. The appearance of a command prompt can vary from computer to computer. But in this case it includes my username and the name of the computer I'm logged into. You might have noticed that there's actually more than one prompt on the screen at the same time, this top one and the bottom one. This first prompt is one I used earlier to run a command, so this is the previous prompt. The command I ran earlier was cowsay. You can see I entered the command here, and below that is the opposite of the command. Some terminal commands are pretty cryptic, but in this case, cowsay is pretty self explanatory. It takes one argument, the name of the string which you would like your cow to say. After the output of the cowsay command, we get a new prompt for entering the next command. And finally the last interface element on the screen, is the cursor. You'll probably notice the cursor doesn't quite look like the ones you've seen in other programs. For instance in a web browser or word processor, the cursor is usually a vertical bar. In the terminal is usually a block, but you might also see it as an underscore in some cases. So one thing that we should explain is the difference between the terminal and the shell. The terminal is a program that draws text in a window, and lets you type things in on a keyboard. Technically it's called a terminal emulator, since it acts like one of those old school hardware terminals. It displays output on the screen and it accepts input from the keyboard. But the terminal itself doesn't know what to do with that input. It needs another program to do that. In this case, that program is the shell. When you type things in the terminal just sends what you type to that separate program. When you press Enter, the shell interprets what you wrote as a command, figures out what program you want to run, runs it and sends the output back to the terminal so you can see it. You could actually use the terminal without the shell, with a lot of terminal programs you can tell it what program to run. The default is a shell, but you can have it run say, the Python interpreter instead. Also, there are actually a lot of different shell programs that you can choose from. The default one on most Linux systems, and on the Mac, is called GNU Bash. But there are others called TCSH, KSH and Seashell. They all work slightly differently and have various different features. For this course, we're just going to stick with Bash. And you can also use a shell without the terminal, sort of. You can write shell commands into a file and arrange for your computer to run the shell program on that file. This is called shell scripting. It's a bit of an advanced topic and we don't go into it in this course. The best way to get used to the shell is to try a bunch of things out in it and see what happens. So here's a bunch of things to try. In each case, run the command and see what you get. And then in your own words, write down what you believe it's doing. Something to notice is that while some commands are just one word, others have more information that follows the command name. These are called Command Line Arguments. And they're input that you provide to a particular command or program when you run it. The command name is just the first word like expr or host. And the arguments make up the rest of the command line. So now, try each one of these commands in your shell. And in the box underneath each command, write what that command seems to be doing. So the date command is for telling time. It has a whole lot of options but if you just say date, you'll get the current date and time. The expr command is a simple calculator. The name stands for expression, as in evaluate an arithmetic expression. And so this command will add 2 and 2 and get 4. Echo is just the shells name for the print statement. It just repeats back whatever you give it, like an echo. Uname prints out the operating system's name for itself, here that's Linux. You can get a lot more information with uname-a, by the way. Hostname prints out the computer's own name for itself. And here that's the name of the vagrant VM you're running in. Now host is pretty different from host name. It looks up a name in the DNS or domain name service to find out its IP address and also other information. Here you can see it gives an IP address for udacity.com. And it also tells you that Udacity's mail is handled by Gmail. Technically it's only giving one of many IP addresses that handle traffic for Udacity, but it's more or less Udacity's IP address. Now bash--version tells you what version number of the bash shell you have installed. It also gives you the copyright information. A lot of programs have some sort of version command, often with an option like --version or dash capital V. Like here's python. Python -V tells us Python 2.7.6 and the history command tells you all the commands you've run previously. When you have used programming languages before such as Python or JavaScript, you've been exposed to concepts such as function and statement. Commands that you run at the shell prompt are a little bit like function calls. You could even do some of the same things in the shell and in code, like the command to delete a file in the shell is rm, which stands for remove And it works like this. And you could do the same thing in Python with the remove function in the OS module, os.remove. So, this analogy helps some people think about commands in the shell. If it doesn't work for you, that' okay, too. But take a moment to think about how shell commands are similar to functions in Python or JavaScript, and think about how they're different. Well, a Shell Command and a Python Function have a lot in common. They're both units of code, they both have a name, and they can both take arguments. But, they exist in pretty different contexts. Most commands that you run in the Shell are actually whole programs that are started up as separate processes on your computer. Like Carl says, running a Shell command in your terminal is a lot like calling a function in a program. But the two techniques are used in different ways. Functions are used to organize a program while Shell Commands are used to run programs. Since Shell Commands output their results in text, it's easy to read and understand what's going on. You can run a command, see what the result is, and then decide what to do next. There are a few different ways for command to output its results. Commands typically put there output to the terminal. For example, the uptime command prints out a single line of information. This single line of output always has the same format. First comes the current time, then comes the computer's uptime in terms of days, minutes, and hours, next is how many users are logged in. And the last item on the line is the computer's current load average. In this case, it looks like the computer is running about 0.01 processes at a time on average, so it's not very busy right now. Every time you run uptime, you'll get output in this format. Other programs can be a bit more dynamic in their output, though. The amount of information they print depends on various factors. For example, the host command prints out one line for each entry in a domain's DNS record. System administrators can specify lots of different things in their DNS records, so the host command needs to be flexible and print out however much information is available. Here we see that Linux weekly news has a simpler DNS configuration, it only has two entries. LS is another command that works this way. It prints the name of every file in the current directory. That means that LS will sometimes output a lot of text, and sometimes none at all. Let's run LS again and see the result. When we ran LS earlier, there was no output. Now we see there's one file, stuff.zip. This kind of dynamically sized output is pretty common. A lot of commands work this way. It can be disconcerting to run a command and get no output or very little output, but don't panic. When using the shell, no news is usually good news. Now it's your turn to interpret LS' output. Let's switch to another terminal running on another computer. How many items are in this directory? All right, it looks like this directory has one, two, three, four items in it. Notice that Royal Dutch Sell isn't three items, it's one with spaces in the name. When you're reading instructions for how to do things in the shell, you'll very often see a transcript of a shell session, a screenshot showing what to type, and what to expect the computer will say in response. But it can sometimes take a bit of thinking to figure out which lines are meant to show something that you typed in, and which ones are output. Here, give it a try. Here's a transcript of a shell session. For each line, mark it as either containing user input, or as being command output. So some of these lines are pretty straight forward. They start with a command prompt and then there's a command that I typed after it. So those, all the ones that start with a command prompt must be input. This one right after the ls command sure looks like output and it is. Here though, I tried to get the shell to wish you a Good St. Moose's Day. But I forgot that the shell has a special meaning for this single quote or apostrophe character. Like you saw earlier in the lesson, the quote means that the argument and therefore the command line that it's on continue at least to the next single quote, which is down here. And that means this and this are both also input lines, and these are output. By the way, if you actually want to see an apostrophe in the output. You can do that. The way you do that is to put a backslash before the apostrophe. You'd also need to put a backslash before the exclamation mark as well. Congratulations, you've reached the end of lesson one. You've learned a few shell commands, and you've gotten some practice using the terminal and learning what sorts of things to expect from it. In the next lesson, you'll be exploring more commands, and more importantly, you'll learn more about how to learn about shell commands, using the Belton manual, and other sources of help, too. See you then. Welcome to lesson two. By now, the shell doesn't look so weird to you as it once did. You've used several shell commands and you've seen their results. In this lesson, you'll learn some more shell commands and get practice using them. But first, since we're going to be working with files and directories a lot in the rest of this course, let's talk a bit about files in Linux, or more specifically, file names. Linux is really flexible about file names. There's no hard rule that a particular kind of file has to have a particular kind of name. The file system doesn't require that files have extensions on the end of their names. If you're coming from Windows, that can be a big change. You can see for instance, a file called readme instead of readme.txt, but it's still a text file. But just as on other systems, there are conventions. If you don't know what a file is, you can use your favorite search engine to look up the extension on the end of the file name. Or, if there isn't one, the whole file name and maybe something about the context. So, given what you already know, and what you can find with some quick searching, see if you can say what each of these files is likely to be. What type of things do you expect to find in each of these files? For Hello-Kitty.jpg is that a photograph, a saved game, or a Japanese textile? License, is that a piece of copyrighted software, piece of plain text, or a crypto key? Readme.md, is that a monitoring device, a mark down document, or a medical record? Superuser.pem, is that a crypto key, a printer config, or a recipe? And install.sh, is that a shell script, a data shard, or a shared file? Again, if you don't already know, look it up using your favorite search engine. So some of these you probably already knew, but I hope you looked up some of them too. jpg is the most common file name extension for the jpeg image format which is the most common format for photos. LICENSE in all caps is a really common name for software licenses on Linux and other systems. It's a plan text file. Well, it's usually written in legalese but technically that is plain text. Now if you've used GitHub, you've probably seen a file called README.md before. It's a text file in markdown format. This next one is one that surprised me a bit. A lot of crypto keys are stored in files with names ending in pem. The keys for ssh for SSL web servers are usually in pem files. What does pem stand for? It turns out this format was created for an old project called privacy enhanced mail. That project didn't go much of anywhere but the file format stuck around and we still use it. And for the last one, install.sh, whenever you see a .sh file, you're looking at a shell script. A shell script is just a text file consisting of shell commands. Pretty much anything you can do from the command line, you can do in a script, too. If you type a command and you don't get it right, or if you just want to recall something that you've used before, try using the up arrow key. The shell keeps a history of commands that you've run so you can walk back through them using the arrow keys. Then you can edit a previous command line that you've used and maybe get some more success. There are a couple of other ways to access the shell history. One of them you've seen is the command history, which prints out the whole history. This doesn't just include history from the current shell session, you can also see commands you ran in the past. Another one is the keystroke control R. This is a special function, called reverse i search, which lets you search your shell history. This is awfully handy if you used some command long ago or just yesterday and it's long command and you want to recall it now. Oh, that was that command we ran. Great. We've already seen a few commands that work with file names. For example, ls lists the files in the current directory. Right now we have just one file, things.zip. Let's go ahead and unzip that so we have more files to work with. If you didn't download thing.zip earlier refer to the instructors note below for instructions. The unzip command typically takes one argument. The file name of the file to unzip. As it works, unzip lists the files and directories it's uncompressing. Let's use ls to see all these new files. It looks like we have some text files and some directories too. Another useful command is cat, give cat a list of file names and it'll print out the contents of the files. For example, we can read bivalves.txt and gastropods.txt by running this command. Cat is a funny name for a command. But it makes sense when you realize it's an abbreviation for concatenate. Cat, concatenate files, and outputs the result. You can also use cat to read a single file. Just give it one file name. A lot of people use cat as their go to command for reading short files. Later on in the course, we'll learn other ways of reading files that work well with larger files. If you were watching closely you may have noticed that I was able to type those commands with super human speed. I'm not actually a very good typist though, I was just using one of the shells built in time saving features, tab completion. If you press the tab key while typing a word, the shell will try to autocomplete it for you. For example, I can cat bivalves.txt by tapping cat bi and pressing tab. Since bivalves.txt is the only file that starts with bi, the shell can autocomplete it for me. But what happens if you use tab completion when there's more than one match? Let's try it. Two files start with gas, gastropods.txt and gastropodsdraft.txt. When I hit the tab key, the shell auto completes as far as it can. If I hit tab again, the shell will tell me all the files that match. Since I want to read gastropods_drafts.txt I can type an underscore and press tab again to enter the complete file name. All right, we've read files from the command line, but we can do more than that. There are also commands for analyzing files. WC is the word count program. It tells us how many lines, words, and bytes are in a file. Since bivalves.txt has one species per line and two lines of citations, we know that the file describes ten different critters. Another command for analyzing files is diff. Diff compares files and shows you how they differ. This can be useful if you have multiple versions or editions of the same file and you want to know what changes have been made. In this case, it looks like a left file gastropods.txt has one line that the right file gatropods_draft doesn't have. This little angle bracket points in the direction of the file that includes that change There's a lot to remember when using the terminal. You can't just click around and explore menus like you can with a graphical program. This doesn't mean that you need to remember every command and every option though. Looking things up is a regular part of the terminal user's workflow. In fact, it's normal to forget the details of commands you don't use frequently. Cowsay is an example of a program with a bunch of options. By default, cowsay draws a cow, but you can customize it too. For example, by using the -e argument, we can replace its eyes with carets. We can also draw a penguin instead of a cow. So, how do we keep up with all these options? Fortunately, all common shell programs come with a manual, and there's a command that makes it easy to read them, man. Manual entries are called man pages, and this is cowsay's man page. Man pages follow a common format. The first section includes the command's name and a brief description of the command. The next section is the synopsis. The synopsis explains how to use the command's flags and arguments. Options surrounded by square brackets are optional. In this case, all of cowsay's options are optional. Some options require additional information. For example, if you use the -e flag, you also need to supply an eye_string. The description describes all of the options in detail. Man pages vary in how they present this information. Some man pages alphabetize their option, while cowsay's man page is a bit less organized. You can use the arrow keys to scroll up and down the man page. The later sections of the man page include more detailed information about the command. Man pages are typically arranged so that the most important details are near the top. When you're done referencing the manual, you can press q to exit. Now, it's time for you to use the manual. Take a look at the manual page for the cowsay command and find the answers to these questions. Who wrote the cowsay program? And what is the command line flag to customize the cow's tongue? Type your answers in these boxes. And remember, to access cowsay's man page, use the man command. All right. So who wrote the cowsay program? If you scroll to the very bottom of the man page, you can see that Tony Monroe wrote cowsay. The version of cowsay that we're using was written back in 1999. And the flag to customize the cow's tongue is -T. Command line flags, like commands themselves, are case sensitive. When you unzipped that zipped file, did you notice that zip prints out all the things it's extracting? Let's take another look at the output of the unzip command. Scroll up through it. Oh, hey look at this. One of the files that it extracted is called .secret, starting with a dot. But when we ran ls we don't see that file. In fact, ls by default doesn't list any files whose names start with a dot. This is because files with names starting with dot are often used on Linux for caching and configuration and other things that you don't normally care about. So the shell will hide them by default because they're not usually interesting. But there is an option to ls to make it display them too. To find out, look in the manual page for ls. It may take some searching around. So using the manual, find out how you can list all the items in a directory, including the ones whose names start with dot. Put the command you found here. So here we are in the manual and I guess it didn't take that much searching after all. The option is -a for all. So if we type ls -a, we'll see our dot files too. Oh, and there's .secret. So the answer to the quiz question was ls -a, but also be correct if you said ls --all. Let's try out some of the other options to ls that are given in the man page. Ls-l is a pretty good one. The l stands for long listing. Try the command in your own terminal. What information do you see when you run ls-l? Can you see the filename? Can you see the modification time of items in the folder? Can you see the file sizes? Can you determine whether you're looking at files or directories? Can you determine the virus scanning status of the things in the directory? And can you figure out what program is used to open the files in the directory? Check all the options that are true. The information included in ls's long listing includes the file name, the modification time, the file size and whether a particular file is a file or a directory. Let's head over to the terminal so we could see what this output looks like. There's a lot of information here. The file name is in this right column. And this column to the left of it that looks like a date and time, is the modification time of each file. The next column over is the size of each file in bytes. We can find out whether a file is a file or directory by looking at this left most column. There's going to be a d for each directory and a dash for every regular file. There's a lot more information here, too. But ls doesn't know anything about the content of your files. It can't tell you whether they've been scanned for viruses, and it doesn't what program should be used to open a particular file. There are a lot of other resources besides the manual for finding out about shell command stuff. Even experienced users can always find something new that can be done in the shell. But if you don't know what a command does and you're not sure if you want to run it, applying your favorite search engine to the problem is a good idea. You can put any shell command into Google or DuckDuckGo or Yahoo or whatever and usually find a lot of help. In fact, let's do that now. Here's a command that you should definitely research, but don't run it. Seriously, don't. Open up your favorite search engine and look up this command, rm -rf /. You might need a search keyword such as shell or command. What does this command do? What do the r and the f stand for? Put your description of what this command does based on your research here. And does the r stand for read, recursive, or root? And does the f stand for force, file, or flag? So, this command rm-rf / is pretty scary. rm is the command for removing files, deleting things. The r stands for recursive, which means that it will delete whole directories and everything underneath them, and the f means force, which keeps it from checking whether you really want to delete. So what this command rm-rf/ does is to delete everything on your Linux file system, or at least everything that your user account has access to delete. If you wanted to delete really everything you'd have to switch accounts up to the super user account first. But fortunately Linux has gotten safer in the past few years. On most systems today, if you try to do this command, the RM command will give you an error message. That's because people who weren't very nice kept telling people to run this command and made them break their computers. You've seen several commands, like LS, Uptime, and cowsay that do something, and then immediately return you to the shell prompt. But not all programs do that. Some programs are a little bit more interactive. They take over the terminal for as long as they're running, and then we get the shell back when the program exits. Take, for instance, ping. Ping lets you test whether another machine on the internet is alive, and how long it takes to send a message to that machine and back. Let's see you ping 8.8.8.8, which is Google's public DNS server. Very fast and well connected, so we should always be able to get to it. Ping starts and it prints out a line for each successful echo, but it doesn't stop on its own and give you your shell back. Instead, you have to tell it to stop. One of the most common ways to tell a program like this to stop is to type Ctrl+C which sends the interrupt signal. When you do that, ping stops, prints out a summary, and you get your shell prompt back. But some programs have a different behavior. There's a really common design in Linux programs where a program will read from what's called standard input, or stdin and write to what's called standard output, or stdout. This allows programs to be chained together on to a pipeline which is a little bit beyond the scope of this course. When you run a program like this from the terminal, it'll read from your keyboard input and write back to the terminal screen. And very often when your input is done you want to send it an end of file character which you do by typing Ctrl+D. Here's an example. The sort program, which sorts lines in alphabetical order. If you run sort and then type or paste in some text, it will print those lines out sorted. But it can't do any sorting until it's received the last line and that's what typing Ctrl+D tells it. You have to use Ctrl+D instead of Ctrl+C if you want the sorted output. Ctrl+C will just cause it to exit. But there we go, there are the four lines that I typed in, sorted. Programs like sort are called line based programs because they read input one line at a time until they reach the end of the input. You can usually use them on files as well as on text that you type in or paste into the terminal. You'll see a few more of them later in the course. So sometimes a program will be waiting for input, and if you want to get your shell back, you have to know how to tell it either that the input is over or that it should exit. Let's take another look at an example. Bc is a simple calculator program, you can use it to do arithmetic like this. It knows about order of operations and parenthesis and things like that. But when you're done using it and you want to exit, what do you do? This is a good opportunity for experimenting. Here are some things to try. Which one of them lets you exit bc and get your shell back? If you type Ctrl+C into a shell program, the Linux system sends a signal called interrupt to that program. Now, that worked on the PNG program, but it doesn't work on bc. It actually gives you a message saying (interrupt) use quit to exit. And typing quit does work, but it's not the only way. Remember, Ctrl+D stands for end of file and it tells the program that there isn't any more input coming. So Ctrl+D also works as a way to exit the program. So the correct options in this quiz are either to type quit or to press Ctrl+D. So bc was an example of a line oriented program, but not every program we use in the terminal works this way. You've already seen one program that doesn't. The man program, for reading the manual takes up a full terminal screen. It's actually use another program called less that knows how to display text one page at a time. So when you press Q to stop looking at a manual page. You're actually using a command that less understands. And you can use less to display any file you like not just man pages. Let's try using less on a long text file. Remember to use tab completion when entering a long filename like this one. Scrolling up and down with arrow keys works the same way as it did before, and man you can also scroll down a page at a time by using the D key or by hitting the Space Bar. You can scroll up one page at a time wit a U key. If you want to skip to very last line of the file, you can use the right angle bracket for that. To get back up to the first line use the left angle bracket. You can go to a particular line by typing its line number and hitting Enter. This is particularly useful when working with source code where you know the line numbers of important lines. It's also useful when you decide to quickly move to the middle of a file. Less also has built-in search. Type slash and then the string you'd like to search for. Press Enter or return to execute the search. You can find the next occurrence of the search term by pressing n. To go back to the previous occurrence, use capital N. Search terms are case sensitive. Searching for otter with a lower case o, won't find any capital O otters. If you're familiar with regular expressions you can use them here, unless the search is actually looking for lines that match your pattern. If you don't know regular expressions, you can still use lesson search capability, but you should be careful and only search for patterns consisting of numbers and letters. The regular expression library will interpret other characters in ways you might not expect. But you can do more than just display files in the terminal. You can also edit files in the terminal. This is really handy if you're logged into a remote system and you want to change a configuration file or something. Instead of pulling the file back to your desktop and editing it with Sublime or another graphically based text editor, you can use an editor that runs right in the terminal. There are a heck of a lot of terminal based text editors out there. Like vim and emacs and joe, and many others. But one of the easiest ones is built into ubuntu, and it's called nano. You can run nano on any text file you happen to have on your Linux box. It takes the file to edit as a command line parameter. And here we are in nano. You can move around with the arrow keys and edit just like this. Down at the bottom of the terminal screen, nano shows you a bunch of commands that you can use. The little carrot or hat character means the control key. For instance, ^J means Justify or rewrap the text to fit on the screen. And ^O means WriteOut which is to say save the file. If the file doesn't already have a name it'll ask you for one. Now open up nano on a file yourself. Looking at the help that's right there, what key stroke would you used to exit nano? Control-G, Alt-R, Control-Alt-Delete, Control-X, Alt-X, or Escape :wq Enter? And down here in the bottom-left, it tells you. CTRL+X means Exit. Remember, any time you see that carrot, with another character like this, it means CTRL, that character. It'll ask you if you want to save if you've changed the file. You can say no. Great, you've reached the end of lesson two. In this lesson, you'll work with a number of different programs to interact with a terminal in different ways. Some that display output and immediately exit, some that work with input one line at a time, and some that are fully interactive. In the next lesson, we'll explore the Linux file system and the tools for working with files and directories from the shell. See you then. Welcome to lesson three. Whether you're going to be developing web services and deploying them on a Linux Container, or doing systems work and troubleshooting servers, having a good grasp on the file system is pretty essential. In this lesson, you'll practice working with files and directories, and using a range of shell commands that operate on them. The two most important kinds of objects in a Linux server's filesystem are files and directories. You've been working with files already throughout this course. So files are probably nothing new. And directories are almost exactly the same as folders that you've probably seen on a Windows or Mac system. They're named containers that can hold files and can also be nested inside other directories. Every object in the file system has a name or a file name. The rules for file and directory names in Linux are pretty flexible. You can have spaces and filenames, you can have dots, you can at signs or accent marks or whatever. The only thing you can't have is the slash character. And in the shell, when you write a file name that contains spaces or certain punctuation marks, you have to put the file name in quotes, or else precede each one of the special characters including spaces with the back slash. So for instance, if you had a file whose actual file name was Great space Filename! When you're talking about that file in the shell, you would write it either as 'Great Filename!' or as Great\ Filename\! This is called Quoting and this is called Escaping. The reason for this is that these characters all have special meanings to the shell, and putting a backslash in front of them tells the shell to treat them as ordinary characters. Directories are nested inside each other, with the outermost or topmost being the file system root or root directory. It's very common for there to be multiple discs or disc partitions on a Linux system. Unlike on Windows, there aren't separate roots for each disc, like C: or D: drives. There's just one filesystem root at the top of the filesystem. This means that no matter what directory a file is in, you can unambiguously refer to that file by giving the full path which starts at the root and lists each directory on the way down to the individual file. The directory names are separated by slashes. So, for instance, here's a file called auth.log, which is inside a directory called log, which is inside a directory called var, which is inside the root directory. So to give the full path name, we start at the root /var/log/auth.log. Now if you're coming from Windows, be careful. Linux uses the forward slash to separate directories, whereas Windows uses the back slash. The forward slash is the same one that you see in URLs, like https://udacity.com, or for writing fractions like 2/3, or in various other uses. So now it's your turn. For each one of these other files, fill in the full path name based on the directory structure and the filename itself. So the second one is a file called syslog, inside the directory called log, inside var, inside the root. So we write that as /var/log/syslog. This one here is Friend.png, inside the directory otter, inside home, inside the root. So it's /home/otter/friend.png. And this one is /home/otter/favorites.txt. Your shell, and every other program for that matter, has a working directory. You can think of this as the directory that it's looking at or focused on, or the one that it uses as the default location for most commands to find files in. For instance, when you've run LS before, you got a listing of files in a directory. But which directory? LS with no arguments will list files in the shell's current working directory. If you want to know the path of that directory, you can use the pwd command which stands for print working directory, and this says that here the working directory is /home/vagrant. You can change the working directory with the CD command for change directory. There are a few different ways to use it. You can give the full path of a directory Like var/log. Or you can give the name of a directory that's inside the current one. For instance, if there were a directory called three, you could say cd three, but there's not. And you can also use cd.. to go up the tree to the parent of the current directory, for instance, from var/log to var. So let's go back to where we started, and you'll see that inside /home/vagrant there's something called ocean. Well, that's a directory, and so we can cd into it. And if you take a look inside the ocean directory, you'll see it has some contents. So using the cd and ls commands, map out the sub directories and files you find inside that ocean directory. Put them here in these boxes. So inside the directory called ocean, you can see there's something called stuff and water, and stuff turns out to be a directory. And inside there, there's misc and otters. And there's nothing inside misc, it's an empty directory. So to fill out this map, there's a sub-directory called stuff, and there was a file called water and then inside stuff, there was a sub-directory called misc that didn't contain anything else, and there was a file called otters. So, the top most directory in the file system is the root directory. And we denote the root directory with a slash. You can describe the location of any file or directory in the file system, with a full path beginning with a slash. The full path is called the absolute path, and that means that it tells every step that has to be taken from the root, or the absolute beginning of the file system. Absolute paths are unambiguous and easy to understand, but they can also be inconvenient to work with, especially if you're working with deeply nested directories. To make things simpler, we can use relative paths instead. A file's relative path, is its location relative to the current working directory. If you're working with files in or near the current working directory, this can save you a lot of typing. Every time you've referred to a file by just its name, you've actually been using a relative path. This is the simplest sort of relative path. The shell looks for the specified file name within the current directory. For example, if the current working directory is ocean, then the relative path of the clam directory is just clam. Rather than having the full path from the root, we can just have the path from the working directory. Oh, and cwd here is just an abbreviation for current working directory. You could also write relative paths for files and other directories. For example, the relative path of the giant file, and the clam directory, is just clam/giant. Notice that, unlike a full path, the relative path does not start with a slash. That's how you can tell a relative path from an absolute one. You can also write relative paths for items that are closer to the root. The special directory entry '..' points from a directory to its parent. So, if you're in /home/philip/ocean, and you refer to '..', you're talking about the directory /home/philip. And if you refer to ../mountain, you're referring to /home/philip/mountain. There's also a special entry which is just '.'. '.' points from each directory to itself. For example, because our current working directory is ocean, if we use ., that refers to /home/philip/ocean. Another handy shortcut is ~. ~ is an abbreviation for your own home directory. By starting a relative path with ~, you can easily specify paths relative to your own home directory. So no matter where you are, that is, no matter what your shell's current working directory is, you can give a file's path as either an absolute path from the root, or you can use a relative path from the current working directory. For this quiz, let's say you're currently in /home/otter. Here are five pairs of cd commands. For each pair, figure out whether the two commands will change the same working directory. This first pair is an example. If you're in /home/otter and you do a cd That will take you to the current working directory's parent which is /home. That's the same result as cd /home. So yes, this first pair matches. Try the next row on your own. Remember, in each case your initial working directory is /home/otter, right here. All right, let's look at this first pair. In this case, cd../otter means go up to the parent directory of the current working directory and then go to the otter folder. So that means we go up a directory and then to the otter folder. So here we're actually just cding to the directory we're already in. The second cd command is cd /home/otter which is just the absolute path. So these two commands are equivalent. Onto the next pair. cd ./www, dot means the current working directory and www means we're going to look for a folder or a file called www in the current directory. So this one right here. This next command, cd www just looks for the file inside the current working directory which is the same thing. So this pair also matches. Let's look at this pair, cd ../www. This will look in the working directory's parent directory for a folder called www. That's not even in the file tree though. Compared to the second command, cd ./www which is the equivalent to what we just saw. So these commands do not match. This last pair of commands are equivalent though. Cd ../../usr goes to the grandparent directory of the current working directory. And then heads down to /usr, which is equivalent to using this absolute path cd /usr. In this case, the relative path isn't any shorter or more convenient than the absolute path, but they're still equivalent. So we'll check it off. So let's say, here we are wondering around the file system. Let's say we end up in var log. That is to say, /var/log is our current working directory as printed out by the pwd command. Now, what do you think will happen to the working directory if we just type cd with no arguments? Do you think that nothing will happen, it will just stay in var log? Do you think that it will go to your home directory? Do you think that it will go to the filesystem root or the /directory? Do you think maybe the shell stops having a working directory at all? Or maybe it's an error? Or possibly the shell prompt turns into a shark and eats you? Which one of these do you think is going to happen? Whoops, I had just tried it. Luckily no shark. Yep, cd by itself just takes you to your home directory. You've probably noticed by now that we tend to talk about the current working directory as where we are. And we talk about using the cd command as moving around directories. This is a really common metaphor. It doesn't mean that the shell is a file inside that directory, it just means that's the part of the file system that currently has focus. So by now you've used cd a bit to navigate around the file system. But what happens if you try to cd but give the name of a file instead of a directory. Like for instance, there's a file on your system called ocean slash water. What happens if you cd to that. So try to cd to a path that's not a directory like the ocean slash water file. What happens? Does it create a directory with the same name? Does it show the contents of that file? Does it do nothing? Does it show an error message? Or does it crash your Linux box? Oh here, I'm going to try it. And it looks like we just get an error. CD, water, not a directory. That's pretty typical for the shell. If you tried to CD a file, or cat a directory for that matter, you'll just get a harmless error message. So the correct answer is that cd to a file just shows an error message and doesn't do anything harmful. Let's try another tricky question. Let's imagine you have a directory tree like this, and you start here in your home directory, which is also your current working directory. Let's then say you also run this series of commands, cd.., cd, cd www, cd stuff, and cd .. After running those commands what directory do you wind up in? What's your new current working directory? Enter the full path here in the box. All right. So each of these cd commands changes our current directory. The first one, cd .., goes to the parent of the current directory. So after running this first command, we go to the parent of otter. The second command is cd with no arguments. Cd with no arguments returns us to our home directory. So, we go straight back to home/otter. The next command in the series is cd www. This takes us to the www directory inside of our current directory, which is down here. The fourth command, cd stuff, takes us to the stuff directory inside of the www directory. This last command, cd ., doesn't change anything. ., refers to our current directory. So we wind up in /home/otter/www/stuff. Typing in long directory and file names is a big, boring pain and nobody likes doing it. One way you can avoid running out of fingers is to use tab completion. It works pretty much the same as tab completion for commands. As you're typing a command or file path, just hit the tab key. If you've typed enough to distinguish a single command or a single file, the shell will automatically complete it. Otherwise it will go beep. Then if you press tab again it'll list all of the possible completions for what you've typed. Experienced Shell users use tab completion all the time almost without thinking about it. Try it out. You can actually use it to navigate all around the directory structure without ever using the CD at all. So some of the most common things we do with files are to move them around, copy them, change their names, things like that. Let's see how to do some of those things in the shell. So the shell command to move files is MV, which is short for move. The simplest way to use it is to just give it one file that you want to move and the directory you want to move it to. You could also use it to rename files, to move a file to a different name in the same directory, or to move several files into a directory. Copying files is very similar. The command is cp for copy. As with mv, you give it the name of the file that you want to copy and where you want to copy it to. And that can be a different file name in the same directory, or a file name in a different directory. Or it could just be a directory that you want to put the new copy in. Both of these commands support a lot of options. You should read the manual pages for both of them. But here's something else you might be wondering. Mv, cp, rm, why do you think these commands have such short names? Put your answer here, and then we'll share our thoughts on the matter. So, why do you think these commands have such short names? There's a couple of reasons I can think of. Short names are a bit cryptic, but once you've learned them, they're quick to type. The second reason isn't really relevant today, but shorter commands are also more efficient. Back when modem speeds were measured in the hundreds of bits per second, every character counted. From a historical standpoint, making command names as short as they could be was very common when the UNIX system was created, even though later on it looks kind of silly and harder to learn. For instance, the system function for creating files is called creat, not create, but creat without the e. When Ken Thompson, one of the designers of UNIX, was asked later what he would have done differently in the design, he said he would've put the e on the end. Where do new directories come from? You can create new directories using the M-K-D-I-R or mkdir command. All you have to give mkdir is a path to where the new directory should be. When you make a new directory with mkdir, the path you give it can be a relative or an absolute path. So you could mkdir notes to make a directory called notes inside the current directory. Or you could make dir/tmp/cache to make a directory called cache inside the tmp directory. Remember, the entire file system descends from the root directory. When you make a new directory, It's created with some existing directory as it's parent. So in the examples we just saw, the working directory is /home/vagrant, and we mkdir/notes, then the notes directory's parent is vagrant. And if we mkdir/tmp/cache, the cache directory's parent directory is tmp. Once you've made a directory, you can move files into that directory with mv, or copy them with cp like you've seen before. And if you're done with a directory, and want to get rid of it, the command for that rmdir. You can't use just plain rm on a directory. You have to use rmdir. But if a directory has files in it, you can't rmdir that directory. For instance, this directory called junk. If we try to remove it, Linux will tell us the directory is not empty. There is a way to recursively remove a directory and all the files inside, and we've actually seen it before in this course. Which of these commands do you think will remove the directory junk and all of its contents? Rmdir -f junk, curl -o junk empty, rm -r junk, or mv junk Trash. So rmdir -f junk doesn't work, since rmdir doesn't understand -f as an option. curl -o junk empty, well, this curl command won't actually do anything. Curl is for downloading from a web URL and empty isn't one of those. rm -r junk is the right answer. The r stands for recursive. And this is the standard way to erase an entire directory and all of its contents. Any files or directories that may be inside it and anything inside those directories, and so on. And mv junk trash will do one of two different things. If there is a directory called trash, it'll move junk to inside of it. And if there isn't a directory called trash, it'll rename junk to trash. So, again the correct answer for removing the entire junk directory is rm -r junk. And the junk that was there is now gone. So, you've learned about creating directories and moving files. Let's say you have a file called beach.jpg in your home directory, and you'd like to move it into a new directory called photos. How would you do that? Enter the required commands here. All right, creating a new directory and moving a file into it will take two commands. The first command will make the directory. We can verify we have the new directory with ls again. Our new directory is up here. Now we can move the file into that directory. There are two ways we could do this. We could say mv beach.jpg to Photos/ beach.jpg, but the shorter way is just to say, mv beach.jpg Photos. We can verify that we really did move the file with ls photos to look inside the photos directory. Any time you want to operate on a bunch of files that have similar names, you can use a glob pattern to do it. I am not making up this name. Globbing is the real, actual, technical term for matching files by name in the Unix shell. Seriously, globbing. If you don't believe me you can look it up, man glob. Globbing is a kind of pattern matching for file names. When you write a glob pattern in a shell command, the shell turns that pattern into a list of file names that exist to match the pattern. For instance, a star matches any string of characters. You can use a star at the beginning or at the end of a pattern. Patterns can be all sorts of different lengths. You can use two stars in the same pattern. For instance, here, matching every file whose name contains pp. A star can appear in the middle of a pattern. Matching all the files that start with B and end with png. There are other patterns you can use as well. For instance, to match files that end in either CSS or HTML, a list of strings in curly braces will match any of the alternatives. A single question mark matches any one character. So BEA question mark dot png matches both bean and bear, but it doesn't match beer or bees. Two question marks matches two characters, and so on. List of characters inside square brackets matches any one of the characters inside those brackets, so be and then square brackets A-E-I-O-U R dot png will match bear and beer, but not bean or bees. Something to watch out for is that file names in Linux are always case sensitive, and that applies to globbing too. For instance, if you have files that end in jpg in capitals and files that end in jpg in lower case, you have to specify which one you want. If you want both, you could use the curly braces. Great. So, now let's do a quiz. Here are three glob patterns, and here are some filenames that they might or might not each match. Go through these lists of filenames, and for each pattern mark the box with the filename matches the glob pattern. If you're not sure whether a filename should match the glob pattern or not, you can always try making a file or directory with that name, and testing the pattern with LS. OK so the first pattern is *S* so that will match anything that contains a capital letter S. So that includes GiantSquid, and Squid, and this Queen mp3, but it doesn't include these which all include a lower case s. You might have noticed that *S* matches Squid.avi, even though there's nothing before the capital S here. Star can match zero characters. So the next pattern is Squid*. That matches only things that start with the word Squid. That will be Squid.avi, but not any of the others. And finally we have this one with a question mark. Remember question mark matches a single character. So this will match p-a-s-s-w-d as well as p-a-s-s-e-d. Okay great. Now let's put it all together and do some shell commands. Each of the answers in this quiz will involve globbing, but it'll also involve remembering some of the other commands you've learned in this course. For the first task, you'd like to back up some files from the www directory to the backup directory. Our second goal is to list all the files in the current directory that end in jpg or png. And our final goal is to print the string Short names: followed by all the one-character filenames in the current directory. These questions are pretty tricky. If you're having trouble, head over to your terminal and create a temporary directory full of test files, that way you can experiment and try out your commands. For this first question, we're backing up some files from the www directory to the backup directory. Since we're making a copy, we'll use cp. The destination of the cp command will be backup, since we want all the copies of the files to land in that directory. Be aware, though, that this command will only work if the backup directory already exists. Cp doesn't create directories on its own. All right, so what goes between cp and backup? Well, the files we want are in www, so we'll start with that as a relative path. We only want the files though that end in html. So we'll use *html to specify that. All right, so the complete command is cp www/*html backup. We're copying the files that end in html to the backup directory. Okay, so in this second question we want to list every file that ends in jpg or png. We can list files with ls, but matching just those two file name endings is a good job for globbing. Jpg and png are two options, so we can put them in curly braces with a comma in between. To match the rest of the file name, we put a star in the front. This is another way that'll work. This just lists all the jpgs and then all the pngs. And this is one more solution. Since jpg and png both end in g, we can factor out the g. This is basically equivalent to our first solution, but is pretty silly. I wouldn't really use this in practice. Okay, our final task is to print short names followed by all the one character filenames in the current directory. The glob pattern to match a single character is the question mark, so we'll start with that. The command to print to the command line is echo, so that's what we'll begin the command with. The last part of this command is the string to print, Short names colon. You could put quotes around the string if you want to, but you don't have to. If this string had funny characters in it, though, you'd want to escape those with a backslash or single quotes. Congratulations, you've reached the end of this course. Like an otter, you too can rock the shell. Now you're ready to go on to any number of subjects that depend on the command line interface. If you're interested in running Linux servers, take a look at out Linux for web developers course. Another command line tool to learn is Git. A very popular distributed version control system. We have a course on that too. We put links to these courses, and other resources in the instructors notes and in the course wiki. And do come back to the discussion forums to share your questions, and your discoveries We hope you enjoyed this course. See you next time.