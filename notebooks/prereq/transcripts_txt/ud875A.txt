In this lesson, we're going to discuss the details of how to build native Android wear apps. These can do so much more than just notifications, and you have a full Android implementation to help you out here. Having Android underneath means that most of your Android concepts that you're familiar with apply here too. So you'll be reusing a lot of your existing knowledge. So to build an Android Wear app, we're going to discuss how these apps are built, how wearables communicate with the outside world, how to create user interfaces for them, and how to implement useful functionality with them, such as sensor processing. An important part of Android Wear application design is that while the watch is acting as a display to push notifications to the user, much of the work is actually done on the phone. Interware devices do not connect to the internet directly and instead, they typically communicate with the outside world via the paired up phone using Bluetooth or WiFi. Another important thing to note is that Android Wear applications are embedded inside the regular phone APK from Google Play. The user will download the phone APK and it will be installed to the phone. The Android Wear companion app that runs on the phone will then detect an embedded wearable APK and copy it over to the Android Wear device and install it there, too. Whenever the phone APK is updated on the play store, this process is repeated to the Android-ware device. The nice part about this is that if someone is using your app, and they're at an Android Wear device, it will automatically support it if it's available. What this does mean is that you must create an application that runs on the phone because a wearable app cannot exist without it. Even if the phone app does nothing, you still need to provide one otherwise Google Play cannot process and distribute your APK file. Here are some other things that are also important to know. The phone APK and embedded wearable APK must have the same package name and version numbers. The permissions requested by the wearable APK must also be requested by the phone APK, as well. The phone APKs and wearable APKs both need to be signed by the same developer keys. If you get any of these things wrong, the wearable app will fail to install, so be careful here. The best way to understand the Soul is to see it in action. Let's create a simple example in Android Studio so, that we can see all the parts, and how to build and install them. Android Studio includes templates for all the popular Android platforms and so we can create one very easily here. In Android studio select File > New > New Project, and you can fill in whatever you want as the defaults because we're not using this for anything important. Click Next. We select Phone and Tablet with the defaults and we also select Wear with a minimum SDK of at least API 21. Click Next. For the mobile activity just select the default blank activity and leave everything with the default activity names. Now you'll see we have the option to select a wearable activity. In this example we'll use Blank Wear Activity. But you'll notice that you can also create a notification or a watch face. Those will come in handy later on. Once again you can leave the activities with the default names and than click Finish. So, now I want you to replicate the same steps. After the project is fully created, how many build.gradle files do you have appearing in your project browser? Choose one of the answers, one, two, three, or four. In this case the answer is three. As we can see here, we have a build.gradle for the whole project, we have one for the mobile and we have one for the wear part. Once we've done all of these steps, that's it. Android Studio was nice enough to create all of the Activities, Resources, Manifests and Gradle files for both the Android phone and the wearable device. You should have two sets of everything. So this is a great starting point for app development. So now we need to build and install the application. Remember, there are two parts, the phone application and the wearable application. Before, I mentioned that the wearable application needs to be embedded into the phone application. While this is required for distribution through Google Play. it's actually possible to build and deploy them separately for testing. So let's walk through how to build and deploy our new application for testing. And then we can discuss the embedding later. You'll notice here there are two Gradle projects, Mobile and Wear. We can build and install each of these separately. So make sure you connect up your phone now. And ensure that the Android Debug Bridge is working properly. Now select the mobile project, and click the green Play button. This tells Gradle to run the Assemble Debug task. Which compiles your code and makes an APK out of it. Android Studio then installs it to your device or emulator. We may need to select a device to install it to. So select that, in this case, my Nexus 5. And click okay to continue. After waiting a minute or two. You'll see the phone side of your application running on the phone. This is exactly the same as what you would have done previously when you learned Android programming. Now to get to the important part, building the wearable side of the application. We now need to get your wearable paired up over ADB just like your phone. Most Android Wear devices would come with a cradle, like one of these. That allows you to connect to USB cable. So we make sure we've got those connected up. Also, you'll need to enable developer mode and usb debugging. So you need to go to Settings, About, and tap on the Build number seven times. Then you go to developer mode and enable USB Debugging. Your wearable will ask you if you want to approve the permission request. Once this is done, your wearable will be able to use ADB. If you're a Windows user, I've provided a link in the instructor notes. To some documentation that shows how to set up ADB for Android Wearable Devices. If you have a wearable device that does not have a USB cradle. You can also set up ADB over Bluetooth. The instructor notes will have a link that has more information about what you need to do that as well. Now that we have the wearable device set up with ADB. We need to build the Wearable project. Let's select the Wearable Gradle project and click the green Play button. This tells Gradle to run the assemblydebug task, similar as before, but this time for the Wearable side instead. Once it finishes building, Android Studio will prompt you for which device to install the APK to. Since there are now two devices connected by ADB. It's very important that you pick the wearable device. If you pick the wrong one, the app will not execute properly. So we select the wearable, then we click okay. Now you'll see the wearable activity appear on the wearable devices. So that's how you can easily test and debug phone and wearable apps from within Android Studio. When you're ready to push the APK to your users via Google Play. You'll need to do these steps a little differently. You need to boot a release mode APK. Which is different than a debug APK because it is signed with your development keys to prove you built the APK. You can start this process by using the build menu and selecting generate signed APK. Which uses the gradle assemble release task internally. And this is how we go start that process. Build, generate signed APK. And then you can follow through by selecting the mobile project. And at this point now, you need to provide all your key details. And then continue through with the rest of the process. I'm not going to go through that process right now though. So let's just hit cancel to get back to where we were. If you go to the mobile build.gradle file, like shown here. You can see there's a property called wearApp at the bottom. That references the ware gradle project. This task tells gradle to embed the wearable APK into the phone APK. You should note that this only happens in release mode. When we did the testing earlier in debug mode. There was no app embedding. So it's important that you test your final APK in release mode by installing it to a phone. And checking that it syncs over to the wearable correctly. If you make a mistake with any of the wearable packaging steps, it'll fail to install in the wearable. By the way, if you're trying to debug packaging installation problems. You can use adb logcat and search for the process WearablePkgInstaller on the phone and wearable side. Which will tell you what the problem is. Oh and one more thing. I mention build.gradle files, but did not go into much detail on them. For many cases you won't need to edit these very often. But if you want to learn more. We have a whole class on Gradle that teaches you everything you need to know. About dealing with dependencies and Multiple Build Flavors. For a link check the instructor notes. So let's do a quiz. What I want you to do is to go through all the steps that I just went through. You need to pair your wearable to your phone or tablet. You need to set up ADB to both devices. You need to create a new phone and wear project. You need to build and install it to the phone or tablet. And then you need to build and install it to the wearable. And finally, what appears on the wearable's display? The answer would depend on if you have a square or a round watch. It'll either say, Hello Square World or Hello Round World, depending on what you're using. We'll talk more about how this is done later. After working through this demo, you can see that we have the ability to run code on both the phone and the wearable, but right now they can't talk to each other. For a really useful wearable app, we're going to need to use the phone to provide information. And we're going to discuss how to do this in the next section. But before we move on, a quick quiz question. Which build mode should you use to do full app embedding for Google Play, debug or release? And the answer is release mode. This implements the wear app embedding, so that the wearable app is included into the phone app. Also, it signs both APK's correctly, so it can be uploaded to Google Play. And for the next question which build.gradle file should you add wearApp to for embedding the wearable APK? Do you add it to mobile/build.gradle? Or do you add it to wear/build.gradle? The answer is mobile/ build.gradle. The phone side needs to embed the wearable APK inside it. Android Wear devices are paired up with a companion phone but are not allowed to connect to the Internet directly. This is done for many reasons. Including the following. Saving battery power. The phone is responsible for dealing with internet and sending only the important information to the wearable. Dealing with sporadic connections. The wearable may not always be in range of the phone. And dealing with different network types, the wearable may connect with many different ways to the phone. So we definitely need an abstraction layer here and the Android Wear framework provides this. There are two main mechanisms used to communicate between a phone and an Android Wear device, data items and messages. Let's talk firstly about data items. These provide storage of key value pairs, as well as automatic synchronization of the data. So you can create a data item on one device, fill in the key value pairs, and then give it to the data API. Once you've done this, it synchronized through whatever means possible to all the other devices paired up. The other devices can then register a listener that'll have a method code when a change arrives in the data item. So let's look at what the code for this would look like with a quick walk-through some of the pieces. You'll need to do something similar later using the documentation as a guide. Imagine we need to transmit number of steps detected on an Android Wear device to a paired up phone. Let's open up the MainActivity.java file contained in the wearable project we just created. So it's in the wear directory > java > MainActivity. The data API is provided by Google Play Services, so we need to first create a connection to this API. Note that this does not connect to the wearable, it just allows your app to make Google Play Services API calls. So, after we put this code in, we need to hit Alt + Enter a few times to add the necessary packages. We also need to create a variable to store the connection in. And we also need to implement two classes that are part of GoogleApiClient for handling connection success and failure. So lets provide the implementation for those methods here. We don't have any code to put in them, so let's just leave them blank for now. Now, let's look at the code used to create a data item. Let's create a method send step count that does this for us. We firstly create a PutDataMapRequest and we need to specify a path for it. The path shown here is used to reference this object and make it unique compared to all the other once that we can create. Next we use put methods to add an integer and long key value pair. We then use putDataItem to submit the object, and then we need to check for errors with the callback to find underneath. Error handling is very interesting, because it just indicates that the object was successfully stored locally. It does not tell you if the object was received by remote device yet. It is totally okay for the remote device to not even be connected. When the device connects, the data item will be synchronized later on. So you'll never receive feedback that the remote device has received it. If you need this kind of feedback, you'll need to code up some kind of feedback mechanism yourself. Another analogy for this is that a package delivery company giving you an acknowledgment that the package has been collected. It has not been delivered to the recipient yet and might take some time to get there. One important point is that data items are promised to never be lost and will eventually arrive once the other device is paired up. Let's now look at the receiving code on the phone. So let's expend the project viewer, and work in the mobile project now. On the receiver side it's quite easy to find when new data items arrive, you simply create a service for this. So let's go to File > New > Service. Create it with all the defaults, and then hit Enter. The first thing we need to do, is make sure it inherits from WearableListenerService and add dependencies. You can also remove the entire implementation because we're going to replace it. You then override the onDataChange method, which is past an array of data events that have occurred. For each DataEvent object you can retrieve the DataMap, and then extract out the path and values for each key from before. You can see here that we're looking for a change, we're then extracting out the path, we're testing if the path equals a certain string, and then we pull out the integer and long value to do whatever we want with it. The final step is to adjust the AndroidManifest.xml on the receiving side to make sure our listener service handles the BIND_LISTENER intent. Google Play Services will then handle all the necessary behind the scenes work to get the data items to your listener. You don't need to start the service itself. So let's expand the project and open up the AndroidManifest.xml file. The final step is to adjust the AndroidManifest.xml on the receiving side to make sure our listener service handles the BIND_LISTENER intent. Google Play Services will then handle all the necessary behind the scenes work to get the data items to your listener. You don't need to worry about starting this service yourself. Oh, and one more thing. Let's go back to the sending code and talk about large items. Data items are typically limited to about 100 KBs. So make sure you do not exceed this size. However, if you need to send something like an image, it's possible using the Asset class. You convert you bitmap into a png byte stream, and then store it into a data item using putAsset. This deals with sending the image in a way that works around the 100 kB limit. So that's it for sending data items. The fundamentals are really easy and most of the hard work like handling the connections and sending the data is all taken care of for you. So you can focus on the important parts of your app instead. Now we're going to talk about sending messages. These are much simpler than data items, in that they encode simple byte arrays, and there are no guarantees of delivery. If you send a message on a remote device that's not connected or out of range, then the message will be lost. It's your responsibility to deal with this, and use messages and scenarios where they can be lost without causing a failure. Here's an example of how to send a message. You can see here that we use the sendMessage call. This is a bit different than data items in that we need to specify the ID of the node to send to, a path representing the message, and a byte array of any content we want to send. Note that you should ensure that the byte array is limited to about 100 kilobytes. Otherwise you'll get an error code returned if you try to exceed the internal limites. So you may be wondering about where we get our node ID from. There is a method called getConnectedNodes that can return a list of nodes that are available. We use the A-weight method to make the call immediately and it will block until the list is available to you. This cannot be done on the UI thread, however, because it blocks. Once A-weight returns, then you can do a loop on the list and do whatever you want with each node ID. Such as sending a message to each node using the previous code that we just showed. So these are the building blocks for sending messages. And you can see the API is very simple. How do we go about receiving messages? Well, we can put that in our myservice.java file. What we do is overwrite another method on message received, which is also defined in wearable listener service, similar to what we did for data items. This method is passed in a message event, and you can retrieve the path of the message, with getPath, and the byte array using getData Let's think about the differences between data items and messages. The first question is which mechanism should we use for reliable guaranteed delivery? And the second question is which mechanism provides fast delivery that can be lost? The answer for question 1 is A, data items. Data items guarantee delivery as we discussed earlier. The answer to the second question is B, messages. Messages are fast, but they can be lost during transmission. And for the next question, what would you use to send a 500 kilobyte image from a phone to a wearable? Would you use a data item and the putString() method? A data item and putAsset()? Or a message with a byte array? The answer is a Data item and put Asset, because images are too large for regular data items or messages to handle. Okay now for something a little more hands on. I want you to analyze one of the Android Wear samples and answer some questions about how it works. So you will need to use the input sample feature of Android Studio and search for Data Layer. You should build and install the sample to both the phone and a wearable or a phone and an emulator. When it's running, you'll see things happening on both sides. Once you've got that working, I want you to review the source code and then we're going to answer the following questions. First one, is what transmission mechanism is used in the send start activity message on the phone side? This method here is used to launch the activity on the wearable. And the second question is what thread does the send start activity message run on? For the first question, the answer is messages. If you open up the application project and look in the main activity dot Java, you'll find send/start activity message in there. And you'll see that it makes calls to send message. And for this question, the answer is it runs on the background thread. You'll see it as code from a-sync task and the do in background method. You're not allowed to make calls like this on the UI thread. For this code here, the sample sends incrementing counts from the phone to the wearable. Find the code that does this. What transmission mechanism does it use? For this question here, find the code which handles this and what transmission mechanism does it use? And for this question, the wearable sends replies back whenever a new incrementing count arrives. What transmission mechanism is used for these replies? For this question, the answer is data items. In the same application main activity Java file we just looked at, it's contained in the data item generator class. In this case, you'll find it's data items as well in the same main activity dot-Java file. The difference is that it actually uses assets inside the data items to send the images which are quite large. For this question, the answer is messages. Go to the wearable project, and open up data layer listener service. And then find the on data changed method. This is called whenever data items arrived. If you looked at the code, you'll see that it uses send message to send the replies back. The first thing to realize when designing your application architecture, is that your phone typically has a much more powerful processor, and a much larger battery than your wearable. You want to offload as much as possible away from the wearable to try to get the most battery life out of it. Another key part of the application architecture is that the phone has direct access to the Internet, while the wearable over here does not. So let's imagine a scenario where you'll building an app to show weather updates on a wearable. The phone will need to make the request to fetch the data, and then send that to the wearable via data relay API. There are many ways you can implement this, but if you do not design this carefully it may perform poorly. So how do we implement an efficient solution to this? One of the first improvements comes from changing how you wake up the wearable device. Rather then having the wearable wake up every 10 seconds or so, and request an update of information from the phone, instead allow the phone to drive updates to the wearable device. The simple action of keeping the watch asleep as long as possible will help conserve battery life. So once you've made the weather update request from the phone to the internet, you may get back outdated information. An important step to do here is to compare this with the previous information downloaded earlier. If there's no change to the information, you should not update the watch. There's no point waking it up just to tell it that nothing has changed. We want the watch sleeping as much as possible. If you have detected a change, it's important to minimize the amount of data we actually send to the wearable. It would be a bad idea to send the entire weather query result to the wearable, since it probably includes a lot of extra information, such as what you see here. Instead, we should pass it on the phone and send just a single temperature value, like this one here, to the wearable. Remember, we're trying to minimize the amount of work done on the wearable, and even things that might seem trivial will add up eventually. So how should we send data to the wearable? If you had to send a large amount of temperature data for a time range, it might be tempting to create separate data items for each time and temperature and send them separately. However for each piece of data, set between the phone and the wearable, there are overheads added by the platform and the network. These overheads include headers for packets, acknowledgments per packet, and energy required for every packet sent. As well as activating the wireless hardware. When designing code to send out over a network, taking these overheads into consideration is important. So by storing many numeric values into a single message, there'll be much less data sent and processed, than sending each one separately. The results can be quite considerable, as you can see here. Once you've sent the item to the wearable, you might be tempted to add an acknowledgement to check it was received. However, if you're using data items, they are guaranteed by the framework to be synchronized when the wearable is paired up, so you can be sure they'll eventually be received. If you're using messages, then you will need to check that they were received, since transmission is never guaranteed if the device is disconnected, or something else happens. Let's do another quiz. For these different kinds of applications, would you use Data Items or Messages? For the first one, phone wants to popup a notification on the wearable device about a nearby restaurant. For the second one, the phone wants to configure the background color to use in a watchface. For this one here, the wearable wants to record a GPS track, and then store it on the phone. Here, phone wants to send to the wearable the user's current street information. Finally, phone wants to popup a notification on the wearable device about an important task that the user needs to take action for. For the first one, Messages is the correct answer. This is very timely information and it's not going to be relevant many hours later, if the wearable is not connected. This one is Data Items. These are settings which would be useful to store permanently in case a new wearable is paired up later on. For this question, the answer is Data Items. While on a run, the wearable might not have data connectivity. So store it in the data layer to ensure it will be synced up later on when possible. This one is Messages. This is information which is only relevant right now. Later on it will not be useful, so there's no need to store it permanently in the data layer. And for this question here, the answer is Data Items. This notification may be around for a while, and it's important that it shows up on the device, even if it's not currently paired. This cannot be lost, because it might be important to the user. In this section, we'll talk about how to build user interfaces for wearables. The important thing about Android Wear is that it uses the same underlying framework as Android on phones does, so anything you know about Android applies to wearables as well. Key difference is, you want to design your app to work well on a wearable, you can't just smoosh down your phone app to fit on a watch, you really need to rethink your UI to make sure it looks good on a wearable. A really good question you should ask yourself is this, what couldn't we do on the phone that we can do now on the wrist? What now becomes possible? So in this section you'll learn about the additional widgets that we've given app developers to use that are wearable specific, and that will give a common look to your Android wear app. A lot of Android Wear apps involve scrolling side to side, and up and down. Grid View Pager handles all this swiping for you. We also have Dots Page Indicator, which shows the little dots that appear at the bottom, showing where the user is located. These two classes do everything with a consistent look and feel, associated with all Android Wear apps. To demonstrate this, we're going to load the Grid View Pager sample app on Android studio. So, we go to File > Import sample, and look for Grid View Pager. And load that up with the defaults. Now, let's build it, and install it to our device. You can see here that we can scroll around the cards, and Grid View Pager takes care of all of this for us. For your quiz, try out the sample yourself and go through the MainActivity.java file to see what code was used to generate this. Here's the MainActivity.java file. And here is where it's configured. And you can see here the SampleGridPagerAdapter, which is responsible for configuring its layout. One of the considerations you have for wearables is that some watches are round, and this is a new screen shape that has never been dealt with before. So if you're designing a wearable app, you could have a round watch, or a square watch. There are two ways to deal with this. You could design separate layouts for round, and square watches. Or you could design everything for a square, and use what we call a box insert layout to ensure that the content always fits within the circle. The down side is that it wastes this space, on the edges. The nice part about box insert layout is that it provides a box for your app to draw in, and it promises that it will never make the square leak outside the round area. There is a sample code delayed confirmation, that uses box insert layout. Let's start the sample up. File. Import Sample. Delayed Confirmation. Next. And then,, create the sample with the defaults. The sample is a bit tricky to run, since it was not meant to be used without the phone app triggering it off. You cannot run it, using the green play button like usual. If you try to run it, it'll prompt you to select the default activity, but it can't find one. This is the error message that you'll get. So to fix this, we need to load up the Android manifest file, and make a correction. We add android exported equals true for the activity, and now it will be able to be found. So we're going to run it, we also specify the default activity. So we select the Main Activity here, and now we can run it on the device. We select that device, and we hit OK. So you can see there's an added padding to the top for the round display, but not anywhere else. Let's open up the layout main_activity.xml. You can see there is an app layout box equals top here. If you change it to all, it will box all sides of the display. If you set it to none, or forget to add this, the box insert layout will do nothing. So, make sure you get this right. Let's run it again, now. After making this change, you can see it working, and now boxing all sides. An easy, but inefficient way of designing is to always design for a round shape, and never ever put anything in any of the corners on the edges. This is easy because you only need to maintain a single layout. However, the downside is that the unused corners on the square watch might look weird, and it waste a lot of space. So, this is probably not a great idea. Finally, the most complete way to do layouts for round and square, is to use WatchViewStub. This layout will inflate either the rectLayout, or the roundLayout depending on the screen shape. You can specify two separate layout files, and do a completely independent layout for both types. The sample that we compiled, and ran at the start of this lesson used WatchViewStub to show either hollow round world, or hollow square world. The catch with this layout is that you need to carefully maintain both layouts, making sure that the same IDs are present in both files. Lets do a quiz comparing Box Inset Layout versus Watch View Stub and which one is the most appropriate for certain kinds of apps. For the first question, what would you use for a News reader or for messaging? The correct answer is probably BoxInsetLayout because you want the text will be completely visible on the screen. What about for an Alarm clock? In this case, you'd probably pick WatchViewStub because you want different layouts for round and square devices. What about for Map navigation? In this case you'd probably use WatchViewStub as well because you'd want the layout to be customized to fit the edges nicely of a round or a square display. What about the, List of the weeks weather? In this case, maybe BoxInsetLayout might be the right choice because you have a long list and you want it to fit on the screen nicely. What about a Photo of a face? In this case you'd use WatchView Stub because you wouldn't want the face photo to be confined to fit within a small box on the screen. You want the face to consume the entire size of the watch. What about Photo of a landscape? Same thing here as well. You'd probably use WatchViewStub because you wouldn't want the image of the landscape being confined to a small box on a round display. In most cases you want to use WatchViewStub to give you a custom layout for both round and square devices. But sometimes, when you're dealing with large slabs of texts, a BoxInsetLayout is the best way to ensure it's properly visible. When dealing with pictures, these look okay on round display when the corners are not visible, particularly when the subject is centered. If you've got an app that controls your whole screen, typically we let the user swipe the screen away. But some apps like the emoji drawing tool, require the app to draw all over the screen. And you don't want the app disappearing when you're interacting with it. So you can disable the swiping action. But then the problem is, if the app has got the screen locked and the swipe is disabled, then how do you get rid of it? So for that, we have a press to dismiss action. Let's start up a sample to see how all of this works. Let's go to file, import sample, and we're looking for watch view stub. So create that with the defaults. Now that it's ready, let's run it on the wearable. You can press and hold your finger on the screen. And this X pops up. And when you tap the X, the app goes away. So that's a dismiss overlay view, and it was included in the sample already. It's very easy to use. Let's look at the code for it in the sample. If we go to the wearable, res, layout, main activity. You'll see we have the dismiss overlay view defined here. It's also invisible by default. You can see here, we grab a reference to the dismiss overlay view. Here is where we create a gesture detector. And here is where we dispatch that such events to the gesture detector, so that the dismiss overlay view can receive them. One limitation of this sample is that, it does not prevent swipe actions. If you try it out, the app will disappear. So how do we go about preventing that? The solution is to override the default theme to do this. Just go back to the project view, and go to source, res, values, and then right-click and create a new themes.xml file. We creat our own custom theme like this. This says to inherit from the device default theme, and to implement an attribute windows swipe to dismiss, and set it to false. Now we need to activate the theme in the AndroidManifest.xml. With the theme activated, now we can run the sample again. You'll see that now, you can not swipe the app away. But you can exit it using a dismiss overlay view. Previously, we discussed how to generate notifications on the phone, like this here. And how they're automatically synchronized over to the wearable device. However, you might run into a situation where you want to generate a notification on a wearable, but not on the phone. This is not possible with the code that we went through earlier. The solution to this, is to create a notification on the wearable device itself. If you create it on the wearable from within the wearable APK, it will only appear on the wearable. It is never synchronized over to the phone. A notification generated on a wearable uses exactly the same code as done on the phone. You can use all the same code that you did previously. I just wanted to point this all out now, since you did not know about wearable apps when we previously discussed notifications. There are two great samples that you should refer to in the sample browser. Synchronized notifications is the first and notifications is the other. In synchronized notifications, let's load that one up. Input sample and synchronize notifications. It's in the wearable project in notification updateservice.java. The method we're looking for is BuildWearableOnlyNotification. In this method you can see the code used to make a notification is exactly the same as what you've seen before. Since Android Wear devices are worn by the users, they're the ideal platform to implement fitness applications. These types of applications typically use sensors on the device to measure step counts, acceleration, and position. The good news is that Android Wear uses exactly the same sensor API as regular Android phones and tablets, so you can use all your existing knowledge about sensors here as well. Let's look at a sample to see how it works. A good one is called jumping jack. So let's create a project around that and test it. In this case, I'm going to use a real watch to test it out and show you how it works. Right now, it has zero on the counter shown in the activity. So let's do a few jumping jacks. One, two, three and now, you can see that it's counted the values correctly. So what is different about working with sensors on Android Wear? Well, the main differences come down to saving battery power, and not doing too much processing on the wearable device. Let's go through some best practices for sensors on Android Wear. You want to do as little work as possible. So unregister your listener when you don't need it. For a running app, we only want to log steps when the user is running the actual activity. For the rest of the day when the activity is not running, we should put the device to sleep and use the standard watch face saving power. The next things is to select an appropriate update rate. If you're going to refresh the display every minute, then there's no point getting updates ten times per second. And you might also want to request that the results are batched up over this time period, so that the CPU can stay asleep the whole time. The registerListener method allows you to control these factors. Also, make sure if you need to process the data, try to do as much on the phone as possible. Remember, the phone has a huge battery compared to the little wearable here. So take advantage of that. If you're trying to measure the bumpiness of a car ride, and you know the Wearable user has their phone with them, why not use the accelerometer on the phone to do the logging instead of the Wearable? The GPS feature in Android Wear does exactly this. If you have the phone and the Wearable in close proximity, it will actually use the phone's GPS unit. If the wearable goes out on a run while the phone stays at home and if the device has a GPS built in, it'll use the GPS from the wearable. There's a sample for this called speed tracker. Check it out for yourself and see how it's implemented. When you sensor that was introduced in KitKat phones and available on all Wearables is the step counter. This is really useful for fitness applications and is a low power sensor you can use often. It's also a lot more efficient than trying to build your own step counter by reading the accelerometers. The Android step counter is provided by dedicated hardware. You'll notice in the documentation there is a TYPE_STEP_DETECTOR, and a TYPE_STEP_COUNTER. The detector is configured to trigger every time a step is made, but it's possible that you'll not receive the events if the device is sleeping. You also don't want to have the device wake up and run your code after every single step, like at these points here. Especially if you only refresh the display every minute. So the step counter here is a much better idea. It gives you an absolute value, so your code does not need to wake up on every step. And you cannot miss any steps, because you always get the absolute value each time. All of the samples we've tested on Android Wear so far. I've designed to be used for a very short period of time. If you run an app like this and let it sit for a few seconds. Eventually the watch display will enter ambient mode and the watch will switch back to the default watch face. You're watch activity will be destroyed and the user will have to restart it again if needed. So what do you do if you want to keep an app running on the display for a long period of time? Such as showing the number of steps while on a run. One option is to grab a Wake Lock and keep the display on. But that will keep the watch fully powered up, draining the battery very quickly. So, that's not a good way to do things. The proper way is to use a feature called always on mode. This mode allows your app to control what is shown on the watch screen while the watch is in ambient mode. It works very similar to a watch face, in that the power usage of the display and processor is kept to a minimum, saving power. You should only refresh the screen infrequently, and try to avoid doing any processing. Later on in this course, we're going to discuss watch faces. Which run all down a watch and it's the default to show when nothing else is running. But always on mode here is useful for activities that run for an extended period of time. Where you want the watch to go into ambient mode, but you don't want it to run 24 hours a day like a watch face. Here's the documentation that you can refer to for more details. Let's work through an example of how to add always on support to a basic wearable sample. So let's create a new wearable project. File, new, new project. Use the defaults. Make sure you create a wear project with a min SDK of 21. And we'll leave everything as is. Now that the project is ready, open up the Wearable Android Manifesto XML file. We need to add a dependency to the Android Wear Shared Wearable library. The shared library is needed for backwards compatibility. So that older Android wear devices that do not implement always on, can still run your application as a regular activity. You need to request Wake Lock permissions in the AndroidManifest.XML as well. Make sure you add this to the phone app too. Since wearable permissions must always be a subset of phone permissions. We need to have this here as well to make it install correctly. We also need to go to the wearable build.gradle file. We also need to declare our targetSdkVersion to being 22, since this is the first API release when Always-on is supported. In your build.gradle, you also need to make sure that you're including the wearable support library correctly. You also need to make sure you include this new provided entry. Which deals with some other dependency issues when you want to do release builds with proguard. But you don't need to worry about that right now. We use the plus here to grab the latest versions but you can specify an exact version if you want. At this point, you should be able to build and install everything. You won't notice any differences yet but at least you can check you did everything right up until now. Let's go and modify our activity so that it can stay always on. Click on the activity here. Modify the activity so that it extends WearableActivity. You need to call setAmbientEnabled to indicate that you want to keep your activity running in ambient mode. Instead of going back to the default watch face. You then need to override the onEnterAmbient method. Which it's called as the watch is going into ambient mode. You can implement whatever changes you want to your UI. You need to present a much simpler UI here. So you should turn off any unnecessary details. Reduce the colors used and keep the number of pixels eliminated to a minimum. Now let's set the TextView, so we can when we're ambient or not. Next, override the onUpdateAmbient method to receive system delivered ticks every minute. This is useful if you want to show an updating clock in your UI. Which is important since the watch face is not visible when your app is running like this. Finally, you override the on/exit ambient method. Which it's called when the user touches the watch display. And when we need to restore the users interface back to normal. So we need to undo everything we did in on enter ambient. Also, if you need to query this information, you can call isAmbient. To find the current state of Ambient mode for your activity. Although you shouldn't need to do this if you track state in the previously overwritten methods. So let's now start up our app and observe it in action. The screen is in ambient mode right now, and you can see that shown on the screen. when you touch it, it wakes up in interactive mode. You could slide the app away if you wanted to as well. When you do the palm gesture, it goes back into ambient mode and our app stays running on the screen. And you can see the color and size changes that take effect as we switch between the different modes. Finally, if you want to see a more complex example. We have a full sample demonstrating how always on mode works. That you can look at as well. So go to File, Import Sample, and search for Always On to find it. So now you've seen a pretty extensive tour of the features offered by Android Wear. We explained how wearable APKs are distributed by the Play store. You also learned how an Android Wear device is basically a complete Android implementation supporting the same APIs as what you're already familiar with. We have added data items and messages to allow you to easily send data between devices without having to implement your own network communications. Simplifying the development of wearable apps. Wearable devices also have different displays than previously available. So, we learned how to support round and scroll outs. And also, how to take advantage of Android Wear's Always on Display feature to provide easily glanceable information at any time. Now you know all the important information necessary to implement a complete Android Wear app. >From designing the initial layout to packaging it up and distributing it to your users. Regular Android applications use the Notification API to show important information to the user on phones and tablets. One of the most important features of Android Wear is the ability to take these notifications, and show them to the user on their wrist. In this lesson, I'm going to show you how notifications are shown on Android Wear. And how easy it is to extend this code to look great on wearables. So let's get started. Let's start by talking about how Android Wear deals with notifications. When an Android handheld and Android Wear device are connected, the handheld automatically pushes notifications to the wearable. On the wearable, each notification appears as a new card in the context stream. Notifications are shown on the Android Wear device automatically with no extra work required by the developer. If you want to give the best wearable experience to your users, you can add wearable specific extensions with just a few extra lines of code. Let's start off by showing how regular Android notifications work on a phone by loading and running a sample. We'll use the sample basic notifications for this. We'll use the same sample later on in the Android auto messaging lesson as well. Go to File > Import Sample, and search for notification. You'll see there's basic notifications here. Click on that, and then Next. You can leave everything as the default values. Click Finish and it'll create a new project on your machine based on the basic notifications sample. Now let's build and run the sample. By clicking the green Play button here, it runs the assemble debug task to compile it and then it asks where to run it. So we select our phone, which is already connected, and then we hit OK to begin the installation and start running it. You can see the sample has started on the phone. We'll walk through the code shortly. We click do it to generate the notification and you can see it appear here in the notification shade. When you click on it, you'll see it launch a web browser and open up a URL for the notification documentation, which is what the sample was configured to do. Now lets go back and click Do It again. This will regenerate a new notification. And if we look at our Android wear devices, you'll see both of them show a notification from the application. This all happens automatically. We can make the intent trigger by clicking Open on the phone and you'll see it appear here just like it did before. The nice thing is that Android wear takes care of all of this for us. So now I want you to replicate the same steps. Run the sample in a phone or emulator and check that you can get it to work. Now that we've seen notifications in action, let's step through the sample to quickly refresh your memory as to how they work. We'll need to understand how this works before we can start adding wearable extensions. So let's open up Application > Java > the Package, and then open up MainActivity.java. So lets now work through the code. Notification ID here is the unique identifier for the notification. Each notification we generate has a unique value and if we issue two notifications with the same ID, we override the first one. The interesting code is in sendNotification, which is here. This creates an intent that is fired when the notification is clicked by the user. We need to create a new pendingIntent here, so that the notification service can run the intent later on for our app. We need to setup a builder for NotificationCompat objects. We'll call methods on this to set it up. This sets up the icon to show for the notification. This tells the notification what pending intent to use, which we created earlier. And this here makes the notification automatically disappear when it's clicked on. This here is a different kind of icon used on the left side of the notification in the notification shade. These three lines configure the main title, the main text, and also some subtext, all of which are shown in the notification on the phone. This grabs a reference to the notification manager. And this takes the builder and generates a notification compound object using the .build method. And passes it to the notificationManager using the NOTIFICATION_ID value. The NOTIFICATION_ID value must be unique amongst the other notifications you might want to create. Before we can add wearable features to the sample, or any other code you might have already, we need to get things ready to make sure it works properly. Firstly, make sure you're compiling against the V4 support library. Let's open up our build upgrader file, which is contained here. And if we scroll down, it's important that you use this library because many notification features such as action buttons, large icons, and Android Wear and auto support have been added to the framework since then. And most developers need to support older devices. The next thing we need to do is make sure our notifications are issued correctly. We open up the main activity, and go down to the bottom here. It's important that we replace the use of notification manager with notification manager compact. If you try to use notification manager while supporting older API devices, they'll lose any special wearable extensions. So this is the code change to implement this. We hit Alt + Enter to add dependencies and then we're done Now that we know how to run a simple sample, and how it looks, let's talk about what notification features are possible on Android Wear. The first thing we can do is add extra action buttons to a notification. The user can view these actions by swiping the notification to the left. These actions are also visible on the phone notification as well, so this is not wearable specific. So you make a call to the addAction method of the notification compact builder. You need to supply an icon to use, and you also need to provide a string to show underneath, and finally you'll need to provide a pending intent for the specific action. You'll notice that this code snippet creates a pending intent that refers to a location, so it would open up a mapping application to display this on the phone. It is important to realize that notifications created on the phone always cause the intent to run on the phone as well, not the wearable. It's also possible to have different actions appear on the wearable device compared to the actions on the phone. To do this, we introduce a class called WearableExtender for wearable specific features we want to use. We use the extend method of NotificationCompat.Builder, and pass in the new WearableExtender object. With WearableExtender, we call addAction here to add the wearable specific action, which is defined here. Note that when you use addAction with the WearableExtender, none of the regular addAction calls will show up on the wearable, and none of the wearable addAction calls will be shown on the phone. They're decoupled from each other now. Another feature of Android notifications, called big view styles, also work well on Android ware. On a handheld a user can touch one of these notifications and it will expand to show more information. On a Android ware device the content is automatically expanded to fill the display, since there is more vertical space available. If you look at this code snippet here you can see the big text style being created and configured here with an edit to the notification by calling set style here. There is also another style called inbox style that's helpful for showing emails as well. You may have noticed code snippets using set large icon for a notification. Android Wear automatically uses these as the background image. However, the android framework only uses a 64x64 pixel version of the image, since it is normally shown quite small in the notification shade on a handheld. The wearable extender provides a method called setBackground. This method can handle high resolution images, such as mBitmap here, and send them directly to the wearable so they'll appear nice and sharp. However, make sure that the image you provide is not too large. If it is too big, you can overwhelm the memory in the small wearable device. Instead, we recommend that you provide 400 x 400 sized images if you want a static background. And 640 x 400 if you want to have image parallax added, where the left and right edges are used to simulate background movement. Make sure that you store these resources in the drawable-nodpi directory to insure the framework does not try to resize them. Android Wear uses voice throughout the platform, and one of the best places to see it in action is doing replies to notifications. Normally when you touch the reply action on a phone, it'll take you to an activity to enter the text. On Android Wear, the user can touch this reply button and then speak a reply and it is then converted into a string and delivered to your app. Best of all, you can use this feature with just a few lines of code, added to your existing notifications on the phone. We use a class called RemoteInput to implement this. We declare a string extra_voice_reply that specifies the key that will be delivered to the intent later on. We also declare a label to put on the text reply screen telling the user what we want them to speak to us. You then call build to get the remote input object. Now we need to add the remote input to our notification. You can see here we declare a pending intent to receive the reply. We then create an action and then we use addRemoteInput to use the remote input object we created earlier. Then we use extend on the notification to add a wearable extender, add action, and the action we just created. Everything is now linked together, and we can issue the notification. This code will continue to work on a phone, but now we can have a reply action that asks the user to speak a reply. So how do we get the reply string back? The previous code is written to use an activity called reply activity. Inside there, you can call get intent to find details about the intent that started the activity. Once you have the intent, you can pass it to the getMessageText method shown here. We can then extract out the voice reply using the key EXTRA_VOICE_REPLY, which returns a CharSequence that was spoken by the user. And that's it. It's that easy. Speech recognition has traditionally been very hard to do by yourself, and Android Wear takes care of all of it for you. There is also support for emoji entry in Android Wear, and these are automatically handled on the wearable, and sent to your app as standard emoji unicode characters. You don't always have to use voice replies. Sometimes your user will be unable to speak to the watch and they might want to reply with a set of pre canned replies. You can use the set choices method to specify an array of options that the user can select from to be used along with a voice reply. And here's how you define the array in the strings.xml file. It contains a set a strings that will be given to the extra voice replied to find earlier. One more thing to note here, if your using the Android wear emulator, you'll have to type your voice replies on a keyboard, since the emulator does not support speech recognition. There are times when you would like to provide more information on a notification on a wearable device. In this example, we have a calendar notification but it would be handy to show some extra reminder notes if the user swipes to the left. Android wear supports a concept called pages which allow you to add extra pages of information to a notification like shown here. To do this, you just create two notification objects. Here's the first page and this is the start of the second page. And then here's the second part of the second page where we add the style to it. And now we create a wearable extender. We use add page to add the second notification to it and then we call extend to add this all to the first notification. Then issue the first notification page, and there's no need to issue the second one. The notification will then show up with the second page attached. And note, that any extra pages added will never appear on the phone. When you're creating apps like Email Clients, there will be times when there are many emails that have arrived. On a handheld, you will be shown a notification that looks like this using inbox style. When you touch the notification, it will open up on the Email Client and show you all the emails. On a wearable, you would like to see more information about the emails without having to pull out the handheld device. It's possible to create a series of notifications, one for each email and then stack will group them together. The notifications are initially shown as a single card. That can be expanded into multiple cards by touching it. So here we create a separate notification for each email our app knows about. You can see that we add the sender here and the subject here for each email. Now, we use the setGroup method to specify a unique key for this group. So Android Wear knows which notifications should be stacked together. We then issue this like any other notification. And here is another notification for a second email. You'll notice the use of setGroup here, just like the previous one. And we issue this notification in the same way as well. The final step is to create the notification for the phone like it's shown here. Clearly we don't want the individual emails to each get a notification on the handheld device. This code sample creates the inbox style shown in the previous image. It adds a summary of all the emails in a nice format that's perfect for showing on a handheld device. The interesting part is the code is setGroup here, and setGroupSummary here. This makes the notification part of the previous group, but we've specified that this is the summary of the group by passing true here. Summary is shown on the phone while the other group items are shown on the Android Wear device. Now that you've seen how notifications can work on Android Wear, it's now time for you to try it out. So, go to this URL here, developer.android.com/training/wearable- s/notifications, and go and implement one of the stacks or pages examples so that you can see how they work. There may be cases where you want a notification to only appear on a phone, and you don't want it to be synchronized over to your wearable devices. An example might be a notification showing that there is an upload in progress on the phone. But it's not a notification that a user needs to be notified on their wearable. The NotificationCompat.Builder class contains a method called setLocalOnly. You can use this to insure notifications only appear on the phone. If you want to make a notification that only appears on a wearable and not the phone, you'll need to wait until the next lesson to learn more about how to do this. Before we finish the lesson, you should know that there are many Android samples that show off how to use the notification features we've just discussed. Let's go to File > Import Sample, and bring up the selector. The first is Basic Notifications. This is the sample we first stepped through. This performs generic notifications for Android only, and is a good starting point for testing out the addition of wearable extensions. The next is Wearable Notifications. This sample allows you to generate every possible notification type for Android Wear and see what they look like. This allows you to prototype everything before you write the code. Finally, there is Eliza Chat, which allows you to have a conversation using speech recognition with an artificially intelligent robot, using your Android Wear device via notifications. So give this sample a try to find out what is possible with Android Wear notifications. So this is everything you need to know about extending regular notifications for a great experience on Android Wear. Your application remains basically the same as before, but we used Werable extensions to add more detail that is useful on Android Wear. The Android Wear software takes care of all the hard parts such as, showing the user interface and handling speech recognition. Another thing to know, is that these kinds of extensions are quite common in Android. Similar concepts are used to handle messaging with Android Auto. So, you'll be able to use similar techniques to extend your software to many different platforms. We've discussed everything you need to know about creating notifications and apps for Android Wear. But one thing we haven't discussed until now, is how to show the time to the user. Well, watch faces are such an important feature of Android Wear that we have a whole lesson dedicated to it. What's an Android Wear watch face? A watch face is what's shown when the screen is on, and no other apps are running. It's what you'll spend the most time looking at. And the first thing that others will see, when they glance at your watch. It's visible all the time, so you can discreetly glance at the watch face, without touching or activating the device. it goes without saying that a watch face should show the time. Watch faces can also be a highly functional way to share concise, timely information. For example, a watch face can show your next upcoming calendar event, or the weather, or the current price of a stock. Watch faces are also a personal statement of style. We like to say that Android Wear lets you wear what you want, and no where is that more true than a watch face. The design guidelines we discussed for wear are a framework on which to build your creations, giving you room and support for creative expression and artistic freedom. Creating a watch face for Android Wear is an exercise centered around visualizing time clearly. It's quite different than designing an Android user interface. Android Wear devices provide a unique way to reimagine the ways in which we tell time. Android Wear also lets you integrate data on watch interfaces for a high level of personalization and contextual relevance. These are powerful tools to create watch faces, but they also run the risk of over complicating your design. The most successful watch face designs take advantage of these advanced capabilities, but deliver information clearly and elegantly. Glancability is the single most important principle to consider when creating a watch face design. Your watch face design should clearly show time and any related data. Experiment with bold, minimal and expressive designs that are highly readable at a distance. As you know, Android Wear devices come in different shapes and sizes. You'll need to consider both round and square faces, as well as different resolutions. Some concepts work better in a certain format, but a little planning will allow users to enjoy your watch face on every type of screen. Ideally the visual design of the watch face works for both round and square formats. In this example, the design is flexible enough to work well in both cases without any changes. However, other concepts might require different designs for square and round screens. When you need to do separate layouts for round and square, try using a common set of colors, line weights, shading and other design elements to draw a visual connection between your square and round versions. By using similar colors, and consistent visual elements, you can customize different square and round designs that still feel visually similar. Some of your concepts will naturally take the shape of an analog clock. Like a center dial with hour and minute hands. In this case, consider the corner areas that are exposed when translating to a square format. Try extending and exploring this extra space. Now it's time for a quiz. Which are the better watch face designs from here? The first one is a square watch with an analog watch face drawn inside of the circle. The second one is a square watch with the analog watch face extended to the edges. Third one is a watch face with the whole week's weather drawn around the edges. And the fourth one is a watch face with just the current weather. The answer here is that the second and the fourth watch faces are great designs. Great watch faces for Android Wear adapt to the shape of the device and remain simple and glanceable even when showing extra information. Android Wear devices operate in two main modes, interactive, and ambient. Your watch face design should take these modes in account. When the user moves their wrist to glance at their watch, or if the user touches it, the screen goes into interactive mode. Your design can use full color, with fluid animation, along with a background image or gradient in this mode. And you can press the side button to go back into ambient mode, or it will time out by itself. Ambient mode helps the device conserve power. Your watch face design needs to include a separate design for ambient mode. How similar or different it is, is up to you. Your watch face can use some color, such as that red there, on screens that support it. As long as it's still obvious that the device is in ambient mode. In this mode, the screen is only updated once every minute. So you should not show the second hands that we saw moving around earlier. Your watch face will spend most of its time in ambient mode, so you should thoughtfully design for it. Android wear devices have a variety of screen technologies, each with their own advantages and considerations. When designing ambient mode for your Watch Face, you should consider how it affects battery life and screen burn in on different screens. You can configure your Watch Face to display different ambient designs, depending on the kind of screen available on your device. Consider the best design for your watch faces on all screens. Some displays use a reduced color spacing ambient mode to save power. One reduced color space parse saving method is to use a low-bit mode. In low-bit mode the available colors are limited to black, white, blue, red, magenta, green, cyan and yellow, as shown in this diagram here. So this means you cannot use anti- aliasing, which is commonly used to blur the edges of lines in text, to make it look smooth. You can see how the top ABC123, looks much smoother than the bottom one. You can't do this smoothing in low-bit mode. On displays like OLEDs, eliminating pixels consumes power. So the more pixels you can leave as black, will be more efficient. You should aim for 5% of pixels illuminated. Other displays support grayscale in ambient mode, so you can support showing a background image like you can see here. Generally, you probably want to keep things simple and not show a background on any type of device, but you can in this scenario. As we said before, OLED displays are capable of being always on and have good power efficiency. But it comes with the problem of screen burning. If pixels are illuminated constantly, they'll eventually be burned into the display permanently. So you should always disable the background, and keep 95% of the pixels truly black and also avoid solid regions. To avoid solid regions, you could replace solid shapes, like these hands, with an outline and hole out the center where the hands meet, like in this image here. The system actually giggles your image by a few pixels every so often to ensure that no pixels are ever stuck being permanently on. You might notice this as the watch goes from interactive to ambient mode. Here is a sped up view of a watch and you can see the movement of the screen over time. Okay, let's due a quick quiz. Let's match the appropriate watch face with the watch hardware that we have. The first watch has an OLED display with low-bit ambient mode and is currently in ambient mode. The correct answer for this is number four. It does not use an NTA listing, the colors are solid and it uses less than 5% of the screen to save battery and not burn in the display. We have an OLED display with a low-bit ambient mode and it's currently in interactive mode. The correct answer for this is number one, the watch is in interactive mode. So full color animation and anything else, so totally fine and recommended. The next watch has an LCD display, which does not show color in ambient mode and it is currently in ambient mode. The correct answer for this one is number two. Since it can show grey scale images, although three and four would also be acceptable here. And for the final question, we have an LCD display, no color in ambient mode and we're currently in interactive mode. The correct answer for this one is also number one, as well. The watch is in interactive mode. So full color animation and anything else are totally fine and recommended here, as well. Let's talk about the System UI elements of Android Wear. When we talk about System UI elements, we talk about cards and indicators that give the user the status of the wearable and show notifications from services on the user's phone. Your job as a designer is to keep these elements from obscuring your design by placing them carefully. Cards here are the notification system that bridges information between the wearable and a mobile device. Cards are also how most applications communicate with users. The user will be notified on the wearable about items such as emails and messages. We also have this concept of something called a Peek card. The Peek card is the top card in the stream that's partially visible over the bottom of the watch face. The API provides the ability to detect the dimensions of the peek card, like this red square here. So that your design can react to this if necessary. You have the ability to request that peek cards by default are hidden, small, or variable to expand to the contents. The user also has the ability to force show or hide a peek card as well. But you need to design for all possibilities. If you have a watch face with the time shown right at the top, you can allow a variable peek card that expands to the full height. This gives the most notification information to the user when needed. If on the otherhand you have the time at a relatively low position, you should leave ridge a small peek card instead. If you have a round face with analog hands, you probably should use a small peek card as well. However, the system notifies your watch face when the bounds of a peek card change like here. So that you can rearrange the elements of your design, if necessary. Like in this example here where the clock face has actually resized itself. Indicators tell the user the status of the wearable, such as charging, airplane mode, connectivity, and so forth. And the hot word is the phrase, OK Google, which tells the user that they can interact with the watch using voice commands. When a user activates the wearable, the hot word can appear on the screen for a few seconds. The indicator in the hot word can be placed in several fixed locations on the wearable. If you have a large peek card they should go at the top of the screen. When you position these the the bottom, the system forces a small peek card. If the edge of the watch face contains strong visual elements such as ticks or numbers like this one here. Then you should place the indicators at the center of the screen. Finally, the indicators in hot word are drawn in the text with no background. So if you have a watch face with complex details in the background like text, you'll need to draw a field background like these behind the text, in an appropriate color. Great Android apps use context to produce experiences that are useful to users at the right time and the right place. Our watch face can show users contextually relevent data and react to it by changing styles and colors in your design. The first step in designing a data integrated watch face is to define the end result. What information that's available to your app do you want your users to know after they've glanced at your design? Your watch face might use data other than time, such as weather, calendar, or fitness data. Consider including data creatively. Avoid simply overlaying a time-based watch face with extra data. Rather, think about how the data can be expressed through the lens of time. For example, instead of designing a weather-related watch face as a clock with indication of the current temperature in degrees overlayed, you might design a watch face like this that describes how the temperature will change over the course of the day, rain, then sun. You could use colors to indicate the kind of weather there might be. There are lots of possibilities. And, remember, keep in mind glanceability for the user. They're going to be looking at this watch face a lot during the day. Less is really more here. The simpler your message, the stronger it will be. In this class we discuss different ways of showing information to the user. But you might be confused as to which is the most appropriate for different situations. See here's a quick run down of when to use each one of the following. Notifications, regular activity, always-on activity or watch face. Let's discuss why you'd use one over the other. Notifications are best when you need to get the user's attention right now. You have a picnic coming up in ten minutes so you need to do something about this straight away. The information will probably be out of date after an hour. Notifications will cause the wearable to vibrate ensuring the user then glances at the device to see what they need to know. Regular activities are great when you need to take care of some action right now. Such as sending a text message to a friend. You want the activity to take over the whole display, show what you just spoke, send the message, and then disappear. You might also want to get more detail about the weather for the week. You can scroll through a list to see what the temperatures are for each day. But this is not something you want to always be visible when the user is busy doing other things. These regular activities will disappear when the watch goes into ambient mode and the default watch face will then be shown. Always-on activities are special because when the watch goes into ambient mode after a timeout, the app continues to run but the display goes into a low power mode. The app draws itself with much lower detail so it looks good with a reduced number of pixels illuminated. This would be great for a navigation app. When the user is not looking at the display, the user saves power, but the interface is ready to be resumed to this one here whenever the user wakes it up. The user can dismiss the always-on app when they have finished the task they're performing. But then they can control how long this task happens for. And finally, there are watch faces. These are selected by the user as the default watch face, and the wearable shows this whenever there is nothing else to show. The user is going to be glancing at this all day to find out what time it is, and what important things there are that are going on in their lives. So now let's do a quiz on this. So what we're going to do is I want you to pick one of each type of notification, regular activity, always on activity or watch face for each of the questions here. First question is how would you implement an app that helps the user go for a run, in showing the current number of steps in distance that they've covered? The next question is what about helping the user find out when the price of a stock or commodity has exceeded a threshold value? Next, what about viewing a graph of the history of the weather at a particular location? What about finding out if there are any incoming emails or messages? And tracking the number of steps and distance walked each day by the user? And finally, tracking the calendar entries that you have upcoming in the day? For this question an always on activity is ideal here. You want to be able to glance at the stats during the run and don't want the activity to go away. But you can dismiss it when you finish the run, returning to your standard watch face. For this question it's notification. Stock prices can change slowly and there's no need to keep checking the watch. The best strategy is to show notification when the threshold has been exceeded so the user doesn't have to keep looking. This one, it's regular activity. If you want to look at some detailed information, a regular activity is fine. Once you're done, the activity will automatically dismiss itself. For this one, notifications are the best way to find out if there are new emails or messages. The notification will vibrate when something interesting happens. There's no need for the user to keep checking the display themselves. For this one, probably a watch face. Watch faces run 24 hours a day. So if you want to track the steps you take everyday of your life, having this on your watch face is probably a good place so you don't have to keep starting up another activity. For this one, it's probably watch face as well. Watch faces run 24 hours a day. So if you're the kind of person who wants to see your calendar all the time, a watch face might be a good idea. You could use a color coded ring around the edge to indicate your busy and free times over the coarse of the day. Or some other kind of non visualization that doesn't involve showing text everywhere Now it's time to dive in and start exploring how to create our own watch faces. The best way to start is to look at some of the existing samples and see how they work. So go to File, Import Sample, and type in Watchface. You can create this with all the default values. If you expand the Wearable Project, you'll see there are many services defined here. The sample actually includes more than one watch face. And we'll see how their defined shortly and what they do. So now, you should build and install the application side to the phone. Include the green play button. And then also, build and install the wearable side as well. Note that you won't be able to select a default activity because neither of these contain one. So let's run this and see what it looks like now on the watch. On the watch we can select a watch face by pressing and holding on the current watch face. You'll then see a selector appear. If you scroll to the right, you'll see sample analog. Select that. You'll see it shows the time with hands and to ticking seconds. Now let's select sample sweep. This one is very similar to the sample analog except you'll notice the second hand has a smooth sweeping motion. This refreshes much faster than once per second to achieve this smooth motion. Now let's select sample card balance. This one's not meant to be used as a watch face, but it's meant to be used to help you visualize the dimensions of the beat card. Now let's select sample tilt. This is implemented using Open GL and shows how you can apply arbitrary 3D rotations to a watch face. Now let's select sample calendar. This is interesting because it actually looks at the calendar on your phone and determines how many meetings you have coming up and presents this in a watch face. So this is an example of how you can implement awareness about your users schedule as part of a watch face. Let's go to sample digital. You'll notice this one has a little gear icon underneath. This allows you to actually configure the watch face locally from an activity. So let's select a red background. Now, interestingly, we can also go to the phone and start up the Android Wear companion app. You'll see that Sample Digital is selected here, too, and there's also a little gear icon. You can click on that and there are more configuration options available for the watch. You'll see how the red background that we selected earlier is shown here. This sample actually uses the data API to synchronize the selections between the phone and the wearable. So you can make changes on either side like adjusting the text color here or the background here. Now that you've seen how to run the sample, now's a good time for you go and try it out for yourself. The first thing I want you to do is to build and install the sample to your phone and wearable. Then, switch between the watch faces I just demonstrated. Finally, I want you to select a sample digital watch face. Then I want you to use the configuration activity to select the same colored background as the text for the interactive watch face. So the question is what happens when the watch goes into ambient mode? And note that if you're using the simulator, you can enter ambient mode by pressing the power button emulator interface. When you select blue for both the background and the text color, the watch face is not very useful in interactive mode. But when it goes back into ambient mode the colors are ignored and the text is visible again. You should avoid letting the user set the same color for the foreground and the background, otherwise the user might think the watch face is broken. Now that you've tried out the watch face sample code, it's time to do a deep dive to understand the different parts of making a watch face. If you look at the project in Android Studio, you'll see it shares a lot in common with a regular Android Wear App in that it has a phone project application and a wearable project. So they're built into an APK in the same way as a wearable app. You can even bundle a watch face in with an existing app or multiple watch faces into the same APK like we're doing here. However one key difference is that watch faces are actually a service, they're not activities. If we look at DigitalWatchFaceService, you'll see that it extends CanvasWatchFaceService. You will also see that we define an Engine class which extends CanvasWatchFaceService.Engine. These classes are both defined in the Wearable support library that you've seen earlier. The first method of interest is onCreate, which is called to initialize your service. The first thing we do is call setWatchFaceStyle, and provide a builder of the attributes that we want to set for our watch face. You can see that we've selected variable size PeekCards here. We also only want PeekCards to show for interruptive notifications and finally we disable the SystemUiTime since our WatchFace is doing it's own time representation for us. The next part of onCreate is initializing resources. It's very important that you do as much of your allocation and initialization here as possible. So setting paint styles and loading and resizing large bitmaps should be done here. You definitely don't want to be doing expensive operations in the main draw code for your watch face. Nor allocating and freeing objects since that will cause the refresh performance to suffer. The next step is the onTimeTick method. This method is called in ambient mode once every minute. This is the only time that Android wear will call you code to update your watch face. We'll talk more about faster updates later. When your on time tick is called, you need to invalidate the canvas. This tells the framework that your canvas needs to be redrawn, and this is done in the onDraw method, which will be called later. The onDraw method is where all the drawing happens for your watch face. You need to run this code very quickly since it'll be called a lot. So hopefully, you did all your prep work earlier in onCreate. You can see that we start by setting our pre-created calendar object to the current system time. Then we start drawing things. We filled the background with a solid color. And then use the bounds object to provide the dimensions. You should always use the bounds object to calculate the width, height, or center of the display, and it will work properly even on devices with an inset chin at the bottom. This is important in an analog watch faces where the hands must come from the center of the display. The canvas object has many methods for drawing, drawRect here draws rectangles, drawText draws text for you. You can control how this drawing is done with the paint object provided as the last argument. These were configured in onCreate. You'll notice this use of isInAmbientMode. This is used to decide whether we'll render the seconds value, or put AM or PM afterwards when in ambient mode. Here we have the onPropertiesChanged method. This method is called to provide to you information about very special display support that you might need to implement. You can see here PROPERTY_BURN_IN_PROTECTION. We do not use bold font on displays that have burn-in issues, since the thick text will be wider than the shifting pattern applied to move the watch face around. You can see here we call setTypeface to implement this. And here we have PROPERTY_LOW_BIT_AMBIENT. This tells us if the display can only render simple colors when in low power mode. So what else is happening for interactive versus ambient mode? The onAmbientModeChanged method is called whenever a switch is made between modes. In the code, you can see it's changing the paint styles so they have different colors depending on the mode we're in. We also detect if the watch supports low bit mode. If it does we toggle the anti aliasing flags since that is not allowed on these watches in ambient mode. In here we call invalidate to force a refresh after the change. Otherwise we'll be stuck with the previous display and will not match the mode we just entered. Finally you will notice an updateTimer call. This is important because we need to refresh the watch quickly when in interactive mode but once permitted in ambient mode. Let's go to the definition of mUpdateTimeHandler. You can see we defined a Handler earlier. We call invalidate to force a refresh and then decide if we should schedule another update later on. If we do, we set an update to occur in a fixed number of milliseconds. If we follow the dependency, we can see it as NORMAL_UPDATE_RATE_MS and this 0.5 seconds. So the CP will sleep between updates. The code is written in onDraw to draw colons for the first half of each second, giving a blinking effect. If you look at other samples like the Suite Watch Face, it does not use a timer, and just calls in validate directly from onDraw. This uses a lot more CPU power, but gives smoothly moving watch hands. Some of the other interesting features are support for time zones. We register a broadcast receiver so that our service will be notified when we change time zones. This happens more often than you think, such as when our user arrives in a new city on an airplane. You can see the code changes the time zone of our calendar object. It then calls invalidate so that Android will refresh the clock immediately. Android Wear automatically propagates the time zone change that the phone discovered to the wearable. So what we need to do is register the broadcast receiver to find out when other changes have been made. The time zone is retrieved here with the getDefault method. One other thing to note is that you'll also need to deal with any localization issues such as drawing the time and date appropriately for different languages. In the same way that you'd have to deal with this on Android phones and tablets. Let's now go to onDataChanged. You'll notice that this service implements a listener for changes in data items, just like we talked about for wearable apps. This is designed to handle updates from the configuration activities and change the UI to reflect the desired colors. Now that we've seen all the code to render the watch face, we still need to look at how the colors were configured. Let's load up DigitalWatchFaceWearableConfigureActiv- ity. This activity runs on the wearable and is available by the little gear icon when the watch face face is selected on the wearable. This is a standard Android Wear Activity. There's nothing special about it. It implements a wearable list view, and shows a list of colors to set as the background. If we look at the on click handler, we can see it calls UpdateConfigDataItem. This method then sends out updates to other listeners on the Android Wear network. Let's go back to the main project. If we look at the phone application project, we can see DigitalWatchFaceCompanionConfigActivity. This is an activity that runs on the phone side. It's also a standard Android activity that brings up some selectives for different colors in the UI like we tried earlier on. This code sends out updates to Android Wear devices using the message API here. It can also receive data item changes made from the wearable configuration activity as well. The main difference here is that the phone side implements many more configuration options while the wearable side was kept simple due to the size of the display Let's go back to the main project view. Once you've created the necessary services and activities, you need to register them in the Android Manifest XML so that Android-ware on the phone and wearable side knows that you have watch faces to select from. Let's have a look at the wearable Android XML file first. Firstly, you need to request PROVIDE_BACKGROUND and WAKE_LOCK permissions. You need to do this on the phone side as well since the phone app must always request every permission needed by the wearable. Let's now look at the service definitions in the manifest. You can see that each watch face has a unique service entry. Let's look at the definition of DIgitalWatchFaceService. You'll notice we've declared our service, given it a human readable name And specify BIND_WALLPAPER for permissions. The first item we have inside here is android.service.wallpaper. This needs to refer to a watch_face.xml file. And when we look at the declaration, it looks like this. You can see here, there's a wallpaper element declared here. Next we have the preview and preview circular attributes. These are used to define images that will be shown as previews on the companion or watch when selecting a watch face. You can see that if we right-click and go to the declaration, this is what it looks like. You can specify a separate image for round displays if you have a different layout. And if you don't provide one, it'll fall back to the square one. You can create these images by just taking a screenshot of your watch face running on a device or emulator. We also have a companionConfigurationAction, which specifies if we'll be providing an activity on the phone companion side to configure the watch face. This enables the little gear icon on the phone side. That we tried earlier. We create a unique name here with our own package name and tag it CONFIG_DIGITAL. We also have a wearableConfigurationAction which specifies we'll be providing an activity to run on the wearable to configure the watch face. This enables the little gear icon on the wearable side to make changes. We use the same unique name as the phone companion configuration action earlier. We also declare an intent filter for a wallpaper service with a category of watch face. Like here to complete the definition of our service. Finally, we need to declare our DigitalWatchFaceWearableConfigActivity which is the activity we'll run if the user wants to configure this watch face. We need to add an intent filter that includes the default and wearable configuration categories for the watch face picket to see this activity. We also should check out the SweepWatchFaceService to see how to implement smoothly moving analog watch hands. Most of the concepts in this code are the same as in the digital service we just reviewed. Let's look at onDraw. If we scroll down, you can see at the end we call invalidate if we're in interactive mode. This forces an immediate refresh as soon as possible, giving the smooth second-hand movement. Also, let's have a quick look at onSurfaceChanged. This method is called to give us the dimensions of the display and typically happens once when the watch face is started. This is where we resize the background image once so it's ready for use in the Android method later. So, for this quiz, I want you to try and create your own customized watchface. You'll notice in the SweepWatchFaceService and the AnalogWatchFaceService that it draws an mBackgroundBitmap. The existing bitmap is a very dark gradient, so you'll barely see it. What I want you to do is to replace the image this references to your own custom image. So, you could put up a picture of a friend or a pet, like my dog Mila here. You can use any 320x320 image in either PNG or JPG format. Don't use anything too large, or it could cause the watchface to run out of memory resizing it. Also, make sure you test your watchface in interactive and ambient mode. You'll need to hide the background image in ambient mode, and clear the canvas to black instead. So, go and implement your change in either the SweepWatchFaceService or the AnalogWatchFaceService. And then test it on your device or emulator. This code makes a reference to R.drawable.bg and this references a bg.png file in res/drawable-hdpi. So what we'll do is we're just going to copy our new dog.jpg into the same directory. So here we're going to copy the image over and now we can see it here in the project viewer. This here shows that I used a 320 by 320 jpeg image. I changed bg to dog here in the code. Now if you look at where the drawBitmap call is made, it draws it all the time. We need to only draw the bitmap when not in ambient mode. So we add this if statement to check the ambient state. Also, we need to clear the canvas to black if we don't draw the background. If you forget to do this then the canvas will show the previous one before ambient mode and you will incorrectly see the second hand. So that's it. We're done with the changes. When we run the watch face in interactive mode, we can see the dog picture in the background. When we go into ambient mode, the background is black. Congratulations! You now have your own customized Android Wear watch face. After learning about watch faces, you now have a complete understanding of how to write any kind of application for Android wear. Watches have been used for hundreds of years to be able to tell the time as well as a personal statement of style. Now you have the ability to dream up any kind of watch face design, and then implement it on Android wear. This will keep your users up to date and on time with relevant information to their life all with a simple glance. I'm looking forward to seeing what kinds of beautiful watch faces you develop for android wear users. Final project time! Now, you get to dig in and make something awesome. Given the nature of these platforms, we've kept this project pretty flexible. But make sure to read the project requirements carefully before jumping in and remember, your app should provide a unified, seamless user experience. It should feel natural, moving from one form factor to another, with appropriate features on each. It wasn't that long ago that computers were these strange things you put in a separate room. You loaded software on them from something you got in the mail and you printed the output on paper. They were clearly abstract tools for uncommon tasks. Nowadays, all these devices talk to each other and to use. They're part of our daily lives, and provide all sorts of value. >From looking at movie times to calling a taxi or talking face to face with a friend across the globe. > And yet, much of how we interact with computers is still abstract and specific to the device at hand. In fact, many people view the future of computing as devices everywhere, floating screens, animated graphics on every surface, cats and dogs living together, pandemonium. But that's not what we mean by ubiquitous computing because it's not the device or the app that's the most interesting thing here. The most interesting thing is solving real problems for real people, and then providing that solution anywhere and everywhere they'd want or need it. That's what we mean by truly ubiquitous computing. When we build for real people, technology doesn't become more visible, it becomes less visible. It blends into our lives and freezes from learning obscure ways of doing things, so that we can focus more on what we're doing not how we're doing it. We hope you've fun learning the design principles and building blocks for these new form factors as we've had teaching them. Now, go out and make the world an even cooler place to live in. These are Android Wear watches. The first thing that you'll notice is that they don't look like other Android devices. Now this is key, because they are used differently than other devices like a phone or tablet. The UI is different. They're worn, instead of put pocket, and so on. The second you'll notice is that these watches are as diverse as the broad set of users who wear them. You might be dealing with a square screen, or a round screen, your user might be a runner or might be a pilot. Instead of fighting these issues, embrace them by designing an app that works great on any watch and in any situation that makes sense. The good news is that from the perspective of actually writing code, these watches look very similar to Android phones and tablets. Much of the underlying software is exactly the same. Even the hardware is basically the same with similar senses and functionality. So once you learn all the new paradigms of designing for a wearable, you can jump in a familiar Android territory to build it. In this introductory lesson, I'll give you an overview of the design philosophy and platform components of Android Wear. But first, let's start with the demo. This is Android Wear. It's simple, glanceable, and built around micro-interactions. Now, the interface is divided into two primary behaviors. First, the user can talk to the wearable. Okay, Google, set a timer for five minutes. You can think of these as actions. Also, the wearable can talk to the user, and you can think of this as the context stream. It's sort of like enhanced notifications that matter to the user right now because it's the right time or place. That's the basic framework and it sets you up for success. But to really make it all the way there, you need to carry the design philosophy into your application as well. Let's talk about that in more detail. By providing the smart connection to the rest of the world while respecting the user's attention, Android Wear feels personal and global. It's simple and smart, and it's unobtrusive and ever-ready. Now applications that represent the following principles will feel most at home in the overall Android Wear experience. Wearable apps are aware of the user's context, their time, location, and physical activity. Now the apps use this information to insert cards into the stream when they become relevant. This makes Android Wear timely, relevant, and very specific. A classic wristwatch is designed to let you see the time in a split second and get on with what you were doing. And it should be the same for Android Wear. The less time it takes to use your software, the more time the user can be present in whatever they're doing, and the more overall value they get. Android wear is fast, sharp, and immediate. Remember what we looked at just a moment ago. The wearable can talk to the user, and the user can ask things of the wearable. Now you can visualize this much like a personal assistant. It knows you and your preferences. It'll only interrupts you when absolutely necessary, and it's always on hand to provide a ready answer. Android Wear is helpful, it's respectful, and it's responsive. Android Wear focuses on simple interactions, only requiring input by the user when absolutely necessary. Most inputs are based around touch swipes and voice. And inputs requiring fine-grained finger movements are to be avoided. The Android Wear is gestural, simple, and fast. Now keep these in mind as you dream up your Android Wear experience. As with everything here, please also check out the additional detail in our documentation. The Android ware platform emphasizes depth and flexibility. Built on Android, it allows developers to use familiar APIs to create useful, performance and imaginative apps that run directly on the watch. In the spirit of Android, you have the freedom to make substantial changes to the user experience, including the creation of custom watch faces. There are three main categories of experiences you can build. Notifications, watch faces and apps. Android wear notifications are the easiest way to get started in the world of wearables. If you've got an Android app with a notifications, they all ready work on the watch. If you've all ready enhanced your notification with actions, such as next or previous. This is even better, and also automatically works with no additional work required. You can take things further with Wear's specific functionality that make your notifications even richer experiences on the wrist. Stacks, which are like inbox style notifications, now you can deliver multiple items in a single bundle. Pages are for showing multiple screens of information on the same topic. But, remember to stay glanceable. Replies. Now replies allow the user to respond directly from the wearable with their voice. The ability to create custom watch faces gives you direct access to the most prominent UI element on the user's most personal device. And the API is simple enough to build watch faces quickly and flexible enough to allow personalization. Given the depth and flexibility of the Android platform, you can create something for the user that's both beautiful and pact with unique features. And here's a few design guidelines that'll set the right context for making these design decisions. First, the Android wear comes in multiple form factors. So you want to make sure that your watch faces work great on both round and square watches. Next, there are two primary states for Android wear. Interactive mode is in full color and motion with fluid animation. Now, this is typically when a user is giving focused attention to their watch. Ambient mode is a low power state and it should use a limited color palette that's only updated once a minute. And finally, make sure to take special screens into account. On low bit screens, pixels in ambient mode are either off or on, which means you'll only want to use black and white with no anti-aliasing. You're also going to want to use burn-in protection techniques with OLED screens, like avoiding large blocks of opaque pixels. In fact, we recommend that around 95% of the screen in ambient mode remain black. Once you've finalized your design, the best way to start developing is either to start with a sample or a template in Android Studio. And there are three main methods which you're going to want to know about. First the onCreate method. You'll take care of your initialization tasks, such as loading resources or initializing paint objects for later use in this method. You can scale these objects using the onSurfaceChanged method. And this method has the screen size passed in as one of its parameters. If you have a bitmap background, or watch hands, this is a great place to scale them to the right size. At the core of the watchface api is the onDraw method. Now that allows you to draw whatever design you can think of to the canvas at a high enough frame rate to deliver fluid animation. Now, this is going to come through at full fidelity while the watch is in interactive mode. And at other times when the watch is in ambient mode, you're able to draw a more discrete version of the watch while also saving power. Additional preferences can be set to arrange the System UI elements appropriately for your design. Once those basics are covered, the limits are your imagination. You can go further with additions like, I don't know a moon phase, the current weather or even fitness stats. Now watchmakers call these items complications, but with Android Wear they're hardly complicated. Once you have the data, just draw it on the canvas as you did the time. The user experiences you build for Android Wear get to take advantage of the power and flexibility of the Android platform. It's easy to get started and possible to create a truly ground breaking UI for your users. In the following lessons, Wayne will take you through the details of wearable notifications, building an app that runs on the watch, and creating a custom watch face. Ready to get started Wayne? Let's do this. Okay Google, send a message to Wayne. I'll be at our building in 20 minutes, can you get Josh and meet me there? Okay Google, start a run. [SOUND] Here's the message. I'll be at our building in 20 minutes, can you get Josh and meet me there? Reply. How about we make it five minutes? [SOUND] Got it. Here's your message. How about we make it five minutes? Do you want to send it? Cat videos. [MUSIC] I'll see you in 20 minutes, Timothy. [MUSIC] I'll see you in five minutes, Wayne. [LAUGH] Okay. One, two. Welcome to Ubiquitous Computing. I'm Timothy Jordan, a Developer Advocate at Google. And I'm Wayne Pakowski, also a Developer Advocate at Google. And I'm Josh Gordon, and you guessed it, also a Developer Advocate at Google. As you'll learn in this course, Ubiquitous Computing is simply a fancy phrase for technology that's accessible to the user, whenever and wherever they want or need it. Perhaps, they're outside going for a run. Or having some friends over to watch cat videos and play games. Or maybe, it's time for a road trip. Your users can be in any of those situations, and you don't want them to have to think about what device they need to get to your service. No, you want an experience that presents itself to the user wherever it makes sense. By building an app that runs on whatever devices they happen to have nearby. In this course, we'll teach you about the existing platforms and tools that can make your app available on a variety of form factors. But before we get started, I'll explain just a little bit more about what it means for your app to be ubiquitous. The traditional approach to supporting different devices is to make an app for each device and platform as they become available and adopted by users. This has typically meant a new project for each and every device developed and supported independently. For most of us, we actually think of the experience on any of these devices as part of a single whole experience for the user with our service. Approaching each as a separate project is well, it's just the wrong way to go about it. Instead you're going to want to think about having a view into your service from every device that makes sense. Now this is really the definition of ubiquitous computing where your service is available anywhere and everywhere. Each view into your service will differ slightly depending on the features available, and what the user needs in that context, but taken as a whole these views lead to a single seamless experience for the user across their life. We'll be teaching you how to use Google's platforms and tools to build these kinds of experiences for your users, while staying relevant and unobtrusive. Now keep in mind this is not an introductory course. We're going to assume that you're already familiar with the Java programming language, and that you already know the Android platform. If you're unsure if you're ready for this course, we recommend you start with Developing Android Apps. Also make sure to check out the instructor notes for other resources that will introduce you to Android and Java. Let's get started! One of the best parts of being a developer advocate is the opportunity to talk to developers and designers around the world in building amazing things. And we talk about their existing integrations, ways to make them more performant, how to take advantage of new services and increasingly, how to extend them to new form factors and more parts of users lives. And in these conversations, I hear a lot of great ideas. Some of these ideas can be characterized like this. Incredibly cool [LAUGH] while also not useful at all. And herein lies a central issue with building for new form factors. Often our imaginations run so far to the science fiction of our art, that we forget to make sure we're solving actual user problems and then test to make sure our solution is a good one. That's why we're going to take a few moments right now to discuss the big picture of design for new form factors as a baseline for our more detailed design discussions later in the course. Now let's start here, with the desktop computer many of us have spent countless hours working with to build and use software. It looks conventional and familiar only because we've each spent so much time with it. But something you'll notice about all these devices when you look at them without anything else in the picture. It's hard to see the human. Now one of my favorite thought experiments is by the VR pioneer, Jaron Lanier. You may have heard this before, so just bear with me for a moment. What if aliens came to Earth and people were nowhere to be found, and what if these aliens tried to figure out what we were like based on our computers. What would they think? DI mean do we have a hundred and two fingers and one big eye? Now if they look to the hammer, he'd make more sense. You can almost see the arm that would wield this tool and hammer in nails. But this computer? I mean, just look at that keyboard, it's not really built for us, in fact, it's not even built for us to type fast. Back when this keyboard layout was designed, it was intended to keep us from typing so fast, that these tight bars would get caught together and screw everything up. But this, is what evolved into the modern keyboard. Now this is a very physical difference between a person and a machine. Let's look at a less physical difference that's just as dangerous. Now what's wrong with this picture? In many ways, this is our relationship to technology today, it gives us a lot of value. However, we're adapting our lifestyle to the technology that assists us, and there's a heavy cost, distraction. We pay that cost frequently. But what if we didn't have to? These are some ways that you can use the technology we discussed in this course. And what I love about each of these examples, is that you can hardly see the technology. Some people think that the future of computing is keeping you immersed, and keeping you away from you life. But as it turns out, with ubiquitous computing, less is more. It's where we, as developers and designers, put the user before the technology. As we remove the abstract barriers, such as what functionality resides on what device. Our users can focus more on what they're doing, and less on how to start doing it. Now, this simple core philosophy to ubiquitous computing is what you see over and over again in terms like seamless, simple, microinteraction, and glanceable. And it's not new. It's the idea that success isn't measured by how long the user is engaged with the interface, but how quickly we can get them to what they need. Now there's a website that's been around for just over 15 years, that was built with that philosophy in mind. Google. This kind of user interaction is in our DNA. Back at a time when the search engine philosophy was to keep the user on the page as long as possible, Google went the other direction. And as it turns out, that's exactly what users wanted. And that's why it made sense for us to recognize that as a core philosophy across all these new form factors.