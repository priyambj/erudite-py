 Hi, I'm Cay. I'm Sara. We'll be the instructors for this course. The way most people interact with their computer is in the same way that I just did with my Word Processor. There were a lot of buttons, but if there isn't a button for what I want to do then I'm stuck. However, there's a secret language that you can use to make your computer do whatever you want it to do. In this course, we teach you that secret language. When you learn it, you will have power over your computer. We'll get you started with the Java programming environment, and you'll write your first programs. You might make a few mistakes. That's okay. Actually, it's good, because you learn from your mistakes. We're really excited to teach you the secret language, so that you can make the computer do what you want it to do. Let's get started. My name is Kylie. I'm a junior at Stanford studying Symbolic Systems, which I joke is CS with a social life. It's computer science with philosophy, psychology, linguistics, and communications. I came into school thinking that I wanted to do public policy because I wanted to change the world. And then, I had a realization that, why do I have to do that with politics when I could do it with technology? But I still needed that push. my brother, who's a developer, told me he would disown me if I didn't take and enter the computer science class. And so, I took it and I was immediately hooked. Let's start with a very basic idea of what programming is. Look at this toaster, what can it do? Okay, the toaster can toast. Good toaster. What about this computer? The computer can run programs, why is that better? Why do we say we are in the computer age and no one says we are in the toaster age. A better way to describe that is that a computer can do any instructions that you give it. Whatever you tell the computer to do, it will do it. And that makes the computer such a universal device that can manipulate images, text, sounds and much more whereas a toaster can just toast. There's just one catch in order tell the computer what you it to do you have to speak it's language. You're going to learn how to tell the computer what you want it to do in the language that the computer understands. And that's a great thing because now you're the master of the machine and it will do for you quickly and reliably any number of tasks that you would find tedious or difficult to do on your own. The language that you will learn in order to talk to the computer, is called Java. The name Java was chosen for fun. Many programmers drink lots of coffee. And some people call coffee, Java, because of the island of Java. They grow coffee. Whatever. We've chosen Java, for a number of reasons. Java is very, very popular. There are millions of programmers who are familiar with Java and who use it every day on the job. Java is as programming languages go, pretty simple for the most part. There are a few rough edges because Java was not designed as a training wheels language for students. It really is a real word programming language. But, that's okay. Java is safe. And, that's great for students. When you make an error, you'll get a very clear indication of what went wrong, and it'll be easy for you to fix it. And finally, Java is very useful for the kinds of everyday tasks that you might encounter. Processing text, processing images, dealing with the web. In this course, you will learn. To use Java in such a way that you can simplify your own work. So again, what is Java? Java is a programming language, a language to write instructions for the computer that is popular, simple, safe, and useful. Let's get going to write some programs in Java. Our first program will follow a long standing tradition among programmers and print a simple greeting to the world. Here is the java code. Well it doesn't look all that simple may be. But I'll show you a little trick. It turns out that this line here is much more important than the other two. And, in fact, let's hide those for now. Now let's have a look at this statement here. And give me your best guess, what greeting do you think will it print? Well, the greeting will be Hello World, the text that's enclosed inside these quotes. Let me show you how that works. I will be using this programming environment, called BlueJ. BlueJ is a great environment for learning Java, and I hope you have a chance to download and install it on your computer. If not, it's okay. You can use a simpler environment that's a part of the web course. BlueJ is really nice, and I really encourage you to go ahead and download it. You'll find a link with installation instructions in the instruction notes. We also gave you all of the code that we're using in this class, so you should download that too. Cay and I are going to help make sure you get BlueJ and the course code installed and downloaded. Installing BlueJ will have two main parts, installing Java and installing BlueJ. You might not notice this part if you are on a Mac. There are links below that will help guide you. There are written installation instructions and some videos of the installation process. You'll need to pick the right instructions for your operating system, Mac or Windows. If you can't get BlueJ running, it's not your fault. It just means your computer's set up differently from ours. We can help. Post your questions on the forums. Below this video, there's a section called discussions. You can read other people's questions and answer, or you can ask a question yourself. When you're asking a question, give us as much information about what you did and what the result was, as you can. The more you tell us, the clearer our advice will be. Once you've successfully installed BlueJ, open BlueJ and go to the Help menu. Select About or Copyright, whichever one you see. Who's the first contributor on the team? In other words, what's the first name that comes up? If you got that working, you just completed the first question on homework zero. Lucky you. You can now navigate to homework zero and do the rest right now if you like. To do that you would use the drop down up there. Right now it probably says lesson one objects, but that's what you'll use to move around between lessons and homework. If you don't feel like switching to the homework right now, that's fine. You can finish up this lesson first. Once you've installed BlueJ, you'll need to download the course code. There's the link below, click it, it'll prompt you to download a zip file. Save the zip file under Documents. Unzip the directory. It contains the code for lesson one. It also contains a file secretCode.txt. The video links from the last question also show the process of saving the Zip file, and unzipping it. What does secretcode.txt contain? If you were unlucky and installing the software didn't work for you the first time, that's okay. For most of the questions, the Udacity IDE is a good backup. Keep trying to get BlueJ working though and definitely reach out for help. We want this to work for you. Afterwards, go ahead and start BlueJ, and follow along what I'm doing here. Select the Project Option, open a project, navigate to the folder into which you have unzipped the starter code, go to lesson one and then to hello, and here you get an icon that represents out first program. Double-click on it, and a window pops up with the program code. Here again is the line that I said is the most important one. We'll have a closer look at the bits and pieces of the statement later, but right now let me show you how to execute a program. Click on the button that says Compile. Now your program is translated from the Java language into a lower-level language that the computer can execute efficiently. We don't normally have to worry about that process, except we have to remember to hit the Compile button before running the program. Now back in the main display, right-click on this box. Select the second line that contains the word main, and that launches the main part of our program. You get a dialogue here where you should simply click OK. As soon as you do that, another window pops up and [UNKNOWN], here's our greeting, Hello World. Now, of course, I want you to change the greeting and print something else, and I want you to show me what you did. Here we'll use the Udacity coding environment, and not BlueJay to give us any of the code that you have developed. Let me show you that. Whenever we want you to submit programming work, you will see a screen such as the following. Here we give you a bit of starter code, and some instructions on what we want you to do. Right now it says, please print Hello Udacity. You can type your answer in here. Or even better, you can first do the answer in BlueJ and then just paste it in here. To test your program, scroll down and click the Test Run button. And here you see the program output. Once you're happy, click the Submit button. That way we get your work, and get you feedback. In this case, that it was correct. Now, it's your turn to try it. Sarah will walk you through your very first programming assignment. Good luck. When you want to just try an idea out in BlueJ, you have a couple options to start. One is to open the test prog BlueJ project that we made for you. It's in the files for lesson 1. The other option is to make a new project using BlueJ. To open the test prog project, open up BlueJ, click the Project menu, and then from the drop down select Open Project. Use the window that pops up to navigate to wear ever the lesson 1 code is. Double click, and open Testprog. It should look something like this. If you right click, you can open the editor. And then you have a main method all set up and ready to go for you where you can put whatever code you want to try out. If instead of using the test project that we made for you, you want to make a new project. You would go to the same Project menu, select New Project. And then give it a name. Some examples are compiler runtime, errors, hello, whatever your project is going to be about. I'll just call this one a new project. Now I close whatever project I had open before and I can see my new project. Before I can write code in it, though, I have to click New Class. And then come up with a name. I'll just call this one Testing An Idea for now. Now you edit this the same way you always would. Open Editor, and there's a lot of stuff in here. I always just delete it. Except for the class definition. And then add back whatever code I need to try out the thing I want to try. Again, you can put whatever code you want in here. Now that you've seen how to make a new testing project, let's put that skill to use. We're going to try out some code. Let's experiment a bit more. What if we wanted to print Hello World on separate lines, like this. Hello on the first line, and World on the second line. Can you write this program? Try doing it in BlueJ, and then pasting it into our IDE. If you can't get BlueJ working right now, then just use our IDE. Let's look at the code that I wrote to do this. Here's all that stuff that we had to do just to make the computer happy. And then here's the interesting part. I wanted to print on two lines, so I used system out print line twice. On the first line, I wanted to print hello, so I put hello in quotes. And I passed it out to system out print By putting it in the parentheses. On the second line, I want it to print out world, so I write world in quotes and again, put it in the parentheses. To run this in the Udacity IDE, I just copy this. I'm going to use Cmd+C or Ctrl+C depending on whether I'm on a Mac or a PC. And then I'm going to go to the Udacity IDE and I'm going to paste it in. Now I can test run it. And like I expected it prints hello and world on separate lines. Let's try printing something different. If I were to program with these two lines, what will it print? You may want to try this out in BlueJ or in Udacity IDE. Does it do what you expected? You should put your answer in this box. It should print 12, and 3 plus 4 plus 5 with all the spaces. This might have been different from what you expected. We didn't use quotation marks here. The quotation marks mark literal text. If we use quotes, it means that we want to write 3 plus 4 plus 5 as it is. But when we don;t use quotes, the computer reads 3 plus 4 plus 5 as numbers. It knows how to add the numbers, so it added the numbers and then it printed the result as you can see here. You can use system.out.println to print numbers and text You've just worked with Sarah on a few modifications of our first program, and I hope you found that you can make changes to the program without understanding all of the bits and pieces. But still, it's a good idea to have a closer look and know the lay of the land. First off, as I've said before, these two lines are pretty routine pronouncements that you have to do with every program. And most programmers don't think about it very much. You know, it's like when you're in an airplane and the flight attendant says we're about to leave put all your seats in your upright position, put the tray tables back. turn your cellphones off. And most people just don't even pay much attention to those things anymore. It's worth noting the word main here, that means it's the main entry point into the program. It's worth noting the name of the program here, and all the other things are kind of noise for us right now. Let's focus on the important statement. Text like this. That's enclosed in quotation marks is called a string. That's just a technical term for the text. This statement here prints the string, in the exercise with Sarah you've seen that one can also print numbers. If you put a number or a mathematical expression inside the parentheses and that gets printed. System.out over here is technically called an object. As you'll see in the next lesson, objects are things that do work for us in a programming language. This particular object represents the terminal window, the window in which a string or a number is printed when println does its job. Finally, this part is called a method we'll talk much more about methods in the next lesson. For right now, just think of it as an instruction that's being executed. As you can tell from this part of the name, the instruction is to print something on the terminal window. What's with the ln back here? That says that it should also be prepared to make the next printout appear over here. So if we first print ln Hello World, and then we print three plus four plus five that printout will appear here on the next line. Without the ln it doesn't make the next printout appear on a new line. You'll practice working with both of these methods. With Sarah in just a minute. Welcome back.What should these two lines of code print? Make a guess and then try running this in bluejay or the Udacity IDE and then put your answer here They print 39. The cursor starts right here. And then, we print 3. But since it's just print and not print line, it doesn't go down to the next line. So then, the cursor is right here. And then, it takes the 4 plus 5. And since there aren't any quotes, it adds them together and gets 9 and prints right here. And then, since its print line our cursor would go down to the next line. But then, we don't print anymore, so we don't notice that. We can see that if we make a program. So, we add all these pieces that we need to make the computer happy, And then, we add our own code then we close it all up and run it, and it prints out 39. When you did your programming with Sarah, it's quite possible that some things went wrong and you got some nasty error messages. When you learn a new langauge, be it a human language or a programming language, errors are a fact of life. Let me show you some common errors so that you can recognize and fix them. Here's a typical error. Have a quick look and see if you can tell which part is wrong. That can't be right, the terminal window object was system.out not system.ouch. Let's see what happens if one makes such an error. You may want to work along with me here in Blue Jay. Open the errors project and open error 1. Here is the error. Let's compile and the compiler, the program that translate Java into lower-level code complains and says it has no idea what the variable ouch is. The compiler knows system.out, it doesn't know system.ouch. Such an error is called a compile time error because it's found when you compile. Some people call it a syntax error because there's something wrong with the syntax of this statement here. As you can imagine there are lots of syntax errors you could make. You might forget the semicolon. You might forget one of these quotation marks or both. You might forget one of these dots. Any time you do that the compiler will complain and you just fix that particular error and recompile. It happens to the best of us. Now here we have a different kind of error, again have a look and see if you can guess. The programmer misspelled world, let's see what happens in this case. When you compile, there's no error, the compiler doesn't know English. And it has no idea that this part has been misspelled. We can run the program and it runs. It just does the wrong thing. When a program compiles and runs but it produces the wrong output, then that's called a run time error. Some people call it a logic error because there's something wrong with the logic of the program not just it's syntax. Now have a look at this statement, it also has an error. What do you think will happen when you try to compile and run a program containing this statement? Do you think it doesn't even compile? Do you think that it compiles and runs but then it prints the wrong value? Like in this case. Or will it compile and run and then print an error message? Or will your keyboard melt into a puddle of plastic? If you have BlueJ open right now, just give it a quick try. Well, I hope your keyboard didn't melt. When I ran it, got an error message. Let me show you. The class compiled with no syntax erros. So I clearly don't have a compile time error. But when I run the program, down here, I get an error message. And Bluej tells me that something very bad happened in the highlighted line. First off, it is a run time error. It's an error that happened at run time. And it is so bad that it terminated my program and displayed what's called an exception report. And the report is that a division by zero was attempted. And that's of course very, very bad. you've seen how to deal with a number of different kinds of errors, and you'll get to practice that with Sarah right now. Let's make sure we understand these different kinds of errors. This line of code has an error in it. Is this error a compile-time or syntax error, or is it a run-time or logic error? It might not be easy to see what's going wrong. You can always try writing and running the code in BlueJ. This one's a compile time error. Let's see how this works in BlueJ. I'll make a program and I'll put this line into it. Now I compile it and it says, cannot find symbol, variable Hello. What do you think went wrong here? You can pause the video and try and think about it for a second if you want. How would you fix this error? The computer doesn't know what we mean by hello. And what we wanted was hello Sarah to be literal text. In order to do that we need the quatation marks. Let's see if it works now. Okay. Now there are no compile-time errors. Let's try running it. Oops. It spelled my name wrong. There's no h in my name. This would be considered a run-time error. This is a logic error, not a syntax error. Let's look at some more buggy code. What is the error in these two lines of code? Is this error a compile time error or a run time error? If you don't see the error immediatley, you can just try it out. This one's a run-time error, and it's pretty small. So it might have been hard to find. I can test it out in BlueJ. Into my program I'm going to write the lines. Then I'll compile it. It said no syntax errors. So right away we can see there aren't any compile time errors. And when I run it, I get my lucky number is 12. With no space right here. Since the program still compiles and the error occurs when we run the program this is a run-time or a logic error. How would you fix this one? You don't have to submit an answer, just good to think about. I think the most important thing to do when you encounter an error is to take a step back and breathe for a second. Usually it's some small inane thing, so I try to look back through whatever part seems to be compiling incorrectly or running incorrectly. And determining if I've, you know, misnamed a variable or done something really small or inane and usually it's that. If it's not then I like to proceed through the code line by line. And just sort of look at what every variable is assigned to, and what, what's happening in each line in the code. And usually by going step by step and slowly, I'll find the error pretty quickly. You've just learned how to write some very simple programs and how to correct errors and to deal with all sorts of fussy details. Let's step back a little bit and think about what a computer can do for us. A computer can execute an algorithm. That's a technical term for a recipe of instructions that are unambiguous, executable, and terminating. Well, those are big words. So let's see what's going on. Unambiugous means that the recipe can be interpreted in only one way. Executable means that its steps are those that a computer can actually carry out. And terminating, of course, means that they come to an end. That's all pretty abstract. Let's look at a concrete situation. You need to buy a car. You have two choices: this beauty over here, it's cheap, but it has terrible gas mileage, or this sleek one over here, expensive, but great mileage. Which is the better buy? I'll show you an algorithm that makes that decision. The first car costs $15,000. And the second car costs $30,000. So, it looks like we should buy the first car. But, not so fast. The first car gets 10 miles per gallon, and the second car 50 miles per gallon. So, what do you think? Which car should I buy? Do you think I should go for Car 1 or for Car 2? Or, in the end doesn't it really matter? Or maybe you don't have enough information to give an exact answer. Tell me what you think. Well, we don't have enough information to figure this out. If you drive a lot of miles, at some point, it must be better to get the more fuel-efficient car. So, let's say we figure we're going to drive 50,000 miles before we sell the car again or it falls apart. And, of course, it also matters how expensive gasoline is. If gasoline costs nothing, then the fuel efficiency doesn't matter, but we'll assume that gas costs $4 per gallon. Now, that's actually enough information for, to come up with the answer, but how will we decide? I will give you an algorithm, that a computer could actually execute, to settle this question. What you see here is an algorithm to answer our question. It's a sequence of steps. Each step is unambiguous, and so simple that a computer can execute it. The sequence of steps will terminate and give us an answer. Now, I want you to play the sequence of steps and execute the algorithm yourself. And when you're done, tell me what you computed for a total cost one and for total cost two. All right, here is how I did it. I go through the first step, miles driven is 50,000. The first miles per gallon is 10. So, that's 5000. The price per gallon is 4. 5000 times 4 is 20,000. Now moving on to the next step, the purchase price for the first car is 15,000 plus the 20,000. From over here, gets my total cost of 35000 over the life time of the car. With the second car, again we drive a 50000 miles. Now the miles per gallon is 50. 50000 over 50 is a 1000 times 4 because we have $4 per gallon, is 4,000 for the gas cost. The purchase price was 30,000, plus the gas cost 4,000 gets me to 34,000. Now let's go on with the algorithm, is total cost one less than total cost two? No it's not, 35,000 is bigger than 34,000. So the algorithm tells us to buy car two. Well, what a relief. I never wanted to buy that one in the first place. But now I have a procedure that is unambiguous, executable, and terminating that tells me what car to buy. So, this is a great example of an algorithm It is a recipe of steps each of which is so simple that a computer or a human can execute them and it reaches an answer. Now, you will notice that this algorithm here was written up in some mixture of plain English and Math not in Java code or not in any other computer language. This is called Pseudocode, and Pseudocode is really important. When you want to develop an algorithm before you get to coded up in Java or another programming language. What most programmers do when they need to solve a complex problem is they first get out a sheet of paper and describe the problem in Pseudocode and then they write in Java. Pseudocode doesn't have anyway near as many rules as Java does, but so it's a good idea to restrict oneself to simple constructs in Psuedocode. Let me show you what those would be. In your pseudocode, you may want to write a computation. Such as the total cost equals purchase price, plus the cost of gas. You might want to have a decision. If the total cost 1 is less than the total cost 2 to one thing, else to another thing. You might want to repeat certain steps. While the bank balance is less than your target, or repeat some actions say, ten times. Those are the three essential elements of pseudocode. Computations or other actions without any regard of the syntax of a particular programming language. When you're doing programming there are two things that you need to learn, that's syntax of the programming language and how to solve problems. And we'll do this in parallel on two tracks. In the next lesson, you'll learn quite a bit more about how to work with the programming language. But right now lets learn a little bit more about algorithms, pseudocode, and problem solving. You've just seen an algorithms that manipulated numbers to give you a useful answer. But I thought it would be more fun to show here a few example that don't have to do with numbers. So here is Robbie our home robot. A robot is a computer too, it carries out tasks and one has to program it to do the right thing. Right now Robbie's task is. To clean up a bunch of legos, Robbie needs to put all the blue legos before all the yellow legos. Here's our first attempt at an algorithm. It's a sequence of steps. Robbie will wave his magic wand and he will say, make it so. Well, that's not really going to work. An algorithm has to be executable. And not involve magic steps. Our pseudocode, here, asks Robbie to repeatedly execute these statements. Namely, why all the blocks are not yet in order. Each time, Robbie is supposed to scan the sequence of blocks. Find the first one that's yellow before blue one, and swap. So Robbie would go along starting at the left, until it finds the yellow one before blue one. Swap the two. And then it would do it again. In the next step, it would scan from the left until it finds the yellow one before blue one and swap them, and again. Now I'd like you to try this. If I write a b for blue and a y for yellow, tell me the sequence of the blocks after the next slot, and the next one after that. That may be Robbie. I'm looking for the first yellow, followed by blue, and swap them. That would be bby, byy. And again, the first yellow followed by blue, and swap them, and I'm at [BLANK_AUDIO] yyy and I'm done. Now, the sequence is in order, all the blue ones come before all the yellow ones. So, Robbie has used this algorithm here to clean up the Legos. Now, this is a great example, again, of an algorithm. You have a sequence of steps, each of them is unambiguous, each of them is something that Robbie can do. And eventually, the Legos are all cleaned up. It's actually not totally obvious why the Legos are always cleaned up when you execute the sequence of steps, but they are. Now, you've seen algorithms and pseudo code first with numbers, then with Lego blocks. And now, you get to practice the Lego blocks a little bit more with Sarah. Have fun. I think with pseudocode you always need examples. Here's some pseudocode. We'll have two items with prices 1 and 10 and we'll set the cost initially to 0. Tax is the item price times 0.08. The tip is the item price times 0.18. And I'll set the cost to whatever it was before plus the item price, the tax, and the tip. And print the cost. What should this print? And when might you use this process? This should print 13.86, and you might use this process when splitting up a bill for dinner with friends. In case you're not sure how I got 13.86, let's just go through this together. There are two items, and we initially set the cost to zero. So initially, cost is zero. And now for the first item, which is $1, we're going to say that the tax is $1 times 0.08, so 0.08. And the tip is $1 times 0.18. And now the cost is going to be updated to be zero. Plus the item price, plus the tax, plus the tip, which would give us about 1.26. Now, we're going to go through for the other item, which is $10. So this time, the tax will be 0.80. The tip will be 1.80. And the cost will be what it was before plus the item price, plus the tax, plus the tip. Which if you add it all up should give us 13.86. And if I did my math wrong, maybe that's just proof that I should be having a computer do this for me. I've found that with pseudocode it helps to have a couple examples. So let's look at this example. So we'll start with n is ten and then while n is greater than one, we'll print it and if n is even we'll say that n is n over two. Otherwise we'll say that n is 3 times n plus 1. What does this pseudocode print? Put your answer here. The pseudocode should print 10, then 5, 16, 8, 4, 2. We start out with n is 10. And then, check if n is still greater than 1, print n, which is 10. Then, if n is even, which it is, because it's 10. We update n to be half of n, and then we skip the stuff in the else. We come back here, n is still greater than 1. This time, it's 5, so we print n 5. And then if n is even, which it isn't, we would have done that. So we go to the else, and we update n to be 3 times 5 plus 1. So 15, 16. We come back up to the while and check again. And it's still greater than 1. 16, so we print 16, n is even. So we update n to be n over 2, so it's 8 now, skip the else. Check again. 8 is greater than 1, so we print 8. n is even, 8 is even, so n is 8 over 2, is 4. Skip the else, come back up. 4 is greater than 1, so we print 4. If n is even, it is. So, n becomes 4 over 2, so it's 2. Skip the else. 2 is greater than 1, so we print n. Print 2. n is even so we update it. n becomes 2 over 2, so it's 1. Skip the else. Now, n is no longer greater than 1. So we drop out of the bottom, and we're done. If this still looks a little foreign, that's okay. We're going to do more practice with pseudo code later. The algorithm you just looked at would work if Robby were a person. But Robbie is a robot, and only knows how to do very simple tasks. Moving to the first place where he sees a yellow before a blue is too complicated. He can only do simple tasks. So, he could move all the way to the left. Or, he could move all the way to the right. He could move one space to the left or one space to the right. He can check if the block right in front of you is yellow or blue. And he can check if the block, just to his right is yellow or blue. I'm going to have you write some pseudo code, but so that I can help you check it, I'm going to give you some of the structure up front. Use the pseudo code commands over here to write pseudo code to move Robbie to the leftmost yellow brick that's followed by a blue. These lines are scrambled. Can you type them into the right positions? You might need to type a line more than once. There might be a few possible answers here, but I'll talk about the one I came up with. If you came up with a different one, that might be right, I'd like to see it. We'll start by moving all the way left. And then, while we haven't found what we're looking for, if the piece you're looking at is blue, you'll need to keep looking. Move one space right. Else, if the piece to the right is blue, you should stop, because you found it. Else, if the piece to the right is yellow, move a space right. I think it's a good way to start by moving all the way left because that means the first time we find a yellow followed by a blue, that'll be the left most one. Now, as long as we haven't found it, we're going to keep looking. While we're looking, if the piece you're looking at is blue, like right here, that means that we haven't found what we're looking for yet, and we should move one space right. Otherwise, that means the piece that you're looking at is yellow. And if the one to the right of it is blue, so if we were right here, we're looking at a yellow, the one to the right is blue. You would stop, because you've found it. But if you're looking at a yellow and the piece to the right is also yellow, we haven't found what we're looking for and we need to keep moving. So, in that case we still move a space right. So, the way this would work on this input is we would start all the way to the left and we haven't found it yet. So, we would look at the piece, it's blue. So, we move right. We still haven't found it, so we look at this piece, it's blue. So, we move right. We still haven't found it. So, we look at this piece, it's blue, so we move right. We look at this piece. It's not blue. So, we check what the piece to the right is. The piece to the right is not blue. So, we check if the piece to the right is yellow, which it is, then we move a space right. Okay. Now, we need to check again. If the piece you're looking at is blue, nope. Else, if the piece to the right is blue. Yep. You want to stop because you found it. So, it looks like it works on this input. Sometimes a set of instructions is not an algorithm. This is a slight modification of the algorithm that Kai gave you before. Why is this not an algorithm? Is it because the description is ambiguous? The description contains steps that cannot be executed? Or the procedure does not always terminate? If you'd like a hint, think about what happens if you apply this algorithm to this pattern. This isn't an algorithm because the procedure doesn't always terminate. Let's try running it on the example I gave. Initially, it's not an order. So, Robby would locate the first two bricks that don't match and swap them. Now, they're still not in order. So again, Robbie would find the first pair of blocks that doesn't match. And swap them. We're now back exactly where we started. If Robbie keeps doing the same thing, again and again, he'll always end up right back where he started. The bricks will never end up in order. So this is not an algorithm. Robbie's batteries will run out before this algorithm finishes, or all the batteries and generators in the world would run out before this process finishes. He will never finish. How about this one? Is this an algorithm? If so what does it do? You'll need a little bit more detail. This is a two by eight block and this is a two by two block. And I can stick blocks together like this. Is this an algorithm? Yes or no? If not, why not? If so, what does it make? An L, an H, a doorway or something else? This is an algorithm, although this is maybe up for debate. And when it works, it makes a doorway. You might have felt like my instructions were ambiguous. I'm going to pretend they were perfect, though. If you can write clearer instructions, post them on the forum. I'd like to read them. And now, I'm going to do my best impersonation of a robot and follow this algorithm. So, first I'm going to place an 8 by 2 block horizontally. I'll do it this way, so you can see what I'm doing. And I'm going to stick a 2 by 2 block on the top of the left end of the 8 by 2 block, so right here. Now, 3 times, I'm going to stick a 2 by 2 block on top of the previous block. So, this was the previous block, one, two three. And now, I'm going to stick a two by two block on top of the right end of the 8 by 2 block. And I'll repeat three times, putting a 2 by 2 block on top of the previous block. And now, I put an 8 by 2 block on the highest two. And we have a doorway. I think the most important realization that I had when I got into computer science. Or the best advice that I got, was just somebody telling me, you're not bad at it. And by it, I mean programming. It's really hard because programming is a completely new way of thinking. It's like learning a language. And, it's really easy to struggle and people always seem like they know what they're doing. because some people have been programming since they were like three in the basement with their little like calculators and stuff. And I wasn't one of those people. And so, it took me a long time to just sort of realize that I could do it just as well as anybody else. And just sticking to it is the best thing that you can do. And there's so much help out there between, you know, online courses. just sort of forums on the internet or your friends, anything. And just being vulnerable and asking for help is the way that I've gotten through it. Congratulations. You've made it to the end of lesson one. Believe it or not, you've learned a lot already. You've learned about the tools that you use to write programs, and you've written your first program. You've also learned how to structure your thoughts. So you can write pseudocode and algorithms that a computer can understand. You now speak the basics of the secret language. In the next lesson you'll learn how to write interesting programs with pictures, text and dates. Not those kinds of dates. We look forward to seeing you there. Programming with objects is the predominant way of developing software today. Code is organized into pieces called objects. You can use objects written by other people to create your own programs. That way, you get to stand on the shoulders of giants instead of having to start from scratch every time. In this lesson, you'll look at lots of different examples of objects. You'll learn what they can do and how to make them do it. At the end of this lesson, you'll be able to write a program that draws a rocket, flying from earth to mars. I think you'll be impressed with what you'll able to do. I'm really excited of what you're going to learn this lesson. Let's get started. My name is Ellora. I am a junior in computer science at Stanford University. I grew up in the bay area, but actually despite that fact, didn't really intend to study computer science. I entered Stanford three years ago as a Psychology major. And took a computer science class because my friends took them and liked them. And I figured I had to take an engineering class anyway, so why not. Object-oriented programming is one of those things where, there's just so many reasons to use it that I can't think of a reason not to use it. I think, first of all, so much of the programming that is done in industry today uses objects and object-oriented programming. And you almost cannot be in industry without knowing what these things are. The second reason is that object-oriented programming really falls in line with the way you and I think. So, you and I think of a person as an object having a height and a weight and an eye color. And, all sorts of attributes. And that's exactly how object-oriented programming works. It works the way we think. Which is why it's great to know how to use it, because it'll make your job as a programmer a lot easier. Hello and welcome to lesson Two of the programming in Java Course. We're going to start a discussion with objects to understand why you might want to know about objects. consider someone that is building a house. It used to be in the olden days that a house was built from nothing but bricks and wood. Nowadays, of course, a builder takes prefabricated components such as this furnace or this water heater and puts them together. You can think of those as the analogue of what an object would be in a programming language. An object is a building block of a program. It is a component with some desired functionality. Just as the water heater over here has some desired functionality for the builder it heats water. In your programs you ask objects to do work. You don't know how they do that and that's okay. Just like if you really think about it do you actually know how a water heater does it's job? Or for that matter, do you care? Here we have a different kind of water heater, a solar water heater and it doesn't really matter how a water heater works as long as it heats water. With an object what's important what it does, not how it does it. That's all very abstract, and, the way one really learns about objects, is to play with them. And I'll show you how you can play with some in BlueJ. Here we hear from BlueJ. And it would really good idea if you fire up your own BlueJ and move to lesson two days as your project. When you open it, you will see the screen with a Day block here. And this is what gives us objects. Let me show you how to make an object. You right-click on it, and you select the line that says New Day. You can now give it a name. For right now, we'll accept the default. Down here, you'll find your first object. This is how BlueJ represents objects. As little blobs, it's a little-known fact that all objects are red. And to manipulate an object, you again, right-click on it. You can ask it to get the current year. Here's the answer. This particular day is somewhere in 2013. See when, the month is March, 3, the day of the month, is the 20th. That's the day that I recorded this lesson. We can make another day object. And now, let's pick, the first line here. Now, we ask which year month and day we might actually want. Let's fill in something. Then, we'll pick a year of 1964. The month of 11 or November, and the day of 28, as I'm sure everyone remembers, on November 28th, 1964, the first spaceship was, to Mars, was launched. Now here, we have another day object. It looks just like the first one. It has a different name. But if we wanted to find out anything about it, so we can in the same way ask it what's your year, and here it tells us. Now, let's do something more interesting. Let's take our first object here and let's ask it what day comes a hundred days later. Now, it doesn't look like it, but this object now has changed. It has moved itself a hundred days later. Remember, it was originally March 20th. Now, when we ask it what's your month, you'll see it's June. That makes sense, from March, 100 days is June, or maybe it would be July. Somehow, this thing knows how to do this computation. How about the day? It's June 28th. I wouldn't have known how to do that. Except by tediously getting out a calendar and counting the days, but our day object knows. How does it know? I don't know, and I don't care. It doesn't matter. I can use it, as long as I understand what it does for me. So, that's a great example of an object. Something that knows how to do a very specific thing, namely to deal with calendars, just like the water heater knows how to do very specific thing, namely to heat water. Thanks Kyle. Let's use the day object to do another calculation. If you haven't already booted up BlueJ, you should do it now and open up the days project. Mariner4 launched November 28, 1964. It took 228 days to arrive on Mars. What was its arrival date? Before you do this, I want to show you one more thing that you can do with objects. I've opened up the days project in BlueJ. I can make a day object and now I can quickly see exactly the day that's in here using the two string method. I won't actually do it, because I want you to be able to do this yourself. And try it. But that should make it much quicker. So here are some hints. Use a day object to do the calculation And use the toString method to read the day. Make sure that when you write the arrival date, you use the same format that the toString method uses. And don't worry too much if you don't have BlueJ working yet. You can just skip to the answer video and watch it carefully. There will be more examples you can do soon. The answer is 1965- 7-14. Here's how we would calculate this using Java Objects. We would create a Day object and specify the year, month and day as November 28th, 1964. If we use the two string method. Shows us what's in this Day object right now, which is exactly what we entered. November 18th, 1964. And then we can add days. That's the flight time. And now, this object has July 14th, 1965. So that's the arrival date. As a side note, this format is an international standard called ISO 8601. It was chosen for good computer science reasons. There needed to be a standard form used by all the different countries so that data stored in computers could be transferred across borders. They put the year first so that when you sort a date sort of alphabetically or lexicographically, don't have to know that word, it's okay. The dates will show up in chronological order. The next concept that you need to understand is the concept of classes. Look at these dates. Here we have a date, the date of the Mariner 4 spacecraft launch, another date that happens to be the inauguration of FD Roosevelt. And a third date, the date of the first lunar landing. Now, all of these objects have something in common. They all day objects. In Java, objects that have common behavior are collected into classes. So the day class is the class that contains all of the day objects. And the reason you want to know about this is when you want to find out something about how days work. You will want to look at the documentation of the day class. It tells you what everyday object it is. Let me give you another example of a class. Here is a string object, and another, and another. All these string objects have something in common. They all have the same behavior. And in Java, the String class defines what their common behavior is. You will learn a lot more about the String class in this lesson. Let's go back to our day class for a minute, and think a bit more what it means for objects to have common behavior. It means that they can all do the same kinds of things. Like what can they do? As you've seen when you played with days and BlueJ, any day object lets you get the month, get the year or add days to itself. These actions are called the Methods of the Day class. They are the kinds of things that you can apply to day objects to achieve some kind of functionality. The word method, sounds a bit strange at first, and you should just think of it as terminology. It's just where one calls the actions that you can apply to any of the day objects. Thanks Kai/g. Let's do an exercise where we match the methods with their classes. Don't worry if you're not sure how to do this yet. I haven't actually given you enough information, just go with your gut. Here's the first one. BirthDay.getmonth. Here, the method is getmonth. "Hello world!".length, here length is the method. Anniversary.addDays, here the method is addDays. And lolcatsPic.draw, here the method is draw. Enter the letter for the class, in the box next to the method call. Let's start with the ones that we already know. We've seen the getMonth method before, it's part of the day class. Looks like addDays is also part of that day class we've been using. This length method you maybe haven't seen yet, but I can look in front of it and I can see hello world, which I know is a string. And down here, I've got something called lolcatsPic. And it's drawing, which sounds sort of like methods which should go with a picture. To really understand objects and classes, it's best to work with lots of examples. Let's try another example. And again, it's a great idea if you can do this together with me. In BlueJ navigate to the pictures project in lesson two and you will see here an icon representing a picture class. Let's make an object of that class. Again, I will accept the default name, and here is my object. What can I do with it? Well you know how to find that out. You right click on the object and you get a list of things that tell you the methods. Let's pick a method and in fact we will pick the method called pick. This particular method opens up this file chooser here. That lists whatever image files happen to be available. You can also navigate to other folders but we'll just pick one here. Once you pick a file, a window pops up that shows the image. Now let's see what else we can do. Let's call the pixels method. And it tells me that this particular image has 104,976 pixels. Okay, that's potentially interesting. over here we have method called translate. Let's just play with it to see what it does. It wants two numbers. I will just put in 100 and 200, click on OK. And now look carefully at the planet. as you see, it moved. So the method is not called translate because it doesn't translate this into Lithuanian. Translation is a mathematical way of saying moving and it moved it by 100 pixels in this direction and 200 pixels in that direction. So this is another great example of an object. The object can do certain things. The methods tell you what it can do. In the next exercise you get to play with objects of the picture class. Thanks, Kai/g. It looks like the picture class has some other methods. In BlueJ, I'm going to create a picture object as we've been doing. And I'm going to fill it with a picture of Jonathan, and here's my picture of Jonathan. I'm going to translate it a little. Translate, and 100. Jonathan can't wait to grow up. Are there any methods in the picture class that we could use to help him out? Let's see. Which of these methods might help him grow up? What about the grow method? If I enter 50 and 50 and then hit OK, what will happen? Does Jonathan grow 50 pixels wider and 50 pixels taller? Does Jonathan grow 50% bigger? Does Jonathan grow 50 pixels on each side? Or does Jonathan grow 50 years older? The answer is Jonathan grows 50 pixels on each side. Let's see how I figured that out. We're back where we left off in BlueJ. I'm calling the grill method on the picture of Jonathan and passing 50 and 50, but I'm going to cancel that for a moment. Out of curiosity, what is the current width of this picture? Get width. It looks like it's 185. So now, if I call the grow method, like I was going to do before, Jonathan just got bigger. But how much exactly? It's hard to tell whether he grew 50% bigger or 50 pixels on each side bigger? Or, just 50 pixels wider and 50 pixels taller. So, let's check the width again. Get width, and now it's 285. So, it looks like the width grew by 100 pixels. If it were going to grow by 50%, it would probably have grown by about 190 pixels. So, it sounds to me like it grew 50 pixels this way and 50 pixels this way, and then did the same up and down. Playing with picture objects in BlueJ is kind of fun. Let me make a couple of picture objects. If you look carefully how I constructed the last object, I filled in the name of the file here. And I'll do it one more time like that. If you do it in this way, you also have to tell the program to draw the objects by selecting the draw method. The first picture appears, and a second picture appears. That looks kind of horrible. Let's have a closer look on how we can make this look nicer. First of all, let's move the rocket a little bit, and let's make the red planet a bit smaller. Well, that's much nicer. But it's a bit tedious to do this with your hands and with clicking and clicking, that's where programming comes in. Here I've written a program that does the same actions, that you've just seen me do by clicking in a java program, a step at a time. We'll understand all of the details pretty soon, but let me show you the basic lay of the land. We're making a picture out of the mariner4 image, we're translating it, we're drawing it, we're making another picture object, we're shrinking it and we're drawing it, and that composes the picture. Now when you operate in this way, you make an object and then you later need to do something to that object. And it's, it's in a program here, it's not in the BlueJ work bench. And then it becomes very important to give names to each of the pictures. You'll notice I call this one rocket. I call this one planet. Those names are names of variables, and that what we're want to discuss next. Use a variable to store value that you need later. Every variable has a name. Here's how I like to think about variables. A parking space is a great example of a variable. That's where you can store a value here, the car, so that it's there when you need it later. This particular variable has the name JO53. We want to remember that name. And you need that name if you want to find your car later. Now, look at this variable. That's a real Java variable. It also has a name. And when you later want to use use the object. That when you use the name again. So the name is one of the important aspects of declaring a variable. Let's practice reading variable declarations. What is the variable name in this variable declaration? Picture rocket equals new Picture mariner4.jpg. Is the name picture, rocket, new, or mariner4? The answer is rocket. If I we want to use this variable again, we're going to use the rocket name. In Java, a variable can't just hold objects of any type, but one has to specify the type that it can hold. In this parking space analogy, look at this variable here. This particular one holds bicycles and we say that's the type of this variable. Now, look at this variable here. There's the name. And in Java, we write the type before the name. First the type, then the name. String is the type, greeting is the name. String greeting. Now that you've seen where we write the type in a variable declaration, can you find the type in this one? Picture rocket is a new picture, mariner4.jpg. Is the type picture? Rocket? New? Or, mariner4? The type here is Picture. The variable name is rocket. We have the methods associated with the picture class. We know that rocket isn't the type, because we already said that rocket is the variable name. New, we haven't seen yet but we'll come back to this and mariner4 is just the name of the picture we are loading. It's not actually the type of object. When you declare a variable, it's important that you give it an initial value. Look at this variable. It's name is rocketSpeed. It's type is called double. And I'll talk about what double means in just a minute. What I want to show you first is over here, the last part of the variable declaration. And that's the initial value. And it really is important that you always supply an initial value when you declare a variable. Because if you forget, and later use the rocketSpeed variable, that would be an error. Every variable that you used must really have a value. The best time to set the value is right when you declare it. Now, back to the curious type double. That means it's a number that can have a decimal point, such as here, 24,724.573. So, when you see the word double, you should simply think a number with a decimal point. And ignore the curious name. Now, look at this variable declaration. The name is sallyRidesBirthday, the type is the Day class, and the initial value looks like this. You will see soon exactly what this syntax means, but when you look at it, it seems intuitively clear, we make a new Day object with a date 1951, May 26. Here's another variable declaration. It's a little bit different from the ones you've just seen. This variable has type int. Int stands for integer. You can use a variable with this type to save positive and negative numbers without fractional parts. Now that you know what int means, take another look at this variable declaration. What is the initial value of the variable in this variable declaration? Is it int, mannedMoonLandings, 6, or there isn't one? The answer is 6. Int is the type, mannedMoonLandings was the variable name, and 6 is the value that we're initially assigning to mannedMoonLandings. There's one more useful aspect about declaring variables, namely comments. Have a look at this variable declaration, we have a travelTime of 228 days. When you read it you probably ask yourself, for which trip? Now I can tell you for which trip, but when you write code it's very common that you look at your code months or years later, or someone else looks at the code. And then they would really like to know more of an explanation. In Java, we use comments to give such an explanation. Notice, these 2 slashes, they are the comment marker. Anything that's after the slashes is ignored by the compiler. It's just there for humans. To understand the code. You can write anything at all after the comment marks, and the compiler won't care. But o course, if you write nonsense like this, the humans who read your code may hate you. Comments are for humans. Use a comment whenever you need to explain something that might be difficult to understand for the human reader. Let's do another calculation with the Day object. Astronaut Sally Ride was born on May 26th, 1951. She died on July 23rd, 2012. How many days was she alive? You should put your answer in this box. You should use BlueJ for this. Open up the Days2 project, and here are a couple of hints. You'll want to make variables for birthday and lastDay. And then you'll want to call lastDay.daysFrom(birthday) and print the result. Don't worry too much if BlueJ isn't working for you. Just look around the video, and you'll find a link to the Udacity Java editor that you can use. The answer is 22,339 days. The way that we would figure this out, is that we would open up Bluejay, and we would go into this days alive printer, and start editing it. And the main method right here, we would first create a variable birthday. Initialize to Sally Ride's Birthday, and another variable, Last Day, initialized to Sally Ride's Last Day. Then we do the calculation and put that in another variable. Here you can see that the daysAlive is an int. And then we print out the result. Which is in daysAlive. I compiled, and I got no syntax errors, so let's try running this thing. I go to the daysAlive printer, run the main method, and I get my answer, 22,281. That doesn't match what I got before, one second. Looks like there was a bug. This shouldn't be May 26th, it should be July 23rd. Let's compile this again. Close it. Try running our main method again. And this time we got the answer I expected, 22,339. So I got this program to work, but I send this program to my friend, she's going to be a little bit confused. She won't know what it does. Let's look at the program again. There's nothing in here that says that the point of this program is to calculate the number of days that Sally Ride lived. So why don't you go back, write some comments for your code, and then I'll show you the comments that I might have written. So, I want to indicate what the overall purpose of the program was. So, right at the top, I'm going ti add a comment that says calculate the number of days that Sally Ride lived. Now, I'm going to look at my variables. Seems like in the context of Sally Ride having lived, the birthday is pretty obviously Sally Ride's birthday. And the last day is probably Sally Ride's last day. Days alive would be Sally rides days alive. Seems like that explains most of the lines of this program. You've now seen a lot of variable declarations. I've seen a lot in my life. I've written a lot in my life. Here's a bunch more. Some of these have mistakes in them. Can you match each variable declaration to a description of the mistake? The possible mistakes are, the variables can only contain letters and numbers. B, it's always a good idea to include an initial value. Variable type doesn't match initial value type. Variable has a bad type. No mistake, this variable declaration is fine. Variable declarations need a semicolon. And variable declarations must have types. Let's look at the first one. This variable declaration says var x equals 13. Well, var isn't a type that we've seen yet. So it looks like the answer is D. The variable has a bad type. Let's look at the next one. Int X equals in quotation marks 13. Well, int usually takes a number. And 13 is actually a string. So it looks like these don't match. So the answer is c. The variable type doesn't match the initial value type. The next one, double x equals 13.0. Well, we're missing the semicolon. That was an option. Looks like F. Int lucky number equals 13. That one's a little bit trickier, but it looks like there's a space in what we meant to be our variable name, lucky number. We can't have spaces in variable names. they can only contain letters and numbers, so that would be a, x equals 13. Well, we don't know if this is right or not because we don't know if x is actually an int. The answer is g, variable declarations must have types. Int x, we haven't given any initial value. It's always a good idea to include an initial value. Int lucky number equals 13. This one looks good to me, so there is no mistake. Variables are called variables because they can vary. Here's a variable. It's initial value is 228, but I can vary that if the need arises. Maybe the trip took longer than I thought. Here I'm setting the variable to a different value. Note that. The declaration looks almost the same as the assignment, where I assign a new value to an existing variable. The only way you can tell them apart is that the assignment has no type. The declaration has the type in here. The assignment looks just like a declaration except there's no type. That tips us off that traveltime is an existing variable, whereas over here where we say int traveltime, it is a new variable. One way of thinking about a variable is as a little box with a name. Of course, the value is inside the box, and it can vary. As a result, of such an assignment. Now we've assigned a new value, to the variable, and the new value is stored, in the little box. We've covered a lot of ground in the last few units. You've learned how to declare variables, and I want to come back to the question, what do you do with a variable once you've declared it. Here we have a variable, planet. It's of type picture, and it's somehow initialized. Now I want to use the variable. I want to call a method on it. What methods can I call? And when I pick a method, what values should I give it? That's what the Public Interface of the Class tells us. It tells me, which methods I can use and what values I should supply. Let me give you an analogy. The public interface of a car is all of the buttons and gizmos that you see here on the dashboard. A while ago, I was driving along in this rental car I could not figure out how to turn on the dome light, so I had to pull out the owners manual. The public interface of the class is also described in a kind of owners manual, called javadoc. That's the owners manual of a class or of a set of classes, let's have a look at javadoc. The classes, that, come with this course, such as the Picture class here, all have an owner's manual. Here is how you can find it. Select the Tools menu, Project Documentation. And a browser window will pop up. Here it is. As you can see, we have the documentation of the Picture class. As you scroll through it, you will find a method summary. For example, here's the grow method and you can see it says resizes this picture both horizontally and vertically. When you click on the link, a detailed explanation pops up. And here it explains that you need to feed two numbers that are called dw and dh. And they're further described down here. The first number is the amount by which to re size the width on each side. and the other the amount by which to re size the height on each side. That's how it works for the classes that we give you. If you use a standard library class such as the String class, you instead want to look at the official documentation. I've made a bookmark for it and I suggest you do the same. Here it is. On the left, you have a listing of all of the various classes. They're many of them, most of which you never need to know. Let's find the String class. Here it is. Click on it. On the right, the documentation for the String class is displayed and again, you can scroll through it. You will find a summary of all of the methods. There are many methods, most of which you don't need to know, and when there's one that interests you, you can click on it and get a detailed explanation. You will have lots of practice with that during this lesson. First off, let's look at a typical method call. As you know, all the way on the left is the object, on which the method is called. Next comes the name of the method. And the values, that we supply to the method, are called the arguments. That's just a technical term. This particular method call is called with the arguments 20 and 0. Let's have a look at another method call, again here is the object, the method name. This particular method call has no arguments, there's just nothing between the two parenthesis. But this method call returns an answer, it returns the number of pixels in the picture. That answer, or as we say, that return value, is then stored in the variable that you see on the left. What about the method call up here? This method call has no return value, it simply, carries out an action, namely to grow the picture. Now, that we know about arguments and return values, let's look at this method call. Recall the days from method, and then store the return value in a variable. What is the argument? What is the type of the return value? The argument is birthday, and the return value is int. The argument goes in the parentheses and is used in the days from method. The return value of the days from method is then put into the variable daysOld. daysOld holds int, so the return value must be an int. Let's have a closer look at how methods are described in javadoc. Here is an example. Before the parenthesis you have the name of the method, in this case pixels. Before the name, you have the type of the return value. In this case, that's int because the pixels method returns the number of pixels in an image as an integer since you can't have half a pixel. Let's look at another example, the grow method. Again, the name is before the parentheses and before that is the return type but in this case, remember the grow method doesn't return anything and we use this special word void to denote that. Void means that nothing is returned. Now this method call has another feature. It describes what kind of arguments to pass. You call this method with two arguments and here you find the types you can grow by any decimal number. It doesn't have to be an integer. Now actually and that's a minor detail, that you don't really need to think about until the next lesson. What you see inside here, the double dw and the double dh are themselves variable declarations. They declare two variables that are called the parameter variables. Like I said, right now you don't yet have to worry about the parameter variables but when you see the word parameters in javadoc, then you'll know where that comes from. Now you know all the technical terms that you need to decipher a javadoc documentation. I found these Method Descriptions in the javadoc. How many parameters does length have? What is the type of the return value. It has zero parameters, there's nothing in the parentheses. The return type is int, we can see it here. How about replace? How many parameters does it have, and what are their types? What is the type of the return value? This last one, print line, isn't from the stream class, it's from the print stream class. How many parameters does it have, what's their type? How many return values does it have? Replace takes two parameters. The first one is target and the second one is placement. Their types are both string. The type of the return value is before the method right here, and it's also string. Print line takes one parameter. The type of that parmaeter is string, and it doesn't have any return values. The type is void. Let's have a closer look at constructing objects. This time we'll use a different class. The class called rectangle. In BlueJ I right-click on the class in order to construct objects. Now look closely here. Up here I have two lines that start with the keyword new. Followed by the name of the class. The keyword new is an instruction to make a new object of the class that's written after new. Inside the parenthesis, we put the construction arguments. Now notice that the're actually two of these. Two so called constructors. The first one wants four construction arguments. The second one doesn't want any. Let's use the first one. Here we see the construction arguments described as x, y, width and the height. I'm filling in some values, five, ten, 60 and 90 and when I click OK, the familiar object icon appears. Now as always in BlueJ, I can right click on the object icon to find out what methods there are. For example, the get width method gives me the width and that's the 60 that I just supplied. You might be a little disappointed that the rectangle is not displayed but to display, simply call it straw method. Right-click Draw and here it is in a little window. Let's look at the second constructor, the one with no argument. When I select it, I don't need to supply any argument values and the object is constructed. What rectangle might it be? I can draw it. But nothing seems to show up. Let's investigate. it has width zero. And height zero, not a very useful rectangle but of course I can always grow it. And there it is. At any rate you have now seen that the rectangle class has two ways of constructing objects. One constructure take four arguments, the other none. Let's have a look at it's Javadoc. Because this project has multiple classes, I have to select the one that I want. And now, I can scroll through in the usual way and see the methods of the rectangle class. But I want to go a little bit above that and here you see a summary of the constructors. There are two constructors, the first one takes no arguments and constructs an empty rectangle. The second one takes four arguments. And I can click on it, and I get the detailed description of what each of the arguments are. To construct objects in a Java program, you also use the new syntax. Let's have a look. Over here, you see a variable whose name is box, whose type is rectangle. And the keyword new tells us to make a new rectangle with these values for the construction. Now you know all the details about construcitng objects. Now that you've worked with constructors a little bit, let's do an example of constructing some rectangles. We want to initialize the variables box, and box2, with two rectangles of equal dimensions that touch each other at a corner. I'm going to give you a few more specifications. I want box to have a width of 20 and a height of 30. I want box's top left pixel to be at x is 60, and y is 90. And if this is the frist box, I want box2 to touch it at this bottom right corner. Boot up BlueJ and try this for yourself. Then paste the code for the two boxes into the editor that we give you. Don't worry if too much if BlueJ isn't working, you can just the Audacity editor we're providing. And here's a quick hint, if you find that your boxes aren't showing up, it might be because you have to remember to call the draw method. Before I write any code, I'm going to figure out all of the dimensions and specifications of my rectangles. Box will match the specifications given. So, it'll be at 60, 90 and have a width of 20 and a height of 30. The question asks for the dimensions of both boxes to be the same. So this one will also be 20 wide and 30 tall. I need to figure out where this upper left corner is. It looks like it's 20 to the right from 60, so that should be at 80. And it's also 30 down from 90, so that should 120. Now, I have all of the specifications, and I need to put them into the constructor calls. So, in the BlueJ project, I'll edit the code for rectangle demo. Open editor. And then the main method, I'm going to create two rectangles: Box and Box Two. And then once I've created them, I'm going to draw them. We'll make box a new rectangle. Now, this constructor needs to take an x, a y, a width and a height. X we know is 60, y is 90, the width is 20 and the height is 30. Now for box two, x is 80, y is 120, the width is 20 and the height is 30. So if I stretch this out, it should look like this. Let's compile, and now I'll run my method. And it drew my rectangles, just as I asked for. The best way to become familiar with objects is to use lots of them. Here, we will look at strings and we will do it in three ways. With BlueJ objects, with Java code, and with another nifty tool called the code pad. In the code pad, as you'll see in a minute, I can type in code and have it executed right away without having to compile anything, or without having to click on the bubbles. The code pad is so nifty that it's a shame that it's hidden, to reveal it, select View and Show Code Pad. And then they make it so small, which is also a shame. Let's make it much, much bigger. In the code pad I can write regular Java statements. Here I declare a variable, here I have a print statement. And as soon as I hit the Enter key, it gets executed. You see a window pops up that has the output. But what's even better, any value that I type in here gets displayed right away. Let me show you. I type river.length, and the answer 11 is displayed as soon as I hit the Enter key. It's important that you don't type a semi-colon because otherwise the code pad thinks that you have a statement like up here. No semicolon tells it that it should immediately print the value of the code that you write. Here I type the name of the variable without a semicolon, and it's printed the string Mississippi. And to the left, I have a little blob that I can drag into the workbench. Here it goes. I drop it into the workbench. Now I'm supposed to give it a name. I'll give it the same name, that the variable has river. And over here I have a familiar BlueJ blob. That I can manipulate in the usual way. I can right click on it, and now the string class has many, many methods, but I want to call length. When I select the length method I get the answer 11. So I can get the same answer in two different ways. Which one is better? It really depends. Sometimes I prefer to use the BlueJ bubbles for quick experimentation, because you can't really make any typos. Sometimes I prefer to use the code pad. Because it's just easier to type in, maybe to copy and paste in, what you want. Both of those are great for experimenting with classes and objects, and to just find out what happens when you call a particular method. You should try them both and see which one you like better. Of course for more hardcore programming. For writing a program that gets repeated over and over again, one wants to write an actual Java class with a main method. In that case, as you know, you right click on the empty space, make a new class, right click, open the editor. And start typing. Then you put your code into the main method. Here I wrote a couple of lines of code that let me compute the length of this string. You compile. You run. And you get the answer. That's more work at first, and it'll pay off when you write a longer program. For short explorations, the object bubbles and the code pad are hard to beat. So go ahead. Fire up BlueJ and work along with Sara to explore the string class and its methods. Let's look at a few more methods from the string class. This is your chance to try reading some Java doc. If we have a variable river that contains this, what method call would replace all of the i's with x's? Write the method call here. What is the return value? You should put it here. Here's some hint. Look for a link on this page to the javadoc for the replace method. Verify your answer using bluej. And here's an example of a method call, birthday.getMonth. The method would look like river.replace and the first argument would be i and the second one would be x, the return value would be Mxssxssxppx. Let's look at the javadoc to see why. To find the javadoc for the string class we'll search, and I'm just doing this in Google. So, I'm in the documentation for the string class. You want to scroll down and look for the Method Summaries. Under the method summaries, there are a couple of different options for replace. Let's look at this one. It has a detailed description here, it takes a target and replacement. The target is the things that we want to replace, and the replacement is what we should replace them with. So in our case, the target would be i in quotation marks, and the replacement would be x in quotation marks. We can demo how this works in BlueJ. On the river string, I call replace and I replace i with x. [SOUND], and we got what we expected. The Trim method is another useful method from the string class. What if we have a String messyString that looks like this, and then we run messystring.trim? What's the return value of messystring.trim? You should go to the API documentation and read it and try to answer, using that. The answer is about the same as what we started with, except that it's missing the space at the beginning and at the end. And if I actually run the method in blueJ, you can see it right here. Let's look at the documentation. Again, I'm in the string documentation and I'm going to look for the Trim method. It says it returns a copy of the string with leading and trailing white space omitted. This part here is just explaining what we mean by white space, exactly. The white space is usually things that you can't see easily, like a tab or a space. Let's do one more of these. Manipulating strings is actually something that you'll be doing a lot. What are the return values of these method calls? Remember, our string river has Mississippi. river.toUpperCase(), river.toLowerCase(), and river.toUpperCase().toLowerCase. As a bonus, what's the value of river after all these calls? River to upper case returns MISSISSIPPI in all caps. River to lower case returns mississippi in all lower case. And river to upper case to lower case returns mississippi, also in all lower case. Because it does the first method call first, and then it does the second method call on the returned value for the first method call. After all these calls, river still contains Mississippi. It doesn't change. None of these methods changed the original string. In the last exercise that you did with Sarah, something remarkable happened. Here we have a string we call toUpperCase. And then, we look at what's in the variable on which we just invoked the method. And we notice that it does not contain the upper case version. So, calling this method did not modify or as we say, mutate the object. We say that toUpperCase is an accessor method, it leaves the object on which it is called unchanged. Instead, it returns a value and that value is then stored in this variable. The uppercased string is here, the original string is still here. Contrast that with that method call. Here we have a picture and we call the translate method on it. When the method is called, the picture changes. It is moved to a different location. We say the object has been mutated. It is now different than what it was before. And we call the translate method a mutator. So again, an accessor leaves the object on which it operates unchanged, and mutator changes or mutates the object. Thinking about whether a method is an accessor or a mutator is really helpful when you're trying to decide what a sequence of statements prints. So, let's take this sequence of statements for example. We make a string greeting and fill it with hello. We print out greeting and call replace with arguments h and j. Looks like I forgot a parantheses at the end. And then, we print greeting again. What does this sequence of statements print? Is replace and accessor or a mutator? The answer is, it print jello on one line, and then hello on the next line. On the second line, when we just print out greeting, we can see that it hasn't changed from the original. We say that it didn't mutate. Instead of modifying the original string, the replace method returns a new one. This would be like if you had a mean cat and you told your cat to be nicer. And instead of becoming nicer, it just gave you a new, nicer cat. That's why we call replace an accessor method, not a mutator. We'll try another example. How about this sequence of statements? I've now opened up the rectangles project. What does this sequence of statements print? Is translate an accessor or a mutator?. Let's see what actually got printed. Here's our terminal, and we can see the first number, which was the original X value, is 5. The original width is 60, the next X value is 30, and the next width is 60. Since the X value changed from 5 to 30. We know that translate is a mutator. Sometimes mutators are useful. But they can be tricky to think about. For example, what does this sequence of statements make? First, we create a variable box of type Rectangle, and put a Rectangle in it. Then, we create another variable of the same type, but I want it to be the same. So, I'm just going to use box. Now, I actually realize I need to get the original box out of the way. So, I'm just going to translate it. So, this would look something like, we would create a rectangle. And then, we create another rectangle that's the same. Then, we translate it out of the way. What is the value of box.getX? What is the value of box2.getX? The value of box.getX is going to be 105.0 and box box2.getX is also going to be 105.0. This is sort of weird. It looks like we called box.translate 100, 100, and the effect happened on box and box2. What's going on here? Perhaps, you were surprised by the last problem that you worked with Sarah. In that problem, an object was shared with two variables. Let's have a closer look at what happens in that case. Here, we have an object that's stored in a variable. Now, it's important not to confuse the object which I've drawn here with the variable. In Java, an object variable does not actually contain the object. Instead, it contains information on how to find the object, it contains the location of the object. We draw that location with an arrow and we call it a reference. Now, suppose we make a second variable and copy the first one into the second. In that case, we simply copy this reference into this variable. As you can see now, both the variable box and the variable box2 refer to the same object. Now, suppose we call a mutator on one of the variables. As you can see, the object has changed. And that change is observable both through the variable box and through the variable box2. That's just how object variables work in Java. And it's good to know, because you can then explain how objects work when they're copied. Sarah will practice that with you with another problem. Hopefully you're beginning to see why modifications to one rectangle variable might affect another rectangle variable. Let's try another example. If I run this code. What happens? Does this code draw a blue rectangle and a red rectangle or just a red rectangle or just a blue rectangle or just a purple rectangle? The answer is a blue rectangle appears. Let's try it out. Here's the blue rectangle it prints. This is because we made a rectangle. And then, we made a variable box. And in that variable, we put a reference to the rectangle we made. Then, we made another variable, box2. And we copied the value from box in the box2. So, we copied the reference. So now, box2 also refers to the same rectangle. Now, we've set the color of the thing in the box to red. And then, set the color of the thing in the box2 to blue. And then, we draw or fill the thing in box, which has the color blue. What if, instead of copying rectangles, we copy strings? Again, we create a string greeting and then greeting 2 which is a copy of the string greeting. And now we call greeting2.toUpperCase. After these statements, what's the value of greeting? What's the value of greeting2? The answer is that both will be "Hello World", but they won't be upper case. Let's draw the diagram. Both variables, greeting and greeting2 point to the same string. But since to upper cause isn't a mutator, the string never changes. Instead of changing the original string to upper case returns a new string with upper case letters. I'm going to tell you a little bit of a secret. There's actually no method that can mutate a string. Some methods return a new different string, but they never modify the original. Copying rectangles and copying strings seemed to have different results, but they were really the same process. We had two variables pointed at the same object behind the scenes. Let's look at a different kind of copying. I make a variable lucky number which is an int, and I set it to 13. And then for my second lucky number I'm just going to set it to the same thing, and then I'm going to change the second lucky number. After these steps, what's now our lucky number? How about lucky number 2? The answer is luckyNumber is 13, and luckyNumber2 is 12. Let's draw the diagram again. luckyNumber is an int, so instead of having a reference, it just contains the number itself. So initially, we set it to 13. Then we made luckyNumber2 by copying the value of luckyNumber1. Which isn't a reference this time. It's just 13. So, luckyNumber2 became 13, then we change the value of luckyNumber2. We set it equal to 12 instead of 13. Since this isn't a reference, we just reset it to 12, and that's how we get our answer. Again, ints aren't objects. Strings are objects. Rectangles are objects. Ints are not objects. You've just worked through a batch of tricky problems with Sarah. And maybe the results of the programs were not always what you expected. That's why it's such a good idea to test your programs to see that they produce the right result. Testing is incredibly important in software engineering. And when testing isn't done right, the results can be quite dramatic. Over here, you see the lift off of a rocket, an Ariane rockets off the European space agency that unfortunately a few seconds afterward explodes in midair. Now what happened here is that the rocket had a device to maintain its position and it actually had two backups. And because of that, the rocket engineers didn't think they had to test it. But both back ups failed for the exact same reason actually and testing really would have been beneficial in this case. So let's learn more about how you can test your own programs. Okay, here we are in BlueJ, and I'm going to write a program that tests the translate method of rectangles. Let's have a look. Here, we construct a rectangle, we call the translate method. We print out what happens to the x coordinate and we also print out what happens to the width of the rectangle. And now for the important part. The important part is that before compiling the program, we also think what should it do? And it is really, really important that you think about that right when you write your test program. Here is a super easy way of doing that. You simply add a print statement that prints what you expect that this program should do. Hmm, what do we expect? Let's see. The x coordinate of the rectangle is at 5, the y coordinate is at 10. And now, we translate it by 25 pixels to the right and 15 pixels down. So we have a 5. Translated by 25 pixels, so we expect that the x coordinate is now 30 pixels, and that's what I'm putting here. What about the width? The width is 60 and moving the rectangle shouldn't change it, so we'll expect this to be 60 again. So this is a good example of a Tester program. We do something. We print the results and we print the expected results. Lets quickly run the program. We have the actual x position of 30 and the expected position of 30. And similarly we have the actual width of 60 at the expected width of 60 so the actual and the expected Matchup. That's great. So, the simple lesson is always print the actual and the expected results. Sarah has an activity where you can write you're own test program and practice this. Kyle gave us all this rectangle code but why are you so sure that Kyle's code works? Now it's your turn to write a test program for the grill method. If you create a rectangle like this with an upper left corner, at 45, 90 and a width of 60 and a height of 90. Let's say you call it box and you call grow with 20 and 20. So it should grow 20 in this direction, 20 in this direction, 20 in this direction, and 20 in this direction. What are the actual and expected values of x, y width and height? Write a test program that compares those expected values with the actual values. Before we can write any code, we need to figure out what the expected values are. This green rectangle is what our rectangle grows to. This point should be at 45 minus 20 and 90 minus 20. So our expected value of x, would be 25. And your expected value of y would be 70. The width would be 60 plus 20 on one side, and 20 on the other side, so 100. And the height would be 90 plus 20 at the top and 20 at the bottom, so 130. So in the test program, I would create my new rectangle and I would print out my expected value for x. And remember, this is just a comment. And expected value for y, expected value for width, and the expected value for height. I want to compare these to the actual values. box.getX, gets me the, actual value, of X for box. Box.getY gets the actual value for Y for the box. And I do the same thing for width and heighth. Now I can run my test program. I had a couple of syntax errors, so I just fixed those up, and now I can actually run it. And I printed, 45, 25, 90, 70, 60, 100, 90, and 130. Looks like the actual values don't match my expectations. What went wrong? It looks like I created the rectangle and then printed out the actual and expected values without actually calling grove. And now if I run it again, I get the actual is 70, expected is 70, 100, 100, 130, 130, and 25, 25. That's much better. Based on these test results, I'd say the grow method works about, the way it says it will. So, it's important to test your code, because you never know the impact it's going to have. You sit down and you write a piece of software for one thing, and someone else might see it a month or year down the road. And think of another awesome way it can be used, and you want to make sure that a code you write doesn't break in other situations. And I think that's one of the things that's awesome about computing, is that the code we write has such a big impact. But in order for it to have a big impact, we need to be very vigilant about making sure that it's good. And we build a good product that other people can then take and do more awesome things with. Now we've been working a lot with rectangles and you may wonder whether there are shapes you can use, and indeed you can. I'm going to show you know more about the graphics library that you get with this course. It's a simple library, I've created it especially for this course. It's very similar to the standard Java library but it's a bit easier to use. You can find the full documentation on the web. But let's just walk through the basics so you get a feel for what you can do. Here is an example of a silly drawing that you can create. When you look at the drawing, you can see rectangles, lines, circles, and text. You already know about rectangles, so let's move on to the other elements. Let's say you want to draw a line from this point to this one. You need the coordinates of the start and the end. And then you simply construct the line by giving the coordinates to the line constructor. You store the object in a variable. And when you're ready to draw it you call the draw method, just like you would for rectangles. Now let's say if you want to draw a circle or an ellipse. A circle is just an ellipse that's symmetrical. Find the rectangle that fits around the ellipse. Determine its top left corner, its width, and its height. And then construct the ellipse, really in the same way, as you would have constructed, the surrounding rectangle. Finally if you want to show some text, specify the top left corner point, and construct a text object. Simply give the coordinates and the message that you want to display. That, in a nutshell, is our graphics library. Sara has prepared a couple of simple practice problems for you. We've drawn a lot of boxes today. But they've all been very flat. What if we wanted to make this look more 3-dimensional? I want you to draw this box and I'm going to give you a few specifics about its dimensions. This top left corner should be at 20,30. This width should be 100. This height should be 40. This corner should be at 50,10, and this one should be at 150,50. Before I can write the code, I need to figure out exactly what each of these corners is, so that I can think about the end points of each of the lines I need to draw are. This line's pretty easy, it goes from 20, 30 to 50, 10. This one's a little bit trickier, this point is at the same height as that one, so it's at 10. And it's 100 to the right from 50. That means that its x value is matching up with this one, so that looks good. This point is 100 over from this one. So, 100 plus 20. And this point, gives us 120, 30. And this point is 40, down from this one. So 120, and 70. So we got that first line. Now the second one. Is from 50, 10 to 150, 10. This line is 120, 30 to 150, 10. This line is 150, 10 to 150, 50. And this line. 120, 70 to 150, 50. The rectangle has its top length here, and it gives us the width and the height. So we know how to specify that one. Here's how I wrote the code to draw the crate. There's a rectangle, which is that front face. Top left 20, 30, width 100, height 40. Then there's that leftmost line. 20, 30 to match the point that it starts at and 50,10 to match the point that it ends at. Then I did the same thing with the top line, middle line, the rightmost line, and the bottom one. Then I had to remember to draw each of these lines. And if I run this program, it draws the three dimensional crate that I wanted. Good work if you got that. That was a lot of getting all of the right coordinates in place. But if you did that, you should be pretty familiar with drawing lines now. So, it turns out that this box that we drew actually belongs to a not so great spy, who labeled it top secret. Can you use text to write top secret starting at this left top corner. All I had to do was create a text object that starts at 20, 30 and has the text top secret in it and then draw it. Now if I run this program again, it'll draw the box and write top secret. Earlier you wrote a program to create two rectangles that touch at corners. What happens if you run these four lines as well? Which of these will box end up looking like? How bout box 2? I haven't actually told you enough to figure this out but you can try it in blue jay. I think the best way to find out, is just to try it. When I run my program, prints out this. It looks like box ended up like this, and box2 ended up like this. Everything that we've drawn so far was in black. Now, black is a marvelous color, but what if you'd like another one, such as one of these? These colors have predefined names, and when you look here, you can see that every color is a mixture of a red, green, and blue component. Red has only red, and no green and blue. Blue has only blue and no red and green. Yellow has red and green, and no blue. You can make other mixtures, and you'll explore that in the exercises that are going to be coming up right now, let's just stick with red. Let's say we have a rectangle that we want to draw in red. You set the color to the color constant red in this way, and then when you draw it, it shows up in red. Alternatively, you can call the fill method, and then the interior's also drawn in red. Now you know everything about the graphics library to make fancy drawings on your own. Go ahead and do the practice assignments with Sara. And when you're done, maybe you'll be motivated to recreate Udacity train. Or create a fancy drawing of your own and share it with us on the discussion group. These numbers look pretty mysterious. Let's talk more about colors and what these numbers mean. We left a few predefined colors out, here are the colors, and here are their RGB values, though they're mixed up. Can you match each set of RGB values to its color? You can figure this out whether you remember what magenta means or not. As a reminder to help you in your experimentation, this is how you would write code to color a box magenta. And this is how you would write code to color a box with color a. The answer is that magenta matches c, yellow matches b, white matches d and cyan matches a. But how did I figure that out? I went into BlueJ and created a rectangle, and filled it. So I got something like this. Then when I set the color, it changed to this sort of red-blue color. Cyan is this sort of green-blue color. I'm pretty sure I know what yellow and white look like, so I'll skip those ones. When I set the color to that color described by a, well, that looks exactly like the cyan that we just saw. And if I set it to color b, that looks like yellow to me. Color c looks like that blue red magenta color. And color d. Well, that's just white. It doesn't show up very well on a white background. If you're curious about this system of marking different colors, you could try making brown or orange. But that's all we'll do with colors for now. You've got a little more practice with graphics and a pretty cool project coming up. So, one of the most interesting projects I've worked on was actually a project that arose out of personal interests. This was around the time that the Euro 2012, which is an international soccer competition was happening. And, so what I did is I went on to the Euro website and I took a whole bunch of statistics about the teams and the games. And I just took that information and I put it into this piece of software. And it was instantaneously able to make these predictions for me about who was going to win, what players were going to perform the best. And that's not something you or I can do with the naked eye very quickly or accurately. But, it's something that this computer could do very well, very fast. And with only a year and a half of programming background, it was information that I was able to extract. So I think one of the really unique things about computer programming is that, the first time you run your program, it's not going to work. And you shouldn't expect it to work. And people get really frustrated, because that's not something that they've seen in other places. And so my advice for anyone learning to computer program, whatever point you're at, would be to fail forward. It's about writing code, and running a program, and having it not compile. And not run. And while that can be really, really frustrating, you'll see that bug ten times later and you'll understand why that bug is there. And you'll be faster at it. And in the end, you don't when your program just runs, because you don't fundamentally understand why that happened. And so. Just fell forward and learn from your mistakes and be okay with this kind of incremental process. Great job. Look at how much you've learned. You now know how to make objects from classes and how to call methods on them to make them do things. You've learned how to look up the documentation for classes and methods so you can find out what they can do and how to make them do it. Also you've learned how to store objects and variables so that you can recall them when you need them. Most importantly you've learned how to combine different objects in order to do more complicated things. In the next lesson you will learn how to write your own classes, so you can become a giant that other programmers can stand on. Hello, there. Here we are in the Udacity recording studio. Last lesson, we used objects from the day and picture classes, and that was pretty useful. But what if I want to make my own classes? That's what we're going to be covering today. You will learn how to design, implement, and document your very own classes. So then, other people can use my classes in their programs, too. That's right, and it's a really important activity and that's why we're covering it early in this course. Let's get going. Hi, my name is Aina. I'm a junior at Stanford University studying something called Symbolic Systems. It's a combination of computer science, philosophy, psychology, and linguistics. And within that, I'm focusing on human computer interactions. I actually entered Stanford as a pre-vet. I was going to be a human biology major. I started taking the chemistry, biology, and physics classes, and I was getting kind of bored, honestly. So, at the beginning of my sophomore year, I took my first computer science class. I absolutely fell in love with it, and I abandoned all things pre-vet, and it's been a marriage ever since. Hello and welcome to this new lesson. In the last lesson, you've used objects of classes that other people have created. In this lesson, you will learn how to write your own classes. We'll start out with the class that models a car that drives along. When you design a class, the first thing you ask yourself is. What can one do with the object? Well, imagine a car object. It can drive. Being a car, one will need to add gas once in a while. The object should be able to tell us how many miles it has driven and also how much gas is left. That's all that our car objects will be able to do. Now the first step is to take this English description of the car's capabilities and turn it into the Java code for the public interface. Her is how I like to do it. I first imagine myself being a user of this class, so I have an object, here it's my car and here's how I might want to call the add gas method. The name of the method, addGas and here I'd add 20 gallons. To make the car drive, call the drive method on the car and of course one has to say for how long to drive and here we say 100 miles. And then I might want to find out how much gas is left in the tank after that. So I again use the mycar object, invoke the getgasintank method. It returns the gas level and I store that in a variable. Well, what's the point? I now have more information. I can see that these two methods take arguments and this one doesn't. And I can see that this method here returns a value that's actually a number and these two don't. Now it's fairly easy to write up the publivc interface of the class. I have four methods. Here you see their names. You see that the first two methods have parameter variables and you see that these two methods return values. Let's see more closely on how this process works. Look at the add gas method here. Here, we see it takes an argument, the number of gallons added. I've called that here the amount and it's of type double. This method doesn't return any value, so it's declared as a void. In contrast gas getgasintank has no argument. So there's no parameter variable here but it returns a number. So we put the keyword double here. So the general process when designing a class is to first informally figure out what you want the class to do. Then to put yourselves in the shoe of the user of the class and see how those methods might be called. And then you have enough information to write up the public interface in Java. Sara's going to practice that process with you with another class. So, we know you're still with us, which of the car methods are mutators? addGas, drive, getMilesDriven, or getGasInTank? AddGas and drive are mutators. Adding gas changes the state of the car. It now has a more full tank. Drive adds miles, and changes the number of miles driven. Reading the odometer or the gas gauge doesn't change the car. Those methods are accessors. As professor Horseman develops his car example, we'll do our own more interesting example in parallel. Cars aren't where the money is. The money is in social networks, but existing social networks, I mean my parents are in existing social networks. Maybe we're going to need to start our own new social network. Let's call it Udacious.net. Social networks are all about people, so we're going to need a person class. And the thing we're interested in them doing, is making friends. So, if we have two people, John and Maria, who meet. And now John considers Maria a friend, we need to update our persons objects to reflect that. What might the method call look like in Java? There are a lot of ways that you could've done this. I chose john.addfriend(mary). We ask the john object to add Mary to John's friends. Now that we know what the method call looks like, we can turn that into an API description. Public void addFriend (Person friend). As it happens, sometimes those friend relationships don't last. Let's suppose John changes his mind. And for reasons I'll leave to your imagination, wants to unfriend Maria. Can you write the Java API for an unfriend method. And a couple hints, I'm asking for the public interface, not an example method call. And the making a friend public interact from the last question looked like this. Again there are a few options here, so if yours doesn't look exactly like mine it might still be right. I chose to call the method unfriend, and name the perimeter that comes in nonfriend. This would be the friend that you are unmaking. The method doesn't need to return anything. What we're interested in is that it mutates the object to reflect the new social developments. It's public because it's part of the public interface of the person class. If you got this, good work. So far, we have two methods in our class. We have add friend, and un-friend. Now, since John and Maria are no longer friends, John went on a friend adding binge. He forgot who was in his friends list because there were so many of them. We need a method to get all the friends in John's friends list. For example, it might return Ann, Fred, Barney. What is the public interface for the method that lists friends? If you need a hint, think about what the method call would look like. The answer might look like public String getFriends. Maybe you came up with a different names for this, that's totally cool. The method should return the friends in a string. And it's public, because it's part of the public interface of the person class. It doesn't take any arguments. GetFriends is an accessor. Asking about the friends of an object doesn't mutate the object. We're just getting access to the information it can provide. Good work helping me to build the public interface for the person class. We'll come back and figure out how to implement each of these methods later. But for now, back to the professor, who will talk about implementing the car methods. You've just practiced with Sara how to find the public interface of another class, now let's go back to our car class. We had discovered the public interface that you see over here and now our goal is to implement it. So imagine a car object and let's have a look at the add gas method. We're adding a certain amount of gas and what should that do to the car. Well, remember, it's not a real car and it's not real gas. This car is just an object in a computer, and it remembers some information. In particular, in order to add gas, the car needs to remember how much gas it has. In Java, you use variables to remember anything. And here's is how you write such a variable, a variable has a name just like the variables that you've seen in the previous lesson as well as a type. And then there is this key word private here that simply means that the variables of an object are a part of the private implementation. The programmer who uses the public interface doesn't need to know about that. You will always want to declare instance variables as private. Let me tell you why they're called instance variables. Let's have a look at another car object, or as we say, another instance of the car class. Of course, it also needs to remember how much gas it has. And the amount of gas that this object has will be different from the amount of gas of the other object. So each of these objects, or each of these instances of the car class needs to have its own variable to store that information. That's what it means to be an instance variable. It's a variable that occurs in every instance of the class. Now there's another thing that each car object should remember, namely its mileage. Here's how you can define the variable, we give it a name, miles driven. It's type, it's again a number. And once again, each instance of the car class has its own value, so it needs its own copy of that variable. These are the two instance variables that we need for the car class. You will soon see how the methods of the car class update or read those instance variables. But first, go ahead and practice with Sarah how to discover the instance variables that we need for the person class. Remember the person class we made an interface for? Now it's time to think about the implementation. What does a person object need to remember for the add friends, unfriend, and get friends methods? There are a lot of possible correct answers here. What do you think? I think it needs to know the persons name, and the persons friends. If it stores the names of all the friends, it'll be able to give us back that information. A person should also store its own name. We can add other interesting facts to the Person object like where they work, or their favorite restaurants. But for now just to do these methods, we're going to keep it simple. If you feel like customizing your Person class once we've got the basics working, go wild. Let's think about the person's name first. How will we store the person's name in the person object? How would you declare an instance variable for a person's name? One answer is private String name. You might have used a different name for the variable here. This declaration says that the variable is private, because it's an instance variable. Its type is String, because it's literal text. And I gave it the name, name, but maybe you came up with something different. As long as it means something like name, that's good. Great. So far, we have our class for person that has an instance variable for the name. Now we need to store the friends. The string containing his friends will be TJ Jamesha. You'll learn a cleaner way to do this later, but this'll work for now. How would you declare an instance variable for a person's friends? Did you get private string friends, if so good work. If not, it's okay, you'll get more practice. And if you called this something other than friends, that's fine as long as it means something similar. The next step right now is to learn how the instance variables get their initial values and how they're updated. Let's watch it for the car, and then we'll come back to the Person class. Alright. Now, you've discovered together with Sarah what instance variables are needed for the person class. So, let's return to our car example and let's start implementing some methods. First off, when you implement a class, you put everything inside a class declaration, which has the keyword class followed by the name of the class, and we generally make all classes public because we want everyone to use them. Inside the class, go the instance variable declarations, as well as the implementations of the methods. So far, I've just put in the method headers here. And we're going to add the method implementations in just a minute. Alright, let's get going. Here is our car class. Here are the instance variables, here is the header of the first method, and we'll put the implementation inside this pair of braces. Now, what do we need to do? Let's say we drive a distance of 100 miles. Then we need to take the miles driven so far. And add the distance to it. That's how the statement looks like. You take the miles driven and add the distance, say 100. Now, miles driven is 100 miles bigger. And we put it back into the variable, so now the variable is updated. Of course, when you drive, you also lower the amount of gas in the take, but we'll come back to that later. Right now, it's your turn, go ahead and implement the addGas method. Simply put in the code for the method inside this text field. Well when you add gas, you update the gasInTank instance variable. And you simply add in the amount of gas that was added. Here is the code. Now, we can try this out in BlueJ. Let's make a new car object. Here it is. Let's drive the car for ten miles. Hm, that wasn't very exciting. It would be nice if we could see the car. Let's do that. I'll put a picture in here, and you'll see later how that picture is initialized. And in the drive method, I'll move the picture by the distance trip. Now, let's make another car. You see the picture. Let's drive it, and there it goes. And that was a little bit disappointing, because it only moved by ten pixels. Let's fix that. Let's move it by 10 times the distance, and actually let's do this right. Let's declare a variable, and then use that variable. Now, when the car drives, then it shows it nicely. Okay, now you have seen how to implement some instance methods. And Sarah will walk you through that process with another example, with a person class. The car's instance methods look pretty good. Now you're going to implement the addFriend method for the person class. We decided earlier that the person class will need instance variables for name and friends. Now the code for add friend will go here. Before you can go this, I need to tell you a couple things about strings and instance variables. You can add strings. If I make a string, addedStrings, which is TJ plus Jamesha, addedStrings now contains TJJamesha. You can add together as many strings as you want. Now to talk about instance variables. A person object can read the name of another person object, friend.name will give you the name of the new friend. There's one more thing. I told you earlier that we should store the names in a string separated by spaces. So I don't want it to look like TJ Jamesha all crammed together I want a space in between each name and the name following it. Now its your turn to implement the addFriend method. That might have been tricky. The answer should look something like this. There might be other ways to do it, but I think this is the simplest one. If you didn't get this, it's okay. There's more practice coming up. There are some subtletles to how this method works, so let's go through an example. Let's say we have two variables, one for Maria and one for Jamesha. Each of those should contain a person object with a name and friends. We have string objects. For Maria's name, Maria's current friends, Jamesha's name and Jamesha's current friends. Let's say we call maria.addFriend(jamesha). We call this method on the maria object and we pass in as an argument the Jamesha object. Now, when this line runs, the first thing that it does is creates a new string from these ones. This will be the new string that's created. It's going to put together friends, friend.name, and a space. Friends is the friends of the maria object because that's what we called the method on. So, we go to the Maria object, and friends is currently just TJ, with a space. friend.name is the friend, the argument, which was the Jamesha object, dot name, which is Jamesha. And the space is just a space. So, when these strings get put together, it'll look like TJ Jamesha. Now the string created by this part will be assigned into the friends variable. So, the old reference will go away and a new one will be created. And now, Jamesha appears in the friends of Maria. The old friends string that contained just TJ might still be around. And it hasn't changed, but the friends variable in the Maria object now contains a reference to a different string. The unfriend method removes a name and the space from the friends instance variable. You can use friends.replace to do this. Implement the unfriend method. Remember to remove the extra space. Use friends.replace and figure out exactly how to use it. The answer is friends equals friends dot replace. Friend name and a space with an empty string. We can look at an example to see how this works. So if this person is Maria and this person is TJ. If we call Maria dot unfriend TJ, we'll come into this method and we'll be doing it for this object. First thing that happens is we call friends dot replace friend dot name with a space after it, and then replace it with an empty string. Friends is initially TJ Jamesha. And friend dot name, whoops, that's actually an error, it should be nonfriend dot name. Do you think that's a compile time error, or a run time error? I'll just fix it. So nonfriend, aas TJ dot name is the string with TJ and nothing else. And then we're adding that together with another space. So we look for the TJ space and friends, and we replace it with an empty string. So this creates a new string, Jamesha with a space. And now we take that string and we make friends, which again was Maria is friends. Stop pointing at TJ Jamesha, and point at just Jamesha with a space. Sarah has just shown you how to implement some methods of the person class. And here were are back with the car, and ready to implement the remaining methods. Just to remind you, so far, we've implemented two methods. Add gas and drive. And when we drive the car, we can see that it has driven. But we have no way of finding out exactly how much. So let's fix that. We need to add a method that one can call to find out how many miles the car has driven. Here is the method header. And here is the implementation. Note this return statement. That indicates that this method returns a value, namely, the miles driven. Over here, you didn't have a return statement because the method had return type void. It didn't return an answer. The method over here has return type double, and it does return an answer. Any time you implement an accessor, you need to provide a return statement. Alright, now it's you're turn again. Go ahead and implement this method. Just put your code in the box. Here is how I do it. It's an accessor method so it needs to return something. And what does it need to return? Just a value of the gas in tank instance variable. Now, we're almost done with implementing the car class, but if you have another look at the drive method, remember, that we didn't update the gas in tank theory variable. That computation is a little bit trickier. Let's first figure it out on a sheet of paper. So, let's say we drive 100 miles. How much gas does that take? Well, of course, that depends on the fuel efficiency. Let's assume we have a car with great mileage. 50 miles per gallon. Well, then the gas consumed is 100 miles divided by the fuel efficiency or 2 gallons. Right, 50 miles for one gallon, 50 miles for another gallon, for a total of the 100 miles. That's something that we can easily program in Java and here's the formula. Let's put that into our code. Of course, that just tells us how much gas was consumed during the drive. We still need to update the instance variable. Let's do that. Here is it. We reduced gas in tank by the amount of gas that was consumed. And we need to set this value here. For now, we'll just use the value of 50 miles per gallon. We'll later see how we can make every car have it's own fuel efficiency. Now, how do we know we did this right? This would be good opportunity for a tester program, and that's what I want you to do next. Write a tester that constructs a new car, fill the car with gas, drive the car. Show the gas level, after the drive. And most importantly, print the expected value. That's what makes a detestor. Go ahead and do that in the coding environment, and then we'll compare notes. Alright, here's what I did. I filled up the car with 20 gallons. And I drove 100 miles. I printed out the amount a gas in the tank. An then I need to print out the expected value. Well that's the hard part. Let's see what I expect. I drove 100 miles. I assume, 50 miles per gallon. That means, two gallons consumed. I started out with 20 gallons, I consumed two so I should have 18 gallons left over, let's put that in and try it out. Here is the result, the actual gas left is 18 gallons and the expected value is 18 so, everything was working great. You've just seen how to implement the drive method so that it updates the gas used. And there were two kinds of variables in that method. Let me show you. Over here, you see an instance variable. And inside the body of the drive method you see a different kind of variable called a local variable. What's the difference? The instance variable, form the long term memory of an object. The kind of thing that an object wants to remember for a very long time. The local variables, on the other hand, are the equivalent of the short term memory. You may remember that you had pizza today but you won't remember it for very long. Whereas you'll always remember your cat. Technically speaking the local variables go away when you reach the end of the method. The instance variables never go away. They stay alive as long as the object is alive. So when do you want to make a variable an instance variable? You want to do that for those values that an object needs to remember throughout multiple methods. You want to make something a local variable when you can forget about it after exiting the method. In this case here we compute the gas consumed for driving this particular distance, update the gasInTank. And then we no longer care that this was the particular amount of gas consumed. We can safely forget it when we exit the method. That's why we put this variable inside the method and made it into a local variable. Now that you know how to implement methods, let's move on to constructors. You want to be able to create variations of objects. For example, a car that's very fuel efficient or a car that is less so. In Java you use constructors to initialize objects, here is an example. In the body of the constructor we simply initialize the instance variables. The first two here are set to a constant value. When a car is first created, it has not driven any miles and its tank is empty. This instance variable is set to a parameter, and that allows you to construct cars with different properties. Here, we construct a car with 60 miles per gallon. The value 60 is passed into the parameter variable. And is then set the instance variable here. Over here we construct a car with 5 miles per gallon and again, the 5 is passed into the parameter variable. And then used to initialize this instance variable. A couple of things to pay attention to, when you define the constructor, note the name. It's the same as the class name. The class is called car, the constructor is called car. Also note that there's no return type at all not even void. The constructor is not a method. It does not return any value. Instead the job of constructor is just to initialize the instance variables. You can have more than one constructor and you'll get a change to write one right now. Here is our constructor in BlueJ, you see the statements that we had just before, together with a couple of statements that set's the car's picture. Now this constructure always takes the same picture to construct the car. It would be much nicer if we could choose a different picture for every car, so let's do that. I'd like you to write another constructure that takes two arguments, the fuel efficiency and the picture file to be used. Go ahead and do that in the coding environment and submit your answer. Okay, here's what I do. Since the constructors are pretty similar, I'm going to copy and paste. Now I can keep these statements because I still want to initialize the miles driven as the gas in tank is 0. And I still want the miles per gallon to be the parameter that was passed in. But over here, I don't want this fixed picture. Instead, I want this one, and that's the answer. Now I can construct a current two ways. I can specify the fuel efficiency and get the default picture. Or I can specify both the fuel efficiency and the name of a picture file, and then the second constructor is chosen. Now that we've added the two constructors, we can see them in BlueJ. I right click on the car class and here they are, pick the second one. Now let's supply both parameters. And here is our car. The other constructor. Only requires one parameter, and we get a car with a default image. Now I'll turn it over to Sarah so you can practice writing constructors for the person class. Remember the person object? It still needs a constructor too. Here's the code that we had for the person object before, and you know how to make a constructor from the car example. Implement the constructor. It will take a name as an argument, and as a hint, think about what variables do you need to initialize... To implement the constructor, we need these two lines. We need initial values for both name and friends. So name is initially set to aName, the argument for the constructor, and friends is initially an empty list. Don't worry, it'll fill up as we add friends. We've got a lot of code for the person class now. We probably want to put it in BlueJ. And make sure that we haven't made any mistakes. So for BlueJ, I'll create a new project, and I'll call it Friends. I need to make a class for the person and then put my code into the class. I'll add the instance variables. The add friend method. And let's just check that it's compiling so far. So far so good. We'll add the unfriend method. Check that it's still compiling. Now I'll go back and put in the constructor. So far so good. Now I should be able to make a person object. And I should be able to add a friend. It's hard to tell whether anything happened yet or not. Maybe we haven't finished yet. Clearly, there's still more to do. Our person class is looking pretty good, but we're still missing a method. Can you remember what the method was? Maybe you want to pause the video and think about it for a second. Did you pause? The answer is, we forgot the getFriends method. We can put all of this data into our object, but we can't get it back out. John still can't get the list of people he added and forgot. If you remembered that, good work paying close attention. If not, I understand. I forget methods sometimes. You go back and you fix it. In BlueJ, implement the get friends method. I need to edit the person again and I want to add another instance method. This method is going to return the string with a friend. So let's return type a string and all it has to do is return the value of friends. Now we can go back and if we add Jamesha as a friend to Maria and then we get the friends of Maria. It returns Jamesha with a space just like we expected. I can create an object for TJ as well. Add him as a friend to Maria and then unfriend Jamesha. And now, if I get Maria's friends again, it just contains TJ. Looks like our object is working pretty close to the way we expected. We can now encode a social network using our Java program. It was pretty cool visualizing the cars. Let's do something like that for the social network. I want to update the constructor for a person object, so that when I create a person, it draws the person's picture. This is how it might look. In person demo, I create three person objects, and I pass in a name of a picture, and also a location. And then when I run all of this, it creates this picture. Can you update the person class so that it will do this when you run the main method in person demo. You will need to take three additional parameters in the constructor: a picture name, an x coordinate, and a y coordinate... Here is how I did this. I added a string parameter picture name an 'int' parameter 'x' coordinate and an 'int' parameter 'y' coordinate. Now as well as setting name and friends, I create a picture using the picture name and then I translate it to the 'x' and 'y' coordinates and draw it. Good work if you got that. Now that our program draws the people in the social network, we need to make it draw the friendships. I wrote a main method that creates three people, Sarah, Cheng-Han, and Cay, and then adds Cay and Cheng-Han to my friends. When I run this main method, It draws connections from me to Cheng-Han and me to Cay. This dot means that Cheng-Han is in my friends list, but not necessarily that I'm in his. Your task now is to fix the person class so that when you run this main method, it draws this picture. With the lines. Each person gets a picture when the object's constructed. And when someone adds a friend, you draw a line, from the person who who has a new friend, to the person who is the new friend. The lines for now should just connect all of the top left corners of the pictures. This is a pretty complicated task right now. You might be thinking, you're not really sure what to do first. So let's chat a little. Here's most of our code for the Person class. You're only missing get friends at the bottom. And y-coordinate over here. In which method should we add code that draws a line between friends? The constructor, addFriend, unfriend, getFriends, or somewhere else? The answer is add friend, though we will need to do some extra work elsewhere to make this happen. Until the add a friend, there's no way to know which line to draw. And we want to draw the line as soon as we know which friends to connect. Which is when the add friend method is called. Here's another question. When the addFriend method runs, do we have enough information to decide where to draw the circle? Yes, it's in the x coord and y coord variables. Yes, we can get the coordinates from the friend variable. Yes, it's somewhere else. No, we should take the coordinates in as parameters in the addFriend method or no, we should make an instance variable. The answer is no, we don't have enough information, we should make an instance variable. The xCoord and yCoord variables are parameters in the constructor. Which means when the constructor is done running, they go away. So then when addFriend is called later, xCoord and yCoord don't exist anymore. We can't get the coordinates from the friend variable. We're talking about the coordinates for where to draw the circle. And the friend probably doesn't know anything about where the upper left corner of the current object is. We could take the coordinates in as parameters in the addFriend method, so it would be addFriend(Person friend) int x int y. But it would be a little weird if every time you called addFriend, you also had to pass in the x and y coordinates that you originally passed in in the constructor. So if we decide to make instance variables for x and y, where would we initialize them? That's one for you to think about yourself. So now imagine that you've added instance variables for x and y. You'll know where to draw the circle when you're adding a friend. And that circle marks one endpoint under the line. But what about the other endpoint? How are you going to get that? Use the instance variables x and y. Use the friend parameter. Use xCoord and yCoord. Get the x and y values from the friend parameter. Or add parameters to the addFriend method to take in the second endpoint of the line. The answer is, get the x and y values from the friend parameter. Friend is a person object. And we've added x and y instance variables to all of the person objects. The line should join our object to the friend it's adding. We can't just use our own instance variables, x and y. Because then our line would start and end at the same point, and wouldn't join both friends. We can't just use the friend parameter. Because this isn't specific enough. We can't use x coord and y coord. Because those variables aren't accessible anymore. And they contain the first endpoint, not the second endpoint. We could add parameters to the addFriend method to take in the second endpoint of the line. But then every time someone called addFriend, they would have to pass in the coordinates of the friend they're adding. That would make the Person class harder to use. Now that we've talked through a few parts of this problem, I want you to try to update the person class so that person demo2's main method will work for you the way it does for me. This is tricky, and there are a lot of steps, so take your time. And I'll do the answer one step at a time, so you can watch the first few seconds if you get stuck. Here's one more hint, use the small circle class we give you to draw the circle at the beginning of the line. I'm going to step through this answer and narrate my thoughts. So, you can pause my answer at any time and go back and try again if you got stuck somewhere. First, I thought about when I want to draw the line. I want to draw it when I add a friend. So, I'm going to need to update the addFriend method. First, I want to draw a circle for the beginning of the line. So, I'll make a small circle and draw it at the top left corner of the picture. But in the addFriend method, I don't have access to that right now. I lost track of the x and y coordinates when the constructor ended. Never saved the top left corner before. Maybe this is something the person needs to remember about it, so I'll create instance variables for x and y. There they are. But I haven't initialized them. Where do I initialize them? I initialize them in the constructor, x starts out as x coord and y starts out as y coord. Now I can draw my circle. It'll just be a new small circle with x and y, and I'll fill it. Now, I want to draw the line. It will start at my upper left coordinate, but where does it end? It ends at the friend I'm adding. If I want to access their instance variables, for x and y, I need to use friend.x and friend.y. So, my line will look like this. Line line is a new line, starts at my , xy coordinates and goes to my friend's x, y coordinates. Last, I need to actually draw the line. And let's see if I did this right. Looks like it compiled and if I run person demo 2, it prints out the picture we wanted. Good work on that quiz. That was really good practice. The next time you see something like this, it'll feel a lot easier than it did this time. Now we've done a lot of work. We've learned how to identify the instance variables of a class, how to provide the methods, how to write the constructors and the result has been a lot of code. But we've forgotten something very, very important. How does one use this code and who's one? That would be the programmer who doesn't want to know what goes on inside the car class but who just wants to write programs that drive cars around. Now, for a car, when we have an owner's manual but for code, what you want is Javadoc. Let me show you what one needs to put into the code to get the javadoc. Over here you see the same car class that we've been developing. But I've added documentation comments. These comments are enclosed in these delimiters. You see them over here. You see another set of over here. And at the top of the class, you see a class comment that describes the purpose of the class. At the top of every constructor and of every method, you see a method comment. For every parameter there is a line explaining what the parameter means. And for those methods that return a value, there is a comment that explains what the method returns. Now, previously, you have seen the javadoc comments in a webpage, the way to get such a webpage for your own classes is to run the javadoc tool, which we can easily do from within BlueJ. In the main BlueJ menu, pick tools, then project documentation and you'll get to see a webpage in the familiar javadoc format that contains exactly the same comments. They were in the source file that's what javadoc tool does. It takes the comments from the source file and puts them into the web page. For example, here you see the description of a parameter and that's the exact same description that was provided in the source code. Notice that over here this method looks rather naked, no description, no parameter description, oh, that's because there is no java.com in here. So it's your turn now. Go ahead and put it in. Okay, let's see how one would write such a comment. The method is called addGas. And we need to describe it's purpose in plain English. So, just say Adds gas to the tank of this car. The method has a parameter, and for every parameter, we'll need an @param clause. Put in the name of the parameter, and then a description. The amount of gas to add. Do we need a @return clause? No, because this method, returns void. That's the Java.comment. When you generate the documentation again, now the comment is included in the webpage. Now you make think it's a bunch of trouble to add all these comments into your code but let me show you something. Here is a part of the documentation of the java string class. When you scroll through it you'll see someone wrote a lot of documentation here, and actually let me tell you who that someone was. You can get the source code for the string class, it's a part of the java development kit. So, here is a part of the actual source code, here is a method and over here. The programmer wrote a pretty long java.comment and not just one. If you scroll through this file, you will see that every method has a comment. Here's another one and you'll see that every method has a comment so if the programmer that give us java can write those comments, so can you. Let's practice writing documentation. In this version of the Person class, there's a java.comment for getFriends. What's wrong with this documentation comment? The first sentence shouldn't have a period. The first sentence should describe the method. There's no at param statement or the at return statement should describe the method. How would you write this documentation comment? The problem with this documentation comment, is that the first sentence should describe what the method does. This one just tells us that a person can have friends. That says something about what a person is, but not about the get friends method. We might instead of written something like returns a summary of a person's friends, at return the names of friends, separated by spaces. Computer science is a highly collaborative study, especially when you're looking at the working world. Everyone works together to pull out and put together this beautiful product. Let's look at Facebook and let's look at Google. You're going to see thousands of programmers sitting in different rooms, coding and sharing their ideas as well as lots of people coming in who want to enhance your idea. Or perhaps change your idea. And you're not always going to be able to be there to explain it. So documenting your code is really, really important to be able to work as a very fast paced efficient team, and to make impact on the products that you work on very quickly. Now that you've seen a lot of code for implementing methods. Let me show you a technique that can help you understand what a method implementation does. It's called the object tracing technique. So, let's say that you have a, a couple of methods that do some work that may not be so easy to understand. Here's what you do. Pick some scenario, that exercises these methods. Like here, I'm making a car, I add gas, I drive it, and I drive it a bit more. And now we want to understand, what do these methods calls do to the car. It's very low tech. Get yourself an index card or a napkin or some other piece of paper. Make a column for each instance variable. So, let's get started. I put the paper clip so we can see where we are. We construct a car, that initialized the instance variables. I didn't have room to put in the code for the constructor but hopefully you remember. The gas and tank and miles driven are initialized to zero. The miles per gallon with the parameter of the constructor. Let's move on. Now we enter the add gas method here. Amount is thirty. Gas in tank is zero. So, the effective set gas in tank is set to thirty. Moving on. Now we drive ten miles. So, distance is ten. And since this method is a bit longer and it has another local variable here, it makes sense to make another card for it. Or actually, since I ran out of simulated cards, I'll use a napkin. So the distance parameter is 10, over here. We update miles driven, previously it was 0. We add 10. That's now 10. Now here we compute the gas consumed. That's another local variable. I'll put it on my napkin. It's the distance divided by miles per gallon. 10 divided by 10. So, we consumed a gallon. Now we can look at this statement here. Gas in tank was 30. Gas consumed was 1. The difference is 29. So, that should now by moved into gas in tank. Now, we're at the end of this method call, and the local variable here and the parameter variable go away. So, we can just crumple up our napkin here. These variables are no longer there once we exited this method. Of course, the instance variables, the long-term memory of the object, they stay around. Now here we are on the next method call, we're calling the drive method again. That means that this local variable, and this one here, will get recreated. Of course this time the distance is 20. Now let's see, miles driven is, miles driven plus distance. Previously it was 10. Now we have 20, now it becomes 30. Gas consumed is distance over miles driven, that's 20 by 10 or two. Gas in tank was 29 minus two is 27. So, now we've executed the three steps in this method. This method is now finished. And once again, the local variables go away. And we're done, and this is the remaining state of the object. What's the point? By doing this exercise, you gain an understanding of what the statements in the methods do to the instance variables of an object. Sarah will walk you through an example on how you can use this technique to find a bug in a method implementation. Let's practice hand tracing with objects. I implemented a get number of friends method, so I can compare how many friends I have with how many friends Chin Han has. Here's the code. Did I get it right? Let's find out by hand tracing these four lines of code. Hand trace it for the Sara variable. I'm going to trace name, friends and numFriends. I start at the first line, create a new person with the name Sara. So name will be set to the name I passed in. Friends is empty, numFriends is 0. And then we're done with the constructor. We do the same thing for Chenghan. And now we add a friend to Sara. So in addFriend, friends will get longer, it'll be friends plus Chenghan and numFriends will go up by one. And then that method's done, so we go up to the next line. In sara.unfriend, we shorten friends, we replace Chenghan in a space with nothing. So friends goes back to being nothing and then we're done. Something went wrong here, though. I clearly have no friends in the list here. But here, my number of friends is still 1. We saw when that happened. In unfriend, we updated the list of friends, but didn't update the number of friends. Now Sarah has just shown you how one can use object tracing to find a bug in a method implementation. And I'd like to show you another kind of bug that's fairly common. So over here I have my drive method. I drive a given distance, I update the miles driven. I compute the gas consumed. I update the gasInTank. And when I compile it, I get an error message. Where it says can not find symbol variable gas consumed. It's complaining over here. Now it's a common error to now say oh, it can't find it so let me just make another instance variable. So on the surface it doesn't seem like an error because the class will compile and actually the code will kind of work but it's really inelegant. Let's use the tracing technique to find out why. Note that this class now has four instance variables. Here they are on an index card. And now let's quickly run through the same scenario that we had previously. The car gets constructed, we add 30 gallons, we drive 10 miles. That consumes a gallon. We then drive 20 miles for a total of 30, that consumes 2 gallons. We're left with 27 gallons. So what's wrong? Have a look at this variable. The stuff that it remembers is short-term information. The amount of gas consumed the last time we drove, that's just like remembering what pizza you had for lunch. You don't really need to remember this long term. There's absolutely no need to remember these values after a call to drive, they should be short term memory that should be a local variable. Okay, let's make it so. Over here let's not make gas consumed into an instance variable. Over here we turn it into a local variable simply by adding the type. Remember the difference between an assignment and a variable declaration is nothing but the type. Now the code will compile. And when we review the instance variables up here, we'll find there are no unnecessary one. Your car does need to remember the miles driven at a gas level across multiple method calls. And of course, it needs to know the mileage so that it can compute the gas consumption. So you've just seen how the technique of object tracing gives us an insight into what an object does and it lets us find some errors. Now, I'd like to talk about a different error. I've on purpose made that error over here. So have a look at the code and tell me what you think is the problem. Is the code so bad that it won't compile? Or will the code run with some errors? Or is the code just inefficient? Maybe gas consumed should be an instance variable? Or is it inefficient in a different way? Maybe miles driven should be a local variable. Okay, have a look, and if you like you can try it out in BlueJ. Now actually, when you try to compile the code, you'll get an error. The error is somewhat curious. It says that gasInTank might not have been initialized. So, the error here was that gasInTank, by putting the word double here, has turned into a local variable. Not the instance variable that we intended. Let me show you another useful way of thinking about instance variables. When I get a compiler runtime error, the first thing I do is likely look at the screen and say, darn, it why isn't this right? But I move forward and the second thing I do is tell myself, hey, you can fix this. You get this code, you wrote this, you know where you can find the problem. So, I usually try to comment out certain areas of code or build use cases for it to try to narrow it down. And then, solve the issue within that one part of the code. The third thing I do is I usually get really frustrated by that point, two or three hours later, and I say, I can't do this anymore. Where do I go? So, I try to look at some documentation or I try to look at some tips. And I specifically go and ask some friends for help. The fourth thing that I do is usually I probably solve it by then. So, I give myself a pat on the back and say hey, you can do it. This is awesome. And I learn something, and I write it down. I take a mental note of it so that next time I don't make that same mistake. When you implement a method, you can make use of a special variable called this that references this very object on which a method is called. Here's what I mean. Look at this method call. It has an argument, number ten, and that argument gets copied into this parameter variable. So now distance is ten, and whenever you use distance, that means ten. Now, when you look at this car, it really has two ingredients, the number ten but also the particular car. And every method in Java has a secret parameter called this that's not actually declare in the method but, in any call, it references the object to the left of the dot. Now, what's the use? If you like, you can add this in front of every instance variable. Let's clean it up a little. So, now it becomes very clear that it's the miles driven of this car that are set to the miles driven of this car plus the distance. And the distance was a parameter variable. It's optional to use this but some people like it a lot because it makes it very clear, which are the instance variables and which ones are local or parameter variables. A bit of terminology by the way, this is sometimes called the implicit parameter because it's never declared. It's implicit in the definition of a method. And a parameter such as this one here is called an explicit parameter. Why don't you give it a try? Here in this drive method, go ahead and add this everywhere that your allowed to do so. How many times did you get to add this and did you like it better this way? No wrong answer, I'd just like to know. There are five places where you can add the this reference, for the instance variable miles driven, for the instance variable miles per gallon and twice again for the instance variable gas in tank. It is actually pretty nice. Right now, you can clearly tell which ones are the instance variables, and which ones are the local variables. So yeah, I kind of like it. then again, it does make the code longer. That's not so good. I'm obviously conflicted about whether it's a good idea or not. Some people really like it, some people don't like that the code gets longer. Now, Sara will go over with you how the, this reference can be useful in a couple of other cases. Java code has a special way of saying things like me or my. It's this. We have this reference. The this reference can be used to distinguish between instance variables and parameters. Or local variables, which only belong inside the method. This, no pun intended, solves a problem that we had earlier. Remember in the constructor for the person, we had to give the parameter this odd name, aName. If instead of using aName, we had just used name, then this code would look like this, which won't work. If we name the parameter the same as the instance variable, then this one just assigns the parameter. The value it already has, nothing changes. But you can access the instance variable using this. If you write this.name equals name, then you'll assign the value of name, the parameter variable, into the instance variable. In Java, local variables and parameter variables are considered first when looking up variable names. We say that a local variable shadows an instance variable. The instance variable is hidden in the shadow of the local variable. And to find the instance variable again, you need to use this. This dot name equals name means set the instance variable name to the value of the parameter name. Now that you've heard of the this reference, open up your code for drawing the lines between people. Remember how we had to make up these special names, xCoord, yCoord and aName, to avoid bugs from shadowing. You wouldn't have called it that at the time but that's what we were doing. I want you to rewrite this constructor to use name, x and y, for the parameter variable names. Here's how I would fix the constructor. aNme would change to name, xCoord would change to just x, yCoord would change to just y. I have to change aName here, xCoord and yCoord. And now I need to make sure to write this.name equals name, this.x as x and this.y as y. I compiled and got no syntax errors. And when I run the program like I did before, the picture still looks fine. You can also this to call methods. Here's an example. I created another method, makeMutualFriend, in the Person class. Because a lot of the time when I make a friend with someone else, they also make friends with me. In the method, I add someone else as a friend and then they add me. This is an example of calling one method inside of another method. Here I call addFriend on the current object from inside the makeMutualFriend method. I also call addFriend on the front parameter until it add this object as a friend. In the first method called the impressive parameter Is this object. It's the same as the implicit parameter of makeMutualFriend call. In the second method call the implicit parameter is the friend object. If I remove this dot in front of addFriend here, we would now say that this method call is without an implicit parameter. A method call without an implicit parameter is applied to the same object, so addFriend, friend is the same as this.addFriend, friend. Which way you write it is up to individual preference. I'm using the this reference in other more interesting place here. I'm using it to pass the current object in as a parameter, so when addFriend is called on a friend, It'll know who to add. Now that I've explained how the makeMutualFriend method works, it's your turn. Can you use the this reference to implement a method mutual unfriend. Mutualunfriend, will take a parameter. The person this person fell out with, and remove nonfriend from this person's friends list, and remove this person from the nonfriends friends list. This is your last exercise before the summary exercise. When you look at the world around us, you see many people probably on their cell phones or their laptops, somehow incorporating technology in their lives. I think it's really important for everyone to learn technology or to learn programming specifically because so much of our world is based upon it. Not everyone is going to become a programmer and that's okay. But it's really important for people to understand the basic principles upon which our world is built. In the last lesson, we implemented several classes but their behavior was pretty simple. But, what if we want to do something a little bit more complicated, like the day class? In that case, you'd need to know more about working with numbers and Java. That's what we'll cover in this lesson. I think I work with text more than numbers when I program. Well, actually, that's what I do too and we'll cover text processing, as well. In this lesson, you'll learn what java has to offer for working with numbers and text. My name's Ingrid Avenda単o and I'm an intern at Jawbone. I'm, I've been going to school for art for three years and then I switched over to electrical engineering. The reason I started that was it started off as a bet with another friend and then the notion started off that I couldn't learn how to program. And I kind of feel a little bit spiteful, and be like no I can do this, I, I can prove them wrong. I, I signed up for, or into the computer science course and that whole semester like it was really, really like terrifying to get into. Because I had no idea what I was doing, but by the time finals rolled around and I'm just. The whole semester had passed where I'm like, I can't do this, I don't think I can do this and I got my final grade. And then I was like, wow, I actually enjoyed this. Which was kind of something I wasn't expecting, but after that I kind of decided, you know what, this is something that I haven't enjoyed in years. Just having challenging problems that, like I'm excited to sit there and program for hours. I'm like I'm going to solve this, I'm going to do it and so I decided I had to do something different and I decided well I'm going to try to do electrical engineering. Its a little bit more hands on with hardware. But I still got that programming element. So that's what leads me to do an internship at Jawbone and I've been doing three years of electrical engineering at the University of Pittsburgh. Hello, and welcome to Lesson 4. In Lesson 4, you will be working with numbers and with strings. You already know that you use integers for whole numbers and the type called double for numbers that can have fractional parts. So far, that seems pretty easy, but there's some things that you need to know so that you stay out of trouble. Let me give you an example. Have a look at this statement over here. We initialize the variable one million with well, one million. We multiply one million by itself, that gives us one trillion, which is a number with a lot of zeroes. And we put this into mystery, now you can already tell that something is going to go wrong. Otherwise, I wouldn't have name this variable a mystery. So go ahead, fire up BlueJ and type these statements into the code pad. Or if you prefer, use the Udacity ID. When you're done, tell me what you got for mystery. Wow what I got is this value here. Seems hard to believe so let me show you how I did it. Here is the code pattern in BlueJ. I defined my variable one million. I defined mystery as the product of one million by itself and I asked BlueJ, whats mystery and here I get this very mysterious number. So what's with that? It looks like we need to understand a bit more about number types in Java than just the difference between integers and floating point numbers. You've just run into the phenomenon called Overflow. Just like a glass of orange soda can overflow when the foam goes wild, the same can happen with integers. The largest integer that java can represent is this number over here. don't worry about the exact number, but you do want to remember that it's about 2 billion. When a number gets larger than 2 billion in change then java can no longer hold the value in an integer, and the most common remedy is to use the double type. Give it a try. Here, one million is typed as a floating point number, as a double. Now multiply it by itself, and what do you get for mystery? Well, when I tried it, I got 1.0E12, that's Java's way of using scientific notation. 1.0 times 10 to the 12th. That's a 1 with 12 zeros. So, in this case, changing from integers to floating numbers solved our problem. But it's not always that simple. With floating point numbers, you sometimes run into the issue of limited precision. Look at this example. Go ahead, try it out, and tell me what value do you get for total price. When you're done, just put your answer here. The problem here, is that the computer, works internally in a different number system called the binary number system, and there's no exact representation for 4.35 in that system. It's kind of similar to your pocket calculator. When you divide ten by three, you get 3.3333 and so on. And then when you multiply again with three, you would get 9.999999 and so on. And the reason is that there is no exact representation for the fraction ten over three in the decimal system. Now as programmers, we don't usually worry about the detail reasons why these round of errors occur, we just have the general intuition that floating point numbers are a little bit fuzzy. Just like the fuzzy photo over here, you can't quite rely on every last pixel. So when you get a number like 434.999 and so on, that's just something we have to deal with. Now, in this case, if we don't want to lose any pennies, the remedy would be to use integers and work in pennies. If this had been 435 pennies as an integer, a 100 times 435 would not have been a problem. There are several other number types in Java that you may need in more technical situations, we've prepared a fact sheet for you. Go ahead, read through the worksheet, and then work with Sarah on a few quiz questions Choosing the right data types for your variables can make or break your programs. We've prepared a fact sheet on numbers for you that tells you what number can be represented in each type. Check out the link below and then write variable declarations for each of these variables by matching them with a type and a literal. Write an appropriate type: int, long, or double in these boxes. And an appropriate literal: 123, 1.23E2, 123L, or 123., in each of these boxes. There may be more than one right answer for some of these. The visitor count for a small doctor's office today would be relatively small. So, we can probably get away with an int, and we would write that as 123. The number of gallons used could be pretty much anything. We don't know what it's being used for, so it could be two or 2 million. It probably doesn't have to be an integer. You could have 2.5 gallons of water. So, this should be a double, and we could write it as 123 point or 1.23E2. Either one of these would work for initializing this variable. PageViews, or the number of pages of a website viewed by users this quarter, could be a very large number. Think about how many YouTube videos get watched. But it has to be an integer number because it's a count. So I would use a long. And when you initialize a long, you would use something like 123L. Half-life, a measure of how long it takes a signal from a radioactive oxygen isotope to decrease by half is another double. There's nothing to guarantee that this would be another integer value. We could initialize this again using 123 point or 1.23E2. And for this case, and also the gallons case, we could have just written 123. That would work as well. You've now seen the integer operations and it's time for the fine print. After reading the fact sheet, what do you expect a to contain? How about b? What about c? Try out the code in BlueJ. What do you actually get, in b, in c. These should have given 42, 16 and 4. This last one should have surprised you if you haven't coded before. Mostly Java follows the same rules that you learn in algebra. Here x is 3 and y is 4. Multiplication happens before addition and then we add 4 to 3 and get 7. 2 and 4 gives us 6 and we multiply it to get 42. It's possible that your algebra sense took over here and you read xy as x times y. But it should actually be 11 because xy is a variable. Then y over 2 and 3, 3 and 2 and 11 gives us 16. For this last one it kind of looks like Java just miscalculated. I would've expected this to be 4 plus 5, which is 9 over 2. Which would be 4.5. Let's go back to [UNKNOWN] to talk about what happened. You just worked with Sarah on a few questions on arithmetic operations. But I want to talk about the somewhat trickier aspect on how to do division with integers. Let's say I have a piggy bank full of pennies, and then I want to know how many dollars do I have. In Java, I can computer that with a division operation, and there's a bit of a catch. When both operands on the left and on the right hand side of the division slash our integers, then the quotient is formed, and the remainder is discarded. Mathematically, 435 divided by 100 is of course 4.35. And then, the 0.35 is gone. The leftover is 4 as an integer. And that number here is now saved as the dollars. That's just what we want, right? 435 pennies is $4. What if we also want the pennies, for that we have a different operator called the modulus operator, and we often just pronounce it as mod. By the operand on the right, let's try that out with 435. 435 divided by 100 is 4. So, there's 4 times 100 going in here. When we take those off, we're left with a remainder of 35. That was no longer divisble by 100. That's what the remainder operator yields. You can see that by making an integer division by 100, and then also a reminder operation with 100 then we get the dollars and the cents value. Now, it's time for you try this tell me what is. Pennies integer divided by ten and pennies mod 10. Pennies divided by 10, it's 43, because we have 435 divided by 10. That would be 43.5. The 0.5 is erased. We're left with 43. Now that means we have ten times 43 of 430 accounted for. And the remainder is 5. In general the remainder by 10 is always the last digit of a number. That's a useful fact to remember. Now that you've seen some of the quirks of math and Java, and why they happen, it's time to practice writing your own Java expressions for math calculations. We started a class for you that has a method for each of these expressions. Can you fill in the Java code for each of the methods? There's a test program you can run to test your work as you go, because these are a little bit tricky. Initially, if I compile and run the tester, all of the methods are actually returning zeros. Let's fix the amdahl Speedup first. Right now, it's returning 0. What if I just write it in sort of the way it is? Now, if I run the tester again, I'm getting an actual of 2.875. When I expected 1.6. I think I'd better go back and fix it. Right now, this is doing the divisions first, so 1 over s, and s over n. And then the additions and subtractions in the middle. And there's no real sense of the fraction that we started with. This whole piece From s to n should stay together in the denominator, and the 1 minus s needs to stay together in its numerator. Let's try this again. Alright, looks like Amdalh/s speed up is working, but we still need to do the cross ratio. I'll try doing this sort of naively again. I've written this as it looks but flattened it onto one line. So, if I return this quantity and I compile I'm getting an error, unexpected type, required class found value. This error probably doesn't make a whole lot of sense to yet but this is a little hint of what's to come. A pair of parentheses like this immediately followed by some other quantity has another meaning. In particular, if you put a type in here instead of an expression like a minus c. What I need to indicate is that I want to multiply, and I'll need to do it over here as well. And now if I try to run the tester again I'm definitely not getting right answers for the cross ratio. This is because when we have a bunch of operators with the same precedents Travel will just start from the left and move to the right so instead of computing a minus c times b minus d over in parentheses b minus c times a minus d. This will do a minus c times b minus d divided by b minus c and multiply that entire quantity by a minus d. What I need to do here, is group the denominator. I could also group the numerator, if I really wanted to but it wouldn't make much of a difference. If I compile again, and run the tester, I've now got two methods working right. Now for the average. I might try retuning the sum of all of these, all divided by four. Let's see how this works. If I run the tester, it looks like it works in one case, but not in the other. Let's look at the second case. I'm going to go read inside of the tester. The case that isn't working is when we try to take the average of 3, 4, 3, and 3. We should, in fact, expect 3.25, but it looks like we're losing the decimal. Java is interpreting this as integer division, because 4 is an integer, and a, b, c and d are all declared as integers. There are a few ways I could fix this. I could write 4 as 4., or 4.0 And then it would get the right answer here. Or I could actually change all of these ints to doubles, and then I wouldn't actually need to specify that the 4 was a double. I can compile this and run the tester, and it still works. That's because if any of these variables are a double, this whole expression in parentheses is going to come out as a double, and a double divided by an int doesn't need to be done with integer division, that calls for regular division. This is a really easy thing to mix up. It looks right to us, but the computer's going to read it wrong and the compiler won't warn you. When we ran this with all ints and no doubles we saw that it ended up being a run time error. This is a good example of why it's helpful to think about what you want your answer to be beforehand. Calculate a couple examples and then write your code. Good book on this quiz. So when learning like order of operations. That was something that I never really thought twice of, especially you know when you're a kid and you're in the math class and then you're in high school and college. And I mean you're told that there's different order of operations but when you're programming it's a little bit different because then you know you've got you know doubles and ints and floats and that's something that like off the bat, like I kind of struggled with, like sometimes my, like I would run my code and it would work, other times it didn't work. And I ended up learning that one of the most important things is being able to know the answer before it comes out and understanding how that answer works. And understanding the sequence like the operations like, what, what different things would work and what wouldn't work. And, one of the things for me, like, you know, even just sitting down with a piece of paper and understanding, okay, so if I divide by an int, will I get an int back. Like, if it's a double that I was dividing by. Like, what, what's the actual way to do this that's right. And then if that something wasn't right, I really needed to work hard to understand why at first and now, I mean, it's more instinctive that I like, I'll, I'll even write it not thinking twice about it. But, when you're learning this, it's something that, like you don't realize is actually important to keep things, I guess together and concise. Something like that. Let's put to work what we learned about arithmetic with a pretty interesting problem. The digital camera in your smart phone takes pictures where a red green and blue values can be any number between 0 and 355. That's 256 possibilities for red, the same for green and for blue and that's millions of possibilities, giving you pretty big files. Now here on planet Earth that's not a problem. But here on our rocket ship that's exploring a distant planet and it wants to send photos back, maybe a less arrange of colors would preferably suffice. So, I'd like to cut down this range into the much smaller range from 0 to 5. And I'd like to do that in a uniform way. What I mean was that if I look at the interval of numbers between 0 and 255, that approximately 1 6th of them should amount to 0. The next 1 6th to 1, the next 1 6th to 2 and so on. Here's a way of doing that. First multiply by 6. And then divide by the length of this interval. Then all the numbers in here will be 0, all the numbers in here will be 1, here they will be 2 and the the last region there will be 5. Now I'll give you a number of choices for the Java code for doing this. And I'm asking you to pick the right one. This one here is the correct answer. Let's see why. The first two can't be right, because we're multiplying with a decimal number here. And then when we divide, we're not going to get an integer. We're going to get some fractional number, 0.0 and a little bit, 0.9 maybe at this end, and so on. But that's not what we want. We wanted to reduce these, this range of integers to that range of integers. So it's gotta be one of these two, and now the question is do we divide by 256 or do we divide by 255? And it doesn't seem like it would matter much, but it really does, namely if value happens to be the very last element, if it happens to be 255. Then this equation wouldn't work, 255 times 6, again, divided by 255 would be 6, and we're only supposed to get values between 0 and 5. All right, here we have the formula, and now it's time to put it to work in Java. You've just seen how to take a value between zero and 255 and change it to a value between zero and five, so go ahead and do that. Then multiply by five so, you get a value that's one of these six. The reason to multiply by five is, if you just left the zero to five in place, then all of the colors would be almost black and you wouldn't be able to see them. So, here what we've done is we've taken a large color range, turn it into much smaller one and then spread it out again into the original range. Now remember you have to do that separately for the red value, the green value, and the blue value. So, go ahead and complete this program. All right, here's what I did. I first of all computed the reduction 0 to 5 that you've seen just a few minutes ago and multiply that by 51 to get one of these six values. That's the job for red. It's the exact same for green, and for blue. Let's try it out. When I run the program, I can pick an image. I get to see it before the change is applied. And when I click on OK, then the change is applied. And when you look carefully, you'll now see that the image looks coarser. It has fewer colors, for example, in this range here. Now fortunately, my cat Eliza isn't on a distant planet. But if she was, then it would take far fewer pixels to send her image to me. The exact equations that we just used aren't really important to remember. But the point that I wanted to make is that even though integer division doesn't sound like the most interesting thing in the world. It can be put to good use and give you a fun application. Go ahead and practice that a bit more with Sarah. So I'm thinking about Sally Ride again. On June 18th 1983 she became the first American woman to enter a low earth orbit. I'd like to sort of mentally recreate that day, so let's start with something relatively simple that we can do. What day of the week was that? I'm going to assign numbers to the days of the week. So Sunday it'll be 0, Monday will be 1, Tuesday 2, and so on. Write a program that takes a date and tells you what day of the week that was. You'll need a reference day to start with, so I'll tell you that January 1st, 1900, was a Monday. You'll want to write a program that uses this fact to count the right number of days To get to the right day of the week. You can use the fact that January 1st, 1900 was a Monday in your program. Before I write the code for this, I want to work it out for a couple other examples. Probably the easiest example would be January 2nd, 1900 since I know that would be a Tuesday. I can calculate the days that January 2nd is after January 1st, by using the daysFrom method on the day object. In this case, it would give 1. Now, the day of the week would be the reference day plus the number of days that we are away from it. So, in our case, Monday, plus the number of days after. And this will work for this case. But if I take a slightly farther away case, like January 8th, 1900. I know that would be a Monday again. But it's seven days after. So, I would get that it was 1 plus 7, which is weekday 8. Weekday 8 doesn't exist. We only have up to weekday six. So, what I really mean to do is start on Monday, and add seven days. One, two, three, four, five. Six, seven. So, instead of continuing up to, day 7 and day 8, I go back to day zero and up to day one. So, that means that I'm using mod. In this case mod 7. So, the uncorrected value in that case would of been 8, and to correct it, I would calculate that the actual day of the week was the original one, the uncorrected one, mod 7. The first thing I need to do is create a day for the reference day and I'm actually not going to use birthday in this case. So, this is actually the wrong way to do this, because I might want to use this program to calculate lots of different days. While I'm testing, I'll make this an easy day, like I just mentioned so, January 8th, 1900 and I'll set up my reference day. So, now I'm going to calculate the days between the referenceDay and the desiredDay. Using that good old daysFrom method and now the uncorrectedWeekDay would be the weekday of the referenceDay. I'll call is referenceWeekDay. Which is a Monday, plus the number of days between the referenceDay and the day we're interested in. And now to get the correctedWeekDay, we take mod 7 from the uncorrectedWeekDay. Lets check if I made any mistakes. I'm pretty sure that my answers should be Monday, that was what I calculated before. Forgot to say that this is a day. And that one too and the referenceWeekDay was an int and I can't find a variable weekday. Because what I called correctedWeekDay should actually just be weekday and that one should work better. So, now if I run the method, I get that weekday is minus 6. Must be a bug. So, where could I have gone wrong? Somehow I got a negative number here. I must have got a negative number because referenceWeekDay plus daysBetween is a negative number. ReferenceWeekDay is definitely 1. So, daysBetween must have been negative. It looks like referenceDay.daysFrom desiredDay is a negative number, but I'm here assuming that I'm using it to count up. I'm going to check that using the debugger. I'll put a break point in and I'll run the method. So, when I step over the line where I initialized daysBetween, I can now see that daysBetween is coming out as negative seven. So, my suspicion is confirmed. Instead of calling referenceDay.daysFrom desiredDay, I should have called desiredDay.daysFrom referenceDay. Let's try this one out. Now I actually get the weekday I expected. And I'm ready to go back and reset this day to the day I was interested in, which was June 18th, 1983. Looks like Sally Ride entered low Earth orbit on a Saturday. What if we wee painting all of the spaces in a checkerboard, and we were painting them blue and red? When we're drawing this rectangle we need to figure out whether it's going to blue or red based on the number of its indexes. We want to write a method that takes the row and the column of a space, and then gives us a one. If the space should be red and a zero if the space should be blue. The public interface of this method might look like this. So, we need some mathematical expression which takes a row and a column and gives back a one or a zero. If the row and the column are both even or both odd, you should get back a zero. If the row is odd but the column is even, then you should get back a one for red. And if the row is even but the column is odd, you should also give back a one. In the checkerboard project that we provided for you in blue jay, you'll want to implement checkerboard painter, and write a test method in checkerboard painter tester. Try running the main method of painted checkerboard. Once you've finished, if you need a hint, think about what happens if you add an even number to an odd number. Do you get an even number or an odd number? This problem could get pretty complicated, so let's write some test cases out. I'll index spots by row and column. So 2, 2 would be right here, and that spot should be blue. So, we need an expression that when given 2 and 2 gets 0. The spot 3, 3 should also be blue. So again, we need a zero. 2, 3 should be red. So, that should be a 1. And 3, 2 should be red. So, also 1. So, what's an expression I could try to use to turn 2 and 2 into 0, 3 and 3 into 0, 2 and 3 into 1, and 3 and 2 into 1. It kind of looks like maybe I'm taking the mod of these and adding that together. So, row mod 2 plus column mod 2. Let's see what this gives in each case. 2 mod 2 would be 0. 0 and 0 gives 0, so that's good. 3 mod 2 is 1 and 2 mod 2 is 0, so that gives 1. The same will happen here. This one doesn't quite work. 3 mod 2 is 1 and 3 mod 2 is also 1, so I would get 2. But then maybe if I just mod the whole thing by 2 again, then I would get 0 which is the same. The 2 would turn into 0 and the ones would stay. So, this expression might work. Let's test it out in BlueJ. First, I'll check my test and put some actual values in it. The test cases I came up with were 2, 2; 3, 3; 2, 3 and 3, 2. For 2, 2 I expected 0, and I expected the same thing for 3, 3. At 2, 3 I expected 1, so 1, and at 3, 2 I also expected 1. So, my tester should be good to go. Now, I'll try putting that expression into the actual program. In the checker board painter, instead of returning five, I want to return row mod 2, plus col mod 2, and then all mod 2. I don't have to put these in parentheses because the plus has lower precedence. And let's try it. If I run the tester, my actual and expected values match up. But could we make this any simpler? What if I noticed that adding an even number plus an even number gives me another even number. And an odd number plus an odd number gives me another even number, but odd plus even or even plus odd both give odd numbers. Then I can just add row and column, and take the mod 2 right at the end. Because if they match, their sum is even. And if they don't match, the sum is odd. So, I'll just get rid of the mod 2 and the mod 2. If I change it in the checkerboard painter, erase that and erase that. What will my test say? Is this still the same? And if I run the test again, still works. As a bonus question, what if instead of returning 0 when they match and 1 when they don't match, I wanted to return one when they match and zero when they don't match. How would you do that? I won't go over it, but it's something to think about. Well hello again. Remember a while ago we had that fancy cat food, $4.35, a jar. And then we did some computations, and there were round off errors, and I said, oh, just convert it to pennies. I guess like this. Go ahead and give this a try. Does it work for you? Or do you get a compiler error? Or are you off by one penny? Or do you get something that's almost the right answer, but off by a few fractions of a penny? Do it yourself, and let me know. When you try this, you will get an error. And the reason is, that the type of 4.35 is double, and any time you do arithmetic and one of the operands is a double, then the entire value is also a fractional number. And the Java Compiler will not let you move a double value into an int variable. That's a bit of a pain. Here is how you convince the Java compiler to do it anyway. This is a very strange syntax, whose origins are somewhere in the mist of time of programming languages and we won't dwell on that. But here is what you need to do. This value here, is of type double. Now we don't want it to be in double. We want it to be in integer. And then you have to put the name of the type that you want and, put parentheses around it. And put it before the expression you want to convert. What now happens is, this expression here is computed. The fractional part is discarded. The integer part, is moved over here. This operation is called a cast. That's a curious name, are we casting out a fishing rod? Is it cast around a broken a foot? The cast of characters in a play? Well I guess it's mostly like the latter, becaues we have this value here. That actually is a, fractional number and we want to cast it, not as the hero in the play but as an integer. Whatever, that's just what it's called. Every once in a while, you need to do this. You have, something that's not of the type that you want, you want to change its type and, the cast notation does that for us. Go ahead and do this computation using the code pattern BlueJ. What answer do you get? Well, if you actually tried this, you will see that you get 434. That's a little unfortunate. The reason here is if you remember that 4.35 times 100 because of round off was 434.99 something. And the 0.99 something is the fractional part, and that was thrown away to get this integer. To really do this right in Java, you have to use a pretty arcane formula that's in fact so arcane that I have to look it up. You use a mathematical function called round that gets you the closest integer. So, 4.35 times 100 may be 434.999. But the closest integer to that is 435. And then, for reasons that are too depressing to have to get into, you still have to cast that into int. We have a fact sheet that you can consult if you actually run into this situation. The round function here is one example of a mathematical function. There's a bunch of them, and we'll take them up soon, but first let's do another programming exercise. So, one of things when I was learning how to program was casting. And that was something that [LAUGH] I feel like I learned casting a little bit later than everyone else because its just that it was very foreign for me to really understand like how everything was set up initially. And so when I learned about like you know oh I have variables. I got that. Okay? So, there's variables. But then you know, you've got ints you've got doubles, and that, that was one of those things I didn't understand the importance of it. And for a while I kind of dismissed it as like I don't want to ask for help, like it's okay. Like I'm just going to, I'm just going to go right through this, and then I'd have problems where I'd be running my code. And then like all of a sudden I got a crazy long number back and I'm like what did I do wrong? The person next to me just got six. How did I had, how did I mess up here? And the email was one of the thing that's like, I think my pride was a little bit got in the way, I probably should have just like, hey, why isn't my number working? By the time I understood, like the difference it's like a whole number versus like you know, number of the decimal like the know like oh, I get it, like. Now, it's just, like, instinctive. Like, whenever I'm, you know, writing something, like, I know which number like, what kind of custom I have with it. And it's those little things that, like, they kind of stand in the way, at first, where it's, it's silly looking back but, I mean once you get the, like major concepts down. It's like, you wouldn't even think twice about it. It's like, I've got a hand and well, I've got an int. [LAUGH] In the olden days, cameras couldn't record glorious color, they only had grey. And sometimes we want to take a photograph and turn it back into grey to give it that old fashioned effect. Now, you might thing that all you'd have to do is average the red, green, and blue values. But it's not quite that simple. As it turns out, the receptors that we have in our eyes have different sensitivities to colors. And what you actually have to do is take the red, green and blue values weighted by these factors, and then turn them into grey. And then, when you're done with that, you can set red to these value green and blue, because they're all the same, that's what makes the color grey. And then, you're done. But we have the same problem that you just saw. Red, green, blue are integers. These weighing constants are fractional numbers. So, the whole expression is a fractional number. And I want to put it back into an integer. So, the solution is again, to inject a cast, put this expression in parentheses and put parenthesis int before that. And then, you get it truncated down to the nearest integer. Once again, I'd like you to try that, so you can see it with your own eyes. Go ahead. Again, in the color class, implement a new method. In this case, it's the turnGray method. Take the red, green and blue values, combine them to a gray value using the equation that you just saw. Make sure that you get an integer. And then, take that integer and put it back into red, green and blue. Go ahead and do it now. Here, I'm computing the weighted average of the red, green and blue values using these funny numbers. By the way that can work, the result here is a double because it involves fractional numbers. And I can't put a double into an end, that's where the cast comes in. Now I have my gray value. And I stick that into red, green, and blue and I'm done. Lets check it out. Here is Eliza in color and here she is in black and white like in the olden days. That's pretty nifty and it shows the reason to worry about casts. We had a situation where we had a decimal number expression that we needed to put back into an integer. Sometimes basic arithmetic isn't enough to solve a problem and you need to use one of the many math functions that Java has to offer. In fact, there's so many that you couldn't possibly remember them all, and we prepared a fact sheet for you. Let me just go over the most important one. Let's say you need to compute a power such as 2 to the 10th. You can't write that exponent neatly in Java, instead you use a function and the syntax looks like this. The function name is pow, it's in a class called Math. You have to reference it as Math.pow. Then, you give it to the two operands, the 2 goes here, and the 10 becomes the second one. If you need to compute the square root, you use the square root function. Again, it's in the Math class, Math.sqrt, and whatever it goes inside the root symbol in Math notation goes inside the parentheses here. For absolute values, there is another function. It's called abs and whatever you put between the vertical bars in Math notation goes on inside here. Now, these kinds of functions come up often enough that I want you to practice this a little bit. Here, I have a bunch of function calls, and I'd just like you to tell me for each of them, what is the result? If you like, you can compute it in BlueJ, or you can just do it in your head. Now let's see here, 10 raised to the 3rd power, that's 10x10x10. That's 1,000. The square root of 4, well 2 times 2 is 4, so that's 2. The absolute value of 3 minus 5, that's the absolute value of minus 2. Absolute value takes away the minus sign, and that's 2. Intuitively, what it means it's the magnitude of the distance to go from 3 to 5. So you have to go two steps, you use the absolute value, so that the direction doesn't matter. The absolute value of 5 minus 3 is the same as the absolute value of 3 minus 5. It's just the distance between these two values. Now, I've tossed in a couple of others just to see if you can guess these. Min and max are the smaller and the larger of these arguments here. So the miniumn of 300 and 255 is the smaller one, 255. The larger one of zero and minus 1. Well, zero is pretty small, but it is larger than minus 2 so that's zero. And our next image processing exercise will put min and max to good use. I'll show you a nifty photot that needs math function to work. We want to take any old photo and make it appear as if it happened at sunset. And the idea is simple. We'll just add some extra red, like this. But there's a potential problem. What if red is already 255 or close to it. Then if we ad 25 to it, then we'll get a value that's larger than 255 and that won't work. So I want red to be red plus 25 but at most 255. And one of the math functions that we've just seen will solve this for you. I'll even give you a hint. It's either Math.max or Max.min. So go ahead and implement the redden method in the color class and then try out the effect. Okay, let's work through this together. We want to add 25 to the redness, but we don't want it to get larger than 255. So, do we want to take the max, or the min? Do we want the larger of 255 plus 25, or do we want the smaller? We want the smaller because we never want it to get larger than 255. And that's the answer. Let's run this program. Here's the original image, which I took around noon. And here it is transformed into a beautiful sunset. And thanks to our friend mass dot min, none of the colors overflowed. Like I said, these math functions can be pretty useful. Now, there's just one little blemish to the program that we've just written. It uses what programmers refer to as magic numbers. Look at this line over here, and it begs to question why 25, why 255? Those look like values that a magician picked out of a hat. Instead of using magic numbers, it's a good idea to use constants. Here is how you do this in Java. The keyword, final, indicates a number that can never be changed that has assumed it's final value. Or like we would say in math, it's a constant value. So here, are the 25, I'll call it added red and the 255 here, called max red. I defined these as variables just like you would define any other variable, except for the keyword final in front. And also, it's a convention amongst Java programmers, that constants should be written in upper case. Maybe with an occasional underscore. Now, go ahead and rewrite the statement here, using these two constants instead of the magic numbers. And put your answers into this box. Here's what it should look like. Note that instead of the 25 we use the constant. Same for the 255 here and now when you look at the whole thing it reads pretty nicely doesn't it? We take the smaller of the original red plus the added red and the maximum. No more magic is involved. You always want to do that in your programs when you find yourself using numbers. whose meaning is not totally clear, just make them into constants. You've written a lot of interesting programs already and that's great. But one capability that was lacking so far was to be able to ask the user to supply input. Here's how you do it in Java. Just like you use System.out for output. You use System.in to get input from the user. But as it turns out System.in is not very smart and to really read numbers and strings from the keyboard you use an object of the scanner class. You construct a scanner with a new operator, new scanner and this is the scanner that can read from System.in. Usually, you want to read more than one input, so it makes sense to save the scanner in a variable. Here it is. It's called in and of course it's of type scanner. Then, when the time has come to read something you call one of the methods of the scanner class. Here, I called the nextInt method. It reads an integer that the user types in. And returns it, and here I'm saving that integer in the age variable. So, you should think of a scanner, kind of like a supermarket scanner, except a supermarket scanner of course reads a bar code. And our scanner here reads something from the user, and also produces some number. The program snippet that I've written here is not quite complete. After all, how is the user supposed to know that then I'll ask for their age. So, before calling a scanner method that reads user input, you always want to alert the user first with the statement such as this one. The string here, how old are you, is called a prompt string. It prompts the user to then take the next step and provide an input. Note that with the prompt string, we put a blank space here, that just looks prettier, so that the users input is a little bit separated. When you print the prompt it looks prettier when both the prompt and the user input are on the same line. That's why we're using print and not println here. And then, you want to have a blank space to separate the prompt from the user input. Here, we write an integer, you can also read a decimal number by calling nextDouble that returns a double. And again, you would then want to capture it in a variable. Let me demo this in BlueJ, so you can see what it looks like before you get to try it yourself. Here, you can see the declaration of the scanner. Here, we are reading an integer. Here, we are reading a decimal number. And before we read anything, we have a prompt. One prompt for the age, one prompt for the weight. Finally, there is an important piece that you've not seen so far, look up here. This is what's called an import statement. As it happens, the scanner class is in a different location than the classes that you've used so far. That location is called java.util, it's a utility class, and we have to tell the compiler that's the place to find it. Whenever you use the scanner, simply place this statement at the top of your code. Let's go ahead and run this. The console window pops up. Here is my prompt. Okay. I'm going to lie about my age here. Now, if that had been my age of course the program would be right next here. I'd be 22. Not much one can do about one's age. It does increase every year. And I lie about my weight too. But I appreciate the sentiment that hopefully next year, it'll be less. That at least should be under my control. All right. Now, you've seen how to read input, and I'd like you to do it in another program. Remember this program, in which we added the sunset effect to a photo. Now here, we used a value of 25 to increase the redness. It might be nice to experiment with other numbers. But instead of recompiling the program with all sorts of different numbers, let's turn this one into a user input. Now, we can't put the input statement here. Because this method is called for every single pixel, and we only want to supply the input once. So, here's the plan. Take out this constant, and add a parameter here. Then here, in the main method, prompt and read the input here before entering this piece of code. by the way, don't worry about this loop statement here. We're going to be covering that in a couple of lessons. Now, here is the place that the method is called. That's where you should pass the added red variable, so that each time the redden method adds that amount of red. Go ahead and do that now. If you have BlueJ, it would be best if you first develop the program in BlueJ, and then when you're done, put your result into the Udacity IDE. If you don't have BlueJ, that's okay, just do it straight in the IDE. But then you won't be able to supply your own input. You'll have to live with the input that Udacity gives you. Let me show you what I did. I removed this line. I added a parameter, then I used the parameter here. And am I done here? not quite. I still have to document the parameter. Pat yourself on the back if you did that. Now, onto the main method. Here, I want to read the input. So, I declare a scanner and I use it to read the added redness over here, I'd pass that value through the redden method. Now, there's a couple of things that I soon need to do. First off, the prompt, here it is, notice print not print on and the extra space. And finally, up here. I need the import statement. Now, we're ready to go. When running the program, I'm prompted for the added redness. I'm going to go and crank it way up here. And, woah, that's pretty red. Now, the benefit of having the input provided by the user, is I can now experiment with other values, I simply run the program again. And just to see if it works, I'll supply a negative number. And as you can see, now the image got a little bluer, greener, whatever, less red. Now, you know how to read user input in Java. Now that you've seen user input, let's turn to another topic, formatted output. Let me show you why we need to know about it. Let's look at this program here. I want to buy 100 cans of my super premium cat food at $4.35 a can. So, my total price is going to be the quantity times the unit price. So, I'll print it. There's also 8% tax so, here I'm figuring up the tax, and then I'm printing that. Let's see what this program does. Well, look at it. It's ugly, ugly. Here, I expected to see $435, and the tax, you never see tax like that on your store receipt. It would say $34.80. So that's what I want. And by the way, I want these decimal points here to line up. It turns out, that's pretty easy to do. Here, instead of just calling println, we'll call a different method. It's called printf for print formatted, and here, we need to add a formatting string. The formatting string is here, it looks a little arcane. The percent says we're now going to be printing something. The 8 means we want it to be 8 characters wide, the 0.2 means, we went 2 digits after the decimal point. The f means it's a floating point or decimal number. The \n means, and afterwards, please give us a new line. As you can see, there's a whole mini language in these formatting strings and you'll practice a few of them with Sarah, after I'm done here. But truth be told, if you simply memorize this one. Or even better just copy and paste it when you need it. That's 90% of what you need. Let me do just that. So, here again, I'm going to be using a printer. I'm saying I want field with 8. 2 digits after decimal point. Now, when we run the program everything is nice and beautiful. Both numbers have two digits after the decimal point. Both of them occupy eight characters. As a general rule, whenever you display prices, go ahead and use printf. You'll practice that with Sara right now. I'm printing a table and need to format some strings. Help me write the formatting strings for printing each of these values. What width goes here and what letter goes here if I want to print six characters wide? What format string goes here if I want two decimal places four characters wide? And format string goes here. The types of the variables are important. CookiesPerDay is an int. So I'll use percent d and I want the width to be six. Cereal boxes per day is a double so in quotes I'll need percent f. And I wanted to be four characters wide with two decimals. Name of the string and I haven't gotten any special width requirement, so this one is just percent s. I'm actually making the table, because here at Udacity we have a micro-kitchen where we keep shared snacks. And I want to find out where all of the cookies are going. So I'm compiling data and I want to print it out in a table, like this. Can you complete the code in MicroKitchenTable? To print out this table, a couple quick hints, this vertical bar character on an American keyboard is right below the Delete key, right here. You'll need to hold down Shift to make it work. Also, make sure to print a row for me and a row for Cay. I've started you off with some variables for cookies per day, cereal boxes per day for Sara and for Cay. There are multiple ways to do this, but here is the one I chose. I chose to make one printf statement for each row. We want eight spaces with the number of cookies, followed by a vertical bar. Followed by eighth spaces with the number of boxes of cereal. Followed by another bar, followed by the name. I'll need to print all three variables, so I'll include them as parameters separated by commas. The format string will start with int value, so I'll use a d. And it'll be eight wide, so I have 8. Then, that vertical bar, then the decimal value, percent f with a width of 8 and 2 decimal places and then the string. The formatting string will look the same for my row and for cay's row, but I'll use cay's variables instead of mine. Since I'm using this pattern twice, maybe I would want to make a variable for it. And call it, Row Pattern or something like that, but since I'm only using it twice, I'm going to leave it for now. So far it looks like I'm eating all of the cookies on my own. But I haven't surveyed all of my coworkers yet, the answer could change. Now, if I'm going to collect more data, I may want to change my program to use a scanner to take in input and put it in the table. We'll leave that for now though. We've talked a lot about working with numbers, how to compute with them, how to read them, how to display them, and you're written quite a few programs. But there's one important point that I'd like to talk about for a few minutes, and that is, first do things by hand before you open the programming environment. The natural urge of every programmer is to go ahead and open BlueJ, or whatever environment you're using, and start typing code. But that's rarely productive. Let me give you an example problem, and show you how I would work it out by hand. So, here's the problem. We're supposed to be putting tiles white and red ones alternating along a wall, and we are told the total width of the wall. We are also told the tile size. The architect tells us, we are suppose to start and end with the tile of the same color, and the question is how many tiles does one need to order? It's pretty clear that you need one more white tile than the red tiles. But how many clearly depends on the size of the tiles and the total width of the wall. So, let's say that your assignment is to write a computer program that helps the builder with this problem. Like I said, this is not the time to open your coding environment. Instead, do a couple of these by hand first so you get a feel for what the computations really are. So lets say we have a width of a hundred inches and each of these tiles is five by five inches. Note that except for the first tile, the others come in pairs. Each pair is ten inches long. So if I take my width, subtract the 5 inches here then I have 95 inches left and how many 10 inch pairs can I put in there? But if divide 95 by 10, that's 9.5. I discard the remainder, so I know I have nine pairs, and the white one for a total of 19 tiles, 10 white, and 9 red. Great, that's my answer in this particular instance. Now the next step is to figure it out for arbitrary values after which and the tile sides Now that you've seen the computation with specific values, let's do it in general. So what did we do? We started with the width of the floor, subtracted the size of the first white tile. Divide it by the sizes of the pairs, took the integer part. And that gave us the number of pairs. Now that's of course the same as the number of red tiles, because every pair has one red tile. And, the white tile says one more. All right, now, we're ready to program, and what I'd like you to do is to complete the program that we started for you. The program will read as inputs, the width of the floor and the tile sizes. And your job will be to run the computation that I've just developed, and to print the answer. Here's the program for you to fill in. You already give the commands for the input and for the output and your job was to put in the part of the program that asked computation. Now we did this by hand, and let me show you again the formula that we obtain. That's the formula here. So we take the width minus the tile size divided by twice the tile size, take the integer part. Here is that formula written out in Java. Have a close look at the parenthesis. I was very careful to compute the entire expression, then have parenthesis around it, and only then take the integer part of the final answer. Now we are almost home free. The red tiles was the same as the pairs and the y tiles as the pairs plus one. Here I'm running the program and when I supply the same inputs as in the example problem, a 100 inches for the width. Tile size of 5, then I get the expected answer. Now the important part of this entire exercise is to first do it by hand. If you can't do it by hand, you can't program it. And doing it by hand gives you valuable intuition that you need to write the Java code. You'll get to practice this with another example that Sarah will show you. Now you've done a lot of work with numbers and most people think that numbers are what computers are really good at. But truth be told many programmers work more with text than numbers. In Java the technical term for text is a string. Why a string? You can think of text being a sequence of individual letters that are strung together. You have already seen strings. In Java, their enclosed in quotes and there's some text inside. You've seen string variables, here is one, it's called name and it's type is string. You've seen a bunch of string methods and here are a few more. In the interest of learn by doing, go ahead, fire up BlueJ. And tell me what happens when you call each of these methods, or in the last case, when you execute this piece of code. Here are the answers that I got. The length method returns the number of individual characters in the string. There were 7. The substring method extracts a substring that sits inside the bigger string. In our case, it extracted this string. Whenever you want to extract substrings, you have to understand how the positions in a string are numbered. In Java the initial position is 0, that may sound strange but it's actually pretty useful, and then it goes from there. The string has length 7 and the position's in it are 0, 1, 2, 3, 4, 5, 6. That's 7 position's. Now in the substring here you see this 3 here. That is the position of the first character that we want to include in the substring. The seven here is the first position that we don't want to have anymore. We don't want position seven. In fact, there is no position seven. We want the ones from three to six. That sounds a bit odd to most people when they see it the first time. But there is an advantage. When you subtract these two numbers, 7 minus 3, that's 4, and that's the length of the substring that you're extracting. The next method here, the indexOf method finds the position of a given character. So, over here I want to know where does the C occur for the first time. And it will go through and say, that's at position three. And finally, you already seen this plus operator in lesson two. It takes two strings and glues them together or as we like to say in programming is, it concatenates them. So, here is the concatenation of Hello and Udacity, notice there's no space in between because there was no space in either this or that string. If you wanted a space, you'd have to add a space. Strings are really useful when you work with text. Sarah has a couple of nifty exercises prepared for you when you get to work with a rather long text and take it apart. And put pieces back together by using some of the string methods that you've seen here. Enjoy. Being able to modify strings quickly and cleanly is probably the most commonly used programming skill. So let's practice a bunch of these. We're going to be working with the Alice Project. We've given you a program book, which does some magic to read in a book from a file. It's down here, but you don't have to look at it if you don't want to. Check out the link to the fact sheet on string methods, and then use them to complete the methods for this program. Objects in the book class know how to read the text of a book into a string. We've included the text in a text file, you can see it in the directory with all of the code for the project. Soon objects of the book class will be able to return all types of information about the text they include. But first, you'll need to add the methods, starting with this one. Right now, getNum characters just returns zero, but it should be returning the number of characters in the entire book text string. And I mean characters like letters and punctuation, not people in the book. There's also a book tester with a main method you can use to check your answers. Happy coding. >From the cheat sheet, we can learn about the length method. If we return book text dot length, that will return the number of characters in all of book text. If I run the book tester, which might take a second since the book is pretty long, I will get the actual number of characters and the expected number of characters For your next feet of coding magic, I'd like you to write a method that returns the location of the first occurrence of Mad Hatter in the text. I'd also like you to add a line to the tester program, so that it prints the location of the first occurrence in Mad hatter. For this one it's okay if you just print the actual and not the expected. What is the actual value? What is the location it prints? So after the get number of characters method I'll add another method. From the fact sheet we can see that the index of method will help us. We want to return bookText.indexOf Mad hatter. Now we need to add that line to our test program, BookTester which prints out the actual value of Alice.firstOccurrenceOfMadHatter, looks like I capitalized it wrong. Alright, now let's see what this actually gives us. Huh, the actual value is negative one. That doesn't sound like a location. There shouldn't be a minus one character in the book. Let's look at the documentation. In my browser, I'll search for java 7 string and find the official documentation. And then I'm going to look for the index of method. Methods, index of, we're giving it a string. Alright, returns the index within this string of the first occurrence of the specified substring. That's what we were expecting. The returned index is the smallest value, k, for which this dot starts with stir, k. Not sure what that means yet, we can think about that later. If no such value of k exists. Then minus 1 is returned. Okay, so minus 1 means that there are no occurrences of Mad Hatter as we wrote it in the book. This might be surprising. The Mad Hatter is a famous charater. But it turns out, in the book, he's always just called the Hatter, not the Mad Hatter. What if we just want to print the first sentence of the book, including the period at the end? What method would you use to print just a piece of a string, not the whole thing? And at what index does the first sentence end? Here's the text from Alice in Wonderland that we gave you, or at least the first couple of sentences. We could sit here and count to find exactly how many characters come before the period. Or we could use the methods we already know. Implement to get first sentence method. If it's working it should return this. If you're not sure what methods to use to get started, you'll have the link to the fact sheet. To do this, we need to add a method to our book class. We're going to want to use the substring method to print out just the text from the beginning to the first period. So, the first index we should put in is zero because that's the first index of the character in the book, and then we need to find the end of the first sentence. We can do this using the indexOf method that we used before to look for Mad hatter. And now the key here is that substring for the second argument, wants to take the character after the last character to print. So, if the last character we want to print is the period and that's our endOfSentence, we want to give substring endOfSentence plus one. Now in our tester, we'll want to add another line where we test out our new method and compare it to the expected value, which is a little long. So, we'll need to split it across a few different lines. And see how this worked. So, the actual is exactly what we expected and the expected is missing some line breaks and goes to the side for a long time. But other than that, it looks like this is basically doing what we wanted. Now that you know where the first sentence ends, you also know where the second sentence starts. Write a method, public String getSecondSentence that returns a piece of the book, starting after the first sentence and ending after the end of the second sentence. Here's a hint, indexOf has several versions, one of them just finds the first occurrence of something but there are others that are more flexible. Here's our trusty book class again. And we're adding a method, getSecondSentence. Last time we could just use the zero as the beginning, but this time we're going to need to start where the first one left off. So we calculate the beginning the same way we calculated the end. But then start right after the period instead of at it. To get the end of the sentence, we'll need to use a different version of the indexOf method. We're still looking for a period. But now we want to start at the beginning of our sentence, that we're working on. And now we use the sub string method the same way as we did before. And return book text dot sub string from begining of sentence to end of sentence plus one. I added a couple lines to the book tester, so we can actually test our second sentence method, and now I'll run the book tester again. Here's the result. I don't remember the second sentence by heart, let's look at the Alice text again. It looks like the second sentences match, good work. What if we want to know how many times the word Alice shows up in the book. It's got to be a lot right. But is it 20 or 200 or 2000. Next, we're going to write a method. public int occurrencesOfAlice that returns the number of times that Alice occurs in the text. Here is a hint. How much will the length of the book change if we remove all the occurrences of Alice? If we replace all occurrences of Alice with no letters, then the length of the book will decrease by five times the number of occurrences of Alice. Because Alice has five letters. So if we calculate the length of the book with Alice and the length of the book without Alice, and take the difference. We can divide the difference by 5 and get the number of occurrences. So, here again, is our book class with our new method, occurrences of Alice. First, we'll calculate the original length and then the length after we remove all the occurrences of Alice, by replacing Alice with an empty string. Then we return the difference between the 2 all divided by 5. Let's add a line to our book tester to see how many times Alice actually occurs. And if we're in the main method again it now tells us that Alice occurs 395 times. It's not totally clear or obvious that this will be correct, but you could check it a few ways. For example, you could open up the text and use some other program to search for the number of occurrences of Alice. Or you could find some word, that only appears once. Or maybe a string of words so you can be pretty sure that it would only occur once. And try using that to debug your code. I guess that was kind of okay as a one off. But it would be better, if the method allowed us to supply any word, not just Alice. And counted how many times the given word occurs. So, let's write a method. Public int occurrencesOf String word that works for any word. The method to find the number of occurrences of any word is going to be pretty similar to the one for occurrences of Alice. But instead of using specific references to the word Alice, like Alice, and the length of Alice. It'll use the given word, and the length of the given word. The calculation of the length won't change. But the calculation of the length without the word will. Looks like I need to actually take in a parameter. And now I return the length, minus the length without the word. Over the length of the word. Let's add something to our booktester, to test our new method. To check it we could compare it to our answer for Alice. Looks like I didn't actually make a method occurrences of. Ops. Occurrences of Alice. Should be more general. Hopefully now it'll compile better. Here we know to expect 395 from before, and there's another word that we checked how many times it occurs. We saw before that Mad Hatter doesn't occur at all. Let's try this out. Looks like we got the answers we expected. Now that we have this book object and we've tested it, let's put it to use. You're going to write a program that takes a user input word, and tells how many times it occurs. Your code will be able to do this. When you're done with this you'll be able to run look up any word. It'll ask you to type a word and it'll look it up. So, I'll type Hatter and press Enter. And it tells me Hatter occurs 55 times. I'm going to give you some pointers. You'll want to make a new book, like we do in BookTester. You'll also need to use a scanner, don't forget the import. Also, you saw how to read and enter a double, but you didn't see how to read a string with the scanner. You'll need to look at the scanner documentation. Scanner has a lot of methods, you'll want to use one of the ones that starts with next and returns a string. If picking the right scanner method makes your head hurt, click the link that says hints. I'll go over this part in detail in the answer video. So, here's the empty shell of our program. We'll need a scanner to read the user input, but right now the code won't compile. It doesn't know what a scanner is. We need to import java.util.Scanner to tell the program where to find the code for the scanner. That's better. Now, we want to print the prompt. And I remember my colon and space at the end. So that there would be space for the user input and I now read in the word. I'm going to use the next line, I'll explain that in another minute. I'll make my book so that I can use it to do the calculations. And now, I can calculate the number of occurrences and print the result in a nice format. I'm safe I made any syntax errors with all that typing. Sure enough, misspelled occurrences. Thank goodness for the compiler. You saw this run before, so I won't run it again. There is that one question left over though. The next versus nextline. Let's look at the documentation. If I search for scanner and Java 7, go to the official documentation, and then search for the methods. Here they are, there are a lot of them, but here are the ones that start to be nextFloat. And next, nextBigDecimal. All right. The ones that return strings are next, next with a pattern, next with another pattern. Next line, all right. And these look like something else. nextLine has slightly awkward language. Advances this scanner past the current line and returns the input that was skipped. But what this means for us is that the scanner will give us a line of input. So, everything the user types before they hit Enter will get loaded in with next. If I find the documentation for next without the line. Here's next. It says finds and returns the next complete token from this scanner. Wants a complete token. Maybe there's more information. It says, a complete token is preceded and followed by input that matches the delimiter pattern. And then, talks about blocking while waiting for input to scan. You don't need to worry about that part too much. Basically, it's saying it'll wait until the user actually enters something. But this delimiter thing, maybe somewhere on this page it says what the delimiter is. Let's look for it using Ctrl+F. Delimiter. This looks like it's in the summary near the top of the page. A scanner breaks its input into tokens using a delimiter pattern, which by default, matches whitespace. We saw whitespace before, that was things like spaces and tabs that you can't see. I guess that makes sense. So, it gives you a chunk that is separated from other things by something like spaces. So, it seems like next would work fine by default if the user just wanted to search for one word, like Alice. But if they wanted to search for two words, like Mad Hatter, you would want to use nextLine. It kind of feels like our Alice in Wonderland code is done now, but there are a few more things we would want to do before presenting or sharing it. Our book class has a lot of methods: getNumCharacters, getfirstOccurrenceOfMadHatter, getFirstSentence, second sentence, occurrences of Alice, occurrences of something else. But in general we called it book, we didn't call it any thing specific to Alice. We would probably want to fix or generalize, or remove some of the methods that are overly Alice specific. Which methods should we remove or generalize? Write the names of the methods here. We need to fix firstOccurrenceOfMadHatter and occurrencesOfAlice. FirstOccurrenceOfMadHatter should probably be generalized to take in any word. Technically I should probably test that change, but I won't bore you. And occurencesOfAlice should probably be removed since we have a general veresion. A farmer has irrigation systems that work for circular fields. He wants to lay out the fields, so that he wastes as little land as possible and wastes no water at all. So, the fields can't overlap and there can't be factional fields because then he will be watering somebody else's lands. He is looking at many different pieces of land and computing how many circular fields will fit on a rectangular piece of land. It's a bit of a pain. Let's write a program to help. Let's say that the circles are laid out. So that the fields touch the sides of the fields that they're right next to. And fields are nestled an equal distance from the field just above them on the left and the right. This calculation takes a few steps, so we'll need to go through an example by hand first. Imagine that the farmer is looking at a plot of land that's 1,900 meters wide and 4,000 meters long. The irrigation system makes fields with a radius of 400 meters. To save some time, I did some of the math. And hopefully you can read from my drawing, that the first row will need 800 meters of length. To get two rows, you'll need 800 plus 400, times the square root of 3. Meters of length. To get three rows, you'll need 800 plus 2, times 400 times the square root of 3 meters of length. How many rows will fit on a piece of land that's 4,000 meters long? My goal isn't to test you on geometry. Just to show an example of how to solve a mathematical problem with Java. Try a few times, and watch the solution carefully if it doesn't work. The answer should be 5 rows. We'll always have the first one, and then each additional row is another 400 times root 3 meters of length. So, to get the total number, we can do 4000 minus 800 over how much we need for another additional row. So, 400 root 3, and then we add 1 because there's that first row that took up 800. This calculation would give us 5.61. But we said that we couldn't have fractional rows. So, we just get 5. Let's generalize what we just did, if you already know the equation for the number of rows given the length of the field, write it down and skip to the next question. Based on what we did up here, the equation should be, rows equals the length, minus the diameter over the radius times the square root of 3 plus 1. Remember the radius was the 400 and diameter would be 2 radius' or 800. And then once we do this calculation, we would drop the decimal. Save this, you're going to need it later. Now we want to figure out how many columns there are in each row, and the land is 1900 meters wide. But it looks like depending on where we cut this off, some of the rows might have different lengths than others. I've done a little math for you here. This first field in the second row starts 400 meters away from this edge. Let's give names to these two different kinds of rows. The first and third are odd rows. The second and fourth and so on would be even rows. How many columns are in each odd row? How many columns are in each even row? The number of columns in each odd row will be two, and in each even row will be one. This is because the width is 1,900. So if we start from all the way on the edge, we can fit 800 plus another 800 is 1,600, but not another 800 which would give us 2,400. So that calculation was 1900 over 800, and then we lost the decimal. In the even row, we had to subtract 400 from 1,900, because we can't use these first 400 meters. Then we can fit 800, and at this point we're at 1,200, and if we add another 800, we would be at 2,000, but that's more than 1,900, so that wouldn't fit. So that calculation was 1,900, minus 400 over 800 and then we dropped the decimal. Let's write an equation for this. Write it down and skip if you know the rest. To calculate the number of columns per odd row, we calculated the width, which was 1,900 divided by the diameter, which was 800. And then dropped the decimal. To calculate the number of columns per even row, we started with the width, subtracted the radius, or 400. Divided by the diameter, and then again, tossed the decimal. Write this down. You're going to want it for later. We know from earlier that the total number of rows was 5. How many odd rows are there and how many even rows? If there are five rows: the first, third, and fifth would be odd rows, and the second and fourth would be even rows. But how would we generalize this, to figure this out let's look at a couple more examples. If the total number of rows was 6, then even rows would be 3 and odd rows would also be 3. If the number of rows was 7, then odd rows would be 4 and even rows would still be 3. So, it looks like the number of odd rows is something like half of the total number of rows, but 4 isn't exactly half of 7 over 2. It would be half of 7+1 over 2. What would happen if we added 1 on to this 6 as well. Then we will get 7 over 2, which in Javaland for integers is still 3. For the even rows 6 over 2 is 3, that one works. And 7 over 2 is pretty close to 3. In Javaland that's 3. So, if I just divide by 2 and throw away the remainders, it looks like I get the numbers of even rows. If you don't believe me, you can try a few more examples. So, it looks like the total number of odd rows is the total number of rows plus 1, over 2, and then drop the decimal. Whereas the number of even rows is just the total number of rows over 2, and we drop the decimal. There's another way you could calculate the odd rows. You could say that the odd rows are always the total number of rows divided by two and then you add one if the total number of rows is odd. So, that would be the total number over 2 plus one if 7 is odd. And if 7 is odd then 7 mod two would be one. So, total mod 2. Save these for later. And you could also try this one. Now we are ready to put all the subs together to get an answer. How many circles fits in a field that is 1900m wide and 4000m long. You can use any of the information you have calculated so far, the total number of rows was 5. The number of columns in an even row was 1. And the number of columns in an odd row was 2. The number of even rows was 2, and the number of odd rows was 3. If you are getting stuck, think about how many of each type of row there are? And how many circles are in that type of row? And the answer should be 8. There are 3 odd rows and each odd row has 2 circles, so we get 6 circles from odd rows. And there are 2 even rows and each of those has 1 circle, so we add 2. In general, that would be the number of odd rows times the number of circles per odd row. Plus the number of even rows times the circles per even row. You'll want to use this equation in your program. You've seen one example all the way through, and have equations for each step. Implement the method getNumberOfFields which takes a width and a length of a piece of land and returns the number of fields that fit on that piece of land. Use each of the steps that we walked through together. So, let's start out what we know first. We know what we want to test. So, I'll go into the plot tester and I'll create a new plot of the size that we did the example for. And then, I'll print out the actual which should be the number of fields, if the radius is 400. And then, I'll print out the expected number that we calculated, which was 8. Now, to actually do the calculation, first thing I do is calculate the number of rows, which should be an int. And the way that we did that was to calculate the length minus the diameter, divided by the radius times the square root of 3. But that wasn't counting the first row, so I've gotta add the first row back. And since there are some doubles in here, I won't automatically get integer division. So, to drop the fractional part, I'll need to actually cast this. Now, I haven't actually defined diameter. But that's just twice the radius. After that, I calculated the number of odd rows. Which was the total number of rows, plus one, divided by two. And the number of even rows, was just n rows over two. The number of columns in each odd row, was based on the width and the diameter. I want to make sure that I actually get an int here. So, I notice that the width is an int and the diameter is also an int. So, that's good. The column is an even row was the width, but we couldn't use that first space at the left. So, we have to subtract off one radius before we divide to see how many diameters fit across. And then, the total number of fields is the odd rows times the number of columns per odd row. And then, the number of even rows times the number of columns per even row and this number of fields is what we wanted to return. Let's find all my typos, oh got lucky that time. Let's see if the plot tester agrees, look's like it at least works for the example we checked. That's a good sign. That was a pretty tricky problem. If you struggled, way to stick with it. So, one of the things for me going into programming and even engineering, was that it was an area that I never thought was actually like important to me as a person. growing up with a very strong art background. I went to an arts high school, like, my mother is an artist, my grandmother is an artist. Like, I just, I never really realized like off the bat, like how applicable it is. Like nowadays, I'm, so I tie the two together. I I make large paintings that have circuits embedded into the canvas. And I use an adreno which I program, so that I can do sequence of like, different light displays at the time. Or, like I'll use like capasitive sensors which I can like program like, and tweak like how the can work and what distances. These are things like me, a couple years ago, would have been like, oh, wait, I, I didn't even know I could do this. This is like a whole new form of art. And I think that's one of the things that people don't initially think like, oh, you know, someone's programming. They're just sitting at a computer, but like even the way that you program is an art. Like you can be so meticulous about it, like the same work ethic that I use towards making like a painting is the same one I use towards programming. And it's something that like, the two are so entwined for me that I can't see how, like, it wouldn't be for other areas. Like, I have friends that are writers and it's, it's also the same kind of, they have the same kind of feelings towards it as well. And it's like, it's something that where even now if I'm doing like an interactive art piece. I want to do a simulation, like that's an art in itself, and like to sit down and like program with open frameworks or something. And like that's just something like for me is like how could you not want to think that these two go together. Like they totally go together. Yeah, one of my big advice big pieces of advice that I'd give for someone learning how to program is, it's okay to look stupid like, it's okay not to know what you're doing. Like it's, it's funny one of my big things going into like, learning how to program was I had pride issues, where I was like I don't want to look dumb, I don't want to ask for help. And asking for help like, whether it's, you know, Googling it like Googling is my best friend when it comes to things that I don't know or you know, even just asking someone next to me. Like hey can you look over this code or forums like, there's so many things, so many resources out there that are available. And you know, everyone in constantly learning, that's the thing, is that like. For me like, looking back the people that I was asking now that I know like what year they were when I was asking its like, wow they are where I am now. And they were still learning cause I'm still learning and so just knowing that its like its okay. People you're always going to have someone that's like oh you're new but that's OK you have to start somewhere. So far our programs always do the same thing. I mean when when we run it a second time, it does exactly what it did before. I don't get it. We just learned about reading input. When you run the program again with different inputs, it'll do something different. That's not exactly what I mean. Whenever I run the program again, it runs exact same lines of code. What if I only want to add a friend if the friend's not already there? I think the time has come to, to learn about programming decisions. Then your program can take different actions depending on circumstances. For example, you could skip the lines of code that do the adding if the friend's already in the list. That's exactly what I want, let's do that. My name's Molly Mackinlay, I'm from Belleview Washington and I'm a senior here at Stanford. And I first got into computer science when I was doing a first robotics program at my high school. I didn't take any coding classes until I got to Sanford and I took CS106A, my freshman year, fall quarter. And I loved it, but before that I thought I was interested in math, science, maybe engineering. And so I took an engineering course in the summer at Cornell University, trying to figure out if that's something I was interested in. And there I got to tour their HCI lab, which is Human Computer Interaction, and that studies how people interact with technology. And I was really interested in how to design technology for people. And make it something that was going to be both effective and really useful for them and that's what really got me excited about exploring CS. Because computer science is all about designing and solving problems that are going to be useful for the people that are using these programs. And so from there I took a lot of really amazing CS classes here. And from there I was sold. And I took the rest of the CS classes and had a really great time with it. Hello, and welcome to this new lessons. In this lesson you will learn how your programs can make decisions. Let's look at an example. Here you have a typical elevator panel, and yes elevators are controlled by computers these days. And if you look at the buttons, you will notice that there are buttons for 10, 11, 12 and then goes on with 14. so, there's no button for 13. and that's of course because, many people are superstitious and don't want to be in the 13th floor of a building. Now, contrary to popular belief, the 13th floor is not filled with secret government offices. There actually is a 13th floor, they just call it the 14th. So, the software that controls the elevator car needs to adjust for this human foible. Here's how you can do that in Java. Let's say floor is the number as provided by the user, 10, 11, 12, 14, 15, 16 or whatever, and now we want to compute that actual floor. Then we need to make a decision. In Java you use the if statement to make decisions, and you enclose the condition in parenthesis. Then you use a pair of braces, and inside you put the statement or statements that you want to have executed when this condition is true. So, if the floor is greater than 13, then we want it to adjust by subtracting 1. On the other hand, if the condition is false, then we'll carry out the actions in the else part of this statement. In which case, the actual floor number equals the floor number without any adjustment. And that's all there is to it. Let's go over the important parts again. The keyword if starts out the conditional statement. The condition goes in here, and is surrounded by parentheses. If the condition is true, then the part following the if is executed. And if the condition is false, then the part after the else clause is executed. Alright, now it's your turn. In some Asian countries, it's not the number 13 that brings bad luck, but the number 14. And those elevators wouldn't have a number 14. And in fact, just to play it safe, some property owners eliminate both the 13 and 14. So, go ahead and modify the program in the next exercise so that it translates the user selected number to the actual floor number. And know, there are no hidden floors with secret government offices. So your job was to adjust this program so that it works for that building, where both the 13th and 14th floor should be skipped in the elevator. So, that means that the numbers from 1 to 12, should stay unchanged. There won't ever be an input of 13 or 14. So that means 15 should get mapped to 13, 16 should become 14, 17, 15 and so on. That means if the floor number is 15 or greater, or in other words if it's greater than 14, then we want to subtract 2 and not 1. And those are the two changes that you need to make to the program and it'll work. There are a couple of other odds and ends about the if statement that I want to briefly talk about. So you know now that the if statement makes a decision. You go one way or another, depending on some condition. Now, sometimes, you're code is arranged so that you don't actually have a decision to do one thing or another, but the decision is between one thing and nothing at all. For example, over here, I've rearranged the code for computing the actual floor a bit. I'm initializing actual flow with the floor and then I only need to adjust it if the floor is greater than 13 and otherwise I need do nothing at all. In this case, it is perfectly legal to omit the else part. That's like if you only choose between doing something or just staying in place. It's okay to do more than one thing. You could put other actions inside here, maybe a print statement. Generally in more complicated situations, there's going to be several statements in between the braces. Conversely, if there is only one action here, it's legal to omit the braces. But we won't ever do that, it's just clear to always put them there. Makes the code easier to read. Now go ahead and work out a couple more practice problems with Sarah. And then we'll talk more about how these conditions are formed. An airline is having a sale, maybe it's time to go on vacation. They're using this Java code, to calculate a discounted price. If a flight to Las Vegas was originally $95, what's it's price after the discount? If the original price of a flight to Chicago was $100, what's it's price now? What's the discounted price? If the original price of a fight to New York City is $105. What its discounted price? Lets trace the code to find the answer. If the price is 95, then the originalPrice is less than 100, so it'll skip the first part of the if and go into the else. The discountedPrice will be the originalPrice, 95 minus 10. If the original price is 100, 100 is still not greater than 100, so we still go into the else. And get original price minus 10. If the original price was 105 though, 105 is greater than 100. So we day, discounted price is the original price minus 20. And we get 85. What if I change the if and the else? Switch them around and make the greater than into a less than. Will the discounted prices computed by this piece of code be the same as the prices computed by this piece of code? If we instead use this piece of code, what will the discounted price for a flight to Las Vegas be? How about for Chicago and New York? The flight for Las Vegas won't change and the flight to New York City won't change, but the flight to Chicago will be less this time. When we write the condition this way, the original price 100 will not be less than 100, so it will go into the L's and subtract 20. Whereas before, it went into the L's and subtracted only 10. For the threshold value, it matters whether we say original price is greater than 100 or original price is less than 100. Even if we switch the if and else clauses because it changes which group 100 falls in. Here I'm back to tell you how to write conditions in Java. Those conditions that you can put inside an if statement to make a decision. Often times you want to compare two values to see which one is smaller, which one is larger and there are a bunch of operators that you can use. Here's a list of them. A couple of them look just like what they look in regular mathematics. The others look slightly different. This one here, you would write as greater than or equal, or maybe greater than or equal, like that, in math. This one here is a less than or equal. This one here is a simple equality, and this one here is a not equal. Of course, these three symbols were chosen because there's no keyboard character , for the mathematical symbols. The equal, equal on the other hand was chosen because the plain old equal already has another meaning. In Java you use the equal, equal for comparison and the single equal sign for assignment. If you want to assign a value to a variable, here we want to assign the number 13 to the variable 4. Then we use the equal sign, and of course afterwards, floor is 13. If on the other hand, we want to test whether or not floor equals 13, then we use the equal, equal comparison symbol. Let's put if statements and relational operators to use in a fun graphical way, to draw flags. Here you see the flag of Indonesia, as simple as flags get, red on top, white on the bottom. Here you see the outline of a simple class for drawing a flag. Its get color at method, its called for every x and y value in the flag, your job will be to complete it so that the correct colors appear. You'll want to know the dimensions of the flag, so that you can decide when to use red and when to use white. And they're available to you in these instance variables. Don't worry about how the get color at method is, called. You can actually peek below and see it, but it uses loops, which we only introduce in the next lesson. Right now your job , is to fill out this method here. Put in a condition here, select the right colors. And as an added challenge, I want you to use the greater or equal operator. Now be careful, for exactly half of the rows, you want red, and for exactly half of the rows, you want white. Here's how I figured it out. If I look at an arbitrary point, x and y, where as always in our graphical coordinate systems, x grows this way and y grows this way, downward. And it's clear that the x value here has nothing to do with which color to chose. But the y value does, so I have to worry about the y value being. Greater than or maybe greater equal, we'll come back to that in a minute, then half the height. Now if it's greater than or greater than equal, or less than or less than equal, it's easy if it would make these things wrong. So, let's look at the actual numbers. Let's assume that the height is 200. In that case the Y values can be from 0 to 199. So, if they're from 0 to 99 then I want red. And if they're from 100 to 199 then I want white. So, if height is 200 then height is over 2 is 100. Greater or equal than 100 should give me wide. So, this is exactly the right condition, we'll put it in here and otherwise I want Red. Let me put it in and demo it to you. I'll just make a flag, many flags as I want in a half times as wide as they are tall and I'll use the same here. And here it is. Red on top, white on the bottom. Let's move on to a more complicated flag. Here is the French flag with three colors blue, white, and red. So, here it looks like we have to make three decisions. Are we in the first third, the middle third, or the last one? In java you would start out with the first condition, and I'll leave it to you to fill in the details in the exercise. Then, for the next part, you'll use an else if clause, so you simply write else if followed by another condition. And finally, you use an else for the remaining possibility. So, here you need to supply two conditions, is the point in the left, is it in the middle or otherwise, of course, it has to be in the rightmost part. This construction with if, else if. You can have other answers if you'd like. And then, finally is a else. This is what you do anytime you get multiple decisions. And I get worked down from the top to the bottom as you would expect. The first condition gets checked if it's fulfilled the statement is executed in here, and everything else is skipped. On the other hand, if the first condition wasn't true, one would move to check the second condition and if that one was true, it would be executed. If it wasn't, then the third one would be executed. In other words, exactly one of these three blocks is executed, depending on which condition is true or whether none of them is true. Well, now it's your turn to try that with the French flag. Again, you'll be given a point x y that could fall anywhere within the flag. And you need to make a decision whether to return blue, white, or red. And when you do that be sure to use an if, else if, else construction. Well, let's have a look at how to do this. Again, we're giving an arbitrary point on the flag. Let's remember that x moves this way, y moves this way. So, in this case the y value doesn't matter at all. What matters is where x is. The total width here is given to us, so this cutoff here is width over 3 and this one is width times 2 over 3. So, the first condition here is going to be x less than width over 3 or maybe less than equal width over 3. Let's settle that. So, let's assume that the width was 300, then x could be any value between 0 and 299. The first 100 values, from 0 to 99 should be blue. The values from 100 to 199 should be white. And the values from 200 to 299 should be red. So, the last value that stays in this branch here should be x equals 99. With the 300, width over 3 is 100. So the less than is correct. We want to be less than 100 to stay here. As soon as we're between 100 and less than 2 3rds of the width, we want to be in the middle brand, branch. And, finally, if neither of those is true, then we want to be here. And thats the code. The takeaway is, if you need to make multiple decisions, then you use the if, else if, else clause. Sarah has prepared a bunch of practice problems for you, so that you get more exercises that involve making these kinds of decisions. Have fun. Cay and I are in a twitter battle. I claimed that I will always have at least one more twitter follower than he has. In other words, my number of twitter followers will always be greater than or equal to the number that Cay has plus one. Is this true, if Cay has three followers and I have a four. What about this statement that Cay plus one is greater than or equal to Sara. How about the statement Cay plus one does not equal Sara? It's true that three plus one is than or equal to four. It's also true that three plus one is greater than or equal to four, but it's not true that three plus one is not equal to four. These values are right on the boundary. We would call this an edge case for this condtion. Its right at the edge of the values that make the condition true or false. When you're writing conditions its really easy to make little slips. Especially for the values right on the edge of the range we want. Its wise to always test a couple of values like this. That way if you miscategorize the case right on the edge you'll find out about it soon. And be able to fix it. What is the opposite condition of cay plus 1 is less than or equal to sara? Write a condition that's the opposite of cay plus 1 is less that or equal to sara. So, a condition that's true when this one is false, and false when this one is true. Do the same for these other two conditions as well. The opposite of cay plus 1 is less than or equal to sara is cay plus 1 is greater than sara. The opposite of cay plus 1 is greater than or equal to sara is cay plus 1 is less than sara. And the opposite of cay plus 1 is not equal to sara is cay plus one equals equals to sara. You may have thought that the opposite cay plus 1 is less than or equals to sara should be cay plus 1 is greater than or equals to sara. But the opposite value has to disagree every possible value of cay and sara. Let's look at a representative set of example's. Our original expression was cay plus 1 is less than or equals to sara. We found that when Cay has 3 Twitter followers and Sara has 4 Twitter followers, that's the boundary. So, I'm using that case and two cases, one on each side of that boundary to compare these three conditions to see which ones are opposites. When cay has 3 and sara has 3, it's not true that cay plus one is less than or equal to sara. When cay has 3, and I have 4, this condition's true. When cay has 3 and I have 5, the condition is still true. Now for the next condition, we find that they disagree on conditions that are not right on the boundary. But, right on the boundary, they agree. So these conditions are not opposites. But this last condition is true for the first case, false for the boundary case and false for the last case. So, it differs in every case from the original condition. You could write out similar tables for the other two original equations, but I think this is enough writing tables for now. Next, we're going to write a kitten class that calculates the cuteness based on a kitten's age. We'll say that kittens over six months old are cute. We'll say that kittens between two and six months, including exactly two months and exactly six months, are super cute. And kittens under two months old are not quite cute yet. They're still too young and sort of look like aliens. There's some code for the kitten class to get you started. You should implement the get cuteness method Before I implement the method, I'm going to write the tester. There are multiple ways you could do this, but there are also a lot of ways that look similar and don't work. Here's the way I came up with. First, it checks to see if the kitten is more than 6 months. If so, we know that we want to return cute. Now, if the kitten is not more than 6 months, but is 2 or more months. Then the kitten is super cute. This condition is only checked if this condition already failed. This whole piece of code is under the else clause for the first if. Now if both of these conditions are false. Then we end up in the last else clause. This catches everything that doesn't satisfy one of the first two conditions. So, if the kitten's not older than 6 months, and is not 2 months or older. Then it's younger than two months, and so it's not cute yet. Let's check that this works. Okay, it looks like these match, they match, match, match and match. So, we're good. We could change this code slightly by adding another condition here. The code will still work modified this way, but it's considered bad form. If you decide to modify the 2 months threshold. You now have to change it in two places instead of just one. Also, if you don't understand the condition right, or just make a little error, there could be cases that you miss and don't handle at all. So, don't add an if condition here. That would be a bug. What if we changed the order of these checks? So, I take months greater than 6 and put it here. Months greater than or equal to 2, here, and then, change the return values to match. Do you think this still works? Lets try it. It looks like it's wrong for the first case. These cases are okay and this one is, but it looks like there aren't any cute kittens anymore. Only super cute ones and not so cute ones. A kitten with eight months will do the first check and find that it's true and return super cute, without ever testing to see if it's more than six months, as well. No matter what number months starts out as, this piece of code, here, will never run. That's a bug. What if I add a line to the bottom of this program? What do you think will happen if I try to compile this code and run it? Will the code compile? Will there be an error? What age of kitten would trigger this return statement? Let's try it, the code won't compile. It says unreachable statement. Every possible branch of this if else statement has a return statement already. Once it returns the answer it won't do anymore. It'll exit the method. Even if there might be more code further down. Java can recognize certain situations where there might be unreachable code and it warns you because unreachable code is a mistake. When I write this line, I'm coding for a case that can never happen. All the cases are handled and finished in the if else statement. The else picks up all of the left overs. So, I shouldn't have an extra line at the end of my program that pretends it might return the cutest kitten of all.. Here's another example of an if statement. What would you say about this piece of code? Would you say the conditions are in the wrong order? the if price if less than or equal to 100 should be if price is less than 100, there shouldn't be if price is less than or equal to 100 at all, or there is nothing wrong? The answer is, there shouldn't be, if price is less or equal to 100. This condition doesn't change the execution. But it adds unnecessary code, and opportunities for bugs. We could later decide that we want to change the threshold of 100. And then we would have to remember to change it in both places. We're creating extra work and unnecessary complexity for ourselves by adding unnecessary code. welcome back. Now that you've seen a bit about comparisons, let's look at some trickier cases. In this program here, I start out with the number 2. I take its square root. Then I square the root, multiply it by itself. If that gets me back to the original value, I print a message, they're the same. And otherwise, I print what the root squared actually is. Go ahead and run this program and tell me what answer you got. Okay. When you run this program, you notice that you don't get the answer there the same. But you get that root squared is a value that's close to 2, but not quite. So there's a tiny error in that computation. These errors are unavoidable. Because decimal numbers cannot store an infinite number of digits. And somewhere, some roundoff is going to happen. So when you compare 2 numbers with fractional parts, you're never interested in whether they're exactly the same. You want to know, are they close to each other? Or in other words, is the difference small? Now we want to take the absolute value of the difference. We just care, is that a small positive or negative value? Translated into Java, we compute the absolute value of the difference, and we compare it against a tiny number. In math, one usually calls a tiny number by the name EPSILON. And in many situations, 10 to the minus 12 is a pretty good value to use. Let's do that in our program. Instead of the exact comparison, let's test whether root squared and the original are close to each other. That's the test here. And of course I have to define EPSILON, using the final keyword to indicate that it's a constant. Now when we run the program, we get the expected result. The takeaway is, whenever you compare two decimal numbers, compare whether they're close enough to each other, not whether they're exactly the same. Perhaps surprisingly, you're going to run into a very similar issue when you compare strings. Check out this code. I have two strings, Uda and city. I concatenated the two together, to form a string that are called firstAndSecond. And over here I have a third string, Udacity. And now I check wether, the first and second which we would expect to be Udacity, is the same as, Udacity. And if so this program prints, they are the same, otherwise it prints what firstAndSecond is. Again, go ahead and run this program yourself and tell me what you find. Just put your output into this box. Let's compare notes. When I ran this, surprisingly, I did not get the answer, they are the same. Here's what I got. It says, firstAndSecond is Udacity. So why isn't it the same as third, which is also Udacity? Let me explain. FirstAndSecond is a variable. Any object variable contains a reference to the object, like this. The string object contains the letters Udacity. Let's look at our other variable. Again, a variable just holds a reference. Now, reference to which object? Is it a reference to the same string object or to a different one? And that is the key question. The equal equal operator. Checks whether the contents of these two variables is exactly the same. In other words, whether both variables refer the exact same object. Now actually, they don't. Because if you remember what happened, firstAndSecond was obtained by gluing together this string and that string. And a brand new object had to be created to hold that content the third string was initialized with the literal string, Udacity, which came from elsewhere. So, in this case, the objects are different. But we don't actually care about that. What we care about is, do they have the same contents? And to compare the contents, one has to use the equals method. And not the equal, equal operator. Let's do that. Over here, I will check whether firstAndSecond equals third. Here's the test. We call the equals method on firstAndSecond and pass it third as a parameter. Now when we run the program, it will work as expected. The program prints, they are the same. So the take away is, when comparing strings, use the equals method and not the equal equal operator. And as a reminder, when comparing decimal numbers. Be sure to check whether the numbers are close to each other, and also don't use equal equal. Now when do you use equal equal? For integers, of course. In the previous unit, we've worried about two object references that pointed to different objects. Now we're going to look at a different situation, when object reference doesn't point anywhere at all. Let me explain that. Over here, you have a situation with which you are very familiar. We have a variable that references an object, [INAUDIBLE] cat. Now, my favorite cat is in fact my cat, Eliza. But maybe Sarah doesn't like cats and her favorite wouldn't be any cat at all. That is in the variable her favorite, there wouldn't be any reference to any cat object. In Java, she denote such a reference to no object at all with the keyword null. So this variable here holds this special null reference. This variable here holds a reference to some cat object. Generally, you would use this distinction meaning either a reference to a specific object or a null reference if the object is optional to test whether a variable is null or not. You use equal, equal and you test, is this reference the null reference? Now, if there is a chance that a object contains null. It actually is important that you make that test. Because if you invoke a method on a null reference, then something bad happens and the method called blows up. Well, it doesn't really blow up, of course. But it does terminate your program with a null pointer exception. It is simply illegal to call any method on null, don't do it. Instead, make this test first. I've prepared a little quiz here, where I'm going to ask you about several kinds of tests. So here's the situation, our intrepid reporter went to city hall to get a statement from the mayor. And now I'd like you to give me the java code to test whether the statement was one of the following. Did the mayor say no comment? Just type in here, what you would put inside the parentheses of an if statement to check for that a couple more. Did the mayor say nothing at all? And finally, did the reporter not manage to get a statement? Maybe he was stuck in traffic. So, just type in the conditions for each one of them. Well, let's compare our answers. Here, we're checking whether the statement equals the string No comment note the use of equals. When you compare two strings, you should use equals. Here, we checked where the mayor said nothing at all. Nothing at all is the empty string, the string that has no contents. And again, we use equals. Alternatively, you could use this test here, where we check whether the length of the statement is 0. That's the same thing as checking whether it equals the empty string. The third test is different. Here, we don't invoke a method. We're checking whether the statement is the null reference. Whether nothing has ever been assigned to the statement. Remember in lesson three how we stored the friends of a person? We had an instance variable friends, and when we added friends, we added their names to the friends instance variable. To remove friends, we replaced their names, with an empty string. What if I decided to add some methods that comment on the number of friends a person has? And try to use these conditions. Match each condition to a description of its error. The errors are; strings are objects and should be compared using equals. The strings friends will never be null. Loss of precision may prevent this condition from being true even when a person would see that it should be true. And this if statement tries to change the value of the variable instead of comparing it. The first one is d. The second one is b. The third one is a. And the fourth one is c. Using equals instead of equals equals or .equals is an easy mistake to make. This won't compile. If I create a string friends, and set it equal to the empty string. And now, if friends is the empty screen. And I'm going to use Shift Enter to go down a line without running it. Then I'll print out no friends left. Now if I run this, I get an error incompatible types, because friends equals the empty string, isn't a condition. It can't go inside of an if check. In the second one, friends will never be null. No matter how many friends we remove we just erase their names from the string, we don't reset the string to be null. In this third one, we're comparing using equals, equals. But strings are objects so we always want to use dot equals to compare them. In this last one, we say if the number of friends equals, equals the number of people times 0.33. Then you're friends with one in three people. But these are doubles, and doubles have precision loss. So, you could actually find out that numFriends equals numPeople times 0.33333 or 0.339, or something like that, and this wouldn't be true. Even though that person is basically friends with one in three people. When comparing doubles, you always want to find the difference between them, and then compare it to a threshold. Pick an epsilon, that is the biggest difference you want to accept, and compare the actual difference with your epsilon. Many times, when you have complicated conditions, you want to combine them. For example, maybe you want to do something if one condition is true, or another one. In Java, there are three operators that you can use to combine conditions. They look like this. The two ampersands are an and these two vertical bars are on or. And the exclamation mark somewhat is a not. You might find it useful to remember that the not equal operator that you've seen a few units ago also has the exclamation mark. Let me show you a few examples for using these operators. And once again, we'll be looking at flags where the visual appearance should help you. Let's start with this maritime flag for the letter d. Here, I made a sketch of this flag. When you're in the middle, the pixel should be blue. And otherwise, it should be yellow. So how do we express when you're in the middle? When the y-value is greater than this level. And less than this level, that's where our and comes in, then we're in the middle. This here is 1 5th of the total height. So, we have two conditions, namely y is at least height over 5, and the other condition is y is at most height times 4 over 5. Both conditions have to be fufilled for us to be in the middle, so we use the and operator. Here it is. Let's just try this out. Here is the condition that you just saw with the and operator here. And in this case, we return blue. Otherwise, we return yellow. In this case, I will make a square flag and here it is. So, the and operator worked out for us. Because we wanted y to be at least here at most, here. Both conditions had to be true for the blue color. Now, let's look at another flag. I've sketched up the flag here. And the question is, when should a pixel be blue. In this case, there are four conditions. The x-value should be at least width over third. That means it's over here. The x-value should be at most, width times two thirds. That makes it over here. The y-value should be the height over 3, and the y-value should be at most the height times two third. All those four conditions need to be fulfilled for a pixel to be built. Now, it's your turn. You'll get to write a program that draws this flag here with a bit of blue on the inside and white on the outside. Here's how I solve this problem. There are four different conditions. All four had to be true. So I join them with the and operator. So let's start with the x-axis. x has to be at least width over 3, and it should be at most twice that. The y value should be at least height over 3, and it should be at most twice that. So, here are my four conditions joined by and. When all of them are true, then the pixel should be blue, otherwise it should be white. Now, you may be wondering, what's the deal with the greater equals versus less thans, particularly, if you didn't do it just so and your answer wasn't counted correctly. This is easiest to see with a specific example. So let's say we have 300 by 300 flag. That means that the x and y positions range from 0 to 299. We want each of these three areas to have equal size, so the first one goes from 0 to 99, the next one from 100 to 199, and the last one from 200 to 299. So to be within the second, of these, you want to be greater equal 100 and less than 200. That's why you have a greater equal here and a less than there. I know it seems like a fine point, but it is worth paying attention to. And here is what it looks like, when I run it. Now you've seen a couple examples of the use of the hand operator, so how about or? We'll put or to use for drawing this Charlie flag. Again, here is my sketch and we have blue at the top or the bottom. If Y is less than height over 5 or if Y is height times 4 over 5 or larger, then the pixel is blue. So we'll put an or operator here to join these two conditions. Once again, it's your turn to complete this program. Use the or operator for the blue ones, and for the middle strip here, you get to use the and operator one more time. Go for it. Well, here's how I did it. This is the condition for y's in the top fifth. This is the condition for y's in the bottom fifth. If it's in the top or the bottom, that's where the or comes in, then the pixel is blue. If it's in the middle here, well, that's the case if it's at least at this point, and at most at this point. Notice the and, then it's red, and otherwise it's just white. So now you've gotten good practice with using ands and ors to form complex conditions. Suppose that x and y are 2 die values. How would you check whether both of them are 3? How would you check whether at least one of them is 3? Write a condition here. To check whether both of them are 3, you want to check whether the first one is 3 and the second one is 3. In a condition, that would look like x equals, equals 3 and, and y equals, equals 3. To check whether at least one of them is 3, you want to know if one is 3 or the other is 3. So, x equals, equals 3 or which is the vertical bar twice, y equals, equals 3. How would you test whether exactly one of them is a 3? To test whether exactly one of them is a three, you would be interested in two cases. One where x is 3, and y is not. And the other where y is 3, and x is not. If this case is true, or this case is true, then exactly one of them is a 3. In code, that would look like this. We have, x is 3 and y is not or x is not 3 but y is. You've been working a lot with and and or now, and the expressions got kind of complicated. In fact, so complicated that they've attracted the interest of mathematicians, such as this stern looking fellow. His name is George Boole. And he figured out the rules for working with conditions that could be true or false. And ever since, that's been called Boolean logic. Now, why do we care? We want our programs to be simpler to read. And so, when we have a long and complex condition, such as this one, we might want to put it in a separate method. Let's think about what this test here was. This was the test for the s flag, where you had a blue square in the middle. And this test you checked, is our pixel, in the middle. Alright, so if we had a method that could test that, we could say, if x and y is in the middle, then we want blue, otherwise white. Much easier to read. Lets go and write this method. Here it is, isInMiddle, takes and x and a y, coordinate. And here, you have the exact same condition that we've had before. And we simply compute, and return that. There's just one catch. We have to specify a return type for this method. And what is this thing that's being returned? Well it's either true or false. In Java, the type, that has two values, true and false, is called, Boolean, in honor, of our friend George. Here it is. So when you have a method, that can return a condition, that's true or false, you declare it as a Boolean method. Then you can use that method inside an if statement just as much as you can use the relational operator. You would want to do that whenever a condition has become so complicated, that you want to put it inside its own method. You can also declare variables of Boolean type. Let me give you a quick example. [SOUND]. I've reimplemented the isInMiddle method to use two Boolean variables. Let's check it out. The first variable, x in middle, checks where the x is between 1 3rd and 2 3rds of the weight. It's said to true if this condition is fulfilled. Or to false if it's not. And similarly. This variable over here, yInMiddle, is set to true when this condition is fulfilled, and to false if it's not. Why might I want to do this? Because each of those conditions is complicated enough that by saving it in a variable, it makes the code easier to read. Now over here, I say if both of these conditions are fulfilled then the point is in the middle, so I return the and of these two. Generally, you use a Boolean variable if you want to remember a value that's true of false, so that you can use it later. Sarah has an example of that for you, in a different context. A while back, the person class had the ability to return the number of friends someone has. We printed the number of friends like this, which works pretty well most of the time. But what if you only have one friend? It would print out, this person has 1 friends. If you want a program to look professional and have output with good grammar, you often need to have the plural form and the singular form of a word. We're going to tackle that problem in a minute. But in preparation, let's write a word class with a method for figuring out if a letter is a consonant or a vowel. Here's the word class. It saves its letters in an instance variable, letters. The is vowel method takes in an index, and then checks to see if the letter at that index is an a. You've probably noticed that this method implementation doesn't really match the description of the method. isVowel should recognize a, e, i, o, and u. Call y a consonant for now. This isConsonant method is completely empty at the moment. It's your turn. Fix the condition in isVowel and implement the isConsonant method. Here's a hint, you shouldn't need to do 21 checks to implement isConsonant. In is vowel, we want to return true if letters.substring equals a or e or i or o, so we add those comparisons using or. So, it would look like this. I had to type letters dot substring a whole bunch of times maybe I should have made that a variable. And then, every word I used letters.substring i to i plus 1, I could replace them with letter. That looks a lot better now for is consonant a letter is a consonant if its not a vowel. So, I can take a shortcut here and just return not is vowel for the given index. I don't need to tell it that it's an int. And I didn't actually initialize letter. If I want to test my method, I can make a new word. I'll fill it with sleep. And now, if I ask if the first letter is a vowel, I get that it's not because it's an s. If I ask if it's a consonant, I get true. I would probably want to test a couple more cases if I was going to ship this code to somebody. But, this looks like it's working for now. Now let's implement the method which returns the plural form of a word. We'll make some simplifying assumptions because plurals in English has a lot of rules. Check out the Wikipedia article if you don't believe me, or if you think phoenetics are interesting. We're just going to look at regular plurals, like dish, which becomes dishes. Or cherry, which becomes cherries. Or clock, which becomes clocks. Here are the rules I want you to implement for the initial version. If you want to make a more comprehensive version, nothing's stopping you, but get these ones down first. If the word ends in y, preceded by a consonant, take away the y an add ies, like in cherries. If the word ends in y preceded by a vowel, just add s, like in day which becomes days. If the word ends in o, s, sh, or ch, add es, likes in dishes. Otherwise, just add an s. You can use the is vowel and is consonant methods that you wrote before, as well as another method that I added. The method is takes an index, and the letter to compare it to, and returns true if the letter at that index matches the letter. There's also a tester program with a bunch of examples of correct plural spellings of the words. As a bonus, what happens if you give your program a single letter word, like a. What if you give it an empty string? Does it crash? So I know that words that end with s or o need to have an es added. So if the last letter is o, or the last letter is s, I return letters plus es. This condition is pretty ugly. And it seems like I'm going to be talking about the last letter index a lot. So I'm going to declare a variable. And now I can replace all of these with just last. That looks a bit better. Let's see if our program works for this case now. I'll need to return something in the else clause. Since just adding an S seemed to be sort of a default leftover case, I'll just return letters plus S here. I'll run my word tester. We want to look at the cases that end with O or S. For example, kisses. It looks like right now, our actual value for kisses matches what we expected. It looks like we also got some for free. All of the leftover default cases where you just add an s, are working pretty well right now. Massages look good, judges looks good, laps, cats, clocks. But there are some that still aren't working, and dishes should be disches, and not dish. So let's go back to our word. The case for y being the last letter was a little bit more complicated, because it mattered whether there was a consonant before it, or a vowel before it. So let's add a case for when the last letter is y. We need to account for two possibilities. If the second to last letter is a consonant, we take off the y and add yes. We can use substring to cut off the last letter, which is the y. And then add back ies. Otherwise, if the letter before the y is a vowel, we just add s. Now it should be better. If I go back to my word tester, and run it one more time. It should work for cherries, which it does. And it hasn't broken. Boys, or days, which also ended in y. So that's a good sign. Still not working well for dishes, or witches. It looks like if it ends in an h, then we need to return the letters with an es instead of just s. Let's check that. It looks like dishes is right, now. Witches is also looking better. Judges, laps, cats, clocks, these all look good. But bathes isn't right now. Bathes just turned into bathes. I think we need an exception for when there's a t before the h. So let's go back and do that. If the last letter is H, then if is the 2nd to last, so if the 2nd to last letter is an S or a C, then we add ES. Otherwise, just S. And now, they should all match. So it looks like it works. But can we simplify the code at all? The code I just wrote was pretty complicated. Now that you have a working version, you could spend 5 minutes trying to simplify the code. You can check whether your simplifications work by running the tester again. And if you get a very simple or very short version, compare it with another short version that I'm going to post in the forum. There should be a link somewhere on the page. [BLANK_AUDIO] We'll now put together everything that you've learned in this lesson, to solve an important problem, how to validate the input that a human user provided. Think again about the program with which we started this lesson, the elevator simulator. The user enters a number between one and 18, but not 13. There is no button labeled 13. And then that program computed the actual floor. Never mind that part. What I want to talk about is the part where we read the user input. In a program we don't have buttons. But we ask the user to type in the input. There's a prompt. And then what if some crazy user now enters 19 in the hope of getting to the roof or something. Or minus 2. Or some text, users do all sorts of interesting things. And when they do, the program might misbehave. So it's a better idea to catch those first, and just tell the user that, that was not right. Let's list the things that can go wrong and how one can address them in Java. First off, there's no button 13. And so in Java, you might write, if the floor equals 13, then print an error for the user. Let's continue. The next rule is that the bottom floor is one, and the top floor is 18. So if the user enters a number that is less than one, or greater than 18. We want to reject that. Here is the Java code. Note the use of the or operator here. If the floor is less than one, or greater than 18, then we print this error message. And finally, there is the issue. What if the user doesn't even type any number, but some words? That would actually be bad. Because, then, the nextInt method would fail. Let me show you how to protect against that. There is another method that we haven't yet seen, called hasNextInt, which looks at the user input, and, instead of, doing what the nextInt method does, namely returning it It just checks whether it is an integer or not. It returns true, if the user entered an integer. It returns false, if the user entered something else. In other words, it's a method that returns a Boolean value. So we can test for that, in the if statement. If the method returns true, then it is safe to call nextInt. We can read the input, and then process it in any way we want. If on the other hand this method returns false, then we print an error message. Now, it's your turn. Put those three pieces together, and fix up the elevator demo so that any bad input from the user is caught and the program only proceeds when the user did the right thing. An integer between 1 and 18, but not 13. So here's the original elevator demo, where we read in an integer, or we're hoping it's going to be an integer, and then we use it here for that first demonstration of a new statement. Our task is to make sure that we get a valid integer here. Someone was kind enough to supply us with the bits and pieces that we need. Here is the check where the, the user mistakenly enters 13. Whether the floor is less than 1 or greater than 18. And finally, where that's not an integer at all. Our job is to put these together in the right order. Now, the first 2 checks already assume that the user entered an integer. So we should use the sur check first to test for that. Let's cut it out, and paste it into the main method, and fix up the flow. So, we have our scanner, we're prompting the user to type something in, and now we're checking what the user types. And if that's successful, then we call nextInt. And that gets us to where we were here. So, everything that's down here needs to get inserted here. Let's do that. So, if the user entered an integer, we grab the integer and we do our computation. Let's move on to the other tests. Here they are. Again, I'll cut them out. So, these one's only make sense after I have read in the next input as an integer. So I'll paste them in here. So if the floor is 13, I print an error. If it's less than equal 0 or greater than 18, I print an error. this isn't really going to work because I'm printing the error and then I still continue with all of these things. What I really need to say is if this error happens, print the error, else go on here. Let me do that. So I have enclosed all of the original action inside this else. Now peaking up, there still is a bit of an issue with control flow. The floor is 13, then it does this, and then in all cases, whether or not it's 13, it makes this check. So we also want to put an else in here. So first we check whether the number is even an integer. If so, we check whether it's one of these two special situations. And finally here we know that it is a good input, and we do our regular thing. Note that we have three levels of nesting. This if contains this if, and the else branch here contains another if. C'est la vie. Some advice that I have for people who are learning how to code for the first time is to not get frustrated or discouraged, especially, if you feel like people are ahead of you or have been coating for so long and your just starting out and there's no way you can catch up. For me, when I first started coding, it was fall quarter freshman year of college and there have been people who've been coding since they were six years old or, you know, in a variety of other classes in their high schools. And I'd never coded before and felt pretty insecure about my, my coding ability. I never had that, that confidence that I could, you know, hack something out really quickly. But I stuck with it, and I think that's what made the difference. I was loving everything that I was learning. I was motivated to go do extra credit or, you know, work on assignments that weren't necessarily due for a certain class I was in. And suddenly, two, three classes in, I felt like I was caught up. I felt like I could find my niche within computer science, where I could be the best. I could be the one who was teaching other people how to do things. And from there, it's been an amazing transformation, in terms of how confident I in my coding ability. Welcome back. It's great to see you again. Welcome back. It's great to see you again. Today we'll be talking about repetition. Today we'll be talking about repetition. Many programs do the same types of actions over and over again. For example, if you're working with a big piece of data, your program will repeatedly read and process each piece of the input. I really like to write programs that do this. Because it means that I don't have to do the same thing over and over. The computer does it for me. Let's get started learning how to do this. Let's get started learning how to do this. Hello and welcome to Lesson 6. We're going to talk about loops. But more importantly, you're going to learn something that you probably want to know. Namely, how you can become a millionaire, even though if you think about it right now, interest rates. Rates are very low. Get a measly 1% on your bank account. And I don't know about you, but I don't have a lot of money right now. All I have to invest is $100. But, I have a plan. Here's my plan. I'm going to set my time machine to that specific point when my bank account has a million dollars in it. Or maybe if I can't find my time machine, I'll just let myself be chronologically frozen and tell them to wake me up at that moment. All I need to know now is to which date in the future to set my time machine. So, that's what we're going to be writing a program for and that program's going to be using loops. Because it has to keep on adding that interest to the bank account until it reaches $1 million. How long do you think it's going to take? 100 years, 1,000 years, 10,000 years, or almost a million years? Let's take a guess. Alright, did you think about it? It probably won't take a million years. It probably won't take a hundred years, and I'n not even going to try and figure it out. Instead, we're going to write a program that figures it out for us. Here's the start of our program. I've setup a few variables. Note the initial balance of $100. My target of a million dollars. The interest rate of 1%, and right now we're in year zero. In Java, you use the while loop to repeat statement. And that's exactly what we need. We want to repeat the statements that add the interest. Here, we compute the interest. Here we add the interest to the balance. Each time we do that, we also want to increment the year because after all, we want to keep track of how many years this process takes. And finally, we want to print out. Just so that we have a running total of the current year and the current balance which is what you see here. How long do we want to do this? We want to do it while the balance is less than the target, the balance starts out at a $100 gets larger and larger. Eventually, it'll exceed the target and then the loop will stop. Now, let's run this program and here it runs. Look at this, after 926 years, we've reached a million dollars. That's actually not so bad. So, I have to wait less than a millenium to become a millionaire. You can do the same thing. Here we have the code that calculates how long it will take $100 to grow to $1 million. How many years would it take to grow to $1 billion, instead? Modify the program and run it. Previously, the condition was to keep running this loop, and keep counting until we hit $1 million. But now, we want to keep counting the years until we hit $1 billion. So we change the loop condition to go up to 1 billion. Now if I run this, I find out that it'll take about 1600 years for my $100 to grow to grow to a billion. I'm feeling a little impatient. I don't think that I can wait, a thousand years, for my money to mature to a million dollars. What if the invention of self driving cars, changes the economy so completely, that interest rates go up to 10%. How long would it take to get to 1 billion then, starting with 100? Start with the same code that you started with last time, and modify the program, this time, so that, you change the interest rate. The rate is included in this line, where we calculate the interest. The interest calculation has to happen inside the loop. Because the balance is incremented by a different amount every year. If we moved this line out of the loop, it would only happen once. And our interest would always be $10. Even when we already have 100,000 in the bank. So I'll put that back. There is some magic numbers still in this code. Maybe these should actually be named variables. So I could take this, and make this into the target. And I can take out the rate, and call it a rate. Now this code is much more readable. We can see that it goes well the balance is less than the target, and the interest increments by the balance plus the rate. Here's another example of a loop. I haven't figured out what it does yet. What is the last value that this loop prints? The last value printed by this loop is 2,000. This is a little bit weird, because the loop's condition says that it only runs as long as n is less than 1,000. Let's hand trace this code to see how this happened. I'll track the values of n, and what gets output. I start by setting n to two. And then I check, n is less than 1,000, which is true. Two is less than 1,000. So I set n to be 10 times 2. And then I print out n. So I print out 20. Now, I'm at the end of the curly braces. So I go back up to the top of the loop and check the condition again. N is 20 now, which is still less than 1000. So I'm going to repeat the steps inside the loop again. I'l set n to 10 times 20. So I get 200. And then I print out 200. I get to the curly brace, so I go back up to the top of the loop again. 200 is less than 1,000, so we'll repeat the loop again. I'll set n to 10 times 200 over 2,000, and then print 2,000. And now I'm at the bottom of the loop, so I come back up and check the ignition. 2000 is less 1000 is no longer true. So I'm going to skip to the bottom and be done. It looks like the last thing that was printed was 2000. And we managed to print a larger value of n than 1000 because the print statement comes after we update the loop variable. It matters when we update the n inside the body of the loop. You've just worked with Sarah to write and understand several loops, and what will often happen to you that you have a loop that's really mysterious. And I'll give you an example. Here's some code that comes from a program that you will improve in a bit to solve a common problem, namely to identify reverse digits in a credit card. So let's see what this code does. What you always want to do is get out a sheet of paper. Here's my sheet of paper. You make a table. One column for every variable. There's a variable n, there's a variable sum. Now, it's always a good idea to take a marker, I like to use a paper clip to mark where we are. So, we set n to 365 and we set the sum to 0. Now, we enter the loop. Is n greater than 0? It sure is. We get to this statement. Now, we need to compute n modulo 10. That's the last digit of n. That would be 5. and now we have a new variable! We record it, we put in the 5. Moving on, sum is sum plus digit, n is n divided by 10, it's an integer division so we discard the remainder. We move to the top of the loop. Is n greater than 0? Compute n MOD 10, 36 MOD 10 is 6, store that in the digit. Sum is sum plus digit. It is 11. n is n, what, 10. Now, n is 3. Back to the top of the loop. Is 3 greater than 0? It barely is, so we stay in the loop. Now, we need to take 3 MOD 10. That's 3. Add it to the sum. Divide n by 10, that's an integer division, so now we get 0. 0 is no longer greater than 0. We fall out of the loop, and go to this statement. And what are we printing? You're printing 14. Okay, well, what's 14? Well, we've computed all of the digits of the number 365, 3, the 6, the 5, and we've computed their sum. 14 is the sum of the digits. And that's almost what one needs to do in order to verify a credit card. You'll see in your next programming assignment what sum of digits you exactly need to do. Now you've seen this code that calculates the sum of the digits of the number. But we promised that this code for iterating over each digit in a number would be useful for validating credit card numbers, and here's why. When you write down a credit card number, it's really easy to switch two numbers. And that's pretty annoying for somebody who is trying to charge your credit card so you can buy things. Luckily, the designers of credit card numbers back in the day thought about this. All credit card numbers have to follow a kind of pattern. And there's an algorithm that uses the pattern to figure out if the customers has accidentally switched 2 numbers. That algorithm has a very similar structure to the code for summing digits. Let me write the pseudo code for this algorithm, so we can compare this algorithm with the one for validating credit cards. When we trace this code, we saw that it set N and Sum, and then for each digit in N; starting with the one on the right, it added the digit to the Sum. And then at the end it printed the Sum, now here's a question; which of these lines of code is responsible for making sure that the code looks at each digit in N? I think the lines that make the contents of this loop repeat exactly once for each digit are while n is greater than 0. And, n gets updated to n over 10. Every time the code in these curly braces runs, n gets integer divided by 10. So, whatever this last digit was, it loses it. If n was 365, it loses the 5. If it was 36, it loses the 6. Now, the code inside of these braces runs over and over again, as long as n is greater than zero. In other words, as long as n has more digits. You could say that this line where we set n is part of controlling the loop as well, since the size of n effects when the loop stops. I would probably not say that the line int digit equals n mod 10 is part of running the loop once for each digit. This line doesn't change how many times the loop runs, it is related though because this is how we actually get the digits one at a time so we can add them up. Now this pseudocode that you're looking at, is very similar to the pseudocode for verifying your credit card number. The pseudocode for verifying your credit card starts by setting n and sum, and it also sets a count. Then for each digit, again starting from the right, it increments the count, and then uses the count to determine what to do with the digit. If the count is odd, then the digit gets added to the sum. Otherwise, if the count is even, then it matters how big the digit is. If the digit is less than five, then we add two times the digit to the sum. Otherwise, if the count is even and the digit is five or greater, then we add two times the digit to the sum, and subtract nine. And then, if the last digit of the sum is zero, the card number is valid. How would you write Java code for this? There's a lot going on here, so first let's do one part of it. How would you change the code for summing all of the digits, so that it only sums every other digit, starting with the rightmost? I'd like you to complete the sum certain digits method, which given a number like, 12,345 would return 5 plus 3 plus 1. And for a number like 6,789, would return 9 plus 7. I'll give you the code for summing all the digits to start with. And there will be some hint links above the submit button, to hint videos in case you'd like a boost. Starting from the pseudo code from the hint video, and get set to the credit card number. Sum is set to 0. Count is also set to 0, and that's an int. And now for the tricky part, for each digit in n starting from the right. So I need to use the parts of this while loop that correspond to that. So I'll keep while n is greater than 0 and n equals n over 10. And I need to actually get the digit so that I can add it. But I don't just want to add the digit to the sum. I only want to do that if count is odd and I need to increment count. So count plus, plus. And if count is odd then add digit to the sum. But count is odd is not quite Java yet. If count mod 2 is 1 then count is odd. And instead of printing the sum, I'll return it. And if I run the tester, so far so good. I don't see any evidence that I made mistakes. That was a good incremental step. Now, let's add back the parts that make this into a real credit card verifying program. I'm going to ask you to write one more Java program. And this time, I'd like you to use this pseudocode. There's a tester program you can use for guidance. And here's a hint. Credit card numbers are too big for ints. This problem is tricky. There are a lot of ways to write code that almost works, but not quite. It will be very important to use the tester program. You can also use System.out.println statements to get an idea of what your program is doing. There will be more hint videos. Try to use the ones that match the questions in your mind. In the credit card class, we can look at the pseudo code, and find that it first sets sum, and count to zero. That's already there. These lines are the same as what we had before, for computing the sum of every other digit. The for each digit starting from the right part, is getting pretty familiar now. I'll keep the code for controlling the number of erasions in place. But now, instead of just always adding digit to the sum. I need to check whether the count is even or odd. And before I even get the digit, I want to make sure I remember the increment count. Now [SOUND], if count is odd [SOUND], I add the digit to the sum. Otherwise, count is even and if the digit is less than five, I add twice the digit to the sum. In the last case. Count is even and the digit is greater than five [SOUND]. And I want to add twice the digit [SOUND], and then subtract nine. This is all just matching that pseudo code. Now, instead of just returning false, I need to return [SOUND] whether the last digit of n. Is zero, or not. The last digit of n is zero when sum mod ten is zero. For example, if sum were 24, then sum mod ten would be four, which is not zero, and the card would not be valid. But if sum is 40, then sum mod ten is zero. And the card is valid. So this would return true. Looks like I forgot to change my pseudo code into real code. Count is odd, if count mod two is one. And now I'll run the tester. And it looks like, for at least the examples that we've used, my code is returning true when true is expected. And false when false is expected. Here's some food for thought. Does this guarantee that my code is correct? So I want to give you a few tips on how you can deal with, errors that, might creep into your code. And here's a typical example. Have a look at the code on the left. It does something wrong. See if you can figure it out, just by looking at it. Well truth be told, I couldn't either when I saw it the first time. So lets run it and see, how it behaves. Whoa, look at that, the numbers are getting bigger and bigger. That's the bank account I want. But that's not the program that I wanted. I wanted it to stop. When I've reached a million dollars. It's gone way beyond that. This is getting crazy. I've been waiting here for a long time, and the program just is not stopping. So the first question is, how can I make it stop without buying a new computer? So let me show you that first. You see that little barber pole icon here? What you do is you right click on it, and then you select the one and only menu option to reset the virtual machine. And now the program has been killed, and we can figure out what went wrong. So, first, I have some terminology. This is called an infinite loop, and it's pretty clear why. The loop just keeps on going forever. Let's see what happened. We compute the interest. And actually, that's the same computation that we had before. It's perfectly normal. We increment the year. We print out the result. And you've seen this happening over and over. So the problem must have been with the condition here. Hm. We wanted to keep one going, while the balance didn't reach the million dollars. It clearly overshot the million dollars, so the problem must lie in here and why don't you give it a try to fix it. The problem is that we don't want to stop when the balance is exactly equal to the target. We want to stop as soon as the balance hits the target. So if the balance is less than the target, we keep growing. And if the balance equals the target or is more, we stop. Here's another error that many people make. Remember what our goal was? Our goal was that our balance should be bigger than the target. So lots of people, when they write their while loop, they put that goal, which they have firmly in their mind, into the header of the loop. But that's not how the while loop works. The while loop says I want to stay in the loop while the condition is fulfilled, and that's exactly the opposite of the goal. That's a common confusion. I'll let you fix it in just a minute, but here's how I remember it. Look at the board, little girl there. And she's warning, are we there yet? Have I reached my goal, namely to be at the destination? And while loops are not like little girls, they're the exact opposite. They're excited to be going and going and going, so you want to formulate your goal while there's still work to be done, we can do it. You'll get a chance to fix this bug right now. Let's trace the buggy code that chi showed us and see how it behaves. Here's the code to compute how many years it will take a balance to grow to a target, but it's not working. Trace the year, output and balance. We initially set, balance to 100, and target to 200. But target won't change, so I wont write that down over here. Rate also wont change. The year, starts at 0. Now we compare the balance to the target. The balance is 100, and the target is 200. 100 is not greater than or equal to 200. So we don't go into the body of the loop. We skip down to the bottom. We never output anything. What would you say the bug in this code is? How would you fix it? I won't go over this, but if you're not sure, maybe try it out in BlueJ. I wrote some broken pseudocode too. It sets temp to n and then while temp is greater than 10, increments count which was originally set to 1 and then divides temp by 10. It was meant to count the number of digits in the number n but it's not doing it. Help me debug this by hand-tracing. If n is 123, what value does count end up with? What if n is 100? What should this loop condition be to get the right answer in all cases? If n is 123, count will end up as 3, which would be correct. There are three digits. If n is 100, count will end up as 2, which is not the correct number of digits. The loop condition should actually be. While temp is greater than or equal to 10. We can see this by hand tracing the code. The values I'm interested in are count and temp. If n starts out as 123, then count will start as 1, temp will start as 123. Temp is greater than 10, so we increment count. And divide temp by 10 and divide temp by 10.0 which will give us 12.3. Now, we go back to the loop condition. Temp is still greater then 10 so we increment the count and then divide temp by 10.0 again so we have 1.23. Now, when we check again, temp is less than 10. So we skip to the end, and we're done. But what would happen if n was 100? Count would start as 1, the way it did before. And temp would start as 100. Temp is greater than 10, so we would increment count and then divide temp by 10.0. So we would have 10. And then check the condition again. But this time, 10 is not greater than 10. It's equal, so it skips out immediately. When in fact, we still had two digits left. We needed to increment count again. This is why the condition should be temp is greater than or equal to 10. I wrote a loop with an error. Here it is. Can you fix this code so that it will print out the balance every year for ten years? If you want to run this in debugging, I highly recommend that you use BlueJ. The Udacity IDE won't be able to give you all the feedback that you need. The year never changed, but year is how we're controlling the loop. So we needed to remember to increment year by 1. Inside the body of the loop. Now if I run this again, the output is much more manageable. It's pretty easy to make this kind of mistake. Where you forget to update the loop counter variable. We're going to show you a way to write a loop that is good for cases like this one, when you know exactly how many times you want to repeat something. Now you've gotten pretty good at working with simple loops and it's time to introduce another loop type. It often happens that you need to work with consecutive numbers 1, 2, 3, 4, 5, 6. I'll just give you an example. Let's say you want to write a to-do list. Maybe your and my to-do list is really complex. So we'll start with something really simple. My cat, Eliza Doolittle. Her to-do list is stunningly simple, and you can program it. The first thing she does is sleep. That's the second thing she does. And the third, and you guessed it. Sleeping is what she does all day. Your task is to write a program using a while loop that prints this to do list. You've just wrote a program that prints out Eliza's to do this, and it probably looks somewhat like this. A counter starts at 1, it goes up to 6, we do some work, we increment the counter, keep on doing, until the counter. Has reached its end. There's nothing wrong with it. But if you think about it, the three statements that control the counter. The initialization, the check, and the update. They're spread all over the loop. The full loop is there, to organize it a bit more neatly. Here is the basic outline of the full loop. It has three slots. And, we fill in the right statements, in each one of them. And I'll demonstrate that. In this low tech way. We'll cut out the initialization, the condition, and the update, and we'll put them in the right slot. Initialization goes here. The condition goes here. And the update goes here. Now, you see, they're all neatly together in the hetero of the four loop. Let's have a quick look at the control flow. We start with the initialization. Then we check the condition. We go into the inside of the loop. Then we do the update. Now, the counter is 2. We check the condition. We go into the inside of the loop. We do the update. Now, the counter is 3. We check the condition. We go inside the loop. We do with the update, we check the condition, we go and set the loop. Do with the update, check the condition, go inside the loop, through the update. And eventually, the condition is false, and we leave the loop. Notice that the initialization happens once, the check happens before entering the loop, and the update happens after finishing an iteration of the loop. Actually, Eliza's To-do List Looks Like This. How would you adapt your for loop to print Eat only on the odd numbered items and sleep on the even numbered items? The answer is, inside the for loop. Around this line, I need to check, whether I'm on an even or an odd count, before I decide what to print. If the counter mod two is one, then I'm on an odd number. On odd numbers, I want to print out, the counter, and eat. Otherwise, on the even numbers I want to print out sleep. Lets' see how this works. Looks like I missed the quotation mark. I get what we wanted. Here I could have just said if counter is 1 or 3 or 5. Like this. And this would still work, as long as I only print six numbers. But if I wanted to print 12 items, Eliza's list wouldn't have eat after the sixth item. You've now seen two loops, the while loop and the for loop. And now, you have choices and which loop to take, and choices aren't always easy. So, let's look at a typical problem. Let's say we have $10,000, and we get 10% interest. And we want to know what happens to our nest egg over a period of 30 years. Which loop should we take? Now, in this case, what's going to drive our decision is the fact that we know we want to do something 30 times. And when you know how often you want to do it, then the for loop is what you want to choose. Over here, I've modified our program to do this. Here you see now I've changed the balance to 10,000. I've changed the interest rate to 10%. And I have now that I want 30 years. And then, I just write my loop here, where the year goes from one to the numberOfYears, gets incremented every time. And inside here, you have the familiar computation of the interest. So, notice that in this loop, I know exactly how many times the loop is going to execute, namely, this many times, 30 times. Let me run the program. Here you see the output. You see the interest, and starting at 1, scrolled off at the top, and it went 30 times. That's the classic case for the for loop. Contrast that with, the example of, the first program that we had, where we wanted to become a millionaire. At that point, we used a while loop, because we did not know how many years it was going to take for us to achieve our lofty goal. When you don't know how many iterations you want, the while loop tends to be the better choice. So, that simply is your criterion for decision. Do you know how many times the loop runs? You usually choose a for loop. If you don't know, you usually choose a while loop. So far, all of our for loops have counted up. But what if we're really excited for a vacation, and we want to print out a countdown. The countdown would print out something like this. How would you change this loop to count down instead of up? Try it yourself, and if you get stuck, I'll show you. We need to change where the counter variable starts. Because now we want it to start at 20. We want to stop if the counter is less than zero, so we'll need to change the direction of the sign. And we want the variable i to go down every time instead of up, so we replace plus plus with minus minus. Now, for the finishing touches. And if I run the program, it goes like this. Those days counted down a little fast, but that's okay for now. But that's okay. Now you now how to count down. The full loop is really useful to take words apart into the individual characters. For example, when we have a word like this, we might want to look at one character at a time. And what we're going to do in our sample program, is count how many vowels this word has. Now, why does anyone care how many vowels a word has? When you know how many vowels there are that gives you an issue, an idea of how complicated the word is. And sometimes you actually have to adjust your writing to be simpler. And then it's good to know that so just. So, how do we do such a a thing. We need to, find, out, each of the characters. And then, look at it more closely. Over here, you see how to look at the i'th character. You take the substring, that goes from position i. Up to, but not including position i plus 1. And that is a string containing a single character. And we'll let I vary from 0 to the last valid index. That would be the length minus 1. Notice that I starts at 0. It is less than the length that makes means it goes up to the length minus 1 and if gets incremented by 1 every time. This loop that you see here with this fore header and extracting the ice letter that's what you use every time that you want to break a word into its individual characters. Now, onto our specific problem we want to count vowels. The condition that you see here checks whether the letter is a vowel. it looks a little backwards. We list all of the vowels, and we ask where the, the letter is any one of those. If we have a vowel. We increment a counter. The rest of the program is simple. We print the result and also we need to declare a few variables. Let's run the program. We're supposed to type in a word and we learn that mouse has three vowels which doesn't surprise us. Actually is the bonus fact of the day. Some words have more vowels than you think. Here's the French word for bird, oiseau, and it has five vowels out of six letters. Which is hard to imitate in English. I keep wanting to post things on Twitter. But the character limit is so small, I can't say what I want to say. Help me write a method to shorten my Twitter posts by only printing the consonants. So how did I ever program without loops, would come out like this. You should put your code in the shortened method of the Twitterizer class. I already have a tester. So I'll just start filling in the implementation. I want to go through the longPost, each letter of it. And copy the consonants into another shorter post. So I'll start out with a string shortPost. And I'll go one letter at a time. I can't use the increment to skip the vowels. Because I don't know which ones are vowels until I check. Inside the loop, I'll need to check if the ith letter is a vowel or not, and if it's not, I'll add it to shortPost. We've written conditions to look for things that are not vowels before. This is a different way of doing it. Instead of using if it's a or e or i, I made a string that contains all vowels, and then I asked that string If it contains the letter I'm looking at. If this string contains the letter I'm looking at, the letter's a vowel. So, if it does not contain the letter I'm looking for, then it's a consonant. In which case, I'll add it to short post. There's one more important thing that I need to do. I need to actually return the string. Let's see if it works. Here's our actual, and it's exactly like the expected. What if I decide I only want my close friends to understand my Twitter posts? And I decide to write them all backwards, and only tell my friends. How would you write a method that reverses your Twitter posts? If I look at my Twitterizer Tester, I now have a test for reversing, how did I ever program without loops? Inside the twitterizer class, I have to implement the reverse method. I want to look at every letter in the string post, but I want to start from the end, and work my way backwards. As I did last time, I'll start with an empty string backwards, that I'm going to add letters to, as I see new letters. But this time I'll start I at the last letter in post. And go as long as i is not less than 0. I mean, as long as i, is not less than 0. Decrimenting i by 1 each time. Inside the loop, I want to record every single letter I see into backwards, and then I want to return backwards. When I run the program, it didn't break the first one, and now reverse works, as well. We've intercepted a secret message, but it's scrambled. You're going to write a for loop that prints every tenth letter, starting at the zeroth one. You'll use it to decode the secret message. This is the project you'll be working with. The decoder tester has the string with the secret messages embedded in it. You'll write code for the decoder class. So that you can use a decoder to decode messages. Here's the Decoder class, and here's the decode method that you want to fill in. First, let's look at how we're going to use the decode method. It's going to return a string with the decoded message. And it doesn't need any arguments. So, in the decoder tester, we want to print out the result of decoder.decode. The decoder was made with the coded messages string already in it. So we don't need to pass that string in again. Now, back to the decoder itself. We need to write a for loop that reads every 10th letter, starting with the 0th one. Since we're reading a string, we want to go as long as the index is less than the length of the string. EncodedMessage is the string that we're reading. And instead of incrementing by one at a time I'm going to increment i by 10 every time, so that we only see every tenth letter. Inside the loop, the part that I want to repeat is reading the ith letter, and adding it to decoded message. So decoded message will be itself Plus, encodedMessage.substring from i to i plus 1. Remember, this is how we got one letter out of a longer string. Let's see if this works. Looks like there are more secret messages in here. If you're curious what they are, I guess you'll have to try starting at different indices. Let me talk for a moment about a couple of bugs that you might have encountered. If you accidentally wrote less than or equals to, right here like this. You might encounter a string out of bounds exception. When you try to access too high of an index in encodedMessage. A string index out of bounds exception is a runtime error. That particular runtime error is nice, because it stops the program and tells you, you tried to access a value that doesn't exist. Which is much better than silently messing up your program's result. You could correctly, though, a little clumsily write the condition as, i is less than or equal to encodedMessage.length(), minus 1. That would work, but I don't think it's as clean. When you iterate over a string, it's best, to go, as long, as i, is less than, the length. Now you've done this already, remember? When you changed all of the pixels from an image into the negative. At the time, I gave you the loop structure to do this, and I told you not to look too closely at it. Now, we're ready to reveal this mystery. On your left we're going to start this program. We have a full loop. Because we want to iterate over all of the pixels, we'll find out soon enough how many pixels there are. The structure's very similar to the structure for working with words. Instead of getting the ith character, we get the ith pixel by getting the color at position i. And we can also set it, presumably after having changed it in some way. So here's your basic loop. Get the pixel, process it, and put it back. Now, how many pixels do we have? We can ask the picture, and it's going to tell us the number of pixels. And that is the exact analogue to the length of a string except that you should think of the pixels as being arranged like this. A row of pixels, another row and they all come one after another. When we ask for them. And eventually we reach all the pixels that way. I starts at zero. It goes up to the total pixel count. Is incremented at every step. We get the i pixel. And that way we get all of the pixels in the image. In our particular example. We simply compute the negative of the color, and then we can put it back. Finally, we want to load the picture, show it to the user, and then start processing it. Let's run the code. Here is Eliza, all positive. And here she is, sadly negative. As you've seen, it's just as easy to work with pictures as it is to work with words. So I have this picture of the queen Mary. Let's slightly dim this picture by turning every 5th pixel black. You saw how to use the pixels method to get the number of pixels. And how to use the set pixel at method to change the color of a pixel. You'll need a for loop. What should your indices be to avoid index out of bound errors? We want to iterate, over every pixel in the image. The first index, in the pixels, would be 0. And the last one would the be one, less than, the number of pixels. Since I only need to affect, every fifth pixel, I'll increment, i, by 5 at a time. To turn a pixel black. I'll use the setColorAt() method, and give it the number of the pixel I want, and the color to set that pixel to. So now if I run this, I get the same picture, but dimmed a little. If you look really closely, on your own screen, it's hard to seen on the video, you can actually see the little, black dots. There are probably other ways to do this, but I think this is the simplest. For example, you could count up by 1 at a time and then use mod to decide whether to actually color the pixel or not. Alternatively, instead of checking using mod, you could set the color at 5 times i. But then, you would need to change the condition for stopping the loop. I think that would require a little bit more thinking. While we're working with some images, what does this code do? It rotates the image 180 degrees. It replaces the bottom half of the image with a rotation of the top half. It has no effect or it crashes and throws an exception. This question is hard. We don't expect you to get it right the first time. The answer is, it replaces the bottom half with the rotation of the top half. This question should have been really hard. You have to think about the order of the numbering of all of the pixels. And imagine everything that happens in the right order. You haven't seen a problem like this before. If these were all the pixels of the image. This one would be 0. This would be 1. This would be picked up pixels minus 1. And this would be picked up pixels minus 2. Now, in the first iteration of this loop, we would get color c from the ith pixel, which would be the 0th pixel. Then we would find picked up pixels minus 1 minus i which in this case would be picked up pixels minus 1. Minus zero, so the last pixel, and set its color to the color saved in c. So we just copied the color from here into here. Now, on the next iteration, we'll get the color from one, right here. Find the pixel at pic.pixels minus 1, minus 1, so right here, and copy the color into here. It's starting to look like we're just going to rotate the whole image. But not quite. Imagine that I gets to this second to last spot. We'll get the color at the second to last spot, and then we'll get the pixel at the second spot. And we'll copy the color from the second to last spot back into the second spot. But this is the color the second spot already had. So the first half of the image won't change. Only the second half of the image will. In this segment I will teach you how to count. And I'll start with a simple problem. Look at the fence over here. This fence has ten of these sections. How many posts does it have? If we have 10 sections: one, two, three, four, five, six, seven, eight, nine, ten. Let's look at the posts: one, two, three, four, five, six, seven, eight, nine, ten. Now, we have one post before every section, and eleven, there's one after. So the answer was the 11 posts. Now, onto something entirely different. Have a look at the program on the left, and my question is, how many numbers does it print? Well, let's have a look. We have a count i that goes from 10 to 20. And, so we print 10, 11, 12, 13, 114, 15, 16, 17, 18, 19. That now was ten numbers, and we print the 20, because over here there was a less than or equal sign. So we print a total of 11 numbers. It's the same as she has with the fencepost, one more number than one might have expected. This is a common error, and people call it a fencepost error. You don't want those fencepost errors, and here it the way to avoid them. Let's think about how many numbers this loop prints. First of all, which numbers are printed by this loop and how many of them are there? This loop will print 10, 9, 8, 7, 6, 5, 4, 3, 2, 1 and 0. There are 11 of them. You could think of this as 10 for 1 through 10, plus a fence post at 0. When I start at some value a, and then it goes up to b including b, with a less than or equal sign here. Then there are b minus a plus 1 values. That plus 1 is a fence post, plus 1. For example, over here, we start at 10, we go to 20, and we have 20 minus 10 plus 1. That's 11 values. What about the case? When i starts at some point and then it goes less to another point, in that case we have b minus a values. For example, if over here we change the less equal to a less than sign. Then we have 20 minus 10, or 10 values. Namely the values, 10, 11, up to 19. That's a very common situation that you've seen before. Let me remind you, the situation where you, you have a less than for the upper bound. Is actually very common and you've seen it several times before. For example, now look at your left. There is the program that looks at all of the letters in a string. And when you look at the bounds you again notice a less than sign here. We go less than and the length of the word. So when we look at our formula over here. In this case, a is 0, and b is word.length. So how many iterations do we have? We have word.length minus 0 iterations. And that makes perfect sense. Because we have one iteration for every letter in the word. And word.length is the number of letters in the word. Here's another for loop. Make sure to read this carefully. I'm asking how many times is the condition evaluated? Not how many times does the body of the loop run. This condition is evaluated 4 times. This condition is evaluated 4 times. First it's evaluated when i is 1. Then we add two to i. So it's evaluated again when i is three. And when i is five. And then, one more time, when i is 7. At which point, the condition no longer holds and so it skips the rest of the loop. Here's another example of a loop. What does this one do? Does it count all non vowels? Does it count all lowercase vowels? Does it count all lowercase and uppercase vowels? Or does it do something else? The answer is, it counts all of the non-vowels. Result is being used as a counter variable. It starts at zero. And then we look at each letter and word. We get the letter out of the word using substring. And then make a string, which is all of the lower case vowels. We take the letter that we got out of word. And convert it to lowercase. So, A and A both become A. And then we check if this string contains whatever the result of that was. If AEIOU doesnt't contain the lowercase version of the letter, then we increment the result. So result goes up when we see a non-vowel. Oftentimes you will want to gather input from a user and you'll give the user instructions such as, please enter a value less than 100. The user then may do something wrong, as users sometimes do. So, here we have someone disregarding the instruction and now what do you do? often times what you do is you simply, politely ask again and the user might still get it wrong not understanding that less than 100 means less than 100. So, you'd ask again. And now finally, the user gets it right. This is a very common situation, and it turns out to be surprisingly difficult to program. Here are two possible solutions to this, the blue one and the black one. And, I'd like you to look at both of them and see which one would work. Take your time, and tell me, is the blue one the right one? The black one, do both work? Or does neither of them work? Well, they're actually both right, let's see why. Let's look at the blue code first. When we start, the value is 100. We go to the loop, value is greater or equal than 100. In fact, we've set it, to make sure we enter the loop. We ask the user to enter a value. Let's say the user is uncooperative and enters 200, then we go back up. Now, the value is still greater or equal than 100. And we go back in the loop. That was the whole purpose really, of this while loop. We wanted to keep asking the user while the value is greater equal than 100, since our target is to get a value less than 100. Remember, the while condition is always the opposite of the target. So now, let's say the user is doing better, enters 99. I'll go back to the top of the loop. 99 is less than 100. And we follow through, so it worked. So this one was a good solution. Now, let's look at the black solution. This one is a little different, we ask the user to enter a value less than 100 and let's say they do, then now comes the loop. This loop is never entered. And in this case we get the right behavior. So, let's look at another situation where the user doesn't makes a mistake first. So, we're again at the top. We ask the user to enter a value less than 100. The user enters 200. Now, that's greater or equal with N100, So now, we get into the loop and we ask the user again and say no if they give the right answer. Then we go back to the top and now we're satisfied, so this also works. But both of the solutions are a little unsatisfactory. Look at the first one here. We have this trick where we're setting the value to an artificial value not to a user input so that we enter the loop the first time, it's a bit ugly. The second one we repeat part of the code. Look at this statement here and the statements here, they're exactly the same statements and we need to repeat them because we first need to get the user input before we can see whether it's any good. And then, we need to keep bugging the user until it's any good. That repetition is also, somewhat undesirable. There is a Java statement that can take care of this issue. So, here is this pesky loop that didn't quite work out for us. We want to keep asking the user to enter a value less than 100 and we want to keep doing it while they enter a value greater or equal to 100. But really, what we want to do is we want to go through the loop once. And then, do the check, and then if the check fails go through the loop again and so on. The key is we want to go through this at least once, the way to do that in Java is to move the while statement, the while condition to the bottom and to add the word do to the top. If there were two on the top, the Y condition on the bottom and this is called a do loop. Let's look at a program that uses it. So, here's our program. It has the do loop that you've just seen. So, we keep asking the user, please enter an integer, less than 100, until they do. In other words, we stay in the loop while the input is greater or equal to 100, and then this program doesn't do anything with it. It just says thank you for entering a value less than 100. Let's, let's run this program so you can see it in action. The program has started, it asks for an integer less than 100. We'll be annoying and put in 200, we get another prompt and we'll be annoying again. And we could do this forever, or not. And now, the program simply says thank you for entering 90. That's the most common reason really to use the do loop for input validation. And the reason you need the do loop is simply you've got to get at least one input from the user before you know whether to complain or not. So, this is the situation where you've got to enter the loop at least once before you know what to do, that's exactly the point of the do loop. The do loop enters the loop at least once, whereas the while loop might never enter the loop. Suppose we want to check for inputs that are at least 0, and at most 100. How would we modify this do loop to look for a number that's between 0 and 100, and could be 0 or 100? Well, first of all, this prompt doesn't match what we want the user to do anymore. That's a bit better. We also need to check more things about the value. If it's too low or too high, we keep asking. Too low would be that value is less than zero. And too high would be if the value is greater than 100. If either of those is true, we want to keep going. Let's test this out and make sure that the edge cases work well too. It's asking me to enter an integer between zero and 100 inclusive. If I enter something like 101, it'll keep asking. That's good. Now, if I enter something like negative one, it still keeps asking. That's also good. But it should accept zero and 100. Looks like it accepted zero. Let's try running it again. Will it accept 100? Looks like it accepted it. So this was the correct condition to check the user's input. In lots of applications, you need to read many inputs. Here, when you look at these adorable kittens, of course, you want to pet them all. But if you're a vet, you might also need to know their weight, their average weight, which one's the largest, which one's the smallest, and so on. So, a program that processes data like that needs to read in all of that information. It needs to specifically, in this case, read in the weight of every kitten. So, we might want to prompt to enter the first weight, the user enters first kitten weighs 100 grams. We get the prompt for the second weight, the user enters, prompt for the third weight and so on. Well, when do we stop? Maybe we could have asked the user how many values are you going to enter? Now, that's a little clumsy, particularly when there's lots of values. There's a common solution to this problem. And that is to ask the user to enter some input, that definitely can't be the right value. In this case here, we might ask the user to enter 0, because no kitten can weigh 0 grams. Such a value is called a sentinel value. Why sentinel value? Well, a sentinel is like the fellow you see over here who guards something. In our case the sentinel is that last input that guards the input sequence. It just says this is the end of the input sequence. Do we have to use zero as a sentinel? No, there are other possibilities. For example, minus 1 would work if all inputs must be greater or equal 0. Or if any numbers can be inputs, you could use the letter Q. In the exercises that come, you'll explore some of these possibilities. Let's practice collecting multiple values. I want to write a program that helps a user compute their average time for sprinting 100 meters. Here are the beginnings of the average method. The method should be reading floating point numbers from the user until the user enters zero and then it should return the average of all of the numbers. You can use the average tester main method to test as you go along. We want to figure out what the sum of all of the numbers that are entered is. And also what the count is. So, we can use them to calculate the average and return it. We can use a do loop to collect the user input. Somewhere in the do loop we'll have to update value by getting the next user input. So, we'll need to ask the user for a double, and then read in the next double using the scanner. If the value is 0, then we want to quit, but if it's not, we want to increment count and add to the sum. So, count goes up, and sum goes up. So, how long do we want to keep going? We want to keep going as long as value is not 0. Because if value is 0, that means we read a 0 from the user. So, we continue doing these steps, as long as value is not 0. Let's try this, after I fix up my syntax errors. Running the main method. If I enter 2, it doesn't quit. Negative 3, it doesn't quit. 0, it stops. And it gives me an average. Let's look at the program again though. There's some repetition here. We have to check that the value is not equal to 0 in two different places. We could change this so instead of using a do while loop it would just use a while loop and only check the value as not equal to 0 in one place. We would declare a Boolean to track whether we're done or not yet. Initially, we're not done. So, it starts as false. Then, as long as we're not done, we would keep doing the things in the loop. So, we wouldn't need the while at the bottom. As is, this loop would go forever because we never change the value of done. So, when do we want to say that we're done? Well, we want to say that we're done if somebody puts in a 0. So, if the value is 0, then we set done to true. This will work the same way. When I run the main method, it'll ask for doubles until I enter 0, and then give the average. You can structure any loop and a half this way using a Boolean to guard your condition. A lot of the time, you can't exclude zero. I'm writing a program that calculates the average altitude of an area. Since some parts are below sea level, negative altitudes are allowed. And an altitude of zero would be allowed too. Can you modify the average method so that the sentinel is a letter Q instead of a zero? It's possible to do this without a loop-and-a-half. If you're feeling adventurous, you can try Googling Java 7 Scanner, and finding the documentation about the hasNextDouble method. I'll talk about this in the answer video. Let's see how we would do this in BlueJ. Here's the loop that we had before, which used zero to decide when to quit, but now we want to go as long as there's another double. We can use the hasNextDouble method to ask the scanner if the next token it has is a double. Then we basically want to do the same stuff as before, right, asking for input and adding it to the sum in counting. Let's just try this. Hm, still running, still running. Okay, I think there's a bug here. So, let's stop this. Look at the code again. Where could this have got stuck? I've never seen simple variable assignments like this get stuck before. So, I think that's not the problem. Now, here I check if there's another double. Oh, there isn't another double, because I haven't asked for one yet. So, I'll need to ask the user for a double before I check if there is another double. And now, I'll have to ask again somewhere in the loop. I don't want to ask immediately because then I'll ask twice. So, I probably want to ask at the end, after I process the value I already asked for. Let's test this again. I can enter three, and four, and zero. Well, it looks like this message isn't right yet. But, if I add a q then I get my average back. That's interesting. This is the average of only the first two numbers, it didn't include the zero, I guess we're still not there yet. We're only incrementing the count if the value is not zero. [LAUGH] We've also got this cruft with the done, we're not going to need that anymore. So, I'll take out everything associated with done. Now, let's see. We have the user enter something If it's a number, we read it in, add it to the sum, count, and ask for another one. This is probably what we wanted. Now, if I enter three, four, and zero, that's better. Now here's a question. What does the average program print if you immediately type Q when prompted for a value? You may to try this out in BlueJ. Does the program print zero? Does the program terminate with an arithmetic exception? Does it print NaN? Or does it do something else? Lets try it out. Here is our average program. If we just enter q immediately then it tells us NaN but what does NaN mean? Lets ask everybody on the Internet. Lets search for java NaN. Looks like other people have had this question before and under the answers it says NaN stands for not a number. It's produced if some floating point operation has some input parameters that cause the operation to produce some undefined result. For example, 0 divided by 0 is arethmatically undefined. So we must have done some kind of math that was undefined. It seems like the most complicated piece of math we're doing here is just this division. So let's print out what sum and count are. Here's a print line statement from sum and count. And now, if I enter q immediately, it tells me that sum and count are both 0. So it makes sense that I'm getting NaN; I'm dividing by 0. So the average program is in better shape than it was at first. It can now take averages that include zero, but it still chokes when the user doesn't enter enough numbers. What we would really want would be to print out an error if the user enters no numbers and count to zero. So, when we run our program, it would ask us to enter a value, and if we enter a bad value like s, it would say error, no input. But if we enter values like we did before, it'll calculate the average. Fix the average class, so that it prints out a sensible error, if count ends up at zero. We want the code to do the same thing that it did before, but now if there isn't a next double the first time, we want to print an error instead of collecting values and calculating the sum and the average. So I'll ask the user to enter a value and then if n has another double, we'll go into the while loop and eventually calculate the average. So I'll indent all of this to put it inside of this clause. Now if they don't enter a double, I'll catch that with an else clause, I'll print out an error message. Let's check out whether this worked or not. If I enter a bad value, I get the message I wanted, and if I enter good values, then it calculates the average. A very common problem is to find the largest element in a sequence of inputs. Now you might think, how hard can this be? In this sequence, clearly this one is the largest. But a computer program can't scan all of the inputs at once like we can. The computer sees items one at a time. So, let's look at this problem a little differently. So here I have these playing cards. I get to see one at a time. And I need to find out which one has the highest value. Let's look at the first one. That clearly is the largest one I've seen so far. The next one, well, that one is larger. The next one is even larger. This one here, not so much, so I won't change my mind about which one is the largest. That one is larger yet. This one isn't as large as the one over here,so we will ignore it and my last one here is also smaller ,so my answer is that 8 was the largest input. In Sudoku the algorithm would look like this, I start at letting the largest be the first value while there are more values I read the next value. And if that value is larger than what I thought the largest was, I changed my mind. When I'm done with this loop, largest would have been set to the very largest of all the inputs. Now you get to try this out with Java code, go ahead and complete the next project. Let me show you what I did. I simply followed the pseudo-code that we developed before. The first line already matches. Now I have to know whether there are more values. Well, the value'=s already in this doubles. And there's a queue at the end. So I'll simply call the has next double method. Next I need to read another input. I do that here. Then if the input is larger than the largest value seen so far, I need to update the largest value. That's here and here. Let's give it a try. Here's my prompt. I'll just enter the values that we had with the cards. Here are the inputs and the Q to terminate, and I'm told the largest value is eight. You have just seen how to write a program that determines the largest of a number of input values, but that program had an annoying flaw. The user had to type in all of the values and if there are a lot of them that can get really tedious. What we really want to do is read the values from a file. To read a value from a file, you can use the scanner class. But you construct the scanner with an object of a file class. And in turn you need to construct that file object by giving the name of the input file. Now, there's a bit of a catch here, when we put this code inside the main method, we need to deal with the possibility that there is no file called input.text. If that file was indeed missing, then the file constructor would terminate with what's called a file not found exception. That exception is considered so serious that we must tell Java that we are aware of it. That's done by putting this class throws FileNotFoundException behind main. We're not covering exception handling in this course, so this is just another one of those things that I'm going to have to ask you to just do. Once we're done with this, everything else is easy, now the scanner works. Every bit as the scanner you've been using quite a bit. You can simply call has next double, and then read a value by calling next double. Well, have a go at it. Modify the program that computes the largest value, so that it reads the values from a file. We need to make this program read data from a file and compute the largest one. We make a file object for the file with name input.text. With that file object we construct a scanner. And now the rest is exactly like what we had before, because reading from a scanner that is attached to a file Is no different than using a scanner that's attached to the console. So here, here, and here we call next double, and has next double in the usual way. When you run this program, it'll tell you that it found, as its largest value, a value that is very large. Let's have a peek at the input file. That file has a lot of numbers in it that seem kind of meaningless. You'll see in the next exercise with Sara where they come from. You just saw how to read from a file and how to find the largest value in a data set. The last program prints out the population of the most populous country, but it doesn't print the name of the most populous country. Edit the program so that it prints out the country's name as well as its population at the end. And here's a hint, what else do you need to remember? What variables should you add so that you can print the population and the country name at the end? So we'll need to save the name of the country as well as the country's population. We'll initialize largest country name with the first country that we look at, sort of the way we initialized largest population with just the population that we looked at. Now when we find something which has a population larger than the largest population. We'll need to update the largest country name as well as the largest population. Now, when our program gets to the end, where we print things out, it'll still have access to the largest and the largest country name, but it's only printing out the population. So I'll add a line, print the country with the largest population is and the variable where we saved the largest country's name. When it asks for a file, I'll find the population file. And I get that the country with the largest population is Afghanistan at 3.0419E7. That seems pretty funny to me. I don't think of Afghanistan as a very big country. Let's look at these numbers. Afghanistan has eight digits. But Bangladesh has nine. Clearly there's something wrong with the program. It looks like it's set the largest population and the largest population name the first time, but then after that, probably didn't update it. So there must be something wrong with my loop. Oh! It's looking for a double first, but the format of the file has the name of the country first, and then something that could be read as a double. So this should actually just be, hasNext not hasNextDouble. Let's try this again. Okay. Now I'm getting that the country with the largest population is China, with this as it's population. That seems much more reasonable. It's a really good idea to be familiar with some common algorithms for processing values in a loop. You've seen a couple of them already. You've seen how to compute the average of a sequence of inputs and you've seen how to find the largest element. There are quite a few more like that, counting matches, finding the first match, position of the first match, finding all matches. And so on, and so on. Instead of me tediously telling you something about each of them, we've prepared a fact sheet where you can find the pseudo-code and an example for easy reference. And Sara will practice a couple of those with you. The point is that you want to be familiar with what algorithms are out there, so that you can adapt them as necessary. Here's another chance to practice your loop skills. Imagine you have a friend who's collecting data on climate change, and he has a data set of how much the water in a reservoir rises and falls each year. If the water level rises, he records a positive number, and if it falls, he records a negative number. Starting from here, write a program that prompts the user for a value until the user enters queue, and counts how many times the user enters a negative number. If you're not sure how to start, we've linked another fact sheet with some pseudo-code for loops with different purposes. You can use it as a guide. The first thing I'll do is I'll ask the user for a value. Could be a floating point value because the water could have gone down by a fractional amount. I'll read the next double and if the value is negative, I'll increment the counter. Now, if I want the user to keep on entering more values, I'll need to tell them that. And it looks like I forgot colon space on the first one. That wouldn't have looked very pretty. Fix that in my compile errors, and it looks like I'm ready to go. If I run the program, I can enter values, and I've entered two negative values now, so if I finish, I expect to see the count as two. And if looks like the water line fell on two years. I'd probably want to fix out the spacing before I shared this. But right now I'm counting all of the negative numbers just the way I wanted to. What if instead of finding how many times a value occurs in a user input we wanted to find out how many times a particular digit appears? For example, in this number 3 appears twice as a digit. You can start with this number class and implement the count matching digits method. Notice, digit to match is a digit, like 3, that you're looking for. And number is the number you're searching in. If you remember how to count the digits of a number you'll remember that you'll need a temp so that we can count down the digits without messing up number. Now we're going to repeatedly divide temp by ten to count the, now we're going to repeatedly divide temp by ten to iterate through the digits from the last to the first. So the way that we'll iterate through each digit in the number is to first use mod to get the last digit and then divide by 10 so that we discard the last digit. Then when we use mod 10 again, we'll get the next last digit. So the first digit will be temp mod 10 and then we divide temp by 10 to discard the last digit. Now in here we want to be counting all of the digits that match digit to match. So we'll need a counter. That starts out at 0. And then every time we find a digit that matches digit to match the increment, the counter, I think I might have some type errors in here, because I'm mixing int and long. But let's see. Alright. I know that when I mod something by 10, the biggest number I'll get is nine. So I know that's it's safe to actually cast this after I take the mod and I will actually need to return the count. I wrote tester here to make sure my program works right. In this number I expect there to be four 9's, one 3's, and no fives. Since I fix all my syntax errors, I'll run my number tester, it looks good. Let's return to our Alice in Wonderland example for a minute. What if I want to write a program that finds interesting words that occur in the book? A lot of the time shorter words are more common words. Maybe longer words are more interesting, and more likely to be related to the exact topic of the book. We could write a program that would help us test this. Let's write a program that finds the first word in Alice in Wonderland that's longer than nine characters. We know that we're going to write a loop that searches for long words. And we know that it should stop if you find one. Or if you run out of words. If I just worry about running out of words at first, I might write my loop as while in.hasNext. Keep looking. But now, there is an other condition that I have to meet as well. I have to not have already found the word. So, i want to keep looping as long as there's an other word and the wrong word is not found. Now inside the loop, we need to actually get the next word. And then, if this word we just got is long, then we want to save the word for later, and also make sure to mark that we've found it, so that we can exit the loop. So far, I haven't created a variable for saving this, but if I scroll down a little bit, I can see that I want to print out long word. So, let's make a variable called long word. Now, in my if statement, I'll update long word and set found to true. Let's try. It says that the first long word in Alice In Wonderland is ADVENTURES. That sounds appropriate and I'd say that's an important word to Alice In Wonderland. What if there are no long words? We could run this program on a text that has no long words. What would happen? Would the program print nothing? Would the program print the first long word is? Would we get an index out of bounds exception? Or would something else happen. The answer is, the program would print, the first long word is and then nothing after it. Because longword would still be the empty string it was initialized as. We would never encounter a word with length greater than nine. So longword would never be updated. So, we saw that the program we wrote won't work well if we never find something that matches. Let's update the first matching program so that prints out there are no long words if it doesn't find a long word. So that you can see the in action pretend that you're looking for words that are longer than 30 characters. Your code will go down here. So, how do we know if there are no long words? Well, if there are no long words then long word will be an empty string. So, if long word dot equals the empty string. And remember, we use dot equals because strings are objects then we want to print out the message there are no long words. Otherwise, there is a long word and we print that out. Now, if I run this looking for words with length greater than 30, well, that's interesting. It looks like there is a word with more than 30 characters. It's just joined up with a whole bunch of dashes. I bet there aren't any words longer than 60 characters though. That would just be crazy, right? Alright, looks like this time we got, there are no long words. You saw how to find the first match and also return if there are no matches. But what if you want to find out where the first match occurs? In our Alice in Wonderland example, maybe we find the first long word and then find out how far in that occurs to get some idea of how common long words really are. This is where the program left off. How would you modify it to return the position of the first long word? As well as that the long word was. Remember, the position of the first word would be zero, and the position of the second word would be one. To do this, we'll need to add a counter. The counter will be incremented every time you look at a word, not only when we find a long word, because we want to count how many short words come before the long word. Let's try to hand trace a little bit and see if this would work. If the first word is longer than nine characters, that would mean we would want to return a position of zero. So we would go into the loop, we would find the word, we would go into the if statement because the word length would be longer than nine. We would mark the word as found. And then we would increment position to one. Okay, that's not quite right, so, maybe this we'll need to start at negative one. So that'll fix it for the case where the first word is long. What if the first word is short, and the second word is long? We'll start with position as -1, go into the while loop. There are more words, and it's not found yet. We read the word. The word is short, so we skip past the if statement and increment the position to zero. Now we go back into the loop. There are more words, and we still haven't found it. We read the second word, which is long so we go into the if statement, set longWord to be the word that we just read, and say that we found it. Then update the position which was previously zero, so now it'll be one, and then get back to the while loop. But we [UNKNOWN] found so we break out, this should work, but I forgot to print it. Alright it looks like the first long word in Alice in Wonderland is Adventures and its position is one. Let's compare this to the text. It looks like Adventures in position one and it's no wonder it would be related to the book, it's part of the title. In the programs that you've seen so far, you've used a single loop to solve a problem. Sometimes, you need to have more than one loop, and in fact it can happen that you have one loop sitting inside another. Such loops are called nested loops. Let me give you an example. We want to write a program that draws this square of colors starting with the black one, increasing the greenness in this direction. Increasing the blueness in that direction. How can we draw all of these squares? Let's think of it a row at a time. For example, to draw this row here, I need to go from x equals 0 then to x equal whatever the width of this square is, which is 30 in our example. So the x equals 30, 60, 90 and so on. And that'll be a loop. That loop will draw on all of the squares in a particular row. To get to r rows, I need another loop. And there you have it, a loop inside a loop, nested loops. Now, the only tricky task remains. If I have row i and colon j. How do I find out the position and the color of this square. You'll get to try that out in the next exercise. Just keep in mind, that as the row index i goes 0, 1, 2, 3 and so on. You want the y position to be 0, 30, 60, 90, hence on. And as J, the colon index goes from 0 to the number of colon. You want the x offset also to be 0, 30, 60 and so on. How about the colors. We want this square down here to have green 255 and blue 255. All the reds are 0. So, you want the greenness to vary from 0 to 255 in equal increments in this direction. And you want the blueness to vary from zero to 255 in equal increments in that direction. You just have to figure out the increments. Alright, go ahead and give that a try and as you do that closely look at those two nested loops that you'll be working with. Well let's figure this out together. In this loop i traverses all rows. In this nested loop for each row j traverses all columns and we need to figure out x and y. Let's look at our picture. As i goes zero, one, two, three and so on the y position goes 30, 60, 90 and so on. So the y values are 30 times i. I should really be using this constant over here so let me fix that up and for the same reason the x values of width times j. What are our blue and green? Let's look at the picture again as I goes larger of the row index, the blueness increases. When I add 0 blueness is 0. When i is the maximum value of 15, the blueness is 255. So in general, i is 255 divided by the largest value for i. Notice the -1. There's 16 rows, numbered 0 to 15. And at the 15th one we want the full value of 255. The formula for the greens is exactly analogous. When j is zero, green is zero. When j is 15, we have 15 times 255 over 15 or 255. And for values in between, the green grows as j does. Again, the point of this example was that you need two nested loops to control the rows and the columns. Let's get some practice with nested loops. This digital clock can display any time of day. It's an American clock, so the hours go from 1 to 12 and minutes go from 00 to 59. We can use a nested loop to print this table of all of the possible times the digital clock can display. We'll need two loops. One will count up the hours, and one will count up the minutes. To make sure that minutes are printed with a zero before them so they fill up two digits, you can use the format string %02d. And if you're not sure where to start while writing your code, think about what code you would write just to print the first line. And how that differs from the code that you would write to print the second line. Let's try the loop for just the first line first. It seems like the minute isn't changing, only the hour is changing, so I'll declare a loop variable called hour that's going to go through all of the hours. It will start at one, and will go as long as hour is less than or equal to twelve, and we won't skip any. Inside, I want to print the hour, followed by a colon, followed by the minute. And I don't want to print it on a line because all of the hours should go on the same line. Hopefully, you notice I'm using a descriptive name for the counter. And that's because in a moment we're going to have multiple loops and it'll be confusing to see which loop counter is which. Lets try this and see how far we got -if I fix the compiler errors. Okay, this is a good start. We have the first line. Now, the loop for the second line would look like this. The only difference is this number, the minute. So, I'm going to add a loop that counts up the minutes. The minutes will go from 0 to 59. And for each minute, I'll print out all of the possible hours with the current minute. Which I'll pass into print def so I can get rid of my comparison code down here. And let's see how that worked. Well, it's kind of hard to tell, because it's all on one line. What I really want is to have a line break after I finish the first line. So after I've printed out all of the hours, I want to print an empty line to advance down to the next line. And now my table prints out, but there are a couple of issues here. It only goes up to 58 and I said it should go up to 59. And it looks like some is missing up at the top. The stuff that was missing at the bottom Is because of my loop condition. I should have gone to less than or equals and the parts that I'm missing at the top are. Probably because bluej has limited the amount of output that it remembers in the terminal. I'm going to try to going to options and unlimited buffering and then try this again. Now it actually saves all of the data that I wanting to see. Alright, I think we're already for another practice question. Here is a slightly different nested loops question. How would you write nested loops that print out this pattern of square brackets, without the slashes at the front? So you would print one pair of square brackets on the first row, two on the second row, three on the third row and so on. There are a lot of ways to do this that work, it's a little different from the last problem. In the clock problem the number of columns was the same for each row, but here it varies. When you fill in the code for this, make sure to use this variable for the number of rows. This way we'll be able to change it, and this will work for any number of rows. I find that it helps me to break these down. So I'm going to start with just imaging printing the first row. This for loop might seem a little bit silly, but once I write it, I can compare it to the one for the second row. For each column, I want to print out a pair of square brackets, but in this case, the columns start at the first column and only go up to the first column. So that'll look like this. The for loop for the second row will look pretty similar except it'll print two pairs of brackets. One for column 1, one for column 2. So this is interesting, instead of something changing inside the loop, it's the actual loop condition itself that's changing form row to row. The threshold is actually the row itself, now these are exactly the same. So I could set row to 1 and do this and then increment row to 2 and do the exact same thing. Which means that I can put this code into a loop. So I'll indent it, remove the extra repetitions and now instead of just setting row to 1, I'll actually loop over all of the rows starting at 1. And going while row is less than or equal to the total number of rows. Let's see how much progress we've made after fixing typos. Well, it's certainly printing some brackets. Let's put some line breaks between the rows. Much better. This was kind of neat. In this problem, we used the outer loop variable to control the number of iterations in the inner loop. The loop condition of the inner loop depends on the loop counter variable for the outer loop. Another situation in which nested loops often arise is image editing. In the past we've traversed the pixels of an image in a single loop going a row at a time. But there are many situations when it makes more sense to make separate loops for the rows and columns. For example suppose that we want to have this effect where we hide all of the pixels that are outside the circle. In this case, you will want to know what the x and y position of the pixels are. Given values for x and y, you can get a pixel by calling a method called getColorAt and similarly there's a setColorAt that lets you set the color at an x and y location. To get this effect then, we will want to loop through all of the possible x's and all of the possible y's with coordinates x, y and see how close it is to the center point. If this distance is less than the radius of the circle, then we want to leave the pixel untouched. But for a point out here, where the distance is greater than the radius, we want to color this point black by calling setColorAt. Here's the outline of the program. Two nested loops for all values of x and y. Compute the distance. The problem gives you the general formula for computing that and then go ahead and do the coloring. Let's have a look at how to do this. In this case here we were asked to fill in the ranges for x and y. Let's look at the picture, x moves this way starting at 0 and going up to the width minus 1. Y goes this way, also starting at 0 and going up to the height minus 1. That gives this loop for x and this loop for y. We were given a formula for the distance, and we can use that down here. Here it is, simply using center x, center y and x, y for the two points. Now if the distance is larger than the radius, then we should color the pixel black and we're done. A common use for loops is in programs that simulate some activity, such as customers in a supermarket, cars on a road, particles in a physical system. And in such simulations you want to have a degree of randomness, just to model how the real world works. For example, some random time might elapse. Until the next customer arrives, or the customer might buy a random number of articles. So let me show you how to generate random numbers in Java. You construct an object of the Random class. And then you can ask it to give you another integer. You have to give it an upper limit, and you get an integer between zero and n minus one. You can also generate a random floating point number, and then you always get a number that's at least zero but less than one. Let me show you the random number generator in blue jay. Lets make an object by going to the tools menu, use library class, and here in the class field we type in java.util .random and hit the Enter key. Select this constructor and here we have a random number generator. Let's ask it for next double, and we get .05 and change and that looks pretty random. Next time when we ask it we get a different random number, .19 and so on. For integers we'll pick this method over here. We asked for an upper bound and now get a number between zero and 999. In this case I get 781. When I do it again I get a different number. Of course every once in awhile I might get the same number twice. It's random. Now I'll let you play with this. We want to simulate a die and that we get random numbers between one and six. Or actually we might as well model a die with an arbitrary number of sides, and your job is to implement the cast method so that every time that. It's called, it returns a different number between one and the number of sides of the die. There's just a catch. You're going to have to call the next int method, which naturally gives you numbers between zero and n minus one. You want numbers from one to n and I'll leave it to you to figure out how to change one to the other. Has the construction parameter for debugging it's handy to give the random number generator what's called a seed. And as long as you seed a generator with a particular value, then it gives always the same stream of seemingly random numbers. Here we're using a fixed seed, so that you and I get the same answers. And practical applications, people do all sorts of things for a seeding, such as using the time of day. Or when true randomness is desired, they actually have a white noise generator attached to their computer and sample it, so go ahead and implement the cast method. Here is the solution. All you have to do is call nextInt to get a number between zero and sides minus 1. And then you add 1 to it. And you get a nu, number between one and sides. Let's try it out. We'll make a die with six sides. Call cast, get a three, four, and here's a six. Let me show you an interesting application of random numbers. You know what pi is. It's the area of a circle with radius one, and of course, there are formulas for computing pi to any desired precision, but that's no fun. We'll compute pi by shooting darts. Specifically, we'll throw random darts into the square. Most of the time we'll hit the circle, sometimes we'll miss, and the ratio of the hits over the tries is going to be approximately the same as the area of the circle, over the area of the square. The square has side lengths 2, so that's 4, and the area of the circle is of course the desired pi. So how do we do this in Java? We generate a random x between minus 1 and 1. A random y also between minus 1 and 1. Compute the distance from the origin and if that distance was at most 1, then we had a hit. If that distance was larger than 1 then we didn't have a hit. So go ahead and complete the program that does this. The biggest challenge is to get the x and y to be random values between minus 1 and 1. Because nextDouble gives you values that are between 0 and 1. So you will need to be creative to adjust this range to the one that you want. Here is the outline of the dart throwing program. We need to complete the part here where X and Y should be random numbers between minus one and one. So we can't just call generator next double, cause that gets a value between zero and and one, and we want a value from minus one to one. So here's the trick, take the value from zero to one, multiply by two. That gives you a value from zero to two, and then you subtract one, which shifts it to the left by one. Here is the final expression. And of course the very same expression will work for y. Now we need to find whether the point lies in the unit circle. He can compute the distance just like you've done in the telescope problem, but it's actually a little easy in this case. I can take the square of the distance, and check whether that's less equal one, because the square root of one is just one. Don't worry about it if you're just used to formula. It's not a math class, so any correct formula will do. Let's run the program. And once the number of tries, we'll try a million and we get a pretty respectable estimate for pi. And like a said there are better ways of computing pi, but this method of using random numbers for measuring objects is really powerful when the object is irregular. When it's easy to find out whether a point lies in it, but when it's hard to compute the area with traditional means. Let's use the random class to write a program that uses a loop to simulate tossing a 6 sided die 100 times. The die can come up 1, 2, 3, 4, 5, or 6. Write your program so that it prints the number of sixes that come up. You'll need to import java.util.Random to use a random generator. So then I can help you check your work. We're going to do a bit of a magic trick. Random generators can be seeded. What that means is you give them a number to start rolling from, and then they grow a pattern based on that seed. So the sequence they generate will look random, but if you create another random generator like this, they'll both generate the exact same sequence. So all you need to know about that for now, is to declare your random generator this way. Because the grading code will be expecting a sequence of numbers generated with this seed. If you're not sure what I'm talking about, and you're curious, stick around for a moment and I'll demo what this does. But feel free to skip to the quiz. My trusty code pad. I'll create and seed a random generator, and now I'll do the exact same thing, and make another one. Now if I ask the first generator for an int, I'll get 2. And if I ask the other generator for exactly the same thing, I will also get 2. I can do this again, and they still both agree. So while I'm getting random numbers out if this, The numbers are predictable, so we know what to expect and can help you debug your code. I've already got my generator set up, and I imported java.util.Random. I know exactly how many times I want to generate a random number, so I'll use a for loop. I want it to generate 100 numbers, and I want to generate numbers between one and six. If I use it this way, it'll give me numbers 0, 1, 2, 3, 4, and 5. So I have to add one. Now I have a die roll, but I don't just want to roll the die 100 times, I want to count how many sixes there are. So if the value is six, I should increment the number of sixes, which means that I had to initialize it, and at the time I had seen zero so far. But I better not do that inside the loop because then I would reset it every time. Now after the loop completes, I'll print out the number of sixes. If you run this you should get 17. If you take a class in probability theory you will likely hear the story of the Chevalier de Mere. He played two dice games. In game one, he would throw a die four time and bet on at least one six. In game two, he would throw two dice, 24 times and bet on at least one pair of sixes. He thought that the odds of winning both games were 2 3rds. But from experience, he knew or at least his wallet knew that he was wrong. Pascal would later come along to figure out the actual odds and invent probability theory. But we don't care about that right now. We just want to help the poor Chevalier with the drudgery of throwing two dice 24 times. Let's complete this program that simulates game one and game two. These methods should return true if the Chevalier would win. Now there's one subtlety to this problem. In this case, the moment you see a six, you already know that he's won, but our generator is hooked up and doing a particular sequence. So that we can help you check your answer. Make sure to simulate rolling the die four times, even if you already know that he won. I know exactly how many times I want to roll the die. In this case, it's four. Now I get the die value from my generator, which was already defined up here. The same way we did for the last question, and I remember to add a 1 because this will generate numbers between 0 and 5. Now if the die value is 6, then I know that he won. Initially, I was assuming that I hadn't seen any yet. So he hadn't won yet. So he won would start out as false. And it's a Boolean. Now I return whether he won or not. If any of the die values were ever 6, then he won would be set to true. Otherwise, it'll just be left as false, the way it started. Now for game 2. Game 2 has more stuff going on. I still know exactly how many times I want to run, but this time I have to generate two die values. Now, I only say that he won, if both are 6. So if first roll is 6, and second roll is 6. Then 'heWon' is true and I started out assuming that he haven't won and at the end I've returned the value of 'heWon'. Now, if I won the demo, I should get something like this. It's hard to tell from this output what the exact probability of winning would be. But if you're curious, you could run it a whole lot more times. And use the algorithms that you've already worked with to calculate the total number of wins and compare it between game 1 and game 2. Good work on this problem. Here's another way of estimating Pi. Take a one inch needle, and repeatedly drop it on a sheet of ruled paper whose lines are two inches apart. Call it a hit if the needle is hitting one of the lines. If you do this a whole bunch of times, Pi will be approximately equal to the number of drops over the number of hits. If you're curious about the details, you can check out a Wikipedia page on this. Clearly, dropping a needle on the floor, and measuring whether it touches a line thousands of times is not a job that anybody wants to do. Thankfully, we can make our computer simulate the experiment for us. We randomly generate a yLow, or the lowest point of the needle, which should be somewhere between zero and two. Then we calculate an angle a between zero and 180 and use this angle to figure out y high. If y high is more than two we have a hit. Now do this many thousands of times and you'll have an estimate for pi. So again you want to randomly generate y low, randomly generate and angle a And then calculate y high. Which will be y low plus the sine of the angle. And be careful, because math.sine takes radiance, not degrees. Math.toradians can help you with the conversion. You can always review the math facts sheet if you don't quite remember how this works. Here's the start of the program to do this. And when you put in the number of tries, I recommend using a large number. At least 30,000. When you write this code, make sure to use the variable tries to control how many times you drop the needle. First I want to generate a yLow. .nextDouble will give me something between 0 and 1, but I want it to be between 0 and 2, and I definitely want a double. Because yLow could be anywhere between 0 and 2. Then I'll generate another double between 0 and 180, and I'll use both of those to calculate yHigh, which is yLow plus the sin of A in radiance. Now if yHigh is greater than or equal to 2, then I increment the number of hits. But I want to do all of this try as times, so I'll highlight it all, hit tab to indent, and then wrap it in a for loop. And I'll need to actually declare hits. Which starts off at 0. All right. Let's try this. I'm going to try it 30,000 times. 3.13. I guess it's okay. It's not great. Let's try it again. 300,000. It's a little closer to 3.14. How about 3 million or 30 million? 30 million. This one might take a second but not that long. 3.141. We're getting much closer now, but it took 30 million flips. And Pi is actually 3.1415 something or another. So we've only got three digits correct. I think anyone who tried to do this without a computer would be flipping needles for their entire life. This method was simply not viable without a computer. It's a fact of life that no matter how hard we try our programs have bugs. In the olden days, computers had real bugs. For example, the moth that you see here got trapped in a relay of the very first computer in the United States causing it to malfunction. But of course, nowadays, the bugs are usually the fault of the programmer by not having thought through everything. And that's normal. You can find simple bugs by putting print statements into your code, printing out everything in sight. Seeing what goes wrong, and then removing the print statements again, but that's no fun. There's a nifty software tool called a debugger, that you can use to control your program. Stop it and look around, and then find out what it actually does as opposed to what you think it's been doing. Using a debugger is pretty simple, there are three key concepts that you need to master. You can set breakpoints in your program, and then that the debugger will stop when the program reaches a breakpoint. You can then step through your program one instruction at a time. And you can even step inside method calls. And finally, you can inspect the contents of variables. So if you have a variable, you can ask the debugger what's inside at this point. So, these are the three key concepts that you want to keep in mind. Let me show you how to do these in BlueJ. This example program, tries to count the syllables in a word. Let me show you. enter a few words. And as you can see, the program doesn't seem to be doing so well. Hello has two syllables, not one. Yellow also has two. Oh, peach has one. Before debugging this program, let's have a quick look at algorithm is used to count the syllables. Here is our algorithm. We look for groups of vowels. There's one here, another group of length one, and another one, and we count the groups. This word has three syllables. However, here we'll count this group, but we won't count an "e" at the end, because nice only has one syllable. That second rule trips us up with some very short words such as the. We're not counting the E would give us zero syllables and we'll say if that happens we'll change the count to one. To summarize, we count vowel groups but not a final e and if that count gives us zero, we change it one. Now on, just seeing the debugger in action. Open the syllable counter program in BlueJ, and I really suggest that you do that with me. Click in this column here next to the first line of the main method and you'll see a tiny stop sign, that's a break point. Now, run the program in the usual way, and now the debugger wakes up. We've hit this break point and what you see over here is the console that controls the debugger. These buttons here, let you step through the program. Let's try it out. We'll click on step and you can see that we're now in the next line. We click on step again, oh, now it has produced the output here. And we're back where the little arrow is. Now when we step nothing seems to be happening, the arrow is gone. That's because right now, we're reading input. Let's look at the terminal window and here it is waiting for the input. I'll just apply it. Now I hit Enter, and you can see the debugger window again. And back here our program has advanced by one step. Let's bring this to the front. And we're past here. Now to make sure that you are trying this at home, let me ask you to do exactly what I did. Set the break point here, enter hello yellow peach, keep signal stepping. And I'd like you to tell me, how many times are you hitting this line, the call to the constructor, before you get out of the loop. He reached this line three times. Let me show you. Here is the first time after having entered the input. Let's keep stepping. Here is the second time. Here is the third time. And now, watch carefully what happens, we're done with the loop. So we've been here three times. You've just seen how to step over each of these lines. But it didn't really show us where the program misbehaved. The hard part goes on in this countSyllables method. So we want to get inside it. For that we need to use the second step button, the step into button. Let me restart the program and do just that. Here we are again at the first line of the program, we enter the input again, we step over the constructor, and now, going to hit the step into button, and that opens up the Word class. Then we have to look around a bit to find the arrow. We're right now, here. Now we can keep stepping, and that gets us through the lines of countSyllables. So the point is, you use step to stay within the same method, and step into to go inside a method. Now all that stepping can get tedious and sometimes it's better to set more break points and run the program at full speed until one of them gets hit. Let's practice that. You see this line where it says count plus plus? Set a break point by clicking here and now go ahead and restart the program. You'll hit the first break point in main. When you hit it, click the Continue button. So that your program continues at full speed. Supply the same input, and then your program will wake up at this break point. Hit Continue again and keep doing that, and tell me how many times you get the this break point. You should get that three times. Let's try it out. Run the program, here's the initial break point, click on continue, supply the input and here we get to the break point for the first time. Click continue for the second time, for the third time and now our program has terminated. You've seen how to use breakpoints in single stepping, to run your program in slow motion. And of course what you really want to be able to do is look at variables. I'm going to rerun the program until I hit this breakpoint, here I am, and over here in this window, you can see the settings of the local variables. You can see that count is 0, end is 3, and this Boolean inside vowel group is false. Up here you can see the settings of the instance variables, of the class whose method we're currently in. Go ahead at home and do exactly what I just did. Run the program until this breakpoint. Then click continue one more time until this breakpoint is reached for the second time, and tell me what is the value of end when you reach it. At the second stop, end is four. Let me show you. I click on continue, I reach the break point again, and over here, I can see that end has the value four. That's how you inspect variables in the BlueJ debugger. Now, we still haven't found the bug in our program, but Sarah will do that with you in the following segments. In the debugging demo, Ki, noted that the word hello, got truncated to hell. The place where text is set is in the constructor, so something must be wrong in this constructor. Let me set a break point to check it out. I just clicked next to the line I want to stop on. Now, if I run the syllable counter, give it hello yellow peach and hit Enter. It pops up my debugger, and my code shows the line that the debugger is stopped on. So far, not a whole lot has happened. We've just converted S to lower case and put it in text. I want to skip these loops and get to the juicy part and figure out what they computed. So, I'll just single step until I get to the last line. Try that out. What will the local variables, i and j be equal to if you step all the way to this last line? You'll really need to do this in BlueJ because the Udacity IDE doesn't have a debugger. So, if you run syllable counter and enter hello yellow peach and then step to the last line of the constructor, what is the value of I? How about j? If I pick up where I left off and I step and get to the last line, I can see all of my local variables right here. The string s contains hello, i is 0 and j is 4. I and j both sort of look right to me. If i is meant to be the first letter that we include, that would be h, that would be good, and if j was the last letter that we were supposed to include, then that would be 4 which would be o. Let's try stepping through the last line. When you step past that last line, what is the value of text? If I pick up where I left off and hit step, I can see now, that my instance variable text, has been set to health. So what was the error? Can you fix the constructor so that it initializes the text instance variable without losing letters? The problem is that the substring method includes i, and excludes j. So when we have j as 4, substring stops copying over the letters, at 3. I can fix this by adding 1. This is a pretty typical error. So now I'm going to stop this program since I think I've fixed it, by clicking Terminate. If I put in hello yellow peach again, which test cases will pass now? Will hello pass? How about yellow? And peach? The only one that passes is peach. If I pick up where I left off, and click enter, I get that the syllables in all of these words is 1. But peach is the only one for which that's actually correct. Hello and yellow should both have two syllables. The program must have more than one bug. Let's find out what's wrong with the syllable calculation. Before we go too far, let's make sure that text is actually hello. I'll place the break point in the beginning of syllable calculation. I can't place it right here because the declaration of the method isn't really a line that you can run. Now, I'll run the program. It still thinks it's running, so I'll just hit terminate and now I'll run it. Or keep trying that same sentence, and it stopped and it looks like the text is right this time, it's hello. That's good. So, I'll keep stepping. Probably the most interesting part is when count gets incremented. So, let's try stepping it till that happens. Stepping, stepping, keep going, all right, we're getting closer, we're now inside this four, inside the if. We'll step to the next one. Alright, and now I'm at count. What is the value of letter right now? If you step until count is incremented, right here, what is the value of letter? Letter should be e. I can see that, by opening this up a little bit more, and then string letter equals e appears under my local variables. Okay, that makes sense. When we see a vowel, that means it's the start of a new vowel group, which would mark that we have another syllable. Any time we see a vowel that doesn't have another vowel before it, we want to increment count. Now I want you to keep stepping until letter is o, and deposit this line where we set letter to text.substring. If you keep stepping after that line, what happens? Is the first if statement entered? If so, is the second if statement entered, is count incremented, is inside vowel group set to true? Well let's see. I'm stepping, and now I've got letter is equal to o. If I continue stepping, I go inside the first if statement. So I'll check that one off. Now if I step again, I didn't go into the second if statement. So the count isn't incremented. And insideVowelGroup isn't set to true. That was bad. It shouldn't have skipped from here back up to the next letter. The o in Hello is the beginning of a new vowel group, but the program didn't count it that way. It looks like it didn't run these lines, because inside vowel group is already true. But that's a mistake. Inside vowel groups should be false, because the letter before o was l, which is a consonant. How would you fix that? I'll make a few suggestions and you can pick the one you think will work and implement it. Should we remove the condition, if not inside vowel group, so that we always increment counts for vowels. We could change the condition of the inner if block from not inside vowel group to count equals equals 1. We could set inside vowel group to false right after count plus plus or set inside vowel group to false when letter is not a vowel. The answer is, we want to set inside vowel group to false when letter is not a vowel. If we always increment count for vowels, then words like peach would be counted as having two syllables. These two vowels, e and a, are in the same vowel group. So even though there are two, we only want one syllable. If we change the condition of the inner if block from inside vowel group to count equals equals one, Will only increment count when there's already one syllable counted. So we'll never increment count. If we set inside vowel group to false right after count++, we'll never be inside of a vowel group. Every vowel would be counted as a syllable, so this would be a lot like the first option. It wouldn't work well for words that have two vowels together. The last answer is the correct one. When we see a non-vowel, we want to change insideVowelGroup to false. For example, in hello, we see the e and enter a vowel group, but then we see an l, so that ends the vowel group. So now go ahead and fix this code. Once you fix the code, which test cases pass. Does hello pass, how about yellow and peach. Hello, yellow, and peach all pass now. If I go to the code, and when the letter is not a vowel, I change insideVowelGroup to false. Now if I make sure my program is not still running, and then compile, and run it again, it seems like it's counting all of the syllables correctly for these words. So is this program free of bugs? It would be nice if a debugger just took all of the bugs out but it can't tell us. As Edgar Dijkstra said, testing can only show the presence of bugs, not their absence. I bet you can think of a test case that demonstrates another bug in this code. If so, post it on the forum. Hello, and welcome to this new lesson. Today we're going to be taking about Array Lists. An Array List collects objects and all the objects in the Array List need to be of the same type. Now what would we like to collect? Me, personally I'd like to collect valuable paintings. So let's see how we would do that in Java. Here you see the rather long declaration of an Array List that can collect pictures. Let's work through the pieces. We're declaring a variable, called gallery, its type is an ArrayList, but whenever we have an ArrayList we need to also specify the type of the objects that it collects. That's the pictures here, so the whole thing here, ArrayList of picture, is the type of the gallery object. To the right you simply have a constructor call, where you again have to type ArrayList of picture. We have the new operator, because we make a new object off the ArrayList type and the parenthesis here simply mean that we pass nothing to the constructor. What we get is an empty ArrayList, which can, as we add them in, hold as many pictures as we like. Here, we add a couple of pictures to the gallery. The add method, takes as its argument, the object that we want to add. Once you've added objects to an Array List, you'll want to be able to do something with the contents. Let's look at that next An ArrayList collects objects. We call those objects the elements of the list. Here's one way of thinking about an ArrayList. You can think of it as a sequence of mailboxes. Here is how you get an element out of an ArrayList. Remember that gallery was an ArrayList of pictures. The get method can get a picture out of that collection. The argument of the get method is called an index and as it happens in Java the index values start with zero. So the first element is at position zero. The second element is at position one, the third at position two and so on. The get method returns the elements stored at the index position. In our case that's the initial element and we store that in this variable. What if we wanted to get at the last element? Then we need to know how many elements are stored in the ArrayList at this time. The size method tells us that. So gallery.size is the number of elements that's currently stored in this particular ArrayList. Since the first index is zero, the last index is one less than the size. Look at over here. This list here has length five and the last element has index four. Now once we have the last index, we can again use the get method passing at the last index to get the last element out of here. Here you've seen how to access elements individually. More often than not, we actually want to access all of the elements in a loop. So let's have a look at that. In order to work with every element in an ArrayList, you want to call the get method for every valid index. That means zero, one, two and so on up to the size minus one. So here's what we need to put into our four loop. I starts at zero. It get incremented at every step and we stay in the loop while i is less than the size of the ArrayList. So this is the classic loop to traverse all of the elements in an ArrayList. I takes every legal index value, for each i we get the element stored in the ArrayList and then we do something with that element. You will get to try that right now. Go ahead and write a loop that draws every picture in the gallery. Okay, here is our Array List of pictures. A bunch of pictures have already been added and our job is to draw them all. Here is the loop that goes through all of the valid index values. We get the IF picture and we'll draw it. Let's see what happens. Oh yuck. It drew them all on top of each other. I guess it makes sense each picture has as its top left corner 00. So I'd like you to do a better job with this. Draw the IF picture so that its upper left corner is 100 times i for x, and leave y at 0. Alright let's do that. We need to remember that to move a picture one needs to call the translate method. Here we go. And let's see what this looks like. That's a little better, but still that first picture here is very long and the next one overlaps it. So let's see what we really want. What do we really want to do is, have the first picture appear at zero, zero and have the next picture appear a little bit after the last X coordinate of the first one. We could call getMaxX to get that last X coordinate, and then add a small value to it. This way they would be 10 pixels apart. Specifically, I want you to do the following. Remove this call to translate. We'll re-arrange the pictures in a separate loop. In this loop we will look at a picture and the one to the left of it. The picture is at index i and the one to the left at index i minus 1. Call getMaxX on the picture to the left. And use that value to position pic, go ahead and give it a try. Let's tackle this together. Here we have the rightmost value of the picture to the left. We'll add ten and then we translate pic by that amount. That's the statement. Now we need to do that for all of the pictures. So I need to add the loop header. I've done that often enough that my fingers can do it on autopilot. Here goes. Pretty soon your fingers will be able to do that too. Let's go and compile, and let's run the program. Hm, that did not seem to work, now did it? Let's see. The program crashed, and I am told that there is an ArrayIndexOutOfBoundsException, and the index that was out of bounds was minus one. Well, minus one is not a valid array index. And why would I have gotten a minus one. Oh look at this i is 0, so over here this i is 0 and then the i minus 1 is 0 minus 1 and that's bad. Now the problem is that when I am at the zeroth picture, that is the initial picture in this sequence. There is nothing to the left, so the remedy is to start here. With i equals 1. The zeroth picture just stays where it was. Picture at index one then gets moved to the right of the one at index zero, and that's all great. So in this case, my fingers shouldn't have been on auto pilot, but I should have thought through what values for i, I actually want. It's very, very common in actual programming to get these kinds of errors. And I wanted to show how it looks like when you do. Now let's try this. And look at that, our pictures are finally arranged in a neat sequence. So, I want to show you one more thing. Here, we have two loops. This one arranges the pictures. The one over here draws the pictures. Now, the second loop is so simple and so common, that there is a shorthand for it called the enhanced for loop. Instead of letting the index value, i, go from zero, through all the valid values. And then using the index, to get the ith picture, you can do the following. You can simply write for, then you make a variable for the picture. Then you write a colon, and then the array list that you want to traverse. This loop sets pic to the first element in the gallery. Or I guess I should say the zeroth element, then to the element within index one, then to the element with index two, and so on. So pic assumes and turn all of the values off the array list each time the loop is entered and in this case, pic is drawn. You could do other things as well, of course. Could we have done the same thing with a loop over here? Not really because in this loop we didn't traverse all of the pictures, we skipped the zeroth one. You can only use the enhanced for loop when you look at all of the elements of an array list. And there's another reason when you use the enhanced for loop you don't actually know the index value. Of any of the elements. And, over here, we needed the index value because we had the i-th element, and then the i minus first element. But, I'll give you a challenge question, and that is, to rethink the logic of this loop, and rewrite it, as an enhanced for loop, like this. And to make that a little bit easier, you get to position the first image, at offset ten. So put ten pixels before the first image, before the second, before the third, and so on. This problem is a little bit tricky, because you have to completely rethink the approach. Previously, we looked at a picture,and the one to the left. But when we use an enhance photo, we only get to look at one picture at a time, so we have to remember something from the past. The way I've done it is, I would remember the rightmost position of the previous picture. Let me show you. I have an enhanced for loop, and when I'm done positioning the picture, I remember its rightmostX value. So when I reenter the loop with the next picture, then I can position it 10 further than the rightmostX value. And they're always spaced apart nicely. What about he first picture? If I start the rightmostX at 0, then the first picture ends up at offset 10. So that's the answer. And now when you look at these two loops, you can see that we can actually merge them. So we do the positioning and drawing in a single loop. That's enough about pictures for right now. Sarah will show you another application of array lists. She'll revisit a class that you've seen in lesson three. The person class that collected friends, at that time we did it in lesson than perfect way by just having one long string of friend names. Now that you know how to collect objects, she'll collect the friends in an array list. Alright, over to you Sarah. Now that you know a little bit about ArrayLists, it's time to revisit an old friend, the Person class. I removed some of the methods and added one new one. GetFriend gets the ith friend, but as you can see it's a pretty ugly method. This is bad code. I wasn't careful when I wrote it and it's messy. It would work alright if my friends are named Madonna, Sting, and Cher. But most people have spaces in their names. Maybe I could fix this by separating the names with commas or semicolons. I could change the separator here. But that won't really fix the underlying problem. The underlying problem is that reality has structure and we need to choose the right data types to model that structure. In our case we have multiple individual people. A string of names isn't the right way to save a bunch of individuals who all play a similar role. An ArrayList would be much better for this. Saving an ArrayList of Person objects, instead of just a string of friends would allow us to do a lot of cool things. For example, we could add a string nationality to each person. And then you can get a list of all the countries your friends are from. But let's work our way up to problems like that. First, let's store the friends in an ArrayList of strings without changing the observable behavior. In software engineering this would be called refactoring. Refactoring is when you reorganize code. The implementation changes. The observable behavior does not change. Often we do this to make it easier to add new features. Now I want you to refactor the person class. I'll give you some tests so you can make sure nothing breaks in the process. You'll need to update the instance variables. Save the friend's names in an ArrayList of strings. You'll need to update addFriend, getFriend and getFriends. We'll skip unfriend for the moment, but we will come back to it later. And I'm going to give you a hint. Do you remember the toString method from lesson two? ToString returns a representation of the object, and works pretty well for ArrayList of strings. Let me show you what it does. If I create an ArrayList, strs, and add a couple of strings to it, like this, and then I call the toString method. The toString method returns, a string, that has the values separated by commas and spaces and then surrounded by brackets. This is pretty close to what you want for the getFriends method. For the getFriends method, you just want the values separated by commas and spaces. And here's one last hint. If you get an error that Java doesn't know what an ArrayList is, you might need to import it. To do this, I'll first add a new variable. I'll call it friends2 for now. Now in the constructor, I need to initialize friends2, and there's that error. I needed to import it. So far so good. Now I'll fix addfriend. I'll add the friend to both of the lists that I'm keeping track of right now. I tried to add the whole friend instead of just the name. Much better. Let's see if the tests are still passing. Person tester. Looks like things are matching, so I'll go to getfriends. Instead of using friends, I want to use friends2, but friends2 is an array list, so I need to get a string representation of it. But toString returns brackets around what I want, so I'll need to remove the brackets using substring. I'll put it in a variable, and now I'll return substring, starting with the second character and stopping before the last character. Let's see if the tests still pass. Looks like everything is still matching, except that there's a trailing comma right here. But that's the getfriend method, so I'll come back to that. And now for the especially satisfying one. I'll get to delete all of this code and replace it with one line. I'll get the element of the ArrayList at friendIndex, and now everything is actually matching what we wanted it to. But I need to clean up my extra unused variables. I still have this private String friends, and I'm not using it anywhere, or at least I shouldn't be. So I'll delete it there, and here, and here, and I think that's all of it. But now friends2 has a sort of silly name. So I just want to change friends2 to be friends. So I'll use find replace and replace all of the occurences. Creating an extra variable might have looked like extra work, and if you didn't do all of that, that's fine. I did it to show you how you might approach a much larger refactoring. Sometimes when you're working on a very big refactoring, it's good to make sure that everything still works at each intermediate stage. You'll learn more about that if you take a job as a software engineer. So what did all of that refactoring get us? Well, think about how you would implement this method now. Before, we had to create a local variable and remember to increment it when we added a friend and decrement it when we took away a friend. Implement getNumFriends, think about the ArrayList methods we talked about that might help you. You can do this by adding one line. In the person class, we can now implement the getNumFriends method by returning the size of the friends ArrayList. Looks like it worked. Storing our friends in an ArrayList instead of a string made it easier for us to add some useful features. Now friends can have spaces in their names and I can have multiple friends with the same name. It's easy to answer questions like, how many friends does someone have or who is the fifth friend on my list? But you may have noticed that we haven't touched the un-friend method. For that we would need to modify the ArrayList, back to Kai to tell us how to do that. Now you've had a lot of practice, making, and traversing array lists, but what if you want to modify their contents? You know how to get an element, and if you want to change it, you use a very similar method, the set method. So, over here, we're calling set, with an index, and the new value. Whatever was there before at position two is now replaced with this new value. In the next exercise you will see a couple of lines of code involving get and set that try to swap two pictures in our gallery but when you run it you'll see it's not working. Your job is to fix it. Here's the bad code, let's see what's bad about it. When you run the program, then the gallery looks like this. Clearly it is not swapping. The pictures had position one and two. Instead, there's seems to be a gap here. Let's, first of all, understand that gap before we go and fix it. Here's the original gallery. Let me write the index values so it makes it easier to follow along what happens. Now, we're taking the element at position one, that's this fellow here. And now we're setting this one here to this picture. So now, over here, this element is also that same guy, pardon my drawing skills, obviously I'm not Gauguin. We get that's this fellow again and put him into slot one. So what we would expect is to see him twice maybe. Except remember that what we we're having in the array list are not objects, but object references. So here's what the array list really looks like. The zero slot, as a reference to this object. The one and two slot have a reference to the exact same object, and then the three and four point to these ones, and I won't draw those arrows. The point is that these ones are the exact same object, and so it's drawn twice, but you don't see that because it gets drawn on top of itself. The gap was just an artifact of the positioning. Never mind the gap, what's important is that if you first copy this one over here you wipe out the element that's in here and then when you copy back then you just get two identical values in the array. That's no good. So what we need to do is instead of wiping out the bridge here at position two, we need to save it. Let's do that. Here we're saving the old value. At slot two, then we can set slot two to what we want. And now here, instead of using the new value, we'll use the old one. I'll go ahead and run this and you'll see that the elements at one and two are swapped. Here you see them. Get and set are certainly the most basic operations on an array list. But there are a bunch of others that are also quite convenient. Let's have a look at those. The add and remove methods, let's you add elements or remove them at arbitrary index positions. So if we add a bunch of pictures and now we add one at position 0, the new one gets added here and what used to be position 0 is now position one. What used to be position one is now position two and so on. Now let's look at remove, here we remove the element at position two. And the other offsets of course, are now different. Note that you've seen a different version of the add method when we first learned about array lists. That method did not have a position, when you omit the position, then add simply adds it at the end of the array list. In the next exercise I'd like you to put add and remove to work. Here's what I want you to do. When you have an array list of pictures, I want you to slide the last one to the front so that all the others get shifted to the right. Go ahead and give it a try. The task at hand was simply to remove the last element off the list and insert it as the first one. Let's look at the code, the index of the last element is the size minus one. That's the one that we remove. Now as it happens the remove method returns the element that it was removed. Now you might say that's not fair, how was I suppose to know that? So let's say that you didn't. In that case, you could have done it in two steps. You could first get the element and then remove it. Either way will work. Let me get back to my original way because it's a bit shorter. Now that we've removed the last element we simply stick it at the very beginning, like this. And there you have it, what was previously the last element is now the initial one. Sara has a couple more exercise prepared for you where you practice working with set, add and remove. Have fun. I'm keeping a list of books I want to read. Realistically, this would probably have 50 items in it, but right now I'll keep it short. I'll start reading again when you're writing your own programs from scratch in Java. Let's say there are six books in my list to read for now. I'll store them as strings in an array list, so they would be indexed like this. For now I'll store them as strings to make this exercise less typing, but if I were doing this for real, I would probably make a book class, so I could store authors and my friend who recommended the book to me. Now a friend just recommended that I read Why Zebras Don't Get Ulcers. I've decided that I want to read it after I read Night Watch but before I read Next. What would method should I use to insert Why Zebras Don't Get Ulcers after Night Watch and before Next without removing anything from the list? Originally, I create the list by using add. And now I want to insert an element without wiping away anything. I can't just use the add method because that would add it on to the end of a list and I want to put it in the middle. So I'll specify the index where I want to add it. So the index I would want is two. Now I always forget whether the index or the element comes first, but that's okay, I can always check. All I have to do is search for ArrayList, Java 7, go to the official documentation, and I know what method I'm looking for, so I'll search, for add, and here I can see the index comes before the element. So the index I wanted was two. And I'm adding another book. And now when I run the demo it'll print The Eyre Affair, Night Watch, followed by zebras and then next, just like I asked. So I actually read the Eyre Affair already, but it was really fantastic and I want to read the sequel. So instead of deleting the Eyre Affair, I want to put the sequel, Lost in a Good Book, on my list in place of the Eyre Affair. What method should I use to replace the Eyre Affair with Lost in a Good Book? So back in the book list demo I have my list of books to read and here I want to replace the Eyre Affair with the sequel. When I want to replace an element I use the set method and the Eyre Affair is element zero. So now that reference at element zero will be a reference to Lost in a Good Book instead of the Eyre Affair and you can see this by running the method again. Now it starts with Lost in a Good Book. Wait a minute, I've already read The Brain That Changes Itself. Who put that there? Please take that one off the list for me. To take The Brain That Changes Itself off the list, I first have to figure out what its index is. Originally, it was three. Zero, one, two, three, but then I added another one, before it, so now it's four. So I'll remove the item at index four. I think you're more familiar with basic ArrayList modifications now. Let's go back to Kai to talk about, how to do computations that take the entire ArrayList into account. In this section, we'll be talking about some common algorithms. I'll explain to you the problem that we want to solve. I'll explain to you the general algorithm and then I'll leave it to you to implement it in Java and then we'll talk together about the implementation. Let's start with the algorithm to compute the sum of values in an ArrayList. Suppose we have a bunch of pictures that we want to arrange horizontally, the total width of all of them depends on the sum of the widths of all of the individual ones. To compute the sum, we'll of course need a variable to hold it. And I'll just write it in a pseudo-code here. Now for each element in the array, add to the sum to measure of that element. And I'm writing it in this generic form so that you can reuse the algorithm for other situations. In our case, the element is a picture in the ArrayList of pictures. And the measure is the width, and here we're summing up the various widths. But in other situations you may be, if wanting to compute some other things, maybe the prices of some articles. So that's the general algorithm, now your job will be to complete code for the specific case of summing the width of pictures. So here I've have set up the ArrayList of pictures for you. Here is a statement to print the result and your job will be to put in the Java code for the algorithm that I've just described. Have a go at it and then we'll compare notes. So here is the algorithm that we now need to translate into Java. Let's do it. I declare a variable to hold the sum. I declare a loop to visit all of the pictures in the gallery. The enhanced photo will do nicely here because I need to visit all of the pictures and I don't care in which order. For each picture, I compute it's width and I update the sum. At the end of the loop the sum will be the sum of all of the widths and here it is printed. That's all. Let's move on to our next algorithm. In our next algorithm, we want to find the largest element in an array list. Again, let's look at the example of our pictures. We might want to know the largest one, to know how much vertical space we need on the wall. Or maybe we want to center them all with respect to the largest one, then we need to know the largest one first. In this algorithm, we start assuming. That, the first element, or rather the element at index 0, is the largest one. Then we look at all other elements, and if an element is larger, by some measure, than the largest element, then we change our mind, and now say the largest element, is the one that we've just seen. So in this example, for example, we would start off by saying, oh, the first one that we've seen, that's the tallest picture. Then we move onto the next one, and say that one is taller so I'm changing my mind, and now this one is now the tallest. this one is even a bit taller, so that one must be the tallest. Now this one here is not as tall so we no longer change our mind. And the last one that was considered to be the tallest is in fact, the one. Just like we've done before, I now leave it to you to implement this code in Java, and this time I want you to actually draw the tallest picture. Go ahead. Alright, let's do it together. The algorithm started out by assuming that the tallest one is the one at position zero. Now, we want to visit all other elements. For that, we can't really use the enhanced for loop, that would visit all elements including the one at zero, which we no longer care about, so we'll use a regular for loop. Here's the loop. Notice that i starts at one, and not at zero, because we no longer want to look at the element at index zero. With this loop, we only look to the index values, and we still need to get the element at that value. Now we're ready to compare the current one against the tallest one. That comparison is here. In that case, we change our mind, and say the tallest one is no pic. When you run the code the tallest one will be displayed, and it's this one. Let's move on to another algorithm. In this algorithm we will count all of the elements that match a certain criteria. When you have a picture, we say that the picture is in landscape orientation if it is wider than it is tall. Most, but not all of these pictures, of course, contain a landscape. We say that the picture is in portrait orientation if it is taller, than it is wide. Now let's say we have a bunch of pictures and we want to count how many of them are in portrait orientation. That's an example of a counting problem, in general you keep a counter. You visit each element. If the element is a match for whatever it is you're looking for you increment the counter. What does it mean to be a match? Well that depends on the problem. If you have an array of bacteria, we might be looking for the ones that are beneficial. If you have an array of pictures, like we have in our example, we happen to want to know the ones that are portrait. Those are the ones for which the height is greater than the width. Now that's your job in the next quiz. Complete the program so that it counts, how many pictures are taller than their way. Our job here is to figure out how many of these pictures are in portrait orientation. It's a counting task. We start by declaring counter. Now, we want to look through all of the elements of the array list. And since we want to go through all of them, we can use the enhanced for loop. We consider the picture a match if it's taller than it is wide. And it seems a good idea in this case to make a comment to explain that. And when we do have a match, then we increment the counter, and that's all. When we run the program, we're told that there three matching pictures. It would be kind of nice to know which ones they are, and we'll get to that soon. In the previous algorithm you've seen how many elements match a condition but we didn't get to see any of the elements that match. Let's start modestly and say we want to see the first one. That's a match. So here in our series of pictures we just want to find the first one that is a portrait which I guess here just happens to be this one. The difficulty with this algorithm is that we don't really want to look at all of the elements, we want to stop as soon as we have found one. Let's set a Boolean variable. We'll keep looking while we haven't found a match. If the ith element matches, then we set found to true, and otherwise, we increment i. We still need to be clear about what i is. i should start at zero, and of course i shouldn't get too large. It needs to be less than the size of the collection. Now when we terminated this loop there are two possibilities. Maybe there wasn't any match in there at all. You could imagine a picture gallery only with landscapes. But if there was at least one match, then i is the index of that match. Once again it's your turn. Draw the first portrait in the gallery. As you see in the algorithm for finding the first match was a bit more involved, and it looks like our friendly [INAUDIBLE] 's have given us some more starter code. We have an integer index that starts at zero. We have a boolean variable to keep track of whether we already found a match. Now, we have to keep looking while what? First of all, while we haven't yet found a match, and while we'll still have a chance of finding one. Now I is the index. We need the actual picture at that index. Here it is. We need to check whether it's a match. It's a match if it's taller than it is wide. Now if it is a match, then we set found to true. Otherwise, we keep on looking at the next position. Finally, if we have found a match, then we need to draw it. Where do we find it? Well, at position I. So we get it from here. When you run the program, it shows the first match. It happens to be this one. It might be nice to know what all the matches are. And as it turns out, that's actually easier to do then finding the first one. Let's see how to do that. You've seen how to find the first match now we want to find them all. In our picture example we just want to collect all of the portraits. This one, and this one. Now if we want to collect them we need to put them somewhere. And you just learned how to collect stuff, namely with an ArrayList. So we have two ArrayLists, the one that contains the elements that we inspect and the one in which we will collect our matches. Now for each element in the original ArrayList we check if it's a match and if so we add the matching element to the ArrayList matches. When this loop is complete matches contains all matches. Like I said this one is actually simpler because we don't need to keep track of whether we have found the first one we don't need to stop after we found the first one. Go ahead and implement it in Java. Here's the starter code that we were given. We were already given the declaration, for this variable, but we still have to initialize it. And down here is, the loop, that we've had at the beginning of this lesson, that arranges, all of the pictures. This time, all of the pictures inside matches, so that they appear side by side. Our job is, to fill up, the ArrayList matches. We need to initialize the variable, and here is the expression. We called the new operator, because we want to have a new object and the type of the object is ArrayList off the picture. The parenthesis here, again, just means that we call the construct. Next, we loop through all of the pictures in the original array list. For each one we decide whether it's a match. And so we added to this ArrayList, that's all. As it happens with this set of pictures there are two matches. Those of them are displayed here. Now you've seen quite a few useful algorithms, but maybe your getting a bit tired of our galleries here. Go ahead and practice them with Sarah in a different context. Iterating over structures like ArrayLists is very important. So let's make sure you've got this down. Let's return to the getFriends method. It was pretty convenient that the two string method printed out almost exactly what we wanted before. But how would we have printed the names of friends without the two string method? Or what if we wanted to use a semicolon instead of a comma? Lets update the getFriends method so that it takes a string separator as a parameter. It should still return a string. You should use the tester I wrote to check your code. This method is a little bit like a sum over all the elements, but you're putting together a string instead of a sum of numbers and you'll need to be careful at the edges. You only want to print separators in between names, you don't want to print one after the last name. In the new space for the getFriends method I want to start by creating a string that I can use to collect all of the names. Now I'll want to add all of the friends. So I'll loop through all of the friends, one at a time, and I'll add the separator and the ith friend's name onto that variable I was using as the collector. But as this is right now it's going to print out a separator before the fist name. So I need to look for a special case. In the regular case, where we're not looking at the very first friend, we'll add the separator and the friend's name. But if we are looking at the very first friend, then we just add the friend's name. I'll just fix a couple syntax errors, and I'll remember to return that variable that I used to collect all the names and now when I run the tester, I can see that it works with whatever kind of separators I put in, whether it's a semicolon, a vertical bar, or a unicode heart. While we're looking at the person class, we didn't implement the unfriend method when we refactored our code. But now you know how to remove items from an array list. So let me see. If I want to remove a person, nonfriend. what if I try getting the name of nonfriend, going through the list to find its index, and then removing that index? Is there anything wrong with this? Refactoring to save an array list of the friends names was a step in the right direction, but not enough. If I have two friends with the same name, I wouldn't know which one to remove. In fact, I can't even tell if I have the same friend in here twice right now. I shouldn't just be storing a list of the friends' names, I should be storing a list of the person object associated with each friend. So let's refactor again I'll make my ArrayList of String that I called friends before into an ArrayList of Person. Now I'll have to fix the way I initialize it in the constructor. And let's look at that implementation of the getFriends method with the separator. Now I need to actually get the name out of the friend stored at this position. I'll show you what happens if I don't do that. Whenever I try to print out the result of getFriends, instead of printing the person's name, it's printing the class, and this weird jumble of symbols. Right now, the array list to string method doesn't know how to make a string representation of a person. So it just prints the reference. These symbols make sense to the computer, but not to people. So to avoid that mess, in the getFriends method, I'll get the name from the friend, and add that And I'll do it in both spots. Can you finish the rest of this refactoring? So, I'll pick up where I left off. I wrote those tests to protect the functionality of the person class. So, I can run them again to find out which method's broke when I changed the friends variable. Looks like the first thing that's broken is that I'm trying to add a string into my array list of person. So, I no longer need to get the name out of the friend before adding it. If I run the test, it looks like the getFriends method is still broken. But the getFriends method that takes a separator is good. The get number of friends method seems to be working alright still. So I'll need to look at this original getFriends method. When we run the two string method on the friends array list, it doesn't have a good way of printing a simple representation for each friend. I can think of two convenient solutions to this problem. One possibility is to delete this, and just use the other getFriends method, that we already fixed. I'll just call getFriends, and pass in a comma and a space as a separator. And now if I run the test, the getFriends method prints what I would hope. But there's another way I might have implemented this getFriends method. I could just add a toString method to the Person class. If the toString method returns the name, then I could implement getFriends the way I did before. So here's approximately what I had before, and if I run the tester again, I can see that the getFriends method is working. This is because when I called toString on the arraylist of Friends, it uses each friend's toString method, to get it's name. Well, actually just to get a representation of it, which in this case, is the name. This implementation will work, so long as I don't want the person to return something more than the name, in its toString method. That last refactoring made our code much better, now when we remove a friend, we can be sure we are removing the right friend. Next you're going to implement the unfriend method but first I want to tell you a secret, classes can have secret methods, here is an example, this private helper method can't be seen outside of the person class, they are only used inside to help with other methods. This one searches for a friend and returns its index. If it doesn't find the friend, it returns minus 1. You should implement the unfriend method and you can use find in your implementation. Now that the friends are in an array list. To remove a friend, I just needs to know its index, and then I can call friends.remove, and that one will be erased, and the indexes will be fixed. In BlueJ, that would look like this. I would find the index of the nonFriend, using the find method, and then remove the friend, at nonFriendIndex. But I need to be a little bit careful, nonFriendIndex could be minus one. I can't remove the person if they're not there to begin with. So if the nonFriendIndex is not minus one, then I remove the friend. Otherwise, I don't do anything. What if I want to rearrange my friends list, based on who I talked to last. I'll add a method, talkTo, which takes a friend, which, wherever they are on the list, will take them, and move them up to the front of the list. There's one odd situation we would need to think about. What should happen if the given person isn't a friend? To decide this, we would need to think about this situation we're modeling. Do you add every person you talk to, as a friend? That would be pretty cool. We'd all have a lot of friends, but I think that's not realistic. So in this case, let's say if you talked to somebody who isn't a friend at all yet, nothing changes. How would you implement the talkTo method? I'm going to use the find method again. I need to find the index of the person I want to move. In this example it would be four. Then I need to remove them from that spot, so that I won't have two copies of that person in the list. And then the induces would change accordingly. Then once I've removed them, then I want to add them at the front. I'm going to use add instead of set, because I don't wipe to away the zeroth one, I just want to move everybody down. So now this will be zero, this will be one, two, three, four, five. In BlueJ that would look like, get the Old Index, by finding the Person. And then if that Person is already a friend we remove them from their old position and insert them into the zeroth spot. If they're not already a friend, then we don't have to do anything. Now for the last method we'll write for the friend's class, at least for this lesson. It's possible right now for John to have TJ as a friend and TJ not to have John back. Let's write a method, removeMeanFriends, that removes all of the friends that don't like John back. So for example, if John has friends, TJ, Maria, Jamesha and Joe. Let's say Jamesha and Joe both like John back, but TJ and Maria don't. So we want to remove TJ and Maria from John's friends list. So in this case we'll start with TJ at index zero. So we'll remove TJ from the list. Now the list gets re-indexed. To look at the next person in the list we need to look at the zeroth person again. So we can't just have a counter variable that we increment by one each time. We look at Maria and Maria also doesn't like John. So we'll remove Maria and the rest of the list will get re-indexed again. So yet again to look at the next person we have to look at the zeroth person. We look at Jamesha and Jamesha likes John, so she should stay in the list. We'll increment the counter and look at the next person. Joe likes John, so we'll keep Joe in the list. So we should increment the counter variable and look at the next person, which would be at index two. But two is no longer a valid index. Even though it was, originally. So we're done. What if I try to code the removeMeanFriends method this way. What's wrong with this code? Sometimes it will not remove enough friends, sometimes it will remove too many friends, or sometimes an Index Out of Bounds exception will occur. As a hint, this condition means, this person is not in person i's friends list. This question is diffuclt. You don't have to get it right on the first try. The answer is, sometimes it will not remove enough friends. Let's trace through an example and talk about why. For this John example, in the for loop we start with i is 0, i is less than the number of friends. The friend at position 0 doesn't like John, so we remove that friend. And now the indexes of the friends change. Whereas before this was 0, 1, 2, 3. Now, it's 0, 1, 2. So we'll check if the friend at position 1 likes John back. The person at position 1 is Jamesha, and Jamesha does like John back. So we skip over this, and come back up to the top of the loop. Now i is 2. So we check if friend 2 likes John back, friend 2 does like John back so we'll come back up to the top of the loop skipping the remove step and now i is 3 which is now less than the number of friends so we're done but Maria never got removed. After removing TJ, Maria's index went from 1 to 0, but the counter in the loop went from 0 to 1. So we never checked whether Maria should be removed or not. This code will sometimes skip friends and not check if they should be removed. Now it's your turn to code the Remove Mean Friends method in BlueJ. I'll show you some working pseudocode, but feel free to try it yourself first, and then come back to look at the pseudocode. We'll create a variable i, which starts at the beginning of the friends list. Now, while i is a valid index of friends, we either remove the i-th friend or increment i. We remove the ith friend if the ith friend doesn't have this person as a friend. And otherwise we increment i. Kai would like you to pay close attention to the answer to this question, even if you get it right. This algorithm is going to be important again, later in the course. To code this in Bluejay, we'll start creating that int i, which was starting at zero. Now, while i is a valid index, so it's less than the size of friends, we either remove the i'th friend or increment i. So, if the condition holds, then we remove the i'th friend. Otherwise we increment I. And the condition is the same one that we saw in that buggy version. We get the i'th friend and then try to find this person in the i'th friend's friend list. And if the index of this person is negative one, then we know that the friendship isn't mutual and we should remove that friend. Now let's test it. Looks like our expectations match. We've been talking about array lists up to now and array lists are very flexible, but there are times when arrays are lower level construct are more useful. Here is how to make an array of values of type double. As you can see, it looks quite different than the declaration of an array list, so let's take it apart. Over here is the type, it's an array indicated by these brackets of double. This is the variable. Here's the new operator and back here we say we want to construct an array of ten doubles, so as you can see you put the length of the array inside the brackets, unlike with arrayLists, the size of an array can never change, this array here has been made with ten numbers and it'll always have ten numbers in it. No more and no less. There's a second way of constructing an array that's often very convenient. Here I have again an array of floating point numbers. I call it moreValues. And over here I simply put enclosed inside braces the values that I want to put in the array. This array has length five and again it'll always have length five. Let's see how we can access the individual array elements. With arrays, you don't call a method to get at an element. Remember with an array list we would have called .get, but with an array you use the brackets and you put the index inside. The values bracket zero, is the equivalent of calling values, dot get zero. For an array you use the brackets. For an array list, you use a method. You use the same notation if you want to store something, into an array. So here values bracket zero equals 42 means put the number 42 into the zero slot of this array. That's a little simpler than with array lists where we would have had to call .set(0,42). How can we look at all of the elements of an array? That's very similar as with array lists. Here we have a for loop. We want to look at values bracket i and i goes from zero to one less than the length of the array. With an array list we would have called dot size. Note that length does not have parentheses. That's just an oddity for historical reasons. We simply looked at all of the elements in the array, and as with an array list, we can use an enhanced for loop to make this a little simpler. Here's the equivalent enhanced for loop, over here is our array. We want value to assume each of the elements in turn, and then we use it. Note that with the enhance for loop, you cant tell any difference between an array and an array list. You put the array, array list to the right of the colon, and the variable to the left of the colon gets assigned each element in term. It's nice that array syntax is so compact, but it has a lot of punctuation to memorize, for practice how would you declare an array containing the first five primes in one line, and the first five primes are 2, 3, 5, 7 and 11. Put your code here. Here's the answer. The type of an array is always the type of the items that it contains followed by square brackets. I named this one primes, and to build the array itself, I used curly braces and separate all of the items by commas. If we declare primes as we just did, and then run this for loop, what will primes contain? Separate items with commas. The answer is two, three, five, three, two we start out with i as zero so primes four takes on the value of prime zero, so 11 is replaced with two, now we go through again but this time i is one. So we look at primes three, and fill it with the values from primes one. So seven is replaced with three. And i would be two, so we break out of the loop. If I declare an array values and initialize it with new int 10. Write statements that put the value 10 into the spots with the lowest index and the highest index. So, if this was your array, put 10 here and here. The most robust way to do this would be to set the 0 value to 10, and then to set the last value to 10 use values.length and subtract 1. Instead of writing values of values.length minus 1 we could have written values of 9 equals 10. This is a good answer too but it will only work if the array has exactly ten elements in it. This one will work for any size of array Let's practice a couple more declarations. How would you declare an array of strings, with space for 10 values? How would you declare an array of strings, that contains two values? Yes, and no. To declare an array of strings with space for ten values, we would make the variable, and give it a type of string array, and an initial value of a new string array with space for ten items. To declare an array of strings that contains two values, yes and no, we'll use the curly brace notation. The type is the same as before, but now we put the strings, yes and no, in the curly braces separated by commas. Some loops are better written with an enhanced for loop, and some are better left alone. Here are three different for loops, the first one, the second one and the third one. Check the box for the for loops that might be better written with an enhanced for loop. The answer is, the first one can be written as an enhanced for loop. These other two would require lots of extra counting variables and things to make them work that way. This one would be difficult to write as an enhanced for loop because it's using the index i to calculate a value, it's also changing the values stored in the array. Both of those things are harder to do with an enhanced for loop. This one would be hard to do with an enhanced for loop, because it's not actually looking at all of the values in order. It starts at Index one, and while looking at any one index, it's also looking at the last index. In an enhanced for loop, you will only get one at a time, and would have to do some fancy trick to remember the last one that you'd seen. This way is much simpler. So, we have arrays and we have arraylists, and it's a bit of a nuisance that we have both. Because it means that we have to make a decision between them whenever we want to collect elements. Generally, arraylists are more convenient because they can grow and shrink. But there are a few reasons why you might want to prefer arrays. First off, the syntax for the brackets, is more compact. For example here, we assign values one to values two and that's a bit easier to read than the equivalent with arraylists, which you see over here. Also, if you know exactly what values you want in a collection, then arrays give you an easier syntax. Here I have a string of workdays, and I know exactly that I want these five strings. No more, no less. I know what they are. Then I can use this handy syntax, to construct an array and initialize it right away. With an array list, I would have to call the add method five times, once for each of these strings. Another disadvantage of array lists is that they don't work well with numbers. We have never done that so far, but let's say we wanted to collect Numbers in an array list, I'd have to do something like this, and when you look carefully, you'll notice that the double here, has an uppercase D. Normally, when we want to have a floating point number, we write double with a lowercase d, and you may recall that the number types are not classes in Java. But inside, the angle brackets here, I must put in a class. An array list can only collect objects of a class. So for every number time, There is a companion class, called the wrapper class. And an object, of a wrapper, just has some number inside. If you have lots of numbers, say for the sake of the argument you have, 1,000,000 values, it takes a lot more space to store 1,000,000 wrappers each of which contains a number, than it would be to use an array That's contains the numbers directly. Most of the time, we're not that concerned about efficiency, but when you are, and need to collect a lot of numbers, definitely use an array. In conclusion, use an array list as a rule of thumb, unless you want the nice syntax that an array gives you. You having the brackets, having the initializers. Or you collect lots of numbers. In that case, array lists are quite inefficient. One challenge when using arrays is that the length is fixed. So let's say that you need to collect some numbers and you don't quite know how many, you're going to have to make an array that's large enough to hold them all. But then you may have fewer numbers in the array. Then it can hold. We say such an array is partially filled, just like this beaker over here. You wouldn't want it to be filled up all the way to the rim. And in this situation you need to keep track of two things. You need, the overall length of the array. So here I'll assume I'll never have more than 1000 numbers. I allocate my array to have this length and then I keep a companion variable that I call the size that tells me how many elements I currently have. Right now, I don't have any. Whenever I need to insert a new element, I execute this code here. I move the new value into values in bracket size, and then I increment the size. For example, to insert the very first element, size is 0, values bracket 0, is now initialized, and the size becomes 1. The next time, values of 1 Gets filled and so on. Now what happens if I fill up the array with a thousand values and then want to add the thousand and first. Let's have a look at that situation. So here I have my partially filled beaker. I fill in more and more, and eventually when it gets full, what choice do I have? I have to get a bigger one and pour everything into that. It's the same with partially filled arrays. So, here's my array. It's almost full. Now it's completely full. I'd like to add another element. So, I'll get myself an array that's twice as long, copy over all the values, and now I can forget about the old array, and insert my next element over here. Of course, one can program that by hand, but as it happens There's a library function that does the work for us. Here it is. The copyOf function takes an array and then the desired length of the larger array. It then makes the larger array and copies the original one in there, returns the large array, and we just capture it here again. So that's what you'd have to do if you're ever faced with a situation Where you want to collect an arbitrary number of values. It's that kind of thing that makes you appreciate the array lists where you never have to worry about growing an array. A lot of teachers have to add up all their students scores to calculate final grades. When I was in middle school a lot of my teachers had a paper grade book, but by putting scores into a computer, teachers might save themselves some work. We're going to build a HomeworkScores class that will read all of the scores for one student and give useful summaries of their work. Eventually it will be able to calculate the total and average scores, and drop the lowest. But first it needs to read the scores for one student. I started the class for you. It'll save the scores in an array of doubles, which will be partially filled. We'll allow the teacher to enter whatever number of scores they feel like. Let's not worry about re-sizing for right now, we'll just make the array very big to start with. Before I ask you to implement the readScores method I want to show you one more thing that's going to help. I want you to look at the toString method that I added to this class. You can use toString to print out all of the scores. It might help if you find that you need to debug a bit. It's also worth spending a moment to look at this carefully. The arrays class has a lot of useful methods for working with arrays. It's structured a little bit like the math class. So to use these methods you call Arrays.toString or Arrays.copyOf. Now, if I call Arrays.toString, and I just gave it the scores, which is a partially filled array, it would print out a whole lot of zeroes at the end. And I'm not really couting those as part of my array right now. So I need to trim down the array first. I'm using Arrays.copyOf, to trim down the array. Arrays.copyOf takes the array that you want to copy and the desired new length. So this method call makes a shorter array that is a copy of the original and then when I pass that to arrays toString it will now return a string representation of only the part of scores that i am interested in Now, it's your turn to add some code to the homework scores class. The read scores method takes in a scanner and that should use this scanner to read and enter the values. Keep reading scores until the user enters a Q. To implement this method, we'll use the same kind of while loop we learned in lesson four. To keep collecting doubles, as long as the user enters doubles. Inside the loop, we'll read that double, using the scanner that was passed in. And then we'll save it. We want to save it in the next open spot in scores, which should be at index current size. So we'll put nextscore in there. Now there's a new element in scores so the size has changed. We'll need to increment current size to reflect that. Lets see it in action. If I run the demo, and enter some scores. It saved the scores in the order that I entered them. Looks like we're ready to add another feature. The next method you'll want to add to the homework scores class is sumScores. How would you implement this method? There are a couple possibilities here. We're working with a partially filled array. So, do we want to use an enhanced for loop or a regular for loop? If we use the enhanced for loop, it'll add up every single item, even the ones in the part of the array that we've said is empty. We know that the current size is four but the enhanced for loop. Just notice how much space there is in the whole array. In this case, the enhanced for loop will work, but only because the array was initialized full of zeros. So, when we take the sum and we add all of these zeros, it won't actually give us the wrong answer. But if I were dealing with an array that might have extra junk left over in the empty space, I would probably want to use a regular for loop. And only go up to the currentsize of four. I'll show you both of those. Either way, I'll need my sum that starts at 0, and I'll return that sum at the end. If I used the enhanced for loop, I just increment the sum by score, each time, and that should work. But if I'm nervous that there might be other junk left over, in the end of my array, then I would declare a loop counter variable. And stop before it gets up to current size, and look at each item one at a time. And here I would have to get item out of scores, because I'm not using an enhanced for loop anymore, and I should actually give my, [LAUGH], loop counter variable an initial value. Now we can see this in action, if I run the demo and enter my scores, I get their total. Now let's look at average score. If all the homework scores are out of the same number, their average homework score might be much more helpful than their total score. Can you implement this method? To return the average score, I want to calculate the total, and divide by the number of scores. I already have a method to calculate the total. I can call some scores, and divide by current size. But I'm not sure that this is what I want to return. We had that issue before, where if current size was zero, we ran into errors. So I'll need to handle that case. If the current size is zero, I want to return zero, otherwise, it's safe to calculate the actual average. We need to actually return the average. Compile. And now, if I enter the scores that I entered before, I'll get the total, and also the average. But what if I wanted to remove the lowest score? We haven't talked about removing items from a partially filled array, yet. Kai will talk about that, now. Now we want to see how to insert an element, here is my partially filled array. And I want to insert an element before this position. So I need to move all of these elements out of the way, so that the green element can go into the slot. Now, you have to be a bit careful with the move out of the way part. If I were to move this element over here, and then this element over here and so on. That will be bad because then this element would override the next one before I had a chance to move that one out of the way. So, in other words, this element would flood the entire tail of the array. The remedy is to do the movement starting at the end of the array. So, I first move this one, then it's predecessor, then it's predecessor. And I keep going until I've moved the one into who's slot that I want to put the new one. The other thing to remember is that insertion increases the size, so I have to make sure to add one to size of my partially filled array. Le'ts look at this in Java code. I increase the size. Here is the loop to make room for the new element. So when I increase my size then I am starting at size minus 1, which is same as the old size. I now go backwards. And each of the moves goes the other direction than the one that you've seen with removal. It goes from a lower index to a higher index. And the last movement is the one that moves pos to pos plus 1, so we want this one to be pos, which means we want I to be plus, plus one and that's where we stop. Finally, when we're all done, we can insert the new value after position pos. As you have seen inserting and removing array elements requires quite a bit of movement. You need to move elements out of the way, in the case of insertion, or move them to close up the gap in the situation of removal. It was also easy with the array list, where you just called add and removed. But the reason that, as explained to you, what actually goes on with arrays, is an array list has a partially filled array inside it, and it's sometimes important to know which operations are cheap, and which ones are expensive. And sorting and removing can be expensive for a long array. Do you remember how we used the add and remove operation awhile ago to rearrange images in the gallery? We removed the last element and added it before the first one. Now that you know how removal and adding works in Java code I'd like you to tell me Tthe cost of this operation. How any elements were visited in the process? With visiting I mean, how many elements were read and how many were modified. So count every read and every write and tell me the total number of visits. There were a total of ten visits. Let's count them. We removed the last element, we had to read the element for that purpose, but there was no gap to be closed up, because that was the last one. Now before we can insert it at the beginning, we have to move these four elements out of the way. Each of those moves involves reading the element and writing it back to the next position. That's two visits per element and there were four elements to be moved. And finally the removed element has to be written back to the location zero. That's one more visit for a total of ten visits. The point that I want to make is that insertion into an array list. Doesn't work by magic. Under the hood, the other elements do get moved out of the way. Now you've seen quite a few algorithms for arrays and array lists, and many times you can solve your problems by just using one of those existing algorithms. But there are also situations where you need to understand the algorithm so that you can adapt them to new situations. Sarah's going to give you an example where you have to do just that. You can combine basic array algorithms to perform more complicated tasks. For example, we can calculate the final score, which is the sum of all the scores except the lowest one. This is related to several of the algorithms that you've just seen. Let's write a method to drop the lowest score, and I'll give you some methods that you can use. One removes the score at a particular index. One finds what the minimum score is and one finds the index of a given score. Skip to the quiz and code up remove lowest if you're pretty sure you've got this. I'm going to do a demo on a small data set in case you want a little more info first. Let's say our set of scores was eight, seven, eight point five, nine point five, seven, four and ten. We'd also have some zeros left over at the end of the arrays since it's paritially filled, but current size will tell us not to go past there, I'd first find the lowest score, it might be 8, but 7 is better, it's not 8.5 or 9.5, there is 7 again, okay 4 is better not 10, okay so 4 was the lowest we say, now, I want to find the index of that element. So, I'll go through again this time looking for the number four and remembering the index. And it looks like I found it, the index I want, is five, now, I remove the fifth element, which will move ten down and I'll need to decrease current size. You won't actually have to implement remove. But now you can see why it might be important when you're calculating the sum, to only look at the items that you know are in the array. Because this ten will show up in two places now. And you wouldn't want to add 10 to the sum twice. If you already have methods to remove, and to find a minimum element and to find a location of a given element, how would you code remove lowest? The first thing I want to do is figure out what the lowest score is. The methods I have available are find, low score, and remove. So first I want to find what the low score is. I'll call low score and put the result into a variable of type double. Then I'll find the exact location of that score that I know is the lowest. By using the find method, and then once I know where it is, I can remove it, using remove. Now that we've implemented removeLowest, a user of the homeworkScores class could call removeLowest before calculating the sum or average of the final grade. Implementing remove lowest this way was nice because we already had these methods and we could just use them. And this almost reads like a kind of English now. What's the low score, find the low score, remove the low score. But these first two steps were kind of repetitive. In this example we had to go through every item to find what the lowest one was. And then go through them again to find the index of it. If this were a very long array with millions of items in it, we wouldn't want to have to go through all of the data twice just to get the location. We would want to think a little deeper and try to combine some of these loops. So, what if we had a method, getlowScorePosition, that would replace the two steps of finding the minimum element and also finding it's index. This looks better, but it won't work yet. First, you'll need to implement getLowScorePosition. Implement it so that it only looks through the data once. And remembers the position of the low score, as well as the score itself. To implement getLowScoreIndex, we'll follow the algorithim we talked about earlier, for finding the first portrait in the picture gallery. But this time, we're using it on a partially filled array, instead of an ArrayList. So we have to be more careful. We'll start by assuming that the lowest score, is the first one. Then we'll look at all of the items, starting at one, because we already looked at zero. Now for each of those elemlents, we'll compare it to the lowest score, and if it's smaller, we changed what we think the lowest score is. Now, while we're looking for the lowest score, we also need to look for its index. So, initially we assumed that the lowest score index was zero, and when we find a lower score, we'll update the lowest score index to be the index of that score. Now, when we finish looking at everything, the lowest score index that we found so far will be the overall lowest score index. Now that I have this method, the simpler version of removing the minimum score will work. I'll test it so I can be sure. And it looks like it correctly dropped one of the fives. So we just saved our computer program one pass over the entire array. Could we do this even faster? Could we do it without looking at every single item in the array? Take a moment to think. Imagine that there's one score that you don't read. What if that score was the min? If you don't read it, you can't find out whether it's the minimum or not. We can't find the minimum without looking at every score. In computer science we would say that we have to do a linear search. Now what if we knew something more about the elements in this array. For example what if I knew that all of the elements were sorted from lowest to highest. Then you wouldn't have to search the whole array to find the minimum. You would know that it was in the first position. As you continue programming, you'll learn how to organize your data so you can get the information you need as quickly as possible. But right now, let's talk more about discovering algorithms. Back to you, Kai. Here's half of my array. I'll just pick up parts for the second half so I can tell them apart. Here's the other half of my array. Now what could I do? It looks like it would be helpful if I could swap these two elements, cause that way I would get this element in place, and also this one. Let's do it again, that's good. Now these two elements are in place. And so are these. Another swap, and another, and another, and presto! I'm done. I have what used to be the second half now in the first half, what used to be in the first half now in the second half, in exactly the right order. Well that's great, now I can start writing pseudocode. So which elements did I swap? The one in positions zero and five. 1 and 6, 2 and 7, 3 and 8, 4 and 9. So each time I swapped position i with position i plus 5. What's five? That's the length of each sub-array, or one half the length of the original array. So i started at zero. We'll figure out in a minute how far it went, and then I'll swap the element at position i with, well I can't say i plus 5 in the pseudo-code, because the pseudo-code needs to explain the general situation. So, it was length over 2, now, how far does i go? In this case, it went from zero to four. So in general, it'll go to length over 2 minus 1. Now that was the hard part, the easy part is to program that in Java, and I'll leave that to you. This is how the problem was set up for you. We have an array of elements, and your job was to swap the first and the second half. I then move the j'th position to the i'th position and then take the saved value in here. If [UNKNOWN] has reminded you how to swap two elements in an array, we've actually seen the same thing with array lists before. Let's go through this really quickly so that you understand this. So we want to swap these two positions. And in the second line, it moves the j element into the i element thereby overwriting what was in here. But fortunately in the first line we had moved that into the variable saved. And then in the third line, we move it into j. Now we're ready to apply the pseudo code that you've seen at the end of the previous unit. That pseudo code asked us to let i go from zero to the length over 2 minus 1. That minus one is always a little inelegant, I prefer to use the less than sign here. Inside the loop, we were supposed to swap the position i and i plus length over 2. Let's copy and paste the swap code. Here it is, but now j, of course, is supposed to be this. Now I fixed up the code. And I'm ready to run. Here you see the result, the array before and after swapping. And you can see these numbers are now where they're supposed to be, as well as for the other half. I want to briefly talk about the code that produced this printout here. When you look over here, we call system.out.println and we can't directly print elements. As I said, arrays are more primitive then array lists, and an array will not print out its value. This method here takes an array and turns it into a string that lists all of the values inside. Though when you want to print out an array list, you can directly pass it out to System.out.printIn. When you have an array, you have to use this helper method. Of course you could also use a direct loop, but the helper method is more convenient. Now remember what the point of all of this was, the point was not how to implement the swapping algorithm in Javam the exciting thing was how we discovered it in the first place, we discovered it by playing around with stuff and not by worrying about exactly how the index values were or whether we needed a For loop or a While loop and I hope that's the lesson that stays with you, if you need to do something that's off the beaten track, that's different from what you've seen before. Get out some Lego bricks, some coins, some candies, whatever, and figure out what the operation would be with those. And that'll give you the intuition that you need in order to be a successful programmer. Programming is all about having the right ideas and the right intuition, not about pushing the symbols of the programming language around. You've seen how arrays can store a sequence of values such as this one. Here we have three prices for three different kinds of gasoline. Well, what if we have two gas stations in this case you'll want to store a two dimensional arrangement with rows and columns, two dimensional arrays can do that. In this example we would have three rows and two columns. In Java we get such a arrangement by saying, give me a new array of doubles, of floating point numbers and I want three rows, two columns. In general, the first number is the number of rows, the second one the number of columns. Note the type, it's a double brackets brackets meaning, it's a two dimensional array, of numbers. If you already know which numbers should go into the two dimensional array, then you can supply them like this. Again, here I have a two dimensional array, of prices. And now, you put a, pair of braces, for the entire array, and then for each row you put another pair of braces with the values. So here we have three rows, each of which is enclosed in a pair of braces. Now you know how to declare a two-dimensional array. Next let's have a look at how we can access its elements. You've just learned how to set up a two-dimensional array, and now let's say we want to know the price of regular gasoline of the second gas station. We supply two index values; the first one is the row, the second one the column. So in this case we're in row zero and in column one. Now you know how to access a particular element. You simply look up the row and the column number and plug them in here. What if you want to look at all elements? For example, to make a print out of every price in the 2D array. Let's look at that next. To visit all elements in a Two-D array, you want to loop over the rows and columns. Let's first loop over the rows. So we have a row index i that assumes to values zero, one, and two in this example. Similarly, we'll have a column index j, then in this example, we'll go from zero to one. If we had more columns, of course it would go further. When you have a row of column index, then we can access the element at the i-th row, and the j-th column. So what you see over here. As the general expression for an element at an arbitrary row and arbitrary column. In this case, we just print it and we use printf. So that the print out lines up nicely. So we would now print this element and print that element, that would finish the innerloop. Then the outer loop would pick the next row, we print these two, and then the outer loop picks the last row. And we print those two. Now, of course, we want the numbers to line up nicely, so after printing each row, we want to print a new line. Notice that this statement is contained in the outer loop, because it happens once per row. But its not in the inner loop because we don't want a new line after every of the element. Now, lets look at the missing balance here. Of course, in this simple example I could just say I should be less than three, J should be less than two, but in general, someone might just hand you a two-dimensional array and you should ask it how big it is. Just like with a one-dimensional array, you just use the length field to find out how big an array is. You can get the number of rows from a two-dimensional array by asking it arrayname.length. And the reason for this is that a two-dimensional array is actually an array of one-dimensional arrays. So prices, which looks like this nice tabular arrangement, really is an array of three arrays, one for each row. And so the number of rows is given by that length. Now, we need to look at how many columns we have. Here you have a row. And the length of that row is the number of columns. So in general, you should remember that, for any two-dimensional array, you get the number of rows with this expression, the number of columns with that expression. Now, let's move on to doing something more interesting with two-dimensional arrays and gas prices. When you have a picture, you can think of it as a giant two-dimensional array of colors. It's a little tedious to work with the colors because they have red, blue, and green components. Here, we'll just use grayscale. Each element in the two-dimensional array will represent a gray level. As an integer between zero and 255. Now, here's the problem that we want to solve, we have a photo, which is represented as a two-dimensional array, of lots of grey level. And now we want to make it a little blockier. When I have groups of four neighbors like this, I want to compute the average color or rather the average gray level of these four pixels and color them all in that color. And this is, I'm making every pixel a bit fatter. Let me blow this up a little. So here are the pixel, and I want to know, what are it's three neighbors to the right, to the bottom, and diagonally. So let's assume the one that I'm starting with is pixels ij, that means my row is i, and my column is j. Let's look at the one to the right. The row number is the same, and the column number has increased by one. So here it is in Java. Same row, column increased by one. What about the one to the south? In this case, the column index j is the same. And the row index has increased by one. So here's the java code for that. Finally, the diagonal one has both the row and column index increase by one. And I'll leave it to you in the next lab exercise to figure that out. So go ahead and. Program this exercise. You need to traverse the first pixel here then you jump by two each time and also the columns you go down by two columns each time. In each step you average these four pixels, compute the average value and stick it back into all four pixels. Don't worry the friendly [INAUDIBLE] have given you some code to start with. Let me show you how I did this. We have the loop for the rows, and the loop for the columns. Notice that the rows jump in steps of two. We'll do the same thing for the columns. Now I need to compute the average of these four pixels. Let me draw my little picture again. So here's position I J. And I want to compute the average of this one. This one. This one, and this one. I already have the one in I J. This one here has row I, column J plus 1. The one over here has row I plus 1 and column J. And finally the one over here has row I plus 1, column J plus 1. I add those four, divide by 4, and that's my average. And I need to stick it back into. Each of those four pixels. I already have the coordinates, so I can just copy them. I'm almost done, but I still have to put in the bounds here. When we talked about the gas prices, we were told, what the general rule is, so let's just do that. The length of a two dimensional array, is the number of rows, and the length of a row is the number of columns. Let's see what it looks like when we run it. Here was the original picture. Here are the process gray levels. Now, you won't be able to see this on the video, but if you run this at home, if you carefully look at this arc for example, you will see that it is more pixelated. Now, the point of all this was, to work with neighbors. To figure out if you have a pixel position, what other neighboring positions. That many, many image manipulation algorithms where you have to do just that. For example, to blur a photo, to sharpen it or to process it in other ways. Now you will work with Sarah with an entirely different problem. She will show you how to use two dimensional arrays for a grade book with a kind instructor who wants to know which students are doing very well and also which exams are too hard. The homework scores class may be useful for storing a single student's grades. And you can get useful information out of a single student's scores. But when my friend Sarel was teaching math, that wasn't enough information for her. She wanted information about her teaching skills, as well as detailed summaries for the students. She wanted to know how well she had taught fractions. And how well she taught equivalent fractions. And for that, she would need to compare the data for all of the students for one topic. This is starting to look like a 2-D array. With this structure it would be possible to calculate the total for a student. And also to calculate the total for a topic, which would allow her to compute sums for each topic. And then compare them, to see which topics she needed to spend more time on. Once that was done, she could write very detailed, customized teacher comments for each student, by looking at what they got in each topic, and choosing different sentences based on that grade. We're going to implement this together. I'm going to make a class. The GradeBook class, which will contain a 2-D array, of all of the scores. It'll also contain, the names of the students, and the names of the topics. Since you probably don't want to enter these scores over and over again, I wrote a method that will read the GradeBook scores, from the files, and put them into the array for you. So, let's assume that the array of grades is completely filled. No partially filled arrays on this question. Can you write a method which returns the sum of the scores for the ith student? If you're ready to try this for yourself, just skip to the quiz. If you want to see a smaller example first, keep watching. What if my grade book looked like this, and I wanted to calculate the total for Sandra. Sandra is at index i equals one. If this whole array was called grades, then I would want to add up this cell, which would be grades [1] [0], because this is the first student. And the zeroth topic would be this spot, because it's student one and topic one. And grades [1] [2] would be this one, Student One, Topic Two. To get the sum for this student we would want to add all of these up. Now, it's your turn. Try coding this in BlueJ. But bare in mind, you might not know the size of the array up front. There might be a variable for the number of topics and the number of students. Let's code this in Java. I can see here that I have the number of students and the number of topics and the two-dimensional array of grades. I can ignore the student names and the topics for now. What I'm really interested in is implementing the total for student method. To do this, the important thing to recognize is that I want to access all of the grades in one row. The grades in one row all share their first index, but their second index varies because that tells which column. So I'll loop over all of the columns starting at the first one and since there's a column for each topic, I'll keep going as long as my column is less than the number of topics. I'll need a variable to hold the sum. And for each item, I'll add the grade in the studentIndex row in the column column. And when I'm done, I'll return the sum. Just to be safe, if somebody gives me a bad studentIndex. I want to return minus one. So if studentIndex is less than zero or greater than or equal to the number of students, I return minus one. This is always a good idea when somebody else is calling your method. You want to think about the things that they could do wrong, and agree on a good way to handle those cases. Returning the total score for one student wasn't too bad. I bet we could return an array with the totals for all of the students. So going back to this example, here we would want to return an array with three elements, one for each student. The first one would be five plus six plus seven. The second would be six plus eight plus seven, and the third would be four plus six plus five. In BlueJ, implement the method totalsForAllStudents. I'm going to show you two ways to do this. We know that for each student, we want to write that student's total into an array and return it. We also know exactly how big we want the array to be because we want one for each student. So I want numStudents items in my array. Now, for all of the student from the 0 student to the last student Going up one at a time. I want to fill that student's spot in the array of totals with that student's total. I already have a method that calculates this. So, I can use totalForStudent. And then, when I've done that for all of the students, I can return the totals. Looks like I forgot to call it totals. Let's check that it works. I'll run the tester, and it looks like it's got what I expecting. Now, we could use nested for loops. I'll still want all of my totals, and I'll still want to return them, but let's think about solving this problem for just one student, for each topic, starting with the first one. And we going up to the number of topics, one at a time. I'll add the score for that topic to that student's total, let's say for now I'm thinking about student 1. To calculate total for student 1, I'll start at 0 and for each topic And want to add that student's grade, in that topic. Then, once I have the student total in my larger array totals, I'll set the total for that student to be the student total that I just calculated. So this is what I do for one student. And now, I want to do that for every single student. So that all of the spaces in total gets filled, so I will indent that a little bit and now for each student starting with the zeroth one so we don't need this line anymore I will go up to the number of students one at a time. I will do all of these steps. So now the inter-loop is calculating the student totals and the outer loop is storing the student totals in totals. So now we're fix up syntax errors. And this way should work just like the last one. I'll run it to make sure and it looks like it's still good. Hopefully the number of values you see here. Makes it obvious why it would be be nice as a teacher, have a computer do this for you. We talked about calculating totals for a student, but there was another important use for this 2D array. We wanted to be able to tell if there was a particular topic that my friend needed to spend more time on. Let's write a method that calculates the sum for each column. So it would return an array whose size matches the number of topics. And those values should be the some of all of the students scores for that topic. So in this case, the array would look like this. If you're ready to go this method, skip ahead. If not, I'll do a short example first. Let's say I want to calculate the total for multiplying fractions. I would want to add this this spot, and this spot, and this spot. This one is the zeroth student, and the second topic. This one is the first student, and the second topic. This one, is the second student, and the second topic. To code this in BlueJ, I'll first imagine just calculating a total for one topic. Let's say it's topic two. Now for each student, I want to look at the grade for that student for the current topic. And add it onto the sum so far. This'll be the sum for this one topic. I'll initialize sum for topic with zero and then once I've calculated it I want to store it in the correct spot for it's topic. I'll need to make this array for all of the totals, it contains doubles. And it should have one for each topic, and then at the end, I'll return all of the totals. But now I need to do this part for all of the topics. So, starting from initializing the sum, to saving it, I want to indent everything, and then add a for loop that goes through all of the topics so now that I am controlling the topic that I am looking at with a for loop we can get rid of that and now I am ready to try it, since there are less topics than students it's easier to tell this time that it is right, but there are a lot of other ways that we could do this, for example I could create my array with one spot for each topic and I then I could go through each student one student at a time, and add their total. And add their grade to the correct total for the correct topics. And then, for the last line, plus 4 plus 6 plus 5. That might work, too. I think that's a little more confusing to read. But there could be advantages to that way as well. I think the way that I showed was the simplest. But trying a few different ways is good practice. You could find the one that you like best. What do you like about it? When I first started talking about the grade book I told you how my friend generated comments for each student. If you're feeling ready for a challenge, try writing a method which returns a report card comment. Use your creativity here. There are tons of possible right answers, so feel free to experiment. I won't try to grade you on this one. If you don't feel like doing this, you'll have many more chances to experiment as you continue programming. Thanks for working on that problem, I hope you enjoyed having a little space to experiment. That's really what I love most about coding. That moment when you realize you understand enough that you can start to design your own challenges. And just try it out. In the next lesson, we'll start talking about how to structure your code from scratch. And create packages. So you can share your code more easily. I think it will go a long way towards freeing you from the Udacity IDE. So you can start coding projects that you invent yourself, and not just the ones that we set up for you. See you after the problem sets. Hello, and welcome to this new lesson. In this lesson, you will learn more about how to become a pro at writing classes. We will start out with how you can discover which classes you should be implementing. Have a look at this description of a task that should be programmed. In a social network, people can send messaged to their friends and they can see pictures that their friends like. How do we know what classes might make sense of this situation? There is a very simple rule. Look for nouns in the problem description. Many of them can be good candidates for classes. So we might want to make a class person or message. What about friend? Well, a friend is just a kind of person so we might not be using that one. So, it's not that every noun turns into a class, but the nouns give a good idea where to start. What about methods? Well, methods are verbs. For example, here, sending would correspond to a method. And in object-oriented programming, there's this core belief that a method belongs to a class. There is a single class that is responsible for sending, and so we would want to make a choice. Is it the person class that has a send method, or is it the message class that has a send method? Or maybe there's another class that we haven't yet discovered, maybe a mailbox class. We're not going to get into the details about this application. Here I just wanted to point out the noun-verb rules. Nouns are good candidates for classes, verbs are good candidates for methods. And I wanted to remind you, that each method is the responsibility of a single class. In this lesson will be implementing a fairly complex program, and we'll start out by just covering the classes that we need. The program that we want to develop deals with car sharing. So, we know car sharing is great, means less waste, less environmental damage, people travel together when they can. So, we want to write an application that simulates car sharing so that we can learn how to make it better. Here is a problem description. So, cars can pick up people whose destination is along the way of their own. The simulation should read information about cars and passengers and print out who has been driven where. What I'd like you to do is to read through this description and tell me what might make some good classes to implement in a program that does this car-sharing simulation. Let me give you a few choices. Which of these do you think would work out? Check all that apply. Well, I'd certainly check car and person. Those are nouns, they're current in the problem description. drive is a verb, so that probably wouldn't work out. And now car sharing, yes it is a noun, but how would a car sharing class help us? What would an object of class carsharing look like? So, that's not so clear. So, this is just a technique to give us some candidates for classes, so that one can get started designing a solution. It's not perfect but it's pretty useful. Now, I want to shift focus a bit and talk about the challenges of implementing a single class. Many lessons ago, we've talked about how to develop the public interface of the class, the methods that one might want to call on objects of the class. But we've always pretty much given to you the instance variables, because it turns out that picking the right instance variables isn't all that simple. While now, the time has come for you to do more of that yourself. And I'd like to give you a few rules of thumb, on how you might discover instance variables. To see how those rules of thumb work, let's have another look at the Car class from Lesson three. That class had an instance variable to hold the amount of gas in the tank. That was a method to add gas where the parameter value would be added to the gasInTank. Now the point that I want to make is that there is a certain pattern here. You have a quantity here. Here you make that quantity bigger. It also gets smaller when the car is driven. I like to call that pattern keeping a total. And it occurs in many classes, not just the car. So then lots of times we have some class and you have some variable, which may be called total or not. And then there's some methods that add to the total. Maybe some methods that clear the total, or subtract from it. I'll give you a few situations, and I'll ask you whether the pattern of keeping a total applies. So, would you keep a total to model the account balance in a bank account? Friends in a social network? A car odometer? Stripes in a flag. Check all where you think the pattern makes sense. With a bank account balance, the total makes perfect sense. The balance can be added to when you deposit money, and it gets smaller when you withdraw money. It's just a number that gets incremented and decremented in times. With friends in a social network, I probably wouldn't be using this pattern. Because in a social network, you don't just con, collect the number of friends that someone has, you want to collect the actual friends. And that would not be a variable that gets incremented or decremented. A car odometer? That again makes sense. As miles accumulate, this not total just gets bigger. Notice that this one here doesn't get smaller. that's fine. And finally, what were flag stripes. I don't know, it's, a flag has a constant number of stripes, they don't change. So, even though you may want to count the stripes, it's not the total pattern where you have a quantity that has some method that adds to it. And maybe some method that subtracts from it. The point is that, once you've seen a couple of classes that keep a total of gas consumed, of miles driven, of money in the bank, whatever. Then you start recognizing that particular pattern, and it becomes easy for you to put in a method that adds something to the total that takes something away. So, let's look at a few other patterns that you haven't seen so much, but they are very useful in practice. When you write code as part of a team, picking good class and method names makes it possible to work together. When I pick good names for my classes, it makes it easier for other engineers I'm working with, to read my code, and know what it does. It also makes it easier for me to remember what I did. So, this process is important, but how do you get good at it? The answer is practice. Lots of practice. Keep writing code, and when you read code, ask yourself, what patterns does this code follow to make it easier to read. Or, what patterns could this code have followed to make it easier to read. These questions will be very hard to answer, at first. But as you critique more examples, it'll become more natural. We'll talk about a few more patterns in this lesson. But for now, let's do another example of designing class and method names. Let's say you've banded together with a group of friends to create a freelance photography company. You've taken on the role of manager and your friends are the photographers. Customers describe photography assignments to you. And you label the assignments with priorities. Each day you have a team meeting, where you give out the highest priority assignments to your friends. Each photographer can do one assignment per day. And every so often, you like to review all of the pictures in the company portfolio. What are some of the methods that might be carried out by objects of those classes? This is a very open ended question. What you come up with will depend on how you imagine this situation. There are a lot of correct answers here. I haven't specified every single step of the program. So everything's open to interpretation. What nouns do you want to make classes out of? And what are the methods that might go with those nouns? I won't give an automatic grade but will be collecting the answers and analyzing them. These are the classes that I came up with. There's a manager and photographers, assignments and a portfolio or maybe multiple portfolios. The manager is responsible for labelling or prioritizing and photographers are completing assignments. So I think the manager has a method something like prioritizing the assign that takes in a new assignment and figures out what to do with it, and photographers have probably a method complete assignment. Thinking about the methods that an assignment has, might be a little harder. Mostly, an assignment should have a priority and a description. So it will probably be possible to set the priority of an assignment. We'll also probably need to be able to get the priorities, or compare them, so that the manager can figure out which ones are the highest priority assignments. Maybe when an assignment is finished, something happens with it. The portfolio probably needs to be able to collect the finished assignments, and there should be a way to look at the finish assignments as well. There are they things that you could have written here, it's possible that customer would also be a good class or may be priority. This would depend on how complicated you wanted to make your priorities Let's talk about the thought process in more detail. The first question I asked myself was, which nouns in this problem description are doing things? Well, the manager is getting assignments, and marking them with priorities, and assigning them to photographers. Photographers are getting the assignments from the manager, and completing them. Assignments don't seem to do too much, but we need to keep some information associated with the assignments. In particular, I thought an assignment would have a priority, and maybe, whether it's finished or not. They would also have the original description. Perhaps I would even want to store the finished work in the assignment. So maybe the finished method would take in an assignment. You might also want customer objects. Maybe the customers are doing something interesting when they create the assignments or maybe the manager keeps a list of customers and assigns the priorities based on who the customer is. Maybe you would want an object to represent a priority. If you imagine the priorities as just numbers and higher numbers mean higher priorities then you probably wouldn't need a special priority class. But if you wanted priorities to age over time, and increase the longer you have the assignment, then you might want to class your priorities, because they would have behavior. This kind of design work can be very difficult, because there's so many ways you might start. But it also becomes a lot of fun as you get better at it. This process becomes a kind of story telling. You're using the code to document the relationships between all of the actors in the story. And creating a model for how to solve the problem. We'll start with a pattern of a counter. That pattern teaches us to make an integer variable that counts whatever it is that we want to count. You want to have another method that increments the counter when whatever interesting event happens that you're counting. And you'll usually want a method that returns the current counter value so that the user of the class can get at it. Okay, that's all really abstract, so let's look at a concrete example. Here, I have the beginning of a Car class. A car has a given number of seats. That of course is not my integer counter, because that number doesn't change. And then I have a method here called addPassenger. Whenever that method gets called, another passenger enters the car. And then I have a method for counting the number of passengers in this car, not counting the driver. What I'd like you to do is, use this pattern and add an instance variable for the counter, which you can call anything that you think is appropriate. And to implement the methods that increment the counter and that returns current value. Our task is to add an instance variable that counts the number of passengers. Here it is. Here I want to add a passenger to this car, so we will increment our counter. But, of course, there's a twist. You can only add a passenger if there's room. So, we need to check if the number of passengers plus the one that I want to add is less than the number of seats. Why not less equal than the number of seats? I still need one seat for the driver. So only in that case do I increment. So when I talk about patterns in general, the pattern that I described here says increment the counter, but it doesn't mean that you'll always have to increment the counter. The patterns gives you the broad outline of what you have to do, and the details are different, in every situation. After all if it was that simple, then you wouldn't be making the big bucks figuring out the answers. Finally, the getPassengerCount really is as simple as you think, here we just return the numberOfPassengers. The point is again, knowing that many classes keep a counter can help you when you have a situation where that is appropriate. Here, at the counter, you figure how does the count change, that's the case here. Here we increment the counter, and then here we have a simple and boring method to return. In this example, we just counted the number of passengers. What if we wanted to know who's actually in the car? We'll turn to that next. Many classes needed to collect objects of another class. Use an array list or maybe an array for the collecting. Supply a method for adding to the collection so that it can get bigger over time. And depending on your problem, maybe you want to have a method from removing items from the collection. You'll want to supply some methods to find out about the contents. Maybe something that prints the contents, maybe to test whether a given value is in the collection. That depends on the individual situation. And here's a bonus tip when you declare that array list or array, don't forget to initialize it in the constructor. because otherwise it will be null, and when you add the first element, you'll get a null pointer exception. Sadly that happens to me a lot. So let's practice that with another variation of the car class. In this case we want to collect the names of the passengers. And I've already declared an array list of strings for you. So that's the instance variable. And your task is to update that instance variable in a couple of methods. Here we're practicing the pattern for collecting values in a class. Here's is already the instance variable that does the collecting. Before we forget, let's make sure it's initialize in the constructor, here we go. By the way, I did forget that when I prepared the solution. Let's see here, here we need to add a strain to the collection, here's the code for that. Now sometimes, the code really is as simple as this. It's still necessary to have a separate method because of course passengers is a private instance variable that the public can't use. In our example, the add passenger method is a bit more complex because we should only add when there's space. Last time around we had a counter for the number of passengers. We don't have that this time, but we have a method, down here. So I'll just call that method. And again if there's room, then I'll do the adding. I don't expect that we actually have to implement that method, that's simply the size of the collection. The last method here, gives us more information about the contents of our collection. Unfortunately it's already been implemented. It simply returns the array list converted to a string, which, has this characteristic form. All of the strings inside, surrounded by brackets. So that's the general collection pattern, any time that an object wants to collect other objects. Using the array list or an array such as this one, and did I mentioned, that you should never forget initialize the array list or array in the construction. You will get to practice these patterns with another example that's dear to Sarah's heart. Lets practise applying patterns. Remember the HomeworkScores class from before, here's a slightly modified version of it. We had it collect all of the scores, so that we could do competitions with them later. But if all that we want is to add all of the scores in and calculate the total without the lowest one, we don't need to collect of the scores. So, here's the outline of what we want to build. A HomeworkScores class with an addScore method and a getTotal excluding lowest method. The only method that should be a mutator is the addScore method. In earlier lessons, we had a method for removing the minimum score. But in this version we wont remove any. We will just find a way to no to count them when we are calculating the total. There are few corner cases I'd like you to think about, they have special behavior. If there are no scores yet, say that the total is 0. If there is one score, say the total is that score. If there are more, say the total is the total excluding the lowest. Now remember, I'd like you to do this without collecting all of the scores in an array list, or an array. Try this yourself. And if you'd like a hint, there will be hint links over here. They'll show you more videos. To answer this question, I'll start with some of the code that I was using in the hint videos. Here's the homework scores class. And so far, it's keeping track of a sum and a number of scores. This code returns a sum but doesn't actually think about excluding the lowest. The way I see this problem, there are two key insights. The first is that to return the total excluding the lowest. We don't necessarily need to permanently remove the low score. If we can find the low score, we can return the total minus the low score, just subtract it off at the last moment. The second insight is that we don't need to save all of the scores to know what the lowest score is. We only need to save the value of the lowest scores itself, so instead of a method that finds the lowest score I will create an instances variable to track the lowest score so far, I will define it as private double lowest which probably make these private to, now I am going to need some special cases in my getTotalExcludingLowest because if the number of scores is zero, I want to return zero, but if the number of scores is one, I want to return that one score which is currently the sum. And if there are more then I want to return the sum without the lowest score. To keep track of how many scores there are, I'm using the counting pattern. I start with the number of scores being zero and when I add a score, I increment the number of scores by one. Now, for this new variable, lowest score. Or lowest, as I'm calling it. I need to come up with an initial value. Ideally I would initialize it with the first score. But I don't know what that is yet in the constructor. So I'll initialize it with minus one, and promise never to look at it until I've added at least one score. This is a good example of why you want to keep your instance variables private. People using the homework scores class might not realize that lowest isn't always initialized. Only the homework scores class knows about this implementation detail. And when you mark this as private, it shows that the homework scores objects are responsible for interpreting the data inside of the lowest score variable. So outsiders don't need to remember things like, I shouldn't look at the lowest score until I've added scores. So now I've initialized the lowest score, but I need to think about how it's changing. I'll need to make sure that in add score, when there aren't any scores yet, I should initialize lowest to be the given score. Then I need to think about, what happens when I add additional scores. The lowest score seen so far can change whenever I add a score. This is a lot like looking for the minimum score in a loop. When I see a new score, if the score is less than the lowest so far, I update the lowest to be score, now it looks like under both of these conditions numScores is zero or the score is less than the lowest, I change the lowest to be the score, so let's make this into one if statement, if num score is zero or score is less than lowest, then lowest equal score making get rid of this repetition and then these two statements happen no matter what whenever I see a new score I count that I've seen another score and I add the score to the sum. So now if I compile and fix my syntax errors, I can run the homework scores tester. And the homework scores class behaves as it should. And I'd like to talk about another pattern that's very common when designing classes. We'll say that the class has a property if it has a value that one can simply get and set. Look at a person, a person has a name. That's a private instance variable, so we'll have a getter that returns the name and here we have a setter that you can use to set the name to a new name incase the person for whatever reason is unhappy with the previous one. It's very very common to have this pattern instance variable getter setter there some variations sometimes you do some error checking in the setter here we check that the new name, is not the empty string, cause no one's name should be the empty string. Or, maybe, in a particular application it just shouldn't be allowed to change the name, in that case, there wouldn't be a setter. This is a read only property in this example where we just have, the instance variable and the corresponding getter. Now, properties, meaning private instance variables with getters and maybe setters are very common. But that doesn't mean that you should make every instance variable a property with a getter and setter. Only use the getters when there is a need for the user of the class. To read the instance variable and only supply a setter when there is a need for the user to modify it, many instance variables do not have getters and setters. Well let's practice that with yet another variation of the car class, this car class has a number of instance variables and I'd like you to look it over and add getters and setters for those where it's appropriate, and not add them for those where it's not. This class has three instance variables. The number of seats, the driver name, and the list of passengers. For which are these should we have getters and setters. The number of seats certainly shouldn't have a setter. You can't really change the number of seats in a car. Should it have a getter? if you added one, it's not a mistake. but there's probably no grade reason for having it. I didn't add one. Now, the driver name definitely needs a setter, because, when you look through the methods, there is no way of setting it otherwise. So, let's add a setter. Here is my setter. Do I need a getter? I think I do. There's no other way of finding out who's driving this car. None of the other methods make any use of the driver name. I'm assuming it was important since someone added the instance variable. So, let's add the getter as well. Here is my getter. And as is so often, the setter and the getter have very simple implementation. What about the third instance variable? You definitely don't want to have getters and setters for this variable. It would be very odd to have a method that holds and places an internal array of the class. And you also wouldn't really want to return it, because then you would give the user of the class the possibility of changing its content. So there is a rule of thumb that says that in general, a class that does not want to return any internal parts of its implementation that a third party could modify. Now, you've seen a bunch of useful patterns that hopefully will help you designing the implementation of a class. I will put those to good use when we implement our car share application. But before we do that, there is another technical topic that we need to tackle. Namely, variables and methods that don't belong to objects, but to the class as a whole. And the beginning of this lesson, we talked about classes and methods, and about the fact that a method should always belong to a particular class, who's objects are responsible for carrying it out. Sometimes that's not as easy as it sounds. Let's go back to a program that you saw in lesson five. In the elevator demo, we write in a number, and then we first checked whether it was a valid integer, whether it was within range, and only then were we able to do any work with it. It would be nice if we could put all of this code in a separate method. And then I would like to call that method, in somewhat this fashion, so I want to read a number between 1 and 18, I want to read it from this scanner and I want to have the prompt to be floor. And of course the reason I want that is, then I can reuse the readBetween method again, when I want to read some other value that's maybe between one and 100 and maybe it's the temperature. So like so many of us, the readBetween method is probably wondering, where do I belong? Well in which class do you think the readBetween method should be put? The system class? The scanner class? The ElevatorDemo, or maybe somewhere else. Just think about it and give me your best guess. So we're going to find a home where we can add the readBetween method. Now, it can't be the System or the Scanner class, because you and I can't add methods to these classes. They're classes that belong to the standard Java library, and we can't add just add our own methods to them. What about ElevatorDemo? So, let's try this. I would put all of this functionality in a method, give me a minute to arrange that and then I'll show you. As promised, here is my method. This method keeps reading an integer until it finds one that is within the desired range and then it returns it. The exact code isn't really important right now. You can have a look at it in the code distribution, if you want to. And, out here, I'm calling it. But, there's a problem. When I compile it, I get an error message. And, that error message, right now, must truly appear like gibberish to you. It talks about non-static methods and static methods. So let me explain what's happening and why the compiler is unhappy. Normally, we call a method on an object and I didn't do that here because I figured, well I'm in elevator demo. So I should be able to call any elevator demo method as well. But the trouble is I'm calling from main. So there are no elevator demo objects and the compiler complains. So going back here, that is the crux of the problem. ReadBetween is not called on an object And there really isn't a great object to call it on. it would have been nice to call it on the scanner, but like I already said, we can't do that. Whenever you're in this kind of situation where you have a method that can't really be called in an object, then you make a static method. The static method is a method that's not called in any object. So, one remedy is, simply, to go back into elevator demo. And, declare the helper method static. Like this. Now, all will be well. And the syntax error is gone. So to answer our original question, it is perfectly legitimate to put read between intra ElevatorDemo as a static method but maybe it's not optimal. Because what if I want to use that perfectly nifty method in another class? So really, read between is a method that seems it would be useful in any situation that you want to read a value from some range. So we, we might really want to put this somewhere else, and the dos that I'm going to put it on I'll call IO Helper. I've prepared that class for you, let me show you. Here is the IO Helper class. Here is the read between method. And again, that is a static method because I'm not going to actually make any objects off the IO Helper class. I just want it to be the home for this method. That means when I call the method, I have to specify the name of the class like this. Here you see the name of the class, IOHelper, the name of the method. Static methods are not incredibly common because, like I said,most of the time, an actual object is responsible for carrying out a method, but they do happen. In fact, you've seen a few of them. In lesson four, you saw a good number of static methods in the math class. Again, the syntax is the name of the class, a period, and then the name of the method. And once again there is no object of the math class. We simply call the square root method directly on the class. Now, you may wonder, why did we have to use a static method? Why couldn't we just call the method on the number 2? Well, that's what it's like in Java. In Java, numbers are not objects so you can never call a method on an object. A call such as 2. square root might be more logical, but it's an error. So to summarize the static method. Belongs to a class. It's not called in an object and they're not actually all that common. Why do you call them static methods? There's no good reason actually. That's a holdover from another much more ancient programming language. There's nothing particularly static about them. In addition to static methods, there are static variables. Let's have a look at them next. In lesson four, you wrote a class to compute some ugly fractions and averages. These methods don't need any instance variables. They should have been static methods. We could easily make them static. And then in the tester, instead of creating a math and Java object and then calling that, we could remove this step and call the methods directly on the class. Which would look like this. This would make it more obvious that these methods do computations based only on their parameters. Their behavior won't be influenced by factors like instance variables. So, go ahead and convert these three methods to static methods, so that the tester can work without creating an object. I don't have to change very much. If I run the tester initially, it won't compile. Because right now, andahlSpeedup isn't a static method. And I can't call non-static methods from the static main method. But if I go here and declare this as public static double andahlSpeedup and public static double crossRatio, and public static double average. Now, I can compile and run the tester method. Looks good. A static variable is a variable that belongs to a class but not to any object in that class. They're even less common than static methods. You're most likely to see them for constants. For example the math class defines a static variable called PI. Can see it's a static, can see it's a constant because it's declared as final and it's the value of PI. If you ever need to use it, you would call it as Math.Pi. Here is another example, there is a class that defines a variable called out. And again, it's static. What do you think? Which class does this? I copied this declaration from the source code of one of the Java classes. Tell me which one. The answer is, it's the system class. You've been using system.out a lot in this course, probably much more often than Math.PI. But anyway, it is a variable that doesn't belong to any object of this system class. It just belongs to the system class itself. Now, Sarah is going to show you another static variable that she would add to the person class, that gives another example where static variables can be useful. Often when you're writing code for a class like the person class, you want to give each person a unique ID. That might look something like this, you would have a private int ID, and each person object would have one. Now, there are a few ways to generate a different ID for each person. One would be to create a static variable. LastAssignedId and use the lastAssignedId to set each person's ID when they are created, we would also want to increment the lastAssignedId every time we used it. Try this out yourself. How would you give each person a unique ID starting from 1 and going up one at a time, so the first person would have ID 1, the second person would have ID 2 and so on. If I decided to use a static variable to do this, then in the constructor, I would want to start with last assigned ID as zero. Now whenever a person is created, the constructor is called. We increment the last assigned ID and use the value of last assigned ID as the ID for the person being instantiated. The solution we just saw has some problems, it had wires the ID generation into the person class, so if somebody is writing code and they want to use the person's class in their code, but they want ID's to be generated differently. Maybe they want ID's to start at a 1000 or may be they only want prime ID's they can't change the way the ID's are being assigned so what would be a better way to assign ID's to our persons? We would create a new interface, IdProvider which would have a method next to Id. You can think of an interface sort of like a class for now. We'll talk about these more in lesson nine. But now that we have this when we create a person, we can take in an ID provider, and use it to set the ID. Then we don't need the static variable anymore. This is what objects are all about, if you want different policies, you create different objects. There's no reason to be tied to a static variable in order to count the ID's. In production code you should never use static variables unless you declare them final and capitalize them and use them as constants, static variable seem convenient, but when you write real code they cause bugs because they don't get cleaned up when you are done the way objects do At the beginning of this lesson we talked about car sharing and what classes one might be able to use to implement a car sharing simulation. And we hit upon the classes car and person. Let's go ahead and actually implement those classes. So, we'll imagine a bunch of people that all gather at the departure location. There's a long road, with destinations, that we'll just label 1, 2, 3, and so on. Each of the people wants to go to at one of these destinations. Maybe this one wants to go to three, same with the others. And then, we'll have cars, that also have destinations. Let's say this car wants to go to destination 4, then of course, this car can pick up whatever passengers want to go destination 1, 2, 3, or 4. But not one that wants to go further. And, of course, the car can only load as many passengers as they have seats. Make that one less because the driver also needs a seat. So, now we need to figure out what are the responsibilities of the classes. Let's start with the person class. A person should know their destination. In our stimulation we also want to give names to people so, of course the person should know that too. A car should be able to pick up a passenger provided, of course, and only the car will know that whether there is room and whether the destination is on the way. And, of course, there is another thing that a car should be able to do, it should be able to drive. It looks like the person is the easy of the two, let's look at that first. Here's the Person class. You can see we have two properties, a person has a name and a destination property with a getter for each of them. These are read-only properties. Once a person has been constructed with a particular name and a particular destination, that doesn't change. Remember, it's just a simulation, these are not real people but, just objects for use in our simulation program. Here is the Car class. Most importantly, a car collects passengers. A car also knows how many seats it has. The name of the driver, we'll just use that for reporting. The current location, it starts at zero and goes up by one every time that the car drives to the next location. And that is destination. We construct a car with a driver name, number of seats and the destination. Initially it has no passengers and is at location 0. So, now it's your turn. I'd like you to implement the tryToAdd method. Where we add a person to the car, at least we try because if there's no room or the passenger wants to go further than the car wants to go, then it's not going to work. In that case, you shouldn't add p to the passenger array list, but you should return false. On the other hand if you can't accommodate the person. Go ahead and add it and return true. Here's what I did. I checked how many passengers I already have, now I want to add a new person. And of course, there's the driver. So if passengers size plus 2, one for the new person, one for the driver, is less equal the number of seats, then I'm good. I also have to check the destination. So, and if the destination is below the destination of this car, in that case I can add the passenger and return true. Otherwise I won't add and return false. Now next I'd like you to implement the drive method where the car goes to the next location, one more than the current location. And then when it gets there it should drop off any passengers whose destination in that new location. Now when dropping off, that just means remove them from the list of passengers. So go ahead and implement that. Here is the drive method. We increment the location and now we want to remove all passengers who wanted to get to that location. That turns out to be a bit tricky so I'll want to find the passenger and then remove it. To remove a passenger I need to know the index. So I have an index i starts at zero, up to but not including the passenger size. I kept the i passenger, I test whether the destination of that person equals to current location and then I remove it. That's all fine, but there's something that one needs to be very careful about and that is when you remove the passenger you can't increment the index. Here's what I mean. Here are my passengers and let's say i is 1 and now Jane has reached the destination, she gets removed then of course Mary now ends up in place one and then I need to come back to the loop with i staying at 1 so that I can examine whether Mary should also, leave the car. So that's why there're two branches here. In this branch, I removed the passenger, and in the other branch, I increment i, to get to see the next one. Now the car, and the person class, have most of the functionality that I need, but somewhere I still need to put the entire simulation together. I've designed another class, that I call the Simulation class, that puts all the information together. It keeps a list of all the cars in the simulation and all of the people. I'm giving you a method to read in all of those data, and that's not the part that I'm most interested right now, so we'll glance right past it. Now the simulation has two phases. In the first phase one loads all the passengers into the cars and in the second phase we drive all the cars until they have arrived. So go ahead and implement this method, what you going to have to do is for each passenger you want to find a car that can hold it, that means you need a loop over all the cars until one of them says yes, this passenger can be added Here is how I did that. In the outer loop, I just go through all of the people. This inner loop is one of the algorithms that you've seen in lesson seven. It's the algorithm to find something. I keep on iterating over all the cars until I've been successful. In each step, I look at the ith car, I tried to add my passenger, that method will tell me whether I was successful or not. If I am, this variable gets to be true and I fall out of the loop. Now go ahead and implement the driveCars method. What I want you to do is drive all the cars to location 1, then all to location 2 and so on. Of course if the car has already reached its destination then you shouldn't drive that car again There are many ways of doing this, here is one that I think is fairly simple. Let's look at the inner loop first. So we want to go through all of the cars and drive them. And we want to keep doing that until all of the cars have reached their destination and that's the challenging part. All of the cars started at location zero and then they moved to location one. And now maybe this one here doesn't need to go any further. And I need to, have to have some way of stopping this car from moving. So what I'm simply going to do is I'm going to remove him from the list of cars. So that's the part here. If this car has arrived, then I'll just remove that car. And remember, when I remove an element from the array list, then I don't reccomend the index. But I do it over here. And I keep doing that while I have cars to drive. Now you've written a lot of code and mercifully the application is nearly done. I'll give you the final piece. Here in the CarShareApp class, you make a simulation object, we ask it to read it's input. Then we load the passengers, and drive the cars. Also, so that you see what's going on, I've added a couple of print statements to the car class. Here in the tryToAdd method, we print out whenever the driver has picked up a passenger. And in the drive method, we print out, whenever the driver has dropped off a passenger. Now I would like you to, run the car share app, with these inputs here. So Jane has a car, that can hold four people including herself, wants to go to destination four. Fred has a two seater wants to go to destination two. And these are all passengers, they want to go to these destinations. The minus one signifies the end of input. Go ahead and run the app, and tell me in which order do passengers get dropped off. Here is the answer. And you simply get it by running the app. [SOUND] Here I've pasted in the input, and here you see the drop offs. Well that's great our simulation really works. It was hard work but we're essentially done. There's just one other step that I'd like to do. And that is to reorganize the code in a more professional way. Remember that manager that we were talking about earlier? Maybe it was you, maybe it was somebody else. Well, that manager is still handing out assignments manually. Let's write the program that will assign them automatically. I've got it started for you. I wrote a class simulation. You don't need to look at it too hard. There's a lot of stuff in here that you don't need to know yet. Mostly what it's doing is it's reading in a story. The story is a text file, inside the directory with the code. It's called story.txt. The simulation class reads these lines of the story on a manager object. Let's look again at this story. First, the manager hires photographers. There's a photographer Danny, then a photographer Leslie. Each day, there's a meeting, where the manager gives out assignments. The manager's going to start with the first photographer and give out the highest priority assignment available first. So in this case, that would be the parrot assignment, which has priority 5. In between daily meetings, the manager gets assignments. These assignments need to be added to the to-do list. Since choosing a priority is a complicated task, I just included the priorities for you. The priorities will be Ints, and a higher number means a higher priority assignment, so the assignment should be done sooner. When we come to the end of the story, we'll check the portfolio and display all of the pictures. Your task will be to complete the methods inside the manager class, using whatever other classes you need to create. So that when you run the main method in the stimulation class, it will print out the finished photos from left to right with no space between them and the name of photographer under each picture. So when you run the main method of the finished code, you should see something like this. The first photo is of a parrot and it was done by Danny, the second one is of the mountain done by Leslie and so on. Make sure that their signature has its top left corner, right at the bottom left corner of the photo. Now I've written one other thing for you, the photographer has the complicated job of creating a photo based on a description. If this were real life, a person would be taking the photo and loading it into the system, but we don't have time to wait for that. So I've included some photos, and a method in the photographer class, that gives the name of a file with a photo, when you give it a description. All of the descriptions in the story, so all of these ones already have photos for them. And the photographer knows how to find those photos. Aside from that, you have free reign. You can add whatever classes you need to make this work. Though to submit your answer, you'll need to find a way to use the classes that are in the Udacity IDE. You can't make new files in the Udacity IDE. But if you use BlueJ, you can create whatever classes you want. I'll give you a little tour of how I designed my solution at the end. But there are a lot of ways to do this, and many of them are good for different reasons. One last thing. I understand that this is very open ended. So if you'd like more guidance, check out the hint links that will show up here. And if you can't make it work, it's not your fault. And if you're satisfied with your progress and what you've learned from the question it's okay to move on. I'm going to start by getting the portfolio working because I kind of want to see some pictures already. It looks like I need to finish up the addFinishedWork method, alright. Now, I need to actually create that FinishedPhoto class. So, I'll come back to my overview and make a new class FinishedPhoto. I'll move this down here since it's going to be used by the portfolio. Now, basically I just want the FinishedPhoto to have the location of the file and the name of the photographer. So, I'll create instance variables for them, initialize them in the constructor and make it possible for the portfolio to get the information back out later. Now, I can go back to the portfolio and compile again, and if I were to actually use the correct class names, I now have the collecting of finished works working. To display them, I'll have to fill in the bits that I left out before. I'll make the picture based on what's saved in my finished work object. Translate it to the correct position and draw it. The signature will have the same x coordinate. Whoops, looks like I have a bit of a name collision here. I've called the picture object photo. And I've also called the finishedPhoto, photo. So I'm going to call this one work. And I'll need to be careful to change it in exactly the right places. And now I can actually get the height of the Picture object, so that I'll know where to place the text. And I'll get the actual text for the signature from the work object not the picture object. Let's see how we were doing. I should probably actually call the constructor when I'm making a Text object. And now it's better. So let's see how this is working. I'll go back to the overview and create a class PortfolioDemo. PortfolioDemo will have a main method where I'll create a Portfolio object and then add some finished work to it. Here's one of the images I know is in the package. And I'm actually going to use the original photographer's name here. And I'll add two more. And at the end, I'll want to display the work. Looks like I should capitalize correctly. Try this again. Now, if I run my PortfolioDemo, it prints out the three photos with the names just as I wanted. Looks like I'm ready to start using the portfolio in the Photographer class. The photographer will need to able to accept assignments. When a photographer accepts an assignment, they'll take a photo, which in this simulation will mean finding a file name based on a description for the assignment. Then the photographer will add the finished work and their name into the portfolio. There are a few ways that we could get a hold of the portfolio. One is that we could just have it passed in as a parameter. In this case, I'll just put it in as an instance variable. Either one works. But I'm going to need to take it in as a parameter in the constructor. And I'm also going to need the name of the photographer. Which will also come in as a parameter in the constructor. Now, that should be all set. But my photographer's probably not working all that well yet. I keep using assignments. But assignments haven't been defined yet. So I'll make a new class. This is all getting pretty squished. That's a bit better. Now, the Assignment class isn't going to have a whole lot in it. Basically, the Assignment object is what's going to be stored in the to do list for the manager and then used by the photographer to know what assignment they should do. I know that I'll need a description for the photographer, and I'll eventually need a priority but I'll come back to that. And here's my get a method for the description. Now, the photographer should compile. Once I fix the typos in the assignment and now I can write a PhotographerDemo that shows that the Photographer class works. I'll make a new Photographer And give the Photographer portfolio. I'll fix a little typo, take out the s that I had here in the Photographer class. And then I'll make sure that all of the assignments made it into the portfolio by displaying the finished work. When I run the PhotographerDemo, I'll get three photos with me pretending to have taken them. So that's looking pretty good. Now, I only need to fix the Manager class though the Manager does have some of the most complicated logic. The most interesting part is when we give out the assignments. The Manager will need a list of unfinished assignments. I already defined that earlier in one of the hint videos along with a list of photographers. Now, there's this detail about assigning the photographer who was hired first the highest priority assignment. So, it looks like I'll be iterating over all of the photographers. And I'm going to want to look at the one who was hired first, first. Luckily, this won't be too difficult since I'm storing all the photographers in an array list. They're going to be stored in the list in the order that I hired them. So if I iterate over the list, I'm going to iterate over the photographers, starting with the one that was hired first. Now, for trickier part. I'll want to find the highest priority assignment but you already mostly know how to do this. So I'll quickly make a helper method that does this. Now, there is one hiccup here, I'll need to add the getPriority method to the Assignment class. But that wasn't especially complicated and now I'm back. Looks like I tried to index into an array list using parentheses. Alright, now I'm using the get method and correcting spelling errors. And I should be able to use my getHighestPriorityAssignment method. So, for each photographer, I'll get the highest priority assignment, give it to a photographer and remove it so I don't do it twice. And one more gotcha. I only want to do these things if there's actually another assignment to be done. So, if there are no assignments in the list of assignments, I'll skip all of this. I can add an else return here and the moment I realize there are no more assignments, I would stop looking through the photographers. This isn't necessary but it might skip a lot of steps if our company gets really, really big and we have thousands of photographers. I think I'm done with the giveOutAssignments method. Now, I'll make sure I've implemented all the other methods. I'll need to add a photographer to the list when I hire a photographer and make sure to initialize all of my array lists, as well as a new portfolio. When I get a new assignment, I'll need to add the new assignment to the list of assignments to be done. And at the end when I'm ready to check the portfolio, I'll use the portfolio to display the finished work. Did it work? Looks like it. If you stuck with that problem all the way through and got it, great job. And if you didn't hope that you learned something by seeing me go through the exercise. Now, that I have this working I would probably want to go back and clean up all of the documentation. But I wont make you spend any more time on this example. Ky has some important concepts to show you with car share program. Let me tell you about a useful concept that you can use to organize your classes effectively. It's called the concept of coupling. And we'll say that a class is coupled with another if it uses the other class. In fact, [INAUDIBLE] shows us this relationship, with these arrows that you may have noticed before. In this example, the Car class. Is coupled with a Person class, because the code of the Car class uses personal objects. But the Person class is not coupled with the Car class because the personal object actually knows nothing about cars. Let me show you. When you look at the code of the Person class you'll see there are no cars inside, but when you look at the code for the Car class, there's a person here, and a Person class is used up here. Like I said, the Car class knows about the Person class, but the Person class doesn't know about the Car class. It's a good idea if not every class knows about every other, it makes it easier to make changes. For example, if we make a change in the Car class, the Person class doesn't care. It never knew the class in the first place. One wants to keep the coupling between classes as low as possible. Let's see what other classes the Car class might be coupled with. Go ahead, go through the code of the Car class, and give me a list of all of the classes that the Car class uses. Just put the names of the classes into this box. Here are the classes that I found. Person, we know about that one. String and Array List, I'm not worried about those, many classes use them. System right here, where we have system.out. And Print Stream, that's a hard one actually, because the print stream class is never mentioned explicitly. One would just have to know that system.out is an object off the print stream class. Now, I am a bit bothered about that dependency, because it means that the car class can only work in an environment where I actually have a console, that would mean any computer. And these days, does your cell phone have a console, does a toaster oven? I don't really like to build on a dependency on system.out and print stream if I can avoid it. As you've just seen in our solution, the car class was coupled with the system and print stream classes simply because the car class does an output. And we'd like to reorganize the code so that that's no longer the case. Let's get going. In the tryToAdd method, we have a print statement, let's instead move that to the point where tryToAdd is called. That would be in the loadPassengers method of the simulation class. Go ahead and move the print statement. I've moved print statement into the loadPassengers method. There's just one thing to be careful about. You should only print the message, when the passenger has actually been added. Now we're half done, and in the next step, we'll finish the job of decoupling the car class from system.out. Let's finish the job of decoupling the car class from the use of System.out. There's a second print statement in the drive method where we print something out every time that a passenger gets dropped off. So we want to move this again to the simulation class that caused the drive method. There's just one problem and that is that this statement occurs in a loop. There may be more than one printout per call to drive. So let's think a bit out of the box here. We drive the car to the next location and what could we tell the caller? We could tell the caller what the passengers are that have been dropped off. So go ahead, take this out. Change the return type so that it now returns an array list of person each time you remove a passenger, stick it into that array list. And at the end of the method, return that array list. In the drivesCars method of the stimulation class, look at where you called drive. Now that returns a value namely an array list of person. Save that array list in a variable. Then make a loop over all of the people in that list and for each of them, print the drop off message. Go ahead and implement that now. We had to make changes in two classes, the car class and the stimulation class. In the car class, we now return an ArrayList which is allocated here, we add a passenger to that ArrayList, whenever one has reached his destination. And all the way in the end, we return that ArrayList as the return value of the method. Did you modify the Java Doc, to add an add return statement. If so, pat yourself in the back. In the drives car method, we call the drive method. That returns an ArrayList. For each person in that ArrayList, we print the drop off message. Note, that I didn't even bother to save the return value of the drive method in a variable. You can of course and you may find that it makes the code easier to understand. But here I say c.drive returns an ArrayList. And for every person in that ArrayList, I do something with this loop. Now, we have achieved the goal of our reorganization. The car class no longer knows anything about system.out. The Simulation class does, but that doesn't bother me so much because that simulation class also needed to know about system.in to read the user input. So the simulation class deals with input and output, the car and person class are blessedly unaware of that. Congratulations for having worked through such a complex example. Real life code does look like that, with lots of classes. And in the next unit, you will see the Java way of organizing related classes. What did coupling look like in the photography example? Here's the BlueJ dependency diagram for the code that I wrote for the photography example. Which classes are coupled with which? The answer is, Simulation is coupled with Manager and Manager is coupled with Portfolio. You can see this because Simulation points at Manager in the diagram and Manager points at Portfolio. But Portfolio doesn't point at Simulation, or back at the Manager. Similarly Assignment doesn't have an arrow to Portfolio. So Assignment isn't coupled with Portfolio. And remember in the code, this dotted arrow means that Simulation uses Manager. So somewhere in Simulation, a Manager object or a Manager method is used. And Java use packages to organize related classes. Now, everyone likes packages particularly on Christmas, but in Java, we, we use them all year long. Classes that have one responsibility, get put in one package and classes with a different responsibility, in a different one. For example, you've seen the package called java.util quite a bit. It contains, various utility classes such as Scanner, ArrayList, Arrays, Random, and so on. That's one aspect of packages, to group related classes together. There's another useful aspect, the second aspect has to do with names. Unfortunately, in real life, names aren't always unique. There may be more than one person called Fred. And if you refer to Fred, they may all feel that they are the one. That's of course why last names were invented. So that hopefully the first and last names are unique. Now with people that's no longer the case, but with packages and classes it actually is. A package name is intended to be unique around the entire world. There's only 1 java.util package, and even though there may be other packages that have a scanner class, java.util.Scanner is unique. And you can actually reference in your programs, the scanner class as java.util.Scanner everywhere. And say things like java.util.Scanner in equals new java.util.Scanner. That's a little tedious, of course, which is why the import statement was invented. When you say import java.util.Scanner, that means that from then on, you can drop the family name, and just use Scanner. These two statements then mean the exact same thing. This is the sole purpose of the import statement, to allow you to use only the class name, or the first name so to speak, without having to use the package name. Now let me show you, how to use packages in your own code. So let's suppose that you have a class that you want to put into a package. All you have to do, is put this statement starting with the word package, and then the name of the package, on the top of the source file. Package names are supposed to be unique, and most companies use their domain name written in reverse order. Such as com.udacity instead of udacity.com. Because domain names are guaranteed to be unique. Maybe you have your own domain name. But if you're not. Udacity, in its infinite generosity, it will allow you to use theirs for the following exercises. Now, when you want to use this class, you do what you've always done, when you imported a class. You just use the import statement, and then you get to use the class in the normal way. Now Sara will practice this with you. And you get to reorganize the car pool classes. For the CarShareApp, we crated four classes. There was the CarShareApp, which used the simulation, which used cars and persons. The simulation and car classes go together and are specific to the CarShareApp. The person is more general and could possibly be used for other situations. These three classes could be organized into packages. The person class might go into a more general, com.udacity package, and the simulation and car, would go in a more specific, carshare package. The CarShareApp, is just a main program, that we're writing that uses these other things, so we'll keep it in the default package. Creating packages in BlueJ is a little bit funny, so I'll show you how to do this. From the car share project. I'm going to look up at the menu. It's at the upper left for me, but it might be right along this bar for you. I'll go to Edit> New Package, and then put in the package name. Com.udacity.carshare. Now the package appears here in Bluejay. I can open it up. This is the com package. This is the Udacity package and this is the Car-share package in the Car-share package I want to put the car in simulation classes. So to do that i will go to that Edit menu again and then I select Add Classroom file and then inside the folder that contains all of the Car-share I'll select the car and add it. Now the car shows up in the Car-share package. But I need to add the simulation too. Edit > Add Classroom File > Simulation > Add. Now in the Udacity package I want to add the person. Edit > Add Classroom File and this time I'll select Person. And now its here, so this compiles but if I go back to the Car-share package and try to compile these or find cannot find symbol class. That's because person is no longer right beside simulation so i have to tell Java where to look for the person class. Where do I look for the person class? In com.udacity. Now before I ask you a question, I've got one more clean up task. Right now there are actually two persons. There's one in com Udacity, and there's one in Car-share seven. So, all of the classes that I copied into different packages, I need to remove. So I'll remove car, and it's okay that I'm permanently removing it because I copied it. And then I'll remove person and I'll remove simulation. So like I just mentioned, right now Car isn't compiling. What import statements would you need to add to this project to make it compile again? Go ahead and reorganize all of the classes into the right packages. Then to get the CarShareApp running again. To which class should I add the import com.udacity.person? Write none if I never need to import this. To which class should I add the import com.udacity.carshare.car? And to which close should I add the import com.udacity.carshare.simulation? And remember write none if you never use a particular import statement. And separate answers with commas, if you find that there are two classes that use the same import. We import person in car in simulation. We import car nowhere, because it's only used by simulation. And simulation and car are in the same package already. We import simulation in the CarShareApp. Here's what that looks like in BlueJ. In the car class, we'll import com.udacity.person. In the simulation class, we'll also import com udacity person, and in the CarShareApp, we'll import com.udacity.carshare.Simulation. Now when I go back and compile the CarShareApp, it'll work the way it did before. But now the code is organized into the correct packages. Hello and welcome to this new lesson on Java interfaces. The purpose of Java interfaces is to let us unify common behavior. Let me give you an example of what I mean with common behavior. Here, I have a sample program that draws a delightful suburban scene with houses, and dogs and we'll add other suburban items to the mix soon enough. Let's look at the code. We have a list of houses, we add a couple of houses. We have a list of dogs, we add a few dogs. Then we draw the houses and we draw the dogs. Now, we have to put the houses and the dogs into separate ArrayLists because they're objects of different types. I can't put a dog in an ArrayList of houses or a house into an ArrayList of dogs. Our suburban scene would not be complete without cars, so go ahead and add a few cars to our program. One for this house and the other two for the Mcmansion over here. Here are the cars. Let's see how I did it? I simply added an ArrayList for cars. Put in the cars at the coordinates that the question asked for, and then I added a third loop to draw all the cars. Now, this is not so pretty. And it really would be nice if we could some how unify all of these various elements, put them in a single container and draw them in a single loop. That's what we'll be able to do with Java interface types. In Java you can use an interface type to describe common behavior. In our example, what do cars and dogs and houses have in common, they're all drawable. They all have a draw method. In Java, we use the interface keyword instead of the class keyword. To define interfaces. Here we say that Drawable is an interface, with a draw method. We give no implementation of the draw method, that's up to the individual classes, that implement this interface. Methods in an interface are automatically public. You can write the keyword public, or you can omit it. Now an interface is different from a class, an interface only specifies the behavior and you can't create objects of an interface, instead you create objects of classes that implement the interface, let's look at that next. When you have an interface, and you have classes that can make use of it, those classes need to implement it. Here's how that works in Java. The class, declares that it implements, the Drawable interface. It provides a draw method, and then it also needs to put in some implementation. The class is free to provide other methods that have nothing to do with the interface. You can have as many classes as you like that implement the particular interface. Here the Dog class does the same. Now, suppose you have an object of a class that implements the drawable interface. For example, a house, then you can save it in a variable whose type is the interface. And that intuitively makes sense, a house, is a kind of drawable. Now that solves our problem. because similarly, we can make an ArrayList of drawables, and this ArrayList now can hold dogs, houses, whatever. You simply take any object of any class that implements the drawable interface, and you add it to the ArrayList. It works, because you can convert from a dog, to a drawable which is what this ArrayList holds. In our same class, we can replace these three ArrayLists with a single one, an ArrayList of drawable. Go ahead and do that. When you're done, you should have just one ArrayList into which you add three cars, two houses, and three dogs. And down here, you should have just one loop. Of course, you also need to make sure that the car, house, and dog classes all implement the drawable interface. Let me show you my solution. First of all, notice in BlueJ, that the dog, house, and car class, implement a drawable interface. You see that with these little arrows with a triangle on the end. If we open up one of them then we'll see the implements class over here. Now let's look at the scene class. Note that we now have a single ArrayList, everything gets added to that one ArrayList and we just have one loop. So you can see how interfaces dramatically simplified this program. What made it all work? The fact that you can convert from an object of a class to the interface type. In this case drawable. And so all these elements were convertible to drawable and then to draw them we can invoke the draw method on each element. We know they all have a draw method because they're all drawables. Sara has a few exercises prepared to make sure that you understand when you can and when you can't convert between two types. And then, she will show you a new interface that expresses when an item is likable in a social network. That was a lot of new information, let's take some time to digest it before moving on. What will happen if I tried to declare a variable house of type house and then create a new dog and try to put that into the variable house. Will, the program declare a variable of type house and store a new dog in it. Will we get an error in compatible types because dog is not a kind of house? Or will we get an error dog is abstract cannot be instantiated? The answer is Error: incompatible types. A Dog is not a kind of House. If you try to store a Dog in a variable that's made to hold a House, you'll get a compile time error, which is good. If Java let you store a Dog in a House variable, you might then try to call House methods on the Dog. And the Dog wouldn't know how to do them. Getting this error is actually a good thing. It means that java is helping us. This is one of the things that we were talking about when we mentioned really early on that java is a safe language. If java let you create a Dog and then store it as a House, you might try to live in it later and fail. But instead of doing that, the compiler will immediately tell you that there's something wrong with your code. Other languages might allow you to keep running the code, and then mysteriously fail or return the wrong results. This third option isn't quite what we want. This the area that you would get if Dog were an interface. If you tried to make a new Drawable, then you would get an error like this. Error Drawable is abstract cannot be instantiated. The Drawable interface has methods sort of, but it doesn't have enough detail about them for Java to actually make an object Drawable for you. There's also something wrong with this declaration. Why won't this declaration work? You can't assign an object of a class to a variable of an interface type. You can't construct an interface type. Or you can't assign an object of a class to a variable of an interface type the object's class doesn't implement. The answer is, you can't construct an interface type. We know this can't be the answer because we have assigned objects of certain classes to variables of interface types. In the example before this, you saw code that created new dogs and then put them in drawable variable or added them to lists of drawable items. So this statement is false. This statement is true, but doesn't apply in this case. I can only put an object into a variable with an interface type if the object is of a class that implements the interface. Like in this case. But if the dog class didn't implement the drawable interface, I wouldn't be able to do this. If you're not quite sure why you can't construct an interface type, let's look at the code. This is the code for a dog. It has all of the information on how to move and how to draw. The drawable interface has almost no information at all. If you tried to make a new drawable, it would know that it should know how to draw. But wouldn't know how to draw. That's why Java won't let you construct a drawable. Let's do one more of these, what if I tried to declare a drawable that's a new rectangle what's wrong with this deceleration, you can't assign an object of a class to a variable of an interface type. You can't assign a value of an interface type to a variable of a class type or you can't assign an object of a class to a variable of an interface type the object's class does not implement The answer is, you can't assign an object of a class to a variable of an interface type the object's class does not implement. We've seen that it's possible to assign an object of a class to a variable of an interface type. And this declaration isn't trying to assign a value of an interface type to a variable of a class type. We can create a rectangle without too much trouble, but rectangle doesn't implement drawable. So we can't store the rectangle that we created in a variable of type drawable. This is a little bit weird, since the rectangle actually does have a draw method, and the drawable interface promises that it will have a draw method and nothing else. The problem is that rectangle doesn't say that it implements drawable. For all Java knows, these two drawable methods could be completely different. If we wanted to save a rectangle in a drawable variable, we would need to change the rectangle class to say that it implements drawable. Now Sarah has shown you another example of a interface, and I hope you've become more familiar with how they work. They're really pretty natural. But when you think about it, there is something mysterious going on. In our suburban scene, we had an array list of drawables. Houses, cars, dogs and so on. We got one of them, store it in a variable of type drawable, of course, then call the draw method on it. That has [UNKNOWN] d belongs to the drawable type, and drawable has the draw method. What's d? It's the variable, so it holds a reference to an object. An object of what class? You might think it's an object of class drawable. Now wait a minute, there is no class drawable. Drawable is an interface. So that can't be it, and in fact, there is no way of knowing to which class this object belongs. There is only one thing that we know about it, this object belongs to some class that has a draw method. And in fact as you loop over the various elements in the array list, this line of code may call different methods. The draw method of the house class, the dog class, or of some other class, so far unimagined, that also chooses to implement the drawable interface. This variation is called polymorphism, which is just a fancy word for saying different shapes. In our scene, that's a very appropriate name. Because the draw method can draw entirely different shapes depending on what the implementing class does. But the term polymorphism is used generally in Java to indicate any situation where you have a method call and the actual method called depends on the type of the object. Now, why is polymorphism important? It lets us build expandable systems, where we can add new types without having to change the essential logic of the program. I'd like you to try this out and add a new type to our suburban scene. Namely a ball class and simply the kind of ball you may find lying on the street. And when you do that, note how little of the program you have to change. Here we have the red ball in the ball class. One has to do two things. First of all, the ball must implement the drawable interface. And we need to supply a draw method, in this case the method was very simple. It simply fills the circular shape. In the Scene class, we add a Ball, and that's it, nothing else needs to be changed. The mechanism that does the drawing stays completely the same. That's polymorphism in action. we have a general mechanism that can deal with any drawables. And if we want to add more, then we can simply add them without having to make any further changes. Now our suburban scene was quaint, but it was rather static. Let's add a second interface to add some motion. The moveable interface has a method move, and we give the number of seconds for the simulated motion. Now, cars are moveable, our car class implements two interfaces, drawable, and movable. Lets see how that start. The car class now needs to implement the methods of both the drawable and the movable interface. Here is the draw method that we've always had, here is the move method we'll arbitrarily say that these cars moves at 10 pixel per second. And each of the components of the car is moved by that amount. What's it look like? When you run the program, you can see this car here moving. Later, we'll move the other cars as well, but for now please go ahead and move Fido as well. So we wanted to make this dog move, simple enough. We simply make the dog move just the same as the car. But of course now we have to edit the dog class, and make the movement happen. There's the dog class. We add Moveable to the list of interfaces. And here's my move method. It's simply enough, I simply move both the picture of the dog and the name text. And I was asked to move it vertically at one pixel per second. That's why the horizontal displacement is zero and the vertical displacement is the same as the seconds. When you run the program, then here you can see the car move, and the dog move. In the latest version of our suburban scene, we had a moving car and a moving dog. But of course really we want all the dogs and cars to move. One way of doing that would be, instead of just making one car and dog move, to put all the cars and dogs into an array list of movable objects. But you might say we already have an array list of drawables, can't we reuse that? We can, but we have to learn a bit more about working with types and Java. Let's say I have a drawable, what I'd like to know is if it's a movable. The instanceof test gives me the answer to that. This expression is true, if d happens to belong to a class that also implements the moveable interface. Of course in that case, I'd like to then call the move method. But not so fast, I can't call d.move because d is not movable. I have to convert d to something that is movable. Here is how you do that in Java. This expression means take d and cast it into a movable. We've previously seen the cast notation to change a floating point number into an integer, it's the same notation but now with an interface type. Once it is a movable, then it is saved in the variable of type movable. And then we can invoke the move method on m. Again you couldn't have invoked on d because d doesn't have a move method, that's drawable. This conversion is necessary. What if you make a cast of something that wasn't movable such as a house then he would get an exception and your program would terminate. That's why it's important that we first check whether d in fact is movable. These instances of tests and casts are not very common but they do happen every so often. And it's good to be familiar with them. So go ahead and put this to work. In the scene program, go through all of the drawables. Find out which of them are moveable, and move them. Our task was to go through all of the elements and the list of the drawables, to check which ones are movable. That's done with the instance of operator. Now then we wanted to move them, but of course, we have convert them from drawables to moveables, that's done with this cast. Take the drawable, cast to moveable, save it in a moveable variable, and then we can use that variable to exercise the move method. When we run the program, we see the cars move, we see the dogs move, which is really isn't moving experience. Now, I'll turn it over to Sara, who will talk to you more about interfaces, the instance of operator and casting. Casting with instance of checks is something you will occasionally need to use when programming in Java, but it's best to avoid it in general. Let's explore why. Here's the code for seeing.Java that you wrote before. What if we had accidentally forgotten to do this check and I just gone through all of the elements and tried to move them. What will happen if I run the program now? Feel free to try this yourself in BlueJ. Will the program run the same way? Will the houses move even though they should be stationary? Will there be a compile time error because drawables can't be cast to type movable? Or will there be a run time error? Because some drawables cannot be cast to type moveable. Like I said, if you're not sure feel free to try it out. The answer is, there will be a runtime error, because some drawables can't be cast to type movable. If I compile and run the scene the way I did before, I'll get this drawing and this exception. ClassCastException, house cannot be cast to Movable. The program never got to the moving part. It looks like BlueJ has kindly taken me to the line where the ClassCastException happened. It looks like we tried to treat something like a moveable that was not actually moveable. And as you can see the program crashed completely. It wasn't so bad that the program crashed in this case. I can just add the condition back, compile, and run again. And this only cost me a couple of minutes. But if I had been running this program for a whole day or something, and it had crashed and lost all my data. Or my website went down and I had to rush to my computer and run the program again to get it up and running. I would be pretty sad. If you find yourself casting something to an interface type and checking whether things are instances of other things. It's often a sign that you could design your code better, so that you could make the Java compiler do more work for you, and find errors at compile time instead of run time. So, what could we have done in this case? Maybe what we really wanted instead of a Moveable and a Drawable interface was some other interface, like Animated. Maybe Animated would have void draw As well as void move. And when houses implemented the move method, they could return immediately instead of actually moving. That way we could ask all of the animated elements to move And not worry about run-time errors. Or maybe we should accept that one ArrayList isn't enough here. Maybe we wanted two ArrayLists one Drawable and one Movable. There are lots of possibilities here, finding the best ones is something that you'll find by trying more things, keep practicing. You've seen some interesting interfaces with drawable and likeable, but let me give you another very common reason why people like to use interfaces. And that is to be able to reuse an algorithm. Consider a common algorithm to compute an average. Here I have an array of countries, each of which has a name and an area. And I want to know, what is the average area of all of these countries. Now of course, I could write a loop to compute that, but lets say I want to a method that does this for any set of countries. So, I'd like you to complete this method that takes an array of countries. For each of them, find out what the area is simply by calling the Get Area method. Add up all those areas, and then return the average. To compute the average, you first need to compute the sum using the algorithm from lesson seven, we traverse all elements in the array. Ask each of it for its area and sum them all up. Then we return the sum over the count, which is the sum over the length of the array. And as you can see here, I was a little nervous. What if someone gives me an array of length zero, then I don't want to divide by zero. So, I'm checking for that, and in the admittedly unlikely case that I do get an empty array, I return zero. When you run the program, It gives you an average area of about 75,000 square kilometers. That's actually not very large, it's a bit larger than West Virginia. Next, let's see how we can compute the average of another set of objects. You've just computed the average area of a bunch of countries. Now, let's say, we have a different data set, a bunch of cars, and we'd like to know their average fuel efficiency. Again, I'd like to have a method average that does that, and the data class. And again, I'd like you to write that method. Your task was to write the average method that computes the average of a bunch of fuel efficiencies. Now, of course that's almost exactly the same as computing the average of a bunch of areas. So let's copy and paste this code. And there are only two spots where I need to fix it up. Over here instead of country, it should say car. And over here instead of calling getArea, I should call getFuelEfficiency. And that's all. This is, of course, intensely boring, and there ought to be a better way. You've just written the same algorithm twice, once for countries and then for cars. And you probably passionately wish to never again have to do that for any other class. So, let's see how we can come up with a generic way of computing averages. The trouble was that the cars and countries had different ways of measuring whatever it is that they wanted to be measured by. By with the car it was the fuel efficiency, with the country it was the area. But let's say they both agreed on what it meant for them to be measured. Let's say, they both implemented a common interface. I call this interface measurable. Let's look inside. It just has a single method, getMeasure. We expect each class that implements this interface to provide an appropriate implementation for getMeasure. For example, the country class implements getMeasure to return the area. The car class has the same method, return miles per gallon. Now, we can implement a single method in the data class that would take an array of measurable objects and it will compute the average measure. That's for you to complete. In the tester, we'll call this method, first on an array of countries, then we call the same method again on an array of cars. That's what I mean with the reuse, this method only has to be written once and we can call it with data sets containing objects of different classes. Now go ahead and complete the implementation of the average method. Here is the method that you were asked to complete. We have an array of objects that are measurable. And we now should sum up all of the measures and then take the average. So over here, objects is an array of measurables. We need to give a type for each of its elements. While that type is measurable. Next we need to compute the sum of the measures. What method should we call an obj? We only have one choice. Obj is a measurable, and a measurable has only a single method called get measure. So let's call it. And here it is, our universal algorithm for computing averages. You'll never again have to write it, provided, of course, that the classes that you want to put in are willing to implement the measurable interfaces. You've just seen a universal algorithm for computing the average of an array of objects of any type that is willing to implement the measurable interface. Let's implement another algorithm along the same lines. This time, we want to compute the largest element in an array. Again, we have an array of objects, and you may recall from lesson seven how to do this. You figure out what is the largest element that you've seen so far, at the beginning that's the first one. Then you go through the remainder of the array, if you find a larger one update largest so far. And at the end that's what you return. So go ahead and complete this method, it'll be the last time ever that you have to write it. Here is how you complete the largest method. For simplicity, I'd put objects i and another variable that I call current. You don't strictly have to do that. And now I have to check whether current is bigger than largestSoFar. Well, they're objects so I can't compare them directly. I have to compare their measures. Is the measure of current bigger than the measure of the largest so far? If so, I changed my mind about who's the LargestSoFar. It's exactly the same algorithm that you've seen in lesson seven, now applied to measurable objects. Let's run the tester. And we see what the most fuel efficient car is. Not surprisingly, it's an electric one. When you look at the code of the tester, there's something that's a little bit subtle. The largest method takes an array of measurable. Over here it returns a measurable, and I'm printing it here by adding it to the print statement. That only works because the Car class has a two-string method. That can convert a Car to a string. And it's a bit of a trick, the same thing won't work, for, computing the largest Country in a set of countries. Let's try that. Here, I'm computing, the largest Country of a set of countries. And now, let's run the program. and it prints the largest Country as some gibberish that's just what a string does by default on an object. And really what we want is we want the result of this call as a Country. We know it has to be a Country its one of the countries that came in so we want this to be a Country and not a measurable and here we want to be able to call The getName method on it. Now when you compile this, of course it doesn't work. We are told the types are incompatible. As a simple fix, go ahead and make that fit, and get this program to run. So here was our problem. Data.largest returns a measurable. That's all it can return, because the data class knows nothing about countries. We need a country, and the answer is simply to cast. The cast is legitimate, the largest country had to be one of the countries that was put in, and its proof safe to convert back from a measurable to the country. Lets think once more what advantage we get from the measurable interface. When you look at the BlueJ, display of classes and the interfaces, you can clearly see that country and car both implement the measurable interface. You can see that the data class uses the measurable interface, that's the dotted line here. And what's important is that the data class knows absolutely nothing about country's cars or any other classes. It's decoupled from those classes, and that's what makes it, so generic. Now, Sarah will introduce you to an interface that's much more commonly used, a comparable interface. Sometimes you don't have to implement an algorithm at all to reuse code. The Comparable Interface is a very common interface. And implementing comparable allows you to use handy pre-implemented algorithms for tasks like sorting. Here's the documentation for Comparable. It's an interface that has exactly one method, the compareTo method. Classes that implement the comparable interface promise that they will implement the compareTo method. When you call a.compareTo(b), it returns a negative number if a comes before b. It returns a positive number if a comes after b. And it returns zero is a and b are exactly equal. Once you implement the compareTo method, anyone coding can use it to figure out what the natural order of objects in your class is. To give you an idea of how common this interface is, strings are already comparable. You can check whether a class implements comparable by looking at its documentation. Under all implemented interfaces, you can see that comparable is listed. Just to get you thinking, what will this method called return Badminton.compareTo Football. Will it return minus 4, 4, 0, true, or false? Think about the natural order of strings. And if you're not sure you can try it in bluejay. I haven't totally explained to you how to do this question, but just go with your gut. The answer is minus four. Strings are sorted alphabetically, so strings that start with B, come before strings that start with F. Since badminton comes before football, compareTo returns a negative number in this case. compareTo could actually have returned any negative integer, and still been correct. But the way that compareTo is implemented for Strings, happens to return minus four. Because strings are comparable, we can sort them by writing one line of code. If I create an array list of strings and add a whole bunch of things not in any order, and then I want to print them out in alphabetical order, I can add the line collections.sort strings. Collections is a class a little bit like a race that has some useful utility methods. If I compile and run this code, it will print out all of the animals that I added to the list, but from A to W. We might want to be able to sort countries like this too. Let's say countries are naturally ordered by their areas. Let's implement the compareTo method for countries. I want to be able to make an array of countries like this, and then use the sort method in the arrays class to sort all of the countries in the array, so that this will work. Let's implement the comparable method for countries. We'll need to make the country measurable and also comparable. Now the method should be public and return an int. It's called compareTo, and it takes an object, otherObject. Now if we want to compare otherObject to this object, the first thing we'll need to do is check whether otherObject actually has a name and an area. If otherObject is not a country, then it doesn't really make sense to compare it to this country. If you keep studying Java, you'll figure out how to avoid this cast using generics. For now though, let's focus on the compareTo method. For now, fill in the code, so that compareTo works as I described before for countries. Return a negative number if this country is smaller than other, positive is this country is larger, zero if the two countries are equal. And notice, I implemented .equals for you. So, you can use this. And if the countries are exactly the same size, you can break ties using the name. Can you fill in the rest for me? Probably the easiest case would be when the two countries are exactly equal, so if this dot equals other country then I can immediately return zero, otherwise if this dot area is less than other country dot area I want to return a negative number, I will just go with minus one otherwise if this dot area is less than, I mean greater than OtherCountry.area, I want to return a positive number. I think one'll do. Otherwise their areas must be exactly equal, in which case, I'll use the string compareTo method on the name, and return the result of that. Once I fix my syntax errors, I want to check that this actually works the way I'd expect. So I'm going to get out my code pad. And make some new countries. El Salvador should come before Belize. So If I compare El Salvador to Belize, I should get a negative number. So far, so good. Certainly the opposite direction should be positive. And Belize compared to Belize should give me a zero. And just to make sure that I'm breaking ties, let's compare Belize to a made up country, with the exact same area. Alright, negative 11 sounds good to me. So long as compareTo doesn't return zero, with two countries that are clearly different countries. Now, to make sure the work wasn't all for nothing, I want to show you that now we can sort all of the Central American countries. Using the Arrays.sort method now if I run this, now I've tempered with the two string method a little bit just to make this easier to see, I get the countries in order by their areas, sorting is actually an interesting task, when many people have studied for years but we just managed to do it in one line of code array for interfaces. We have been talking a lot of about interfaces and how useful they are, now I would like to bring up a related topic called inheritance, and interface specifies behavior that the class that implements it should exhibit. Inheritance can do a little better than that, when a class inherits from another class it picks up behavior and data. Here is an example of a set of classes, where one would probably use inheritance, to model them. We have a class vehicle, it's a very general class. A car is a special kind of a vehicle, a motorcycle is another kind of a vehicle, a truck is a kind of vehicle. And an SUV is a kind of car. Now you would use inheritance not interfaces in this situation because you could put common data into the vehicle class. Such as the weight of the vehicle, the number of wheels, things like that. Now you might say why not always use inheritance? It seems better. But there are two issues with it. One is, it is complex, and also a class can only inherit from one class, whereas a class can implement as many interfaces as it likes. A bit of terminology, the class from which one inherits is called the super-class, and the class that does the inheriting is called the sub-class. We would say truck is a sub-class of vehicle. Vehicle, has a super-class, of truck. Just to see that you're paying attention, let me ask you, what are the sub-classes of car? What are the super-classes of car, the sub-classes of SUV, and the super-classes of SUV, in our inheritance hierarchy over here? Just put your answers into these boxes. Let's look at the car class. It's subclass is SUV. An SUV is a special kind of a car. At superclass is vehicle. A car is a special kind of vehicle. A vehicle is more general, a car is more specific. Subclasses of SUV, we don't have any. Superclass of SUV, car is a superclass. And then going one further up, vehicle, is also superclass, sometimes people say that car is a direct superclass. Now we could implement, this vehicle hierarchy in Java, but truth be told, it's a little dull, and we'll come up with a more interesting hierarchy. And the car hierarchy you've just seen, makes it easy to understand the concepts of super and sub classes but it doesn't make for a very interesting implementation, instead lets look at quizzes. In a quiz, you can have different kinds of questions so it's natural to have a super class question. And then, you may have various sub classes. Maybe a question where you need to fill in a missing word, or a question where you're given a bunch of choices, or one where you've to supply a number, but it might be okay if it's not exactly the right answer. A numeric question might take round off into account. And so on. You could even think that there is a, sub-class of choice question. I'll call it a Multi Choice Question, you know, one of those where you need to supply all of the choices that are correct. What do our questions have in common? They all need to be able to display themselves, and the display may be as simple as showing the question text, or it might have to have a list of choices. Or an underscore at the right place for filling in a word, and also any question needs to be able to check its answer. That might be a string comparison or a number comparison that's, or a number comparison after some accuracy. So the idea is that, the super-class question will give reasonable implementations of these methods, and the sub-classes can modify them if they don't work for the context of the sub-classes. I've implemented the question class for you, and here is a programming problem that's designed to make you familiar with that class. So that you can form sub-classes, as we go, go along. Here's the question class. Have a look at it's methods, as you answer the next programming question. And here is a demo program, in which I want you to fill in some details. Make a question object, and then there is a method present question. That displays a question, gets the user response, checks whether was correct. They're methods for displaying and for checking a response. And I want you to look them up and call them. There are two tasks for you. First off, to make a new question. Here, we construct the question, and now we need to set the question text. There's a method for that. And we need to set the desired answer, and there's a method for that. Really all you had to do is look up here and imitate how to set up the first question. In the present question method, we first display the question. Again, there is a method for that. To find that out, you actually had to look up the Question class, the method is here. There's no other way to show that question text than to call display. The code for reading the response was already given to you. Now, we need to check if it's the correct response. That's the job of the checkAnswer method that you also had to discover by looking at the code of the Question class. It gets the user's response and it returns true of false depending on whether it's correct or not. We were supposed to print true or false. The simplest way of doing that is to just print the value of the Boolean variable. But, of course you could also print true in this branch and false in this branch if you prefer. So if the outcome is true, we return a score of 1 otherwise a score of 0. Let's just run this program. So let's see. Who was the inventor of Java? Everyone knows that or not. And who was the founder of Udacity? Oh, I better get that one right or I'll get in trouble. Now, [LAUGH] I did this one right and at least I got a score of 1. So, now you have an idea on how the basic question class works. And we're ready to refine that class by forming sub-classes of it. You've just worked with the question class and now its time to form a Subclass. We've all seen these multiple choice questions, as a question and there're multiple choices hence the name. By the way, if you ever want to know what's the original name of the Java language, it was Oak, which was a name that was so dull and boring that they changed it. Now, of course, one could put this entire text here into a question class and set the answer to this string three. But that too would be dull and boring. It would be better to have a class that specifically deals with multiple-choice questions. So that we could declare an object, somewhat like this. We make a Choice Question, that's what I'm calling this class. We still need to set the text of course, but then for the choices I want to be able to call a method that I call addChoice that adds the particular choice and then specifies whether it's false or true. When I formed the Choice Question class, I didn't want to start from scratch. I want to inherit as much as possible from the question class that's already written. Let's see how to do that. I'll define the ChoiceQuestion class and then I specify that it extends the question class, that's the Java keyword for denoting that ChoiseQuestion should become a subclass of question. Into the body of the subclass, I put in any new methods that are present in the subclass but not the super class. Such as the Add Choice Method. You also put in the implementations of any methods that needed to change in the sub class. For example, we'll need to change the display method, since displaying a choice question must also display the choices. And finally, you of course need to add any instance variables that the choice question class needs to do its job. In our case, that would be the list of the choices. The key point is what you don't put in here. When you define a subclass, you never include any of the methods from the superclass that work just fine. For example, the set text method will work fine, and we can simply inherit it from the superclass. Also, you don't want to include any fields from the superclass. You get those automatically, and if you were to include them again, you'd get 'em twice, which is not good. The point is that, what you put inside here is the difference from the superclass. Everything that the subclass has, that the superclass doesn't have at all or that it doesn't have in the same way. Let's have a closer look at exactly how that works for question and choice question. Here is our question class, here is the choice question class. Now have a close look and tell me, which methods does the choice question class inherit? Just give me the names of all those methods that choice question doesn't redefine, that it simply picks up from question. Which methods does choice question overrides? That is which method does choice question need to redefine because the one's from question are not satisfactory. And finally, which method or methods does choice question add that weren't present in the question class in the first place? Just give me the names of the methods, all together there are 5 of them. Alright, here goes. There are three inherited methods, set text, set answer, and check answer. And you can tell because they are over here, and they're not over here. Because choice question extends question, it picks up all of those methods automatically. It inherits them. Display, on the other hand, is both here and here. Which tells us that the choice question was not happy with this display and provides its own. It overrides the one from the super class. Finally, there's add choice, which wasn't over here at all, so that's an added method that only appears in choice question, but not in question. Next, you'll get to implement these two methods, but the good part is, you don't have to implement these because they are already in the question class and choice question just inherits them. Let's get started with implementing the missing methods in the subclass. We'll start with the addChoice method in the display method I've given you a stop gap implementation we'll refine that later. In the addChoice method we need to add the new choice one of the multiple choices somewhere where as some where. We actually also need to have an instance variable to collect the choices, we'll just collect them in an ArrayList of strings. One entry per choice that means you needed to clear that instance variable in the choice question class and you also need to initialize the instance variable in the constructor. Once you've done those things you can turn back to the addChoice method and simply add the choice. There's the second parameter that indicates whether the choice is correct or not. We'll take that one up in just a minute. At this stage, just leave it alone. So go ahead and do those three things and then we'll compare notes. There're three things we have to do. First off, we need to declare an instance variable to hold the choices. That's an ArrayList of Strings. In the constructor, I initialized it with an empty ArrayList. And in the add-choice method, I simply add the choice to the ArrayList. That was a good start, but so far we've ignored this parameter that tells us whether that choice was correct or not. And that's what we're going to be doing in the next stage. Lets continue implementing the addChoice method. You've already done the first part, adding a new choice to the list of choices, now if this parameter here says that it was the correct choice then we should set the answer, and the answer should be a string 1, 2, 3 or 4 depending on whether this was the first, second, third or fourth choice. How do you know which choice it was? It's not passed as a parameter to add choice, but you can tell by looking at how many elements are already in the choices array. Of course, when you ask the choices array for it's size, that's an integer, answers are strings, just concatenate with the empty string to change the integer to a string. And now you're going to have a bit of a challenge. When you have a choice question object, it has two instance variables. The correct answer, this instance variable is inherited from the question super class and the list of choices. You will want to set the answer to a string, such as this string 3, but how can you get at it? The answer is an instance variable of the question class and it's private, no one can access anything private in the question class accept the methods of the question class themselves. Choice question extends question but that doesn't give it any special privileges. It cannot access this instance field any more than anyone else. So that's the challenge you need to overcome. And the point is, of course, that just like everyone else, you will need to use the public interface off the question class. Go ahead, give it a try, and implement the add choice method. Your task was to complete the implementation of the addChoice method, and the previous step you had added the choice string to the list of choices. Now we want to take this parameter into account. And if were handed the correct choice, we want to update the answer. Now the answer is the string, such as three if we're currently at the third choice. So, over here, we can find out what the current choice is by measuring the size of the choice array. When we're at the third choice, there are three choices in the array. The number that we need is three, but we need it as a string not as a number. That's the step here. Now, this is the string that we need to set as the answer of our question. I've talked about that, you cannot simply access the instance variable of the super class, but mercifully, we have a method from the super class that does just that, namely setAnswer. So, all we have to do is call setAnswer. SetAnswer by the way is an inherited method that we simply get to call. Alright. Now you've implemented your first subclass method completely. And next, we'll turn to implementing the display method. Now, let's turn to the implementation of the display method. It's supposed to display a choice question in this format. First, the text of the question. Then all of the choices, and we put a 1, 2, 3, 4 in front of each of the choices in case the poor test taker is too frazzled to figure out the numbers themselves. It's easy enough to do this part. All we have to do is loop through the choices and print them with a number in front of them. And since this has nothing to do with learning about inheritance, I'm just going to give you this code. It's right here. So we print the number of the ith choice and the ith item. actually not quite because in Java the choices have indexes, zero, one, two, and three. And we chose the more traditional one, two, three, four, which accounts for the i plus 1 over here. The hard part is to display the text of the question. And again, the question text is in the Superclass object, and we can't get at it directly. Let's have a look at the Super class. Here is the question text, do we have any method that lets us read it? there is, And we could call display, and then it would print it. That's just what we need. Lets do it. Here I call display that should display the text and then here I am displaying these choices around the demo. Oh! something very bad happened, I got a StackOverflowError. Now, that's technical link of for having a method that keeps calling itself. why itself? See the method is called display and here it calls itself. That's a problem, I didn't want to call my own method, I wanted to call the display method of the Question class. So my difficulty is that I have two methods called display in the Superclass and in the Subclass. And they have the same name. That's exactly what always happens when you overwrite a method. Now, there's a special syntax for invoking the Superclass method and it looks like that. You simply say super.display. Go ahead and give that a try and fix up the display method. We had the problem that simply calling display inside the display method couldn't possibly work, it would just call the method itself and itself, and itself. The way to get the super class method involved, which displays the question text, is simply to use the keyword super. This will work. Now the program correctly shows, first the text of the question and then the list of choices. You've just implemented the choice question [UNKNOWN], and used it in a program that displayed two choice questions. Previously, you had written a program that presents two plain questions. Can we mix the two? How can we write a program that presents a plain question, and then a choice question? Should we provide two present question methods? One for questions, one for choice questions, or is it okay to provide a single present question method who's parameter has type question, and use that to present both the question and the choice question? Or should the parameter of that single method have type choice question? Or, are we trying the impossible? What do you think? It's good enough to provide a single method present question whose parameter is a question. A choice question is a special kind of a question, and so, you can pass a choice question into a method that expects a question. In general, anytime that you have a subclass, you can give it to any method that expects a super class object. Go ahead and try this out. Make a quiz that contains a question and a choice question. Just reuse that question that we had before, that asks who was the inventor of Java. Over here, both of the questions are paths to the single presentQuestion method. And in that method, just to make sure that you got the point, fill in the right type for the parameter. Here is the first question, I just copied it from a previous program. Here's the second question. Notice the first one is a, plain old question, the second one is a choice question. I'm passing both of them to the presentQuestion method. That's just one of those methods, it's down here, and its parameter has type Question. So it's okay to pass a choice question into a question parameter. You can always convert from the subclass to the super class. You've just written a program that contains multiple question types. Over here, we have a plain question, over here a choice question. We pass each of them to the present question method, that method is down here. It has a parameter of type question. And now let's focus on this display method here. Notice that q is of type Question. And I would like you to tell me exactly which display method is called, in the call q.display. Is it always, the display of the question class? Is it always the display method of the choice question class? Does it vary? Is it sometimes question display and sometimes choice question display? Or could this call even call some other method, something other than question display and choice question display. Let me know what you think. When you think about it, you know that this call here in your last program sometimes showed a question and sometimes a choice question. But actually, in other programs, this call could even show something else. We could have a third class that's also a subclass of questions. Pass it to present question. And then its display method would be called. We've just talked about which display method gets called int present question method? The method has a parameter whose type is question. So here's the parameter variable. It contains an object reference which points to an object, an object of what type, while you think it's question, because that after all has the type of q, but not so fast, the type of q, the variable isn't the question. The type of the object is really not known. It could be any sub-type of question. Now the good thing is, that when the program runs it does the right thing. At runtime, it's determined what the exact type of this object is. And its display method is caught. That might be question.display, choice question display, or the display method of some other class. That also extends the question class, this is a very useful feature because it allows us to write generic codes such as present question that works with questions of any type and actually this diagram should be familiar to you, you've seen the same diagram when we talked about interfaces and there is the name for the fact that the correct version of a method Get selected at run time. Remember what that's called? Was it object already has programming? Incapsulation? Inheritance? Or Poly morphism? The answer is polymorphism. Polymorphism means that a method call such as here the call to display reaches the correct method at run time depending on what this variable refers to, the correct version of display is fit. Polymorphism is great because it make systems extensible. I can add new classes to the system, such as new types of questions, and still reuse the present question method without having to change it. We just saw that because of Polymorphism, one can write a program that can handle any mix of quiz questions. Let's try that out and develop another question type. A numeric question expects an answer from the user that is a number. For example here we ask what is the area of a circle with radius one. And the answer is of course pi, but that might be hard to enter, and we can't really expect the user to type in the exact value of pi, and as you know, this is not even the exact value, either. It goes on forever. We just want the user to be able to enter, say, 3.14 or 3.14159, depending on how well they remember those digits. Either one of those answers should be fine. In fact, we'll take any answer, that's up to point oh one away, from the answer, that the user provides. In a different numeric question we might use a different tolerance. Your task is to implement this new question type. We've give you the constructor, your job is to provide the set answer method. And the check answer method. And the check answer method, you need to take the tolerance into account, you need to check whether the given number is not too far away from the response. So, technically the response is a a string, you need to convert it to a number. And we show you here how to do that. You may need additional instance variables. And then you should put them here. Go ahead, give this a try. Lets start with the most interesting method, in the checkAnswer method, I am given the response which is a string, I convert it to a number by calling DoubleparseDouble and now I check whether that number is close enough to the actual answer, we've learned in lesson four how to do that, we take the difference of the two numbers that you want to compare, take the absolute value. And check whether that's most the given tolerance. Now, there's just one catch. What's this answer here? Well, it's whatever was supplied in the set answer method. Interestingly, the set answer method here takes a double, so it's not a string. And that means it's different from the set answer method that was defined in the question class. That method took a string. Now I could've converted this number into a string, and then passed it on to the setAnswer method of the question class, and let the question store it as a string, and then I could've converted it back from a string to a number, I suppose, except when I tried that it didn't work, because the question class has no way of giving me back the answer. It's used inside it's own check answer method. But that one is worthless to me, because it doesn't take the tolerance into account. So instead, I just store the answer as a double in the numeric question. You've just implemented a program that shows two kinds of question; a plain question and a numeric question. Both of them work past to the presentQuestion method. Clearly we can extend the system with all sorts of other question types, and we won't ever have to change the presentQuestion method. So, what polymorphism gives us is extensible software systems. We can start out with something simple and without having to change any of the basic structure. We can extend the functionality by adding more and more subclasses. Polymorphism is one of the two corner stones of object orientated programming. The other one is encapsulation. Remember that encapsulation means, we separate the interface of a class from it's implementation. And that means that the implementations can evolve over time and gain more functionality without having to change the rest of the system. So, both of these cornerstone properties let us build systems that start out small and that can be functional for a long time. Which is why object-oriented programming has become such a popular methodology for writing programs. Now, in a few short weeks, you have gone from just becoming familiar with objects and how they work, to being able to write quite sophisticated programs that can withstand the test of time. So, you've really come a long way in this introduction to programming, and I hope you enjoyed it.