You're probably familiar with many of the services that are offered by Google. And if you develop applications your users likely are too. Perhaps they need to find a location or see what's interesting nearby. They're using Google Maps. Maybe you want to monetize your apps so that app usage is rewarded and your users, they don't have to pay upfront. Google Ads is your friend. As well as these, we've got lots of great APIs for you, storing files in the cloud with Google Drive, accessing Goggle Analytics. Signing into your application, integrating with Google Fit and much, much more. In this course, you'll learn how to use these services in your apps. You'll see how easily you have the power of Google at your fingertips, allowing you to build better apps. Before you can get started, let's take a look at getting the tools that you need. You'll be building your apps using Android Studio, which is available at no cost to you and can be downloaded from developer.android.com. If you want some help in setting it up, check out the Android Fundamentals course at the url below. To build applications that use Google Play services, you need a development environment. And to install the development environment there's two main things that you'd need. First, is Android studio. You can download Android studio from the developer.google.com site. When you install Android studio, you get the ability to use the Android SDK Manager, that you can see here. And using the Android SDK Manager, you should install the Google Play Services SDK. You'll see it as an item on the list, under extras, near the bottom of the screen. Make sure that you install the most recent version of this. I would also recommend that you take a look at the Android Fundamentals courses offered by Udacity. There are two of them at the moment, and I strongly recommend that you at least take the first. And it's really not a bad idea to take the second as well. These will give you a head start in Android development and teach you many of the concepts that we'll be covering in this course. Here you can see that I'm running a very simple app that I've called LocationLesson1. You build this application using Location Services and the techniques that you'll use for building this application can be used across many of the different services that you'll learn in this course. So, how did we get here and how did we build this? Let's take a quick look. So, to build an app like this one for location services and many of the other services that you'll be encountering in this course, you're going to do the following steps. First of all, the easiest way to get started is to create a new app using a Blank Activity in Android Studio. Once you've done this, you'll edit the build.gradle to add the services libraries. You'll using something like this, but the version number may change. Then, you'll edit AndroidManifest.xml, to tell your application that you're using these services libraries, and the particular version that you're using. When you put this value, integer Google Play services version. When you do a gradle sync, the correct version number will be put in for you. So it's good just to use this string. And then finally, in AndroidManifest.xml you're probably going to be adding a bunch of permissions as well. In this case I was doing location so you see I set users permission for access_fine_location. Depending on the activity or depending on the type of application that you're building, you'll be putting different permissions in here. When building an app that uses the Google services, you'll generally use an Asynchronous Programing Model that looks a little bit like this. In the onCreate of your activity, you create a Google API client. And then in the onStart of your activity, you connect that Google API client to the relevant APIs. In this case Location Services. In order to use this, you're going to need to override a number of different methods. One is OnConnectionFailed, which the services will call whenever the connection drops and you need to handle what to do. Generally just reconnecting. One is OnConnectionSuspended, which is very similar to OnConnectionFailed and will be called if the connection gets suspended but not necessarily broken. And you might want to cache some information. When you succeed in making a connection to Location Services, Location services calls back to OnConnected, telling you that you're now connected to the services. And in the case of something like location, you'll then create a LocationRequest. They had passed to Location Services to get your location details back. And it would call you back with OnLocationChanged, letting you know that your location request details have changed, and there's new location information available to you. And you'll get a Location object, which you can then use to write to your screen. So in the application that we just saw, that location object included a latitude, and I was able to update my screen and write the latitude to it. Now this programming model isn't just limited to location services. As I've said, many of the services that you'll be using during this course follow a very similar programming model to this. You're going to have an OnCreate and an OnStart. You're going to have a GoogleApiClient that you connect to the services that you want to use. And then you have to handle certain overrides. Usually, they'll be OnConnectionFailed, OnConnectionSuspended, OnConnected, and then an override that's specific to the services that you're using. In this case, it's OnLocationChanged for location services. Don't worry if you don't know all of these by now. Take the best guess that you can and by the time you finish this course, this will hopefully be second nature to you. So first of all, you'll create a blank that uses your desired API. What do you think that would be? Secondly, you extend your activity with the blank call backs. Which call backs do you think they would be? Third, you also extend your activity with the blank listener in case the connection fails. And then, finally, after connecting the blank, you'll wait for the blank callback. What do you think these will be I'll give you a clue. The answer in one and the beginning of four are the same. And which callback do you think you'll be waiting for when you connect to the services? Once you've done all of this, you'd then follow the requirements of your specific API. Fill out the blanks and then continue. So the correct answers are here. First of all, you'll create a Google API client that uses your desired API. In the example I showed earlier, I was using the location services API with a Google API client. With others, you may be doing login, you may be doing maps, you may be doing other things, but you'll still be using a GoogleApiClient for that. You'll next extend your activity with the ConnectionCallbacks. These are the heart of the asynchronous programming model, where the services can call you back whenever something important happens. You'll also need to extend your activity with the OnConnectionFailedListener. In case the connection fails, so that you can handle it gracefully. And then, finally, after connecting the GoogleApiClient that you created earlier on, you wait for the onConnected callback. Once you get the onConnected callback, you know that your ApiClient is connected to the services. And you're able to make the calls on those services. And then once you've done that, you can follow the requirements of your specific API. Like for example, as you saw earlier on, I was doing location work, so I also had an on location changed method, that was firing whenever the location changed, as a result of the location request. You'll see all of this in much more detail in the location services module, as well as all of the other modules. This sequence will be used in every app that you build and you'll want to be sure that you know it as you move through the rest of the class. Since this sequence is so important, take some time to think of a good way to remember these steps and then maybe go post in the forum about it. Also take some time to read what other people have said. You might find a methodology that works for you. Some APIs will also require you to set up credentials and access using the Google Developers Console. For example, in the maps course, you'll need to enable your map to use the maps API. And if you look here on the left, there's APIs & auth. When I select that, and I select APIs, and then I select enabled APIs, you can see the APIs that I've enabled. And one of the map apps that I build, I'm using here the Google Maps Android API version 2. You'll also need credentials for some of your apps. So for sign in maps, and some of the others, the system needs to know which apps are using which resources, and as a result credentials need to be enabled. And here you can see I've selected credentials. And here you can see I've generated an API key for the apps that I've built that are using Maps. As you need them, you'll be stepped through everything that you need to do on the Google Developer's Console in the lessons, but it's good to have a look at it. Go to console.developers.google.com and have a play around. You've now gotten everything you need to get started with building Android apps that use Google Services. The API's that you've installed, give you access to all of this functionality. And they give it to you in a consistent way. Remember that Google API client that you saw for accessing your location? It's the same object, and very similar code to what you'd use to access Google+ or Maps or Wallet or Drive. You can learn these in any order you like. But the most important thing is to get started and to get coding. So, you'll see just how easily you can harness all this goodness. You should go and take the location module first, because many of the concepts you'll need for the others are covered there. Let's go. Maps, everybody uses them and many people love them. Maps on mobile devices like this one have changed the world over the last few years. It's not that long ago you had to carry a paper map of any location you weren't familiar with. Or like me, as soon as you arrive at an airport, you'd study the route to the hotel, memorizing it so you wouldn't have to stop in a strange place and unfold a large piece of paper to figure out where you were going. Mobile maps not only provide a local map in your pocket, but also a map of the entire world down to street level. They also include cool things such as a view of the street as if you were there or a 3D fly-around of many major cities. There are so many ways that maps can help you build a better app. Maybe you have a business and you want to direct people to that business. Why not build an app that provides navigation to your business from where they are using location services that you can learn in one of our modules? Or maybe you want to create a treasure hunt game, or plant a geocache. You can even do this virtually, where instead of hiding objects in the real world, you put them in the virtual world, with pins on a map that your users will then have to find. There are far more scenarios than I can think of and I bet you have a few doozies of your own. In this lesson, you'll learn all about Google Maps and how you can build them into your android apps. Here's a very simple app that has a map embedded within it. It doesn't have visual controls along the map that allow me to do things such as zoom in and out. But I can actually pinch the map if I want to zoom. Here you can see I'm zooming in, and here you can see I'm zooming out. It also has data such as country names, you can see here the United States country name as well as the states in the United States and cities. And also here we can see Mexico is a country name. So a lot of the data is already available on this map for me and I'll show shortly how I built this and it was very, very simple, very straightforward, and effectively getting all of this data for free. If I zoom in on a specific location, like right now I'm going to zoom in on the Silicon Valley area, and we begin to see town names. And if I get in even closer we'll begin to see street names. Here you can see West El Camino Real. We can see Latham Street. This is right here where I'm recording, and if I zoom even closer we'll begin to see individual buildings. And here we can see buildings appearing. Across the road from here is a shopping mall. And, actually some building when, I zoom right into them, I begin to see some of the details of the interior of the building. So here we can see I have a department store very close to me, and I'm beginning to see the sections within the department store Including the fact that they put the bakery right beside the intimate apparel. Now, all of this data came with the maps without me having to write anything. I just added the map to an Android app with a default customization. It's very, very simple to do. And in the next few minutes, you're actually going to build this exact app, and it will give you the foundation for building much more complex and interesting mapping apps later in this course. So let's get started. Before you can do any mapping applications, you need to get a key that gives you access to the google maps android API. This is pretty easy to do, but it involves taking a few steps out of Android studio for the time being. You're going to be working in terminal. So as you can see, I've opened my terminal here. The first thing you need is the SHA1 fingerprint for your app. Google maps uses this as a way to identify your application, so it can give your app good service. This fingerprint is a machine readable attribute of a certificate and a certificate is a way of determining that your app is real. Just like in the real world, a certificate is a sign of an authority, where you can call upon a third party to certify that you are who you say you are. Now we're just going to use a debug certificate for this as it's easier for learning purposes. The debug certificate is issued to you by yourself. Now later, if you want to release your app to the play store, you'll need a publication certificate which is verified by Google. If you want to do that, follow the instructions on the developer website linked below. The first thing that you'll need to do is to locate your key store file for debugging using the terminal. It's called, imaginatively enough, debug.keystore. On a Mac or Linux, it's at cd ~/.android. So note that when you put a dot in front of a folder like this it's usually hidden so just know that you may need to unhide it. If you're using Windows it'll be at c:/user/ your user name /.android. Remember it could also be hidden on windows. This is the directory that contains the debug.keystore nad I can use this to get the fingerprint. And I'll show you how to do that next. The command to get the certificate is the keytool command. And the keytool command, you tell it your keystore. And you can see the keystore location is .android/debug.keystore. You also just give it an alias. I'm calling it the androiddebugkey. And the password and username is just android when you're using debug. So, when I press Enter, you'll see my SHA key is listed in the certificate. The certificate fingerprints are here, MD5, SHA1, and SHA256. So, just keep track of the SHA1 key. I would just recommend leaving the terminal window open because you will be needing that data in a moment. So take a moment now to get the SHA1 fingerprint from your debug certificate. Remember, you're going to have to find your .android directory for your platform. And then you're going to run the keytool command. And the keytool command is run with the following parameters. -list, -v, -keystore, with the location of your keystore that you found. It may change based on your operating system. You saw how I did it for the Mac. -Alias android debug key -storepass android,-keypass android. Once you've run this, take a look at your SHA1 key and make sure you make a copy of it or leave your terminal window open. When you're done, check this box. Wonderful, this is something that you'll use to setup your projects credentials in the Google developer console. It's also a very useful skill because you're going to use it for other APIs too. Now that you have you have your SHA1 fingerprint, let's take a moment to go over the four steps that you'll need to take to set up maps. In order, the first thing that you'll do is to set up billing for your account. Then you're going to create a project, then you're going to enable maps on that project, and finally, you're going to set up the credentials. Once you've gone through this process once, you wont have to set up billing again. You only do it once for all the applications under a single project. But for future apps you may have to do some of the last three steps. The Google Developers Console is an online resource that helps you manage the data that comes in through various Google APIs. When using Google Services it is required, in many cases, for you to set up a project here. Now when you visit it you'll see all of your projects. And I have quite a few here but I'm going to add a new one to this app. Of course you'll have a different list or you may not have any yet. But before I create a new app I'm going to set up billing. While the vast majority of functionality doesn't carry a cost, you still need to set up billing because under your project you could have things that are charged such as, App engine, or cloud storage or things like that. So in order to create a new project, you do need to have billing. So when you set up billing, if your only going to be using maps don't worry your never going to get billed for using the maps because maps functionality and Android has no cost. In the developer console, when you create a billing account, there are a number of steps that you need to go through. The first is to name the account. And then later on when you're creating your project, you'll pick the billing account based on its name. Then you have to specify the country for the account and where the account resides. Payer details are going to be linked to this country. So be sure to pick the right one. Then you just pick the account type. You might be paying as a business or you might be paying as an individual. You just pick which one. Next comes the payer details. And that's just the name and address of the payer. And then finally there's the payment type. And this is going to be a credit card or bank details. And depending on which one you pick, you have to configure it. It's as simple as that. Once you've filled out this form with all of these details and submit it, it will take a few moments. But then billing will be available and you'll be able to create a project and select the billing profile that you've just set up. So once you've set up the billing account, it's time to create a new project using the Create Project button. Enter the human friendly name for your application. I'm just going to call it My First Map. Then you enter the project ID. This ID needs to be unique across all of Google's infrastructure, so you'll need to get specific here. As you can see, I've just called it udacityfirstmap1, because this isn't taken and it's available. Then you select the billing account that' you're going to use, and if you remember when you're setting up the billing account, you gave a profile name, and I have a profile that I call My Cloud Project, and I'm just billing based off of that. Then you just click Create. As you can see, it will take a few moments creating. But when it's done, you'll be taken to the project dashboard. Now you can see I'm on the project dashboard. So the first thing that I want to do to enable maps, is to go to APIs off, then select APIs. And here's a number of APIs that are available to me. But we can see there are Google Maps APIs here. So I'm going to go to the Google Maps Android API and I'm going to enable it. Now that it's enabled, the final step is to set up the credentials. Over here I can click on the credentials link, then under public API access, I'll create a new key. When it asks what type of key, I'm going to select Android key because I'm building an Android app. It will give me a dialogue asking me for the SHA1 that I got earlier, followed by the name of my app. Because I'm not deploying this app, or doing anything with it that would require the certificates to check, the restrictions are much looser. And one of these is that the name doesn't really matter. But I am going to use the fully qualified name of my app. The SHA fingerprint is what we got in terminal earlier on. Let's take a look at that. Here you can see my SHA1 key. So I'm just going to copy all of that, and then I'm going to put a semi-colon, and after the semi-colon I'm going to put the name of my app. In this case, it's com.google.devplat.lmoroni.firstmap. Don't worry if you need to change the name. You can do this later with the edit allowed android applications button. But, I'll just create for now. And we can see that my key is listed here. And if I wanted to change my name, I just say, Edit, allowed Android applications. And I can go ahead and change the name. The API key is listed at the top. Make a copy of that, or keep the console open, because you'll be needing that in the next step. Take some time now and go through these steps to create and set up your project. Again, the steps that you will need to follow are first you got to set up billing. Maps on Android doesn't occur any charges, but you still need to set up billing in order to create a new project. Two, you create the project. Once the project is created, you will then get access to the project console. And on the project console, you can enable the Maps API. And then once you've enabled the Maps API, you set up credentials and you use your SHA-1 and your application name in order to generate an API key for that application. Go through these steps now and check this box when you're done. Great. Now that you set up the project you're actually ready to build your first app. Now we'll start building the app itself. First, take some time to create a single blank activity app. There is a mapping template available that you might want to make use of later but, in order to learn the ins and outs of mapping, let's create one from first principles. Next, you want to edit your build up gradle in the usual way. In your Android manifest there's a few things that you'll need to set up. First of all is the meta data with the references for Google services, just like in Build.gradle. Then there's the meta for the API key. Now you created the API key in the developer console earlier on, and you need to put the API key as a meta tag in your Android manifest. To see where you do that, take a look at the developer documentation, or we'll show you the answer in the next node. You're also going to need permissions for internet, network state, and write external storage. And then finally you're going to need a mega tag for OpenGL, as well. Now most of this should be review to you, but we've linked some Documentation in OpenGL and the API key metadata tag in the instructor notes below. When you've done all of this and you're ready to go, you've added each piece to your manifest, you've edited your Build.gradle, check this box. So the first step in what you had to do was to modify your build.gradle file. And as you can see here, I've done this by adding the Google Play services libraries. I'm just using 6.5.+, but as we spoke about in earlier sessions, you should always make sure that you're using the most recent version. And use the full number, don't use a plus. But I'm just putting plus in here for ease of use. Next, you have to edit your AndroidManifest file, and you can see that here. So, if I double click on that, and open it, I can see my AndroidManifest file and the details in it. Now, there are a number of things that needed to be added. The first thing that you had to add was the ability to use OpenGL. And, as you can see, I'm using OpenGL here with the users feature tag. android:glEsVersion=0x002000 and required=true. So this gets added onto the manifest tag above the application tag. The second thing that you wanted to add within the application tag was metadata saying that you're using the play_services libraries. Here you can see Android name equals Com Google Android GMS version. Android value equals ad integer of Google Play Services version. So these are the same tags that you've been adding to be able to use the services libraries throughout this course. The next tag here is the metadata for your API key. And the API key is what you created in the Google Developers console earlier on. Here you can see I've added the API key, and just the values that I was able to get form my API console I put into the Android value tag for com.google.android.maps.v2_.API_KEY. So you've added the OpenGL, you've added the Google Play services libraries and you've added your API key. The final thing that you need to add to your Android manifest are the users' permission tags, and here you can see them. So users' permission for android.permission.internet, android.permission.accesssnetworkstate, and androidpermission.writeexternalstorage. So, once you've added all of these, your android manifest is good to go. Your build gradle is done and you're now ready to add the map to your application. The user interface for your app is to find an activity_main.xml. We're going to add a map fragment to our app using this code. As you can see, it is a fragment, and it is using com.google.android.gms.maps.MapFragment. It's not really doing much more other than that. We're just adding a fragment, matching it to the parent's layout and using, like I said, this map fragment to find it. Take a moment now to take this code and add it to your app with an activity_main.xml. Check this box when you're done. In the previous example you got a map into your app without writing a single line of Java code. Now wasn't that cool? You did it by using an XML based description of the map in a fragment. Because this is XML, you can use properties to set up your map without using any code. So, for example, by setting a few properties we can create a map that shows us a flyover of New York City. Let's give it a shot. With the basic app you've just built, you can configure the initial state of the map in a number of ways. For documentation on all of the ways you can configure it, using XML attributes, look in the instructor notes below. But for now we'll configure a few attributes to show something interesting. So here's the layout that you had just created with your fragment containing the maps fragment. And this gave you the default Google maps that you've been using throughout. But what we're going to do is we're going to change this. So we're going to take a look at New York City with a flyover type view. So first of all, there's going to be a number of attributes on the fragment that we're going to need to set. And we're going to do these using the Maps namespace. So we need to tell the XML about the Maps namespace first. So I'm going to do that up here. And you see, we have XML namespace tool equals this. We're going to create a new XML namespace for our map. And here are the details for the XML namespace for map. As you can see, xmlns:map is equal to http://schemas.android.com/apk/res-au- to/. So this will give us the map attributes that we can now add to our fragment. Map attributes will consist of things such as the latitude and the longitude of what you want to look at. So the latitude and longitude of the area in New York City we're going to look at a la now. Here you can see, I've added the map camera target latitude and map camera target longitude. Don't worry about the red underlines on them at the moment. Now, when you're looking at a map, you actually look at a map through a virtual camera. So you tell the camera the target latitude and longitude that it's going to look at. So the latitude of downtown New York City is 40.7484 and the longitude is negative 73.9857. But what this is going to do is, if you remember when you first run the map, you had a view from high in orbit looking down on the Earth. And this will do that, but it will be looking down on New York City. But all it's going to do is shift the camera. >From being high in orbit looking down on the equator to being high in orbit looking down on New York City. So we also want to move the camera so we zoom down onto New York City. And we'll change a couple of things. I'm going to add them and then talk through them one by one. So these are the three attributes that I've added. The first is the Camera-Bearing. The Camera-Bearing is the direction that the camera is looking at, with zero degrees being looking north, 180 degrees being looking south. So as a result, you can see I'm looking at 112.5 degrees, so I'm kind of looking east with my camera bearing. Next is going to be the camera tilt, so if you can imagine the camera when it's looking straight down, it's going to be tilted at 90 degrees. But if I can change that to 65 degrees, then the camera is going to be appearing somewhat at an angle looking down, so we have a nice 3-D isometric view of the world beneath us. And then finally is the Camera ZOOM. The larger the number, the closer you are to the surface of the Earth. So if you can imagine a Camera ZOOM 0, that's what we've had all along, where the camera is way up. Looking down on the Earth. But with a Camera ZOOM 17, I'm going down really close to the Earth. And as you'll see, because I've got a camera tilt of 65 degrees, I'm getting a 3D view of the skyscrapers in New York City. And with the Camera ZOOM being 17, I'm actually lower than the level of some of these skyscrapers. So, let's run the application and see what it looks like. So, now here we see the application running on my tablet. It gives us a view of downtown New York, and I can actually scroll around and see the city in three dimensions. So I can see some of the skyscrapers that are cylindrical in shape. And as we had an earlier on, we were actually looking the base of the Empire State Building, and here you can see the Empire State Building rising out of the view of the camera. Because the camera is actually lower than the height of the building. And as I zoom around New York City and I pan around, we can take a look at some of the interesting features in some of the buildings. For example, here is the United Nations headquarters, overlooking the river. Here are things like some of the islands in the river itself, and we can see the skyscrapers on them. Sometimes, it takes a little while for them to show up. So you've effectively gotten all of this for free, you didn't need to set up anything to get the 3D views or anything like that. Just basically by the fact that you tilted the camera and were close enough into the earth, to be able to see the 3D views. If I were to zoom out you'll see, I'm just going to see now a pan-view of New York City without the 3D. As I zoom out, you can see we were facing towards the East, looking out over Long Island. When I zoom in over the city again, once I get close enough we'll start seeing the buildings and the skyscrapers popping up. And there they are. Pretty simple, just all of this was done just by setting attributes on the map fragment. Pretty cool, right? Take a moment now to find the latitude and longitude of an interesting place like maybe your home town and make an app that sets the initial location of the map to those coordinates. Feel free to play around with some of the other map attributes too. You could post a screenshot of your app in the forum. You can find latitude and longitude for a location in Google Maps by looking at its URL field, or you can drop a pin onto your map and you'll see the latitude and longitude right there. Awesome. There were a lot of attributes that you can configure by XML, and it's important to understand them. I would also suggest taking some time to look around the forums and try and write some code to start your map in one of the location, and configurations someone else has chosen. They may have found something really cool. We saw earlier that we could add a map fragment or a layout file and set properties on it to get some pretty interesting and cool maps. We even had a 3D fly over of New York city that was pretty cool right? Well that just scratches the surface of the types of app that you can build with map integration. The XML based maps always start in the same location and that can be limiting for a mobile app. So in order to get a little more power and flexibility, we're going to switch gears and start using the Google Map objects to compliment the map fragment using Java code. Once we've gotten that, it then becomes really easy to set properties and respond to user events on the map. Let's start with an example where we set the different map types such as the standard map, the satellite view or the hybrid view. In this app, you can see a map of New York City. And I have control over this map by touch. I can panoram the map, and as you can see, I can pinch to zoom in and out. When I press the buttons at the top of the map, Map, Satellite and Hybrid, I can change the map type. So if I touch Satellite, I now can see details of the buildings taken from Satellite images. Here you can see Madison Square Garden and even when I zoom in I can begin to see some of the seating plans in Madison Square Garden. And of course Hybrid gives me a hybrid of the two. I can see satellite but I can also see data such as landmarks like the Empire State Building and street names such as Fifth Avenue, as you can see here. I've done all of this using a Google map object in my Java code. This is slightly different from the fragment that you used in the earlier sample. And we're going to dive in to take a look at how to do this next. So, first things first. You'll need to create a new app and set it up in the same ways you set up the last app. That means you'll need to go through these steps again. So first, you'll create a new app with a single view. Then, you'll add the services libraries to Build.gradle. Then, you'll edit your Android.manifest by putting the services libraries, the open GL stuff, the API key, and the internet, network state, and write external storage permissions. Check that you've done each of these, and if you need to review how to do this, refer to the answer video for creating and configuring the app earlier in the lesson, where we showed a simple fragment. When you're done with all of that, check this box to continue. Okay so if you've followed all the previous steps correctly you're going to end up with source code that looks like this. First of all in your build.gradle file you should see the entry here for those services libraries, as we've discussed and as we've been using all along. Next in your AndroidManifest file you should see a number of things. First, you can see where I've added the OpenGL libraries. Second, you can see where the service libraries have been added and it's the same as you've been doing all along when building applications that use the services. Third is the API key. And if you remember from the early example you created API key and you were able to put the API key in your meta data as shown here. Now before you run this application, you have to associate this application with the same API key in the developer's console, and I'll show that in a moment. And then finally is the user's permissions. As you can see here, we have INTERNET, ACCESS_NETWORK_STATE, and WRITE_EXTERNAL_STORAGE setup. If you recall when we looked at the application, we had three buttons across the top of the screen, and we had the map fragment itself underneath them. And the basic UI that Android Studio created for us had a single text view. So delete that and replace it with the layout code that's in the instructor notes. This is made up of a LinearLayout which is set to be in vertical orientation. And within this LinearLayout I then have another LinearLayout at the top which contains the three buttons. And as you can see my three buttons are Button Map, Button Satellite, and Button Hybrid. And then underneath this LinearLayout for the buttons is the fragment itself containing the map fragment similar to what we've been doing earlier on. So I have a linear layout putting the buttons on top and the map underneath. And then the second linear layout within the first has the buttons horizontally stacked side by side, as you can see here. So now if I run the application you'll see I have the basic map with the three buttons. They won't do anything yet, because I haven't written the code behind them. Try it out yourself, see what happens, and check your error log for details. Typically if you have problems it's the API key hasn't been setup properly. And after we wire up the buttons we'll take a look at how to do that. Now, once you've setup the layout of the app, it's time to take a moment to talk about what's actually happening in the final app. If you remember, we have the map on the screen, which is somehow modified by pressing the buttons at the top. Now, thus far, we've learned how to make a map fragment and change that through user activity. But we haven't learned how to create a Google Map object, which is the thing that within code will be able to change the contents of the map fragment. So to do this there's a few things that we need. First of all, we'll need to implement the onMapReadyCallback. Now we'll do that by modifying the class declaration for our main activity to have this, so here I have my onMapReady which is just setting mapReady, a boolean ,to true, and then this local variable called m_map to map. And you notice here it passes back a Google Map, so my m_map, of course, is a local instance of a Google Map. And you can see I've defined it at the top of my activity here. And of course the activity itself has to implement the onMapReady callback. So, within our onMapReady, I'm just saying the mapReady is true. I'm loading my local instance of a map with the one that was sent back to me. I create a new lat-long, which I'm calling New York, with the latitude and longitude coordinates we used earlier on. Then I'm setting the camera position using a camera position builder. I'm targeting at New York, and I'm setting the zoom to 14, so it'll be a little bit further out than the one we saw earlier. And then on m map itself, now the map object, I can call the move camera on that to set its position to be this target. As you can see, it's pretty straight forward. And you can do other things like angling and zooming to different levels and different types of views that you want on the camera position itself, but here I've created a very basic camera position. So that's all that you really need to do to get your map set up for working within an application and having a handle on a map object that you can then program. And I'll show you in the next step how we then program that to allow to have satellite or height reviews. So now that you've written the callback, and you actually have a handle on a map object, the next thing to do is to write the code for the buttons. To do this, you're going to work in the onCreate function. And for each of the buttons, you're going to create an onClickListener. Within the onClickListener, a function that gets called, you're then going to set the mapType property of the GoogleMap to the relevant type of map that you want, based on the button. So, for example. If you want a hybrid map, you would set the mapType property of the GoogleMap, to the constant that defines a hybrid map. These types and these constants can actually be found on the GoogleMap object itself. Take a look at the documentation and you'll find them. When you're done creating all of this, check this box. So, here is what your completed code should look like. As you can see here, I've code for the Button Map object, the Button Satellite object, and the Button Hybrid object. For each of these, the process is the same. So, for the btnMap object, I findViewById, the button that I had called btnMap. And once I found that, I set its OnClickListener. And within its onClickListener, if the map is ready, then I am going to set the map type to be GoogleMap.MAP_TYPE_NORMAL. As I mentioned earlier on, you'll find the types within the GoogleMap object itself, and here you can see I am just saying GoogleMap.MAP_TYPE_NORMAL. Similarly for the satellite, I find the btnSatellite object. I set its OnClickListener, and within its OnClickListener, I set the MapType to be GoogleMap.MAP_TYPE_SATELLITE. And for the hybrid, I do the same thing, findViewById. I get the btnHybrid. I load it into this button called btnHybrid. And then I set its OnClickListener. And if the map is ready, then it will set it to be a MAP_TYPE_HYBRID. It's as simple as that. And then one final thing to add is, just remember, mapFragment. You're going to get the actual fragment. And you're going to get an Async map for this mapFragment. And this is all the code that you need to be able to create the application that we've just seen. So now I can run my app but it's probably not going to work because I haven't set up the API key. The next thing that you should do is to go to the Google console and then based on the name of the app, like in this case you can see my app is at com.google.devplat.lmoroney.maps3_2. I need to set that up within the API console. So if you remember in the earlier lesson, when we created public API access, we had an API key and we had Android applications that were allowed to use that API key and these were defined by the SHA 1, in this case the debug one. Followed by a semi-colon, followed by the name of the application. Now you can see here I've done the same thing, the same SHA 1. And now this application, com.google.devplat.lmoroney.maps3_2. This is the most common place you go wrong in writing applications and creating them. Is that either you've named this incorrectly, you've made a mistake with the SHA 1 key, your API key is wrong or something along those lines. So if you this API key beginning with Alza and ending with d or z8, if I go back to Android Studio and go to my Android manifest, you can see I have, it was Aiza. Sorry, not Alza. You can see I have the API key set up here correctly and it's definitely the same name application com.google.devplat.lmaroney.maps3_2. A little pro tip is if you ever refactor it, and you'll think you've refactored and you've gotten everything changed if you refactor the name of your package and you'll find that maps don't actually work. What can happen is that while your refactor it and while you've changed it on the console in refactoring in buildup Gradle the application id string here may not change. So if you ever refactor your app and find trouble, just make sure to come back into your buildup Gradle and make sure that the string here with an application ID matches the refactoring that you've done. So let's now run the application and take a look. And here it is again. Here's the application running. You can see I'm centered on New York City. I have my three buttons laid out across the top. Remember, that was the horizontal layout. And then the entire thing is in a vertical layout with the button panel on top of the actual map fragment and of course I can continue to pan and zoom around the map if I so desire. And when I press the buttons, for example the hybrid button, I now get a hybrid map, which you'll see more closely if I zoom in, so you can see the street names were highlighted and the streets themselves were highlighted. And when I press the buttons for example, the hybrid button, I now get a hybrid map, which you'll see more closely if I zoom in. So I have the satellite photographic map, but with the lines of roads and things laid out on top of it, which is really, really useful when you're navigating around places. Or if I just want the pure satellite picture, here it is. So it was as simple as that. Very little coding and you're beginning to see that you can build some pretty powerful functionality. You've just built your first Android App that renders Google Maps. You've learned how to create a map fragment in the UI and have that initialize Maps for you. You also learned the beginnings of how to get and use the Google map object to allow users to change the map while the app is running. You've just begun to scratch the surface of what's possible with Maps in your Android apps. Are you ready for more? Great. Let's go deeper. Up to now you've built your first mapping applications where you saw how to set up the Google Maps API and integrate and authenticated map into your application. You saw the map fragment and user interface. And you saw how to use that to get a Google Map object that you could then manipulate and code. In the last lesson we modified a lot of properties of the map. And it's often helpful to think of them as being properties of a camera floating over the landscape. You could look at it as the cameras on an aircraft that's flying over the map. So as well as setting latitude and longitude of the location you want to look at. There's also cool stuff like setting the direction of the cameras looking in and the angle at which it looks at the map. The camera doesn't always have to point straight down as well as having the ability to animate the movement of the camera giving the impression of flying over a landscape. In this last end, we'll do a lot of work with the camera. And we'll see how it can be used to build better maps for your apps When using maps in your application the map fragment provides a view over the map, based on the specifications defined on your camera. If you don't define a camera you just get a view of the entire world over latitude zero and longitude zero. Understanding the camera is the key to understanding your app. The camera is controlled using a class called CameraPosition. The properties that define your camera are the targets. And this is the latitude and longitude that you want to point the camera at. This lat long will define the center of your map. And how much of the map you see is determined by the zoom. This is a value from zero, the furthest out effectively showing the whole world, down to 21, which is really close to street level. You can get in even closer by using Street View, and you'll see that in a later lesson. Bearing is a property, and this determines the direction that the camera is facing. It's specified in degrees clockwise from north. So if you want the camera to be facing east, the bearing would be 90 degrees. If you wanted to face northwest, the bearing would be 315 degrees. Tilt is how much the camera is tilted by. By default, this is zero which means the camera is facing directly down towards the ground. You can increase this with the upper bound determined by how far zoomed out you are. So, for example, if you're zoomed out really far the maximum tilt that you could do is 30 degrees. As you get closer to the Earth, the maximum tilt goes up. With a maximum of 67.5 degrees. You can just see tilt as how the camera is tilted toward the ground, you're looking straight down at the ground, or you're tilted at the ground so you can get a 3D isometric style view. Like you had with the skyscrapers earlier on. In code, to create a camera position, you use a CameraPosition.builder. This builder takes the properties that you've just seen, such as the target, which is the latitude and longitude. The zoom that you want, how far you want to be zoomed into the map. The baring of the camera, the direction that it's pointing in and the tilt of the camera. When you've set all of these properties and you build it, you'll then get a camera position and I've just called it cp here. Then if you want to instantaneously update the map to show the location that the camera is pointing at with these values, you call map.movecamera and you pass it, a camera update factory.newcameraposition with that camera position that you've just defined. Like I said, this will instantaneously move the map to that location. But you may also want to animate the map to that position where you'll see a flyover type effect where you'll fly to the new location. And to do this, you'll use animateCamera. And animateCamera takes the same CameraUpdateFactory.newCameraPosition ith your camera position, but it also has a couple of extra parameters. One is the time in milliseconds that you wanted to take to fly to the new location. Of course you might want to zip over there really quickly or you might want to slow pan up over the Earth and down to the new location. You'd specify the time in milliseconds here. So if you wanted to take five seconds, you'd put 5,000 milliseconds in here. And the callback function gets called when the animation is complete. So if you want to execute some code once the animation is done, you could put it in that callback function. If you don't want to use a callback function, you can just put a null here. Let's take a look at an animated camera in action. This app was built using the animate camera method that you saw in the previous video. Note that it has three buttons, just like in a previous application that you built, and each of these buttons animates map movement to a different location. So, for example, I'm now looking at a map of the United States, but if I tap on Seattle you see the camera is going to animate. As I zoom into Seattle, taking a few seconds to do so. It's a really cool effect. So once I'm in on Seattle, there you can see some of Seattle, including, you can even see here an indoor map of the Pacific Science Center in Seattle. I can for example then touch on Tokyo. And you'll see I'll fly up and out into orbit, and then back down over the Pacific until I land on Tokyo, like so. And again, you can see I'm now in downtown Tokyo. And if I so desire, I can also go to Dublin. Now here there's a case of I haven't pre-cached some of these tiles, so you're just seeing blank as it's flying over. And it'll soon land on Dublin. So if I zoom out of Dublin, you can see those tiles are getting cached. So none of these tiles were pre-cached for testing the video, and that's why we couldn't see when we flew from Tokyo to Dublin. If I just zoom out and effectively cache the tiles, I'm not doing anything myself to cache them. This is just how the application is running. And so the map fragment itself will cache the tiles for you. So here you can see Japan, and if I go back somewhere over Ireland and now I tap on Tokyo, you'll see that the orbit will change, and I'll drop down onto Tokyo. And now if I try to go to Dublin, you'll see I fly out of Japan, up over the surface of the Earth, over Asia, over China, back over western Europe before dropping down and onto Dublin. So you know have everything you need to build this application yourself. You've all the tools. Why don't you give it a shot? If you have any trouble, the source code is linked to the speaker nodes. Here's a few latitudes and longitudes that you can use when you're building your app. The Seattle latitude and longitude I used is this one. The Dublin one that I used is this one, and I've added a new one here for New York. So if you prefer to zoom in on New York instead of Tokyo, here's the latitude and longitude for that. Or if you want to use Tokyo, see if you can remember the technique that I showed in an earlier video on how to get latitude and longitude for yourself. When you're done building the application, check this box. This app was built in a very similar way to the demo that switched map types that you saw earlier on. If you aren't familiar with the layout in Gradle and manifest configurations, check back to that video. But I'm going to show them a little bit here. First, you can see in my bill.gradlel file I've added the Services library that gives me access to the Maps SDK. Then, in Android manifest, I've added my open GL stuff. And I've added the uses-permission stuff for INTERNET, ACCESS_NETWORK_STATE, and WRITE_EXTERNAL_STORAGE. I've also added the metadata for the Services libraries here. And then finally, I've added the API key configuration here. Now, remember, every time you create a new application on Maps, you're going to configure the API key on your Google developers console. So for example as you can see here, here's my API key that I'm using in the application. And because I've called my map com.google.devplan.almarone.maps33, I also have to have a setting for it in the Android applications, using the SHA1 key for my debug certificate followed by a semi colon, followed by the app name. So, you should see a list of them here, and if you recall the apps that we've been building as we go along in the course, I've been adding them here. And that's why they're actually working. Okay, let's take a look at the layout next. And here you can see in the layout, I've done the same as I did in the earlier application. I have a vertical linear layout, and the first child of that is a horizontal linear layout. This horizontal linear layout contains three buttons. These buttons are button Seattle, button Tokyo, and button Dublin. I've just set their text to be the names of the cities, I've hard coded the text in this case it might make more sense to put that into a string XML in a real application. And then the second child is the end of the horizontal linear layout, so the second child of the vertical linear layout course is the maps fragment, and here's just the standard maps fragment setting. Where it's a com.google.android.gms.maps.MapFragment. So as you can see, the layout is virtually identical to the layout we had earlier on in the application that allowed you to switch the different map types. Now let's take a look at the source code in the main activity. Here you can see the main activity, and I've created four camera positions, NEWYORK, SEATTLE, DUBLIN, and TOKYO. Of course, I'm only using Seattle, Dublin, and Tokyo. But I've put New York in here in case you want to build the application using New York. And here with the latitude and longitude that I had showed in the slides for New York, for Seattle, and for Dublin. And if you didn't find out you're on for Tokyo, here it is for you and this is available in the speaker notes, this source code. So these are constant camera positions that I've created for the names of the four cities. Then in my onCreate, I just wire the button handlers and I only have buttons for Seattle, Dublin, and Tokyo. So in each one of these on the onClick, I'm going to call this helper method that I wrote called flyTo, and it's flyTo the city name, so if you click the Seattle button, flyTo(SEATTLE). If you click the Dublin button, flyTo(DUBLIN). If you click the Tokyo button, you flyTo(TOKYO). And then to look at the flyTo helper method, you can see it here. And here's where I call the animateCamera. So on my map, I'm animating the camera, the CameraUpdateFactory.newCameraPosition(t- arget). Remember, a parameter passed into FlyTo is a CameraPosition target. So when I said flyTo(SEATTLE), I'm just flying to the camera position that I called Seattle. I'm taking 10 seconds to do it, which is the 10,000 milliseconds here. And then I'm just doing a null, so when the animation is complete, I'm not going to trigger anything. One thing to note with Android apps that use maps, as you saw when I demoed earlier, as the camera flies across the map, it doesn't slow down by downloading the tiles in between the cities, so sometimes you'll see emptiness when I manually panned around the map in the areas between the cities. Further transitions after that looked a lot cleaner because we were seeing places in between. Because while I manually panned, I was caching those tiles. Now that we have a good feeling for how maps work and we've seen how we build cameras to determine how we view the map, let's switch gears a little bit and talk about markers. I work with youth hockey in the Seattle area. And our league has a number of ice rinks where the kids play. So with that in mind, I decided to build a simple app that highlights all of the rinks on a map and here it is. As I move around the map, you can see pins for the different rinks. As I touch each pin, it highlights with the name of that particular arena. This is Kent Valley. This is the ShoWare Center. Or if I zoom up here, this is my home rink at Renton. I could, of course, put more information in here, such as an address, or even the dates that I need to be there for a game. But for now I'm just going to show the pins. Let's take a look at how to build an app like this one. The class that defines a marker is called the MarkerOptions class. With this you have a number of properties that you use to define your map marker. You can set its position using a LatLng, and, of course, the LatLng contains the latitude and longitude where you want the marker to be. And you can set its title using a string. As you saw earlier when I had my rinks for example, renton, all that was was a string called renton. And here is an example of building a marker option that does that. I say MarkerOptions renton equals new MarkerOptions.position, my latitude and longitude, I just pass it a new LatLng, with the latitude and longitude, and then the title("renton"). So this was the code that I used to generate that pin on renton that you saw in the application. As you can see, it's pretty straightforward. And when you have a map, you can add this to your map by calling the ad marker method on your map. Let's take a look at this in action in Android Studio. So here's a mapping app that I've already created. This one is identical to all the others that you've been using throughout this course. It has a single view and there's a map fragment on that view. The Gradle file is set up for the play-services libraries. And the manifest file is set up in the usual way with OpenGL, with the services libraries, with the API key, and with the permissions that I want to use, internet access network state and write external storage. And of course on my Google Developers Console, as I showed you earlier on, I've configured this API for access through that API key and the API key is here. Now let's take a look at the main activity. So in my main activity class I've just created a number of local variables of marker options type and I just named them after the various rinks, renton, kirkland, everett, lynnwood, montlake, kent and showare. I've also created a camera position that I called Seattle, which is just the default camera position that I'm using when the application actually launches. Then, in my uncreate function, I called the marker options in the way that I had demonstrated on the slide. So, for example, Renton is new marker options with the latitude and longitude of Renton and the title Renton. I was able to get the latitudes and longitudes for each of the rinks using the technique that I showed earlier on just using Google Maps, dropping a pin and reading the latitude and longitude from them. So I've set up all of my marker options for all of my rinks. And then in my onMapReady function, so remember the onMapReady callback gets called when the map is ready, because I've implemented onMapReady callback in my activity. So when the onMapReady gets called, I simply add all the markers to my maps so, m map dot add marker Renton and map dot add marker Kirkland, etcetera. I add them all and then I call fly to Seattle. And the flyTo function is very similar to the one you saw in the previous demo except this time I'm just moving the camera, I'm not animating it. So then I'm just going to fly to Seattle and I'm just going to jump into that location. I haven't put any flyTo to the particular rinks. The only time flyTo has been called in this application is right at the beginning, when I say flyTo(SEATTLE). And the only time that the flyTo function's called is, of course, in the on mapReady when I flyTo(SEATTLE). So that would just give me a default view, looking at Seattle in the location where we could see all of the rinks on the same map. So, I had moved the camera to the appropriate location to allow me to do that, and that was the camera that was defined as Seattle. As you can see here, with the latitude/longitude, zoom of 10, bearing of 0, so I'm looking straight down, and a tilt of 45 degrees. That was pretty simple, right? And in the next step here, you're actually going to build a custom marker, so you're not going to use the default marker pen. You can create your own marker, for example, a hockey player. But before we get to that, let's have a little quiz about using markers on maps. So which of the following are properties of a marker as defined by MarkerOptions? Position, latitude, title, or elevation? Check all the boxes that you believe apply. The correct answers are position and title. Position contains a LatLong object and that defines position for you, so you don't need a latitude. Title was the string that was used just as a friendly text to describe the actual marker and there's no elevation settings. Earlier we had code like this, where we say renton equals new MarkerOptions. We passed it a latitude and a longitude and we set the title as a string. Now this code set the position and title for the pin. But we can customize this further with another property which is the .icon property. Here's an example. Now you can see I have the same position I have the same title, but I'm now using the .icon property, and I'm setting that to a BitmapDescriptorFactory.fromResource. And as you may recall from Android fundamentals, when you use a BitmapDescriptorFactory.fromResource, you can then define a resource as an R.drawable. And I'm just using the basic R.drawable.ic_launcher. Which is the default icon that comes with Android Studio projects, and it's an icon of a little android himself. So just to keep things simple, I'm not adding a new icon to this application. I'm not adding a new icon to this sample, I'm just using one of the ones that is built in. You can, of course, add your own graphics as drawable resources and use them here, and in fact I would recommend it. Because using the little Android icon is a pain, as you'll see in a moment, isn't the most user friendly way of doing it. So if you've been following along, take a moment now to edit the hockey rinks program to add a custom marker. If you don't have one of your own, you can just do what I did, and use the R.drawable.ic_launcher and this will give you the little Android figure that you saw in the demo. Check this box when you're done. Here you can see how I've edited my onCreate where I had previously set up all of my different markers, renton, kirkland, everett, lynnwood, etc, by creating a new marker options and setting a position and a title. But now as well as the position and the title, I'm setting the dot icon. And the dot icon is set to bitmapdescreptorfactory.fromresource.R.- drawable.ic_launcher. If I was using a different icon, of course, I would just put the name of that icon here, but for simplicity I'm just using R.drawableic_launcher. And you can see it's on every one of these markers. And that's it. That's all I needed to do to create the custom markers. So if I've run the application you'll see what you saw earlier on, where instead of the standard Google Maps pin I had the little Android pin instead. And we you zoom in and out of the application the icon will scale automatically so that it's always appropriate. Now that we've seen markers for locations and how to customize them, let's look next at another great feature of Maps and that's the ability to actually draw on the map. You'll have a number of functions that will let you do this. We'll look into them next. So polylines are made up of a number of line segments that are drawn on a map. The end points of these line segments are defined using the latitude and longitude. Google Maps will then draw the correct line for you, based on the location of your camera, your zoom level, your bearing, and your tilt. It's smart enough to be able to do all of that for you. All you need to worry about, is the latitude and longitude of the end points of your line. Let's take a look at how to do that. So lets take a look at how to add a polyline to your map. Now a polyline is defined with the polylineoptions() .geodesic(true) and then you simple add a LatLng to that. You can stack these adds into a single column as you can see here. Where my PolylineOptions.geodesic(true), I just add LatLng, add another one, add another one and add another one. This makes your code a little bit easier to read and a little bit easier to manage. See if you can edit the hockey application so instead of pins for each rinks you have end points and a line segment. And as a result you would have a shape outlining where all the rinks are and the area contained within. So I'm just going to show how I added the polyline to the map with all my different ice rinks. So to draw the polyline, I set up the latitudes and longitudes for all the different ice rinks, Renton, Kirkland, Everett, Lynnwood, etc. And this time I'm just setting them as LatLng objects. Earlier they were marker options, but now they're just latitudes and longitudes. I set up my camera position to be exactly as I did in the earlier sample. Now in my onMapReady, I just move the camera to my camera position, which is Seattle. And then to draw the polyline I just call map.Polyline. It's a new Polyline object, geodesic true, and then I just add all of the latitudes and longitudes that I had created earlier, Renton, Kirkland, Everett, Lynnwood. Notice that I begin at Renton and I also add Renton at the end. And then this just closes the shape. Because what will happen when you draw a polyline is it will draw from Renton to Kirkland, from Kirkland to Everett, from Everett to Lynnwood, etc. So, if I want to close the shape, I just want to go back to the initial one at the end. And then I will get all my rinks drawn into a polygon like shape by adding a polyline. And this is what it will look like. Here you can see on my tablet I have the same map of Seattle, and I have all the endpoints of the different rinks. My home rink of Renton that I showed earlier on is the beginning and ending point, and then the polylines get drawn from Renton to other rinks. So for example, this is the rink in Kingsgate. You can see, Kingsgate highlighted there. Or I can go all the way the rink in Everett, etc. So, these are the polylines that I've drawn from me connecting the rinks. And because I just joined the last rink at ShoWare back to Renton in my code the shape gets completed. And as you can see here, my second last one was ShoWare. I then added Renton and the shape got completed. So my polyline actually became a polygon. You can actually also do a map.addPolygon and specify the endpoints and it will auto close it for you. So in addition to the polygon and the polyline, you can also draw a circle around a map around a particular area. You specify the center of the circle, using its latitude and longitude. You specify the radius of the circle in meters, and you can also specify the stroke color that's used to draw the circle, and the fill color that is used to fill the circle in. Try to add a circle to the hockey app now. Pick one of the rings and draw a circle around it. So as we saw earlier on, you specify the center point of the circle, and then its radius in meters. So here you can say I've set the .center of my circle. I just call map.addcircle a new circle options. And I set its center to be renton. And renton of course, is the latitude and longitude that we created earlier for the location of the rank and renton. I set a radius of 5,000, which means a 5 kilometer radius around the rank and renton. I've set the stroke color, which is the diameter of the circle will be drawn in this color, Color.GREEN. And then I've set using a fill color, using Color.argb. And you see I've set the A to be 64, which means it's going to be semi transparent. It's going to be slightly translucent. So, we can see the color, the 0, 255, 0, which is going to be green, but it's a partially transparent green. Now when I run the app, I'll actually see the circle projected properly, including taking into account the tilt and zoom of the camera. And it will be drawn on the surface of the earth. Let's take a look at that. So here you can see it, I have my green circle, my semi translucent one. So as I zoom in, you'll see that my stroke is green. You'll see that my circle is five kilometer radius around the renton ice rink. Because I've colored it with translucency, we can actually see through to the map underneath. And also because my camera is tilted a little bit, we can see that it's slightly oval in shape. I'm not looking straight down at 90 degrees to make it a circle. I'm tilted a little bit, because I'm looking somewhat up from the horizon direction, towards the Earth, and this part of Seattle. So there we can see it. The circle was added. Pretty straightforward. Pretty simple. Right? Of course if I rotate my map, the circle rotates with me. So it's all properly calculated for me and all properly drawn as a five kilometer radius circle around my home rank and renton. If you've ever used Google Maps, you may have noticed that not only can you zoom down to street level, but you can also see what the location looks like as if you were standing there looking around. This is called Street View. It's an incredible, immersive technology that allows you to explore the world without leaving your desk. If you think that's an exaggeration or over marketing, here's an example of street view that actually happened to me. As well as working for Google, I've authored a number of very popular young adult science fiction novels. Two of the locations that I have used in these novels are the town of Shiprock in the Navajo reservation in New Mexico, and the town of Kawatana just outside Nagasaki in Japan. I've never been to either place, but I've gotten fan mail from people who live in them asking me to say hi the next time I'm in town. I did all of my location research using Google Maps, and in particular Google Street View. The great news as an android developer, is that all of this imagery is available to you using Google's APIs. Let's take a look at a simple street View application that allows you to hike the Grand Canyon. Here's a simple Android app using street view to show a scene. As I move my finger around the display, you can see that I can look around this location. As I touch the arrows, you can see that I can walk along the trail. Similarly, if I touch in the far distance, I can jump to that location. This location is a hiking trail in the Grand Canyon. And as you can see, street view isn't limited to just streets. As I touch in the direction of the hike, I simply follow the path. This one actually goes all the way down to the bottom of the Grand Canyon. This virtual hike down the Grand Canyon was built using only a few lines of code. Let's take a look at how to build this for ourselves. So to build this app just get started with the typical steps that you would do. First you create a blank activity app, then you'll edit your Build.gradles at the services libraries. Then you'll edit your Android manifests with the meta keys for the services libraries. The metadata for your API key and don't forget to go onto the Google Developer's console. And add a new instance of the SHA1 followed by a semicolon followed by this app's name, so that it will be valid for that API key. You've seen how to do that before. Add permissions for Internet, network state, and write external storage. And then the meta for OpenGL. If you're not familiar with the meta for open GL there is a link in the speaker notes below but we also covered it in previous parts of this course. When you're done with all of this, check this box. So great, you've now created your application. So the next thing to do is to edit your layout. To do this, you're going to use a StreetViewPanoramaFragment. You can add a StreetViewPanoramaFragment to your layout.xml simply like this. You create a new fragment, and you give it this name, com.google.android.gms.maps.StreetViewP- anoramaFragment. Now over time this name may change because of refactoring of the code, so if this doesn't work for you, just check the latest documentation for, StreetViewPanoramaFragment, to see the package that it's in. Once you've done that, in the standard way, you give it a name. I've just called it streetViewPanorama. And you give it a width and a height. And for this application, I just matched the parent to them. So go ahead and edit your layout.xml now to add this fragment to it. So here we can see my app and a couple of the modifications that I've done. First of all, there's the AndroidManifest.xml. I've added the uses-feature for OpenGL. I've added the meta-data for the Google services. I've also added the meta-data For the API key. As I scroll across you can see API_KEY, and here's my API key that I got for the Google developers console. I can show in a moment where I configured the Google developers console for this app. I've set my permissions, and you can see them here, INTERNET, ACCESS_NETWORK, and WRITE_EXTERNAL_STORAGE. And that's pretty much it. It's very straightforward. In the Google developer's console, I can look at the Google developer's console. And if I click Edit allowed applications. And I scroll down. I have a number of applications that I've filled. But this one is called maps3_6. And I've just added the SHA1 key, followed by a semicolon, followed by the name of the application. And when I did that, I was given this API key, here. You can see it begins with AIza and ends with Drz8 and when I go back to my manifest file I can see that key is present right here, beginning with AIza ending with Drz8. So that's what I had to do to set up the application to run. Now in my activity. Now in my layout I've added a fragment. And it's typed com.google.android.gms.maps.StreetViewP- anorama. And I've called it streetviewpanorama, simply. So next we're going to update the code behind our main activity to handle this fragment and to draw the street view for us. To edit the activity, there are a number of steps you need to follow. First of all, the activity itself should implement OnStreetViewPanoramaReadyCallback. Once you've done that in your OnCreate method, you have to create a StreetViewPanoramaFragment Object and hook it up to the one you put in the layout of the XML file. Once you have this object, call this method getStreetViewPanoramaAsync(this) on it. Next you have to create an override and it's the override for onStreetViewPanoramaReady. And this is because you've implemented the OnStreetViewPanoramaReadyCallback. The onStreetView PanoramaReady override takes a single parameter. And this is the streetViewPanorama, and you just give that an object. For example, you could just call it Panorama. Then on this object, you call .setPosition() for the location. If you want to set it to the Grand Canyon as I have done, this is the latitude and longitude of the Grand Canyon. You then create a StreetViewPanoramaCamera, which is very similar to creating a Maps camera, as you've done in previous modules. Once you've done that, on the panorama you called .animateTo, the camera that you've just corrected, and then the time in milliseconds. And the camera will animate to that latitude and longitude as you've set it for the location. And you'll then see the Street View for that. This is all that we did to build a Grand Canyon application, just using this latitude and longitude. See if you can go ahead and implement this now for yourself. So here's what your code should look like. In your onCreate method, you're just going to create a StreetViewPanoramaFragment. You're going to initialize this by calling getFragmentManager().findFragmentById, very similar to what you do for typical controls. And then you just pass it the ID of the fragment, earlier I called my fragment streetviewpanorama, and that's the ID that I pass in here. Now once you get your streetviewpanorama fragment, you then call the getStreetViewPanoramaAsync, passing it this class. And this will setup the asynchronous callbacks for whenever the streetviewpanorama is ready. And then the callback you @Override, and you just call it onStreetViewPanoramaReady, and it takes a StreetViewPanorama as its parameter. And here you can see I've just called that panorama. On panorama, you then call .setPosition, and you pass it a latitude and longitude. This is the latitude and longitude of the Grand Canyon. You then create a camera, and very similar to mapping applications, you create a StreetViewPanoramaCamera using a Builder. And then you just set its bearing and other parameters that you like, but I've just set its bearing to be pointing at .bearing(180). Once you have the camera, you then animate the panorama to that camera with a duration, and here you can see, it's 1000 milliseconds, it's as simple as that. If you want to have a little bit of fun, here's a couple more locations you can take a look at. This location on the left, at 41.89 12.49, is the Colosseum in Rome. And this location on the right, at 51.17 and -1.82, is Stonehenge in England. And this is all it takes, implement this code if you haven't done so already, and you'll have a street view app that allows you to virtually hike in the Grand Canyon, in the Coliseum, or in Stonehenge. What types of scenario could you use this in? The possibilities are endless and I would love to see what you build. Lets explore the API a little bit. Now, we saw earlier that we could set the location of the panorama by calling setPosition on the Street View Panorama object and give it latitude and longitude. In addition to that, we could also get the location, and this will return a StreetViewPanoramaLocation Object. This object itself will have a latitude and longitude on it. So you can use this if the user has moved around the map to understand where the user is presently, and then you can plot that location on a map. So, for example, if the user was hiking down the Grand Canyon, you could have a map beside the StreetViewPanoramaView, and as the user moves down the Grand Canyon, or the user moves along in Street View, you can have a pin on the map update to show the user's location based on what they're looking at. You can also getPanoramaCamera on the StreetViewPanorama. Now you might remember the camera from earlier in this course, and the concepts are the same. This will return a StreetViewPanoramaCamera as you saw when we were creating the app. And this will allow you to read or edit things such as the zoom, the tilt, the bearing, etc. Let's take a look at the code now and look at the panorama camera again and see how we had set it up. So, if you remember back to the code, I've changed the camera view to be one where it points south by setting the bearing to be 180. I created a StreetViewPanoramaCamera, and I tell the panorama to animate to that camera at this bearing. I could have done similar things with tilt or zoom, just like I would with the mapping application. So, if you're not familiar with this, check back to the sections where we explored using the camera on a map view earlier in this course. There are some default behaviors on the street view panorama object that you can override, if you like. By default, street names are written on the panorama. Zoom gestures to zoom in and out are available and user navigation is enabled. You can check and set each of these using the following. For street names, you can call isStreetNamesEnabled, and this will return a true or a false. To set the street name, you can call setStreetNamesEnabled. And you pass that ability in true or false to turn street names on or off. For zoom gestures, you call isZoomGestureEnabled to check if it's on or off and that will give you a true or a false. And similarly, you call setZoomGesturesEnabled and pass that ability to turn them on or off. For user navigation, you check isUserNavigationEnabled, and this will return a true or a false. And you call SetUserNavigationEnabled to turn it on or off, passing an ability true or false. It's as simple as that. Let's take a look at what this will look like in an application, and we'll see what it looks like with street names on and streets names off. So I've made a small change to my app. And I'm just changing the location that we're actually looking at. And I've set it to be the latitude and longitude of the street right outside the studio where I'm filming this. So I called panorama.setPosition on this, and I do everything else the same. And I'll show you what the app looks like. Here you can see the area outside the studio, and I'm on Latham Street. And you can see Latham Street in the street view itself. And if I go to other places, we can see Showers Drive and the other part of Showers Drive. And as a result you can see all the street names being updated. Here we can see Showers Drive again from this angle. So street names are on. And you may want to turn this off. The default value is that it would be on. Now lets take a look at what it takes to turn it off. Now, if you remember, it was just panorama.setStreetNamesEnabled and we'd pass at a boolean. I want to turn if off, so I'm going to set false. So now I'm going to rerun the application and we'll see what it looks like. And here's the same application running now with the street names turned off. And you see I can just see the view outside. The street names have not been overlayed. The default behavior was for street names to be there, but I've overwritten that, and in some cases it might make for a better app. It's really up to you and what the needs of your app are. Play with the others, the user navigation and the zoom gesture, for yourself and see if you can get some nice effects. You can also respond to user interaction with your street-view, and there's some great methods for doing this. First of all, you can detect whenever the camera changes by looking at a new direction or zooming in and out with a handler called setOnStreetViewPanoramaCameraChangeList- ener. If your user touches on the panorama and you want to detect that to respond to it, you can use to set OnStreetViewPanoramaClickListener. If the panorama changes, typically by the user navigating to a new location, you can also detect this using the setOnStreetViewPanoramaChangeListener. These are all very useful if you want to build an app that provides information about the location that you're looking at. For example, in the Grand Canyon Hike, it would be really cool if you could show the direction the user is facing in as they pan around to look at the canyon for various spots on the trail or plot on a map where they are on the trail. See if you can figure out how to do this for yourself. It's beyond the scope of what you're learning here, but it might be useful for your final application. Congratulations, if you've made it this far. You've learned so much about mapping, satellite views, drawing on a map, markers, custom pins, Street View, and a whole lot more. It's been a lot of material covering a lot of territory, pun fully intended. And, I hope you've been inspired to think about how you could make your app better by using Rich Mapping. Or indeed, maybe you have an idea for an app that could be built around Mapping. Think about what you can do, if you combine it with Location Services and other Google APIs. With that, I'll sign off in the hope that you've really enjoyed this course. I look forward to seeing what you can do with Maps in your future Android applications.