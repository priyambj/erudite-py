Welcome to Linux for Web Developers. I'm Mike Wills and I'll be your instructor for this course. Every time you visit a web application, your browser is requesting a number of files that are sitting on a server somewhere out there on the Internet. More often than not, that server is running Linux. Therefore, as you develop and get ready to launch your own web applications, it's critical that you understand how these servers work and how to get your web application up and running on one. In this course you'll do just that. You'll start with a quick introduction to Linux, and you begin exploring the Linux file system. How are files organized, where do they belong. I'll then introduce you to a number of Linux security concepts. Managing users, how to understand permission system, firewalls, and package or software management. Finally, you'll get a very basic web application up and running using the Apache web server, and a postscript SQL database server. Managing and configuring servers is one of my favorite parts of this career. There's something very powerful in knowing that you've taken a server from zero to hero, all on your own and are in full control of it's capabilities. I think you'll enjoy this experience, and in the end, you'll be able to truly share your web applications with others while having the most intimate, low level knowledge of how people are actually receiving and experiencing your application. Linux is by far the most popular operating system of choice for web servers on the Internet today. Some estimates say 80% of public Internet servers are running some flavor of Linux. So what exactly is Linux? Linux is an operating system similar to Microsoft Windows or Apple OS X, which you might be more familiar with. The biggest difference with Linux though is it's free. Now, when I say free, you may be thinking of money, and that's not necessarily the case. You may have heard the phrases, free as in beer and free as in speech. It's quite popular within the open source community. Let's discuss what each of these means and how they apply to the Linux operating system. Free as in beer refers to money. If someone buys you a beer, it costs you nothing. Many versions of Linux are, in fact, free for you to use. But just because you get to use it for free, doesn't mean you get to see the underlying source code or modify it for your own purposes. Free as in speech refers to your rights or liberties with the software. You're free to run the software how you like, see how the software works, redistribute the software, and improve upon or modify the software. This latter definition, free as in speech, is how Linux became so popular. There are literally hundreds of versions or distributions of Linux available. And it's because of this latter definition of freedom, that this became possible. So with all these different versions of Linux available, how do you pick the right one? With all of these distributions, it's important for you to learn how to do some basic research on a distribution. And compare them against one another. Take a moment to research two different Linux distributions. And share what you've learned with other students in the forums. Here are some suggestions for what you should look for. Once you've shared your research on the forums. Take some time to read what your fellow students have discovered about the distributions they covered. When all you're done, check this box to continue. Thanks for sharing what you've learned. Being able to compare distributions against one another and make an educated decision is an important skill. Once you've selected a distribution to use it can be very difficult to transition to something else later on. Let's continue to compare a few different Linux distributions and identify their target markets. On the left I have provided four different and unique distributions. Red Hat, Ubuntu, Linux Mint and CoreOS. On the right, are four use cases. Match each letter with the use case. You may need to do a bit of research on your own before tackling this. So, I've provided some links to a variety of resources in the instructor notes. Each of these distributions targets a unique population of users and use cases. Redhat is focused on large enterprises and corporate customers that require support. Ubuntu focuses on ease of use on servers, desktops, laptops among many others. Linux Mint is for desktop users and includes proprietary media support. Remember, it's a modified version of Ubuntu, itself. Finally, CoreOS is a newer distribution that targets companies building clusters of containerized applications. Now this course isn't about vagrant or virtual machines. That was just some overhead work you needed to accomplish to get to this point. You're now logged into a Linux box. Whenever you get to this prompt, I want you to ignore all of that virtual machines and vagrant stuff as much as possible. Yes technically this computer is just a virtual machine sitting on your computer. But that's not too different than what you'll be doing as you start setting up your own web servers. Most likely you'll be given a virtual machine from a service provider like Amazon. And you're log in to it via SSH. This experience is pretty much the same as what you have configured now on your computer. You are remotely connected to a completely different computer. What does that mean? You can do anything here on this machine. And it will have no lasting impact on your personal computer. Remember, this is an entirely different computer. You can turn it off. Throw it away. Rebuild it any time you want. So I want you to have no fear when SSHed into that computer. You will not break anything on your computer. Now, let's get comfortable with this new computer, your Linux virtual machine. And see how it organizes all of the files you'll be working with. Since we're working from a command line only, we don't have a graphical interface, it only makes sense that we're currently residing in some place on this computer. We're within some directory in which whatever we type will be executed from. This is called our working directory. Whenever you log into a Linux machine you're automatically placed in your user's home directory. We can confirm this by typing the command, pwd. As you can see, the result of this is /home/vagrant. Let's unpack this a little bit. The slash is the root level of the file system. It's the absolute highest you can go in a Linux file system. Everything on the machine is in some way, a child of the route level, usually through a variety of other directories. Home is a directory you'll find within all Linux systems, and it houses all the home directories of each user with a few exceptions. If we cd into this directory and then list its contents, we'll see that there is a directory for each user on this machine, including our current user, vagrant. So let's go back into our own home directory and see what's there. This is our personal space to store stuff, but the operating system has already placed a few files there for us. If we just run ls we won't get any results, so we'll need to provide a few flags to ls to modify it's behavior. We'll add the -a flag, which tells it to show all the files, including hidden ones. On a Linux system, any file that begins with a dot is considered a hidden file. We're going to add one more flag to the ls command. That is the l flag, which will list the results in long format, and provide a bit more information. Now, there's a lot of info here, and we'll eventually go over most of it. For now, I want you to just focus on the first character and the names themselves. If the first character is a d, that's a directory. If it's a dash, that's a file. So you can see here that the .ssh and .cache are both directories. The rest of these are files. Let's take what we've learned thus far about the Linux file system, particularly our home directory, and answer a few questions. Provide the full path to the directory you started in and also provide the full path to one of the files within this directory. Remember, a full path must start at the top-most root level, which means it will begin with the slash character You start in your home directory. So the full path /home/vagrant is the correct enter here. The full path to a file within this directory could be /home/vagrant/.bash_logout. You could've also used the file .bashrc, or the file .profile. If you're interested in learning more about what these files actually do, look at the instructor notes. Now that you know all about your own home directory, let's imagine that you've created a new user named student. What would the full path to that user's home directory be? All users home directories are stored within these slash home directory. So a user named student would have a home directory of /home/student. So you're all comfortable with your home directory, but surely there's more to this computer than just that. Right? Oh yeah, there is a lot more. So let's start exploring some of the other areas of the Linux operating system. We'll do this by cding to the top level root folder with cd /. If we ls -al this directory, we'll see that there's a lot of content here. We're definitely not going to cover all of these, but we'll discuss the most important folders. We're already familiar with home, but there are two other important directories where you'll be making lots of changes and editing files. Etc is where configuration files live. As we start setting up our web and database server, we'll be modifying some files within this directory. Var is for variable files. Which is kind of an odd name. Variable files are simply files that you expect to grow or change in size over time. You'll typically find system and application logs within this directory. There are a few other directories that are that are important for you to know, but you probably won't be modifying or directly interacting with them. Bin is where executable binaries are stored, that are accessible by all users. These are applications that you run, like the LS command we've used a few times already. If you were to list the contents of this directory, you would actually see there's a file called LS within it. SBin is very similar to bin, except that these binaries are to only be used by the route user for system administration and maintenance purposes. We'll discuss some of the applications within this directory a bit later. Lib is for libraries that support the binaries that are located around the system. Finally, usr is for user programs. This could seem a bit confusing compared to the bin directory. The difference isn't that important. The only difference really is that the binaries within bin are required for a boot-up and system maintenance processes, and the binaries in usr necessarily aren't required for that. Now that you're familiar with the most important directories on any Linux file system, in which directory would you find system management applications that are not normally used by standard users? You would find these system management applications within the /sbin directory. We've used the LS command or application a few times already, and we know that it's located within the slash bin directory, but how come we didn't have to type the full path to this file to run it? Why didn't we have to type /bin/ls? Linux systems provide a nice little short cut system within the dollar sign path variable. Let's take a look at that and figure out how the operating system saves us some typing. If you type echo $PATH and you run that, you're presented with a bunch of paths separated by colon characters. We see /usr/local/sbin:/usr/local/bin and on and on and on. These are actually the directories Linux will progress through looking for a binary when you just type the name of it like ls. When you type ls, the operating system checks the first directory for an executable file names ls. If it's not there, it checks the next. And on and on and on until it gets here to /bin. And it does find that file, so it runs it. If you ever find that your commands aren't being found, or things are just acting really crazy, you might want to check this variable. I've placed a link in the instructor notes that will walk you through how to edit this variable and save it if need be. Now that you're pretty comfortable with your shiny new Linux machine, it's time to get your hands dirty, and really start working with it. In the next lesson, you'll start addressing some security concerns. You'll work with user management, authentication, file permissions, firewalls, and software updates. It's going to be a lot of material, but it's super important, not only for your users, but the Internet as a whole. You're about to unleash your very own server to the internet, and anyone in the world, at any time is going to be able to talk to it. There are many different distributions of Linux out there for you to choose from. So how do you make the right choice? First, you need to understand exactly what a distribution is and the ways in which they can differ from one another. Because Linux is free as in speech, people are free to make a variety of choices when they decide to create their own distribution. They can choose what software to include, how that software should be updated, how the community makes contributions, and even how that particular distribution can be shared with others. For example, Red Hat Enterprise Linux is a popular distribution for enterprises. This particular distribution is not free as in beer. Companies have to pay a licensing fee. In return for that payment, they have the right to use the software and receive support from Red Hat. Ubuntu is another popular distribution that itself has various versions. Some tailored towards servers, others for desktops, and even mobile phones. Ubuntu receives consistent updates to it's software, which is how it differs from it's parent distribution Debian. Debian is known for it's stability and reliability. Many Debian servers have been up and running for years without requiring a reboot. For this reason its software updates cycle is very slow when compared to others. Now that you're going to be putting another computer out there on the Internet, accessible by anyone, we need to discuss security. Not only for your own application's sake, but for everyone else out there as well. If a bad guy gets access to your server, they can do anything they want with it. Send spam, launch denial of service attacks, and so much more. In this lesson we'll discuss a number of security-related topics, including managing users, packages or the software installed on the server, various methods of authenticating users, how Linux manages file permissions, and finally, how to configure a firewall. One of the most important rules in security is the rule of least privilege. Put simply, this means a user or an application only has enough permission to do its job, nothing extra. You've already experienced this within your virtual machine, although you may not be aware of it yet. When we access our virtual machine, using vagrant ssh. We're logged in as a standard user named, vagrant. Let's try running a command only an administrative user would be allowed to run. Let's list all of the files with in the ubuntu users ssh directory. You see, we get this error here, permission denied. Only the ubuntu user or the root user can read the files within this directory. You may be thinking, but I am the administrator of this virtual machine. I am root. So how do I actually log in as root? It's time to learn about super user. Since every Linux machine comes with the user name root and that user is super powerful, they can do anything they want on this machine. It's very common to disable the ability to remotely log in as root. Instead, we'll log in as a user we create, and then we can run individual commands as root by using another command. This is to make any potential attacker's job a little more difficult by eliminating the username that they already know exists on this on this box. Our vagrant virtual machine has already set up the security pattern for us and many other cloud providers will do this for you, as well. If not, it's highly advised that this be one of the very first things you do when you're setting up a new server. We'll cover exactly how to do that a bit later. Let's run that same command again, except this time we'll prepend the command with this pseudo command here. Now we see the results. The pseudo command ran this command as if we were root. It's typically regarded as a best practice that you not use the SU command. Why? The rule of least privilege that we discussed earlier. Do you really need to switch your entire working context over to the root user to run a single, or even a few, commands? What happens if you forget that you are currently within SU? You could potentially do some extremely damaging operations, and there's no safety net there to warn you when doing so. Now, not every user has the ability to work as the superuser. You have to give that user those permissions specifically. We'll cover that in more detail when we start adding new users. For now, you know how to perform operations as the root user, and that's all we need to start managing software known as packages on this machine. So let's dive into that a bit. When you need new software, what do you typically do? You might visit an app store like this and download it or you could actually walk into a store and buy a physical copy. You have a lot of different options. You might even say you have a list of options. Now how often have you seen software for Linux sitting up on a store shelf? Not very often, if at all. But we still have a list of various places we can go to get software. This is called a package source list. Let's take a look. All of your available package sources are listed in this file /etc/app/sources.list. Remember when we were discussing distributions, we said each one approves and releases packages in their own way and that's one of the big ways in which they differ. This is the package's list for your current version of Ubuntu. As you skim through the file, you'll see some pretty recognizable parts. We see a URL here and the word trusty looks familiar. That's the code name for the version of Ubuntu we're running. We know Ubuntu is also based off of Debian, so that's probably what this deb stands for here. This is a list of software repositories that Ubuntu set up for us automatically. There are a lot in this list and each of these would be referenced when you try to update or install new software. Speaking of which, let's go ahead and make sure that all of our software is up to date. One of the most important and simplest ways to ensure your system is secure is to keep your software up to date with new releases. Because Linux systems focus on reliability and they run a variety of complex applications that have numerous dependencies of their own, most Linux distributions do not auto-update the software installed on the system. You'll need to do this yourself and test your apps to make sure any recent updates don't break your application. The first step to upgrading your installed software is to update your package source list. We do this with the command sudo apt-get update. See the sudo there? We have to run this as the root user. The update command will run through all of the repositories we saw within our etc/app/sources.list file, and it will check to see what all software is available and what those version numbers are. This command doesn't actually perform any changes to the software on your system. It just makes sure your system is aware of the latest information stored within all of these repositories that you're making use of. Now that our system is aware of what all software is available, and the most recent version numbers, it's now time for us to actually update the software. We do this with the command, sudo apt-get upgrade. Once again, we have to use sudo. Remember this is an administrative task that we have to run as the root user. After a few seconds, you'll be presented with a list of everything that's going to change on your system. And this question, do you want to continue, yes or no? We'll say yes in a second, but let's review this information real quick. Here we have a list of packages that will be upgraded. Some of these names look familiar. See a name python here, python down here. But others, not so much. This early in setting up a new machine, you can be pretty safe in just accepting that the system is always making the best decisions for you. Later on, when you actually have your web application running on this system, and it's serving your users. You're going to want to take more care in reviewing this list. And testing everything in a non-production environment before performing similar operations on your production server. For now, we'll just hit yes and we'll go take a coffee break as all of these new versions are downloaded and installed. The apt get application is your main interface to a ton of package related functionality. We can check out everything you can do by reading the man page for it with this command, man apt get. We see here it can install packages, it can even remove packages, it can do all sorts of stuff. For now, let's see if there are some packages that are no longer required that we can just automatically remove. We'll do this with the command apt-get autoremove. And once again, it's an administrative task that has to be run as root. So we use sudo. After a few seconds, we're returned back to our prompt to let us know everything is all done. Now let's use apt-get to install new software. We'll install an application called finger. It's something we'll use a little bit later on when working with users. We do this by typing the command apt-get install finger, and once again using sudo. So how did I know the package I wanted to install was called Finger? Most of the time the package names are pretty easy to guess, but not all the time. For instance Python has two extremely popular versions, you have Python 2 and Python 3. It may be a bit more difficult to figure out what the name of that package would be. Fortunately, each distribution tends to publish an easy to browse version of their repositories. For Ubuntu, you can search for packages at packages.ubuntu.com. If I were to search for Python and I look at this top result that says 2.7, so that's Python version 2. If I search for Python 3 and I look at the top result it says 3.40, so I know that's Python version 3. Let's get a bit more practice searching for packages using Ubuntu's package website. Use the site to search for the package names for Apache HTTP Server, PostgreSQL, and Memcache on Ubuntu Trusty. Enter your answers in these boxes. You don't need to include the full app to get command, just the package name. The correct answers are apache2, postgresql, and memcached. Now that we've installed Finger, let's use it. This application will look up various pieces of information about a user, and display it in an easy to read format. If I type Finger, the command will output information about all of the users currently logged into the system. You can see the vagrant user here, that's us, and the last time we logged in. You can also pass a username to the Finger application to see additional information about a specific user. Type finger vagrant, and you'll see some additional information including our home directory and what shell we're using. So where is finger retrieving all of this information such as our user name, our home directories, the shell? Much of this information is found within a file that stores information about each user. This file is called etc/passwd. Let's take a look at that file using the cat command. Each line within this file is an entry for a single user, and each entry has a number of fields that are separated by colon characters. Let's find the entry for our current user, vagrant. The line looks like this, vagrant:x:1000:1000: :/home/vagrant:/bin/bash. These two numbers 1000:1000 might be different on your system, but that's okay. It's nothing to worry about. The first field reads vagrant and that's this users username. The second field used to store encrypted passwords. Historically storing encrypted passwords in this file wasn't an issue as the hardware was too slow to crack a well chosen password. These days, almost every distribution will just insert a character that is ignored in this field. In this case, ubuntu uses an x. The third and fourth field store your user ID and group ID. We'll discuss these a bit more when we get into talking about file permissions. There's a fifth field here that may be hard to see since it doesn't include any text. It's empty. This field is used to store a better description about this user. You can see one user does have a better description here. Gnat's and then this full description, gnats bug reporting system admin. The last two fields are the user's home directory and finally, the user's default shell. Our home directory is /home/vagrant as we already knew. And our default shell is bin/bash. The following is an entry in the systems /etc/passwd file. What is the following user's home directory? Enter your answer here. The users home directory can be found, in the second to the last field. In this case, that value is /var/list. Using a combination of the finger application and reading the etc/password file, identify the following information for the root user. User ID and the Group ID are both 0. In fact, this is a special rule on Linux systems. The root user will always have 0 as its User and Group ID. The Home Directory is /root. And the default shell is /bin/bash. If you recall, when we were discussing Sudo, we mentioned that it's a common pattern to disable the ability to log in as root, and to only log in as a different user that has the ability to use Sudo. This is a security measure, since every bad guy out there knows every Linux box has a user named root. By disabling this account from remote log, in we remove a very easy attack vector. Now vagrant took care of this for us. They created a user name vagrant and we just type vagrant ssh from our terminal to automatically connect. But not every hosting provider is going to set something like this up for you. So let's do this ourselves. We can create a new user by using the adduser command. This is an administrator feature, so we'll have to use sudo as well. Let's go ahead and create a new user named student. We'll then be asked to enter a password for the student. I just used the word student, but as you can see, in these password fields, you don't see what you're typing. We're then asked the number of additional questions about the user. All of these are optional, so you can ignore them. But I'm going to go ahead, and add a bit more additional information here in the Full Name section. And that's all there is to it. We can confirm this user was created by using the finger command. Now, that we've created this user. Let's go ahead and connect to our server as that user. I've opened a new terminal here, and this terminal is on my local machine. I have not connected to the server yet. I can connect to the server using this command, ssh student@127.0.0.1 -p 2222. Let's break this command down a little bit. We've been connecting to our server using vagrant SSHwhich is just a shortcut for all of this. SSH is the application we use to remotely connect to the server. And 127.0.0.1 is the IP address we want to connect to. This is a standard IP address that always means localhost or the same computer I'm currently on. The student@ is the user we want to log in as. We want to log in as student@ this IP address. Finally, the -p 2222 flag tells us to connect using port 2222. When Vagrant set up our virtual machine, it automatically set up this port on our local machine to forward to the virtual machine. After hitting Enter, you may be asked an authenticity verification question. Just hit yes, and then you're asked for the user's password. Enter that, and you'll be logged in as the student. Now that we're logged into our server as the student user, let's try and run a sudo command. We'll try and run sudo cat /etc/passwd. We're asked for a [sudo] password for the student which is just the standard password we set for the user when we initially made the user. We now get this warning. The student is not in the sudoers file. This incident will be reported. Our students does not have permission to use the sudo command. So, let's fix that. I switch back to my other terminal where I'm logged in as vagrant. This is a user we know can run sudo commands. They can perform administrative tasks. Now, the list of users that are allowed to do this is within the etc/sudoers file. Let's read that file using sudo cat /etc/sudoers. Here we can see that the root user is listed along with a few groups using % and then the name of the group. On some systems you would just add the student user just like this, using a special program called visudo, that's allowed to edit this file. But on Ubuntu, it handles it a bit differently. If you look at the very bottom of this file, there's a here that says includedir /etc/sudoers.d. This command tells the system to also look through any files in etc/sudoers.d and include those as if they were written directly within this file. This is a common pattern since distribution updates could overwrite this file. And if that were to happen, you would lose all of the users you added. By keeping your customizations in this other directory, the system eliminates that risk. Let's see what files are currently included in that directory by running sudo ls etc/sudoers.d. We see a file here called vagrant and that makes sense since we're actually using sudo here. Even though vagrant wasn't within our etc/sudoers file itself, this file is being included by this directory, giving this user the permissions it needs. Let's go ahead and give our student user access to pseudo themselves. I'll first copy the vagrant file and name it student. I'll then need to make a small edit to this file and I'll just use nano to do that. This second line here is actually what's doing all of the work. The file name doesn't mean anything, so we'll change the word vagrant here to student. There are a few more options here. And if you'd like to understand them all, I've placed a link in the instructor notes for more information. For now, we just want student users pseudo access to function exactly as the vagrant users currently does. After saving that file, I've switched back to my terminal where I'm logged in as the student and we'll try to run this pseudo command again. And there we go, we see the results. Our student user now has access to use pseudo. We've just provided super user access to the user student, but if you remember, that user has an extremely simple password. The user themselves could reset their password using the passwd command, but you can't rely on that user to do so all the time. As a super user, you can foresee users password to expire. Use the man page and read through the documentation for the passwd command. Enter the command that you would use to force the student user's password to expire. You would use the command, sudo passwd -e student, to force the student user to reset their password the next time they login. Student is the user and this -e sets that password to expire. You just added a powerful user to your server that authenticates using a user name and password. Hopefully, you chose a strong password since attackers will soon start running bots against your server attempting to guess any valid usernames and passwords. This is going to cause all sorts of issues for your server. Your logs are going to be filled with invalid login attempts, and if one of these hackers manages to gain access, well that's about the worst thing we could possibly imagine. There's another way to perform user authentication that's much more secure. It doesn't rely on passwords, which we're pretty horrible at making secure, since we have to make them simple enough to memorize. Instead, this form of authentication, called key based authentication, relies on physical files located on the server and your personal machine, the one you're logging in from. Before we get into key based authentication, let's demonstrate how public key encryption generally works. Let's imagine I wanted to send a message to Cameron without anyone else being to see that message. If I were to just place this note on Cameron's desk, anyone could come by and read it. I could find a box with a lock and lock the message away but then I have to somehow get this key to Cameron. That's not going to work because anyone will be able to come by and grab the key. But what if Cameron already had a box set up on his desk, with his own lock, and the key to unlock that box is always in Cameron's pocket? He never shares that key with anyone. I can then come by his desk, place my message in the box, and lock it. And no one else can ever see that message. In this example, the box is called the public key. The box can be left out in the open, shared around without any consequence. The key in Cameron's pocket is called a private key. Cameron never lets anybody else borrow that key or see it. This combination of public and private keys allows me to securely communicate with Cameron. This same cryptography trick can be used to authenticate a client with a server. The server will send a random message to the client. The client will encrypt that message with their private key, and then send that encrypted message back to the server. The server will decrypt this message with their public key and if that value equals the same value they sent, then everything checks out and the client has authenticated. We'll generate our key pair on our local machine, not on our server. Remember, you never, ever want to share your private key with anyone else. It should remain firmly in your possession at all times. For this reason, you always generate key pairs locally. If you were to generate the key pair on the server, you cannot claim that the private key has always been private. We'll generate our key pair using an application called ssh-keygen. You will first be asked to give a file name for the key pair. I've given this one the name users/udacity/.ssh/linuxcourse. This directory here is the default directory that key pairs should exist in, so I advise you to keep that the same. But you can name it what you'd like. We'll then add a pass phrase to our key pair, just in case someone does happen to get these files. This pass phrase will prevent them from actually using them. Once done, you'll see that ssh-keygen has generated two files, linuxCourse and linuxCourse.pub. This file, linuxCourse.pub, is what we'll place on our server to enable key based authentication. The ssh-keygen application can generate key pairs of various types. The key you just generated was an RSA key, which is the default type if you don't specifically define a different type. Read through the ssh-keygen man page and determine what other key types are supported by the SSH version 2 protocol. The SSH version two protocol supports the DSA, ECDSA, ED25519, and RSA key types. MD5 and SHA256 are hashing algorithms that are not suitable for public key encryption. Now that we've generated our key pair locally, we still need to place the public key on our remote server, so SSH can use it to log in. There are multiple ways to do this and there are even some applications that will do most of the work for you, but we're going to do it the manual way. First we want to make sure we're logged into our server as the student. I'll first create a directory called .ssh using the mkdir command within my home directory. This is a special directory where all of your key related files must be stored. I'll then create a new file within this directory called authorized keys. This is another special file that will store all of the public keys that this account is allowed to use for authentication, with one key per line in that file. Now, back on my local machine I've read out the contents of linuxcourse.pub, and I just want to copy that. Then, back on my server as the student user, I went to edit this authorized key file. And in here I'll just paste in that content and save it. The final thing we need to do is set up some specific file permissions on the authorized key file and the SSH directory. This is a security measure that SSH enforces to ensure other users cannot gain access to your account. We'll discuss file permissions in a lot more detail shortly. For now we'll set the permissions using the following commands. We'll run chmod 700 on our SSH directory, and chmod 644 on the authorized keys file. Finally we're all done and we can now log in as the student user, but instead of using user name and password. This I flag and the definition here of what key pair we want to use will allow me to login using that key pair. If you set a passphrase for your key pair, you'll be asked to enter that. But, once you're done, you'll see you've logged into the server and you did not have to enter your remote password for this user. The final thing you'll want to do to secure the authentication process is to disable the password base logins. This will force all of your users to only be able to login using a key pair. To do this, you'll have to edit the configuration file for SSHD. Which is the service that's running on the server listening for all of your SSH connections. This configuration file is located at etc/ssh/sshd_config. And you can edit it using sudo nano. There are a lot of options in here, and you can read through them all to get a better understanding of how SSH is configured. The comment lines start with the hash symbol here. And they're pretty good at explaining what everything does. The line we're looking for is right here, PasswordAuthentication yes. We just want to change that to no, and then we'll save the file. Now, the SSHD service is currently running, and it only reads its configuration file when it's initially started up. So we need to restart the service so it runs with the new configuration option we just made. We restart the service by sudo service ssh restart and that's all there is to it. Now all users will be forced to log in using a key pair. SSH will not allow users to log in with a user name and password any longer. A bit earlier you changed some permissions on the authorized key file and the .ssh directory using a command called chmod. But what exactly does that mean? Let's dive a bit deeper into how Linux manages file permissions. I've listed the contents of the students' home directory. And we're going to look at three pieces of information provided here. The first column we've looked at briefly before. Remember the d means that this is a directory. The dash means that it's a file. Now, you might think that there are nine additional spaces here for information, but what's actually happening is there are three separate sections and each of those sections has three pieces of information. Let's break out this entry here for bash.rc. The three individual entries are rw-, r--, and r--. Let's go ahead and label each of these entries. This first one I'm labeling owner, then group, and finally everyone. This means the owner can read and write the file. The dash here indicates that the owner cannot execute the file. If they could, there would be an x here. Users within the group can read this file, but they cannot write or execute it. Finally, everyone can read this file, but they cannot write or execute it. So how do we identify who the owner in the group are? If we look back at our directory listing, we'll see two columns, here in the middle. Most of the entries read student student, but there's one here that reads root root, and I'll come back to that one. These two columns identify the owner and the group for each entry in this list. Now it's important to remember, although each of these has the same word, student, listed in the two columns, they're in two entirely different things. The system has a username student, which is the owner of the file. And a group name student, which was automatically created when we made this user. This is pre-common practice on a Linux system, to have a group name the same as the user. Just remember that they are two entirely different things. So, what's up with this entry here that has root root? We can see that the entry's name is .., and that's just a shortcut for the parent directory. And we know we're in our student's home directory. So this entry here, is the equivalent of /home. That directory is owned by the root user, and has a group of root. And if we look at the permissions, we see that only the root user can write to that directory. Lets test this out for ourselves. I'll move into the directory using cd.. And then I'll try to write a file. You'll get a permission denied error, just as this permission system told us we would. Only root is allowed to write in this directory. And our current user's definitely not root. We can still list the files in this directory, because we have read access, and we even entered the directory because we have execute. We just can't write. Explore the file system a bit and identify the owner and group for each of these files or directories listed here. All of these files are owned by the user, root. But some of them have different group owners. .bashrc has a group owner of root, /var/local has a group of staff, /var/log has a group syslog, and this file has a group of root. So we know permissions are represented as Rs, Ws and Xs, indicating read, write and execute. But when we changed the permissions of some files earlier we used numbers. How did the digits we entered translate to these values? We can translate these values as follows. Rs are equal to 4. W's are equal to two, X's are equal to one and if we don't want any permissions, that will be a zero. By adding the numbers together, we end up with a result identifying the full set of permissions to apply. For example, if we wanted to give read and execute permissions, we'd have values of four and one, which when added together, gives us a final value of five. To represent, read, and execute permissions, you would use the number five. But remember, permissions are done in sets of three to identify what permissions are set for the individual user, the group, and everyone. Let's analyze our student's .bashrc file once again. And convert its current permissions into octal form. The current permissions for this file are rw dash, r dash dash, and r dash dash, r is a 4 and write is 2. So the user value would be 6. For group, we just have an r. So the value is 4. And for everyone we have a value of 4. To represent this permission set in octal form, we'd use the value 644. Convert these symbol-based file permissions to their octal form. Remember, read is four, write is two, execute is one, and nothing would be zero. The first is 644. This one is 777. The third one is 755. Remember, this D does not chance the octal permissions. It just represents that this is a directory. The final one is 600. We've already seen how to change file permissions using the chmod command. But what if you need to change a files group or owner? There are also commands that allow you to do that. They are Chown. C-H-O-W-N. And change group. C-H-G-R-P. We'll play with this bash history file here located on our home directory. Its permissions are set so only the owner can read and write the file. This file stores a recent history of every command the user has typed, so it's for security reasons only that the user can read and modify the file. If you run cat on bash history, you'll see that we can currently read this file. If we change the file's group to root using this command sudo chgrp root and then then name of the file. If we try to cat this file again, you'll see that we can still read it. The group has no permissions on this file, so there's pretty much no effect. Our ability to read this file right now is determined by the owner setting, not the group setting. But now, if we change the owner to root of the bash history file, you'll see that we can no longer read the file. Permission is denied, and this is because only the owner can read and write the file and that owner's root. Our current user student would fall in the everyone category and they have no permission at all to read this file. Go ahead and change the owner and the group back to student on this file. We were just experimenting to show these commands and when you might need to use them. Now let's move on to the last security topic we'll discuss, firewalls. You now have a server sitting out there on the Internet and this server is doing a lot of different things and talking to other devices on the Internet. Depending on your application it could be responding to web requests, database queries, sending and receiving email, and let's not forget handling the SSH sessions we've been using this whole time. But how does your server know which application is in charge of handling each type of request? The answer is ports. Each of your applications are configured to respond to requests destined for a specific port. For example, a web server would by default respond on port 80, the default port for HTTP. We can control which ports our server is allowed to accept requests for using an application called the firewall. We'll do that shortly, but for now let's explore some common ports. Below are a few of the most common services a web server would run. Identify the default port for each of these services. HTTP runs on port 80. HTTPS is 443. SSH is 22. FTP is 21. POP3 is 110. And SMTP is 25. Just because our server can listen on every single port, for any type of request, that doesn't mean we should. The rule of least privilege, which we've discussed throughout this entire lesson, tells us we should only listen on the ports required for our application to function correctly. We can configure which ports we want our server to listen to using an application called a firewall. Let's imagine this wall is our firewall application. And each of these slots is a port. We currently have all the slots filled, which means I can't pass data from one side, the Internet, to the other, my server. You could say I'm denying all incoming requests, but if I open one of these boxes, we'll choose port 80 here. I can now pass information through. The server on the other side can now fully function as a web server with the added benefit of completely ignoring these requests that we know we're not interested in. Let's go back to our terminal and start configuring our server's firewall now. Ubuntu comes with a firewall pre-installed called ufw, but it's not currently active. You can verify this by typing command, sudo ufw status. Status: inactive. Let's start adding some rules to our firewall, then we'll actually turn it on. If we think back to the wall of boxes from our last video, we were initially blocking all incoming requests. This is a good practice, as it makes it much easier to manage your rules. Just block everything coming in, then only allow what you need. We'll establish this default, deny incoming, by using this rule. We can also establish a default rule for our outgoing connections, any request our server is trying to send out to the internet. We'll set this rule by using this command, sudo ufw the default rule, allow all outgoing. Go ahead and check the status of your firewall by typing, sudo ufw status. You'll see that it's currently still inactive, which is a good thing. We're just configuring our firewall now. We actually have to turn it on ourselves once we have everything how we want. If we were to turn the firewall on now, we'd we blocking all incoming connections including SSH, which means our server would be dead in the water and completely inaccessible to us. It's now time for us to start configuring the firewall to support the various ports and the applications we know we'll need. Let's start allowing the ports we know we'll need for the applications our server will be supporting. First and foremost we know we'll need to support SSH so we can continue administering this server. Normally you would do this by typing sudo ufw allow ssh and you can go ahead and do that now. But remember, we're using a Vagrant virtual machine and Vagrant set up our SSH on Port 2222. So we'll need to allow all TCP connections through Port 2222 for SSH to actually work in our scenario here. For now, the only other application we plan to support is a basic HTTP server, so we can allow this by using sudo ufw allow www. And with that, we can now enable our firewall with sudo ufw enable. This step here can be a little hair raising, because our SSH connection is reliant upon these rules being correct. If all of a sudden you lose your SSH connection to your server, it's a pretty clear indicator that you messed up some of your rules. Some cloud providers do offer a way to regain access to your system through an external control panel. But many others, you're just out of luck at this point. For this reason, I recommend configuring your firewall pretty early in the server setup process. Finally, we can confirm all of our rules are set up as we indicated by using the sudo ufw status command. We'll see all of our rules here and that our firewall is currently active. Congratulations. You now have a server updated and configured, sitting out there on the wild west that is the internet. Best of all, you can rest easy at night knowing your server is safe and secure. Where you do go from here? It depends on your needs. There are a lot of different types of servers, email servers, chat servers, web application servers. Generally, the only big differences between each of these is the software they have installed and the ports that they have open. I've placed a few server set-up walk throughs in the instructor notes below, that should get you started. I'd encourage you to start by setting up a web application server, installing Apache in a database server like PostgreSQL. Good luck, have fun, and remember, experiment. This is your own little piece of the Internet.