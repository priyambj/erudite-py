Famous computer scientist Edsger Dijkstra said, if debugging's the process of removing software bugs, then programming must be the process of putting them in. There's a lot of truth to that. When we're programming, we're bound to introduce errors in our code. Even the best apps on the app store have their fare share of software bugs. So as developers, we can expect we'll be spending a lot of time debugging and fixing our problems, whether it's our own code or even someone else's. But trust me, it's not as bad as it sounds. Debugging's just part of being a programmer. And thankfully for us, Xcode makes this process easy and fun, once you know what you're doing. My name's Jared Parks, and I'll be the instructor for this course. Let's get started. Throughout this course, we're going to use Xcode's debugging tools to fix problems in the So Many Bugs app. That's what you see here. When you launch the app you should see this scene selection screen and it contains buttons for different buggy versions of the app. I'll go ahead and run the final version that contains no bugs. At least, no bugs that I know about. The app's pretty simple, it starts with this main screen and has this ominous spider web in the background. And if I tap the screen, a spider should crawl on. So there's our first spider, and I'll go ahead and spawn a couple more, so that you can see them all animating at the same time. And one more. If I select the gear icon in the upper right-hand corner, then I can adjust the types of the spiders that we're spawning. So I'll pick this angry red spider here and go ahead an spawn an angry red spider. And let's spawn some of the other types as well. So I'll spawn a blue one. And spawn a green one. There's our green one. So as you can see, the black spiders are basic. The red spider here is pretty fast, kind of angry looking. The green spider's smooth, calm, and collected. And this blue spider is just kind of dorky and slow. If you want to know more about how the animations are done, then check out the link in the instructor notes. The last feature of the app is shaking the bugs off the web. Before I show this feature to you, I want you to download the app, and then get acquainted with the code. There's a download link posted in the instructor notes. Make sure to reference the final bug view controller and final settings view controller classes. Those are the classes that are used in the working version of the app. After you've looked them over, I want you to answer the following questions. First, which method shakes the bugs off the screen? And second, which UIEventSubtype member value is being used to shake the bugs? UIEventSubtype, if you haven't seen it is an enumeration value declared by the UIEvent class, and the member value is just another word for the value of the enumeration. I've posted a link to the relevant documentation in the instructor notes, and you can use them if you get stuck. Once you've found the answers, write them in the appropriate text boxes. The method that shakes the bugs is called disperse bugs animation. It gets called when the shake motion ends. This makes sense because the UIEventSubtype member value that we're checking for is motion shake. You could have written the answer for that second question in any of the following forms. Now, I'll go back to the app and simulate a shake event. To simulate a shake event, go to the Hardware option in the main menu at the top, and then select the Shake Gesture here. You can also use the hot key for shaking, which is Ctrl + Cmd + Z. Once the phone shakes, all the spiders scatter readily from the center of the web, and disappear. if you spent any amount of time in Xcode you've likely handled warnings and errors. Warnings are issues identified by the compiler that might cause problems or have unintended side-effects on your running application. Now you're not required to fix warnings before running your app but it's highly recommended. Errors, on the other hand, are reported by the compiler and must be fixed prior to running your app. If you don't fix them, the next code can't build your source and can't run your code. Both of these types of issues, warnings, and errors, are fundamentally different than the kinds of bugs we solved in this course. Before we talk about bugs, let's take a look at the ways Xcode shows warnings and errors to us. The first place is here, where my cursor is at the top toolbar. Here Xcode displays the number of warnings here and the number of errors in your code. As you can see, this project currently has one warning and one error. The next place that Xcode reports warnings and errors is in the issue navigator. You can access it by clicking on the issue navigator button in the navigator panel here. Or, if I were to go back, you just click one of these icons on the top tool bar, that'll also bring up the issue navigator. If the issue navigator is currently hidden in your set-up you might not have the navigator panel revealed. Make sure that you click this button to reveal the navigator panel on the left side of Xcode. In the issue navigator, Xcode pinpoints each error and the file where it originates. If you are to click one of the errors, it'll take you directly to the file, and this is really useful. I'll go ahead and resolve these errors, this one error just looks like an unwrapping problem, and there we go. The second here is in the story board, so View right here is inaccessible because there's no segue. Let's go ahead and fix that. I'll control click, drag, and add back the present modal segue and let's run the project. That was warnings and errors but let's talk about the types of problems you'll solve with the debugging tools. That's runtime errors. These errors are fundamentally different from the compiler warnings and errors we just saw. Specifically, these errors occur while the app is running. Also, these are errors that your users will see and they're going to complain about them if you don't fix them. There are two types of runtime errors. The first is a logic error which occurs when your app or program doesn't work as expected. For example, I'll go to the print debugging scene and when I tap, no spider appears on the screen. Now, this is definitely a logic error. When I tap, spiders should be appearing on the screen. As the second type of runtime error, a fatal error, we also call these crashes. To demonstrate one, I'll click on the settings button, then I'll try clicking on one of the bug types here. As soon as I click the button, the app crashes, we're redirected back to Xcode, and we're given a crash report. At this point, the app cannot continue any further but clicking Stop should not be your first move. This is something that I've commonly done before as I was learning to program, I panicked, my app stopped working, I didn't know what was going on, so I just assumed clicked Stop. The problem with stopping after a crash is that it get's rid of valuable debugging information that Xcode's trying to give us to help us fix the problem. So my first word of advice about debugging is don't panic. It'll only raise your blood pressure and it doesn't actually get you any closer to solving the problem. Instead, it's better to take a clear sequence of calculated steps when you are debugging and we'll cover that next. When you don't have a clear plan for debugging your issues, you can waste a ton of time wandering aimlessly through your code. I've been there before, and it sucks the joy right out of programming. But it doesn't have to be this way. A better approach to debugging is having a consistent debugging process. First, you want to reproduce the problem. The more complex the problem is, the more important this step becomes. Being able to reproduce the problem ensures that you understand the reasons which led to it. And sometimes it's as easy as clicking a button for your program to crash, but other times it may take running your app for thirty minutes before the problem occurs. The point is, you can't reproduce a problem if you don't understand it, and if you don't understand it, then you can't fix it. Which leads to the second step, gathering debug information. Now this is crucial. But you may be wondering what type of information are you looking for exactly? Well it depends on the problem, but typically you want to start by examining the program state or logs. Now the program state is all the stored information that you have at a given point in your program's execution. For instance, when the error occurred, what is the value of a variable? What kind of error are we looking at? Maybe it's in EXC, BAD_ACCESS, maybe it's a off by one problem, it could be anything. What line of code caused the error? Or what functions or methods led to the error? This is the information that you'll want to know when you're debugging, and ExcCode reveals this to us through its tools. And thankfully there are a bunch of tools, and they're really easy to use. Now the hope is, of course, is that with all the information that you gather, you can form a strong hypothesis about what went wrong. But as you may already know, having an hypothesis and actually testing that hypothesis, are two entirely different tasks. If you're certain about what went wrong, then you can go ahead and try to fix it. But if you're unsure at all, then you should probably go back and gather more information before trying your fix. In some cases however, trying a fix that you're not 100% sure about isn't a bad thing. Even if it doesn't fix the problem, it could reveal more information about why and what is happening. The trick is to make sure that you maximize the amount of information you gain per fix that you try. If you find yourself making small changes and your program keeps crashing, or it doesn't behave like you expect, then stop for a moment, pause, collect your thoughts, and make sure that you really understand the problem. Once you do, you can make a more informed fix and try to reproduce the problem again. And if your fix works, then when you try to reproduce the problem it won't happen. But if the problem still occurs then you'll have to go back and start in the same debug spin cycle. Now this can be tough, but it's expected. It often takes multiple iterations of this full debugging process to ultimately figure out what your problem is. So let's review. The debugging process is as follows. First, reproduce the problem. Then gather any debugging information you can about the problem. Once you have enough information, form a hypothesis about what went wrong. Then determine an implement affix. Last, test the fix by trying to reproduce the problem again. If you stay true to this method, and you know which tools are available, then debugging isn't so much of a headache anymore. It's almost like solving a code mystery each time. If you treat it that way then it can be a much more pleasant experience when you're programming. It's time to fix our first bug in the So Many Bugs app. Right now I'm in the print debugging scene and no spiders are appearing when a user taps on the screen. We've already completed the first step of figuring out this problem, because we know how to reproduce it, by tapping on the screen. But we need more information so that we can determine the root cause of the problem. So I'm going to stop the simulator so that we can investigate the code. Right now we know that the problem could be related to some incorrect behavior when a user taps on the screen. And we'll treat this as our starting point, like we're solving a code mystery, and we'll trace the steps leading up to the crime. Now for this problem instead of using specialized debugging tools, we're going to use a simple debugging approach called print debugging or cave man debugging. It may also go by some other names, but the key is that we're only going to use print statements to inspect what's happening in the code. Now this is an extremely simple approach, but a really well placed print statement is sometimes all you need to determine what's wrong. I'll start by looking at the PrintBugViewController.swift file. This is the view controller that's on screen when we're tapping. And right now we have reason to believe that the problem is related to our code incorrectly handling a tap. Now, it could be the case that our logic for handling a tap is not even called. So let's click this drop down so that we can see what this particular class contains. And, if we go here to the bottom we can see this handle single tap method. Now, this method looks promising and I'll go ahead and click on it. Could of also jumped to this method by using the Cmd+Shift+O hotkey to bring up a quick search. And then type in handleSingleTap. And we're looking for the one in the PrintBugViewController on line 83 here. And tap enter and it will jump us there. Of course, this assumes that we know the name of the method before we're actually searching. Anyways, at the beginning of this method, let's add a print statement to make sure that we actually call the method itself. We can also see that a call's being made to the addBugToView method. If I command click on it, Xcode will jump me to the location where addBugToView is defined. Let's put another print statement here so that we can see if this code's being reached as well. And we'll rebuild and run the application. I'll go to the print debugging scene and then I'll tap. And we can see in the debug area that both of our print statements are showing up for each method. This confirms that the methods are being called, but the spiders are still not being added to the view. So the problem must be something else. I'm going to leave it up to you to figure out what the problem is. As an exercise, I want you to use only print debugging, like print statements such as print LN, to see if you can identify and fix the problem. Then, once you've identified the problem, select one of the following statements that best describes what it is. Your choices are, the spiders do not appear because bugs are never created by the bug factory. Bugs are created, but they're not added to the view. The bug maximum restricts the creation of bugs. And, bugs are created, but they are positioned off screen. Once you fix the problem, select the most appropriate answer, and continue. I'm going to show you how I use print debugging to figure this one out. Since I know that we make it to the addBugToView method, I'll add a print statement before and after the if block. Before the if block I'll print out the current count of bugs in the bugs array and the value of max bugs. And after the if block I'll print out the count the bugs again to see if anything's changed and then I'll rebuild and run. I'll select the print debugging scene, let's do a couple of taps. And here in the debug area we see that each time a tap occurs, the bug count is less than max bugs, so zero is less than a 100 here. And then the bug count's also increasing after we can assume that a bug's been created. So we've gone from two bugs and then three bugs here. So this suggests that the bugs are being created and added to the bugs array. So that doesn't seem like our problem. So let's stop and dig back into this. If we look carefully into this if statement and you have a little bit of intuition then you'll see the problem. The bugs which are instances of a UI image view are not being added to the view after they're created. So technically the bugs exist, but our view's not aware of them. So I'll go ahead and add that in and then let's run one more time. Debugging, and we'll tap. And there we go, the spiders are being spawned on screen as expected. Now, Swift provides two standard protocols, printable and debug printable that can greatly benefit your print debugging. The printable protocol requires a class specify a description property, and the debug printable, not shown here, requires a debug description property. Before we use either of them, let's see how our current print statements are lacking. I've added two print statements that print self when new bugs are being added to the view for this addBugToView method, so one here and one here. And we know the value itself is this instance of the PrintBugViewController class. One might assume that printing self will be a good way to get information about the entire view controller, seems like a perfectly valid assumption. For example, the print statements could tell me the current count of bugs and any data that's specific to this view. But, when I run the app and create some bugs, the default output of this statement is just the name of the class, PrintBugViewController, and the memory address. And this isn't particularly useful but we can do much better than this by implementing the printable and debug printable protocols. So let's stop the app and I'll hide this for a minute and let's scroll down to the bottom. To keep things clean and readable, let's implement these protocols in an extension. For the description, let's return the number of bugs in the bugs array. So you can see for this we need to override the description property. And we must specify, because it's a computer property, that it's string type. And then you simply return string. So we can see that we're returning PrintBugViewController contains the number of bugs in the bugs array. Then for the debug description, let's return the number of bugs and also the positions of each bug. So for this particular description, we will start with the number of bugs again, and then we'll iterate through the bugs array, and for each bug we'll add the bug, index number and its frame information, and then we'll return the entire string. So let's rebuild and run this. And I'll go to print debugging and tap, and now when our print statements are reached, we can see the number of bugs instead of just the name of the class and the memory address. Now, if we want to use, and this right here is our description property, if we want to see the debug description, iInstead of using printLn, stop, we'll use the debugPrintLn. There we go, here, for both of our print statements. One more time. Click, tap, and there we go. Pretty slick, huh? There's still another problem in the Print Debugging scene of the So Many Bugs app. If we tap on the Setting icon, and then we try to set a new bug type, our app crashes. I want you to use the techniques we've described so far to fix this problem. While you're working through the problem, remember the steps of the debugging process. And also pay close attention to any information that's given when the application crashes. Once you fix the problem, check this box. My intuition is that this problem is related to the PrintSettingsViewController. So before we run the app, let's go to the PrintSettingsViewController here. And add a print statement to the bugTypeSelected method. This is the method that get's called when any of the bug type buttons are pressed. And I'll rebuild and run. Print debugging > Settings and select a bug type. And we're still crashing, but from the debug output, we can see that we're at least calling the method because our first print statement is reached and then something goes wrong. In the crash report, it's saying that we have a fatal error and then it unexpectedly found nil, while unwrapping an optional value. If we look at the line causing the error, line 31, we see that there are three unwrapped values. One here, here and here. So let's try printing out each of these before the lines reached. And rebuild and run, going to stop first. Build, there we go. Select the Print Debugging again > Settings > Select, and there's our problem. The current title of the button is Button, and when we try to convert this to an integer in the second print statement on the two int call, It fails. The behavior that we want is for each button title to be an integer which corresponds to a particular bug type, so let's go to the storyboard here. And we're looking at the PrintSettingsViewController. Let me zoom out a little bit so that we can see what we are doing. There we go. So hide this and here are our buttons. So these first four are the ones that we're worried about. Let's change these. We'll go zero for the first because it's a zero index bug type. One, two, and three. And we'll rebuild and run, and let's select a new bug type. And it looks like it worked. But let's do a quick sanity check to really make sure. A sanity check when debugging is a basic test that'll quickly evaluate whether or not the program's working as expected. So since we set the bug type to the blue bug here, we should be able to create blue bugs. There we go, our first blue spider. Try a different type. Green. Red. Here's red. And we're good to go. Before moving on, I want to show you one more useful approach to print debugging. You may have noticed that while print statements can help us solve problems, they're kind of hard to maintain. For example, if we wanted to temporarily remove certain print statements from code, we'd either have to comment them or we'd have to delete them completely. And there is also other considerations. For example, if you wanted to have print statements in some debugging version of your code but then not in the ship version of the code. You'd also have to remove them and this kind of maintenance just gets tedious and one commonly used solution for this is logging. Logging or logging systems and frameworks allow us to write log statements, much like print statements, that can include additional information such as data, function names and the line numbers. And most importantly, you can specify level of severity for each log statement, which will control the actual statements that get printed based on the overarching severity that you've set for your particular application. And I'll show you how this works in just a second. So one such logging framework is Dave Wood's XCGLogger for Swift. And this is the GitHub project for it. I've posted a link in the instructor notes if you're interested. So I've already downloaded the project and I'm going to run the demo application that comes with it. You can see stated at the bottom of the view that the XCGLogger will only log messages that are set for the same or higher log level or you may hear it referred to as a severity level. So the current log level is debug. And if I click this Debug button, we see that the execute debug code block was logged. Because it corresponds to a debug log statement. Let me hide this away so we can see it a little bit better. If I click Info. Info is also log. but if I click Verbose, nothing happens. And the reason that nothing happens is because verbose is a lower level than our current level which is debug, but if I drag it down to verbose, now verbose is executed. So we can play with this again, we'll go up to error, so now error and severe are the only ones that should work, here we go, both of them. The Warning nothing, Info nothing, Debug nothing, Verbose nothing. And it's that simple. If you want to know more feel free to play around with the demo app before moving on. With print debugging, we used individual print statements to examine a program state. And this required us to know what state we were interested in prior to printing it. And we also noted that print statements themselves can be hard to maintain. In practice, there's a better way to debug that offers us the maximum amount of state information available at any given point of execution. I'm talking about breakpoint debugging or debugging by using breakpoints. Breakpoints let developers pause the execution of a program, so they're able to see all the program state available at a point at which the breakpoint was reached. Xcode makes break points extremely easy to use. It only takes one simple click. In fact, you've already probably set some break points by accident, but let's do so on purpose now. Currently, I'm in the BreakpointBugViewController.swiftfile of the SoManyBugs app. I want to know the state of our application when a user taps the screen to create a new spider. And I'll do this by setting a Breakpoint in the handle single tap method. First I'll go down to the method handleSingleTap, and then I can create the breakpoint by clicking in the gutter, left to the main code area. If you accidentally place the breakpoint in the wrong place, you can remove it by clicking and dragging it off like this. But let's go ahead and keep our breakpoint here for now. When you create breakpoints this way by clicking in the gutter next to a line of code, we'd say that we're creating line, or instruction breakpoints. If you can't see the line numbers currently, go to Xcode, and then Preferences. Go to Text Editing and then make sure that you have the checkbox selected next to line numbers. Another way to access the breakpoints that we're setting is by looking at the Breakpoints Navigator in the Navigator side panel. This is the second to last icon in the Navigator panel. Optionally, you can use the key Command Seven hotkey to display the breakpoint navigator. In this view, we can see the breakpoints that we set. So right now we have a breakpoint set in the handle single tap method on line 85. And it's in the breakpointbugviewcontroller.swift file. We can toggle these breakpoints on and off here by clicking on the breakpoint icon. And in the same way in the code, you can click on the break point icon to toggle it on and off. So let's keep this breakpoint active for now, and run the app and see what happens. You'll notice that when I re ran the application, it didn't require us to build again. And that's because break points are created by the debugger itself and they're not part of your application source. On the main screen, I'll select the break point debugging scene. And then, I'll tap the screen to create a spider. As soon as I tap, we're immediately redirected back to Xcode. What's happening? First, don't be alarmed, your application's actually still running. But the execution's been paused at this break point. With your app paused, we can now use Xcode's debugging tools to inspect our code. At the bottom of Xcode, the debug area is revealed, and the bottom is split into two views. We have the variables view on the left, and the console on the right. And you can re-veil the debug area by clicking on this button here. Like so, or by using the hot key Shift + Cmd + Y. Personally, I always like to reveal the debug area when I'm running applications. To enable this feature, go back to X code, and then go to preferences. Go to behaviors, and in behaviors you want to look for running, the running section here, and then look for the Starts option and select it. And then check the box here that says selection, show, debugger with variables and Console views. So like it reads when your application starts running, we'll show the debugger with these two views. With the debug area revealed you can use the two buttons in the bottom right hand corner to hide the variables view, and hide the console view. In the variables view on the left, we can see all the variables that are visible in the current view mode. The default view mode is Auto. Auto shows variables that are currently in scope that the debugger thinks you're most likely interested in, given the context and current line of execution. The other view modes include local variables and all variables, registers, globals, and statics. The local variables view mode shows the variables and arguments that have been declared in the current function or block, as well as the special variable self. Self is also usually displayed in the auto mode and it's an alias to the object whose function or blocks been called. So in this case, self refers to a breakpoint bug viewController. And it contains all the values and properties of this breakpoint bug view controller. The last view mode displays everything. This includes local variables, globals, and even registers. Typically, auto or local view modes will be all that you need when you're debugging. However, this mode's here if you need it. So we'll go back to auto. On the right is the console. And right now the only thing in the console are the letters LLDB in parenthesis. These letters refer to the LLDB debugger or low level debugger. Here, we're able to type any valid LLDB commands. And we'll talk more in depth about these commands and LLDB later in the course. Back in the main area, we've already seen that we can toggle our breakpoints on and off. So this time let's set this breakpoint inactive, and then click on this button here in the debugging bar to continue the program's execution. Once the app becomes active, I'll tap the screen, and this time the execution doesn't pause when I tap on the screen because the Breakpoint's disabled. But you've probably also noticed there's a problem. Our spiders are not appearing on the screen again. And to figure out why we have this problem, we'll make use of breakpoints, the variables view, and something called a stack frame next. Right now we have the same problem as we did before, where spiders are not appearing on the screen when we tap. We're already able to reproduce the problem by tapping on the screen. So the first step of our debugging process is complete. So let's begin gathering information about the problem at the most likely candidate for what could be causing this, the handleSingleTap method. So instead of our print statement, we'll use our Breakpoint here. And if handleSingleTap is called at any point then our Breakpoint should pause the execution of the app when it reaches this method. But if handleSingleTap is not being called then the Breakpoint will never be triggered and our app will not pause. So we'll run our app and as we saw a second ago, when we tap we are reaching the Breakpoint. So it does work. That was more of just a verification step in how you might work through the problem if you were starting from a clean slate. So let's talk more about what Xcode is displaying to us when our application's paused. Right now on the left side in the navigator panel we're seeing the Debug Navigator. If you don't see if right away, you can use the hot key, Cmd+6. In the Debug Navigator, the first thing we see are gauges which represent the CPU, memory, disk and network usage. You can toggle the gauges on and off by clicking this icon here. If you click on any of the gauges, you'll get some really valuable insight about of the app's resource usage. But we're not going to focus on those diagnostics in this course. So let's go ahead and turn the gauges off for now. The next thing that we see is a list of threads associated with our running application. So right now we have one, two, three, four, five, six threads. And the thread that's handling the code where the Breakpoint was triggered is Thread 1. We can see that by this arrow here. If we look at the drop down list under this thread, we'll see what's known as a stack trace. It's also commonly referred to as a call stack or the back trace. A stack trace is a report of all the available stack frames which lead up to a point of execution. And yes, as the name implies, the stack trace is literally a stack like structure where stack frames are pushed and popped off of the stack. In each stack frame, that's what we're seeing in these lines here, is a record of all the program state available at the point in which the frame was active. So typically there are stacked frames for each time a method or a function is invoked. In each frame with black text includes code that we've written while everything else, these gray ones, is either library code or some other framework. Where we don't have access to the actual source. So if you look at this full stack trace, we can see that we're currently examining the state available when we called the handleSingleTap method. So, go ahead and tap on that. And we'll drag back. And the state that we can see includes what's present here and the variables view. So if we look we have a UiTapGestureRecognizer that's in scope. And we have the BreakpointBugViewController. If we click down on the UiTapGestureRecognizer, we can see its current property values. You'll notice that Xcode tries its best to display the values in a format that we can understand as developers. So for some properties, like this _ButtonType, we see that it's value is currently 0. And for other values like the _Imp, we see a raw memory address. Now you may be thinking to yourself, what am I going to do with the memory address? I mean it's just a raw address that's not very useful. But there's actually a couple things that you can do. I'm going to show you some of those later in the course. Right now let's just focus on what we've learned from this Breakpoint. We know that the handleSingleTap method is being reached when we tap the screen. And if we look at the stack trace, we see that our method handleSingleTap is indeed being called. And if we click on the main stack frame, we can see that the main application. Or the app delegate, I'm sorry. Is in sub class of UIResponder. And it appears that this particular class is sending an action. Some kind of gesture. To our BreakpointBugViewController. And if you didn't catch that, I can jump around between the frames by just clicking on them. You can see the variables update based on the context for that particular stack frame. And this is a really powerful way to debug. It allows us to, by clicking, trace the steps which led to our particular error, or to our particular Breakpoint. I'll go ahead and stop because I want to show you one more thing. Let's disable this break point in the handle single tap method, and let's go ahead and add a break point if we scroll up a little bit to the- here we go, add bug to view method on line 33. And I'll run the app again. I'll tap the Breakpoint Debugging scene, and then tap on the screen. Now this time, our stack trace includes stack frames for both addBugToView(), here at the top, and handleSingleTap. And you'll notice again as I click through these stack frames, the information that's available in the variables view changes. And that's because each stack frame contains different state, which was available to it at the time it was reached. So in the handleSingleTap, we have the recognizer and self, and then the add bug to view. We just have self and then this new bug, and remember, you can always switch this view mode to see additional information. So let's go ahead and focus on self, which is an instance of the break point bug view controller. If you click the dropdown, we can see that it has a reference called bugFactory, it's a reference to a BugFactory object, and that it has a value for maxBugs, which is currently 0, moveDuration, a disperseDuration, and then our array of bugs. And that's an array of UIimageviews. We also see our current values. And if you look closely, you may already see what's causing some of our problem. Currently, max bugs is set to zero and the bugs array also contains zero values. This means that this if block will not execute because account of the bugs array is zero, and that is not less than the value of max bugs, which is also zero. This sounds like a valid hypothesis. But how can we be so sure? Well with breakpoints, we can actually test the hypothesis. Breakpoints not only allow us to pause the execution of our apps, but we can actually run our apps step by step or line by line. And this is going to allow us to see if the if block is actually being entered or not, and we'll do this next. It's time for us to step through some code using breakpoints. Currently we're in the breakpoint bug view controller and we have a single breakpoint set in the addBugToView method. As we've seen before we can set breakpoints like this on individual lines of code. And if the breakpoint's reached then our app will go into a paused state. And from here the application's technically running, but we have the power to execute our app line by line. And this is what is known as stepping through code. You can think of stepping through code like having fine grain control over the execution of your program. So lets go ahead and run the application and trigger this breakpoint. So go to the breakpoint and debugging scene and tap the screen. There we go. And now our breakpoint's reached. The debug area appears, and we can focus our attention to the horizontal debug bar, here, that runs across the top of the debug area. On the far left there's a button for hiding and revealing the debug area. The next button, called the Breakpoint Activation button, looks like a smaller version of the breakpoint arrow that we seen before. And if we click it, then it will toggle all the currently enabled breakpoints as either on or off. So it's kind of like a global state for active break points. Note that any breakpoints that are currently disabled when you click this button are not going to be effected. So it only works with active breakpoints, and we can demonstrate this if I set a break point here on the moveBugsAnimation line. I'll keep it inactive, and then we'll toggle this button. Now they both go grey but when I go back and the global state is active, only our previously active breakpoints are actually enabled by this. This inactive breakpoint is not affected. We can drag this off, we don't need it for now. The next button on the bar is for continuing the programs execution. The hotkey for this button is control command y, you may be using this one pretty often. And if we click it then our app will resume like so. So let's tap the screen again and we'll reach the breakpoint again. The next three buttons are also related to execution control, and they're called Step Over, Step Into and Step Out. You will really want to become comfortable with these buttons because they are most frequently used when you are debugging. And we'll get back to them in just a moment. Continuing right, we have a button for the debug view hierarchy which allows us to debug our apps visually. And we're going to talk more about it in the next lesson. And then next, we have this arrow which will allow us to simulate a location. And we're not going to use this button for this particular course. The last three pieces of the tool bar are called the jump bar and they're similar to what we saw earlier in the debug navigator. So let's give our self some more space first, there we go. So the first element of the jump bar is the current process. And if we select so many bugs, the current process. Then we could see all the different threads in this process. And then from there we can jump to the different stack frames within a particular thread. Now at the top level this might be really useful if you're debugging two processes at the same time, like a client and a server. If you want to investigate multiple processes simultaneously it's a little bit advanced, but Apple has a great example in their 2012 WWDC video called Debugging in XCode. And I posted a link to this particular session that they recorded in the instructor notes if you're interested. The second element in the jump bar is the currently selected thread. If you click this element, just like we saw a second ago, we can jump between threads and the thread stack frames. And then the final element is the current stack frame. All right, so that was the quick and dirty tour of the debug bar. Let's talk about stepping through our code. Right now, we believe that spiders are not being drawn to the screen because the max bug value is set to zero, and this is keeping us from actually entering the if block that creates spiders. So if we use Step Over, we can find out if this is really true. What Step Over is going to allow us to do is execute the current line of code as if it were a black box. By black box, I mean you don't know what's going on inside of the box, or inside of the line of code that you're executing. You just see what happens on the outside, or as a result. So, you might see the return value of the function or the result of the computation for this particular line of code. For example, if line 33 happened to be a function call, then by clicking Step Over we will not go inside of the function, it'll just go ahead and try and execute the function. So I'll click Step Over, and it runs the current line of code. So with the green arrow at the final closing brace, this is indicative that the function is, or the method is, ready to return. So let's stop the app now and change our max bug values to 100. Scroll up. There's max bugs. Change it to 100. And let's rebuild and run the app again. Go to the break point debugging scene and we'll tap. And let's click Step Over. Or instead of clicking the button each time, you can use the hot key, F6. This time Stepping Over drops us right into the if block. So with our change, we've insured that we've at least entered the if block. The next button we want to talk about is Step Into. Step Into allows us to step inside or into a function call in order to examine it's execution. The hot key for Step Into is F7. So let's step inside this line to see what's happening when we call the bug factories create bug method. And we can see that X code that automatically redirects us to the bug factory's create bug method. And we can step through this method line by line using Step Over. Now it's going to be a lot of Step Overs, because this particular method has a lot of lines in it. And if this method was hundreds of lines long, then stepping through each line would get kind of tedious. So that's why our third button Step Out exists. Step Out will jump us all the way out of the current function, in this case the function method create bug. The hot key for Stepping Out is F8. Once we step out of create bug, notice that our new bug now has a memory address. And by the fact that it shows a memory address, we can assume that a bug was created and it contains some properties. So let's go ahead and click the continue button to see what happens. Hmm, now that's weird. When we try to click continue, it appears that we've hit the create bug or the add bug to view break point again. And this suggests that we may be creating multiple bugs each time the user tabs. So this is actually a separate problem and we're going to address it later using another debugging tool. For now, let's just stop the program and, if you remember from the print and debugging example, in this example, I'm also neglecting to add bugs to the view after they're created. So let's go ahead and add that back. And let's disable this break point. And I did that by right clicking. You can right click as well, or just toggle. And let's play. I'll tap and it's a little laggy and whoa, okay. So I knew this was going to happen because I looked at it ahead of time, but we have an issue here and we're creating way too many spiders. That's actually kind of neat, I think some people may be inclined to call this a feature. But all jokes aside, this is another bug. For now, let's leave the app in this broken state, and we'll get some more practice stepping through our code. In the break point debugging scene, we currently have way too many spiders being created when a user taps the screen. But there's another more pressing problem that I want you to solve using break points. If we tap the settings icon from the main view, we should be able to set the spider type that we want to spawn on the screen. However, if I tap any of the spider icons or even the back arrow here, the settings view doesn't dismiss. We're just stuck. I want you to solve this problem using breakpoints. As you work through the problem, write the steps that you take to debug it in this text box. And when you're done you can compare your steps with mine. Now while you may not go the same way solving the problem that I did, it's always really useful to see other's perspectives for solving the same problem. Here's how I solved the problem. Since I know the settings view is an instance of the breakpointsettingsviewcontroller, I'll start by examining that swift file. And if I look over the class, my guess is, is that the problem could be occurring in both the dismissSettingsTouched or even the bugTypeSelected methods. One of these two. But to be sure, let's set a breakpoint in each of these methods to make sure that they are actually being called first. Set the breakpoints and I'll go back to the app > run it > breakpoint debugging > go to settings > and I'll tap the red spider. And we dropped right into the bug type selected method. So, it's a little strange. If this methods being called, then why is the view itself not being dismissed? because it has it's call to dismiss view controller animated. Well one thing I do know is that if this method dismiss view controller animator is being called, it's not causing any type of crash. So it's being called without any side effects. So that's not the worst thing that can happen, but by the fact that we're not dismissing the view, we still have a bug. So let's read a little bit more about this method and see if it tells us anything. If I hold down the option key and then click the methods name, then Xcode will display a pop-up describing the method. And it says that the method dismisses the ViewController that was presented modally by the receiver. That sounds reasonable, but we can dig a little bit further. I will click the UIViewController Class Reference to open up the docs about this particular class. And here I can search and read more about this particular, where are we, dismissViewControllerAnimated. Now while I'm searching for this, I also want to make sure that everyone knows you can find this information online or your could use a documentation tool like Dash. Dash is a wildly used documentation viewer. It's useful for other languages other than just Swift and frameworks like the IOS frameworks and such, and I posted a link to the Dash website, and the instructor notes if you're interested. Now if I go to the dismiss view controller and scroll down to the Discussion area. You can see that it mentions that if you call this method on the presented view controller itself, it automatically forwards the message to the presenting view controller. Now this kind of makes me curious. Which view controller is actually presenting the settings view? So we'll go back to our code, and we'll look at the self in the variables view because self is what we're using to make this dismissViewControllerAnimated call. In the Search box of the variables view, I'll type in the word viewController to filter our results. Here if we click through the drop downs, we can see that it has a parent view controller, maybe that's it, it says UI navigation controller. But, I also know based on the quick description that we read, it mentioned something about presenting things modally. And our parent modal view controller is currently set to 0X0, which is really just a special address meaning null or nil. So let's go over to the story board and see how this thing is being presented. Zoom out a little bit, and if we look at the breakpoint bug view controller, see that it has a segue here. And the segue that's presenting this is a show segue which is not quite right. This should be a modal segue based on what we're reading. In order for it to work correctly with the self dismiss view controller animated method that we saw. So let's try changing this to modal. You may have caught on too if you can see the icons here are different. So like the icon for the previous one which worked fine was modal or we can assume that it's because of this present modally. If we made it show and made it modal. There we go. So this seems like it may be our fix, and we'll go ahead and try it. So now, if I go to settings, I'll tap one of the bugs. What has happened? Okay, we still have one of our breakpoints actives, so let's make these inactive. Sorry, I'm hiding a lot of different things here. Just try to get my environment the way I want it. And we'll click continue. And it looked like it dismissed just fine. Try that again. And it looks like we've found and fixed our problem. Now, before we move ahead, I want you to ask yourself how hard is might've been if we used only print statements. You'd see that breakpoints and also a good skimming of the documentation can give us a lot more power and flexibility to solve our problems than the print statements that we use by themselves. Also, anytime you're handed a new project, using breakpoints like this to step through each line of code is a really good way to understand how something works. Now that we're getting more comfortable stepping through code, I want to take another look at stack traces in the Debug Navigator. First, let's start with the BugFactory.swift file, and I want you to set a break point at line 26 in the beginning of the createBug method. Then run the app and examine the stack traces that are produced when this specific breakpoint is hit. By examining those stack traces, you should be able to answer the following question. In the breakpoint debugging scene of SoManyBugs, how is the createBug method being called? Is the method being called when we handle a tap, when we handle a tap and when we animate the bugs, when we handle a tap and when the BreakpointBugViewController initializes, or only when the BreakpointBugViewController initializes? Mark the best answer to complete the quiz. The correct answer is when we handle a tap and when we animate the bugs. Let's see how we can use Stack Traces to prove it. I already have a breakpoint set and the create bug method of the bug factory class. And we'll run the application. I'll select the breakpoint debugging scene, and then Alt+tab on screen. And as we can see from the stack traces, the createBug method is being called by addBugToView, which in turn was called by handleSingleTap, and the breakpointBugViewController. So we know that create bug is called when we tap. But what about when we animate? If we continue the app's execution, we're dropped right back into the same breakpoint, and we can see that the stack frames have changed. This time it looks like we're calling adbug to view again, which in turns calling create bug. If we keep clicking Continue, the stack frames just keep increasing. And the culprit seems to be the move bugs to animation method. If we click on it, then we can see that after bugs finish animating here in the UIView.animateWithDuration, we have the other add bug to view call. This probably explains why so many spiders are being drawn to the screen. For now we're going to leave this call here, even though it's not the behavior that we want, because in the next lesson, I'm going to show you another way to troubleshoot this same problem. As we've used break points, there are a few icons that you may have noticed here in the variables view that I haven't explained yet. I'm talking about these icons here, the A, the L, and there's other ones that we're not seeing right now for this particular case. These icons here are actually pretty straight forward. And while I could simply tell you what they are, there's a much better way for you to learn this information. I'm here at Apple's WWDC 2012 Session Videos. And if we scroll down, I want to look at the Debugging in Xcode video. In this particular session, Apple's own engineers describe each of the icons that we see back in Xcode here. While the session itself is a little dated, the content is still extremely relevant. This particular session contains a lot of valuable information about Breakpoints. It also contains information about Breakpoint actions, which we'll cover later in the course, and other debugging features in Xcode. You can watch the entire session in the browser. I know it works in Safari. It may not work in some of the other browsers. Or you can download the session itself and skip ahead to the particular segment that'll help you with this quiz. And I've posted a link to this page in the instructor notes. And like I said, it's not required that you watch the entire session to complete the quiz, but I would really encourage you watch this entire video and really any of Apple's WWDC sessions because they're such a great source for iOS developers. And the best part about it is that Apple makes all of their previously recorded WWDC sessions available online for free and I posted a link to where you can access all those as well in the instructor notes. So with that in mind. Watch the video and then matched the following icons to their correct variable kind. And by variable kind, that's the term that Apple uses to describe what these labels are. They relate to a variable kind. Your choices are instance/global variable. Local variable. Static variable. Argument. Expression. And register. Next to each of the icons, write the number corresponding to your choice. Starting with the E icon, the correct answer is five. It represents an expression. The S icon stands for static variable, three. The A icon, four for argument. The V icon stands for instance, or global variable, one. The R icon is register, six, and the L icon stands for local variable. So, if you see any of these icons in the variables view, now you know what kind of variable they're referring to. Before we move on to more advanced debugging tools, I want to talk about what you can do when you're facing a bug that you can't solve. And there are a couple possibilities. It could be the case that there's actually a problem with Apple's code and this can be especially true when you're using SDK's that were recently released or changed. And if this happens, you'll want to file a bug report with Apple. Developers in the community will commonly refer to this as filing a Radar. And Radar is Apple's bug reporting system. I've posted a link in the instructor notes with instructions on how to use Radar. Besides Apple's code, there can also be problems with third-party frameworks you're using in your application. If there are problems with a third-party framework, then you're going to have to contact the third-party framework that you're using to resolve any issues. And this can be difficult depending on the level of support and responsiveness of the third party. That is why it's so important that you make sure that you use well-trusted and well-maintained third-party frameworks. So before you get started even using a framework, that's why it's a good idea to go take a look at their repository, see if it's been updated recently, see if people are talking about it. If it looks like they have a good support system. If they have maybe a website that you can go to and request help or file a bug report. Those are the types of things that you want to look for. Another possibility is that the problem you're trying to resolve is a result of poorly designed code, or a case when you're trying to solve a problem in a less than ideal way. And this occurs actually more often than most of us are willing to admit. But if you do find yourself in a situation like this, it's probably best to either rewrite or refactor your code so that the problem is avoided entirely. At any rate, if you're stuck on bugs like these, you may find yourself needing to explain a bug to someone else that can help. But that should be your last resort. The more bugs that you can solve on your own, the less time you'll spend debugging and the more time you'll spend developing. But, if you do need help, one common place you can go is Stack Overflow. If you've not use Stack Overflow before, it's a question and answer site for professionals and enthusiast programmers. I posted a link in the instructor notes if you need to go check it out. When you're sharing a bug on Stack Overflow or anywhere else, you want to be as specific as possible. Make sure that you're using all the correct terminology, and that you avoid being ambiguous or confusing in any of the wording that you use. It's also extremely useful to provide a list of explicit steps for how to reproduce the error. This can be as textual scriptions or even gif images. And personally I enjoy gif images where possible. If you're interested, I've posted another link in the instructor notes for a tool that you can use to easily create gif images on your own. Either way, the key thing to remember is that when you're sharing a bug, you want to empower somebody to reproduce the error. If they can't reproduce the error, then they'll be very limited in the type of help that they can provide. In this lesson, we use print debugging and break point debugging to get a glimpse of what was happening at the moment a bug occurred. This helped us to form opinions about what was wrong and how to fix them. In the next lesson, we'll dig deeper into Xcode tools for debugging our code. We'll talk about the LLDB debugger, breakpoint actions, the debug view hierarchy, and more. Remember the key to being a good debugger is being a good investigator. In that way, debugging is a lot like solving code mysteries. And to solve code mysteries we need the right tools to gather evidence and fix them. Xcode has many tools for debugging code. And so far we've scratched the surface. In this lesson, we'll learn how to use the LLDB debugger. And breakpoint actions to examine, and even execute code while we debug. We'll look at some of the newer tools like the debug view hierarchy. And QuickLooks that will also give us more visual debugging information. It'll be a lot of fun. And by the end, you'll be wondering why you haven't been using these tools. Every time you've encountered a bug. So without further ado, let's get started with the debugging super tool, LLDB. When we're clicking around in Xcode setting break points and debugging code, it's easy to forget the main tool behind the scenes doing all the heavy lifting. I'm talking about the LLDB debugger. The LLDB Debugger, or the low level debugger is what actually allows us to set break points, step through code, and see the state while the app is running. Normally we interact with LLDB using Xcode's graphical interface, but LLDB also has a powerful command-line interface too. The LLDB command-line interface is what you see here in the console of the debug area. It has many commands, such as fr v, which is short for the command frame, and the sub command variable. The command fr v shows us all the arguments and local variables that are currently in scope. So we can see that we have self, we have bug, we have a shakeAnimation. And if we look at the variables view, this is the same information that's available to use here in a more graphical format as opposed to this textual format here in the console. And I'll type the same command, this is just the shortened version, the fr v, this is the full version and we get the same results. Now the entire LLDB command set is rather large, so instead of showing you each command, I'm just going to focus on some of the most commonly used ones. If you want to dive deeper into LLDB and learn things like custom data formatters or writing scripts for LLDB then you can check out the resources in the instructor notes. We've seen the basic first sub command for frame called variable. But LODB's frame command can do much more than this. To demonstrate on back in the semi bug zap, and were paused at the handle single tap method that we've seen before. And this is in the break point bug view controller. >From the console, we can look up information about LLDB commands including frame, by typing Help. So I'll delete this and type Help and I'll just go ahead and scroll through all this, so you can see the entire output. We have all the commands and then there are command abbreviations. Like the FR and the V that we saw earlier. That you can see for the different commands. And I'll stop here for a frame. And here's the information we have. It says that frame provides a set of commands for operating on the current thread's frames. And by frames, it means stack frames. So to get more specific help information about frame, I can type the command frame followed by help. This delete button clears out the console, by the way. So that's what I clicked to do that. We'll go frame help. And now we can see that frame supports the following subcommands. So there's the variable command that we used earlier, but it also supports info and select. And at the bottom, it says, for help on any particular subcommand we can type help command and then the subcommand. So for example, help frame variable, should give us the help information about the variable subcommand. Well we've already seen the variable subcommand, so I want to try the two others. So I've stopped the application, and I've kind of reset up our debugging environment here. I've set a breakpoint at the add bug to view method. And there are no other breakpoints in the particular app. And this is for the BreakpointBugViewController. And I've triggered this breakpoint again by just tapping on the screen. So let's type, frame info. And we could see that the output shows that the current frame is frame zero, and this is for the addBugToView method. And this mirrors what we have in the debug navigator, which is frame zero, and frame zero is for the add bug to view method. And to switch the current stack frame, we can use the frame select subcommand followed by a frame number, so I'll select frame one. And just like that, Xcode jumps us to stack frame one, which is for handleSingleTap, here. And you can see that it's jumped us here in the code area as well. And this is pretty neat. It's not really that much different than what we can achieve by just clicking around in the debug navigator, which you can do the same thing here in the console, by just selecting different frames. So now it's really unleashed the power of the command line, to do something that you can't already do in the graphical interface. And we'll do this with the expression command. The expression command, let's us run swift expressions in the current debugging context. So this is actually really cool. This means, we can do things like run methods. Or even change the values of variables while our program is paused. So I'll start typing the command expr, which is an abbreviation for expression, followed by println. And bugs, so this is just like the println statement that we could put in our code. You can see that currently bugs is empty. So I'll go ahead and just continue a couple times, so that bugs contains some things. And actually, I'll turn this off, this breakpoint off, hit play so it runs all the way through. We should have way to many bugs now. Turn the breakpoint back on. I'll reach again. Let's run the same expression. And see the our bugs array is very full, now that we have all those extra bugs, that have been created. So that first expression for just printing, that's pretty cool. But let's try something a little bit more fun. We can actually empty the bugs array. So to do this, we'll use expression self.bugs.removeAll. And this takes a argument, keepCapacity. And we'll specify this is true and we'll hit enter. And now when I run this expression, it appears that it's completed, but we don't see any updates visually, if we go back to the simulator there's nothing here. This makes sense because we're paused at the breakpoint, after all. Because we're paused, none of these changes have taken effect, but if the expression did run we could quickly check while we're paused by printing the bug's array again. And we can see that it's now empty. And if we were to step over, we'll see that we drop right into the if statement, which also further validates that the bugs count is now zero, or the bugs array is empty. And that is less than the maximum bugs, so now we're dropping right back into that if statement. So we were able to change things on the fly to alter the execution of our program. That's pretty cool. And I'll hit play and continue back and there you go. More bugs are created. And I'll get us back to a known state. Well, there we go. Now, the next command that I want to show you is print object. And print object displays a description of an object that you specified. And the output that you'll get is similar to what would happen if you used the expression command and then use print LN, like we just saw. Now, the abbreviation for print object can all be done with PO, instead of just P, space, O, it's all PO. And we'll run this for the bugs array. And we can see that it is empty again. Now let's try running PO for self. And this time, LLDB does its best to give us description, just like we saw earlier when we were implementing printable and debug printable. But because those things are not implemented, this is the best it can do so it gives us the type, breakpoint bug view controller, and the address. Now if we were to implement printable and debug printable, like we saw earlier, then when we use the PO command, LLDB will choose the most specific protocol and show that description. So, Debug printable is considered more specific than printable. So if Debug printable was implemented, it would show it. If printable is the only thing implemented, then PO would just display the printable description. So, we'll show that as an example real quick. I'll stop, and we'll go to the bottom of this file. And let's implement these protocols in an extension. And now that we've implemented both the Printable and DebugPrintable protocols, let's try printing out self again. And we see that because debugDescription is the more specific, or DebugPrintable is the more specific protocol, that's what's used. So, hello from DebugPrintable. And I'll stop, and let's comment this out, and only implement Printable. Let's bring back up the same situation. Now, if we PO self, we get hello from Printable. So, that was pretty cool, but now I really want to show off the flexibility of the command line interface. This next example's going to be a little advanced, so don't worry if you don't follow everything the first time I show it to you. We're going to use it again in an example later in the lesson. So, to start, what I've done is kind of set us up again. We're in the add bug to view, and we have a breakpoint set that we've reached, and I've already allowed it to run so that all these bugs were created, and then I've triggered it again by tapping when the breakpoint was active. And the reason that I did that was I wanted to be able to print out the bug object. And you can see all these image views here, and we're going to use one of these raw addresses. So, I'm going to copy this for later use, and let's go ahead and clear this out. Make sure it's copied. Okay, there we go. So, we're going to start with the expression command, but this time, we're going to use Swift's unsafe Bitcast function. And the unsafe Bitcast function, it's going to allow us to convert the raw address into an object that we can actually interact with. And this might be really useful in cases where you have the memory address for an object, but you're unable to access its properties and values. So, let's see. Can I actually look at bugs? There's one of them. And yeah, we can interact with some of it. But let's imagine that we couldn't. And there are cases where this will be handy. So, here's how it can be used. The first argument is going to be our raw address. And this is the raw address that we saw earlier for one of our bugs, in the bugs array. And we know that this address refers to a UIImageView, because that's what is contained in the bugs array. And so, for the first argument we have the raw address, and then in the second argument we have the UIImageView.self), which is going to allow us to cast the address into a UI image view object. And we'll hit enter. So boom, there we go. LLDB has just converted our raw address into a UI image view object and it's even stored it into a temporary variable called $R4. Now, if we wanted to instead use our own variable name instead of the $R4, or whatever it ends up assigning it, we can instead run the same expression, and we'll use let $bug1. You need to do use the $, that's special for the console debugger here. Hit Enter, and now, if we run the expression println with our variable, there we go. So, notice here the print output is the exact same output that we would get if we print out bugs, or we scroll up to the top, lot of bugs here. Here we go, so, for the first one, I think it stops right there. There's our first UIImageView, and this matches exactly the UI image view here that's now contained in the variable above one. And I can even change bug one's values. So we'll run another expression, so we'll say $bug1.frame = CGRect. And let's print this guy back out. And there we can see that the frame has now been updated to have X and Y of 0, and a width and height of 64. And because we know that bug one refers to the same thing as the first bug in the array, if we are to print out the bug's array, we should see the same thing. And there we go. So the frame for the first bug, (0 0; 64 64). Now, again, don't worry if this example is kind of hard to follow at first. We're going to demonstrate using this again later in the lesson. Get more comfortable with the LLDB command line. You're going to have to dive right into the documentation and just start playing with things yourself. In the instructions notes I've linked to the LLDB documentation. And I want you to use it to answer the following questions for the so many bugs app. So what we want to know is, what LLDB command will set a break point on line 26 of the BugFactory.swift file? We want to know what command will set a breakpoint on all Swift methods whose selector is viewDidLoad. And if you don't know what a selector is, a selector is another word for the. So viewDidLoad, that'll correspond to say the viewDidLoad and UI view controller, the base class, but it'll also refer to the viewDidLoad that we've implemented in the break point bug view controller, or any sub classes of UI view controller. Next, what command will list all the breakpoints that are currently set for application, and what command will show the stack trace for all threads? So I want you to experiment in X code and write your answers in the boxes next to each of these questions. Note, for all of my answers I'm using the non abbreviated commands and their options, so your answers may not exactly match mine and that's okay. The most important thing here is that we get the same outcomes, and you get practice using the command line and the documentation for it. So go ahead and attempt the problems and then check to see if your answers behave the same way as mine. So to set break points in the command line we'll use the LLDB's breakpoint command. And for the first question, which sets a line breakpoint, I've used breakpoint set and then I specified the file option and for the file, BugFactory.swift, and for the line option, line 26. So the whole command looks like this. Next to set a breakpoint using a selector, we use the breakpoint set command again but this time we use a selector option and for the selector option we're passing the value viewDidLoad. This as we'll see shortly creates what's known as a symbolic breakpoint, because it matches on a symbol In this case a selector instead of a line. And the selector we are interested in is viewDidLoad so the full command looks like this. And note that because viewDidLoad does not take any arguments, we're just writing the name by itself. However for a method like viewWillAppear, which takes a parameter. The selector is going to include a colon, so it would be like you will appear colon and that's because it has a parameter. That's what the selector would look like for that particular method. And if you're unsure at all about how to specify selector then you can always go to Apple's documentation because they use the selectors everywhere in the documentation. So for example I"m in the UI view controller classes documentation and we can see, go up a little bit here's our viewDidLoad selector. And notice it does not have a color or anything it's just viewDidLoad. This minus symbol here represents that it is an instance method belong to an instance of UI View controllers, not a class method. And if we scroll further down we'd see for instance view will appear. And it takes a colon and that colon exists because it has a parameter for animated or if you have a method that's got multiple arguments, see if you can find one. Here we go, begin appearance transition we can see that it's selector has two colons, it's got a colon for the first parameter Is appearing and a con for the second parameter animated. Next, a list all breakpoints, we use breakpoint lists. And to show the stack trace for all threads we use thread backtrace all. Let's go ahead and see these commands in action. I'm back in Xcode again and we're paused at the handleSingleTap method for the BreakpointBugViewController. And I'll go ahead and run our first command that we saw. So, breakpoint set --file, we'll use BugFactory.swift. And a line, line 26, and hit Enter. And when I hit Enter, you'll notice that it assigns the breakpoint a number. This is going to be Breakpoint 2, but it doesn't change anything in Xcode UI. If we actually go to Debug Factory, we don't see a breakpoint here on line 26. And that's okay, the breakpoint actually does exist. It just exists in the console session and the UI does not update. Maybe that's something they'll add later. But, for now, just know that your breakpoint does exist, and if we hit continue, and continue the application, we can see that we've dropped in, and that we've hit Breakpoint 2. Now, for the next command, we'll do our, here, let me clear out again. We'll use breakpoint set, and this time we'll pass the selector option, and viewDidLoad. So this is a little strange. It says that our Breakpoint 3 is 23 locations. And that's a lot of breakpoints. But that's kind of the point. Setting breakpoints on selectors manually would be very tedious. So, you can imagine if we had, say, 23 view controllers, we would have to click through each file, so print, see the PrintBugViewController, and go to viewDidLoad and set it here, but I'm not going to do that right now. We'd have to do it for this one, and so on, and so forth. So this saves us a lot of time. And this is another good reason to know how to use the command line. So let's continue the app and see if we reach one of the 23 breakpoints. We're still stuck in createBug. Oh that's right, that's because we're creating way too many bugs. So before we can continue, we need to disable this or else I'm going to have to hit play a bunch of times. So since there's no UI element to actually disable this, we're going to have to do it through the command line. So I'll type breakpoint. And there's a subcommand disable. And then we pass in the number of the breakpoint. So breakpoint 2. And this should disable our breakpoint. And now we'll hit play. And should be back, there we go. So we're back at the running state. And, so to trigger any of the viewDidLoad breakpoints that we set, we're going to have to load a new view. So let's go back to the main view, and then go to the Breakpoint Bugging to view again. And it's stopped us on Breakpoint 3. And if we pull back a little bit we can see that stack frame one is that viewDidLoad. It indeed did drop us in into a viewDidLoad breakpoint. So let's demonstrate the last two from this exercise. We'll go back to the breakpoint BugViewController and let's add a breakpoint to the addBugToView method. We'll hit play. There we go. Let's clear this out. So now we'll do breakpoint list. Breakpoint list. Let's drag this up, see everything we're looking at. So our first breakpoint. Set and BreakpointBugViewController on handleSingleTap. Then we have the line breakpoint that we set from line 26. And then here's the viewDidLoad selector so we can see that it's set a bunch. We have a bunch of different viewDidLoads for all these different UI kit classes. So that's pretty cool. And oops. There's one other thing I want to show. This is actually another really neat thing you can see, hit count. So it actually shows us how many times we've reached a certain breakpoint. So this could be really useful information, you can imagine that in certain cases you might want to know this. And for the last command we'll do thread backtrace all. And this is the command-line equivalent of all the stack trace information that we have available to us over here in the navigator. So we can see for thread 1, we have, there should be frame 0, 1, 2, and then 17. Oh wow, it shows us even more information. Okay. Maybe that's because I don't have all our options here. Nope, wrong option. So I believe there's an option to show, there we go. This will show only stack frames with debug symbols and between libraries. So, we don't have symbols for these particular frames, but we can see way more information with this particular icon unclicked. And then for thread 2, open him up. We have frames 0, 1, and 2. And the next thread, thread 8, we have 0, 1, and 2 as well. I think that's going to be the same, yep, for thread 9. We just demonstrated some powerful LLDB commands and each of the commands is now another tool that you can use when your paused at a break point. I hope you're beginning to see a pattern in how we can use break points and tools together. That is, that we can set breakpoints, and then we can get our apps to reach break points, and then we can use tools to examine our applications while they're paused. But there are also some other interesting ways that we can edit the very nature of a breakpoint so that it doesn't necessarily pause an application. For example, we can modify breakpoints so that they only pause in certain circumstances, like only pause after the 10th bug is created, instead of just the first bug. Or we can make breakpoints that don't pause the applications at all, instead they can perform some behavior and then just let the application continue running. For instance, don't pause, play a sound. To achieve these kinds of behaviors, we'll use breakpoint actions, and specifically that's what breakpoint actions are, they're behaviors that are triggered when a breakpoint is reached. So to demonstrate, I'm going to start in the breakpoint navigator and right now we have no breakpoints. I've removed the ones that we had, but let's add one for the add bug to view. There we go, so now it shows up. And if we right click a breakpoint, then a context menu pops up and we can select this option to edit the breakpoint. And here's where the fun happens. But before we add and action or a breakpoint action, let's work with the other fields first. So we see this condition field at the top and this allows up to specify a condition that must be true in order for a breakpoint to be active. For this breakpoint let's specify that the count of the bug's array must be greater than three before the breakpoint is triggered. And to do this, I'll type in the expression bugs.count is greater than three, and we'll hit enter. And let's go ahead and run the application. And stopped. If we look down in bugs, we can see that we have four image views. So the bugs are greater than three and our breakpoint has now been triggered. So let's stop this and go back and edit our breakpoint again. And I'll clear the condition and this time let's set the ignore times before stopping value. We'll make it two and rerun the app, tap the screen, and there we go. It ignored it the first two times, and created two bugs, and now we're on the third iteration through, and about to create our third bug. Let's stop this one more time. Go back to the breakpoint navigator and edit again. So we'll make sure this is zero and this time let's select this check box that says, automatically continue after evaluating actions. I'll run this again and when we click, it appears that the break point has been skipped. However, that's not exactly the case. It only looks like the breakpoint's being skipped. What's happening, is because there are no break point actions specified, the breakpoint was triggered, but then immediately evaluated zero actions and continued. So if we add an action, we can prove that something else should have happened. So we'll click edit and the first action type that we'll look at is the debug or command action. This includes a text field for entering any valid commands that we could use at the LLDB command line interface. So we'll do our PO command we saw earlier, print out bugs, then run. Then we can see that it's evaluating, it's evaluating a lot because we're creating a lot of bugs, but then it should just fall through our breakpoint, it has never paused our application. It is taking more time to actually execute though because it has to run the actions. So we can really see our problem now because with one tap way more than one bug was being created, and we kept seeing the contents of this update over and over again. So let's stop and see if we can see this problem another way. So go back and edit. And this time we're going to add a new breakpoint action, so we click the plus and let's choose sound and we'll keep it this default bottle sound and run again. Let me turn on, make sure we can hear this. [SOUND] And now, we can hear the problem too. So each time a bug was added to the view, the breakpoint was triggered and our sound played. And you can actually even add your custom sounds instead of the default ones, and I've included a link in the instructor notes if you're interested. So let's stop this one more time and talk about the remaining actions that we haven't looked at yet. I'm not going to show examples for each of the actions because some of them are outside the scope of this class but there are additional resources in the instructor notes that can guide you through using them. So in the breakpoint editor, which we see here, we'll add one more action. And here at the top, we see AppleScript. And what an AppleScript action is going to allow you to do is run an AppleScript's script when the breakpoint is hit. The next one is capture a GPU frame, and this does exactly what it says, and it can be useful if you're debugging applications using OpenGL or something like that, using SpriteKit. Then we have the log message, which will either log a message to the console, or we can actually speak it back to us but I'll admit that having the computer speak back to you can feel a little bit like Space Odyssey. And then the last action is the Shell command. And similar to the AppleScript action, this allows you to run a shell script when the breakpoint is reached. One way this can be really useful is for an app that might need to clear the local database records each time the app is run in the simulator. So instead of doing this manually, you can set a breakpoint and actually run a script that clears the local database for you. And really, there are endless possibilities with what you could do with this, so I'd encourage you to experiment with them in your own projects, and if you like, there's another cool thing we can do here. We can actually share our breakpoints too. So if you right click any breakpoint in the navigator and you select share breakpoint, then it'll now show up as shared, and the breakpoint will be included as part of your Xcode project file. And this means that you can share your Xcode project with anyone else, and they should see the breakpoint, and because the shared breakpoint is recorded as part of a file, then it'll also show up in version control systems like Git. As an exercise, I want you to create a breakpoint action that plays the Basso sound when the number of bugs added to the BreakpointBugViewController has exceeded 10. And when you're done, check this box. Hopefully this should've been a pretty easy exercise for you. If you'd not already done it, set a breakpoint to the addBugToView controller method and we'll add a breakpoint action to this. So let's add an action that plays a sound. Here we go. Select basso. [SOUND] Maybe basso, I guess. Maybe I've been saying that wrong all along. And I'll set the conditions, we want debugs count to be greater than ten. Let's run the application. [SOUND] And so when we tap the screen, we hear the sound and it stops and we can see that we have 11 bugs in our bug's array. So this is kind a cool. I think, you could imagine that if you have some condition, you want to make sure that's not being triggered, or should only be triggered. Occasionally you could play some custom sound, that makes it sound like your computers about to explode. And it will definitely catch your attention. And it could be really useful to use something like this, if you have maybe a system or an application that needs to run for, say 30 minutes, before your actual break point is going to get triggered. So, you can have it running in the background. And then when you hear the sound, you know that it's happened. We spent a good amount of time playing with what are known as line breakpoints. We created these by clicking in the gutter on the line of code where we wanted to pause the execution of our application. But Xcode gives us options to create other types of useful breakpoints that are not associated with any single, particular line of code. To create them, we'll need to go to the break point navigator. And I'll remove this breakpoint for now. And then we'll want to focus our attention on this plus sign in the lower left hand corner. If we click it, a context menu appears, allowing us to add exception breakpoints, open GLES breakpoints, symbolic breakpoints. And a test failure breakpoint. In this course we're going to focus on only the exception and symbolic breakpoints. Because the other two, open GL and test failure, are more specialized cases. So let's add an exception breakpoint and see what happens. The first that we can see is that Xcode creates a breakpoint that does not belong to any single file and it reads all exceptions. To show the difference I'll set a line breakpoint. You can see how this one belongs to a file and this one does not. So like it sounds, this breakpoint can be triggered by any and all exceptions. If we right click and edit this breakpoint, we can see that the break option is set to on throw. Thus, anytime the run time environment throws an exception, this breakpoint will be hit. We could change this to on catch but let's leave this setting for now. To demonstrate how this breakpoint's used I'll go to the breakpoint bug view controller. Scroll up to the viewDidLoad and we'll change the action for the singleTapRecognizer from handleSingleTap to hangleSingleTaps with an S because we know that that method does not exist. And this will force an exception to be thrown. So let's run the application. We'll tap in the breakpoint debugging scene. So once I've tapped the screen, we can see that our breakpoint is being reached. And it's saying that an unrecognized selector is being sent to the instance of a memory address for a breakpoint bug view controller. And if I try to continue, then our application will crash. And it's terminating on a uncaught exception of NS exception type. So let's go ahead and look at the other options we have. Let's stop for the exception breakpoint. So the only thing that's different, besides the action and options, which we've seen before, is this exception option. And we can set it for a particular language, like objective C and C++, so that we only fire on exceptions triggered in either language. And that's really it for exception breakpoints. You may be wondering to yourself, well, how is a exception breakpoint useful? This type of breakpoint can be extremely useful if your application is crashing on a particular line of code. But Xcode and the stack trace really just aren't giving you a whole lot of information. So with an exception breakpoint, you can pause right before the app crashes, because say it's not handling the exception. And then determine who is the culprit of the crash. The next type of break points I want to talk about are symbolic break points. And the use of symbolic break points, here we go, is eerily similar to how we created break points in LLDB using the break point set command and passing the selector option. So to add the symbolic breakpoint, we are now at this menu, and we need to specify a symbol. And like we did earlier, we'll use the selector viewDidLoad. And after we hit Enter, it really only appears as if one breakpoint has been set, but looks can be deceiving. If we run the application, as soon as we run, and I'll stop now. We can see that it expanded out into all the different cases, all the different places where this particular selector matched. And if we extend the navigator, we can see some more information in regards to which particular viewDidLoad we're talking about. We'll drag it back and now we'll check the other options that we have. And we can see that, besides the things we've already assumed, we can specify a particular module. And so let's add UIKit to the module field, and hit Enter. And now we'll run again. And stop. You can see that our list has shrunk to include only the viewDidLoads matching that are in the UI kit module. So with that in mind, let's go ahead and try another exercise. At this point many of you have probably fixed the problem in the break point debugging scene. I'm referring to the one where when we tap, way too many bugs are appearing on the screen. So if you haven't fixed the bug, even if you've already fixed the bug. It's okay. I want you to take a moment and use your new skills of the new things that we've gone over with Breakpoint actions to find and fix the problem. Or think about how you would've found and fixed the problem. And once it's resolved, check this box. My preferred way of tracking down this problem is to set a breakpoint in the add book to view method of the breakpoint of the breakpoint bug view controller. Then, if we run the application, we notice that when we tap the screen and we hit play, it seems like the add bug to view is just being called over and over again, almost in a recursive fashion. And by recursive I mean that the frames keep adding and they don't decrease until we've reached some large number of bugs. And if we drag out the navigator, we can see that after our first add bug to view call, we have this move bugs animation,that's then calling addBugToView again and it just continues all the way up the stack. So let's tap this one and we can see that we are making an extra call or what appears to be an extra call here so we'll delete that. Whoops, I shouldn't have stopped the application because now I'm missin any debug information I have. So my bad, let's do this again. We'll hit play and now it just, oh, now we just have two bugs. So how are we hitting this? Let's run it one more time. So we hit it once from handleSingleTap and there we go. We have an extra call here, that's why we're getting two bugs. So let's go ahead and blow that one away and we'll try again. This time, when we tap, we'll disable that, play, just one bug crawls onto the screen at a time. And that's the behavior that we want. Quick look is a visual debugging feature that was introduced in Xcode five. You may have seen it before if you pressed space when you selected a variable in the variables view. Let's take a quick look now. So I'm going to run the application and this time instead of selecting the Break point Debugging scene. Let's go to the visual debugging scene. And tap. And that's strange. It looks like something's being added to the screen. It looks like our spider, but it's not crawling onto the web. So let's add a breakpoint, and addBugToView for the visual BugViewController. Go back and tap. Let it fall into our breakpoint. If we go to the variables view. We can bring up a quick look by selecting a variable and then pressing the space key. I'll select self and press space. The quick look for this object's fairly limited. It gives us the same information that we've seen before. It tells us the type and just gives us this value which is a raw memory address. But lets try something that's more visually oriented. So lets go the bugs array, and we'll take the first element in the bugs array. Since it's a UI image view, and press space. And this is much nicer. It actually shows us the image that is displayed in the UI image view. So lets have a little fun with this. And we can actually change the image in LLDB and see how it affects the quick look. So I'll type expression and then bugs. Element zero. And then for the image we'll change it using UIImage name, named: settings. Enter. And this command updates the element at index zero to use the settings image instead of the spider image. And if we go back to the quick look, hit space. We can see that that image has indeed updated. And if we run, it's hard to tell, but it could be the case that that's also changed, and that's our second bug. Now we're going to fix this crawling issue in the next exercise. But for fun I want to show you how to make a custom quick look for any class that you may have. So i'll go ahead and stop the app, and let's scroll down to the bottom of the VisualBugViewController class. And the process for creating a custom Quick Look is the same for every class. It just depends on your implementation. So you have to implement this method called debugQuickLookObject. So I've gone ahead and we're going to do this in an extension for the "VisualBugViewController". We're implementing the debugQuickLookObject method. And it returns an AnyObject? Optional. The key is, is that this any object that we return is something that X code knows how to display. So for instance it was able to display a UI image view. We saw that just a second ago. So that's one type that we could return. But for the other types, I've posted a link to Apple's listing of all the other supported types that you can use in this case. For this particular example we're going to return a UI image. I've written this code ahead of time, and what is essentially does is it loops through our bugs array. And it creates an image with colored squares indicating each bug that's in the bugs array. Now you can step through this code if you like, but the purpose here is to show you that we can actually do this. So disregarding this code, we return an image at the end of the day. And that's going to be our quick look. So let's run the app and see what this looks like. So we'll go to the visual debugging scene. And let's go ahead and spawn a couple spiders. Whoops. So let's deactivate that first. Create some blue ones. Create a red one or two. Green one, black one, and we'll re-enable this. And now if we press space on the self, we can see our image. And this image gets it's colors corresponding to the bugs that are in the array. And there you go. That's a custom quick look. We've arrived at the final tool for this course, the debug view hierarchy. This was recently added to Xcode, and it allows us to dig in to the visual hierarchy of an app while we're debugging. So to make things interesting, let's run the application, and I'm going to create a couple spiders. [SOUND] There we go. And lets set a breakpoint in the add bug to view, and jump back and drop into our breakpoint. >From here, there are two ways to access the debug view hierarchy. The first is in the debug navigator, and we get to it by going to the debug navigator, and then selecting this UI hierarchy from the dropdown, from this icon here. So we'll select it. And if we look at this unfolded list, we can see all the different UI image views, debugs, essentially that are being created. And we can see where they're located. If we click on one of the items in the list, this is where it gets interesting. It brings us to this visual display of our view. So as I'm selecting on these, these are debugs that I click on. This. It's talking about the buttons that we have. And there are debugs. Now if we click and drag this area, this is really cool. It explodes into a three dimensional view of our view hierarchy. And we can see visually now. Some of the relationships between different elements in the view. Just like the list, we can select the different components, so I'll select this one. That's the UI Navigation Transition View. Select that one. Let me zoom out just a tad. There we go. That's one of the UI image views. There's a UI image view. That's the UI navigation bar background, and so on. Now let's go over to the controls that are available to us. Dragging this bar in the lower left hand corner, will allow us to increase and decrease the spacing between the components in the hierarchy. The next two buttons can toggle, showing clipped contents, and constraints, which does not do much for us here. Let's just leave it as is. And, the third button from the left, can flatten the view back into its two dimensional form. Next are the viewing modes which include contents, wireframes, and wireframes and contents. And let's just leave it as wireframe and contents for now. After that, we have these minus and plus icons which are for zooming. And then if we click the equal sign it will just zoom, so that maximizes your view based on the space that's available to you. Now this last control. What it does is, it adjust the views that are visible from you going from the bottom most views on the left, to the top most views on the right. So, if I start by dragging from the right, and moving left, you should see the things on the top disappear, before the things on the bottom do. And, hold up. Let me zoom out. There we go. And let me tilt it a little bit. And those are all the controls that we have on the bottom. The next thing that we can do in the debug view hierarchy, is get diagnostic information about the components we've selected in the utility area. So you'll want to click one of the components. And then to display the utility area, make sure that you've toggled on this icon here. There we go. And here you can see information about the component's type. UI image view, it's raw address. Some state information. And a display showing its content. The raw address, hint, hint, can be casted like we did earlier in the command line interface, to gather more information about the component itself. So you can see how this would be incredibly useful, especially for games and other applications. A lot of things going in and out of the view. This is a really cool way to debug our application. As a final debugging exercise, I want you to debug the problems that I've introduced to the visual debugging scene of the so many bugs app. Now you may be tempted to just copy the code from the final working scene, but I highly encourage that you don't do this. Instead I want you to use the debugging tools we've learned especially the visual ones to debug and fix the problems in the scene. As you work through each problem that you can find write the steps that you take to debug the problem in this text box. And if you're feeling really adventurous also include your hypotheses about what is causing the bug before you fix it. Now the first problem that I notice is probably the first problem that you notice and that's that the spiders are being created, however they're not crawling on the screen. So I've spawned a couple spiders here and no luck. They are not crawling onto the screen. So let's add a break point for this. I'll do it again in the bug to view method. And we'll trigger it again. There we go. And now let's bring up the debug view hierarchy and select one of the UI image views for one of our bugs. Here's something I noticed off the bat. All the bugs appear to be in the same position. Every single one of them. They're all here in the top left hand corner slightly out of our view. And something else is strange and that's the visible content doesn't really look like what we saw earlier. Last time I didn't even see bugs here. This time I see some of the red bugs, some of the blue bug, there are some black bugs. I'm not seeing them at all. If I go to the inspector, I'm not really getting a lot of information about what's going on. This is a little confusing and what I'd like to see is a little bit of information that describes where the visual content the actual spider is. Let's try running again. Create another bug, see what happens. Actually the debug view hierarchy. This is another oddity here. Now we see some of a blue bug. What happened to our red bug? Let's try it one more time. See if anything changes. Yeah. Each time so now we can see almost all the blue bug and some of the red bug. So my hunch is that the content for the spider image is being randomly placed somewhere within this frame instead of the position of the frame being randomly placed somewhere within the view. So seems like we're randomly placing the wrong thing. Instead of randomly placing this thing's position, we're randomly placing the visual content. So let's use the command line interface to test this assumption. So I've selected one of the UI image views here so that I have an address I can work with and in the console let's use the unsafe bit cast to cast this address into a UI image view object that we can use. So we'll type the expression spider equals unsafe bit cast and we'll pass the raw address for this image view and then the UIImageView.self since we're casting into a UI image view object. Lets go ahead and print out this spider object. There we go. And the first part of the images frame shows a negative 100, negative 100, which are the x and y position. But this is a little weird. The spiders bounds show the CA basic animation thing. So this kind of plays on the same hunch that maybe we're doing something with the visual content or the bounds instead of the frame. So let's set a new break point when the animation shouldn't be occurring. Like maybe if there is an animation it's played through and that could tell us something. So, there shouldn't be any animation of position, which we're on this hunch that maybe we're updating the bounds instead of the position of the frame. There shouldn't be any animation of that going on when we pop back to the master view. So let's go to the visual debug controller. Let me hide these things away. And here in the pop to master view controller I'll set a break point. Let's see if we can trigger this break point and see if we can get any new information. So I'll re run the app and then I'll tap the back arrow. That should trigger our new break point. And now let's print out the spider object again and see what's happened. Okay,now our bounds. I don't see anything there for bounds. The animation, maybe that's gone. I think this is enough evidence to work on this idea to prove that maybe the issue is happening when we animate the bugs or maybe we're animating the wrong thing. We're not moving the frame. We're moving the bounds. Let's stop the app and go to the move bugs animation method. Because this is the method where that movement is supposed to happen. And I think we see the problem now. Instead of updating the frame, we're updating the bounds. So let's change bounds to frame and then rebuild our application. [SOUND] And lets disable this. There we go. So now our bugs are appearing just fine. I'll just create a couple. And it's going to shake the phone. Do the shake gesture. A little weird. This time the spiders did flee from the screen, but instead of spreading out radially from the center, they crossed over the middle to exit off the screen, and that's not how it should work. They should be spreading out radially from the center. Let's look at that again. We'll create some more spiders. Woah, okay. It looks like we have another problem. Maybe the bugs aren't being deleted, but we'll look at that in just a second. Let's shake it again, and that's the same problem. So this is probably related to the disperse animation. Let's go ahead and take a look. So I'll stop at this point, just need to stop for a second. So here's the disperse bugs animation, and we can see that we're setting the off screen position. And whatever this off-screen position is being set to, that's what we're trying to update the bug frame to is this new off-screen position. It's causing the bugs to cross over the middle of the web. So right now we're taking the bugs center coordinate to calculate this off screen position, we're taking the bug center coordinate, the X, and we're subtracting it from the view center coordinate for X and we're multiplying it by -20, and we're doing the same thing for the Y. We're taking the bug.center.y, and then the view.center, it's y, and we're also multiplying it by -20. So let's try this calculation by hand and see what it really looks like. So let's say that we have this fictitious view in spider and that the spider's enter, it's X, is maybe 180. And let's say view centers, it's X is maybe 150. And if we subtract these two values we get positive 30. And if we multiply that by negative 20 we get negative 600. And with a new center value of negative 600, this would cause the spider to move all the way from it's position to where it currently is across the center to some point all the way over here on the left. So think that's our problem. Instead, I think if we multiply maybe by a positive value, we can move to the right, away from the center instead of left, across the center. So let's go back to the code now and fix this. So I'll change these to positive 20's, and once we build and run again, create a bunch of spiders, and simulate shaking device. And nice, there we go. All the spiders are now running away in a radial pattern like we wanted. Now there's one last bug which I think you noticed, it's maybe more of a lack of implementation instead of a bug. But when we tried shaking the bugs and then created some more, we noticed all these bugs came running back onto the screen. So, where are these extra bugs coming from? My thought's maybe we're forgetting to move them. So let's just check back in the visual debug controller. And see if our hunch is correct. So we go to the empty bugs from view. That's where this should be happening. There we go. Model that. I left a message to remind myself, and I haven't done it to empty the bugs from the view. In this case, I'll forgive you if you copy the code over from the final working version because that's what I'm about to do. This should just be a simple fix. So if we go up, it debugs from view. Here we go. Let's put that in. Try it one more time. And create some bugs, shake them off the screen, and then if we create some more, should be no new bugs crawling back on. Looks good. Let's do a couple of different types of bugs, just for checking sake. Shake them off, and everything looks good. And that's it. That's all the bugs that I know that are in the visual debugging scene. And I hope you're able to find and fix all these bugs on your own. But most importantly, I hope that your confidence is growing, so that you can go forth and when you're faced with bugs like this, or any bugs in your application, you know what tools are available to you, and you can use them to debug your applications. As we've seen, Xcode provides great tools for stepping through our code and fixing issues. With features like quick looks and view hierarchies, we can even examine our applications visually. But remember, regardless of what tool you're using, debugging always involves the same basic steps. You have to reproduce the problem, gather any debugging information, determine the fix, make the change, and then try to reproduce the problem again. If everything goes well, the problem will be fixed. In closing, none of us will ever write perfect code, but by becoming better debuggers, we'll know how to fix problems when they arise.