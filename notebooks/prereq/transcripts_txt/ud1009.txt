You got this. You got this. Eden? Hello. Hi, I'm good welcome let's head out this way. So today what's going to happen is we're going to meet. Hey. Our IOS candidate is going to be here pretty soon. Her portfolio looks really promising. Yeah, I'm just looking at her resume now and that Mong app that she built. That's really intuitive. So, I'm thinking we tackle it like this. I'll take the behavioral questions. We'll have Kristen do the Swift questions, and then if you could handle Objective C that would be awesome. Great, yeah, that aught to give us a good sense of her skills. It's kind of funny I was looking at her LinkedIn profile and I didn't see anything about Objective C. I guess we'll find out. Okay, here we are. Now, do you need anything to drink. Would you like some tea, some coffee? I'm great, thank you. Okay, let me know if you have any other questions. Thanks a lot. [BLANK_AUDIO] You got this. You got this. As long as they don't ask about Objective C. No, you wouldn't do that. Hi I'm Gabriele and I'll be your instructor for this short introduction to Objective-C. This course is tailored for Swift developers. Our goal is to prepare you to dive into an unfamiliar Objective-C code base and migrate features from Objective C to Swift. We'll be focusing on the following skills. [MUSIC] In lesson one you'll learn the distinguishing language features of Objective C. In lesson two we'll go over some Objective C syntax and you'll write some classes and properties from scratch. In lesson 3, we'll talk about how to write and call methods, a.k.a. send messages in Objective-C. With these new skills you'll build a functioning game. In lesson 4, you'll port the app GIF Maker from Objective-C to Swift, focusing on writing custom classes and incorporating third party frameworks and extensions and lesson 5, you'll import more features of GIF maker from Objective C to Swift focusing on data persistence with NSCoder and I NSK.driver. To wrap things up in less than six, we'll review the most common challenges for interoperability between the languages of iOS and you'll complete a set of coding challenges to sharpen your interrupt skills. [MUSIC] We were lucky to get a chance to talk with an iOS engineer from Venmo, and Keith Smiley, an iOS engineer from Lyft. They told us about their experiences rewriting the Venmo and Lyft apps in Swift, and how they see future of Objective C in iOS development shaping up. I've been at Venmo for two years, and for the first 22 months, at Venmo, I was on the iOS team and I built a large part of the Apple that exists currently today. And now I'm on the strategy team, we're focused on exploring different monetization strategies at Venmo. The Venmo iOS team decided to rewrite the Venmo app in Swift. Around the same time as WWGC 2015, Swift 2 was just announced and we were watching all these videos about all the cool things you can do with Swift. At the same time, quintessentially, our product design teams were discussing new UIs and new UXs and in the Venmo app. Also, at the same time, our existing Objective-C.code base was becoming very unmaintainable, building new features was taking a long time. If we ever wanted to do any design changes to the app or different flows in the app, it would require massive refactors because of the fact that our UI layers and our model layers are so deeply coupled together. So, one day after the one of the WWDC sessions, all of us came back to the San Francisco office and just started whiteboarding what of Swift version of the Venmo app looked like. We made an API layer, we made a UI layer and we just opened up our computers and started building it. This wasn't like an official project or anything but we started we kept doing this for about a week and a half and came up with a bare bones version of the Venmo app. kind of just like an experiment to see how a Swift only version of Venmo app feels, and how much faster we think we can iterate on a version like this as opposed to the current version of the app. We got to a very good point in those two weeks, and finally told what we were working on and how this code base that's going to maintainable for a very long time. And it's also going to enable us to write features much faster, and because of all that, they decided to get on board and we started building this app. Objective-C will stick around for a very, very, very long time. All of you like it, the foundation and I think all of Apple's frameworks are actually written in the 100% Objective-C. I don't think Objective-C is going anywhere for an extremely long time and I think that having some knowledge about how it works is extremely important. I do think that as time goes on, more and more Objective-C developers will be writing Swift more and more often. A lot of existing companies that have 100% Objective-C apps will start catching the Swift train and start building all their new features in Swift, which I highly recommend. What I don't recommend is just rewriting an app, a perfectly good app and in Objective-C and Swift because it's going to be a very, very, very long project with very little gain. One of the largest challenge of doing a big rewrite is the fact that during that time of the rewrite, your team can't really build new product features and if you are building new product features, you have to build it twice. Once in the existing app, as well as like in the new app. The nice thing is that when you build it twice, you can actually see how much faster you're building it in a new app, which is quite delightful and kind of proves your point to the rest of the team that this is a good decision. But that was definitely the most difficult part about doing this rewrite, but when we were being conservative on new features in the app during this time and the ones that absolutely had to get in, had to be written full times. We're still working on it today, it's almost done. The scope of the app is also changed a lot since we first started. That said, the entire team is working on it. And whenever some project does come up, like a product feature that needs to come out, one of us will move off the core app, rewrite app and start working on that project and then work on it twice. Once for the old app and once for the new app. If we were hiring a new developer at Venmo who primarily will be writing Swift, I think that them having some Objective-C knowledge coming in to Venmo would be really valuable to us. It would also differentiate them from other candidates that might only also know Swift, which is really important. Though our entire code base will be 100% Swift, we do have a lot of dependencies that are Objective-C, and sometimes you do have to go into them and maintain them. We would want them to know the syntax of Objective-C primarily, as well as some of the nuances of Objective-C. For example, Objective-C variables are by default always optional. That means that opens you up to a lot of errors and runtime bugs which you don't have in Swift, and so it's important to be even more careful, and check for nil before you're adding a variable into a dictionary. A lot of our third party dependencies are still in Objective-C, some of which we have open source ourselves. So going back into those dependencies and updating things is important. Knowing basic Objective-C syntax is very important. Knowing how to do anullability on it to make sure that your Swift code plays nice with Objective-C is also very important. To get a feel for the distinguishing language features of Objective-C. Let's start by comparing and contrasting it with swift. We aren't going to exhaustively catalog the similarities and differences between the languages. Instead I'd like you to focus on two essential similarities and three key differences. Objective-C and Swift share the IOS frameworks and design patterns but they differ substantially in their handling of nil, their approach to mutability, and object typing. Let's dive deeper into the similarities. Building the portfolio apps for the iOS nano degree, you've become intimately familiar with the classes and foundation and UI Kit. Those classes are bridged to Swift. But as you may know by now, many of those classes are actually written in Objective C. This means that the way they're used in Objective C will look and feel very similar to the way you use them in Swift. Let's take a look at an example. The following code snippets are taken from a custom view controller class that inherits from U.I. view controller. In the code snippet here, you can see the familiar U.I. view controller method, viewWillAppear. The Objective-C syntax will certainly seem foreign at this point but let's focus on what we can find in common between the two implementations. Just as you would do with Swift, you start out by calling the viewWillAppear method of the superclass. After that, you call any methods necessary to prepare the view before it appears, in this case the method displayResult. By the way, if you ever find yourself needing more time to read through the code examples, go ahead and pause the video. Let's take a look at another example. Here are some of the methods of the AppDelegate Protocol. You'll notice that if you create a new project template in Xcode, whether it's an Objective-C or Swift, the same six AppDelegate methods appear by default. I'm just showing the first four here but you get the idea. And here they are in Swift. And here they are in Objective-C. These methods manage transitions between the five main application states. Active, background, not running, inactive, and suspended. These five states are language agnostic. And the transitions between them are handled identically in Swift and Objective-C. As an iOS developer joining a new team, digging through your colleagues' Objective-C code, you can expect to see many familiar classes and methods from UI Kit and Foundation. Let's talk about another similarity between iOS development in Swift in Objective-C, design patterns. Whether you're writing in Swift or Objective-C, you'll be using principles like the delegate and Model View Controller patterns to guide the architecture of your app. For example, in conjunction with the delegate pattern, both Objective-C and Swift make extensive use of protocols. Part of the need for protocols stems from both languages having single inheritance. A given class can only inherit from one other class. Instead of multiple inheritance, both languages employ protocols to share functionality across unrelated classes. Let's take a look at an example from the familiar UITextFieldDelegateProtocol. Here's an implementation of the shouldChangeCharactersInRange method for a text field accepting a zip code. Here it is in Swift, and here it is in Objective-C. Here are the two signatures together, and here we see the body of the method for each. Notice that the two implementations are incredibly similar. The use of protocols across Objective-C and Swift engenders continuity across iOS apps at the scale of app architecture and on a more granular scale, as the two languages employ many of the same protocols. Now on to the differences between Swift and Objective C. Let's start with how they handle nil. As you know, Swift treats nil values with a great deal of care. Wrapping anything that could have a nil value in an optional type. Objective C is much less concerned with nil values. The language doesn't need the concept of an optional because any object can have a nil value. No problem. Surprisingly, in Objective C, you can invoke a message on a nil pointer with relatively little consequence. Watch. Here's some code that represents a bike messenger picking up a package. Here, I'm initializing a messenger and then he picks up a package. Now let's press run and since we've got a log statement here, we can look down here in the console and see package contents, top secret stuff. Now watch what happens if I set the value of the bike messenger spike to nil. First of all the compiler doesn't care. If this were Swift the code would even compile. And then when I run the code, it handles it like it was nothing. Down here in the console, we see package contents null but there's no crash, there's no null pointer exception like we get in Java. Now in this toy example, the fact that nothing happens when we invoke a method on Spike isn't such a big deal, but in general you don't want your program doing nothing when it's supposed to be doing something. You may find yourself frequently checking for nil values even though they won't crash your program per se. Objective C's relaxed attitude toward nil values also has some implications for debugging which we'll talk about more in the lesson on interoperability between Swift and Objective C. Objective-C's approach to mutability differs from Swift in a couple fundamental ways. One relating to how mutability is achieved for a given type, and one relating to the probability of an unintended mutation propagating through a program. Let's look at an example. Here I'm initializing an NSArray of strings. Notice that if I look for the method addObject or something akin to Swift's append method, it's not found. In fact, if you search the NSArray class reference, you won't find any methods for adding objects to the array. I can make a new array using the array by adding object method but I can't add an object to an existing NSAarray. The other option is to define my array as an NSMutableArray and now we can see that the method add object is indeed available to an NSMutableArray and we can add booties to our kayaking gear. We'll go ahead and run it. We can look down here in the console and see the contents of our array. Swift and Objective C differ in their use of reference types and value types. Swift encourages widespread use of value types like strut while Objective C favors reference types like classes. Structs are used pretty sparingly in Objective C and they don't have the capability that struts do in Swift swift. For example, this beer struck on the left that we've seen before in swift on the left would be encoded as a class and objective C. To understand what this means for immutability, let's compare what happens when a type is copied by value and what happens when an object is copied by reference. This comparison will likely be familiar to you by now. Focus on the last four lines of code and take a few seconds to guess the value of myBeer.style. Down here in the console, we can see that myBeer is still a lager. Structs are value types. When myBeer was assigned to yourBeer, a new copy was made, and the values of the two copies are independent. Let's see what happens when beer is implemented as a class in Objective C. Now focus on these four lines of code, and again try to guess the value of myBeer.style. We'll run the project, and down here in the console we see that the style of myBeer is now a stout. Classes are reference types, which means that when we assigned myBeer to yourBeer, a new reference was made. But myBeer and yourBeer both point to the same underlying instance. When we changed the value of yourBeer.style, we changed the value of the underlying instance to which both beers refer. Swift is statically typed. The type of every entity is known a compile time. Objective-C uses a combination of static and dynamic typing. The types of the majority of objects are declared a compile time, in fact, it's required that every object have a type. But sometimes, the type that's declared is id. The id type is somewhat sneaky. It's kind of like a amorphous blob that stands in for any type, declaring an object of type id, is kind of like writing to be determined. When an entity is declared with the type id, a more meaningful type is determined that run time, in other words, dynamically. Here's an example. Let's say we have an array representing the contents of a bag. In Objective-C, arrays are not typed. Instead, every item in an array is a type ID. That means we can fill up our bag with all different kinds of objects, a bowling ball. [BLANK_AUDIO] A lamp. [BLANK_AUDIO] A string and hey one more lamp. [BLANK_AUDIO] Now, let's say we want to randomly grab an item from our bag. We'll do that by generating a random number first. [INAUDIBLE] Now, at compile time, we don't know what class our mystery item belongs to. It's marked with a type ID. At runtime, we can get a little more information. If we throw a log statement in there, we can see in the console that the class of our mystery item is a lamp. There are actually several ways in which Objective C can be characterized as more dynamic than Swift. The second has to do with how objects are bound to the methods they invoke. In Swift, method binding or method resolution happens at compile time. In Objective C, methods in the objects invoking them are not bound until runtime. Let's imagine another array holding objects of multiple types. This time we have objects belonging to the classes Puppy, Drum and Dealer. Now let's imagine that we choose an item from this array and invoke the method, play. Now, these three items actually implement the method play in three different ways, which play the code is referring to isn't known at compile time. Coupling of method and object doesn't happen until runtime. And if we look in the console we see Frolick. Okay, that was Spot, the Puppy. And if we run it again we see, Here's a card. Okay, that was the Dealer. And if we run it again, we see ba-doom-cha, that was the Drum. Naturally, with great power comes great responsibility. Invoking a method that doesn't exist is not usually a good idea. Let me show you what I mean. Here's an array, similar to the last one, but this time I swapped out the dealer object for a string. Now let's see what happens when we call the method play. No compiler errors, so far so good, and we press run. Uh-oh! Of course, we knew that was going to happen because ns string obviously has no method called play. Let's take a look at what this error says. So, we'll scroll up to the top of the console and it says unrecognized selector sent to instance and then there's a string of numbers. You've probably seen in an error like this before, but you may not have realized that that word selector comes from Objective C. In Objective C, selector is another name for method. So when you see this unrecognized selector sent to instance, start debugging by investigating objects with the type ID. It's possible that the class of the offending object is not what you think it is at run time. And to defend your code against the perils of ID, you can also use introspection. You can ask if the object at hand responds to the selector in question. Hi. Hi. I'm Gabrielle. Edith. So good to meet you. You just talked to Jessica, right? Yeah, we had a great conversation. I was just showing her a prototype of my app. Excellent. I totally want to check that out later, but I want to start off with a few technical questions about Objective C. We can get those out of the way. Sounds good. Can you give me an example of when you would use NSArray and when you would use NSMutableArray? Help me out. How do I answer this? Look in your professional and social networks and find an Objective-C developer. Ask that person for one interview question they commonly asked and post that question to the forum. Now do you have a general sense of what Objective-C is all about. Next stuff will get into the nitty gritty of writing classes. [BLANK_AUDIO] In Objective-C, the class is the principal mechanism for bundling together data and functionality. Whereas Swift might employ a diversity of types, including classes, strucks, and eNUMs, Objective-C primarily uses classes. In this lesson, we'll write a class from top to bottom, and then do it again and then do it again. Well start with the house class. To begin with, the house class will have three properties an address, represented as an MLS. sting. A bowl, indicating whether the House has a hot tub or not. And an int, representing the number of bedrooms. In the diagram here, I've depicted objects, outlined in orange. To write our house class first we're going to create a command line project. We'll be making a lot of these throughout the course so do take the time to click through these steps on your own. Under file click New, and then Project instead of an iOS app this time choose OS X application and then command line tool. And we'll call this house, and make sure Objective C is the language that's chosen. With a command line tool, we can focus on the code and not worry so much about the UI. To add the files for the house class to the project, control click on the house folder just like you would any other Xcode project. Go down to a new file. Choose OS10 as your source and then coco class. And again, we'll call the class house. Now, in the project navigator on the left you should see the files house.age and house.m. In Objective C every class is associated with two files, a header file and an implementation file. The header file represents the public interface and the implementation file holds method implementations as well as any properties we'd like to be private. Open up the house.h file and you'll see that the house class descends from the class in this object. All objective C classes descend from this class. The class has been declared for us using at @interface the name of the class colon and then the name of the superclass. Let's go ahead and declare our properties. For now, we'll do that in the header file which means they'll be public and accessible outside the class. To do that I type at sign property nonatomic then the class that the property belongs to which in this case is an NSString, and asterisk to indicate that this is a pointer. And then, the name of the property address and of course top it all off with a semi-colon. We'll add number of bedrooms, and since a number of bedrooms is a primitive type, an int, we don't use a pointer. And the same goes for the BOOL, hasHotTub. Other property attributes you may want to include between these parentheses include readwrite, readonly, and copy. Notice that for the House class we declared our properties in the header file, the public interface. So right now, if I go into the main function, notice that I'm outside of the House class. But I can get a hold of an instance of House and change its number of bedrooms for example. Let's say we wanted to limit that access. We could start by declaring number of bedrooms in the implementation file so that it's private. So we switch over to the .m file and and we redeclare number of bedrooms. And we marked this private implementation with the property attribute readwrite. Readwrite means what it sounds like. >From inside the class, one can read or write to this variable. Then we switch back to the .h file and we mark this version of the property as readonly. Naturally, read only means that one can read the value of the property but not write to it. Notice that if I go back to the main function, I can access the number of bedrooms from outside the class. But I don't have to worry about accidentally changing it. If I try to write to this property, the compiler won't allow it. You can think of readwrite and readonly as being similar to var and lap in Swift. Readwrite is akin to defining something as a variable and readonly is akin to defining something as a constant. Since our address property is an NSString, we're going to want to mark it with the property attribute copy. In general, you want to use copy for strings. To understand why, let's see what happens when we don't mark the address with copy. Here we are in the main function of the House class, and in this line we're creating a string that's holding an address. Now we're going to use that address to initialize an instance of the House class, myHouse. If we log the address of myHouse to the console, we see 555 Park Ave. Cool, now let's say some joker is writing test code and they append this string La la Land to the addressString variable. Notice that we never accessed myHouse.address a second time? But if we log the current value of myHouse.address to the console, we see 555 Park Ave., La La Land. So that's no good. We don't want to leave properties of our classes vulnerable to unintentional changes. Right now, we're initializing the address property with a pointer to addressString. We can fix this problem by initializing the address property with its own independent copy of addressString. So we'll go back to our house.h file, we'll mark address with copy, and then run the program again. You can see that this time the value of myHouse.address doesn't change. All Objective C objects inherit an init method from the NS object class. So unlike in Swift, it's not always necessary to implement a custom initializer. If I go into the main function of our house project, I can initialize an instance of the house class with no problem. You've seen this a few times now. Every time you create an object, you type alloc, which allocates some memory space and then init to initialize the object instance. Alloc and init are always written together. They're like entangled particles. They can't be separated. That being said, this house I initialized has no address. So I think we should write a custom initializer. We'll write our custom initializer in the House.m file. This is the first method we're writing together. So let's take a minute to talk about the syntax of method definitions. Every method definition starts with the return type. In this case, our return type is going to be instancetype. Instancetype indicates an instance of the class in which this method is found, in this case, an instance of the House class. After the return type, we'll type init, no surprise there. But generally, you're going to want to initialize an instance of a class with some values. So it's common to name your initializer initWithSomeProperty. In our case, we'll initWithAddress, and then we place a colon after the method name. After the colon, we pass in our parameter, address, and of course, address is going to be a pointer to a string. We indicate the parameter type here in between parentheses and include an asterisk to show that the parameter is a pointer to an object. After the parameter type comes the parameter itself, address, and then some curly braces to hold the body of the method. So the general form for writing a method definition looks like this, the returnType between parentheses, the methodName followed by a colon, the parameterType between parentheses. If the parameter is an object, include an asterisk, the parameterName, and then in between curly braces, the body of the method. Now let's get back to initialization. Every init method is going to start out by calling the init method of its superclass, which in this case, is NSObject. So we set self = [super init]. Next we want to check that everything went well with that call to super init. So we type if(self). Self should have a value now, so this statement should evaluate to true. Then in the body of this if statement, we'll initialize our properties. I place an underscore here before address, and this is how I access the address instance variable directly. Remember that address is marked with the attribute copy, so we want to initialize it with a copy of the string that's being passed in. This line protects the address from the unintentional changes we talked about earlier. So again, we set _address equal to a copy of address, the parameter being passed in. We'll give these other properties default values. Let's say the default numberOfBedrooms is 2 and the default value of hasHotTub is false. When we're done setting the values of the properties, we return self. I think we need a Bedroom class to represent the bedrooms in our house. Follow along with me. Like we did before Ctrl-click on the House folder, go to New File, choose Cocoa Class, and we'll call this class Bedroom. And of course we want the language to be Objective C. Okay so now, what should the properties of our bedroom be? I'm going to give it a BOOL to represent whether or not it has a privateBath. And I also want to property to represent which direction the window faces. I like it when my bedroom window faces east, so that I can see the morning sun. What's a good way to represent a direction? If this were swift, we definitely use an enum. That's what we'll do here too, but you'll notice that Objective C enums are pretty minimalist compared to Swift enums. Enum definitions go at the top of your header file. The preferred way to create an enum is using the NS_ENUM macro, where NSInteger is the enum type and direction is the enum name. All enums in Objective C are of type NSInteger. Now that we've created our direction enum, we can add the property directionWindowFaces to our Bedroom class. And now that our Bedroom class is ready, let's go back into the House.h file and add a couple bedrooms to our house. [SOUND] What's going on here? Unknown type name bedroom. Okay, even though they're in the same project, the house class can't see the bedroom class right now. We have to import it at the top of the file like this. Looks like that come to the compiler and now we can use the bedroom class from inside of the house class. Now that we have our bedroom properties., I want to talk about a couple more property attribute you'll see here alongside nonatomic. The attributes strong and weak. We could have written our bedroom properties like this, but we didn't actually bother writing strong because pointers are strong by default. Although there are some development teams who always write strong just to be extra explicit. So when should a reference to a property be strong, and when should it be weak? Strong references are used for properties that are the primary responsibility of the class. In other words, owned by the class. These bedrooms are owned by the house class. Weak references are used for properties that are the primary responsibility of some other class. There are two times when you should use weak references for properties. When the property is a delegate and when the property is a subview of the main view. Take note, this is important to avoid memory cycles. For more information on what causes memory cycles, check out the links in the accompanying text. Go back to your book project and add a class called Person. Give the Person class properties for name and birthday, and be sure to include a designated initializer. You'll need to investigate different classes you could use to represent a birthday. When you're finished with the Person class, change the author property of book to be of type person. Now that you know all about writing and initializing classes and using Enums, I'm sure your rock-paper-scissors game is taking shape. You'll notice that there are some methods missing to get the game functioning. We'll finish those up in the next lesson on methods and messages. Now, that we have some classes to work with, let's define our object's behavior by adding methods to those classes. While we're at it, we'll talk about the somewhat unusual way that function calls are conceptualized in Objective-C. [MUSIC] The init method you wrote for RPS turn and RPS game probably looked something like this. Let's walk through the method definition syntax one more time. The dash tells us that this is an instance method. Then in parentheses here, we have the type of the method returns, which in this case, matches the type of the class to which the method belongs. After the return type becomes the method name, followed by a colon, then we have the parameter type in between parentheses followed by the parameter name, and then the body of the method in between curly braces. What about when we're passing in more than one parameter? Like in the RPSGames init method? When you're passing in more than one parameter, the parameters get interspersed with the method name. So in the RPS came example, the method name is here and here, and the general form would look something like this. Also notice that when we pass in an RPS turn object as a parameter. We need an asterisk to indicate the pointer to the object but when we pass in a move which is an integer. We don't need a pointer. Now that we know how to define methods, let's see how to call them. We'll start by filling in the body of the throw down method. This method will simulate a player throwing down a move rock paper scissors, and simultaneously generate an opponent's move in order to create a rock paper scissors game. In our case, an instance of the class RPS game. The player chooses a move, rock paper or scissors, and that move gets passed into the throwDown method. First off, we'll take that move and generate an instance of RPSTurn. We'll call it playersTurn. Notice that the Objective C compiler doesn't infer types the way the Swift compiler does. So every time we create a new variable, we need to first indicate its type like we're doing here. Then on the right side, we allocate and initialize an instance of RPSTurn. I'd like to dissect the right side of this statement. Focus in on this section and you'll see our first method call. In-between brackets on the left, we see the object receiving the method call. RPSTurn. And on the right, we see the method alloc. But in Objective C, instead of saying we're calling a method, we say that we're sending a message. So the general form for a method call looks something like this. In the previous example, RPSTurn is the receiver and alloc is the message being sent to the receiver. Next, let's zoom out to the call to end it with move. On the left, we see the receiver of the method call, the space in memory that's been allocated. On the right, we see the method in it with move followed by the argument players move. So here's the receiver, the message and the argument. The semantics of sending a message versus calling a function, is related to what happens behind the scenes in Objective C when a method is called. The method, object message send, which belongs to the NSobject class, is called every time a message is sent to an object. Object message send is not called until runtime. Consequently the relationship between the message and the receiver is not resolved until runtime. This is in contrast to what happens and swift. In swift, a function call binds a particular implementation of a method, to a particular instance of a type at compile time. Then the message and its receiver are not bound until compile time is the principal difference between sending a message and calling a function, but for our purposes, it's primarily just a difference of vocabulary. Let's get back to the throwDown method. We managed to initialize the player's turn with this line of code. Now we need to initialize a turn for the computer. We'll just use the default init method for now. And now that we have turns for both players, we can initialize a game. Notice that when you have long method names like this that might not fit on one line, the convention is to line up the colons like this. Xcode will do it for you automatically if you press return. So now we have an instance of RPSGame to work with and our throwDown method is finished. Previously we initialized an instance of RPSGame and assigned it to self.game. What does self.game refer to? Take a few seconds to guess. [BLANK_AUDIO] Since we're in the RPSController class, self refers to the RPSController, self.game refers to the game property of the RPS controller. In Objective C, just like in swift, we can use dot syntax to access properties of an instance of a class. So if we wanted to say orchestrate a tie, we could access the move property of each turn like this. Notice that we never wrote any getters or setters for the game property. Objective C generated them automatically. Swift generates getters and setters automatically, too. In fact, you might not even know what I mean by getters and setters because in most cases you can get away with not writing them. If we were using a custom setter, the code to set self.game would look something like this. When we initialized to this computer's turn variable using the default in that method we never actually set its move property to anything. We need to fill in our generate move method in order to randomly generate a move for the computer. The best tool for this job is a switch statement. The syntax for switch statements in Objective-C take this general form. Switch statements in Objective-C are quite limited compared to Swift and that they can only condition upon the value of an integer. They also differ in that the flow of control falls through. That means you need to include a break statement following the statement to be executed for each case. It's also required that you include a default case. Now let's apply this to our generateMove method. To generate a random move for the computer, we'll first need a random integer between zero and two. We'll get that using this line of code, using the familiar arc4random method. Now on to our switch statement. Will switch on the value of the interger we just generated and return a different move for each case. Note the break statements after each case. We're going to need a default case to catch any invalid numbers. But right now our enum just has three expected choices. Let's add a case for invalid to our enum, and then we can return that for our default case. Now we have a catch-all in the event that we get some number that's not between 0 and 2. We check that we have a break statement after the default case, and that's it. Our generateMove method is ready to go. Since we primarily need the generateMove method for initializing a turn for the computer, let's write a custom init method that initializes a turn with a random move. We'll add that custom in that method to the RPSTurn class. I'm going to start by copying and pasting in the initWithMove method and then I'll change the name to init. And we're not going to be passing in any parameters this time. And then we'll initialize the move property with the value returned by generateMove. With this construction, we're sending the message generateMove to self. And again, here self is a pointer to the RPSTurn object. And now this line in the throwDown method will initialize the variable ComputersTurn with a value for its move property. What if we place a break point after computersTurn, we can run this and then inspect the value of that variable in the left side of the console. So we press Run and then we see our variables here on the left side of the console and the value for move is Paper. Now let's run it again. This time it's scissors, we'll run it again. This time it's rock. So our init method is doing a good job of generating random moves for ComputersTurn. We need to add the logic for the rock paper scissors game, the logic that defines who wins. For this, we'll need if statements. The general form for an if statement in Objective-C looks something like this. It looks a lot like an if statement in Swift, except you always have to have parentheses around the condition. And of course, the statements are followed by semi-colons. Let's add an if statement to the defeats method you began defining earlier in the RPSTurn class. We need to return true every time the move associated with self, the object calling this method, defeats the opponent's move. The opponent is being passed in here. So we need to return true for three cases. If self.move is paper, and opponent.move is rock, then return true. Self defeats opponent. Here's the second case. If self.move is scissors and opponent.move is paper then return true. Self defeats opponent again. You can see that the logical operators, the equals operator, the and and or operators, are all the same as in Swift. And finally if self.move is rock and opponent.move is scissors, return true as well. For all other cases, the opponent will defeat self so the method should return false. This method returns false if the game is a tie, but that's okay. We're going to handle ties in a different method. When you wrote your winner and loser methods, you may have gotten an error reading something like this. No visible interface for 'RPSTurn' declares the selector 'defeats'. Selector here refers to the message or the method being called. And interface refers to the public interface for RPSTurn that's found in its header file. Defeats is not visible to the winner and loser methods. Because, just like we saw with properties, in order for a method to be visible outside of its class it must be included in the header file. So we'll open up the header file for RPSturn. And we'll include the defeats method here. Now if we go back to our winner and loser methods, we can see that the compiler error has gone away. Now I know that up until now, you've only learned the bare bones of Objective-C syntax. But that's really all you need to jump into your first migration project. Next up, we'll review the specs for the gif maker app, and start porting it from Objective-C to Swift. All right. You've got some fundamental Objective-C skills under your belt, it's time to put those skills to work. When you enter the workforce as an iOS developer, you'll likely encounter a code base written in Objective-C. As a Swift expert, you'll be called upon to port features from Objective-C to Swift. [MUSIC] That's what we're going to do with the App, GIF maker. We've written the app in Objective-C, and it's your job to migrate the entire app to Swift. Let's take a closer look at how GIF maker works. The gif maker app converts videos from your phone into gifs you can share with friends. It enables the user to record a video or choose an existing video from the photo album. That video is converted into a gif the user can add a caption to and then share. Okay, how are we going to make this. When I have a complicated project in front of me, I like to break it up into smaller pieces. So, let's start there. Here's our high level to-do list. First, we need to convert a newly recorded video into a GIF. Add a caption to the GIF we create and share it. We also want the user to have the option to choose from the album. And we want to enable at least some basic editing of the video before it becomes a GIF. Let's start with this first task and break it down a little further. To convert a newly recorded video into a GIF we'll need to present a video camera and retrieve the saved video. Convert that video into a GIF and display that GIF in the UIImageView. So now, we get to start with something we know. Presenting the camera. We're going to be going back and forth between the Objective C and the Swift versions of GIF maker. So go ahead and open up both projects in Xcode. Here we are in the Objective C project. And we want to see how the video camera is presented. So let's say I didn't know anything about this project. But I do know that the UI image picker controller is what presents the video camera. I could go over here on the left and search image picker controller, and I could find out where the code to present the camera is. And here you can see it's in this file called UI view controller plus record. It turns out, we need to present the video camera from two different UI view controllers. So the code to present the image picker controller is in this UI view controller record category. Okay. So present video options. That seems promising. Let's check out this method. Action sheet record video. That looks like what we're looking for. Now this record video action calls launch camera. Let's take a look at the launch camera method. Okay, here's where the image picker controller is being created. So here we are in our swift extension to UI view controller, and you'll need to import mobile core services at the top of the file like I've done here, and this is where we're going to write our launch video camera method. Let's look back at the objective C launch camera method, and see what we need to include here. Okay, I think I'm just going to make a list of what this method is doing. Create imagePicker, set the properties of the image picker, what properties are we setting? Source type, media types, allows editing, and then set the delegate, and then present the controller. I think that's pretty much all this method does, cool. Now we'll copy these notes over to the swift project, so we can fill in that method. Let's see what should we call it recordVideoController, set the source type which is of course camera. Media types is a little bit tricky, because it has to be in array, and also has to be a string, for now we're going to set allows editing to false, but we're going to change that later, we set the delegate to self, and we're almost ready. Present, what's going on there, cannot assign value of type UIViewController to. We need to conform to the protocol of course, and also the navigationController delegate. Okay, cool, so that error went away. And then we present it. Probably don't really need these comments now. That I do it for presenting the camera, and now we also need to write the methods to retrieve the video that we record. Remember there are two methods that we need to implement that are part of the image picker control, or delegate protocol did finish picking media with info, and imagePickerController did cancel. So let's look back again at the Objective C version, and see how these methods are implemented there. Here we are in the Objective C project, and we're at the pragma mark for ImagePickerControllerDelegate Methods. If we look here in the method didFinishPickingMediaWithInfo, we can see that first, we need to check the media type. Then, if the media type is a movie, we need to save this raw video URL. And then here, the comments say get start, and end points for a trim video. Well we're not trimming the video yet, so we can skip that part, and then here, it's gotta call to crop video to square, we're not cropping the video yet either. I'll tell you what, for now, we'll just save this video to the photos album that way we'll know the recording functionality is working. So we're back in the Swift version of our UI view controller extension, and to make this file a little more readable, I went ahead, and moved to the image picker controller delegate methods into an additional extension. Here in the method did finish picking media with info is where we want to save our video to the photo album. So we'll call the method UISaveVideoAtPath to save to photos album, and we'll remember to dismiss this view controller the image picker controller, this has to be a path. And, if we scroll up to our launch video camera method you can see that it's been connected to storyboard, it's connected to the record button. So our launch video camera method is ready, our image picker controller delegate methods are ready, so let's run it, and see how it looks. Okay, now keep in mind that when I show you these representations of the phone on the screen. I'm actually showing you a movie that I recorded of me running the app on my phone, because of course you're going to need to be running the app on device, if you're testing anything involving the camera, you won't be able to use the simulator. Here you can see I can launch the camera, I took a video of my teammate, the cameras dismissed, and here you can see that when I go out of the app, and then I go into my photo library my video is there, fantastic. Now you might be thinking, why are we writing the code to display a GIF if we haven't converted the video to a GIF yet? The answer is, it's easier to test the GIF conversion code if we can see the GIF. A UI image view off the shelf doesn't have the ability to display a GIF. Let's see how the gif was displayed in the Objective-C project. If we go into the WelcomeViewController and look in the viewWillAppear method, we can see where this variable firstLaunchGif is being initialized. If we Cmd+click on this initWithName method, it'll take us inside the gif class. Here we can see that the image is being set with a call to this method animatedImageWithAnimatedGifName. Okay, where's this method? Let's see, if we scroll up we can see tat animatedImageWithAnimatedGifName is a part of this extension that Rob Mayoff wrote, that UIImage+animatedGIF extension. This seems like it's getting a little complicated. But guess what? Arne Bahlo has an extension that does exactly what we need and it's written in Swift. So let's switch back to our Swift project and go ahead and add a new file called UIImage+gif. You can find a link to the GitHub repo containing Bahlo's SwiftGif extension in the corresponding text. If we go into his repository and we go into the SwiftGif common folder, we can see this UIImage+Gif.swift file. Go ahead and copy this code and put it into the Swift file you just made. Make sure that you copy this copyright information as well, so that Bahlo gets proper credit. Next we want to hook up the storyboard outlet for our WelcomeViewController's gifImageView. So let's open up the storyboard and we'll open up the assistant editor. And we'll hook up the GIFImageView. Next we want to set the GIFImageView here in viewWillAppear. If we go back to GitHub can see here in our Arne Bahlo's readme for the UI image extension how to use the extension. I'm going to call this proofOfConceptGif for now. And then we'll call UIImage, and then the method gifWithName, and then you'll notice that I've included a couple GIFs to get you guys started in the project. hotlineBling is the name of one of them, and then we need to set the image on our gifImageView to be the proofOfConceptGif. And of course we don't want to forget to call super. So we'll make sure to call superViewWillAppear. And now we should be ready to run it. And when we run it, sweet, there's Drake. Now when we convert our video into a GIF, we'll be able to display it. In looking through the UI View Controller record category, you may have noticed a method called convert video to GIF. This is where the magic happens. Let's see here. It's using a class called regift. What's that? Regift was written as a Cocoapod by Matthew Palmer. And it does exactly what we need. It converts a video into a GIF. If you look into the GIF maker objective C folder, you'll see a folder called third party code. If you open up that folder, you'll see another folder called Regift, that's where we've included the files directly in the project. We've also added these files to the swift project template. Here's Matthew Palmer's read me for regift on GitHub. And in the Quick Start guidelines, we can see that to initialize an instance of the regift class, we need to pass in four parameters. The video URL, the frame count, delay time, and loop count. Go back into your swift project and add frame count, delay time, and loop count at the top of the UI View Controller extension file as constants. We'll start with these defaults for now but you can experiment with different values to suit your liking. Next we'll add a method called convertVideoToGIF which uses the regift class. In this method will create an instance of the class regift. In the read me, we can see that this line of code initializes an instance of regift. The method that creates the GIF is named appropriately createGIF if we open up the regift.swiftFile. We can see they create gift returns in NSURL to the newly created GIF. So go ahead and create a variable called GIFURL to store the return value and now that in theory we have a URL to a GIF. Let's test it out by displaying it in the GIF editor. If you look in the GifEditorViewController in the Objective-C project you'll notice that there's a property for a gifImageView. Go ahead and add this property in your GifEditorViewController.swift file, and connect it to the gifImageView in Storyboard. We're also going to add a property to hold the gifURL and that property will be an optional of type NSURL. We'll set it to nil for now. Once you've got the gifURL set up, we're going to want to add some code to the method viewWillAppear. This code will render the gifURL as a gif. Kind of like we did in the WelcomeViewController, we'll make a GIF from the recording by calling the method gifWithURL. And notice that gifWithURL takes a string as a parameter. So we'll need to use the absoluteString property of our NSURL. And then we'll load that image into the gifImageView. And, of course, let's not forget to call super.viewWillAppear. With these life cycle methods, we always have to remember to call super. Back in our UIViewController+Record extension, we'll instantiate an instance of the GIF editor, add our GIF URL and then push that on to the navigation stack. We're going to do all of that in a method called displayGIF. So first we instantiate our GifEditorViewController, pass it the gifURL and then push it on to the navigation stack. And, of course, we'll want to call the method displayGIF from the method convertVideoToGIF so that we can pass it the gifURL we just got from regift and we won't forget to unwrap it. We're also going to need to call this convertVideoToGIF method somewhere, we can do that up in didFinishPickingMediaWithInfo. Remember we were just saving the video to the photo album, instead we'll just call convertVideoToGIF. And now we'll run it. So let's see how it looks. Here comes the camera, there's my video producer seeing how many malt balls he can stuff in his mouth, the camera dismisses and there's our GIF. All right, time to look back at our checklist. Convert a video into a GIF and display the GIF. Well, here's the video we recorded and there it is as a GIF. So we can check that one off. What's next? Add a caption. What will we need to do to add a caption? Up until now, we've had no GIF model. To have an object to save the caption to, we'll need to rewrite the Gif class. We'll also need to implement the caption text field in the Gif Editor and that will require some code to adjust the keyboard. Then we'll need to take the caption that the user inputs and add it to every image that makes up our animated GIF. Super! Let's get to it. Let's take a look at the GIF editor view controller in the Objective C project. We can see that it has three properties. A GIF image view, a GIF, and then in the .m file a caption text field. If we look through the implementation file. We see the view controller lifecycle methods. We see a bunch of code for formatting the caption text field. We see the UI text field delegate methods, the code for adjusting the keyboard. And then a method called present preview. Okay, here we are back in the GIF editor view controller in the SWIFT project and we'll start by adding those properties. We already have a property for the GIF image view. So we need to add a property for the caption text field which we can drag in from storyboard. And we'll replace this GIF URL property with a property called GIF. And we're not really sure when this GIF property's going to be set. So we'll make it an optional. Next you're going to want to go back to the method, convert video to GIF, this is in the UI view controller record extension. Now, instead of passing the GIF URL from the convert video to GIF method, let's go ahead and initialize an instance of the GIF and then instead of passing the GIF URL. We'll just pass the GIF as a parameter to the display GIF method, and then we'll go back to our GIF editor view controller and set the GIF image view in view will appear. So instead of GIF from recording. It should be gif.gifimage. Now let's run it and see how it looks. This will also tell us if everything is in order with our GIF class. All right, okay. Let's launch the camera. Whoa! Super we can still see our GIF. So it looks like everything's in order with the GIF class. Hopefully you will be able to see your GIF too. And now we'll move on to implement the UITextField delegate methods. Here in the presentPreview method you can see that once we have the caption, we need to recreate the GIF following these steps. Here in this line we recreate a new instance of Regift. After that, we create a new GIF including the caption and save it to a URL variable. With the URL to the newGif, we create an instance of the GIF class. Then we assign that instance of the GIF class to the preview view controllers GIF property and push the preview ViewController onto the navigation stack. Let's revisit our To-do list. At this point, you should be able to run the app and see a GIF with a caption added in the preview of your controller. For example, here's my roommate's dog, Mia, patiently waiting for a treat. Notice that I can make a GIF from this video, and then I can add a caption and I can see the caption in the preview. Sweet, add a caption, done. We can check that one off. All right, moving on to share the GIF. Our share the gift task has fewer steps. We just need to add the GIF to an activity items array, and then present options to share it with an Activity View Controller. If you open up the GIF preview of your controller in the Objective C Project, you'll see the method sharegif. If you built the app meme, this code may look very similar to the code you used to share a meme. Notice that the GIF is being sent as an NSData object. And that the NSData object is being initialized from the GIF objects url property. The ActivityViewController is being initialized with an array of activity items which includes just one item, the animated GIF. The completion handler is being set so that if the activity is completed we return to the RootViewController, which right now is the welcome view controller. The ActivityViewController is presented modally. Recreate this functionality in Swift and then move on to compare your implementation to the sample code. At this point, your share gif method should be in place and connected to the share button. So your app might look something like this. Here's a video of my coworker, who I accosted while she was looking at her data. I add a caption, and now I can text it to my teammate. And you can see that in the text message it appears as a GIF. So now, we can check off Share the GIF. Next step, convert a video from the album into a GIF. In order to convert a video from the album into a GIF, you'll need to create an action sheet that has three options. Record a video. Choose from existing videos. And cancel. To enable the option to choose from that album, you'll need to write a method that launches the photo library. So let's move on to create an action sheet. Let's take a look at the code in the UIViewController (Record) category in the Objective C project. To create this ActionSheet, first we'll need to rewrite the method presentVideoOptions.Then we need to connect that method to the record button instead of launch a video camera. So let's switch back to the swift project and rewrite this method in our uIviewController swift extension. Okay, here we are back in the swift version of GIF maker. In our UIViewController swift extension. We've created the function presentVideoOptions and first we need to check if the camera's available. If the camera's not available, we want to launch the photo library which we'll just put in comments for now. If the camera is available we create an action sheet of type UIAlertController. Next, we need to create three actions to add to the ActionSheet. Here's the first one, recordVideo. It'll have the default style and the completion handler will call the method launchVideoCamera. Here's the second action, chooseFromExisting. It also has the default style and this action will call the method launchPhotoLibrary, which again, we'll just put in comments for now. The third action is cancel. There's a designated style for cancel, and we can leave the completion handler nil. Then we add each of the three actions to the ActionSheet. Finally, we present the ActionSheet and set the tint color of the titles to pink. In the end, the ActionSheet will look something like this. Okay, back to our list again. Hopefully, now you've created your action sheet and implemented the method, Launch Photo Library. So, your app might look something like this. Here's the action sheet. And here, I press Choose from Existing, and I'm able to choose this video. I took this video where I'm pretending to squish my coworker. And then, just like with the newly recorded video, I can see my GIF in the GIF editor, and I have the option to add a caption. So, convert a video from the photo album into a GIF, checked. We're getting to the homestretch. We just need to enable some simple editing to improve GIF composition, namely, we're going to allow the user to trim a video before it's converted into a GIF and constrain the GIF to be square, so that it doesn't get distorted. We're down to the last item on our checklist. Let's see where we are. Here's some footage I took earlier of one of our video producers Hezekiah stuffing a paratha in his mouth and I want you to take note of the space above his head. That's how we'll be able to tell whether the video has been cropped to square. Now I'll trim the end a little bit and there's our GIF. You can see that it's trimmed, it's no longer distorted and that space above Hezekiah's head is gone. So we know that our GIF has been cropped to square. So now we can check off the last item on our list. That wraps up the first iteration of Gift Maker. Now you have hard evidence of your ability to read Objective C and migrate features to Swift. Show off your skills and get a few laughs by sharing the gifts made with your app on social media. Next up, we'll make Gift Maker more professional by adding the ability to save and persist data. Now that we can generate copious hilarity with GifMaker, it'd be a shame to toss all those witty nuggets to the wind every time we restart the app. In this lesson, we'll give GifMaker the ability to save and persist data. Let's take a closer look. In the first iteration of GIFMaker, you may have noticed this create and save button on the preview screen. In this next iteration, we want that button to do something, namely save and persist GIFs. Here's what the new flow will look like. The app opens up to the welcome view the first time a user opens the app. But from then on it opens up to the saved gifts collection view. With the saved GIFs collection view as our root view controller, we follow a flow similar to the first iteration until we get to the preview screen, where now the user is able to save a GIF. Once a GIF has been saved, it's added to this collection view. Eventually you can build up a collection and persist the GIFs, such that when we close and relaunch the app, our GIFs are still there. Let's walk through the tasks you need to accomplish to take GIFMaker to the next level. You want to be able to save a GIF and display it in a collection. So you'll need to implement a collection view. You want the user to be able to view the details of each GIF in the collection. So you'll also need to set up a detail view controller. You want to be able to persist GIFs, which we'll do with NSKeyedArchiver. And then in the end, you'll want to add some finishing touches, including styling, and the first time user experience. Let's start by focusing in on the first two tasks. Save a GIF and view GIFs in a collection. In order to save a GIF, you'll need to create the SavedGifsViewController and configure the PreviewViewControllerDelegate. In order to view GIFs in a collection, you'll need to implement the necessary protocols, starting with the CollectionViewDatasource protocol and the CollectionViewFlowLayout protocol. You'll also need to create a custom class for the CollectionViewCell. Let's get started by creating the SavedGifsViewController. OK. Hopefully your SavedGifsViewsController is ready to go. Now let's add the ability to manage a collection. If we look in the Objective C project, we can see that the SavedGifsViewsController conforms to the UICollectionViewDelegate, the CollectionViewDataSource, and the UICollectionViewDelegateFlowLayout. So when I add all three of those to the Swift file. Now let's take a look at the implementation. If we scroll down to where the datasource methods are, we can see our familiar friends. NumberOfItemsInSection and cellForItemAtIndexPath. Cool, no surprises there. Let's switch back to the swift project, add our protocols and then implement those methods. I've got a mark here for the delegate and data source methods. And now we want to add collectionView, numberOfItemsInSection, and cellForItemsAtIndexPath. For numberOfItemsInSection, we're just going to want to return the number of saved gifts. And oops we're not really ready to implement self into the next path yet because we haven't made our custom cell. So let's make our custom cell. Go ahead and add the GifCell class and have it inherit from CollectionViewCell. Open up storyboard and find the scene called my collection. Inside the collection view, you'll see the GifCell now go ahead and drag an outlet from the GIF image view into the GifCell class. And then also in the GifCell class we're going to need a function called configureForGif and this is where we'll set the GIF image. And now let's switch back to the saved GIF view controller. And of course if we want to be able to see our GifCell, we should give it a size. So let's go here to our mark for the CollectionViewFlowLayout and here we are. Here's the method for sizeForItemAtIndexPath. So the width of our cell is going to be approximately half the width of the collectionView.frame. But of course this method expects us to return a size and we're going to need a margin as well. So let's go up to the top of our class and create a constant to hold the margin. You'll want to make this cell margin a CgFloat so that it plays nicely with the CgSize and we incorporate it into our widths. And then, of course, we'll want to return the size, and we should be good to go. So this ought to give us two columns of cells in our collectionView. And let's not forget to implement cellForItemAtIndexPath. So of course we want to dequeue a cell we want to cast it to a GifCell. We'll grab a gif from the savedGifs array and we'll figure the cell for that gif. [BLANK_AUDIO] Now sometimes when I just want to see my cells before I have data a put in them I'll make them a weird color so they stand out. So I just went into storyboard and I made them this blue color. And just for testing purposes, I'm returning 5 here in number OfItemsInSection, and then I commented out these two lines in cell for item index path. And then when I run the app what I see is this so I can see my collectionView and I can see my cells and I can tell that their space the way I want them. I can also see that this view is kind of blocking my collection. If you look in the Objective C project. You'll notice that this view that has the pink squares is called the empty view, because it's the view that's meant to appear when the collection is empty. My collection isn't empty right now. So I'm going to go ahead and add an outlet for this empty view and I'll add a line to viewWillAppear so that when the number of savedGifs does not equal zero the emptyView is hidden. Go ahead and add an outlet to storyboard for the collectionView and then while we're here and viewWillAppear we can call reload data. And now you can move on to work on the preview controller. All right. Let's see where we are. If you were able to get the preview view controller delegate set up. Your app probably looks something like this. I open up the app to an empty collection. I'm able to see my GIFs in a collection. But when I close out of the app completely, and then I relaunch, my GIFs are gone. So we can check off Save a GIF, and we can check off View saved GIFs in a collection. Now, I know we still need to set up our detail view but so we don't have to generate test GIFs every time we relaunch the app, let's go ahead and persist the GIFs first. In order to do that, we'll need to be sure that the GIF class conforms to the NSCoding protocol. We'll need to save the GIFs to the documents directory using the NSKeyedArchiver method, archiveRootObject. I will need to retrieve those saved GIFs using the NSKeyedUnarchiver method, unarchiveRootObject. If we open up the Gif class in the Objective-C project, we can see that the Gif class inherits from NSObject and conforms to the and NSCoding protocol. We're going to need to add both of those to our swift gif class. Remember that in order to be visible to Objective-C APIs, a swift class must inherit from an NSObject and that's true of the NSCoding protocol. If we open up the gif.m file, we can see that the two required methods for the and NSCoding protocol are implemented here. The methods initWithCoder and encodeWithCoder. Naturally, we'll need to implement these methods in the swift version as well. You're going to rewrite the method initWithCoder, just like you see here, calling decode object for key for each property to an unarchive a gif. And you're going to rewrite the method encodeWithCoder just like you see here. Calling encodeObject forKey which takes the object to be archived and the key as parameters. So to start off with, here we are back in our gif.swift file. And we're going to add NSObject and NSCoding. And of course the NSCoding protocol requires two methods. init with coder, and encodeWithCoder. So, unarchiving is going to look something like this and archiving is going to look something like this. And I'll let you guys take it from here. Did you notice how when we called decodeObjectForKey we had to cast each of the returned values? Why do you think we had to do that? Take a minute to guess and then continue on. [BLANK_AUDIO] If we Alt+Click on the method decodeObjectForKey so we can look at the documentation, we see that it returns an object of type AnyObject. Well, in any object optional that is. Of course, in Swift, we want our objects to have specific types. Compensating for differences like this in typing is a common interoperability challenge. Now that we have a file path where we can save our GIF's we just need to add two method calls. The method that saves the GIF's, archiveRootObject, and the method that retrieves them, unarchiveObjectWithFile. If you look in the app delegate of the Objective C project you'll see that these two methods are called here. But we want to keep our swift app delicate nice and clean, so we're going to call these methods, in the save to GIF's view controller instead, so switching back to our swift project. So here we are in our save to GIF's view controller, and I'm going to suggest that we call archive root object, as soon as a GIF is saved, here in the method previewVC, didSaveGif. Now where should we put the method call that retrieves our GIF's. Okay, hopefully those NSKeyedArchiver methods were pretty straightforward. Time to check in and see if your app looks something like this. Here, I've created a few GIFS, then I close the app, I shut it down so it's not running in the background, and when I relaunch it, my GIFS are still there. Fantastic. So, now we can check off Persists saved GIFs. Next up, let's go back and set up the detail view for the GIFs in our collection. In order to do that, you'll need to create the DetailViewController. Implement our old friend, didSelectItemAtIndexPath, to present that detail view, and then, add the ability to share a GIF from that detail view. iOS teams today are faced with finding ways in which their apps can benefit from Swift, and challenge to decide what features should be ported. Now that you've used tools like NSKeyedArchiver and Collection Views in both Swift and Objective-C, you're well positioned to help your future team navigate this transition between languages. Next up, the top five challenges to enter operability. We talked to Keith Smiley, an iOS engineer from Lyft, and Izmir Sing, an iOS engineer from Venmill, about what it was like to migrate their apps from Objective-C to Swift. Keith and Izmir are intimately familiar with the challenges and triumphs of achieving interoperability between the two languages. So we asked them about the problems they encountered most frequently. To wrap things up, in Lesson 6 we'll review the most common challenges for interoperability between the languages of iOS, and you'll complete a set of coding challenges to sharpen your interop skills. Our old app is currently 30% Swift and 70% Objective-C. So we had a lot of Objective-C code that was interopting to Swift with the Swift headers. And a lot of the time because of implicitly unwrapped optionals, we would expect some variables to be non-nil but because for some reason or for some edge case, we had a nil parameter passed through that would cause lots of bugs. And I think we had thousands and thousands of crashes in our current app because of that interop issue in general. And that's actually one of the reasons we decided that like going 100% Swift is important for both our developer happiness, because this is a much nicer code base to work with, but also for the happiness of our users, who will be able to use a more robust product. So the most common interoperability ability challenge I've encountered is when I'm going from Swift to Objective-C, so my Objective-C code is consuming my Swift code. And the challenge I face is that all the time my Swift code, it includes structs and enums and other constructs that are specific to Swift only, so it's very difficult, or actually Xcode doesn't make it possible at all to create headers for those in Objective-C. And in order to have your Objective-C code consume that's that Swift code, you have to create like wrapper classes that kind of shim your code from Swift to Objective-C, which leads to like more lines of code, more files of code, and more complexity, which was probably one of the larger reasons as to why we decided to do a rewrite where we don't run into issues like this. After we completed our nullability audit, it wasn't completely smooth sailing, because we realized that our nullability audit actually exposed some bad practices that we were doing in our Objective-C code base, because sometimes things that shouldn't be nil ever, we were setting to nil, just not realizing that we were. But thankfully, with Apple's toolkit they've given us with Objective-C, and when they introduced the nullability audit, so the ability to do them, they'll give you warnings every time you set something to nil that's not supposed to be nil. And that was helpful in us improving the quality of our code base, making it more robust by removing those warnings, by making sure we'd never set those values to nil, or if they should be nil, by making sure that we make them nullable. There were actually no features that were especially difficult to port from Objective-C to Swift. And that's because porting anything from the Objective-C to Swift is relatively straightforward. Because Objective-C, when you went from Objective-C to Swift, like, all the constructs that exist in Objective-C also exist in Swift. So you can literally just go from a syntactical change from Objective-C to Swift. The point of our rewrite, though, was not to port the code like one to one, it was to make architectural decisions that led to a more robust code base. And that meant a lot of whiteboarding. There were multiple correct solutions, but probably one best solution. So it meant a lot of like just meeting as a team and figuring out what that best solution was. And that's where I think our brains worked the most. And it was an engaging, but also a difficult problem to solve. So for the most part, if I was writing a new app, I would write it 100% in Swift, because almost all the features that exist in Objective-C also exist in Swift. That said, if I wanted to do something crazy like method swizzling, I think because Objective-C's a dynamic language, I would do it in Objective-C. That said, I don't think I'd ever be doing method swizzling if I'm doing something the right way. So I would probably go 100% Swift and maybe some Objective-C dependencies if it made my life easier, but write my main product in Swift, because it gives you all the powers of map and flat map and generics and structs, and value types, which is very powerful that Objective-C just doesn't give you. As you remember, Objective-C is pretty blase about its handling of nil values. Like Desmir mentioned, by default any object can be nil in Objective-C. >From Swift's perspective, the danger of nil values lurks around every corner. If your Swift code is consuming Objective-C code, you need to be constantly checking for nil values. Unexpected nil values that are handled incorrectly can crash your app. To see how an unexpected null value might get passed to your Swift code, let's take a look at how Objective-C gets translated into Swift by default. Let's say we have an Objective-C class that represents a user. Our user class has properties representing a user's name, email, and avatar. And down here we have an initializer that takes two strings as parameters but doesn't take an avatar. Not every user has an avatar. If we click on this icon in the top left corner, down at the bottom of the menu we see this option for Generated interface. Clicking that option gives us the interface that's generated for Swift. So, okay, we've got some Swift code now and we see name, avatar, and email along with the init method. But we also see a lot of exclamation points. By default, Swift treats every variable coming from Objective-C as an implicitly unwrapped optional. As we know, implicitly unwrapped optionals are dangerous. We don't want to be accidentally unwrapping null values. Having implicitly unwrapped optionals automatically sprinkled throughout your code base, is sub optimal at best. Apple realized this and has addressed this problem by providing nullability annotations. Nullability annotations clarify which variables have the potential to carry null values. These annotations are pretty straight forward. And they include nullable and nonnull. As you might expect, nullable pointers can have nil values and nonnull pointers cannot. So let's go ahead and annotate our user class. In this case name and email will be nonnull because every user must have a name and email. But avatar should be nullable. Now, see how this warning pops up down here? As soon as you add nullability annotations at one place, the compiler will start encouraging you to add them everywhere. It's all or nothing. No problem. We just need to add in annotations to the two parameters. Email and name are still both nonnull. The compiler is still complaining and it's pointing to this return type. To know how to annotate the return type we'll need to look at the initializer in the .M file. Notice that this custom initializer can return nil if email verification fails. So we'll go back to the header file and we'll mark this return type as nullable since sometimes it can be nil. There, now the compiler is happy, let's see what our generated header looks like now. Again, we go up to this icon in the upper left, click generated interface. Okay, now this is what we like to see, no exclamation points. The properties that we marked as non null, name and email, are interpreted as regular variables. The Aaatar property, which we marked nullable, is a respectable explicitly unwrapped optional, and so is the return type for the initializer. Even though technically Objective-C is a statically typed language, it sneaks in more flexibility in typing through the use of the type ID. ID as you'll remember is like saying to be determined or this object can be of any type. At runtime a more specific type is determined. Delegates generally have type ID as well as objects inside of arrays. When Swift is consuming Objective-C code, objects of type id are given the type any object. An object of type any object can hold a variety of types. Although your code may work if you allow objects of type ID to be imported as objects of type any object., it's not really in the spirit of Swift development to allow for such flexible types. Not to mention, any object can leave you vulnerable to unrecognized selector errors when you're dealing with untyped arrays. Let's take a look at an example. Here's a Backpack class written in Objective- C. And you can see it has a property called Keys which holds an NSMutableArray. This example project also has a class called Key which implements the method openDoor. Here's some Swift Code that's using the Backpack class. First, we instantiate a Backpack instantiated Key to represent her house key and then add that key to the backpack. So far so good, now let's take the Key out of the Backpack and try to open the door. The code above compiles fine but when we press run we've got a problem. So, let's go down to the console and see if we can see what's going on. We have to scroll up to the top. Okay,what have we got. Unrecognized selectors sent to instants and a bunch of numbers. What's this about a string. If we look again at the Backpack class we can see the first object in the array as an API key. So, it doesn't implement the method openDoor. OpenDoor is the unrecognized selector. We can avoid the unrecognized selector error by using optional chaining when we call methods on objects of type AnyObject. Method calls on objects of type AnyObject can be treated as implicitly unwrapped optionals. Here, the call to openDoor will just silently fail. Placing the question mark after openDoor is equivalent to conditioning on a call to the method responds to selector in Objective-C. If we want some notice when this method fails, because the method call acts like an implicitly unwrapped optional, we can use if let to handle two different conditions. Another prudent alternative for handling objects of type AnyObject, is to cast them to a more specific type. Since you can't always be sure what that more specific type is, it's safest to use the conditional typecast operator as?, like so. And if we run it, we can see that this avoids a crash. And if we grab the second item in the array instead of the first, the cast succeeds and so does the call to openDoor. If you'd rather minimize the use of any object all together, you can provide information about the contents of Objective C collections when those arrays are defined using lightweight generics. For example, let's say we added a property to our BookClass to represent the awards that a book has one. Each item in the array is a pointer to an NSString representing the name of the award. We indicate that by placing NSString in an asterisk between angle brackets before the property name. And here's what it looks like when it's translated to Swift. Notice that, instead of being an array holding objects of type any object, awards is an array holding objects of type String. We can also do this with dictionaries. For example, we might have a property representing a dictionary of quotes about the book that are paired with their source URLs. Again, we indicate the types held by the dictionary here and between angle brackets. And then, if we look at the generated interface, we can see that the swift version of our quotes dictionary is holding keys of type string and values of type NSURL. Keep in mind that lightweight generics are only supported for NS-array, NS-set and its NS-dictionary. They won't work with NS mutable arrays. In objective C, a pointer to an error is generally passed as the last parameter to a method that could fail. If the method does indeed fail, a value can be assigned to the error pointer. Let's take a look at an example. This method, do something that might fail with error could be used something like this. Note that because we're passing a pointer to a pointer, we use the double asterisks in the method definition and we use the ampersand in the method call. If you take a look at the NSError class reference, you'll notice that NSError has three properties: domain, code, and a user info dictionary. These properties are access to get additional information about the cause of an error. A similar error causing function in Swift would look like this. Swift uses the keyword throws rather than an error parameter. And here's what the method call might look like. Notice the do catch statement. In Swift, if you have a method that throws an error it's required that that error be handled either with a try or a do catch statement. And Objective C on the other hand, it's perfectly acceptable to ignore an error completely. The error itself might look something like this. You'll often see each error case handled individually, like so. Remember that enum members can be associated with values. One can use associated values to provide information about errors. And if we run this, we can see the string associated with each error printed to the console. At first the systems of error catching in Objective C and Swift, may seem pretty different. But errors actually travel between the two languages remarkably well. In Objective C, returning a false value in this case would constitute an error. Now you might think that this BOOL return value could cause a problem. But swift doesn't have to bother with the BOOL. Let's take a look at how an error causing function like this one would be translated in Swift. If we look in the generated header, we see that the Swift version of the method doesn't have a BOOL. It just throws an error that can be caught just like any other sort of Swift style error would be caught. Also notice, that there's no more error parameter and the width error at the end of the method name has been removed. In Objective C, an error can also be signaled when a method with an error parameter returns a nil value. Let's take a look at the generated header for this perform some action on string method. Now as a Swift developer. I'm sure your ears perked up at the mention of a nil value. But don't worry, we can handle that nil value in the same way we would handle any other error-throwing function that returns a value. With the tri-question mark construct. Notice that the return type for this function is just a plain old string. Not an optional. Since Swift generally uses enums for errors. It's straightforward to catch specific errors and define customized responses. And you can still do this when your code is consuming NSErrors. With a defined set of common error codes that is. Even though NSError doesn't encode errors as enums. The properties of NSError have been defined, such that the most common errors can be accessed using dot syntax. Like so. You can find a list of the available NSError codes in the Foundation Constants Reference, linked in the accompanying text. The bottom line when your Swift code is consuming errors from objective C, is that apart from using the class name NSError. You can pretty much treat an NSError as you would treat a SwiftError. What about when your Objective-C code is consuming Swift errors? Let's take a look at how a Swift method that throws would be interpreted by Objective-C. Here I have a project whose main function is in Objective-C. The project includes a Swift class with the following error throwing function, this function throws an error of type MyError. Notice that in order to expose this enum to Objective-C, I mark it with the attribute @objc. Now we're going to call this function from our main function. We've got a variable to hold our error and an instance of SomeSwiftClass. Now let's call our Swift function. Notice that Xcode gives us the option to call doSomethingThatMightFailAndReturnError. AndReturnError has been appended to the method name and now we have the option to pass an error parameter into the method. Cool, that's not that surprising. It's pretty much the reverse of what we saw going from Objective-C to Swift. Now let's see how the error might be processed. We'll write a log statement and in that statement we'll grab the domain and code from the error that's returned. And then if we run it, here's what we see in the console. So the domain and error code are automatically populated, which is super. Unfortunately, if you want to know the value of the enum member that goes with that code, like WeirdReason or TypicalReason that you can see here, you can't access it directly from your Objective-C code. You have to look back at the enum implementation. It was no coincidence that I wrote the MyError enum to be of type Int. Let's not forget that enums in Objective-C can only hold ints. That means that if you have a Swift error that you want to be consumed by Objective-C it has to be of type int. Unfortunately, that means that enums like this one, that provide information about the errors right in their raw values, can't be translated to Objective-C. Even though NS errors aren't as spiffy as Swift errors, the takeaway here is that the interrupt for error handling is mostly handled for you. NS errors just work in Swift. And all you have to do to get your Swift errors to work in Objective-C is mark them with the attribute @objc, and make sure they have an integer type. In the section on error handling, we used the @objc attribute to expose an enum of type ErrorType to Objective-C. When I place that modifier in front of this particular enum, the compiler doesn't like it very much. Okay, let's see what the compiler has to say here. @objc enum raw type 'String' is not an integer type. So I'm reminded to change this to an integer. And of course I have to change the values to integers, too, and the error goes away. And now I'm able to access these error codes from the parts of my project that are written in Objective-C. These compiler errors can be really helpful because they flag code that would otherwise be silently ignored. For example, let's say we're back in our house class and we've added a Swift struct to represent a hot tub. If I mark this HotTub struct with an @objc attribute, I see an error. @objc can't be applied to this declaration. And of course I'm reminded that Objective-C can't consume structs. So I edit my HotTub to be a class. I make sure it inherits from NSObject. I edit these functions a little bit. And now when I add the @objc attribute, I don't see that error any more. I can see that there's no problem. Although, now that HotTub inherits from NSObject, I actually don't need the @objc attribute any more. Achieving interoperability between SWF and Objective-C is no small feat. How do we promote clear communication between these two languages? How can we ensure that when a variable has passed from Objective-C to SWF, SWF knows what to do with it? These are questions that iOS engineers will continue to wrestle with for some time. Master these five challenges and you can become an important part of the conversation and the resolution. In the meantime, Hey what you working on? Yeah, I'm having some trouble deciding what to do about the Udacity app rewrite. Ooh, are you going to rewrite the Udacity app in Swift? You know, I do code more quickly in Swift, but rewriting the entire app would be a lot of work. On the other hand, I don't really want to write new features in Objective C. Did someone say Objective C? Objective C is so dynamic. Doesn't make you feel like you have more power as a developer? Yeah, that's true. But Swift is a more modern concise language and it probably improve performance. Yeah, that's true too. The more I think about it, I think the best move might be to try to use them both. Hmm, but Objective C and Swift are so different. How are we going to get them talking to each other? [MUSIC] You say, inum and I say, inam. You say, dynamic and I say, static. Inum, inam, dynamic, static, let's call the whole thing off. You say, giffy and I say, jiffy. You call a function and I say a message. Giffy, jiffy, function, message, let's call the whole thing off. But, if we call the whole thing off. You lose foundation. And if we ever part, then that might break my app. [MUSIC] So if I liked type arrays and you liked untyped, I'll take them untyped with optional casting, for we know we need each other so we better call the calling off, off. Let's master. You say, care. And you say, car. I like to swizzle. And I do not swizzle. Care. Car. Swizzle. No swizzling. Let's call the whole thing off. [MUSIC] But if we call the whole thing off- You'd loose core data. And if we ever part then that might break my app. So if I pass you value, would you want some warning? You can use annotations. For we know we need each other so we better call the calling off, off. Let's master. Let's master. [BLANK_AUDIO]