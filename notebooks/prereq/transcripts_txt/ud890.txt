Hi, I'm Ido Green. I'm a Developer Advocate at Google. And I'm Cameron Pittman. I make front-end courses here at Udacity. Cameron and I want to help you a bit with the forms, because almost any meaningful experience on the webs come with boxes that need to be filled. It might be a registration form, a shopping cart or a sign in form. All of these need simple forms. And why? Well, it's because the simpler the form is, the more conversions you're going to see. Right, and in fact, according to Chrome usage data, you can make forms 30% faster by just making them ready to autofill. We will dive into it in the second lesson. For now, just remember that with faster forms comes happier users and more conversion. And that's why we're here. This course is all about best practices for designing and developing forms. We want you to build forms that work great for all your users, no matter their platform, mobile or desktop. However, mobile platforms are a bit more of a challenge due to the smaller screen size. So we are going to focus on that more in this course. Yes, and for this course, Ido and I expect that you're a web developer who understands the fundamentals of HTML, CSS, and JavaScript. We expect that you've been building sites with forms, and you're always trying to stay up to date with best practices. In the first two lessons, you'll be learning about inputs that make up forms. All the little button and toggles that clutter your user screens. And in the third lesson, you'll take on forms as a whole and examine what you can do to convert more users. This is especially important for e-commerce sites, but it certainly applies to any kind of long form. In the last lesson, you'll make forms reactive and touchable for mobile users. That sounds like a lot of fun. Let's get started. If you want to get better at building forms, you need to start critiquing forms. Many forms that look pretty reasonable are, in reality, not that great. With that in mind, I want you to try critiquing this form. You could find a link to it in the instruction notes. This form is actually part of the final project for this course which is an event planner app. You'll eventually have a chance to apply everything you've learned in this course, to turn this clunky app into a high conversion machine. And by the way, the version that you'll see in a few moments might look slightly different than this one. And that's simply because we might tweak it a bit between now and when you're actually taking the course. Overall though, it should look pretty much the same. Anyway, play with his form for a moment and when you're done, I have a question for you. How would you improve this form? Would you change the title? Would you consolidate inputs? And this means simply taking multiple inputs and turning them into one. Would you write better validation messages? Or would you add more questions? Check all that apply. I'll start at the top. Change the title? Mm, no, I wouldn't do that. Right now the title is Create an Event, and that seems pretty straightforward, so I'll leave it alone. Next up, consolidate inputs, definitely. Look, right now you have to select the time, the day, the month, and the year separately. And These are all really part of the same question so, I think it make sense that they're the same input. Seems like an improvement to me. Now, what about better validation messages, definitely. Here, let me show you what happens when you try to create an event without valid inputs. I will click this button, then I have to scroll down. And then I get a list of errors. This could be a lot more helpful in a lot of different ways so that should definitely be improved. And lastly, what about adding more questions? Well, you really want to minimize the number of questions you ask if you want to keep the form simple. So no, I don't think that adding more is going to improve this form. Okay, not too bad. In the next video you'll see an interview with Luke Wroblewski who is a product director at Google. Luke is an expert on forms. You're going to here him talk about how he approaches forms as a whole. Let's watch. Hi, I'm Luke Wroblewski. I'm a product director at Google, and the experience I have that's probably most relevant here is I wrote a book called Web Form Design, and in there I looked at all the little details and nuances that make forms work online. I think what you just said about thinking purposefully about forms is the key. All right, don't treat these things as one offs that you have to do. Don't just copy a pattern out there and assume that it works. Actually take the time to think what are you asking people, how are you asking them that? And if you put in a little bit of effort, you'll have a lot of impact and that's kind of the whole essence of form design. A picture is worth a thousand words, right? So I want to show you a few examples that will help you develop the right mindset for creating better forms. This is an example that is good. Notice how it is quick to finish. Notice the placeholders. The fonts are visible and big enough. Notice the progress bar. And this is an example that is not so good. Notice how it is hard to finish. Notice that you don't see any progress. The font is too small. I hope you noticed the patterns that well-designed forms share. In the next video, Cam and I will summarize the principles of a well-designed forms. When building forms, you've got one main objective, getting more conversions. That's when a new visitor to your site sign up or make a purchase and nothing is more effective than making forms quick and easy to finish. Yeah, that makes sense because the less users have to type, the less that's in the way between them and converting. It's pretty simple. You know, in my mind the best example of a super fast form is Amazon's One Click Ordering. It's great because you're just done in milliseconds. True, that's a fast form but it only works for some products and only if the users are already signed in. For all other situations, it pay to help out your users. Guide them through useful labels, pronged validation, and progress indicators. Build their confidence and watch your conversions go up. That's great advice, let's do it. While you are working to decrease the time it takes to complete the form, you've got a few options at your disposal to help out. First off, you could use your user's existing data. For example, if the user is logged into your site, and you already know their postal code because they submitted it in a earlier form, it will be nice of you to pre-fill the postal code field with a known one like you could see here. Another option is to access the geolocation in order to determine the postal code. This works even if the user isn't logged in. Check the instructor notes for more details. This is great because with almost no efforts, you saved your users time and you're one field closer to completion. In the date example, here it's three fields closer. Great, no? Another easy option is to enable users automatically fill fields by enabling autofill. You will dive deep into autofill attribute by enabling Auto Complete in the next lesson. But before thinking about our attributes on your inputs, I want you to think about the input elements themselves. Just look how powerful autofill can be. I'm just start typing here and when I'm choosing, it's automatically fill the form. You know, I'm one of those people that likes to finish something as soon as I think of it. If I think about something like let's say picking out a flight. I'll just take out my phone and start picking dates. And I found that I pretty often encounter dropdown menus, usually for things like dates. This seems reasonable, right? Okay, I want you to watch this counter that just popped up on your screen. It's going to count the number of taps it takes for me to search for a flight. Are you ready? Watch. Did you catch that? Three taps to select a month. Not a great start. Here, let me finish. [SOUND] Did you see how many taps that took? It's ridiculous. Clearly, there must be a better input than a dropdown. There are much better options than dropdowns. Check the links in the instructor notes if you still don't believe us. After watching Cam having terrible time with dropdowns, you should be asking yourself, how do I pick the right ones? How do I decide what input to pick? These are great questions. Luckily the HTML five star includes a number of input types tailored for every situation. You can find a link to the list in the instructor notes. Consider these the tools or building blocks for your forms. This should look pretty familiar. Here is on the left is the phone input. So here on the right is the Email and in the middle you could see the URL. And of course we have many more. Notice how each specialized input contains the buttons that the user needs. Nothing more, nothing less. This is great because we don't have too much real estate on a mobile device and we want to enable our users the most convenient way to type the information they need. In the next quizzes, Cam will challenge you to research on your own and pick the best input types for your forms. This flight picker app was annoying. I was tapping way too much to pick flight dates. This site is obviously using the wrong kinds of inputs. There's gotta be a better way. So for this quiz, I want you to think about the types of inputs you're inflicting upon your users. So you don't make the same mistakes that I did when I built this. Here are two HTML inputs. The first input is for date and the second one is for time. What types of inputs make the most sense for these two inputs? Check out the link in the instructor notes to a list of inputs on the Mozilla Developer Network. Do some research, and when you're done, type your answers into these boxes. So I'm on the Mozilla developer network and I have a list of inputs. I see a few relevant inputs like date, datetime and datetime-local. datetime and datetime-local are both really useful, but they both obviously include times. Given that there's a separate input for time in this quiz, I want to go with date. So I'll scroll down, and there is time. Well, that's pretty straightforward. This is what the form looks like before you enter date and time. You'll notice that these two are just defaulted to text inputs. And then after you enter date and time for the types, you will see that now you have a nice date selector for dates, and a nice time selector for time. That looks pretty good. Okay, so not everything about drop downs is all bad. For instance, the ability to give users a predefined list of options actually can come in handy. It's just that forcing users to scroll through massive lists of options can be tiring. And it's not very flexible because they have to pick one of the options. Incidentally, there is one kind of input that combines the helpfulness of a pre-defined list with the flexibility of a text input, and it's called the data list. Here's an example. With the data list, you still get a pre-defined list of options, but users also have the ability to type. And as users type, they will see options from the list get suggested. But this doesn't mean that users have to use one of the options. They can actually keep typing. This makes data lists a nice, flexible solution. The syntax is pretty simple. Rather than putting options in a select tag, put them in a data list tag. Each option should have a value set to whatever value you want it to take, and you'll need to give the data list an id. The input should have a list attribute, and the list attribute should match the datalist an ID. Check the Instructor notes for more information. For this quiz you're going to be building the data list you just saw. I'll be giving you a version of the demo with a dropdown, and you'll be turning it into this. As always, don't forget to take a look at the instructor notes, and good luck. Here's where the code starts. There's a select tag here indicating that this is a drop down and there are a few options inside. And this is what it looks like as a datalist. The differences are pretty minimal. Starting right here you can see that the select tag turned into a datalist tag. I added a list attribute to the input with the same ID as the data list. And I changed all the option values from inert HTML text to values. And once again here's the finished data list. I like it, these are super useful. All right, well next up, you're going to watch the next part of the interview with Luke. This time, he'll be talking about what makes a perfect form. Let's watch. The perfect form is no form. Right? Nobody wants to fill in forms. And I mentioned before, I wrote a book about web forms. The first two words in the book are forms suck. Which is very true, right? Nobody wants to go through that process of filling in a form. They want what's on the other side. They want that ride from Uber. They want the book from Amazon. They don't want to sit there retyping their name for the bizillonth time. And ultimately it's almost an insult to the person. Technology is supposed to change the world, but the damn computer doesn't even remember what my name is? How many times must I type my name into the same freaking computer before it knows who I am? Like I said, it's almost insulting to people to treat them that way. So my ultimate example of the best form is no form. And that's why I like these things that get you down to a single tap or something where you can just instinctively say, I want that and get what you want. We are a long ways away from that, in any case, but there are a couple examples, which was very promising. And, usually, that's how things start. Or you'll see one or two examples that people say, oh, that's unachievable, but gradually more and more people get to that point and it becomes the new norm. You know, there are other ways to predict what your users will want to type. Yeah, for instance, if you already have your users relevant data, why not just prefill the form for them? It's easy enough. Even if your users aren't logged in, you can still help them out. For example, you could guess their location using location services. Check the instructor notes for more details. In the end, this is all in the pursuit of the most important principles to take out from this lesson. Speed equals conversions. This lesson got you thinking about fast, efficient inputs, but you are just getting started. In the next lesson, you'll dive into other time-saving tricks, like creating inputs that support autofill and validation. Awesome, see you there. Welcome back. In the last lesson, you starting building efficient form by picking input types. It's a good start, but you could do more to make inputs even simpler. Yeah. In this lesson, you'll be helping your users fill out inputs faster and with more confidence. This means adding useful labels and prompts, enabling auto-fill and validating their inputs. Let's get to it. First things first, labels Pop quiz for you and for you. What was the last website you visited? Don't say Udacity. I'll pause for a moment to let you think. Cam? Maybe Twitter? I can't remember. Maybe [LAUGH]. [LAUGH] You know, there's a pretty good chance that you are like me, and you didn't immediately recall. And that's okay, because everybody forgets things. It's not a big deal, but as a developer you should do what you can to help people remember what they're doing while they're on your site. The good news is that we've got the label element. Labels should be prominent and visible when a user is filling out their associated inputs. When writing HTML, use the label element as a container for your inputs. Associated inputs get nested inside labels. You could use the four attributes to link inputs and labels. Either way works fine, but I like to nest because it simplify my HTML and makes it more semantic. As an important bonus, applying labels to our form elements helps to improve the touch target size. The user can touch either the label or the input in order to place the focus on the input element, like I'm doing right now. And you could see here that we're using the four attributes. Okay, enough of me talking. I want you to try one out in the next quiz. Labels aren't too tricky. And you may have noticed that in previous quizzes like this one and this one, I was actually using labels. So, now it's your turn. In this quiz, you're going to be working with this page. There are two inputs that need some labels. The first label will be for this check box which is asking users if they want to use their shipping address, for their billing address. And then the second one is for this telephone number. For the billing address check box just use the for attribute, but don't nest the input inside the label. And then for the telephone number input, nest the input inside the label but still use the for attribute. Using it make sure that the screen readers connect the label with its associated input. If you get stuck, you'll find the link in the instructor notes to the Mozilla developer network documentation on labels. And one last thing. Eto and I, highly recommend that you test this input on an actual mobile device too. Check the links in the instructor notes, for more information. Good luck. For the billing address input I just set the for attribute on the label to the same ID that the input has. Easy enough, and then for the telephone number I nested the input inside the label. I actually like doing it this way a little bit more, because nesting it makes it more obvious that the input belongs to the label. I still used a for attribute though, so that my form would play nice with screen readers. And here's how it looks. Doesn't look too different right now but you'll notice that when you click on the labels, that their associated inputs get put into focus. Very nice. Next stop, we'll be continuing our interview with Luke Wroblewski. Watch him as he describes how he likes to design inputs. Customer wants to buy something, company wants to sell something, what's sitting in between them? A form. If you think about registration, a company wants to grow their user base, someone wants to be part of that community, or product or they have. And again what's between them is a form. So in all these places where this connection happens between the organizations that make things on the internet, and the people that use those things, there's generally a form. And those forms as you say consist of input fields. The biggest mistake that i think people make is treating those things from what I would call almost a back end perspective. That is inside of a database, to simplify things, you have these name value pairs, right, name and then a field for what the name is. And you've got a whole bunch of these things and they constitute something like the record of a user, or a purchase. And when it comes time to collect that information to fully fill in that database, what you do is you just spit out those name value pairs as input fields and labels. And ta-da, job done with a form. So both of these things I learned almost the hard way, if you will, at eBay about how to think about them differently. When I was at Ebay many years ago it was the 28th largest economy in the world. So lots and lots of people buying and selling things on there. And we found that when we made small changes to these forms we could really have a huge impact. In fact when we redesigned the registration form process, we had to go back to Wall Street and restate earnings because that was how tremendous the impact was. And when you think about the ability for something like a form to impact something like the 28th largest economy in the entire planet, you really start to understand the importance of all the little details in the forms. And that goes well beyond which name value pairs you include. How you put the labels in, what kind of form control you use, what kind of feedback you give to people as they're filling in this information. How do you organize it? What do you do to message the before and after parts of the form? because it's a part of a broader flow. And so the biggest mistake is really not considering that full envelope of form design, and really just regurgitating a database's fields onto a screen and putting a submit button on the bottom When you were playing with the label element, did you notice how the label appeared next to the input? This is not an accident. It makes it easier to see the label. Please remember, portrait and landscape view have different form factors. In landscape view ports, like this one, labels should be next to the input elements. In portrait view ports, like this one, labels should be above the input elements. Few things to keep in mind. If you are not careful, custom scroll handlers may scroll input elements to the top of the page hiding the label. You should especially avoid placing labels below the input elements because you run the risk that they may be covered by the virtual keyboard, not good. For example, here we make sure that all the labels appear above the inputs because, as you can see, the virtual keyboard is coming up. Along with labels, placeholders like this one are super useful for text or numeric inputs. Use placeholders to give users a concrete idea of exactly what they should type. For example, an input on a city field show what is the expected value telling users they should use a full name of the city, like here. But remember that placeholders disappear as soon as the user start typing in the element, which means they are not a replacement for labels. They should be used as an aid to help guide users. At Udacity we've used this slogan in the past. Learn. Think. Do. And it definitely still applies today. There's no better way to learn than by doing, so for this next quiz you are going to do some placeholders. You'll be given a little input that prompts users to type in the name of an event. And I want you to give it the placeholder event name. Make sure you test on your mobile devices, and once again, check the links in the instructor notes if you need help getting started. This one is pretty simple. All you have to do is add the placeholder attribute to the input and set it to some text, which in this case is Event Name. And this is how it looks. Notice that you can see Event Name within the input when there's no text. But when you start typing, it disappears. Nice. All right, let's keep going. Let's talk about calendars. Many forms need the concept of a date. It shows up everywhere, ordering plane tickets, movie tickets, setting a doctor appointment, and probably a million other examples. You could turn dates into a three or four parts process with time, day of month, months, and a year. Or you could use a calendar widget. I like calendar widgets because they are much simpler, and more straightforward. You've got a few options for displaying calendars. You could use the browser's implementation by setting the attribute type equal daytime locale on an input element. But, you might find that it doesn't match the visual theme of your app, that's fine. You could always edit it styles or simply roll on your own CSS, using web components or a JavaScript widget. See the instructor notes, for some more info about styling or building calendars. Other way, the most important thing, Is to show your users a full calendar when they need to set a date. If not, users will never get away from your form to look up dates which only increase the odds that they will abandon the form all together. Here is another example. When I wish to book a flight, I can see clearly what are the dates that this flight is going to take off and land. Dates are common. Show your users calendars when they need them. Here's another opportunity for you to practice. This calendar is really doing things the hard way. Each part of the date is being typed in individually, as is the time. So for this quiz, I want you to simplify this calendar. Consolidate all of these inputs into a single input that still lets users input all the same information. And as always, take a look at the instructor notes if you want some more information. I started by going straight to the Mozilla developer network. I wanted to check out the list of different input types. As you might recall, there are two inputs that consolidate dates and times. And they are date time and date time local. Either one of these works for this quiz, but I like date time local a little bit more, because. I never mentioned anything about time zones. But there's no reason you wouldn't be able to make date time work either. And here's how it looks. You can click on this drop down arrow to get a nice visual calendar to pick out dates, and you've got a place to input times, perfect. Ugh. What? Come on, nothing. Ugh, come on! What? Nothing, you know what, I just can't deal with this, the buttons are too small. So you know what, I'm not going to buy these shoes, I just can't deal with typing my address in one more time on this small screen. Yeah What website is it. Yikes, they should do better. I know, okay, so my phone isn't actually on. But this scene isn't all that uncommon online. It's hard to type on a small screen. So if it's hard to type the form doesn't go through, and then the user abandons the form. This is particularly sad, if you're an online retailer and you just missed a sale. Right, we could leverage to autocomplete attribute. It tells the browsers to automatically fill the user's saved information into a form. Yeah, that sounds pretty useful. It is, here let me show you how. In modern browsers, there is a cool feature that you could use; autofill. Users appreciate when a website save them time by automatically filling common fields like name, email, and more. Plus autofill helps to reduce potential input errors like what Cam experienced before. Browsers use many heuristics to determine which field they could auto-populate based on a previously specified data by the user. You, the developer, can give hints to the browser by providing both the name attribute and the auto complete attribute on each input element. For example, to give the browser a hint that it should auto complete the form with a user's name, email, and phone number. You should use these auto complete attributes. Let's have a look on the name or should I say the first name, the input element has an AutoComplete attribute equal fname. On the email input, we have the autocomplete equal email. And on the phone input element, I'll have the tell AutoComplete like you could see here. Let's see it in action. When I start typing the address, you could see that the browser is already remember what was typed here before. And now with a click on the enter, I'm filling the shipping address with just a few clicks. Awesome. In the instructor notes, you could find a massive list of auto-complete attributes. Take a look and see how you could automate life for your users. And put a big smile on their faces. Now it's your turn to add some AutoComplete attributes. It's time to practice. Here is a very simple input for an email address. Right now, this box that you'll be checking out in a moment is just a text input. So the browser has no way of knowing what kind of information is about to be typed in. And if it doesn't know what's going to be typed in, it can't help you type it in. So for this quiz, I want you to make this input autofillable by adding an autocomplete attribute. When you do it right, you should start seeing some email addresses pop up here as you type. See the instructor notes for the list of possible attributes that Edo just mentioned. I started by heading over to the Mozilla Developer Network, and then looking at the autocomplete attribute. Here's a list of possible values, and scrolling down, you can see that one of the options is email. Back inside my HTML, I went to the input element and added the autocomplete attribute. I set its value to email, and yeah, that's all you have to do. So this is how it looks. Now, when I type into this input, I can see suggestions from past email addresses I've used. Perfect. Speaking of automation, it's worth mentioning the autofocus attribute. Autofocus automatically puts the cursor on an input when the input is rendered, making it easy for users to quickly begin using the form. Thus, the browsers immediately move the focus to the input field. However, mobile browsers ignore the autofocus attribute, so that the keyboard doesn't randomly appear. The Google home page, for example, as you could see here, uses the autofocus attribute on the search bar, because the vast majority of users just want to start typing the queries as soon as the page loads. See, use autofocus when you want to save your user's time. But be careful because it will still keyboard focus and potentially prevent the backspace character from being used for navigation. Also, it's recommended that you only autofocus inputs that are above the fold. Otherwise, the page will scroll down immediately upon rendering, which can be jarring. In many cases, we ask users to type out the same information, even when the website has their information. For example, think about name, address, telephone number, email, credit card, etc. Would it be cool to offer a shortcut that saves time, typing, and money? Yeah. You know, retailers often use past orders to suggest future inputs. Because once they've already collected and saved your address why ask for it again? Yeah, and it makes life less frustrating for your users. It also a good idea to ask permission. For example Amazon ask which saves address to use. But be careful. If your application fills in too much, users might get the wrong information. For example, shipping your package to the wrong address. Remember, reusing information will make your forms faster. So far, we focused on helping users fill out forms faster by, well, not filling out anything. But now, I want you to think about your users confidence, with good validation features. With validation, you can ensure that users know that they are filling forms with the right information. More importantly, validation can ensure that the users fill out form correctly the first time. They won't waste time leaving an input and submitting a form only to find out a few seconds later that they forgot a digit in their zip code. With validation, you are giving your users a real time feedback and minimizing errors. I want to choose and new password, and like in any good website, I have a few rules that I need to enforce. Here, while i'm typing, you could see that I'm using lowercase, and now I understand that I need an uppercase, as well, I need few numbers, and I just passed the minimum length of eight characters. I'm adding some punctuation, and only then, I'm enabling the next button. It's worth adding that HTML file validation or any front end validation, for that matter, is not a replacement for a service side validation. Your websites are obviously not safe, unless you validate on your back end too. The approach Cam and I are discussing is just a way to improve the user experience, and to put a big smile on the faces. In the next video, I'll show you how to use HTML5 attributes for validation. Ready to validate some numeric inputs? Well, here's a gradebook that calculates, well, grades. The way this gradebook works is that you just enter four grades here and then hit Calculate. And you see the average show up right here. Each of these grades should be a multiple of 10, which means they should be either 0, 10, 20, 30, and so on all the way up to a maximum of 100. There are a few issues with these inputs that I want you to fix. As it is right now, these inputs only take numbers, but the controls here on the side are less than useful. For instance, you can click and hold on this one and it will go up well above 100 and really, all the way up to infinity. And it needs to stop at 100. For this input you can actually go down into negative numbers, and there's no such thing as a negative grade. In this one we'll go up by 1s, which is fine, but we're expecting that all grades are multiples of 10, so there's no reason to go up by only 1. Now just so you know with HTML attributes alone, you won't be able to prevent people from typing crazy numbers like this one. But you can make these controls more useful. So for this quiz, it's your job to make them more useful. To do so apply the numeric validation attributes that you just learned about. You can see what each input is missing right here. And for bonus points, which don't actually exist [LAUGH], take a look at this text input for a letter grade. Try using the pattern attribute with regular expressions to validate possible letter grades. I'm thinking you could use American letter grades which go from A, B, C, D and then skips E and then goes to F, with subgrades of plus and minus. But feel free to validate for whatever grading system you're used to. And lastly, it's worth noting that these numeric inputs look and behave slightly differently in different browsers. So test in different browsers to see the differences. As always, check the instructor notes for more information. Have fun. Starting at the first part of the quiz, it needed a maximum. So I added a max of 100, that's easy enough. The second one needed a minimum, so I added a minimum of 0. The third one needed both a minimum and a maximum, so I added a minimum of 0 and a maximum of 100, not too bad. And the last one, the fourth part of the quiz, needed a minimum, maximum and a step so I added a minimum, maximum and a step of 10 so that the controls would jump up or down by 10 each time. And here's the input for the bonus question. In the bonus question, I challenged you to add a pattern attribute with a regular expression to validate the letter grade going into the input. Here's the one that I used which looked for either an A or A+. Or anything between a B and D with a plus or minus after it if it needed it, or just an F. Your regex may or may not have looked different and that's totally fine. Different school systems use different grading systems so use whatever works for you. And here, let me show you the form in action. All right, it looks good, each input is going up by 10, it looks like, all the way up to 100. Yep, won't go down all the way to 100. All the way to 100, and won't go down. And when I hit Calculate, I still see an average. And let me check this pattern attribute. Let me see if this works. I'm going to add a grade of M, which is not a real grade. So this should fail, and let me hit Submit. Oh, look at that. This field needs to be filled out. And that's because the required attribute was on it. So I filled that out, and let me hit Submit again. And now look, I'm getting an error here that asks for the requested format for this grade. So clearly an M doesn't work. Let me try an A. Hey, look at that. The form was submitted. I really hope you're starting to see just how useful these validation attributes are. They provide a fantastic first pass at making sure the data that's going into your forms is accurate. For more complex validation, you've got the constraint validation API which allow you to harness the power of JavaScript to validate inputs on the fly. Here let me show you how it works. The core of the constraint validation API is this function, setCustomValidity. And as you could see, it's getting a string. setCustomValidity makes the assumption that if you pass a none empty string to it, the input is invalid. So it displays an error message. That means that the opposite is true. If you pass an empty string to it, then the input is valid. In practice, simply set a callback on an inputs, on input event like we did here. And at the end of the callback, call setCustomValidity on the input. If we type in something like that, we will get the error message. And if we are typing correctly, we're passing the test. Good job. All right. Are you ready for a challenge? This quiz is going to be a bit more difficult than the last few. For this one, I want you to validate this new password entry using the constraints validation API. Notice how there are two inputs for passwords? This is pretty common and it prevents users from making typos when their letters are typed out as little black dots. You'll be using JavaScript and set custom validity to check that a, both passwords are the same. And b, that the passwords meet all of the requirements listed here. The validation messages that you pass to set custom validity are really important. They need to help the user out. Don't just tell them that something's wrong. If the password is too short, tell them how many characters it should be. If it's missing a number, tell them that it's missing a number, and so on. Give this quiz a good, honest try, because it's a great opportunity for you to think through the nuances of more complex validation. The idea of checking for these requirements may seem really straightforward, but the implementation details might surprise you. As part of this quiz, you'll need to think about string parsing, which can be, well, a little annoying. To help you out a bit, I'm giving you some regex's in the code that you might find useful. All right. Well, good luck. I know you can do this and, like always, check the instructor notes for more information. I think this quiz is slightly challenging because, though the logic is very simple, it's easy to accidentally get lost in a nasty series of nested if statements if you're not careful. It was my goal to keep my code as clean as possible. I'd love to see your code if you think you did better. Because this is by no means the best answer. Okay, let's get started. When you look into the script tag at the end of the body, one of the first things that you'll come across is this, the IssueTracker object. I'm using it to collect and then format the validation messages that I want to show. The idea is that I'll eventually call retrieve, which returns a string. And this string is the validation message that I want to pass to setCustomValidity. And remember that if there are no issues with the validation, then setCustomValidity expects an empty string. Which is what this case is doing. Next up, there is the onclick handler for submit. I start by grabbing the values on both of the inputs and then creating two different IssueTrackers. One for the first input and one for the second input. The reason is that sometimes I might want a message to show up on the first input, and then sometimes on the second. After that there is the checkRequirements method, and it's a pretty legible series of if statements. There's no nesting with these if statements so, I'm pretty happy. And this is where all of the regular expressions are coming into play. The only complicated if statement is this last one where i'm looking for illegal characters. Or those symbols that aren't explicitly allowed in the password. It's only a little complex because I wanted to inform the users exactly which characters they use that are illegal. So I have to loop through the regex match group to create all the different validation messages. Here's where checkRequirements actually gets called. And it only happens after I know that the first password and the second password match. After that, it's just a matter of retrieving the two messages and then setting them on each input with setCustomValidity. All right, not too bad, let's see this in action. Okay, now you can see that these are now password types, so you can't see what I'm typing. So let me fix that real quick. There, I switched from password to text, so now you can see what I'm doing. I'll try to submit this, and I see that they don't match. Okay, that's obvious. All right, and these two are too short, they're missing an uppercase character, they're missing a number and they don't have any symbols. So when i hit submit, I see all of that. Cool, okay so now I added some uppercase letters, some numbers, and some symbols and I'm pretty sure these match. Nope, and now they're still too short, less than 16 characters. Okay, now these two should be long enough now, cool. And my password was successfully changed. All right now I hope you didn't pay too much attention to that because that was my real password. No, I'm just joking. All right, anyway, I hope you had as much fun validating these inputs as I did. In the next lesson you'll start designing forms with all of the inputs you've practiced with so far. With designing comes testing. So in the next video watch Luke describe how he likes to test forms. So we use a combination of things. Over my career I've used lots of different things, all the way from itracking to usability to quantitative analysis. But I think the most important thing is to be iterative and to be in a process of learning. The worst case scenario you can get to is what I call the sort of culture of delivery. Which is, your whole processes are aligned to one ship date, and we redesigned checkout. Okay, what's the next project? And we shipped that, that's done. All right, that's a culture of delivery. A culture of learning is, hey, we're going to try this. Oh, let's see what we can learn before we actually build it. Oh, we started to build it. Let's prototype it, and make it better and better. Hey, we launched it. What happened? Let's measure. We should tweak that. Let's keep measuring. Let's keep learning. When you do that then you find all of these opportunities for optimization, and for insights, that you wouldn't have. If all you're doing is getting to that launch and then moving on to the next launch after that. So internally here I have a number of different teams that look at both sides of the equation. We do rapid iterative prototyping up front. So we'll build a little prototype, we'll put users through it, and we'll learn, do they understand our intent. Can they actually act on what we're trying to allow them to do? And then after launch, we'll go and track the metrics and sometimes with the metrics you'll see, oh that's weird. Why is that going on? And then the next natural step is to actually go talk to people. There's a case study that Expedia published a long time ago. Which was fascinating to me because they had a check out flow, standard thing, right. You have booked the trip and you're going through and they had this optional field called company, right above billing information. And for whatever reason, people would enter their company, and then start putting in the address of their company below company, which kind of makes sense. But what happened is, they would get these billing errors. Because they put in a billing address that is not the billing address of the credit card, instead it's the company that they work for, this was an optional field. So Expedia removed it, and instantly they got 12 million more in profit a year overnight just from dropping this one optional field. And until you actually see somebody go through a flow, how would you ever guess why there's so many errors? You have to talk to a couple people and go, oh they think it's their company's address that's why we're getting all these billing errors. It's not like bad credit cards or what have you. So that combination of the quantitative data, hm, lots of errors in billing addresses, and qualitative, why let's talk to them, really lets you fix the product and make it work. At this point, you've done a lot with individual inputs. You should be proud. Right, you've tried out different input types and you know how to pick the right one for the right situation. You've attached useful labels to your inputs ensuring that users always know what they are typing while they are typing. You've used the autocomplete attribute to help the browser autofill common input fields. You've used different validation attributes to validate users' input, even before they submit your forms. And you've played with the constraints validation API, for those times when you need to validate more complex inputs. In the next lesson, Ken and I will help you to take a step back from looking at single inputs to looking at the forms as a whole. Right. Let's get started. We're glad you're back. In the last lesson you practiced building better inputs. You practiced picking the right input types. You enabled autofill. You added clickable labels and you validated inputs. Now it's time to take a step back from perfecting individual input and start thinking about designing better forms made of many inputs. This lesson is particularly important for e-commerce, where better forms means more sales. Yeah, this is really, really important. And take a look at PayPal's ridiculous rise in mobile payments. I think it makes sense that this lesson also focuses on creating great mobile experiences. Definitely. Luckily, there are a few basic principles everyone can follow to build better forms on every platform. And they also apply well outside of e-commerce. Your ultimate goal is to minimize the amount of time your user spends filling out forms. In this lesson, you'll practice techniques to make forms mentally easier for your users to handle. And at the end of the lesson, you'll be given two ugly, nasty forms with low conversion rates. It'll be your job to apply best practices to improve the forms and boost conversion rates. Awesome. Let's go. Yeah, let's go. Following a few principles, we make forms a breeze for your users. Which ultimately means more conversions for you. One, make forms as short and sweet as possible. Avoid making any redundant information and auto-fill as much as possible. Two, provide helpful prompts. In the last lesson you did it with the label elements. Three, provide immediate feedback. Feedback comes in many different shapes. In the last lesson, you get feedback on an input with an instant validation. In this lesson, you'll use progress bar to provide feedback on the users progress through the entire form. You can learn about these principles and more through the link in the instructor notes. Now that these principles are fresh in your mind, Ken is going to help you do some brainstorming. I know that you have quit filling out a massive form like this one before. I know you've groaned when you've come across some huge form with a million pages and tons of little radio buttons, because nobody likes to click these for hours on end. So, with that in mind, I want you to brainstorm some questions that people ask when they come across big forms like this one. The reason why is that one of the most important skills for any developer is empathy. Empathy is the ability to see the world through somebody else's perspective. Any one who creates any thing for any other people needs a strong sense of empathy. And that includes web developers. Remember, you're building a website for your users, not for yourself. So this questions is going to be a free response question. See this long form? Ask yourself, what are you thinking when you see it? What do you want to know before you start? What kind of knowledge would help you finish it? Type your answer into this box, and in the solution video, I'll show you what I think. Share your answer in the forums, too, because maybe one of you will catch something that I didn't. So I actually got this survey a few months ago from my university's alumni association. It was awful. There were hundreds of radio buttons and every question seemed basically the same. I had no idea when it would end. I know it was probably important for them, but I just kind of gave up halfway through. I just didn't want to spend 20 minutes clicking little radio buttons. So if you're watching this and you're from my school, sorry. But anyway, that's one question. How much more is there? Most of us have places to go, people to see. And you know I started the survey so that probably means that I cared enough that I wanted to finish it. But then I started weighing my options. I could keep going and lose an unknown amount of time, or I could just quit and be done with it. Neither option seemed that great. So I wondered if I could save my progress and come back later. Would it even be safe to close my laptop? I wasn't sure, so that's my second question. Can I finish this form later? This is especially important for e-commerce, where people may start shopping now, but actually purchase later. I take the train home almost every day. My laptop doesn't have Internet on the train, but my phone does. I'm always looking for work I can do to keep myself occupied on the hour of my journey home. So that leads to my next question. Can I finish this form on a different device? Giving your users the option to easily finish later only makes it more likely that they'll actually finish. These all seem like really reasonable questions to me. In the next video you'll watch the next part of the interview with Luke. He'll describe the ways he empathizes with users when testing new forms. Yeah, so my process for sort of putting myself, the methodology I like to think of here is this sort of outside in view. This is, you look at what your product looks like to people outside of your organization. Most companies think about it from inside out perspective. That is, oh we have these legal requirements, oh, the tech team can only build this. The design teams, and you add up all of these different ideas and thought processes, which make a lot of sense within the bounds of your company, but don't make a lot of sense when somebody's looking at it externally. This is why you find simple forms, like a Contact Us form, including 20 fields, because this one came from legal, that one comes from marketing. You have five things like this because the database is structured this way. And one very common technique, not common but very useful technique that you can have to force yourself to think outside in, is to actually have somebody role play the role the role of a form. And what do I mean by that? If you give someone a form, and you act like a human, and they only are able to respond with what the form says. So as an example you can say, hi, I'm Luke. I'm trying to decide whether or not I want to get a loan with you. First name. Okay, Luke. Last name. Wroblewski. Gender. Male, right, you can really start to see how it doesn't make any sense as a conversation. If instead you were to make that a real world conversation, you'd say something like, hi, I'm looking to maybe get a loan. Oh, well what are you trying to buy? Oh, well I'm trying to buy a home. Is this your first home? And, very naturally, you can weave that process through. And to go back to the original answer, this name-value pair in the database, it is not a human interaction. It is a process of telling a machine the requires fields it needs to process a document, which generally is not how we think about the world. So that role playing can go a really long way to helping people see almost the silliness, if you will, for a lot of the interactions we have online. Ken, we need to film, what are you doing? Hold on, hold on, hold on. You buying some tight kicks? Yeah, and I'm just about done. I can see that I just need to finish my payment information and done. Why don't you show then what you just did? Okay, all right, my phone wasn't actually on because we're acting. Come on we're filming. Anyways. [LAUGH] I just thought this would be a good lead-in to the feedback part of this lesson, because it's all about showing your users their progress. I see, you were buying something online and the form was nice enough to show you that you only had to finish paying. Yeah, but my phone is off, so why don't you show students what this actually looks like? Sounds good. No. No, what? Nothing. I'm just shopping for some shoes and found this site. It looks pretty good, but it's asking me to register before viewing. So, I bounced out of there. Let me see. Man your phone is blank. [LAUGH] It is. But this kind of thing happens. Registration gates really only push users away. It makes it more difficult to view products and buy them, and that just is bad. Very, very, bad. You just watched us discuss the downside of gated shopping experiences. I want you to draw a conclusion from our discussion. Imagine that you're building an e-commerce site. Of the practices listed here, which are most likely to drive users away and decrease conversions? Will requiring complicated passwords push users away? Will registration gates on checkouts push users away? Will suggesting similar products push users away? Will requiring that users have a name on a shipping address push them away? Check all the options that you think will drive users away. I'll start at the top. And no, complicated password requirements are not likely to drive users away unless there's something totally insane like 1,000 characters. But in that case, you should still just use a password manager and then not worry about it, so no. Registration gates will though. More on this one in a moment. Suggesting products is fine, no harm in subtlety helping people find products that they might like. Just don't overdo it. And a shipping address should have a name, so this one also isn't a problem. Okay, so it looks like the only problem from this list is registration gates on checkout. Remember how you should avoid putting your products behind a registration wall? The same applies to purchases. When someone wants to buy something, they just want to buy it. Don't slow them down, and that's all registration gates really do. If you minimize the time to conversion, you'll watch your conversions increase. This is a multi-device world. Everyone uses their phone on the go. And they probably sit down with their laptops when they get home. People probably visit the same sites on both, but that doesn't mean that they've got the same intention. Yeah. While you may peruse your favorite online retailer while you're on the go, you may not feel comfortable taking out your wallet and typing in your payment information in public. Or maybe you just don't feel like dealing with tiny little buttons and you're in a big rush. So you wait until you get home to actually make the purchase. It's perfectly reasonable. And developers who take advantage of this pattern stand to convert even more users. There are a few ways you could help users start a form on one device and then finish on another. For instance, you could offer them a way to share an item through social channels or email. Or there's an even simpler tactic, save to a shopping cart. This lets users leave for now without worrying. Because they know when they come back later, their items will be waiting for them. Here's a website that you'll be improving at the end of this lesson. And like before, there's a slight chance that what you'll see may look slightly different than this, and that's only because we might tweak it between now and when you take the class. Anyway, you can find a link to a live version of this in the instructor notes. What I really want you to do though is play around with it. Start clicking through, start giving it a shot, and start thinking about what you would want to do to improve it. This is another quiz where you'll just be brainstorming. I want you to think about what areas for improvement that you can find in this form. How would you make it faster? How would you make it simpler? And once you've thought about it, check this box to continue. First things first. There are too many fields and a lot of them are completely irrelevant. Why is this form asking for a middle initial? First off, not everyone has one. And secondly, it's just not necessary for a checkout. Same thing with age and gender. This is a checkout form not a census. And still, why is age a drop down? Isn't that a number? Anyway, there's Confirm Email Address which just annoys me, like I don't know how to type it the first time? Don't put these on your forms. I could keep going. There are a lot of examples of totally irrelevant information here. And the layout isn't that great either. The form doesn't try to help you out. There's no indication of progress, and nothing is being validated whatsoever. So, it looks like you'll have your work cut out for you at the end of this lesson when you fix this. Yeah, so how can we make forms that are fast, easy and accurate to fill in? Which is essentially all of form design. So, I'll try a distill an entire book slash years worth of materials into a couple of minute answer. But at the very highest level, when we have a series of questions we need answered. The process we should start with is this thing that Caroline Gerrit calls, keep, cut, postpone, or kill, I think is the right methodology. I might have one of those words wrong. But keep is, this is information that's critical, required, we've got to have it in the form somewhere. Cut, I guess that's the one for kill. Cut means we actually don't need it. And it's surprising how many times you can go and look at forms and see things that are included there and nobody's even actually using. You go and talk to the team like, oh, well what are we doing with this piece of data? I don't know. because it's over here, has anybody look at this in the past three years? No, but we've always collected this. So here it is. So there's stuff you can cut. Postpone is things that you can ask later. So there's a lot of information that we force you to give us upfront, which isn't applicable, and actually has a better time and place further down in the flow. So postponing questions until they're appropriate is a really good strategy as well, and the last one is explain. And explain just basically boils down to telling people why you're asking for something, or how they can answer that question. There's a case study at the beginning of my web form design book where a major e-tailer, a huge e-commerce site, had two options at checkout, one was log-in and one was register. It turned out you could actually register without creating an account. You could actually buy something without making an account, but it was totally unclear from that language. Login or register. So what they did is they changed the label of the button that said register to continue and they put a little bit of text that said you do not need an account to continue. And conversions went up something like 30%. They made 300 million more a year overnight, just from explaining what they were actually talking about. So that keep, cut, postpone, and explain methodology is great at the very highest level. Then when you go deeper, you get much more into interaction design and visual design considerations. What's the right input control for this type of question? How do I minimize typing mistakes? How do I bound people so that they don't go into an error state? And you can do that with things like custom keyboards, input types, inline validation. There's a whole school of methodology for the nuances of forms. But it all starts at that bigger picture methodology of really thinking through what should be there, where and what you need to tell people about the questions you're asking them, if that makes sense. Cameron, why did you name this video One Weird Trick? What were you thinking about? What? Nothing. I was just going to talk about a weird trick where you can use a device's location to speed up checkout. Okay. What did you think this was about? Nothing. Okay. Let's move on, then. What were you going to say? You know what? Let's just cut to the next video. Many forms ask for addresses, E-commerce in particular. Incidentally addresses are often incredibly annoying parts of the form because they require so many input fields. There are street address, postal codes, territories, countries, region, etc. But luckily, addresses can be pretty easily generated from a mobile device. Essentially all mobile devices have location services through gps or wi-fi. By accessing geo location, you can often auto fill addresses to within a fairly close range. Users might need to adjust a bit but manipulating one input is obviously better than eight. For example Uber, in this example, you could see how we got the location of the users with this simple JavaScript code. Another way to do it will be to allow users the auto fill option. Here you could see that with only few clicks I have been able to retrieve a location that was previously saved. When you search for a car, the app uses your location to guess your address. And when you sign up they ask for permission to use your location. To learn more about accessing location services on the web, Android, and iOS, check out the links in the instructor notes. You've got quite a few new tools in your forms tool belt at this point. You've spent a lot of time thinking about forms as a whole, so I want you to put your skills to the test with this check out. I'm going to give it to you in its current state, which is a bit ugly. This skeleton of a nice form is here but that's about it. You can tell that there are definitely way too many inputs. Clicking on the labels isn't working and not to mention the color scheme isn't really looking that great. What Id like you to do is turn this into a simple, beautiful form using everything that you've learned so far. This is an open ended exercise in that there's really no correct answer. I want you to apply what you've learned about inputs, labels, simplification, auto completion, validation and form design. You may find that you can make some small tweaks to improve this checkout, or you may want to just blow it up and start from scratch. It's up to you. In the next video, you'll see me discuss two different versions of my check-out. One will use native HTML elements, while the other will take advantage of Polymer. Polymer includes a set of elements called gold elements that I found to be really helpful with e-commerce. As this is totally up to you to create, feel free to take advantage of whatever framework or library you like. Doesn't matter if that's Polymer, Angular, React, or something else entirely. It's up to you. The point of this quiz is to give you a chance to think through a checkout flow from start to finish. I want you to make decisions and build something that you're proud to show off. I also want you to think mobile first while you're designing. You'll learn more about this in a bit. But for now i just want you to do your best to think about what it's like for your mobile users first. It'll be a big help. Prioritizing for mobile devices will only help simplify and expedite your checkout flow. When you're happy with your checkout, share in the forums. And while you're there, peruse your classmate's forms and give them some constructive feedback too. I'll leave a few helpful links for you in the instructor notes. When you're happy with your checkout and ready to continue, check this box. Good luck. I know you can do it. To start off with here's the native version of my check out form. See how it looks kind of material designee? The reason why is because I want to building the polymer version first because to be honest my design skills aren't really that great. I wanted to apply some material design best practices and then I just copied the results over using native HTML. With this version I actually kept a few of the original inputs, but I did do as much as I could to get rid of as many as possible. I also made the language a little bit friendlier. And I did my best to make sure that the form was pared down to just the bare minimum. I also make the assumption that somebody wants to use the same billing address as they used for shipping. That allows me to add this check box which i like. If somebody wants to use a different billing address they simply click it and then enter it. You can see that I'm using placeholders in lieu of labels. But if you look in the source code, you can see that the labels are actually still there. Screen readers need labels so I wound up just simply hiding them using a special CSS class. This keeps them in the dom, but they don't show up. There's also a bit of validation happening. Among other things, credit card numbers are being parsed to find the type of credit card. That's pretty helpful. Of course, this version doesn't quite follow all of the best practices that you've learned. I wound up ditching the progress bar at the top and I'm doing nothing to help out with location. And so here is the polymer version that uses gold elements. The similarities are obvious but there are two big differences that I want to point out. First off, there's a nice progress bar at the top that expands as the user fills in validated information. And two, this version takes advantage of a user's location. Watch as I click in the address bar. The site wants to know if it can use my location. I wound up hooking up this input to the Google Maps API. Which allows me to auto complete addresses as a user's typing. And now that I have the address, I'm also helping the user out by giving them the zip code already in the credit card information area. And of course if the billing address is different for the credit card, you simply click right here. And the browser scrolls down to show you a new address input, nice. There are a few other changes that I made so I encourage you to check out the source code which you can find a link to in the instructor notes. So how did your checkout forms compared to mine? Think you did better? If you haven't already, share yours in the forum. In the next lesson you'll be practicing with mobile form techniques. Before then, here's the next part of the interview series with Luke where he'll discuss mobile first. So for a long time, I've advocated this approach of Mobile First. And the reason why I've pushed for that is 341, mobile's a huge opportunity. If you look at the scope of it, it's much, much bigger than what we've had before with personal computers. Two, mobile has new capabilities. For example, with a desktop or laptop, we knew with 99% certainty you were in the U.S. Yay. WIth mobile we can get you down to like 50 meters, which is a huge, huge difference. And there's a lot of other capabilities like multi-touch and all the sensors and devices that we didn't have before. But the third one, which I thought was actually the most impactful was if you go from a typical 1024 by 768 screen down to a 320 by 480, kind of early smartphone screen, you've lost 80% of your screen space. Which means you need to think really, really hard about what can fit on that screen, because you can't fit everything from before. So you have to do this really hard thing called prioritization. And in order to prioritize, you have to understand what you're doing for people, why and how. And when you think about all these different devices, mobile is a great forcing function for getting you down to the core essence, to what really matters? How fast and easy can we make this? Maybe the watch is another forcing function because you should be able to, I saw people ordering pizzas with their voice on their watch. But the less capabilities you have, the more creative you have to get with how people can get stuff done. So it's a great way to essentially force yourself to, well, we have this 40 screen check out form or 40 input field check out form, can we get it down to five, what would that take? Would that even work? And when you do it on the desktop, you don't have that concern. It's like oh yeah, there's plenty of room. I'll just add field number 45 on page 3. People can type. So on a multi-device we're all right. I think it helps to have that filter first, to get down to the core essence and then you can bring that core essence everywhere. because why should someone with a 20 inch monitor suffer through 40 form fields, where someone with a 4 inch monitor gets away with only five, right? They should equally get the same treatment. Great job! You applied the clicks to make forms faster and better. You applied the principles of short forms. You didn't ask for redundant information. You simplified. You gave feedback. And you tried out location services to help with addresses. Now it is on to the next lesson where you'll focus on touch. Remember your mobile users are incredibly important so we want to create touch interaction that users will love. Welcome back, in the first two lessons you learned how to build great inputs. In the last lesson you practiced building great force. Along the way you probably noticed that building great experiences for your mobile users has been a major theme of this course. Yes, and that's because it can be a lot more difficult to build the really fantastic experience for them. When users choose to interact with you app, it should respond to that touch in intuitive and beautiful ways. And that's what you'll learn in this lesson. You'll fix a few sites that badly need your help with some better touch events. And at the end of it you'll be given this courses project. If you feel like you need more practice designing websites for mobile, I highly recommend checking out the course called Responsive Web Design Fundamentals. Which I teach alongside Etos colleague from Google Pete Lepage. You can find a link to it in the instructor notes. Great, first thing first, I want you to see why touch events matter. So why worry about touch? Touch events are just click events on a touch screen, right? No, I don't think they are. Definitely not. They have different pseudo classes and different event cycles and you need to account for both. Let me show you what can happen if you don't account for touch events at all. This is an example site that use touch. Which you can find the link in the instructor notes. I recommend posing this video and go play with it for a moment. Pay attention as I'm dragging this element, what's going on. Both in depth tools and on the element itself. Another good example is here as you can see I'm just improving my images. In this example is taking touch, mouse, and pointer events. Much better. Well that was fun. Notice how the UI didn't quite react to your touch. First thing first. You need to account for the touch pseudo states. The fastest way to support touch is to change the UI in respond to a DOM elements change in state. DOM elements can be in one of the following states default, hover, focus or active. To change our UI for each of these states, we need to apply styles to the following pseudo classes active, focus and hover, as shown here and here are the results. On most mobile browsers hover and focus states will apply to an element after it's being tapped. So, consider carefully what size you set, and how they will look to the user after they finish their touch. Bear in mind that anchor tags and buttons may have different behaviors in different browsers. So assume in some cases the hover will remain, and in others focus will remain. Here you could see it in action, when we're clicking on each of the buttons, and it's left with a different style. You could open dev tools and see what are the pseudo states that we gave for each of the buttons. In iOS, in particular, we don't have an active state by default. So check the instructor notes for a shim. For this quiz, I'm giving you this site with these three buttons. I want you to load it on your touch capable devices, like my phone here, and I want you to do some research. Eudo just explain until you can use pseudo-classes to make your your UI feel more reactive. These three buttons have active, focus and hover pseudo-classes applied to them. When a button is active, it's background will be Aqua. When it's in focus, it's background will be FireBrick and when it's hover it's background will be HotPink. See how the first letters match? Clever anyway, take a look at this site on your touchscreen devices and answer this question. Which pseudo-class does not get applied on mobile devices? That means, never gets applied on mobile devices. Does active never show up, does focus never show up or does hover never show up? Take a minute, play around with the site and then select one of these three answers. So I've got the site open on my mobile device, and I will start tapping. Okay, so did you see that? It goes aqua then pink. So Aqua is active, and pink is actually HotPink, and that means hover. Notice that no matter what you do, you don't see FireBrick showing up. But that was on an iOS device. I wonder if it's any different on an Android device? Let's see. Okay, so it goes Aqua, then FireBrick, interesting. Last time on the iOS device, I didn't see FireBrick. I wonder if HotPink is there? If I press down on a button and then slide my finger off, the HotPink shows up. Which means that hover is actually there too. So on Android you have all three. So the correct answer is, actually, none of them because different mobile devices behave slightly differently. It's worth keeping this in mind as you develop your sites to look good on any device. You're starting to think about forms with touch, which is a distinctly human interaction. In the next video, watch Luke describe how the human body becomes a factor with mobile devices. So one of the big differences that comes from direct manipulation screens, that is things you touch to provide input versus what we have in the desktop and laptop world, is that the human body all the sudden really starts to matter. Before when we're building software for desk tops and laptops the size of our hands, the size of our finger what's a comfortable reach, that burden is taken on by the keyboards and the mice. Right so long as the mouse is comfortable and the keyboards comfortable the software designer doesn't have to worry about it. They don't have to think about these are going to considerations. As soon as software is something that people can touch and feel, the screen has to be considered in the context of your hand. How far can you reach that thumb? How big is that thumb? These things impact where you put controls, how large you make controls and how easily those controls are to manipulate. Anyone who's struggled with a desktop form on a mobile device knows these teeny little tick boxes and radio buttons can be super frustrating especially if you're trying to pick a specific one. So at the very least we need to consider how to size controls, how to space them. And that's sort of the bare minimum. If you want to do one better then you start thinking about well. Is it possible to create this flow or to complete this flow using what I call one thumb one eyeball. And one thumb one eyeball actually illustrate this here since I have a phone like all of you too. In your pocket, kind of hold it like this, and you look at it like this. TV may be on, you may be outside, or something like this. How can I get something done, just with these sorts of actions? And that goes much broader than just size, right? It's where you place the controls, it's what the flow looks like, it's the kind of controls you use as well. And we have a lot of controls that require the precision of a mouse cursor to use well little like spinner wheels that you find on the desktop drop down menus that you find desktop. All those controls need to be rethought for touch screens so that they can actually be used by our hands. It's worth doing a quick refresher on creating event listeners. For this quiz, I want you to add an event listener to this sample site. See this red box here? You can click and drag or touch and drag it around the page. There's also a P tag right about here. I want you to change its inner HTML to touch end only when the touch end event occurs. Here let me show you. In device emulation mode when i let up, you can see touch and pop up here. And when i'm not in device emulation mode, nothing happens. And that's because me letting up here is a mouse up event, not a touch and event. Here's the general structure of an event listener in plain old vanilla JavaScript. The target is the specific node you want to actually listen to the event. And this could be a dumb node, it could be the document or the window. The type is simply a string of whatever type of event you want to listen to, in this case, it'll be touch and. The listener is a callback function that will get past the event object as the only argument. And this gives you access to the event itself and whatever information it contains from within this listener callback. There's also this use capture boolean which comes at the end of the method. It determines whether you should catch the event before or after other elements have had the opportunity to catch and interpret it. If you're not sure what that means, don't worry about it. You actually don't need to use it for this quiz. Also, when you take a look at the code, you may notice that you have the option to do this quiz with vanilla JavaScript or jQuery. Both vanilla JavaScript and jQuery are perfectly valid solutions. But I want you to give it a shot with vanilla JavaScript first. Afterwards if you're adventurous, try using jQuery. Why not? The two solutions are actually pretty similar. But you're only going to see me give the vanilla JavaScript answer in the solution video. And as always there are links in the instructor notes to help you out. Good luck. I started here from within the afeat because it already has the square target which I want to add an event listener to. I set an event listener on the square target listening to touchend. And I also added the callback showTouchEnd, which will get called whenever touchend occurs on the square. And here's showTouchEnd. It's pretty straightforward, but I did add some logic to it to make it disappear after a moment. But you didn't need to do that. All that's important here is that I set the outputs innerHTML to touchend. So when the touchend event gets called on the square, showTouchEnd gets called. And when showTouchEnd gets called, the output.innerHTML gets set to touchend. Okay, that's pretty simple. Let's see how it looks. So here's the site. With the mouse, nothing happens, which is expected. But when I switch to device emulation mode and move around, look at that, touchend appears right here. Cool! All right, that's a pretty good start for events. Let's keep going. For this quiz you'll be making this slider, well, slide back and forth. And just for reference, I'm calling this gray box that's moving a toggle, while the whole thing is called a slider. Let me show you what the code looks like. Like with the last event listeners quiz, you can actually use either JavaScript or jQuery. The differences are minimal, though you'll see me walk through my solution with vanilla JavaScript. Take a look through at.js to see how the slider works. It's pretty straightforward. The crux of it being two methods, ToggleTracker.addMovement and slide. You'll want to call slide whenever you want to animate a new position of the toggle. I also recommend using requestAnimationFrame with it. And that'll give you nice performance. You can see that slide uses transform translateX to move the toggle some x position away from its original origin, and slide determines that distance by using toggleTracker.getTtranslateX. Back to toggletracker.addMovement. It expects an x position to get passed to it. This exposition represents the current exposition of either the finger, as in a touch of ent, or a mouse on the screen. You want to call addMovement whenever a new touch starts pr a touch move event occurs. And likewise, you'll want to call it for a mouse down or mouse move. It's going to be your job to use the event listener to find this exposition that gets passed to atMovement. In the end, all you'll need to do is set the correct event handlers on the toggle in the window so that both touch dragging and mouse striking work. Here's where your code should go inside the attachEventListeners function. You'll know you've done it right when, well, the toggle is sliding back and forth. Make sure you test on mobile. And if you're having a hard time, make sure you read the comments in the code because I left you a lot of hints. Okay, well check the instructor notes for more information and good luck. To solve this problem, I started where attach event listeners gets called. It's generally it occurs inside an event listener for dom content loaded. When attach event listeners gets called there is a flag that's set for sliding and that indicates whether or not the toggle's actually sliding. I'm going to take advantage of this flag to figure out when I should use events on the window to move the toggle. You'll see, inside attach event listeners I set the touch start event listener on the toggle itself. This is because I wanted to make sure that sliding starts when somebody is actually touching the toggle, not some random place on the screen. Inside the event listener I set sliding to true because at this point the toggle should be able to slide. And I added the first movement to the toggle tracker. Remember add movement is expecting the x position of either a mouse or a finger on the screen, so in order to get that I'm using the event object. The event object contains a touches array and there's only one touch. And it has a property pageX which is exactly what I'm looking for. Next up, here comes the move. So on touchmove, I look for if the toggle is (sliding) already. I need to look for (sliding) because I attached touchmove to the whole window. And that's because somebody's finger can pretty easily slip off the toggle. And so if the toggle should actually be (sliding), I add the movement the same way I did before. And then i request an animation frame using the slide callback. And this is what actually makes the toggle move. And lastly, I want to watch out for any touchend events, whether or not they occur on the toggle itself. So, in that case, I add toucnend to the window. It doesn't matter where the finger gets let up on the screen. In that case, sliding is done. I then did basically the same thing for mousedown, mousemove and mouseup. The only difference is now I don't have a touches object on the event objects and I can simply go straight to pageX. Cool, okay, that's enough code. Let me show you what this looks like. Just like before, touch events seem to be working and mouse events work as well. I can slide off and keeps going but as soon as I let up, no more sliding. Congratulations. You are well on your way to building fantastic forms. You've been building forms that take less time and help users along the way. Yes, and you know how to build better inputs, faster phones, and reactive touch interfaces. You've got all the tools you need to make your phones a breeze and increase conversions. And most importantly, you've been developing the right mindset for tackling forms in the future. Right. So get out there and build some forms to convert more users. If this course has helped you out, head over to the forums and share your story. Thanks for learning with us. Be strong and happy. Bye bye.