You might already be familiar with Gradle, as the magic that happens when you hit run in Android Studio. Or you might be familiar with other build tools and are just looking to ramp up on Gradle. These days it takes a lot of work to turn a pile of source code and resources into a shipped, tested and functioning app. In this class, we'll learn to use Gradle to automate these processes, which makes software development so much more fun and so much more productive. Anyone serious about making a business in Android or Java development should understand the complexities that development will kill you if you don't automate. Welcome to Gradle and Android for Java. I'm Mark, a Core Engineer at Gradle. And I'm Jeremy, a Course Developer at Udacity. In this course we'll be focusing specifically on how to build your app. And we'll assume you're familiar with writing simple Java and Android applications. If you're just starting on your Android journey, Udacity also has a developing Android apps course, which you might want to take before this one. This course is divided into four lessons. First we'll learn the basics of Gradle and Gradle build scripts. Then in lesson two, we'll learn to use Gradle to build Java projects. In lesson three, we'll learn how Gradle interacts with Android Studio, and how to create app with free and paid flavors. Finally, we'll learn how to use Gradle to automate a whole raft of useful Android tasks, like dependency management, unit testing and sign-in. It will be a bit of a whirlwind tour but we'll do our best to call out any topics where you can dig in deeper. There's nothing magic about the App Build process but it can get pretty complicated at times. All right. I'm ready. Let's build something. Sounds good Jeremy. Let's dig into the Java and Android build process. Yeah. Building a Java project doesn't seem too bad at first glance. You just call Java C on your source files and it spits out some class files. You can also copy over resources like images and strings. For distribution, you can Jar up your class files and resources and you're done, right? Well, you might also want to generate some documentation. Running some unit tests probably sounds like it would be a good idea as well. If you're getting really serious, you might even want to run multiple sets of unit tests, including integration acceptance tests. Then, assuming those tests pass, you might want to deploy your Jar to a repository. This is starting to sound like its a lot of work to do by hand, but not impossible, right? Or you could write a shell script that would automate this process. It'd be messy but it's doable. Android apps on the other hand are beasts. The Java source isn't compiled as standard Java byte code, but to custom byte code for the Android run time. Android has three different types of resources that all get packaged differently. There's an additional wrinkle in that the resources that you define need to be pooled together with resources coming from your included libraries. And the identifiers of all those resources need to be known beforehand, before anything else gets compiled. Also, Android apps most be cryptographically signed. When you put all that together, it looks something like this. Now, considering you might want to build both Debug and Release versions of your app, you might also want to build free and paid variance. The point is, is that the process of building Android app is not something we can do by hand. It's not even something that we can do in a shell script. We need a more robust solution. That solution comes to Android in the form of Gradle. Hey, welcome to our first quiz. You'll have to excuse my handwriting. A big part of this course will be quizzes and programming exercises. This approach to teaching is called formative assessment, that means we're not asking you questions to give you a grade, but to challenge you and keep you interested. Don't worry if you need to submit a quiz multiple times or even skip ahead to the answer video. The questions are here to help you, not to examine you. With that in mind, let's do our first quiz. Which of the following are advantages of using a build tool, portability, automation, deliciousness, repeatability, or delectability? You could make a case for any of these choices but, the ones we were thinking about were portability, automation, and repeatability. Build Tool will allow you to build your project on any system and build your project with just a single command. You can also be sure your build will happen in exactly the same way no matter who runs it. Please do not eat the build tools. So why is building software matter? Historically, it used to be that building was just compiling and packing your source code. Today, builds are responsible for so much more. They run our tests, can buy coded resources from multiple sources, generate documentation, create multiple build variance, publish our applications, and manage dependencies. Because of this, the build has become the software factory, in which we can continually change, test, and release our apps. Think of Gradle as the one stop shop for defining and integrating all the parts of your software delivery process. For example, for Gradle users, the process that executes the modern IDs, like Android studio, or CI front end products like Jenkins, is all defining Gradle. In this day and age, an app store Android developer unable to ship changes into production faster and faster will fail behind the competition, in the end automation is the key to making this happen. So why Gradle? The biggest reason is that Google has selected Gradle as the build system for Android Studio. In fact, Android Studio delegates the entire process of building Android Apps to Gradle. When I hit the run button, Android Studio just sets Gradle in motion and sits back to watch. By learning about Gradle, we can extend this default behavior to build even more and more capable and well tested Android apps. Obviously, Google is full of very smart engineers. And one measure of their smarts is that they felt they didn't need to reinvent the wheel with build systems. Gradle solves some the most hard problems faced by Android developers. How to automate building and testing apps to achieve rapid productivity. And how to manage dependencies and variations that allow professional developers to pump out dozens of variances of their apps with one click, or build a suite of apps and deal officially with apps that are very large. Another key insight is that many Android developers work in header genius environments. With differing and complex technology stacks, Gradle is the dominant multi platform build system. Other strengths of Gradle include the compact and powerful build language used to write its build scripts and the rich domain model that allows Gradle to reason about your build. One of the strengths of Gradle lies in it's extensible domain model. At the heart of this model is the concept of tasks. A task is a self-contained unit of work that Gradle can reason about. At the core of a task is its action, for example we might declare a task to compile some Java sources or to copy some files from one directory to another, or to simply print hello. A task can perform some action in isolation but it can also declare dependencies on other tasks. Gradle will ensure that all these dependencies are run and ensure all of their dependencies and so on and so on. A task can also define its inputs and its outputs, the files that it reads from and writes to. This allows Gradle to determine if a task needs to do its work, or if everything is already up to date, in which case it doesn't need to run. We'll explore all these features later on in this lesson, but for now let's get Gradle up and running and execute our first task. All right, enough theory, I want to see some command line action. Not so fast, you might say. Don't we have to install Gradle first? Not at all. Gradle's first trick is that it knows how to install itself. All it needs is a shell script, and a tiny jar that knows just enough to download and install Gradle. I have in this directory, a copy of the Gradle wrapper. Gradle wrapper consists of just a shell script, we've got one for a Mac and Linux and we've got one for Windows, and then inside the Gradle directory you have a tiny jar. The way the Gradle wrapper works is you call it with a Gradle command, it'll check to see if Gradle is installed. If it is it'll just pass along a command, if it isn't the Gradle wrapper will go ahead and download Gradle for you first. Let's go ahead and run the Gradle Shell Script and see what happens. We didn't already have Gradle installed so now it's downloading it. You see a lot of dots. Even more dots. All right. There we go. Gradle's been downloaded. Welcome to Gradle 2.3. Hm, it looks like Gradle decided we need some help. This option to see a list of all available tasks looks good. Let's try running this. So let's try running the tasks command using the Gradle wrapper. Whoa, that's a whole lot of tasks that Gradle already knows about. And as we scan through all of these tasks, looks like there's a task that's calling out to us. Let's give this one a try. Now let's use the Gradle wrapper to run the hello task. Along with some diagnostic output, we get a nice greeting. How sweet. Gradle has to do a significant amount of work to start up. Mainly because it's required to spin up an instance of the Java virtual machine. This startup time can be mitigated by using the Gradle Demon, a demon is just a process that hangs around in the background of your operating system, doing something useful. When Gradle's instructed to use a demon, a demon process has started, and continuously runs in the background, keeping the JBM instance alive, so that subsequent Gradle runs can use the same instance. By default, Android Studio always uses this as Gradle demon, when running Gradle from the command line however you'll have to explicitly enable it. Simply put you should always use a demon when possible. By using the demon you can take advantage of huge performance benefits that are planned to get even better in future versions of Gradle. Welcome to your first coding exercise in the course. We've put together a bunch of demo code and exercises to accompany this course. The absolute easiest way to get the code is to download it from the downloadable section of the classroom. However, if you're familiar with GitHub, you can also find the code here at github.com/udacity/ud867. Once you've downloaded the code it should look something like this. Inside the Run Your First Task directory, you'll find a bunch of files. These three, the Gradle folder and the two Gradle-W files are part of the Gradle wrapper that we already talked about. The files you want to concern yourself with are build.gradle and solution.gradle. Every single one of these exercises will have that pair of files. The build.Gradle file contains all of the instructions for the exercise. And the solution.radle file contains all the solutions. Let's open up the build.Gradle file and your favorite text editor. I'm going to use Sublime. All right, so here's the instructions for your very first exercise. I'll let you read them on your own. Your challenges are going to be using the Gradle wrapper to execute a task and then modifying that task in a simple way. Remember if you get stuck, check out the solution.gradle file and it'll help you out. All right, give it a try and then see if you can answer the question on the next slide. Once you're done running your first task, you should be able to answer this question. What is my favorite kind of candy? Is it chocolate, taffy, jelly beans, or bacon? And while you're at it, did you go ahead and run your first task? If so, was it awesome? Oh, hey. [SOUND] Congratulations on running your first task. While the Gradle wrapper is an incredibly convenient feature, let's also go ahead and install Gradle locally. Keep up the great work. [SOUND] In this course, the solutions to the quizzes are all in the course code. So just this first time, let's take a look together at where to find the solution. So here's the directory where you found the instructions for your first task. Here is the build.gradle file that specified what we were to do for the first exercise. And in the same directory we have the solution.gradle file. Let's open it up and sublime. So here we go, we have some nice explanation of the commands needed to run a task using the Gradle wrapper on various operating systems. We even find the cool tip that if we want to run tasks from this solution.gradle file instead of the build.gradle file, we can easily do that using the -b command line flag. Also, we find the answer to the really important question at hand. [SOUND] I swear I don't have a problem. [SOUND] [COUGH] Anyway, if you ever get stuck on an exercise, don't sweat. Just check out the solution.gradle file. By the way in later lessons, we end up switching to a whole Felician directory so watch for that, as well. Awesome work with this quiz and good luck on the rest. Typically, whenever we're working with an existing Gradle project, we'll be using the wrapper, because that way we can ensure that everyone working on the project is using the same version of Gradle. For our purposes however, it'd be a bit of a pain to generate the Gradle wrapper scripts for every single one of these folders, so, we'll have you use a local installation instead. You can find these instructions in the course repository under 1.02-Exercise-InstallGradle. These instructions will have you first check that you have got a working Java installation and then we'll walk you through the process of installing Gradle. Note that if you're on Mac and you are a Homebrew user, that's a very easy way to install Gradle. Also on Mac, there is the GVM, the Groovy Environment Manager, and that will also automatically install Gradle for you. Those are some good options to check out. So let's walk through the process of installing Gradle manually. First let's check that we have a working Java installation. Looks like we're good to go here. If you don't have a working Java installation there are instructions for how to install that in the course repository. Now we need to download Gradle. Head on over to Gradle.org/downloads to do so. We want the complete distribution. Once we have the Gradle complete distribution downloaded, we need to do a bunch of other things to get Gradle installed. We need to move it to an appropriate place on our machine, our suggestion is user local Gradle, and then we also need to add a few environment variables. You can do all of this by yourself, however, if you just paste in this giant block of script into your console, that'll do it all automatically. All right, here goes nothing. There we go. Gradle has been extracted to user local Gradle, and now we're ready to rock. By the way, if that last command complained, you might need to run it with sudo. All right. Let's see if Gradle installed correctly. Hey, there we go, that's looking good. Gradle 2.3, ready for action. All right, it's time for you to go ahead and install Gradle. When you're done, try running Gradle--version from the command line. You should get some output that looks something like this. Go ahead and fill in your Gradle version number and your groovy version number. Also, let's have a look at the affected Gradle daemon. First run, Gradle--stop to stop any daemons that might be running, run the hello world task. Note down how long it takes, then run the task again and see how long it takes the second time. At the time of this recording, the most recent version of Gradle was Gradle 2.3 running on Groovy 2.3.9. The time it takes for Gradle to start up will depend on your machine. On my machine, to start up with no Daemon running took 4.1 seconds, and then once the Daemon was already running, it only took 1.2 seconds. Awesome work getting Gradle installed and the Daemon configured. Let's learn more about what we can do with Gradle. Here's an example of what a Gradle build script looks like. Even without any explanation, it's reasonably easy to figure out what's going on. We have what kind of looks like a stripped down JSON syntax. However, down here, where it looks like we're creating a task, there's what looks like a Java print line statement. What's going on here? Is this script just structured data like JSON or XML? Or is this actual Java code? Well, the answer is that Gradle scripts are written in a special purpose build language provided by Gradle. But it's not a language that's developed by scratch. It sits on top of a generic scripting language called Groovy. Groovy has a lot of syntactic sugar in other features to allow us to write build scripts that look a lot more like natural language when compared to using something like Java. Second Groovy integrates perfectly with java, which is the language that Gradle platform is written in. The main thing you need to learn when using Gradle is the Gradle build language which is where the keywords like Android and task are coming from. But it also helps a lot to understand how this build language sits on top of Groovy and Java. The entire build script has what we call a delegate object, which exposes the Gradle build language to Groovy scripting language within the build script. If you write a Gradle plugin, you could write it in any language and use the same delegate object. The Gradle build language is also called the Gradle DSL, or Domain Specific Language. A domain specific language is a language that is finely tailored for a specific task. In this case the domain we're talking about is an Android build. Note, there's a big difference between describing your build and providing explicit instructions on how to actually make the build happen. The Gradle DSL declared in so you're only responsible for describing your build and Gradle itself knows how to make it happen. That means your build scripts can be much shorter and much easier to understand. However, within the build script you have a full blown powerful programming language at your disposal. We do recommend that you keep build scripts declarative, and try not to pollute it with low-level logic. That's what Gradle plugins are for. You can write them in any JVM language like Java, Groovy or Scala. Let's check out the fundamentals of Groovy so we can better understand what's going on in Gradle build scripts. Before we get started looking at code, a pet peeve of mine in online courses is when you have to constantly pause the video to copy down code. You don't have to do that in this course. All the code we'll demo is included in the course GitHub repository. Groovy exists to fill a hole for Java developers who need a scripting language. It's terse, expressive and it operates extremely well with Java and has some special features that make it ideally suited to creating domain specific languages. Gradle even provides it's own Groovy distribution so we don't even need to install Groovy. We can just put our Groovy code in a build doc Gradle file and ask Gradle to do any task that uses the file. To start off with, we'll declare a task called Groovy that doesn't do anything. We'll be talking about this syntax in a minute. Don't worry about it for now. All this is doing is just telling Gradle to go ahead and load this file. If we go ahead and run that task by running gradle groovy, what we see is that Gradle runs the Groovy task but doesn't really do anything. That's what we expected. All right, let's dig into Groovy, and you know where we have to start, right? Of course we gotta start with hello world. Let's try running this build script again and see what happens. All right, we see our message, we've successfully reached hello world. Let's do something more interesting. Most Java is also valid Groovy. Let's test that out by creating a very simple JavaGreeter class, just as one method to say hello. And prints hello Java to standard out. If we create an instance of that class and then tell it to say hello let's see what happens. Remember this is Groovy not Java. Let's run our gradle groovy task again and there we go. Hello Java. Gradle is an optionally typed language. That means that you can give all of your variables types if you want to, but if you don't feel like it you can declare variables just using the def keyword. In this case, we're just declaring a variable called foo with value 6.5. We can also execute simple groovy code inside a string, by creating a block of curly braces preceded by a dollar sign. While dynamic typing is really nice, sometimes it is good to know the class of a variable. We can do that simply by calling dot class on any variable. Finally, dynamic typing also allows us to reassign a variable to a different type. This isn't very good practice but it's good to show off. All right, let's give this code a try, awesome it looks like foo has value 6.5, yep that's what we expect down at this line. Looks like five plus six does indeed equal 11. Looks like Groovy was nice enough to do this math for us. And then finally it looks like foo is of class Java math big decimal when it has a value of 6.5. But then when we reassign foo to a string it looks like foo now has the class java.lang.string. Let's have a look at how to declare functions in Groovy. It looks somewhat java-like but note the def out front instead of a return type. Also we don't need a return statement. The last expression in the function block is what's returned. So this function takes its input and doubles it. We can call it with a number, however, since plus is overloaded in Groovy, we can also call it with a string. Let's check out the output of these invocations of doubleIt. All right, looks like doubleIt, with the argument five gives us ten and doubleIt with the argument the string foobar, gives us foobarfoobar. Fantastic. There's one more super cool feature of Groovy, and that is whenever a function is called with at least one argument and it's unambiguous, you can usually leave off the parentheses. Let's give that a try. I've set us up with three functions here, one of which no args, one with one arg, and one with two args. Let's see what we can do. If we go ahead and call our one arg function with some argument and we don't put any parentheses around it, well, let's see what happens. Hey, we successfully called the function. All right. Now let's give the two argument function a try. Note, we still have to separate the arguments with a comma. All right, let's see how it goes. Beautiful, no parentheses, still getting a function call. Let's see if we can pull the same trick with the no argument function. Looks like something exploded. It turns out, you can't use no parentheses when you're invoking a function that doesn't have any arguments. Otherwise Groovy is confused about what's going on. All right. Let's try something real hard now. We're doing a nested function call. So we've got two args. And then the first arg, 22 args is one arg past 500. And then 200 is going to be the second arg, for two args. You think this is going to work? Let's give it a try. Hm. Looks like something broke. Looks like there's something weird going on in here. Turns out this is actually ambiguous. It's not clear to Groovy whether you want to pass two arguments to one arg or what's going on here. Fortunately, we can make this unambiguous with just a couple of parentheses around 500. Now that we've added those parentheses, let's see if it works now. [SOUND] Beautiful, we're getting the nested function call exactly how we want it. First the one arg function is being called then the two arg function is being called. Now that we've got the fundamentals under our belt, let's check out some advanced Groovy features. The first one is called the closure. The closure is essentially a different way of declaring a function. But a function that can be packaged up, passed around and assigned to variables. You declare one just using curly braces like this. Closures are so-called because they also capture variables from their enclosing environment. So, this value of foo will always be one million dollars. Let's go ahead and try calling, since myClosure is a function, we can call it just by putting parenths after it, let's give it a try. Awesome, there we go. We're getting print statements from inside the closure and the value of foo is respected inside the closure. Unlike normal functions, closures can be passed around to different variables. So if we declare bar and set it equal to myClosure and then declare yet another variable baz and set it equal t0 bar, we can then invoke baz because baz is now a function. And there we go. By calling baz, we got the exact same result as calling myClosure. All right, let's do some really tricky stuff, hold on to your hats. So, closures have a different syntax for arguments. You put a comma separated list of your arguments on the left side of an arrow and then do whatever you want with the arguments. So I hope it's clear that this is actually a function that doubles it inputs. The tricky bit is that Gradle allows for higher order functions. That is, functions that take as one of their inputs another function. For example, here we have applyTwice. Its first argument is a function and its second argument is just some argument to be passed through that function. And what it returns is function applied twice to that argument. Let's check out an example. If we set foo equal to 5 and then we apply doubleIt twice to foo. Well, let's see what we get. Before we run it, see if you can figure out what it's going to be ahead of time. Well, let's see, five doubled is ten and then ten doubled is 20. Awesome. Let's talk about lists in Groovy. Groovy allows for a super simple list literal syntax and also allows for some very sophisticated list processing. For example, we can execute a closure for each item in a list. We simply define our closure. In this case, it's just printing out each item. And then we call myList.each and then our closure. Let's see what this does. And there we go. Each item in our list gets printed out. There's a couple things we can do here to make our syntax a little bit more compact. The first thing is we can define our closure in line. Note we don't have any parentheses around here because Groovy syntax is awesome. Also, if a closure is only taking one argument, then by default that argument is just called it. So let's try running this. And there we go, does exactly what we expect. Let's talk about classes in Groovy. Groovy has a simplified syntax for creating classes, but the classes themselves are essentially Java under the hood. So, here we've got a class. It's got a member variable, it's got a method. We can create a new one, just how you're used to from Java, and then we can ask it to print its greeting. We can also change the greeting and ask it to print that greeting again. Groovy automatically creates getters and setters for all of your member variables. Let's give this a try. And our outputs are just as we expect. First printing the default greeting then after we've customized it, it prints the custom greeting. Closures can have a delegate object. Let's check out this closure we've created here. It's trying to assign to a variable called greeting. But greetingClosure doesn't have a variable called greeting. Actually, the only place the greeting is defined is as a member variable of this class. What we can do is set the delegate of greetingClosure to be an instance of GroovyGreeter. And now, greeting closure can access the member variables and methods of that instance of GroovyGreeter. So if all goes well, when we invoke greetingClosure, after setting its delegate to myGroovyGreeter, it should be able to set the greeting and print the greeting just fine. Let's give it a try. There we go. We have successfully changed the greeting inside the instance of GroovyGreeter from a closure. Well congrats on completing our whirlwind tour of Groovy. I know that was a lot to cover. Fortunately there are a ton of resources out there to help you. We've linked a bunch in the instructor notes and I strongly recommend checking out this demo again in the sample code provided with the class. Now that we've learned the fundamentals of Groovy, it's up to you to experiment with some Groovy yourself. Check out the experiment with Groovy exercise to get some practice in with the concepts we've learned, then, give the following questions a try. What do these following lines print? You can logic this out, but I would really recommend just running it and seeing what happens. The next question might require you to dig into the documentation a little bit. What list method allows us to generate a new list by applying a closure to each item in this list. Is it map, collect, find, or filter? This was a tricky one. I really hope you just went ahead and ran these lines, to find out what they do. the thing to realize, is that this foo is going to be the value of the variable foo. This foo is just the string foo. In here, again this foo is the value of the variable foo. So that's bar, and this foo is just the string foo. So it's "$foo + foo =${foo +"foo"}" So bar + foo = barfoo, there we go. Over here the list method allows us to generate a new list, by applying a closure to each item in the list. That would be Collect, awesome work. That's all the Groovy we'll discuss directly in this course, though you'll get to write plenty more. If you're ready for a bit of a break from me and Mark, we've got some suggestions for where to go to learn more. Learning new languages is one One of my favorite things about working in Tech, and Groovy is a particularly handy language to have in your back pocket. Check out the links in the instructor notes to learn more. Next up, we'll use our new Groovy knowledge to start configuring Gradle builds. Now that we have some groovy under our belts, we're in a much better position to understand what's going on inside of Gradle build script. Just like a closure can have a delegate object, the entire build script delegates to a project object. All the keywords in the Gradle DSL are properties of, or methods on the project object. For instance, the project object has a method called task for declaring tasks. It accepts the name of a new task and optionally a configuration closure which we'll talk about shortly. If we run Gradle tasks to have a look at all the tasks that are currently defined we see under other tasks my task one that we just defined. All right. Everything's working so far. Because the entire build script delegates to the project object, we can actually go ahead and leave that off when we're declaring tasks. Also, because Groovy Syntax is awesome, we can knock of those parentheses as well, since this is just calling a function. Now this next part is tricky. Gradle actually reaches into Groovy's execution model. And uses an advanced Groovy feature called an abstract syntax tree transformation. The upshot of which is, you can knock off the quotes as well. This is not a thing you need to understand super deeply, however we do have more information in the demo code provided with the class. Now that we have declared a task, we can also configure some properties on it. So, we can give myTask4 a description, and we can give it a group. If we then run Gradle tasks again, this is what we see. Here's the group up here, and here's the description. The most important property of a task is the list of actions the task will perform. Instead of setting the actions property directly, we add a closure to the end of list of actions to perform using the do last method. So, let's give task four a try. Gradle helpfully tells us that it ran myTask4, and that it went ahead and printed the statement. There's a few other ways to add closures to that list of actions for the task to perform. We can add doFirst to add a task on to the front of a list. We can also use the left shift operator which does exactly the same thing as doLast. This is nice because it allows us to use this very compact syntax, and this is what you'll see most often when people are declaring, very simple tasks in Gradle. We can also declare a task, and then immediately pass it a closure to execute as its action. This is an extremely common pattern, and it's probably the most common way that people declare simple Gradle tasks. Instead of configuring a task line by line as we were doing previously, we can also pass a configuration closure when we're defining a task. The configuration closure delegates to the task object. So it can go ahead and set the description, the group, and the actions of the task. Now you may have noticed something a little bit weird about that configuration block. We are trying to assign this string description, but there's no equal sign here. Well Gradle's actually done something very clever. For every property, it's created a setter with the exact same name. So this line is actually a function call omitting the parentheses because Groovy. Assignment also works just as well. There's only one gotcha with this. And that is, if you're assigning a collection to a property in a configuration closure, you gotta use the equals sign. Just a thing to keep in mind. One more thing to know about tasks, some task properties can be set in the task declaration like this. However, not all properties can be set this way, so check out the course code for the full story. The only time you actually have to use this syntax is when you're declaring a typed task, which we'll talk about soon. Now it's your turn to configure a task. Check out the instructions in the configure a task folder in the course code. When you're done, check off this box. Also, see if you can answer this question, what group is the solution task assigned to? Note that you can tell Gradle to use the solution.gradle file as its build script, using this command right here. Go ahead and fill in the group right here. I hope you managed to get that task configured all right. And if you didn't that you could check out the solution.gradle file and get your solution. Speaking of which, this was the udacity task group. Awesome work configuring your first task. The rest of this course is just making more complex tasks and connecting them together. Now that we can declare tasks, it's time to start thinking about the relationships between tasks. For example, in a Java build we can't jar up our library before compiling our sources. We model these relationships by task dependencies and order. We'll discuss three ways to configure the relationships between tasks. Depends on, finalize by, and must run after. Task A depends on Task B, if Task A can't do its work without Task B having done its work. To take a familiar example, when you're getting up in the morning, you can't put on your shoes without putting on your socks first. Let's declare and configure some tasks. So here's our tasks that represent getting ready in the morning. We've got put on socks, just prints a message, put on shoes also just prints out that we're putting on our shoes. The new thing is we've got this depends on function. And we just passed the task name that put on shoes depends on. In this case, put on socks. So, let's give put on shoes a try. And we are running Gradle on quiet mode, so that we don't see all those diagnostic output. We just see the printed messages. There we go, when we try to put on our shoes Gradle realized we can't put on our shoes without putting on our socks, so we ran that first. The next type of task dependency we're going to talk about is finalized by. We say task A is finalized by task B. If every time task A runs, task B should be run afterwards. To continue our example, every time you eat breakfast, you really should brush your teeth afterwards. We have those tasks here. We've got the eat breakfast task, and the brush your teeth task. And we note that eat breakfast is finalized by brush your teeth. So, let's see what happens when we try to tell Gradle to just run the eat breakfast task. Looks like Gradle It was keeping us honest and made us brush our teeth after we ate breakfast. The use case for must run after is slightly less obvious. Say we have a long running process that's unlikely to fail, like deploying some artifact to a continuous integration server. And we also have a short running task that is likely to fail, like running unit tests. Those two tasks don't have any dependency relationship, but if we're running both we would really like the unit test to be run before the integration tests. To continue our morning routine example, let's continue showering and putting on a fragrance like perfume or cologne. Putting on a fragrance doesn't require showering, and showering doesn't require putting on a fragrance, but if we're going to both take a shower and also put on a fragrance, we should really take the shower first. Let's create those tasks and relationship between them. All right, so we've got our take shower task, and we've got our put on fragrance task along with the should run after take shower. So now if we go back to Gradle, and we say hey Gradle, run put on fragrance and take shower. Well, let's see what order they run in. Looks like they run in the order that makes sense. First we take a shower, then we put on the fragrance. Let's check out a few other things we can do with task dependencies. We can depend on multiple tasks, note this is one of those situations where you do need to use the equal sign when you're assigning to a property. Let's give this one a try. So since get ready depends on taking shower, eating breakfast, and putting on shoes, looks like we eat breakfast, and since breakfast is finalized by brushing your teeth, we do that. We're going to put on our shoes, but first we have to put on our socks. And then we take a shower?Â Whoops. Something's not right here. I think we need one more ordering constraint. There's no dependency relationship between taking a shower and putting on shoes, but it certainly looks like if we're going to both take a shower and put on shoes, we should probably take the shower first. Let's change that out. And there we go. We say to put on shoes, you must run after take shower, and now if we run this again, looks like we're doing things in a more sensible order this time. One more advanced thing we can do is look at all the tasks in a project and decide which ones we want to depend on. Let's make a task called getEquipped that depends on every task that starts with putOn. So here's our get equipped task. And you'll see it depends on, and then this is actually a list that was created by looking at all the other tasks in the project. You don't need to understand how this works right now. The point is just to show off something that would be extremely difficult or impossible to do in other build tools. Let's give it a try. And we run get equipped, looks like we put on a fragrance, we put on our socks, we put on our shoes. As always there's more information to be found on task dependencies in the course code. Check it out! Now that we've learned to configure task dependencies, let's try an exercise. We've provided a number of tasks related to making coffee, and your job is to add the dependencies between them. When you're done, what tasks appear in the other tasks section when you run Gradle tasks? Add sweetener, black coffee, brew, drink, pour, and or sweet coffee. Nice work configuring coffee making. Only the black coffee and sweet coffee tasks show up in the task list. Since no other tasks depend on them, clearly they exist only to be run by the user, hence they get top billing in the task list. Remember you can always see all tasks using the --all command line option. We've seen how to create new Gradle tasks, and add task actions to them. So far, task action implementations have been simple, such as just writing text out to the console. But what about more sophisticated tasks? How might we go about implementing a task action for, say, copying files? We would first have to define some way for the users to configure which files should be copied and to where. We then have to write all the I/O code necessary to perform the copy action, handle errors, and report status back to the user. Thankfully, Gradle includes many tasks which are preconfigured to provide commonly needed functionality. We distinguish these tasks by their type, such as copy, delete, or zip. We refer to these kinds of task as type task. In contrast, tasks whose actions are implemented inline in the build script using gif first or gif last are referred to as ad hoc tasks. The syntax for creating a type task is similar to that of an ad hoc task, the difference being that we define the type of the task as a name parameter. As with any other software API or framework, you'll want to become very comfortable with finding your way around the Gradle documentation. Gradle provides a few different forms of documentation, but we'll focus specifically on the DSL reference, which is a good first place to look if you want to know what all configuration options are available, in any given part of your build script. The Gradle DSL reference covers all the different build script components. Many of which we'll talk about later in this course. Since we're currently concerned with tasks, let's take a look at the task types that are available as part of the Gradle distribution. As you can see there are a number of built in task types, varying from followup operations to compilation, to source code analysis. Since one of the most common build actions involves copying files. Let's take a look at the copy task API. For most built in task types examples are provided for common configuration use cases. If we look further, we can see the various task configuration properties as well as methods available. Many of the method descriptions reference other greater API types. Since many API methods take a groovy closure as an argument, it's helpful to know what arguments will be passed into the closure. The eachFile method, for example, takes a closure as an argument. The closure that we pass in as an argument, is then given an instance of FileCopyDetails as its argument. We can click this link, and then get additional details about the options that are available on this class. The Gradle DSL reference is your best friend. Learn it, love it, and it will help you out of all sorts of jams. We'll teach you a lot about the Gradle DSL in this class, but you'll inevitably run into use cases we haven't covered. Fortunately, Gradle has fantastic documentation that will allow you to find the features you need. In fact, let's get a little practice. If you wanted to dynamically decide at runtime whether or not to run a task, to what method on the task object would you pass a closure? Write your answer in this box. You can find a link to the Gradle DSL reference in the instructor notes. By the way, since we'll be back here pretty often throughout the course, this would be a good time to go ahead and bookmark the Gradle DSL reference. To get a task to decide whether or not to run its action at Run Time, we can pass a closure to the only if method on the task object. You did go ahead and bookmark through Gradle DSL reference, right? Coping files in Gradle is simple. We start by simply declaring a new task, and specifying the type of the task as Copy. Of course this task won't actually do anything, because we haven't told it what file we'd like copied, and to where. Simplest example is to copy the contents of one folder to another. We use the copy tasks from method to add sources, and the into method to specify the destination. This copy task will copy the contents of the images directory into the build directory. We can specify files to include or exclude, our filters can use wild cards, allowing us to do things like, include all files that match a certain pattern, or have a particular file extension. This combination of source, destination, inclusions and exclusions is called a copy spec. Let's configure our task to only include jpeg images, by calling the include method, and passing a file pattern. We can also configure a single copy task to copy from multiple sources. Copy specs can be hierarchical, which is particularly useful when you want to exclude certain files from a particular sub-folder, or a specific Include them in another. Let's configure a copy task which copies all JPEGs into one folder, and all GIFs into another. We define two child copy specs. One to include only JPEG files, and the other to include only GIFs. We also specify the folder we want to copy these files into. These folders will be created as subfolders, under the root copy destination, the result being that JPEGs will be copied to build/jpeg, and all GIFT files will be copied to build/gif. Gradle provides task types for creating archives like ZIP or TAR files. Archive tasks are nearly identical to copy tasks, except instead of specifying a destination directory, we specify an archive name. Let's zip up all files in out images directory. We use the Zip task base name, and destinationDir properties to tell Gradle what to name the archive, and where to create it. Note the the destinationDir property takes a Java file object. Luckily, the Gradle project interface provides a convenience method for creating files. We can do similar things with archive tasks and trial copy specs. We can create an archive which puts JPEGs and GIFs into their own directories inside the archive. The only difference from our copy task example, is that we specify the archive name and the destination. Sometimes we want to delete files during our builds, usually to clean up previous build outputs. We can use the delete task to delete files or folders in our project. Here we have a task that deletes the build folder. Your turn to configure some file system tasks. In this exercise you'll create tasks to copy, archive, unarchive and delete files. Check out the configure file system tasks folder in the course code to get started. When you're done, what task type do you use to unpack an archive? Awesome work using Gradle to interact with the file system. You use the copy task type to unpack archives. It's that simple. As our builds become increasingly more complex, we want to ensure that we don't redo any work that has already been done the last time we executed our build. This is especially important during development, when we run our builds often many times a day with just some minor changes. It would be a huge impediment to the development process if our build had to start from scratch every time. We call the idea of only doing the minimum amount of work necessary incremental builds. For example, let's consider an Android application. Building our app requires compiling our code, generating source files, and packaging static resources into the final APK. If we were to say, change one of our layout files, we don't want to have to compile our code again. That would be unnecessary. Gradle accomplishes this by tracking each task's inputs and outputs. Before each task is run, Gradle saves a snapshot of the inputs used by the task. If that particular task doesn't have any snap shots of its input yet, or if the inputs have changed, then Gradle will run the task again. Gradle additionally saves a snapshot of the outputs created by this task. The next time Gradle goes to run the same task, it compares the inputs to the snap shot it saved earlier. If the inputs match, Gradle then also checks the outputs. If the outputs haven't been messed with since the last time the task ran, then the task can be skipped. If the outputs have changed or are missing, then the task must run again. When Gradle determines that no work needs to be done and the task can be skipped, the task is said to be up-to-date. Let's investigate incremental builds and up-to-date checking. Go ahead and check out the exercise in the course code, then see if you can answer this question. How does time stamping build outputs interact with incremental build support? Does everything work fine? Is it a problem because build support should be tagged by version number, or is it true that the task can never be up-to-date? Awesome work checking out incremental build support in Gradle. Time-stamping build outputs means that the task that generates those outputs can never ever be up-to-date, since its output file is changing every single time. Incremental builds give you a lot of performance boost for free. So sit back, relax and watch your build log scroll by. You may often come across situations where there's part of your build script that you'll want to change somewhat regularly. While you're well on your way to becoming a Gradle build master, the other developers using your build, may not be so familiar with Gradle. This means they're relying on folks to modify your build script. In order just to change its behavior, is less than ideal. This is especially true, if you expect an automated system to be running your build. Solve this problem, Gradle allows you to parametrize your build, by adding properties to the project object, from locations outside your build script. Command line arguments, gradle.properties files, and environment variables. Let's check out the syntax. To explore Gradle properties, let's create a task that prints a simple greeting. If we just run this as is, somewhat unsurprisingly, we got a crash. Gradle says that it could not find property greeting on task print greeting. Yep, that's not defined anywhere. We'll need to pass in the value of the greeting we want to use. The first way to do this, is using a gradle.properties file in the same directory as your build script. If we just add the line, greeting equals hello from properties file, and rerun the task, now we get the behavior we expect. Another way to pass in a property to a Gradle build script, is the command line. In this case it'd be the -P flag that lets Gradle know that we're going to be passing in a property, then the name of the property equals, and then the value we want. Note that the greetings property is now defined in two places, in the properties file, and from the command line. Let's see which one wins. Looks like the command line wins. I hope this makes sense, because the command line is the last line of defense before the project is actually run. There is a third way we can use gradle properties, and that's from inside the build script itself. If we pass a closure to the ext property of the project object, and then we define our property, then the property is defined when we run our task. Note that defining a property inside the build script, shadows all other definitions, like from a properties file. Now, it's time for you to parametrized a build. Check out the gradle properties exercise in the course code, then see if you can answer this question. If a property is defined in a gradle properties file, and on the command line, which one wins? Is it the gradle properties file, or is it the command line? Awesome work parameterizing a build! It's the command line that has the upper hand, which I hope makes some sense. Command line arguments are the last chance to change the behavior of your build. So it's useful for command line arguments to take precedence. Awesome work. Now we can customize the behavior of our build without having to edit the build script every time. So far, the only option we've seen for adding custom functionalities for our build script is via ad hoc tasks. We've also seen how typed tasks make it simple to reuse common functionality throughout our build scripts. We'll now learn how to write our own task types. Creating a custom task type in gradle is easy Let's start by defining our task class. Again, since Gradle scripts are simply groovy, we can define a class right in our build script. In general, we'll always extend the default task class which provides a basic implementation of the task interface. We've got class MyTask extends DefaultTask. That's all there is to it to define a custom task type. Of course, since we didn't provide any additional capability for our task. It's functionally the same as defining an ad hoc task in a build script. We have to somehow tell gradle what we want our task to do when it executes. Luckily gradle has also made this very simple. To add an action to our task type we simply define a method annotated with the at task action annotation. Let's start by adding an action that simply prints a string out to the console. Now that we have defined our task type and given it an action. We can create an instance of this task type in our build script just as we would with any other typed task. Let's go ahead and add a task named Hello doorbelled\g script and declare its type as this new hello task we've just created. So, we've got our new hello task of type, hellotask, lets give it a try. There we go. The method of the HelloTask class that we annotated with TaskAction got executed. Perfect. We can also easily make our tasks configurable by adding properties to our class. Here we've added a firstName property, which our task action then uses. Remember, since this is Groovy, we don't need to worry about creating getter and setter methods. We've declared a task HelloName of type HelloNameTask. And then we've configured the first name property of our HelloNameTask. If we give this a try, aw, hey console. Hello to you too. Now it's time for you to take a crack at creating your own task type. Check out the exercise in the course code, then come back and answer this question. What annotation denotes that a class method is the action of tasks of that class? Fill in the blank here. Nice work creating your own task type. It's the @Task Action annotation that tells gradle what method should be the action of tasks created from your class. Before we get into any crazy multi-project Android builds, we should talk about how to figure out what's going on when your build fails. While it's technically possible to attach a debugger to Gradle if you really know what you're doing, the first line of defense should really be thorough logging. Gradle logs messages in one of six levels. Debug spews a ton of, only occasionally, useful information on Gradle's internal workings. Info gives much better insight into what Gradle is up to. It details how long each task takes to complete, and other high level events, like when Gradle connects to its Daemon. Lifecycle logs what tasks are currently being run, as well as the total time the build took, and whether or not it was successful. Quiet is the level for log messages, that should be this way even if the user has told Gradle to be quiet, but there aren't any errors. Also, any print line statements in the build scripts are actually redirected to the quiet log level. Finally, error is exactly what it sounds like. By default, Gradle displays all logs at the lifecycle level and above. Running with the -d flag, gives all logs at the debug level or above, which is all of them. The -i flag, gives all logs at the info level and above. And finally, -q gives only quiet and error logs. Remember again that println statements are equivalent to the quiet logging level. This means that even if the user uses the -q option, println statements will still appear in the log. When the Gradle build script fails to complete, it doesn't display the stacktrace by default. If you want to see the stacktrace, gist of your code, use the stacktrace option or the -s flag. To see the entire stacktrace, including Gradle core code, you can use the -full-stacktrace option, or a capital S. Again, make sure the difference between these two is that the partial stack trace is a lowercase sand the full stack trace uppercase S. A mentor of mine once said that the best debugger is clear thought and print statements. Of course, he was a bit of a Luddite who didn't trust symbolic debuggers, but he's not totally wrong. Check out the logging exercise in the course code. Then see if you can answer this question, what log level are print statements logged at, and by what logger? To get the full log output you can run gradle--debug and run the hello task. Fill in the logging level here and the logger identity here. Nice work investigating logging levels. Print statements are logged at the quiet level by the system.out logger. One of the challenging things about working with a language that uses closures, is it's not always particularly obvious when a piece of code is going to be run. When Gradle's invoked with a name of a task to perform it can't just go ahead and execute that task. It first has to figure out that task dependency and those task dependencies, and so on. Gradle then executes all the tasks, and in the correct order, before the target task is eventually executed. That means that before any task execution happens, the whole dependency graph has to be created. There are actually three phases to the lifecycle of any Gradle build. Initialization, configuration, and execution. The initialization phase is mostly concerned with setting up multi-project builds which we'll talk about later in the course. In the configuration phase the build script is executing which configures all the project's tasks. This is when a directed acyclic task is built up and Gradle determines which tasks need to be run, and in which order. Then finally, in the execution phase all the task actions of all the tasks that are chosen are executed in the proper order. Take a look at the build Lifecycle exercise to investigate the difference between the configuration phase and the execution phase of the build. Then, consider the following Gradle build script. If the task gradle test is run, in what order are the numbers printed? Nice work exploring the Gradle build lifecycle. When the task configuration closure is encountered, it's immediately executed. However, let's consider what order these print lines will run in. The first line that we printed, is print line two. Second, print line three will happen. And then finally, print line one, which is the action of the test task, will happen during the execution phase. The distinction between the configuration phase and execution phase can be very confusing. Remember, when your script isn't behaving how you expect, your best debugging tools are clear thought and thorough logging Gradle. Tasks. DSL. Demon. Jeremy! Jeremy! You did it! Did what? You finished lesson one! You've learned the basics of Gradle. Well, what about building projects? That's later. Now that you know how to configure and create tasks, let's build a Java project. What about Android? We're getting there, I promise. Okay you guys do that. I'm just going to take a little nap. Hey Mark, check it out. I made a directed graph of all the tasks I need to do to become a gentleman's spy. Okay, let's see. Being smooth depends on an intimate knowledge of whiskeys? Hm. Which depends on spending a year at a mountain monastery devoting your life to meditation and whiskey sampling? Yeah. See, I even configured each task with the group. One for marksmanship, one for counterintelligence, one for looking good in a suit. Sure, but do you actually know how to do all these tasks? Like, for example what would be in the action list of the shockingly good at fencing task? Good point. Well, other people have become gentleman spies in the past. I'll just look up a documentary on James Bond, or Sterling Archer and I'll figure it out. You realize these are fictional characters, right? That's just your opinion, man. Rumor has it, they were actually based on- Never mind. But you do have a good point. We've learned a lot about the nuts and bolts of how to declare, configure, and run Gradle tasks. But we still don't know how to define the tasks you'd need to build, say, a Java project. Hey, super spy! [SOUND]. What would be the console commands you'd use to compile and build a Java project? It'd be like, Java C something, and then you'd need to add some stuff [CROSS-TALK] Oh. Mm-hm, writing your tasks to build a Java project would be a huge pain. Especially if we wanted to make sure it was all portable. Thankfully, my colleagues at Gradle, as well as hundreds of community contributors. Have developed a huge number of plugins that define useful tasks for you. We don't have to write a single task to build a Java project. We just need to import the task from the Java plugin. Too bad we can't import any spy skills. It's all right. I really wanted to be a build engineer anyway. Which of the following are Gradle plugins capable of? Extending the Gradle domain model. Adding DSL elements. Adding tasks. Adding tasks types. Or cookie baking as a service. And Gradle itself is largely indifferent to any particular project you might want to use it for. So plugins are empowered to do all of these things. Well, except this last one here. How did this get here? Hm. Hold on a second. Hey, Mark. I've got a new startup idea. Building Java projects are relatively simple when compared to Android projects. It is still a multi step process that we prefer to automate. Gradle provides full support for Java projects. To include compiling our sources, creating a jar file, generating documentation, running test, and creating reports. Gradle models the java build process by creating tasks for each of these steps and wiring up the necessary dependencies for us. A typical Java build will usually involve compiling our source code and processing resources. And packaging those resources and Java class files into a jar. It can also include test code, which will need to be compiled, and then the tests run themselves. Optionally a Java project may also include generating Java docs or packaging source jars. Gradle also creates lifecycle tasks for us. Describe common build outputs like assembling our artifacts. Running project checks or doing a complete build. All this functionality is provided by free Gradle, in the form of a plug-in, which can be applied to to your project. Now let's take a look at how to add a Java plug-in to our build. Applying the Java plugin is simple. We only need to add a single line to our build script. Now if we run Gradle tasks, we see a whole wealth of capabilities that the Gradle Java plugin can handle for us. There are four main tasks we'll use most often, assemble, build, clean and scrolling down a bit we'll use the test task as well. Assemble creates the output we're interest in. This is usually a jar but can also be more interesting artifacts. Check runs any tasks we've set up. Build depends on both assemble and check. Finally, clean deletes all the build output. We've got a trivial Java project in this folder, with a single class called person. Let's try running Gradle assemble. Looks like it's done. Looks like the build directory contains another four directories. Looking in the newly created build directory, we find a classes subdirectory, which holds our compiled classes. And a libs subdirectory, which holds our newly created jar. Now you might be thinking to yourself, I thought there wasn't going to be any magic. This sure seems like magic. How did Gradle know where to find my source code? I promise there's no magic. Gradle just has a lot of very sensible defaults. Like, for instance, it assumes that your JAVA sources live in a folder named source name JAVA. This, like most everything else in Gradle, can be configured, and we'll show how shortly. There's another important thing to know how to do. And that's run the project we just built. You might have noticed that the Java plug-in doesn't add any tasks for running your code, and that's because the JavaExec task type is already part of the core Gradle functionality. The main property tells the JavaExec task the path of your main class. And we'll talk about this class path property very shortly. If we go ahead and run this task, there we go. We see our task running, and then we see a greeting coming from our newly compiled Java. Let's use the Java Plug-in to create a jar. In the course code, we've provided a simple project with a single class for you to practice with. In the process of building the jar, gradle will create a build/tmp/jar/MANIFEST.MF file. What are the contents of that file? Since we haven't configured the JAR manifest with anything more interesting, all we get is Manifest-Version 1.0. Congratulations on using the Java plugin for Gradle to make a JAR. Let's dive deeper into the capabilities of the Java plugin. This probably seems like a whole lot of magic. How did Gradle know where to find your sources? And how did Gradle know what compiler options to use? Or what directory to put your build outputs? Gradle uses the philosophy of convention over configuration, or as I prefer to think about it, Gradle has sensible, opinionated defaults. You can lay out a Java project however you please, but by default, Gradle will assume your sources in source, main, java. And your test in source, test, java. And your outputs in the build directory. Gradle is married to that idea however, and you can easily tell gradle that your sources live somewhere else. There is a big upside to falling into gradle defaults though. It means you can pick up any other Gradle Java project and be pretty confident that you already know how the project is laid out. It also means that if the project deviates from the defaults, that configuration is obvious in the build script. Gradle also does its best to separate capabilities from opinions. The Java plugin actually first applies the Java base plugin. The Java base plugin is what provides the ability to compile Java, and adds the concept of source sets to the project. However it doesn't add any source sets in particular. The opinionated conventions are applied by the Java plugin. As we get deeper in to the Java plugin, it'll be useful to know where to get more information. The first place to go is the Java quick start guide, and the Gradle user guide. You can find the link in the instructor notes. It has a quick rundown of the capabilities of the Java plugin. And if you need a refresher for setting up a Java project in the future, this would be a great place to go. For deeper information on the Java plugin, check out the chapter in the Gradle user guide. Here you'll find the information, all the tasks the Gradle Java plugin defines. There's also a great graph of the dependencies between the tasks. You can also get details on the default settings, like project layout and how to change them. Check out the documentation for the Java plugin, and see if you can figure out which task Gradle would execute if the assemble task was run. The assemble task depends on the jar task. The jar task in turn depends on the classes task, which in turn depends on both the compile Java and process resources tasks. Let's see where we can find this in the Gradle documentation. In the Gradle user guide chapter on the Java plugin, there's a graph of the dependencies between tasks that are created by the Java plugin. Here, we can see that assemble depends on the jar task, and jar depends on classes, which in turn depends on compile Java and process resources. Let's put our new documentation reading skills to work, and change some configuration in the Java plugin. Check out the course code for details. When you're done, fill in the blanks that you had used to add the implementation version attribute to the jar manifest. Awesome work configuring the Java plugin. Answering this question took some real documentation hunting skills. We need to hit the attributes method of the manifest of the JAR task. Let's check out how to find that in the documentation. We start at the Java plugin chapter of the Gradle user guide, and a search for JAR brings us this helpful link to the DSL reference. Here in the DSL reference of the JAR task type, if we search for manifest, we find that the JAR task type has a method called manifest that accepts a configuration closure. We also get a link to the Gradle Java doc. Finally, in the Gradle java docs on the manifest interface, we see that there's a method called attributes that allows us to add content to the attributes of the manifest by passing a map. Awesome! That's what we were looking for. Well, okay. I got this. I got this. I got, oh, no. [NOISE] Hey, whatcha doing there? I'm building an awesome new app and it's using a ton of cool libraries I found. Oh, your libraries are in these Java archives here? What? No. These are just jars. Anyway, a bunch of the libraries I'm using are themselves using even more libraries. Which gives you even more jars to juggle, right? What do my jars have to do with anything? I'm making jam later. Anyway, I checked all my jars into source control, but now it takes forever for me to check anything out. And anytime one of my libraries updates, it's just a giant pain to sort out. You know that Gradle can take care of this whole problem for you, right? Well, Gradle can do just about everything, can't it? It's true. Gradle makes using external dependencies super simple. It can take care of downloading your dependencies from repositories either hosted by your organization or publicly available out on the internet. It can also handle your trends div dependencies. That is the dependencies of your dependencies. It even makes sure that if you're using the same dependency across multiple projects you'll only ever download dependency once. No more juggling jars. Hey Mark, you want any jam? Any sufficiently interesting project is going to depend on perhaps quite large collection of libraries. Maybe you start depending on just one or two libraries, so you just put their JARs in your project directory and keep on trucking. You end up having a huge collection of JAR archives. But then, what if a new version of your dependency is released? You'll have to manually download and update the JARs and in turn all of its dependencies and all of its dependencies' dependencies and so on. This is clearly getting unmanageable. Another option would be to include a list of your project's dependencies and have anyone who wants to build your project go and download them all. Of course, they would then have to hunt all over the internet to find them and they would have to check all the time to make sure that the versions they have Natural list of your dependencies. Brutal, right? Of course, since this is a course about Gradle, Gradle provides a better way. Most libraries, or more generally artifacts, that you might want to use in your project are present in various repositories around the internet. Most prominent repositories are probably made in Central and jcenter. Anyone can upload artifacts to these repositories, as long as they include the appropriate meta data. Every artifact in the repository can be identified and retrieved by a unique set of coordinates. If an artifact has dependencies of its own, that is also specified. The upshot is, Gradle knows how to retrieve artifacts from all sorts of repositories and will store them in local cache to make them available for your project. Not only that, but if you have multiple projects using the same artifact, it will only ever be downloaded once. Gradle will also take care of retrieving any transitive dependencies and will even resolve conflicts when different parts of your dependency tree rely on different versions of the same artifact. To add a dependency to a Gradle project, we first need to declare the repository to fetch the dependency from. The most basic sort of repository is just a folder full of jars, which Gradle calls a flat directory repository. All repository configuration is done inside a repositories script block. For a flat directory repository, we just add a flat dir block and configure the directories we want to include. This is great option if you're migrating an existing project to Gradle, or using a dependency if it's not available from a remote repository. But it also means you forego a lot of Gradle's advanced dependency management features. The repository script block also allows you to use shortcut methods for commonly used repositories such as mavenCentral, mavenLocal, or jcenter. Simply call the appropriate method, and the repository will be automatically added. This is by far the most common way to declare a repository. Gradle also supports resolving managed dependencies from Maven and and IV repositories. The syntax for both is the same. Simply place your configuration in Ivy or Maven block. For both Ivy and Maven repositories, the only required configuration element is the location of the repository, expressed as a URL. In some cases, credentials may be required to access a repository. You can easily provide a username and password by placing them inside a credentials block. Gradle supports a number of protocols for accessing repositories. In addition to the standard http and https, Gradle also supports sftp and file-based repositories like this. Now that we've configured our repositories, we can define dependencies on artifacts contained in those repositories. Dependencies that are resolved from repositories are referred to as external module dependencies. Dependencies are assigned to configurations. We'll talk more about configurations in detail later, but for now you can simply consider them to be groups of related dependencies. For the examples here, we'll be adding dependencies to the compile configuration, which is added by the Java plugin. Dependencies are configured in the dependencies script block. The syntax used is the name of the configuration we want to add the dependency to followed by a dependency notation. We can also use a Groovy map syntax to identify dependencies, again, by their group, their name and their version. In some cases, we simply have files we want to add as dependencies. File dependencies are declared very similarly to manage dependencies, however instead of a dependency notation we simply use a file collection or a file tree. In this example, we are simply adding two JAR files as dependencies by creating a file collection. We can also use a file tree, which allows us to do things like specify filters. This is useful for including a number of files within a directory. Gradle also supports project dependencies, which are dependencies on other Gradle projects within a single multi-project build. We'll talk more about multi-project builds and project dependencies in the next lesson. Time to take what you've learned, and add some dependencies to a Gradle build. Check out the exercise in the course code. Then, how long does it take to run Gradle refresh dependencies for the print dependencies task? How about Gradle print dependencies without the refresh dependencies command line option? Write the time it takes in these boxes. Awesome work adding dependencies to your Java build. Times may vary, but on my machine it took 2.02 seconds for Gradle to run that task when it had to go and download the Commons IO library from Maven's Central. However, it only took 1.2 seconds to build when using the local cached copy. Gradle provides two ways to visualize dependencies. A traditional dependency report showing the complete graph of dependencies and a dependency insight report showing how a particular dependency is included in your project. Here we have a simple Java project with a single dependency on the Spring Core Library. We can generate a dependency report by running the dependencies task. Gradle displays the project dependencies, including transitive dependencies. The report also breaks out dependencies by each configuration. To see the dependencies for a particular configuration, we can use the --configuration command line option. And there we go we have the dependencies just for the run time configuration. The dependency insight report shows how a particular dependency is included in our project. This report is especially helpful when identifying version conflicts. To run the dependency insight task we need to specify the dependency we're interested in using the dash dash dependency command line option. Let's get an insight report on the commons-logging dependency. We can tell from this report that commons-logging is a dependency of spring-core, which in turn is a dependency of our compile configuration. We mentioned that one of the main uses of dependency reports is to help identify dependency version conflicts. Let's introduce a conflict and see how this affects the output of our reports. Let's add an explicit dependency on version 1.2 of the commons-logging library. If we now run the Gradle dependencies task again, as you can see, commons-logging is now listed twice in our dependency report. In this case, you can see our project depends on 1.2, whereas spring-core depends on 1.1.3. This introduces a conflict, which Gradle will then attempt to resolve. By default, Gradle resolves version conflicts to the newest version, in this case 1.2. In our report this is indicated by an arrow, showing us that version 1.2 is being chosen over version 1.1.3. We can get similar information from the dependency insight report. Let's run this report and see the results. Again, we can see that the dependency is shown twice in our report. We see that our compile configuration depends on version 1.2, and that our compile configuration also depends on spring core, which depends on commons-logging 1.1.3. Gradle noticed that there was a version conflict, and resolved the conflict in favor of version 1.2. Different dependencies may be needed at different times in the build process. Logically related dependencies are grouped into configurations. So far, we've be adding dependencies to the compile configuration. But the Java plugin creates other configurations as well, such as runtime, test compile, and test runtime. The Java plugin ensures that the specified dependencies are on the class path when the corresponding tasks are run. Dependencies can be added to any of these configurations by simply using the name of the configuration followed by the dependency notation. Here we have an added dependency to the test compile configuration. This dependency will only be available from our test code. Configurations can extend to other configurations. For example, test compile extends from the compiled configuration. Which means that all of the dependencies in the compile configuration are automatically included in test compile. We can verify this by generating a dependency report. Here we see that the compile configuration contains a dependency on commons logging. But the test compile configuration contains both the dependency on commons logging and on JUnit, and on one of its transitive dependencies. If you have a more advanced build with dependencies that don't fit into a configuration defined by the Java plugin. You can create a custom configuration. Just add the name of your configuration to the configuration script block, we can then assign dependencies to that custom configuration. We can now run a dependency report to see the new dependencies added to the Project. And if we scroll up we find our custom configuration along with the dependency we declared. Under the hood configurations are really just fancy file collections. And can be used anywhere a file collection can be used such as in a copy task. This is useful if we want to download some dependencies from a remote repository and bundle them in our project somehow. Let's use our new configuration skills to create a custom configuration, and add some dependencies to it. Check out the exercise in repository, then see if you can figure out the following question. What would be the name of the archive generated by a zip task with the following configuration? Version equals 4.2, base name= "Foo" and classifier= "SNAPSHOT". You could solve this either by just trying it, which is what I recommend, or by checking up the documentation on the zip task. Write your answer in this box. Awesome work creating a custom configuration. The scheme for archive names goes basename-appendix-version-classifier-ex- tension. So in this case we'd get Foo-4.2-SNAPSHOT.zip. One of the most important parts of making high quality software. Is rigorous testing. Simply typing in test values into a function won't get us very far. So to do real testing on large scale, tests need to be automated. There are many types of tests, but broadly tests fall into one of two camps. Unit tests and Integration tests. Unit tests test individual classes or methods in isolation. Whereas Integration tests, test your code in conjunction with some other systems, libraries, or environments. In addition to writing tests, we want to automate the execution of our tests, more importantly, we want to integrate test execution into our build process. The benefit of this is we can now ensure that our tests are run when our application is built, ensuring that every change to our code is tested, reducing the likelihood of unknowingly introducing bugs into our software. We won't get into the specifics of how to write good tests, but I hope I've convinced you on the importance of testing. Let's check out how can help us easily automate our testing. To get started running unit tests with the Java plugin, all you need to do is place your tasks in the source test Java folder. You can, of course, change the location of your test code by configuring the test source set. The only thing we have to manually configure is our test dependencies. In this example, we're using JUnit as our testing framework, so we have to add a JUnit dependency to the test compile configuration. Running our test is easy. Just run the test task. You'll notice Gradle has to perform a bunch of other tasks before it can actually run our tests. It has to compile our Java source and then compile our test source, and finally it can run the tests. In this case, the build was successful indicating that all of our tests passed. Gradle also provides detailed reports on our test execution. These reports are placed in the build reports directory. Let's take a look at one of these reports. In this case, you can see we have one test and that the test was successful. Of course in a real project you'd have many tests. Now I've gone and edited our task so it will fail. Let's see what happens when we run the test this time. Oh no, our build failed. Let's see what went wrong. Execution failed for task ":test". There were failing tests. All right, we expected that. Let's check out the report. Looking at the report tells us we ran one test, and that it failed. And then we can even look at our test class to see the full stacktrace of what went wrong. Let's give this testing thing a try. We've provided an exercise in the course code with a simple project, and a couple of unit tests. Set up and run the tests, and when you're done, describe in plain English what was wrong with the class that was failing a test. Awesome job setting up unit tests. Seems to me that the Person class is failing a test because it seems to think, despite all evidence to the contrary, that its name is always foo. There's a wide world of Gradle plugins out there created and maintained by Gradle, its partners, and by developers around the world. To find documentation on plugins included with Gradle by default, check out the Gradle User Guide. Specifically, Chapter 21 on the standard Gradle plugins. There are three broad types of plugins. Language plugins for compiling languages like Java or [INAUDIBLE]. Integration plugins for creating different sorts of artifacts. And software development plugins that make the software development process easier. To find plugins written by third parties, check out the Gradle plugin portal at plugins.gradle.org. Here you can search for plugins that will help you automate whatever it is you're working on. Now since these plugins are provided by third parties and aren't bundled with Gradle, there needs to be a way to distribute them. Just putting them under source control leads to the same messes with libraries or any other artifact. Fortunately, Gradle's dependency management can be used for the dependencies required by the build script itself. If you click on any of the available plugins. You'll see a snippet for using the plugin in your build. The build script block means that this configuration applies to the execution of the build script itself and not to the compilation or execution of whatever project Gradle is building. This block declares a maven repository hosted by great deal and a dependency on this particular plugin. Also since this is a quite common pattern. There's a simpler way to do the equivalent thing using the plugins block. We use the Gradle Wrapper way back the start of this class to run our first task. Before we had even installed Gradle. That's a cool party trick, but the real strength of the wrapper is that you can put your build tool under version control. So everyone building your project is building it with the exact same tool. The Gradle Wrapper is composed of four files, a jar, our properties file, and a pair of scripts, a shell script for UNIX and Mac, and a batch script for Windows. When you pass a command to one of these scripts, it'll first check if Gradle is installed, download it if necessary, then execute your command. A wrapper can be created by running the built -in wrapper task. Here we go, let's give it a try. And here we see the files of the Gradle Wrapper, the two build scripts, and then inside the Gradle directory we'll find the gradlewrapper.jar and the gradlewrapperdir.properties. We can now run our Gradle build using the wrapper. We use the wrapper identically to how we would use the Gradle command. Let's get our task list. Oops, looks like we don't have this version of Gradle installed. Since this was our first time using the wrapper, it went ahead and downloaded the appropriate Gradle distribution, and cached it locally. We can also explicitly configure what version of Gradle we want the wrapper to use by setting the Gradle version property of the wrapper task. Let's change the version to 2.2 and run the wrapper task again. Now if we use this new wrapper to get the task list, it'll have to download Gradle again because we don't already have version 2.2. If we run gradle --version to see which we're actually using here, looks like we were using version 2.2 just like we asked for. Configuration options of the Gradle Wrapper is stored in this Gradle Wrapper properties file. We've got it opened up down here. As you can see, what URL to get Gradle from is defined here. Is currently using Gradle version 2.2, just like we set from the build file. Let's change this back to 2.3. Now if we try running Gradlew version again, we see we're back on version 2.3. This is a really important feature, as it allows us to centrally control what version of Gradle is used to build our project. In practice, the Gradle Wrapper files, including the scripts, jar, and properties file, will be committed to source control. This serves two main functions. First, it means that everything that is needed to get up and running with the development of our project is included in the source repository. Second, it means that the Gradle version is also version control, which eliminates the possibility that a developer encounters problems with the build due to using the wrong version of Gradle. Time for you to set up and configure a Gradle wrapper. Check out the exercise in the course code. When you're done, select the four files that make up the Gradle wrapper. Awesome work setting up a Gradle Wrapper. The four files in the Gradle Wrapper include the two gradle w scripts, the gradle-wrapper.properties file. And the gradle-wrapper.jar. Oh my god Mark, I have the best idea for an app! It's going to totally change the world. Oh, yeah? Yeah, it will totally revolutionize how left handed people meet each other. Really? It's so simple Mark. You'll be shown pictures of other lefties near you, and you'll swipe them to the right if you don't think they're interesting, and you'll swipe them to the left If they're a lefty you would like to meet. Brilliant, I'm sure. Ugh, you wouldn't understand. Look at you, standing there in your righty privilege. Mm-hm. Well I just wanted to thank you for teaching me everything there is to know about Gradle. I'm going to be using the Gradle Java plugin to build my Android app. I just thought you'd be proud. Whoa, whoa, whoa, whoa, whoa. We barely scratched the surface of Gradle. There's a lot more to building an Android app than just compiling some Java code. No, I'm pretty sure I know everything. I'm changing the world, remember? I know, I know. But, let's take a look at how the Android build process works, first. I promise we'll change the world tomorrow. Fine. Howdy, Mark. What you got going on there? Oh, you know, just working Android Studio. Why are you wearing- Android Studio? Why you lily livered son of a droid. Real code cowboys build from the command line. Just EMAX, ADB, and Gradle. That's all I need to build an Android app. But there's code completion and automatic refactoring. Who even knows what's going on inside one of them fancy city IDEs? Could be anything happening in the build process. Not like good, old, honest, hard working Gradle. Android Studio doesn't even use an internal builder. What did you say, now? Android Studio delegates its entire build process to Gradle. There's nothing magic happening. Whoa, that's super-cool. [COUGH] I mean. Really now? So, you're saying that I could use Android Studio for all them fancy code-completion features, and still wrangle my build process? Yeah, exactly. See, look, I can pull up my terminal Android Studio, run my Gradle build task, and see. Oh my. All them fancy features, and it's just Gradle under the saddle. I reckon I got some thinking to do. Thanks for the tip, partner. If you're familiar with Android Studio, I'm sure you've at least seen some doc Gradle files lying around in your projects, or noticed the Gradle logo on some toolbars. Throughout this lesson we'll learn how Gradle and Android Studio work together to build and deploy your apps. We'll also talk about how Gradle makes it easy to create variance of your apps, like debug and release builds, and paid versus free versions. Android Studio is an incredibly powerful piece of software. It has an editor with sophisticated code completion, and static analysis features. It also has a suite of tools for integrating with Android devices and emulators. The one thing it doesn't have, however, is an integrated build system. Android Studio delegates the entire build process to Gradle. That's everything that happens to turn your sources and resources into an APK that you can install on your device. Gradle itself doesn't inherently know anything about Android. That capability's provided by Google in the form of an Android Gradle plugin. Android Studio is actually happy to import and work with any Gradle project. We can use it to do all sorts of interesting things, like build Java libraries or deploy a backend service to Google App Engine. Even though Android Studio isn't building your project, it still needs a deep model of your project, so it can provide features like code completion, and auto importing. It maintains its own internal model of your project, and when a project is loaded or a Gradle build script changes, Android Studio needs to synchronize its internal model with Gradle's model. When you get a "failed to sync" message, it usually means you've just got an error in one of your build scripts. Let's define a trivial Gradle project to work with. This one doesn't compile or build anything, it just tells a joke. And we can use it to do all the normal gradle stuff we're used to, like, we can get all the tasks that this can do, and we can run our tell-joke task. Awesome. Everything's working. Now, let's try importing this project into Android Studio. So, here's the Android Studio splash screen. What we want is this import project Eclipse ADT, Gradle, etc. And it tells us to go select our build.gradle file or some other options. Let's go find it. All right, here is our super, simple build.gradle file, it's the only thing in this directory. Android Studio will pop up a dialogue asking you if you want to use the Gradle wrapper. Android Studio always uses the wrapper, and always uses the Gradle build daemon. We'll go ahead and let Android Studio set up the daemon. When Android Studio first opens, you might not see anything interesting. To see what's going on with your project, just open up the projects tab. You still won't see anything for the moment since the project pane is configured to display only the files that are relevant for an Android build. Fix that by clicking on the Android drop down and selecting Project. Now, if we expand out this directory, we can see a whole slew of files that Android Studio has already created for us. Note, that you can see your build.gradle file, as well as the gradle W wrapper scripts. As well as a bunch of other stuff that was added by Android Studio. There are several ways to run Gradle tasks from Android Studio. The first is the terminal down at the bottom left. Here we can do exactly the same stuff we were doing from outside Android Studio. Note that the first time you use the gradle wrapper created by Android Studio you may need to add execution permission to the wrapper script like so. So, now we can get our task list like normal. There we go. And we can run our tell joke task again. Awesome. So, we can do everything we could do from a command line from inside Android Studio as well. There's also an easier way to Gradle tasks from Android Studio. And that's by opening up the Gradle pane on the right of the window. If we open up the Gradle scratch directory and we open up the other tasks, we find our tell joke task. We can double click to run it. Excellent, our task is still working. Let's open up our build.gradle file. Let's try adding a second jug-towing task to our project. In order to get Android Studio to recognize our second task, we need to hit these little circular arrows again. There we go, here's our new task, and we can run it just like the other one. A moment ago, we just had to build that Gradle file. And now we've got a directory totally full of obscure files and directories. Unfortunately, IDEs tend to do that. Let's take a look at these various files and figure out why they're all there. The .gradle directory is where Gradle stores information for incremental build support. So, that's your tasks inputs and outputs, stuff like that. The .idea directory is where Android Studio stores its model of your project. The build directory is where your build outputs go, if this build generated any. For now, it's just holding onto some information related to the synchronization between Gradle's project model and Android Studios project model. Finally, you know the Gradle directory. That's where the wrapper JAR and the wrapper properties are stored. In the root folder, we have our build.Gradle file that we originally added. We also have this .iml file, which is again part of Android Studio's project model. Finally, we have the two wrapper scripts and then this local .properties file. This is how gradle can figure out where the Android sdk is on your machine. Let's move our joke teller from inside our build script, to a java project and then let's use Android Studio to build it. While we're at it, lets try using the Gradle application plug in to run the project. Check out the exercise in the course code. When you're done, what tasks does the run task from the application plug in depend on? Assemble, build, compile Java, process resources, a jar or a classes, select all it depends on. Awesome job importing a Java project into Android Studio! And also, great job getting used to a new Gradle plugin. So, what task does the run task depend on? Well, we don't actually need to create a jar, so all we need to do is compile the Java, process where the resources and create the class files. The Android plugin can handle a large range of use cases, but it has sensible enough defaults to make simple builds straightforward. In addition to handling the actual business of building and packaging your app, the Android plugin provides a bunch of different configuration and customization options for us to mess with. Of these available capabilities, we'll be covering six main themes. That Android developers are commonly find themselves wanting to do in their Gradle Android builds. The first is build variants. It's often useful to build slightly different versions of the same app, such as debug version for testing and a release version for the Google Play store. Another common use case is a free version and a paid version of your app. The Android plugin makes it easy to share code and other common resources between these variants. Second, the androidplug in allows us to manage dependencies on a per variant basis. Third, the android plugin can override resources and manifest entries also on a per variant basis. In lesson four we'll talk about some of the more advanced features of the android plugin which include application signing, pro guarding and testing Let's go ahead and create a new Android project and then have a look at the default build scripts. We'll give our app a domain and a location. We'll set a main SDK and we'll add a blank activity with a fragment. We'll leave the defaults for the fragment. So here we are in our newly created Android app. If we go ahead and haul out the ancient test device and then run our application, let's see what happens. All right sweet, looks like we're up and running. So let's dive into what gradle configuration is present by default. Again the project pain has defaulted to this Android centric setup. But I find this kind of confusing so I'm going to switch back to the project to just show the straight up project layout. So here's our project and here's our build.gradle file. There's a whole lot going on in the default Android build scripts. For starters this is actually a multi project build. An Android app itself as a sub project. We'll talk all about multi project builds in lesson four but it set up this way so it's easy to add other sub projects that we want to build together with the app like libraries or even a backend. There are two things to notice in this route build script. First we declare a build script dependency on com.android.tools.build:gradle:1.2.2. There are two things to note in this build script. First, we declare a build script dependency on this artifact coordinate. This is where the Android plug in for where gradle lives. Second, and we'll talk about this part of the gradle API soon. But this block adds the jcenter repository to every sub project of this build. That means every sub project can just declare dependencies and they'll automatically be retrieved from jcenter. Now let's take a look at the build scripts specifically for the android build. Which is in the app directory. So here's the build script for the Android app. Note that first applies the Android plugin which it fetched from jcenter. All configuration happens in the Android configuration block. All that's absolutely required are the first two lines defining the SDK version and the buildtoolsversion. The default configured block, configures attributes of the Android manifest. We'll talk about the build typeâs block momentarily. Finally the dependencies block works just like java dependencies. This declares the compile time dependencies on every jar in the libs directory and on the Android support library. Now it's time for you to check out the developers.android.com documentation, on the Android plug in for Gradle. You'll find a link in the instructor's notes. While you are at it, also go ahead and download the plugin language reference. Once you've got those resources, find out which two properties on the Android configuration block are required. Are they build tools version, compile options, compile SDK version, or source sets? Awesome work checking out the documentation. You've got a great taste of what's to come, and you'll know where to go for help in the future. So, as you discovered, the only properties that are required on the android configuration block are, build Tools Version and compile Sdk Version. It's often convenient to build different Variants of your app. A free version, and a pay version is the most obvious example, but you also want a de-bug version of your app for development purposes, and a release version for when your app is ready for the play store. Instead of constantly needing to maintain separate code-bases for every Variant, we can simply write the code that is unique to each Variant and Gradle will take care of the rest. A Build Variant is a cross product of two components, a Build Type and a Product Flavor. The two are mechanically similar, but conceptually orthogonal. Build Types are typically transparent to users and are only important to you as a developer, whereas Product Flavors control features that are visible to end users. Build Types are used to control how our app is built and packaged. By default, every Android app has two Build Types, debug and release. As the name implies, Debug Build Type is primarily used during development, and the Release Build Type is for production. Also, by default, the Debug Build Type is compiled with debug symbols and signed with a debug key, which allows us to install on a development device. You can also define additional Build Types, for example, for quality assurance testing. Product Flavors are used to create Variants that will be user facing. Product Flavors will typically map one to one with a place door download. A very common case is an app with free and paid versions. Together, Build Types and Product Flavors create a matrix of Variants. With Debug and Release Build Types, and free and paid flavors, you get a two by two matrix of Variants. In this case, we have Variants. Free Release and free Debug, and paid Release and paid Debug. Let's check out how to declare and configure Build Types and Product Flavors in our Gradle build. Let's check out where and how to configure build types. Since build types are only relevant to the android component of this build, we need to check out the build.gradle file in the app folder. Build types are declared in the build types script log. Here we can see that android studio has already added some additional configuration to the release build type for us. Take note, although debug isn't listed here, the debug build type still exists. In this case, we are disabling packaging optimizations by setting minifyEnabled to false. Also, we are configuring where the android plug in should look for proguard configuration. We'll talk more about proguard in lesson four. If we open up the gradle pane to look at the available tasks for our project we see that we have assemble tasks for each one of our build types. So we have assemble debug and assemble release. Another way to pick which build type we want to build is by opening up the build variance pane. And then we can select between debug and release. Let's say we were building a game and wanted to make a build for a QA testing that's exactly like the release build except it bundles in sheets for infinite gold or to skip levels or whatever. We can easily declare a new build type by adding it to the build types block like cell. It's your turn to do some build type configuration. Check out the exercise in the course code. Note that the build dot Gradle file you'll need to work with, is actually in the app folder. When you're done fill in the blanks to configure the debug build type We've learned how to use build types to customize Gradle's behavior. So now let's look at how build variants allow you to control the behavior of your app itself. And depending on which app we're building, the Android Gradle plugin creates a whole slew of source sets. And depending on which variant you're building, it will merge the sources and resources from those source sets into the final APK. At the most broad level, there's the main source set which is located in source main. This is where we've been putting all of our code so far. Additionally, there's a source set for each product flavor. Assuming our example from before, let's say we have a free and a paid product flavor. There's also a source set for each build type, in this case debug and release. Finally there's also a source for each final variant. So that's source free debug, free release, paid debug, and paid release. If we have sources and resources that we need in a paid flavor but not in the free flavor, we can put them in source paid. Similarly, if there are resources we need for debug build but not for the release build, we can put them in source debug. Finally, if we have resources that are needed only for the paid debug variant, then we can put them in the source paid debug. When we build a particular variant, Gradle will take care of all the emerging sources and resources we need for that variant. It will also take care of a variety of resources that are defined in more than one configuration. The rule is that the more specific configurations override the less specific configurations. Java's source files cannot be overwritten, so you need to be careful that you don't try to define the same class definition, and it ends up in multiple variants. Gradle can do a bit better for resource files like strings.xml, or even Android Manifests. For resources of that type, the files will be merged, and the entries will be overridden by ID. To determine what sources and resources are included when we build a particular variant, we can draw a diagram that looks like this. We start in the middle. If we want to build the paid debug variant, Gradle will include everything in main, then merge everything in paid, overriding any conflicts. Next Gradle will merge in everything from debug overriding again. Then, finally, Gradle will merge in the resources and source that are in paid debug. Let's make an app with a free and a paid version. We're starting out with the base template, everything absolutely vanilla, if we run it, it looks just like normal. Unlike buildTypes, the Android plugin doesn't create any for us by default. If we want to declare product flavors, we do so just like we do with buildTypes, except we put them in a productFlavors block instead of a buildTypes block. Here, we've gone ahead and created our free and paid flavors. Along with unique applicationIds for both. Now, if we open up the Build Variants tab. We see, we have options not just between Release and Debug. But freeDebug, freeRelease, paidDebug, and paidRelease. Of course, these different flavors don't actually do anything different yet. By default, source and resources in the main source set, is included in all app variants. However, when we declare additional flavors, the android plugin automatically creates new source sets for us, where we can place flavor specific code and resources. So if we want to include code specifically for the paid version, we can have src/paid/java and src/paid/res. Similarly we can have src/free/java and src/free/res. When gradle builds each app variant, it will automatically bundle the additional source in each of the flavor specific folders. The new app template in Android Studio makes an app that just displays a string. Let's open up the res > values > strings.xml file and here's the Hello World string that will display. Let's create new strings in our free and paid versions, so that the free and paid versions display different messages. The easiest way to do this is first, we'll copy the hello world string. Then we'll right click on the app directory. And I know it's a little bit off screen, but if you navigate up to the very top, there's New > Android resource file. We'll name the file strings. Resource type is values, and here's the interesting part, where we choose the source set. We'll make this part of the free source set. Okay. Now if we look at the src folder, we'll find src > free > res > values > strings. That's what we're editing right now. Let's put in our new message. And we've also done the same thing for the paid flavor. Now if we open up the gradle pane, and go to the install section, let's try installing the free debug version. And we can also go ahead and install the paid debug version. One more thing that's useful to know, in addition to including additional sources in a flavor variant, we can place flavor-specific configuration in our gradle build file. Basically, any configuration that we can put in the defaultConfig script block, can also be placed in the flavor configuration block. For example, let's say the paid version of our app requires a new Android SDK, we can enforce that like so. Let's add product flavors to our joke telling app. The free version will tell a bad joke, and the paid version will tell a funny joke, at least that's the intention. We've provided some sample jokes in the course code, but feel free to get creative. When you're done, where do you put string resources for free and paid flavors. Fill in this portion of the path. Awesome work adding flavors to your app, you put string resources for the paid flavor, and app/src/free/res/values/strings. Similarly, for the paid flavor, it's just app/src/paid/res/values/strings. Let's go one step further and add a whole new activity to one flavor of our app. We'll make our app with a button offering a joke, in the paid version of the app the button will open a new activity showing a joke. In the free version, the button will just display a toast, telling the user to upgrade to the paid version. When you're done, see if you can answer this question. Why assign unique application IDs to flavors? Is it because it's required, is it to distinguish log messages, or is it to allow installation of both flavors simultaneously? Pick any of these that apply. Awesome work adding a flavor specific activity. It's not actually required to assign a unique application ID to each flavor, however, it does help by distinguishing log messages and most importantly it allows installation of both flavors on the same device at the same time. Well, while there's a lot more to learn about Android build variance, you're well on your way to building bigger and better apps, all while keeping your build complexity manageable. The Android griddle plug in creates a set of configurations for each build variant. This allows us to manage dependencies independently for each of our variants. So we'll have the usual compile and run time configurations. But we'll also have free compile and free runtime. And so on. The free runtime configuration extends the free compile configuration. Just as compile extends runtime when using the Java plugin. Additionally, free compile configuration extends the regular compile configuration. Which means our free variance will include all of our default dependencies. In addition to those added to the free configurations. It's probably likely that we would want to enable ads in the free version of our app, but not in the paid. Utilizing Google's Ad Services requires to depend on the Ad Services Library. However we don't want to unnecessarily bloat the paid version of our app by including a library that won't be needed. To solve this problem we can simply declare this dependency only for the free version of our app. As you can see here, we've added a dependency to the Google Play ad services. But we've assigned it to the free compile configuration. That's really there is to declaring variant specific dependencies. But we've included a demo in the course repository. You should check it out. There's a couple more things about Android Build Variants that you should know about, but you won't necessarily need to use them very often. Consider a game that contains a great deal of drawable resources. So many in fact that including all the drawables for every resolution would result in an unacceptably large APK. This would be an excellent time to use product flavors, one for medium DPI and one for high DPI. Now, consider what happens if we want to add free and paid flavors. You'll want both a free and paid medium DPI version, and a free and paid high DPI version. This comes out to four total flavors. However, now if you want to include additional functionality in the paid version, for example, you have to put it in two places. One for the paid medium DPI and one for the paid high DPI. Now, suddenly we've lost all the code release advantages of using flavors in the first place. Fortunately, the Android plug-in supports the concept of flavor dimensions to deal with this use case. Just like the Android plug-in will create tasks for each combination of build type and product flavor. You will now be able to build every possible permutation build type, product flavor, and flavor dimension. Let's say say we want to change a compile flag in our Java project. We can just add some configuration to the compile Java task. However, unlike simple Java projects, which have a finite set of tasks such as, compile Java, jar, test, etc. Android projects can have an indeterminate number of tasks, depending on the build types and product flavors we have declared. Additionally, the names of these tasks are generated, and they're based on the name of the particular variant the task is for. Not only that, but these tasks are created at a very late stage of the project configuration life cycle. Which means, in most cases, we can't directly reference them in our build script. Essentially, we need to solve two problems. First, we need a way to reference each task used to build a particular variant without having to know the task's actual name. Quite simply, we want to configure all the tasks of a particular type for every variant. Second, we need a way to defer the configuration of that task until after all of our build variants have been created. Which really just means that we can't configure the task until a task exists. The first problem is solved by the Android Gradle Plugin itself, which groups all the information to include the tasks associated with any given variant into a single object. There are three main types of these objects, the Application Variant, the Library Variant or the Test Variant. The type of variant we need depends on the type of project we're building. Application Variants and Library Variants are created for Android Applications or libraries respectively. And Test Variants are created for the on device test APK. Each one has its own specific properties, but they all have common tasks, like compiling Java, merging resources, and so on. So the Android Griddle plugin is nice enough to neatly package all the information about a variant for us, but the problem remains, how do we reference these variant objects? This problem is solved by what Gradle calls live collections. Essentially, as the Android plugin creates variants, they are added to a fancy type of collection. These collections allow us to define configurations for objects that don't yet exist. Instead, Gradle will remember our configuration and execute it when a new object is added. We specify this configuration by calling the all method on our variant collection. For example, if we wanted to configure all the Java compile tasks for our application variants to add a compiler argument, we could do something like this. This will now configure each Java compile task for each of our debug build types, regardless of how many product flavors we have configured. Also, you don't have to try and guess what the final names of each of those tasks might be. Hey Mark! Hey Mark! What is it this time? I've got my million dollar idea. Okay, you know what's super hot right now? Uh-huh. Match three games. So, I thought, what would be even better then a match three game? A match four game. I've got it all sorted out. I've got all of my matching code in the main source set. And then I'm going to add source sets for each one of the extra games I'm going to build with the matching engine right? So I've got my source set for my matching candies game. I've the got the source set for my matching sushis game. I've got my source set for my spider matching game. Yeah, but that's not really what product flavors are for. They're for different versions of what are really the same app. What you want to do is share a code between different apps. So, you really want to build a project library. Oh. You're a librarian and you have to match four books. Perfect, Mark. You're a genius. Congratulations on learning how to build apps with multiple flavors. That's just the start of how you can make your apps bigger and better while keeping them modular and maintainable. In the next lesson we'll talk about Java and Android library projects. See you there. Hey Jeremy. Oh, hi Mark, just a second. What are you doing here? I'm building the libraries my app depends on. What? I'm building the libraries my app depends on. I've got like eight Gradle projects set up, and I've got to build them in exactly the right order, making sure each project's output is ready to be consumed by the next project, then I send them all over to this project here, where they get built into my app. Wow, impressive. I know right, it's pretty spiffy. Oh man, multi projects. Oh no. I know that face, that's the face you make when Gradle can automate something I've been working hard to do on my own. No no, keep it up. Come on Mark, Gradle can handle all this for me, right? No, no, this is the way to do it. Bro, don't hold out on me. Come on, help me automate all this. All right, let's set up the multi project build. Thank you. In this lesson, we'll first look at why and how to break up a complex app into reusable libraries. In the process, we'll learn a bit about Gradle support for multi project builds. Then, we'll dive into some of the advanced features of the Android plugin for Gradle, including automatic signing and test support. Let's get started. They'll vary integrate, when we want to share code between different versions of what are essentially the same app. However, if we want to build a collection of apps, with similar capabilities, we may instead, want to break up some of our functionality often to a library. We may even simply have a collection of utilities that we want to share across projects, similar to the Google lava Library. There are two choices when creating libraries for use with Android projects. We can create a straight Java project that build a .jar file, or we can build an Android library that creates an .aar file. The primary difference between the two is that an .aar or Android archive can include its own resources and manifests, such as layouts or fragments, and it uses its own R file. The benefit of creating a Java library is it can be used on non-Android projects. It's up to you to determine if a library should be Android-specific or not. Just keep in mind that there are maybe future considerations, and that Java libraries are easier to turn into Android libraries than the other way around. Each of these cases would you use a Java library or an Android library. A custom fragment needs a layout and we need an Android library to include that resource. A custom collections framework doesn't need any resources, so it can just be a plain Java library. An Android service doesn't need any layouts, but it does need a manifest, so it needs to be an Android library. A custom activity needs both a layout and a manifest. So it needs to be an Android library. Finally, a library that just does some math and doesn't have any Android specific dependencies can just be a regular Java library. So far we've only talked about how to use Gradle to build a project component of a single deliverable output. But builds rarely stay so simple. A Gradle project can have any number of sub projects, each of which also has their own sub projects. Every multi project build also has a root project. Even if that root project is the container for its subprojects. You'll generally create a subproject in order to move some reusable functionality into a library. That way the library can be used by other projects, and also so Gradle can determine that the library and the app that depends on it should be built together. A Gradle multi-project build is configured in a settings decorative file in the root of your project. If you're creating an Android app, using Android Studio this file's automatically generated for you. In fact, every Android project created by Android Studio is a Gradle multi project by default. Note, Android Studio refers to sub projects as modules, but we'll use the two terms interchangeably. Lets check out an example. Now that our Java joke telling code is really coming along, we've broken it out into its own library. That way we can reuse it across projects. Let's check out how this project works. Inside our Android app build directory, we have this javaJokes directory that contains a stock Gradle Java project, just like we've been building all along. If we use the terminal to navigate to the javaJokes directory, we can use Gradle to build this project on its own, without reference to the Android app. However, our app doesn't yet know anything about this library. What we need to do is declare a compile dependency on the output of this library project. To do that, we need to add the library project to the same multi-project build as our Android app. We can do that in the settings.gradle file of the root project. The settings.gradle file is where we tell Gradle what sub-projects to include in the multi-project build. We already have the app project for the Android app, so we'll add the javaJokes project. There we go. Now if we ask Gradle what projects or sub-projects in this multi-project build, Gradle tells us that there are two sub-projects, the Android app and the Java library. Next we need to declare a project dependency between our Android app and our Java library. We can do that in the build.gradle file in the app directory. Here we simply say that our app has a compile time dependency on the project javaJokes. Now that we've gone ahead and declared that dependency, we can go ahead and import our Java library into our Android project, and we can use the class from our Java library. If we bust out the old test device, here's the joke from our Java library inside our Android app. When you run this multi-project build, if you watch the Gradle console you'll notice something like this. The app project started running some tasks. Then the javaJokes project jumped in to create a jar for the app project to use. Well, that's all there is to it, to add a Java library project to an Android studio build. Time for you to modularize your joke telling app. You'll create an app for displaying jokes and then you'll make two Java libraries to supply the jokes, one by hand and one using the Android Studio wizard. Then you'll add project dependencies between your Android app and your Java libraries. When you're done, you'll be able to answer this question. When a Java project is run as a project dependency, what tasks are run? CompileJava, processResources, classes, assemble, jar, build. Awesome work creating a Java library in Android Studio. The Android app module depends on the default artifact of the Java module, which is the jar. The jar task depends on compileJava, process Resources, and classes. Android libraries are essentially fully featured Android apps with the one restriction that they can't be installed by themselves. They have to be packaged into another app to be installed on a device. Android apps tend to consist of a whole lot of files, so while you can totally create an Android library by hand, it's a lot easier to use the wizard. Let's check out how to do that. If you right-click on the root of your project and select New Module > Phone and Tablet Applications > Android Library, you can give your library a name and an sdk, and then just like a normal app, you can choose what kinds of activities you want to add. Let's add a blank activity with a fragment. We'll give it a name. Now, a myLibrary folder has been added to the root of your project with all the familiar source and res and even a manifest that you'd associate with a normal Android app. Also, the wizard is nice enough to add your new library as a sub-project in the multi-project build. So, the last thing you need to do to be able to use your new activity in your base app is to head over to the build.gradle file in the app directory. And then we'll need to add a compile time dependency on the project myLibrary. That's all there is to it. Let's check out a working example. So here's the demo from the course code, which I strong suggest you go check out. We've added this imageactivity Android library to our project. This library defines an activity with its own layouts and with its own values, like strings. So here's the message that the activity's going to display. And this drawable of the Gradle logo is also wrapped up inside our Android library. In settings.gradle, imageactivity is added as a subproject, and in the build.gradle file of the app directory, we have a compile time dependency on the image activity project. So that means in the main activity of our main Android project, we can import image activity and set up an Intent to go launch it. If we go ahead and deploy that to our test device, here's the activity from our app module and our button which then launches the activity from our Android library. There we go. We've made an activity that's easy to reuse between applications. Now let's modularize the joke telling app even more. Check out the exercise in the course code, where you'll add an Android library project to an app. The library will contain an activity for displaying jokes, and that can be reused across any other joke telling apps you might happen to make. When you're donem where can you find the AAR file generated by your library project? Fill in the blank. Excellent work creating an Android library. This will really help keep your builds organized as they get bigger. You can find your AARs in /build/output/aar. Mm, Gradle, mm, Gradle. Jeremy, Jeremy. [COUGH] Hey, Mark. What's up? Yeah, I thought you were supposed to release your Android app today. What's all of this? Oh, I've just got to use Android's Studio wizard to generate my signed APK today, so I'm just doing my wizard ritual. I hope it all works right. A wizard? Yeah, you never really know what those build wizards are doing, right? So, you just gotta hope nothing goes wrong. You know a wizard isn't actually magic. Oh yeah? Well, how does it generate its magical keys and magically spit out a signed APK? There's nothing magic about it. Android Studio can't do anything that you can't do from the command line. Oh yeah? Yeah. Android Studio, all it was doing is telling Gradle to run some tasks. And those tasks are just using regular command line utilities. So, it's not magic? No. And I don't have to wear this robe to get it to work? Oh, thank god, this is so hot. [SOUND] Help me get this thing off. Oh, I never should have trusted that centaur I met in the mystical forest. I shouldn't have paid him 50 gold pieces for programming advice. All Android apps must be digitally signed before they can be installed on a device. The actual cryptography in math of how the signing process works is utterly fascinating, but also kind of beyond the scope of this course. Digitally signing an app accomplishes two things. First, it allows Google and users who download the app to verify the identity of the developer that published it. Second, it guarantees that the app hasn't been tampered with since it was signed. Quite simply, signing is required for apps on the Play Store, so that users can be sure that the app they are downloading was indeed published by the listed developer. It also protects you, as the developer, so that no one else can publish an app under your name. Gradle automatically signs debug applications with a special debug key that allows our app to installed on development devices. However, app sign with a debug key can't be published through the Play Store. In order to sign an app, we first need to generate a key. This key will be unique to you and should be used to sign all of your apps. We will also create a key store which is just a special type of database that we keep our key in. Android Studio makes creating key stores and generating keys incredibly simple. Let's take a look at how this is done. Signing an app gives you a cryptographic way to associate your app with a secret key that you control. To sign this app, we need to do three things. First, we need to create a keystore and a key. Second, we need to create a signing config in our build.gradle file. The signing config basically describes where to find and access the keystore and key. Then finally, we need to assign the signing configuration to a build type. You can do the entire signing process via command line tool, so don't think there's anything magic happening here. We have here a completely stock android project and note, that there is no install release task. That's because we haven't assigned the release build type a signing configuration, so it can't yet be installed. Let's go ahead and generate our keystore. We can do that by navigating to Build > Generate > Signed APK, up in the toolbar. We'll say yes, we want to generate the signed APK of the app module. And now we'll create a new keystore. We can choose to put the keystore in our project directory just by clicking this button. So we're creating a keystore called keystore in the root of our project. We're giving it a password, password. Then inside the keystore we're creating a key with the alias udacity, also giving it the password, password. Then we're specifying some demographic information in our certificate. If we just want to create a one-off signed APK, we can continue on through this dialogue. However, we'd really like to configure automatic signing. So we'll go ahead and use a different wizard to get that setup. To configure automatic signing, we'll right-click on the app directory and select Open Module Settings. Then in the Signing tab, we can create a new signing configuration. Go ahead and enter in the information about the key alias, the keystore locations, and the passwords. Now we can open up the Build Types tab, select our release build type, and assign the config, Signing Config. Now you'll not that that wizard actually added some configuration to our build.gradle file. We had the sign and configs block and then the config, Signing Config with that information we entered. Also, down in the build types block, our release build type now has a signing config assigned to it. And after we sync our gradle files, you'll note we now have an install release task. Note that the store file field is using an absolute path, which isn't very portable. There are various issues you might want to consider regarding the security of checking your keystore and passwords in the version control, but the most expedient thing to do is use groovy string interpolation and the rootdir property on the product object to make this a relative path instead. Time for you to set up your own key store and add an assigning configuration to an app. Then you can deploy your release build. When you're done, say your release build type was using a signing configuration called release. What task would be run immediately before app package release? Fill in the blank. Awesome work configuring signing. If you're using a signing configuration called Release, then the task that's run immediately before app package release is app Validate Release Signing. In this project we've got something a little bit silly. We've got 100 classes, each of which have 700 methods. Well this is clearly a contrived example. In principle there is nothing stopping a large project from getting this big especially if you have a lot of big dependencies. So, let's try compiling this. Oops, looks like we've got an error. Trouble writing output. Too many method references. 70,000, max is 65,000. Let's unpack what's going on here. The Android virtual machine doesn't actually run Java byte code. It runs Dalvik byte code. And there's a build step after java compilation, where the Java byte code is turned into Dalvik byte code. The step is called dexing. Part of this process is compiling a table of every method in the application, which is then indexed with two bytes. So, that means we're limited to 65K methods. Fortunately, we can ask gradleto simply break up this table into multiple tables by setting in our build.gradle file under default config, multiDexEnabled true. Now if we try and build again, looking through our build log we see that the dex process was run successfully, so now we're building just fine, even though our project is gigantic. This is just something to be aware of so you don't get bit by this in the future. The Android plugin can reduce the size of your app by stripping out unused code and resources. It does this with the help of a tool called Proguard. Proguard can do a lot of interesting stuff including obfuscating your code by giving all your classes and methods meaningless names. Though that's mostly of interest if you're really worried about your code being reverse engineered. For our purposes, the properties we want to configure on our build type are minifyEnabled and shrinkResources. In this project, we have declared a dependency on Google's mobile services library. But we're not actually using anything from that library. Proguard is smart enough to figure that out and will strip out the unused code from our APK. The mobile services library also includes many resources like drawables for sign in buttons. Turning on shrinkResources will strip out any unused resources. We've configured two new build types. One of which has turned on magnification and resource shrinking and one of which has not. Let's check out the relative sizes of the APK's generated by each filed type. Let's run the assemble task to generate both APKs. If we then go find out APKs in App, build, outputs, APK. We see that our big APK is 2.9 megabytes, whereas our shrunk APK, that was using minification and resource shrinking, is only 1.2 megabytes. There's a lot more you can do to optimize your APK using Proguard. We've included some resources in the course code, where you can learn more. There are two main types of tests you can add to your Android project, unit tests and connected tests. The primary distinction between the two, is that unit tests run on a regular Java VM on your computer. And connected tests run on an Android device or emulator. In general, you should use unit tests for testing generic, non-Android related classes. In fact, since unite tests are run against a mock Android STK implementation, any code that calls the android API will fail. In this case, you should either use a mocking framework like Makido, to mock the appropriate android dependencies, or use a connected test instead. Additionally, you can configure the testing options in your Gradle built script, to construct the mock Android implementation to return default values, rather than throw an error. In any case, it's up to you as a developer to decide how to best write your tests, and how to structure your code in such a way as to make testing easier. Connected tests should be reserved for testing logic that depend on Android API's, or for more high level testing like integration and functional tests. Remember, connected tests are packaged as an APK that will be installed on an Android device or emulator. So there's typically more overhead involved in their execution. Both unit tests and connected tests have their own source sets, named test and android test respectively. The notion of variants extends to tests as well. Allowing you to write tests specific to your build type of product flavor. The naming conventions for these source sets follow the same pattern as for application code, except for the test or android test suffix. There is a whole lot to know about Android testing. Honestly, we could, and probably should, make an entire course on how to do it well. Let's just look into how to run tests and when to use unit tests versus connected tests. We've defined a super simple project with this class Echo. It has a method that just returns whatever you put into it. It also has another version of Echo where it first logs whatever you input and then returns it. We've also added a product flavor to this project. In the paid folder, we've got paid Echo which does essentially the same thing but for collections instead of single objects. So we have this collection echo that echos back whatever you put in. And then this version of echo that first logs each item that you put in. So, we have defined some tests in the test directory. These are JUnit tests and so we just verify that echo is in fact behaving how we expect and that the logging version of echo is behaving how we expect. To test the paid flavor, in the testPaid folder, we have another pair of extremely simple JUnit tests that just verify that the echo of the collection works as expected. And that the echoing of the collection with logging works as expected. All of this code is in the course repository, so you can get a closer look there. If we open up the Gradle pane, and run the check task. Let's see what happens when we run these tests. Uh-oh, we have failing tests. We can check out the report at this file path to see what went wrong. So here we are at app> build > reports > tests > freeDebug > Index.html. And here's our report of what went wrong. Let's see Method i in android.util.log not mocked. So I think I know what's going wrong here. We tried to use the Android logger from a unit test. Now, the Android framework doesn't exist when we're running unit tests since those are being run on the local machine. If we want to test something that is accessing the Android framework, we have to run those on the device. Let's move those into connected tests instead of unit tests. So we'll comment out the tests that require the Android framework, comment this one out too, and now we'll added our connected to test to the Android test directory. Note that this is an Android test case now instead of a JUnit test, and we can add our paid tests to the Android test paid directory. Now if we open up the Gradle pane, and run connected check, and there we go. The tests that require accessing the Android framework will run on the device, where the Android framework is available. And they all pass. Time for you to create some tests of your own. Check out the exercise in the course code. When you're done, where would you put connected tests for a free product flavor? Write your answer in this box. Awesome work configuring unit tests and connected tests. You would put connected tests for free product flavor in the android Test Free directory. Hey, Jeremy. What are you working on? Just developing. Really? Yeah, it's actually going super well. Thanks for all the help with Gradle. Sure. Yeah, it's really helped me keep my bill organized. Well, I'm glad to help. You know what? I think I'm actually finished. Well, nice work. Yeah, my plans for world domination are complete. Thanks, Mark. Oh hey, do me a favor though, will you meet me at the radio tower and bring along some chicken wire, a frying pan, and two AA batteries? Sure. All right. Thanks, Mark. You're the best. Sure. Wait, what? Well, I hope you learned something in this course. Familiarity with Gradle will serve you well, no matter where your development journey takes you. Testing and build automation make even the largest projects easy to create and deploy. This is Mark from Gradle, signing off. Jeremy, what'd you mean by world domination? What did you build?