Do you ever feel like leaving you problems behind, strapping on your arm cannon and going on an adventure to jump around on top of stuff and blast away at evil robots? I know, right? Me too. Welcome to our second course on 2D game development with Lib GDX. In the first course, we made a simple game of dodging icicles. In this course, we'll learn how to make a much more complex platformer game featuring our hero, Giga Gal. In the first three levels, you'll let Giga Gal walk around, including this cool walk animation, and you'll let her jump around on top of platforms. Giga Gal will jump around on the top of platforms, dodging and fighting enemies with bullets fired out of her arm cannon. Sounds pretty cool, huh? So what do we need to do to bring Giga Gal to life? This course has eight levels to beat. In this level, you'll learn how to draw the images and animations that make up Giga Gal's world. In the next levels, we'll add the logic for Giga Gal herself, the platforms, and the camera that follows Giga Gal around the game world. In the second half of the course, we will add the evil robot enemies, and let Giga Gal fight back with her cannon. Finally, we will learn to load level data, and add a HUD and on-screen controls. By the way, this course relies heavily on the content from our first course on 2D game development with Lib GDX, so if you haven't already, you'll definitely want to take that course before moving on. The first order of business in this level is downloading the course code and ensuring your development environment is up and running. Next, we'll learn how Live GDX gives you access to some of the important capabilities of whatever platform your game is running on, including logging, graphics and file access. Then, we'll learn all about drawing sprites and textures and the differences between those two terms. We'll also learn a few tricks, such as creating a stretchy sprite called a nine-patch. And combining multiple sprites into animations. Finally, a big game with a lot of sprites can run into problems trying to load a ton of different files. So, we'll learn how to pack all of our sprites into a giant image called a texture atlas that we can load all at once. But first, the course code. Let's go get it. The code for this course lives in a git repository hosted on GitHub.com, at GitHub.com/udacity/ud406. Let's check it out. Here we are. If we scroll down to the bottom, here we'll find a read me that actually explains everything you'll need to do to download and start loading up the course demos and exercises. If you're familiar with git and GitHub, just go ahead and fork and clone this repository. Or, easier, if you scroll back up to the top, you can hit this Download Zip button to grab the code. If you can't access GitHub at all, you can also download the code directly from the downloadable section in the classroom. Now that our zip has finished downloading and we moved it to the desktop, we can go ahead and extract it. And here we are inside the course code. You can see all the demos, exercises, and exercise solutions for the course. Go ahead and grab the course code for yourself. Check off these boxes as you complete each task. Let's review how to import and run a libgdx project. Open up Android Studio and close any open projects until you get to this splash screen. On the Quick Start pane select Import Project. If you click on this button, second from the left, you'll jump straight to your desktop. There, hopefully you can find the ud406 folder. If not, go ahead and press these blue circle arrows, and that should refresh the file picker. The folder you want is 2.1.01-Demo-importAndRunAProject. And hit OK. Now that the project is imported, let's get it fired up. The easiest way to run the desktop version is to open the terminal down at the bottom left of Android Studio. And then execute the command gradlew desktop run. There we go, it looks like everything's working. Instead of using the terminal, we can also set up a run configuration so that we can use the Ctrl+R shortcut to run the game. To do that, we can go to this run configuration drop down, select Edit Configurations, hit the plus button, select Gradle. We'll call this new run configuration Desktop. We'll hit this button, and select the root project. And then for tasks we'll say desktop run. Then if we just hit Ctrl+R or hit the green arrow, we'll run the app. Unfortunately, you'll have to do this with every project you import as these run configurations are stored in the same place as user specific stuff, like the theme you use, which doesn't make sense to check into Git. Finally, to run the Android version, you can just switch the run configuration back to Android, and hit the screen button, or hit Ctrl+R. Hopefully, all these steps are familiar to you from a previous course. But you might want to run through them again just to refresh your memory. Excellent, now that we've got our development up and running, lets start digging deeper into libgdx. Let's try a programming quiz where we'll use GDX app to figure out what platform we're running on and then log the result. Since this is the first programming quiz in this class, I'll walk you through the workflow you'll be following for the rest of the class. First, below the video, you should see a link containing the URL of the starter code for this quiz. In this case it's 2.1.02 exercise log application type. All right, we've loaded up the exercise. So now the first thing to note is that the root of this folder contains a readme. It actually has a detailed description of everything we've covered so far in the course along with instructions of how we're going to complete this exercise. So this says to open up the TODO pane to find what we're suppose to do. Looks like there's four TODO's and two different files. If we open up one of these folders. That's actually this TODO in the README itself. If we open up this one, this looks like what we're suppose to be accomplishing in this exercise. Let's open it up. All right, first thing, we're supposed to give our application listener a log tag. Well, we want the tag to be public, static, and final. It's a string named tag and it's value is logging demo, class, getname. All right, that's one to-do accomplished. Let's look at the next. All right, the next few to-do's are us Gdx.app to find out what application type we're running, and then use Gdx.app to log the result. Well, I think I can actually do those together in one line. We'll start with Gdx.app log, passed in the tag, provide some description of what we're talking about, then, to get the application type, we can just use Gdx.app getType. Now, if we run this application we get the nice log message we're running on desktop. All right, give this a try yourself. And also try running it on Android to see of Gdx.app is accurately reporting its application type. Remember to follow the Todos in the starter code and take a look at the solution code if you run into trouble Nice work. The solution videos for this course will be quite short or non-existent, since the complete solutions are all available in the course code. But I'll jump in when I have something interesting to point out. In this exercise, in the Android assets directory, we've provided this punchline file that contains the punchline to a funny joke. Well, actually the punchline's encrypted. So it's up to you to read in the punchline and decrypt it. Follow the to do's in the course code to load, decrypt, and log the punchline. I am so, so sorry. I asked everyone [LAUGH] on the game dev team, and apparently none of us can write jokes. So, how does GigaGal tie her shoelaces when her arms are cannons? Very carefully. Now that the housekeeping is out of the way, let's get back to drawing things on the screen. Let's draw the udacity logo in the middle of our game world. There's a number of things we're going to have to do to make that happen. First of all we need a sprite batch. Sprite batch is pretty much like the shape renderer we were using for drawing simple shapes, except it draws textures. We also need to declare a texture to hold onto the Udacity logo. Remember that a texture is just an in-memory representation of an image. In the create callback of our application listener, we need to initialize the sprite batch, and we also need to load up the texture. If we open up the project pane, and we go to android assets, we can see the Udacity logo that we're loading up and about to draw. Down here in the render callback, when we're getting ready to actually draw, first we need to set the sprite batch's projection matrix, just like with the shape renderer, and then begin the sprite batch. The draw method of the sprite batch is ridiculously overloaded, but in a way that's actually very similar to the rectangle methods on the shape renderer. In this case, we are drawing the Udacity logo with its bottom left corner at zero zero with width logo size and height logo size. Just like with the shape renderer, we've got to remember to end the sprite batch. And there we go, we've successfully drawn the Udacity logo. I'll leave it up to you to figure out how to center it in the world. Follow the to-dos in the course code to try loading and drawing a texture for yourself. So, here's an issue. What happens when the size at which you want to draw a texture is different from the size the texture actually is? For instance, this center image is the actual size of the GigaGal texture. That's one pixel in the texture is one pixel on the screen. Well we have two very different ways of drawing GigaGal at six times her normal size. The way we choose the color of the extra pixels that are added when we scale up a texture is called filtering. On the left, we're using nearest neighbor interpolation. That is to say that we just pick the nearest pixel in the original image to figure out what color to color a new pixel. Over here, we're using linear filtering, which uses a linear combination of the nearby pixels to select a new color. Basically, average it. Now, in most cases, especially if you're only making the texture a little bit bigger, linear filtering will tend to preserve more detail. But it's also a little bit more costly from a graphics point of view. However, since all the textures for GigaGal are in this pixel art style, we'll be using nearest neighbor interpolation or nearest neighbor filtering for most of this class. LibGDX provides a third type of filtering called MIP mapping. And that is where it precomputes a bunch of versions of the texture at different scales. This is most useful when the size of a texture is going to be changing dramatically over the course of a game, which mostly happens in 3D applications. So we're not going to worry about it here, Games usually have a lot of image assets. Not always. Some games create quite a bit of their imagery programatically actually using simple graphics primitives. But it's definitely more common to represent actors and objects with sprite images or 3D models, depending on the type of game. When you add textures, backgrounds, icons, badges, buttons, and other UI elements. The list of image resources you have to keep track of just keeps getting longer and longer, especially when you may need multiple copies of an image with a different level of detail for each. In these cases, it becomes more efficient to combine related images into a single sprite sheet or texture atlas. There's a little more overhead in the drawing code but loading becomes much faster, much simpler and typically you even save storage space because the combined images compress better than they do individually. We just talked about texture filtering and how that lets you draw textures at whatever size you want. However check out these buttons in your operating system. No matter how big they are, they always have these nice rounded corners and the same smooth gradient on the sides. If we created these buttons by simply drawing the same texture at different sizes, they would look stretched out and the corners wouldn't maintain their nice curves. The way buttons are drawn and actually this entire window is using what's called a NinePatch. So if you look at this window, there are four corners that don't stretch at all and then there's four edges that do stretch, but only in one direction. Finally, there's the middle or the contents which we'll have to stretch in both directions. Four corners, plus four edges, plus the middle equals nine patches. So, to make a nine patch you take a stretchable image, like this one we're going to use for GigaGal's platforms. And then you draw four lines across it like so. Now we've got our nine sections, the four corners that don't stretch at all, the four edges that only stretch from one direction, and then the middle that stretches in both directions. Now we can draw this nine patch at whatever size we want and the edges and corners will never distort. Let's see what it takes to load up a nine patch. So first of all we just load up the texture that we're going to be making into a nine patch, and then the nine patch constructor just takes the texture and how much to chop of the top, left, bottom, and right to define the nine patches. In this case, the edge of our scalable image has size eight. So for instance the top left corner is an eight by eight square. The top edge is eight pixels deep and so on. Drawing a texture versus drawing with a nine patch is almost identical. The only difference is you call batch draw passing in a texture, but with the nine patch, you call draw and then pass in the sprite batch. And here we can see the results of drawing with a nine patch verses drawing with a texture. If we draw a texture at a small size and then at a larger size, the screw heads get all tiny and it doesn't scale very beautifully. With a nine patch on the other hand, the size of the screw heads is always identical, regardless of the scale of the overall nine patch. Time for you to load up the texture, chop it into nine patch, and draw it out at a couple different sizes. Let's check out to what it takes to create a walking animation. The animation constructor expects an array of texture regions. Now what is a texture region as opposed to a texture? We'll actually talk about that in the next node, so hold on a second. We have three frames in our walkLoop. So we load up the texture, convert it into a TextureRegion, and add it into our array, then we pass them to the constructor how long we want each frame to last, the textures to display, and then the PlayMode. Also note that when we create our application listener we save off the time at which it's created that way we can get the appropriate frame from the animation later. Then down in the render callback we figure out how many seconds have elapsed since we started displaying the animation using this bit of math here, and then we ask the walkLoop for the key frame that we should be displaying right now. That's the texture we want to display given the elapsedTime since we started displaying the animation. There's also a whole lot more detail in here about how to draw the cool explosions we're about to see. I'll let you look into that on your own. So here's the result. The animation has three frames, one where GigaGal's left foot is forward, one where her right foot is forward, and one where her feet are about even. Since we put this in ping pong mode that means we go left foot forward, even, right foot forward, even, and so on. Also GigaGal appears to be in a bit of trouble. Hope she runs through all the explosions okay. Dig into the to do's in the course code to set up GigaGal's walk loop and the explosion animation. We have here in core raw asset sprites all of the assets we've created for gigagal. Now we don't want to have to individually load each one of these files into our completed game. What we really want to do is pack all of these images into a big texture atlas. Then we can load that whole atlas all at once, and we don't have to load a bunch of different files. To do this we have to delve into the mystery that is the build.gradle file. The to do's in the course code will show you exactly how to do this. But first of all, we need to add a dependency on the GDX tools package in the build script block. That means that this code itself is dependant on GDX tools. Then we need to import texture packer. Then down in the block of the build script that applies to the core project, we're adding a new task called packTextures. That first of all, deletes the previous atlas, and then processes our core/rawAssets/sprites directory. Finally we ensure that every time the compileJava task is run, the packTextures task is run first. I am sure all of this Gradle stuff is still a gigantic mystery. Don't worry about it. Check out the To Dos in the course code, and it'll explain it all in excruciating detail. The upshot is that if we open up our project pane again and we go into Android > Assets > Images, we find a big PNG with all of our assets packed together in one image. So how do we actually use the textures that we've packed into our atlas? Well, the answer is kind of complicated. First we have to create an asset manager and have the asset manager go load up our atlas. Then, we can use findRegion on our atlas to grab particular regions of the atlas that contain the texture we're interested in. So down here in the render callback. We've got our standingRight texture region, we'll just get the texture and we'll draw it using a spread batch. Let's see what happens. Whoops, okay, we just wanted the the standingRight texture right here, but instead we got the entire atlas. To get a texture region to draw correctly, we have to use one of the more complicated versions of the draw method on the sprite batch. That takes into account what portion of the incoming texture we actually want to draw. Again, the annotations in the course code will do a better job of explaining this than I will here. All right, time for you to go through the entire texture workflow. >From packing all of your textures into an atlas. To loading textures back out of that atlas that you want to draw. And then drawing them correctly. Fantastic work so far. You're learned more about how LibGDX provides access to common platform features and learned to pack and draw textures, animations, and nine patches. With that background out the way, let's start bringing to life. Next level we'll set up movement and jumping, along with all the proper sprites and animations. See you there. Now that you can load and draw sprites and animations, it's time to start work on Gigagal. In this level, we'll plan out the structure of the game, build out a project skeleton, and set up our asset loading system. Then we'll focus in on creating Gigagal herself. To keep track of the state of Gigagal, and to know what sprite or animation to draw, we need to keep track of five things: Her position and velocity, what direction she's facing, whether or not she's walking and what state of jumping or falling she's in. Giga gal is a complex class, for sure. But at the end of this level, we'll have a fun character to play with. Let's get started. Time for you to use the LibGDX project setup utility to create the blank project that we'll turn into GigaGal. Check out the instructions in the course code. Go ahead and lay out the skeleton of GigaGal. The to-do's in the course code will let you know specifically what you need to do. Awesome. Let's start flushing out the skeleton. Now that we've got our project skeleton together, for GigaGal, let's get to the point where we can start drawing sprites to the screen. The first thing to do is going to be setting up our texture atlas, which means setting up the pack textures task in our Gradle Build build file so we can generate our atlas. The biggest part of this exercise is going to be setting up this Assets singleton class. Now using the find texture region method is actually quite slow. And we want to set up where we only have to ever do this once for each texture. Setting up a singleton is a pretty efficient way to do that. As part of setting up our asset singleton, we'll also create this GigaGal assets class that will hold onto the specific regions of the texture outlets that we'll use to draw GigaGal. Then over in GameplayScreen, we'll create all of the drawing infrastructure we're used to, like a SpriteBatch and a viewport. Then down in render, we'll set the background color, setup the SpriteBatch's projection matrix, and then go grab the texture region out of our GigaGal assets in our class. Finally we'll draw that texture region to the screen. And here we go, we've got our first glimpse of GigaGal. As always, the to-dos in the course code will show you exactly what you need to do to setup Asset Loading. Good luck. In this exercise, you'll start setting up the GigaGal class, including giving GigaGal a position and velocity, giving her a simplistic update method, and allowing her to draw herself. You'll also start working on the Level class, which will hold on to all of the objects in a single level of GigaGal. When you're done, the results won't look super different from the end of the last exercise, but at least GigaGal is standing on the ground now. Check out the to-dos in the course code to allow GigaGal to keep track of her position and draw her sprite in the right spot. Just like we did for the hero of Icicles, add in the ability for GigaGal to move left and right based on arrow key input. Check out the to-do's in the course code, to first add some constants that define how fast GigaGal moves. Then add onto her update method, so that you can detect left and right key presses and actually move GigaGal back and forth. In the last exercise, we made GigaGal move, but you may have noticed she couldn't turn to the left. Let's fix that. First of all, we'll add this facing enum to keep track of what direction GigaGal is facing. Then we'll update her facing direction based on what direction she's moving. Finally, down in render, we'll draw either the right facing sprite or the left facing sprite based on GigaGal's facing direction. When you're done, it should look something like this. By the way, I don't think she's passing the cannon from hand to hand. I think both of her gauntlets are able to turn into cannons. But feel free to interpret that however you want. Now it's up to you to set up GigaGal for multi-directional mayhem. Alright, this one is going to be tough. In this exercise we're going to let Gigagal start jumping. First, by making her fall. Then, by making sure she doesn't fall through the floor. And finally, the hardest part is deciding what to do in response to the jump key being pressed. Should Gigagal start jumping, continue a jump she already started or is Gigagal falling and therefore we shouldn't do anything at all? Stick with it though, because the result is way too much fun. It's up to you now. You've got the set up, the constants that determine how jumping works like how strong gravity is and how high Gigagal should jump. Set up the jump state enumeration that determines whether Gigagal is on the ground, currently jumping, or falling. Then sort out how to transition amongst those states. Finally, just jump around. After that marathon of setting up GigaGal's jumping, let's do a slightly easier exercise. In this one, you'll just have to add to the jumping sprites to the GigaGal assets class. And then in the render callback, determine whether we're on the ground or we're currently jumping, and draw the right sprite. If you thought GigaGal was cute before, check her out now. Boink, boink. Your mission, should you choose to accept it, is to add GigaGal's jumping sprites to the assets singleton. And then add in the logic to draw the correct sprite based on GigaGal's jump state and facing direction. In previous exercises, we added in the JumpState to determine when GigaGal is up in the air versus on the ground. We added the Facing state to determine whether we should display the left or the right facing sprite. So, now let's add in WalkState to determine when GigaGal is just standing versus walking. Then we'll make sure we're updating the WalkState properly. Then we'll add into our giant if-else block in Render. Then we'll add the walking sprites into our giant if else block in Render. I know this is getting pretty ugly and you might be thinking, shouldn't we be doing this with switch statements? Well, you can do it with three nested switch statements if you really want to. I think this is a little bit cleaner. The result is a Gigagal that stands, jumps, and walks. Follow the to dos in the course code. To load up the walking sprite, create the walk state enumeration, and display the proper sprites with Gigagal is walking versus standing or jumping. Time to face the final boss of this level. In this exercise, you'll animate GigaGal's walk, first by loading up the animations and storing them in GigaGal's asset inner class. Then by getting and displaying the proper frame in GigaGal's render method. When you're done, it'll look like this. To add GigaGal's walk loop, you'll need to load up the animations, keep track of how long GigaGal's been walking, draw the right frame, and then you just have to sit back and enjoy your victory. Are you a robotics expert? Because you've just brought Giga Gal to life! This level has had a lot of challenging stuff in it, figuring out how jumping should work, keeping track of the complex set of anums that define Giga Gal's state, loading up all the right assets, and making sure they're drawn at the right time. While jumping around randomly sure is fun, I think this game is missing something. Maybe some platforms to jump on? Whatever system you choose to build your game, take advantage of the objects and patterns it provides to decouple the pieces and simplify development. These might be special abstract data types that hide private data, or a type safe way to pass messages between game objects. There might be a built-in mechanism to create actors or items in the world, or maybe even behaviors that can be attached to these objects. The system might provide object pooling to automatically recycle unused items and optimize memory usage. If you're using a game engine or library that includes features like these, they can greatly speed development and usually end up making your code more robust in the process. You don't have to build these components from scratch, and you don't have to debug them usually. Even if you're not using a game development framework, the programming language you choose may offer features that can help you create solid game code. Type safety, object-oriented features like classes and interfaces. Private data access, threat synchronization mechanisms, memory management, standard collection types. These are all useful features that can reduce your coding burden. Now that we've got GigaGal running and jumping, she really needs something to jump on. Let's add the eponymous platforms to this platforming game. First we'll talk about the mechanics of how GigaGal will interact with the platforms. And then we'll add pretty 9-patch platforms to the game. Then we'll figure out the details of how to check when GigaGal should land on a platform and when she should fall back off the side. Finally, you'll make your own platforming challenge course. Let's get to it In this exercise we'll begin working on the platform class just by giving it some dimensions and a basic render function. When we're done we can make platforms appear on the screen, but we can't interact with them yet. Follow the to do's in the course code to set up some basic platforms. Now that we have some basic platforms, let's make them a little bit more presentable by trying them with the NinePatch. First, we'll need to add a PlatformAssets in our class to the assets singleton, then, in Platform's render method, we'll just draw it using the NinePatch instead of a rectangle. And there we go, much prettier. Follow the to-do's in the course code to draw some pretty Nine Patch Platforms. Now that we can draw pretty platforms, we need to let GigaGal land on them. We've got a bit of a tricky decision on our hands though. What class should be responsible for determining when GigaGal has landed on a platform? Should the platform determine when it's been stomped on by GigaGal? Should GigaGal determine when she has hit a platform? Or should the level object orchestrate the interaction of its minions. This is where a game design start to be more of an art than a science. But, I'd argue that GigaGal should handle her own collisions. It's GigaGal's jump state and velocity that will need to change based on the result of the collision. So making her responsible is the logical choice. Leaving the collision detection up to the level is also a reasonable choice. It depends on how smart you want to make your entities. There are certainly cases where you want your game entities to just hold on to their position, velocity, and texture, and not handle any of the logic themselves. That's not the direction we've gone with this game, but it can be a reasonable choice. The platforms probably shouldn't be the one checking to see if GigaGal has landed on them. If we were organizing things that way, the platform would need to reach into GigaGal to fix her fall state and that's probably not a good idea. We need to be careful about what entities can affect other entities, lest we end up with a complicated web of interactions that we can no longer reason about. We'll come back to this sort of topic when we add enemies and bullets to the game. So, we've set up the rules for figuring out when GigaGal lands on the top of a platform and when she misses the edge. We do so by looking at GigaGal's position in the last frame, and her position in the current frame. So, in this diagram, the base of the arrow is her position last frame, the head of the arrow is her position this frame. In which of these cases does GigaGal land on top of this platform? So the first rule of GigaGal landing on a platform is in the previous frame she has to have been above the platform. And this frame she has to be below the top of the platform. So, that eliminates this case and this case. In all three of these cases, the last frame she was above the top of the platform. This frame she's below the top of the platform. And she's ended within the horizontal span of the platform. So, in all three of these cases, even this one where it doesn't really look like it, we're saying she's landed on top of the platform. In this exercise you'll let GIGAGAL land on top of platforms mostly by filling in this landedOnPlatform check. First we check to see if GIGAGAL has fallen past the top of the platform in the last frame, then we check to see if either her left or right foot is currently in the platform's horizontal span, or if she's straddling the platform. And that finally means we can careful, careful. Yes! So it's time for you to give GigaGal the ability to land on platforms. Check out the to do's in the course code to get started. Our platforming system is complete. Now, it's time to create some challenges. How high can Giga Gal jump? How far can she jump horizontally? What other tricky jumps can you set up? Add some debug platforms and try and create your own jumping challenge. Or just jump around for awhile and enjoy your work so far. Awesome work. You've added the core platforming mechanic to Gigagal and worked out some sophisticated game logic to do so. I hope you're already starting to get some fun ideas for level designs. Right now though, you only have one screen's worth of platforms to work with. In the next level, let's fix that, by allowing the camera to follow Gigagal around. See you there. Part of the fun in creating a 2D game is designing the game world and levels. You can be as creative as you want here, and come up with something completely new, or take inspiration from an historical great, an homage to the bit glory days. Whatever your game world looks like or how it behaves, for all but the most basic games you're going to need a way to define, and save and restore, level layout and features. And first, this might be done statically in code, you just hard code paths and obstacles, and I'm using powerups. But eventually you'll find keeping level data separate from game code, really simplifies level design and programming. It's a good idea to store level data in simple text files during development. Whether comma-separated values, YAML, JSON, XML, it doesn't really matter as long as the data is generally human-readable and you can edit it directly. It doesn't even have to be text. An image bitmap is another flexible way to define levels, and it's easy to edit with standard drawing tools. We'll explore this more a little later on. The format you choose will usually be a function of which parsers are readily available in your game framework or programming language of choice. There will probably be several options, so you can pick the one you're most comfortable with. For production, many game developers convert text format level files to binary. In part to reduce their size and sometimes to make the data harder to reverse engineer or hack. Even if you don't do this though, pushing level data into external files is highly recommended and makes it much easier to work with. So far we've had a stationary point of view while GigaGal moves around the screen. That puts some pretty severe limits on our level design though, given that we only have one screen's worth of platforms to work with. Let's fix that by allowing the camera to follow GigaGal around the screen. While we're at it, we'll also remove the floor at the bottom of the screen and detect when GigaGal has fallen to her doom. Finally, while the chase camera is great for debug purposes, it'd sure be useful to be able to move the camera independently from GigaGal's position. So we'll add in some debug camera controls as well. Let's get the heavy lifting out of the way first by adding a chase camera that follows GigaGal no matter where she goes on the level. Check out the to do's in the course code to add GigaGal's chase camera. One of the ubiquitous mechanics of platformers is that when you fall off the platforms, you fall into a bottomless pit. Up until now, we've had a nice friendly floor at y equals zero. Let's remove that so if you a bad job jumping up platforms, you fall for ever. Remove the floor from GigaGal's update method to add in some consequences for missing a jump. And by the way, you'll probably want to make sure that when Gigagal spawns in to the level, she lands on top of a platform. So now GiggaGal can fall forever, but it's a bit harsh to have a permanent game over after one missed fall. Let's check to see when GiggaGal has fallen below the level and then reset her to our starting location when she has. This kind of mechanic is also known as a kill plane. Check out the to do in the course code to add a kill-plane and respond GiggaGal when she falls off the level. Now that we can make levels that are bigger than just one screen, and there are some consequences for falling off, let's build a level with more and bigger jumping challenges. Add some more platforms to the debug level initializer so that Gigagal has some more room to play. So, now we can build levels that are as large as we want. But it's a bit of a pain that if we want to check out the bits of the level that are far away from Gigigal's spawn point, we have to actually walk Gigigal over there. Let's fix that by adding in some debug camera controls that allow the camera to move independently of Gigigal. We'll also add in a toggle so that you can snap back the camera to following Gigagal again. And then can switch back to free roaming mode. Check out the to do's in the course code to add in some debug camera controls. Excellent job with some simple, but important work. Your camera is the only window your player has into your game world. So, make sure it presents the best your world has to offer. So, now we have GigaGal, some platforms to jump on, and a camera that can move around the level. It's awfully quiet in there though. In the next level let's adds an evil robot buddies to play with. Let's add the dastardly robot enemies to Gigagal. Ugh, they're so evil with their floating around and their slight buzzing noises. Anyway, each any will patrol the top of a particular platform. And if they hit Gigagal, we'll send her flying with both tricky jumps and robots in her path. It's also time to give GigaGal something to strive for. So we'll add an exit portal to our levels. Let's get started by setting up the assets for the enemies. First things first, we're going to set up the assets for the enemy robots. Note that there's no interaction between GigaGal and the enemies yet. This is just drawing a sprite. The process for setting out new sprites should be pretty familiar by now. We'll need to set up an inner class for enemy assets in our assets singleton. And then we'll draw the enemy sprite in the render method of the gameplay screen. Let's specify the behavior of our enemies. Each enemy will be associated with a particular platform, and will patrol the top of that platform, turning around when it reaches one of the ends. Like that. The enemies also seem to be floating on some kind of zero gravity, so we'll have them bob up and down as they move. Finally, we need to determine how to make the enemies dangerous. Now one option would be to have GigaGal have a health meter, and then subtract from that health every time she hits an enemy. I think it's more interesting though if instead, every time GigaGal touches an enemy she gets flung backwards, possibly falling to her certain doom. Let's start fleshing out or building out our robots. When we're done we'll just have an enemy sitting on top of a platform. Note that it's not moving or colliding with anything yet. Our enemy class needs a render method to draw itself. And we'll need to hold on to a platform and a position. We'll also need to add a collection to our level to hold on to the enemies. Finally, let's add some enemies into our debug level. Next let's have the enemies patrol the platform. First will decide how fast they should move and then we'll make sure they turn around when they're about to fall off the edge. Check out the to do's in the course code to get those lazy robots moving. Now, just for aesthetics, let's have the enemies bounce up and down as they move back and forth. Check out the to do's in the course code to add a little bit of swagger to the robot step, or a wobble to their anti-gravity systems, whatever. Our enemies sure are scary. All blue and shiny and evil. When you get up close though they do seem a little intimidating. Let's figure out how we can detect when Gigago has run into an enemy. So Gigago takes up kind of a rectangular space. And the dangerous bits of the enemy are more or less a circle. For the actual game we'll end up approximating both Giga Gal and her enemies as rectangles. But as an aside, can you figure out how to detect when a circle and a rectangle are overlapping? Check out the course code for a little challenge on circle rectangle collisions. Turns out, circle rectangle collisions are pretty complicated. But collisions between axis aligned rectangles are trivially easy. Actually, you get rectangle overlap for free in LibGDX's rectangle class. So let's approximate GigaGal and the enemies as rectangles. Then check to see if GigaGal is touching any enemies. Let's also figure out if GigaGal is running into the enemy from the left or from the right. It's up to you to set up GigaGal to detect when she's run into an enemy. First by setting up rectangular hit boxes, detecting the overlap, and then calculating the direction of the hit. Let's give our enemy some actual teeth, or electro repulsor fields, or whatever. When Giggy Gal touches an enemy, she'll be flung away to her almost certain doom. This mechanic is commonly referred to as knock back. First, we need to set up a constant for Gigi Gal's new velocity when she gets knocked back. Then after we establish the Gigi Gal is touching in enemy, we determine whether to fling her back to the left or to the right. Check out the to dos in the course code to turn our robot bodies into remorseless killing machines. If you experimented a lot with the knock back we added, you may have noticed that while being flung through the air you could still kind of control your movement left or right. You could either slow down or speed up, how fast you're flung away. Also, if you're so lucky as to be knocked back in such a way that you landed on a platform, you just slid right off it. Neither of those behaviors make much sense, so let's fix them. First, we need to set GigaGal's horizontal velocity to zero when she lands on a platform. There we go. Second, we need to add a new jump state called recoiling that disables the left and right controls while GigaGal is flying through the air after being hit by an enemy. Check out the to do's in the course code, first to make sure that GigaGal doesn't just slide off of platforms when she lands on them. And second to disable the arrow keys when GigaGal is flying through the air after being hit by an enemy. Are you having nightmares about the evil robots? You're helpless to do anything but watch them drift back and forth spreading their evil. Well in the next level, we'll fix that by letting GigaGal destroy the enemies with her arm cannon. And you know what that means. Lots and lots of explosions. Today we are canceling the robot apocalypse! First we need to activate GigaGal's arm cannon and make sure we clean up the bullets that fly off screen. Then we need to add in explosions when ever GigaGal scores a hit or destroys an enemy. Finally, ammo isn't free, so we need to add in ammo power ups for GigaGal to grab. Let's get started. As usual, let's set up and test the assets we'll need for the rest of this level. The bullet/plasma blast and the ammo power-up are both straight forward. The explosion animation will need to be set up just like giga gal's walking left and right animations. Check out the to-dos in the course code to get started. Let's set up our bullet class by giving our bullet a speed, direction, and position. Then we need to add a bullet collection to our level. Finally, let's test it by spawning bullets absolutely everywhere. Create your own bullet storm by creating the bullet class, adding a bullet collection to the level, and then spawning bullets all over the place. Now let's put the bullets under Giga Gal's control, adding a shoot button and making sure the bullets are spawned at both the right position, that is coming out of Giga Gal's cannon, and in the right direction, that is shooting left when Giga Gal is facing left and shooting right when she's facing right. Check out the to dos in the course code to let Giga gal fire her cannon. Right now, the bullets the GigaGal fires, just fly on forever. Hitting characters in the next game over or, more practically, eventually slowing the game down. Let's fix that by cleaning up the bullets and our plasma blasts that leave the screen. Check out the to do's in the course code. To clean up after ourselves and remove any bullets that are beyond the visible area of the screen. Time to make our bullets actually mean something by detecting when they hit an enemy. This will actually be simpler than detecting whether Giga Gal has hit an enemy. In this case, we'll just check to see whether the center of the bullet is within the radius of the enemy. We'll also add a health counter to the enemy and destroy them when they reach zero health. Follow the to dos in the course code to let Giga Gal actually destroy her nemeses. Let's make our hit detection a little bit more dramatic by allowing our level to create, manage, and dispose of explosions. Then we'll have our bullets create an explosion every time they hit an enemy, and have our enemy create an explosion when it dies. Check out the to-dos in the course code to make some stuff blow up. Power-ups are a classic game mechanic, easily recognized by anyone who has played a video game in the last, actually ever. Well, the first power-up was probably introduced back in 1980 with Pac-Man. And if there were power-ups in video games before that, I neither confirm nor deny that I'm old enough to have collected them. But anyway, a power-up is just an object that gives the player some ability or other benefit, like super speed, additional ammo, an extra life. You get the idea. Of course, it's up to you whether or not they appear in your game. What they do, how and when you let players collect them, and there are a lot of options. You can place them randomly or at spots you preselect. You can spawn them when an enemy dies or a puzzle is completed. You can make it so a player collects power-ups just by touching them. Or require some other, more involved process, like smashing a chest, or digging out a wall. There's certainly nothing that says you have to have power-ups in your game. But they really have stood the test of time. I think most game players would agree that they add something to the experience. One more thing for this level. Let's make sure GigaGal has to be at least a little careful with her cannon, by limiting her ammo and distributing ammo power-ups around the level. Whoops, looks like we're out of ammo. So we can pick up this power-up, and that'll give us just enough ammo to destroy the enemy. Follow the to-dos in the course code to add ammo power-ups for GigaGal. Wow, that was complicated. You think that blowing robots to smithereens would be the easiest thing in the world, right? Awesome work keeping track of GigaGal's bullets and myriad explosions and with that the core mechanics of GigaGal are complete. In the next two levels we'll add in the capabilities to load up a level from an external file. And then we'll add a ton of polish to the game rules, add a HUD, and mobile controls. Keep it up. Games are a team effort. You, the developer, are often working with a designer who decides how the game should work. It's then your job to bring their designs to life. Even when you're working alone, it's a good idea to keep these two jobs somewhat separate. Take your level design, for instance. You don't want to have to write Java and recompile your game every time you move a platform or add a new enemy. Ideally you'd like to use some external purpose built level-editing tool to create a level file, which can then be loaded by your game. And this level will do just that, using the Tiled level editor to create JSON level files, which will then turn into an actual level object in our game. Let's start by downloading Overlap 2D. Head over to overlap2d.com and hit the big download button. When the download is finished you'll probably want to put it somewhere other than your downloads folder. The desktop will work fine. Let's see what we've got here. Overlap 2D comes with some examples,some plug-ins and the executable jar that contains the application itself. You can double click on it to open it. If everything worked, you should see a screen like this. Go ahead and download Overlap 2D and check this box when you're up and running. Let's create a new project by going to File > New Project. We'll call the project GigaGalLevels. [BLANK_AUDIO] And we'll store it on the Desktop for now. This width and height is fine. And then, pixels per world unit, we actually want to set to one since we're using pixel art. We want one world unit equal one pixel in our art. This area is called the scene. It holds all the components of your level. A project, by default, comes with a single scene called main scene. Let's go ahead and create a new scene. And we'll call it level one. Now, let's import some resources. We want to navigate to our raw assets directory. And then, select all the sprites we need to build up our level. That will include the enemy, the first frame of the exit portal, the power up, GigGal standing right sprite, and the platform. We can find our newly imported resources in this resources pane. So, let's start laying out our level. Now remember, we have a kill plane at about -200. So, let's make sure that we place all of our platforms well above that. Actually, zero, zero is right here. So let's move up to the upper right quadrant. You can do that by holding space and then dragging the scene. So, let's drag a platform out from our resources into the level. Now, we have to do something a little bit weird to get overlap 2D to properly export the width and the height, and that is convert this from just a simple image into a nine patch. If we right-click on this platform, we can select convert to nine patch. And then, we can drag these guides to transform our image into a nine patch just like we did back in level one of this course. Can apply and save. And now, if we want a longer platform, we can just say width 200, and the platform will extend out just like we're used to. Let's add a few more platforms to the level. Now, one more thing. We'll add enemies to our level, but we're actually only using them as a visual marker. The way we're going to specify to our level loader that a platform should have an enemy on it, is using the platform identifier. So, we'll select this platform, go up to Identifier, and call this platform Enemy. Later, we'll read this in and know that we're supposed to spawn an enemy here. Set up a new overlap 2D project. Create a new scene within that project. Import our resources. And add some platforms to the scene, specifying that some of those platforms should have enemy spawned in on them. Let's add in the rest of the level elements. We'll need to add in GigaGal's spawn location. The location of the exit portal that ends the level. And, we'll drop in some ammo power ups to help GigaGal fight her way there. Build out the rest of the level by placing GigaGal, some ammo power ups and the exit portal. The first step in building out our level loader is parsing the raw JSON level data into a tree of java objects that we can interact with. To do that will be using the simple JSON library. Follow the to dos in the course code to import the raw level data. First things first, this is a platformer, so let's load up the platforms. While we're at it, we'll check the platform identifier and add in enemies on the platforms when it's appropriate. Check out the deducing the course code to read in the platform dimensions, add the platforms to the level and then add any necessary enemies as well. Before we can read the position of the exit portal from the level file, we should probably add the exit portal to our game in the first place. Check out the to do's in the course code. To add in the exit portal assets and awesome animation. Create the exit portal class, add a render function and then, add the exit portal to the level. Finally, finish up our level loader by loading GigaGal, the power ups, and the location of the exit portal. As you gain experience with game development, you may find yourself creating your own specialized tools, maybe more than you'd expect. Sometimes there's just no better way to convert a data file into the format you need or extract font data to create a custom texture. One tool you commonly have to write as a level editor which can sometimes grow into a full blown project of its own. If your game levels are big and complex, a custom level editor can end up saving time in the long run. And it makes it much easier to release new content to keep your game fresh. It also allows others to build levels for your game which can be a great way to engage your audience. It's still a good idea to represent your levels with human readable data files. Because they tend to be platform independent. And you also preserve the flexibility to make changes with a simple text editor. You might choose to use binary data files in production null to save space. And it's easy to add a binary export function. If you write a dedicated level editor. I always enjoyed writing tools and thought it was interesting how tool development kind of happens in reverse compared to the game itself. Tools are usually needed right away, so there's a flurry of coding activity up front. Games, on the other hand, tend to gel at the end, it's all the individual components come together. So, if you're creating a game, and the tools used to build it. Well, you're going to be very busy right from the start. Awesome work setting up level loading. Keeping your game data separate from your game mechanics allows you to breakup work so a whole team can contribute to your game. Next, let's tackle mobile controls and add a headup display. It's time for the final boss battle. It's up to you to package all of the awesome gameplay features of GigaGal into a polished cross-platform game. First, we need to add in a head-up display to keep track of GigaGal's ammo, score, and lives left. And we'll also need to set up a way to calculate a score. And we need to start keeping track of GigaGal lives. Finally we'll add in touch targets to allow mobile users to play GigaGal as well. Let's get after it. First, let's set up the infrastructure for drawing the various overlays we'll be creating in this level. Note that we'll need to set up a separate viewport for the HUD since the viewport that draws the level is jumping all over the place, whereas the viewport for the HUD always needs to stay in the same place. Check out the to-dos in the course code to get our overlay infrastructure set up, and to get some test text drawn. To put our overly infrastructure to work, let's start by displaying Giggi Gals' remaining ammo. Next, we'll start calculating a score based on how many times Giggi Gal hits enemies and how many enemies she destroys. Finally, we'll start keeping track of how many lives Giggi Gal has left, and add that to the HUD as well. Check out the to do's in the course code to make a helpful HUD. Gigagal, sure has been doing a lot of work. Jumping around, shooting, occasionally falling into the void. And when she gets to the level exit portal, nothing happens. Let's fix that by detecting when Gigagal has finished the level and adding a victory overlay. Check out the to-dos in the course code to celebrate Gigagal's success. If we're going to celebrate GigaGal's successes, we should also bring attention to her defeats. When GigaGal runs out of lives, let's display a nice, encouraging Game Over screen. Follow the to-dos in the course code to give the evil robots some appreciation when they manage to win a round. So far our ostensibly cross-platform game really only works on devices with keyboards, let's fix that by adding some on screen controls. Do one more asset round up, add one more overlay class and with a little drawing, we'll have the touch targets for our mobile controls up and running. Finally check out the to do's in the course code to wire up the mobile controls and get our mobile support up and running. Building little demos is fun and all, but building a real game is a whole different beast. It's like assembling a fine watch, there's so many moving pieces to keep track of, and integrate, and so many interactions have to be frictionless, lest the whole thing grind to a halt. And guess what? You've done it. You've brought Gigigal to life in all her platform jumping, cannon shooting, robot destroying glory. I can't wait to see how you choose to extend what we've built here. Will you add a level select screen, add new types of enemies, add different types of weapons maybe a boss battle? The possibilities are as endless as your imagination now that you've got the skills to bring your ideas to life.