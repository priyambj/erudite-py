Every object oriented language I can think of has a way to dynamically refer to the current object. In JavaScript we use the keyword, this. But as you and I both know, it can be pretty confusing at times. It doesn't always return the object you're expecting it to. I would actually go so far as to say the parameter, this, is easily the most widely misunderstood aspect of the language. But it's actually pretty easy to use. If you're thinking about it in the right way. So you'll notice I'm always very careful to refer to it as the parameter this. And that's because it behaves almost exactly like a normal parameter, with a couple of exceptions. Parameters are those words that we see between parenthesis in a function definition. So there's really just two major differences between a regular parameter and the parameter this. The first is, you don't get to pick the name for the perimeter this. It's always just going to be referred to as this. And the second is, you go about binding values to the perimeter this a bit differently from how you bind values to other perimeters. There's about five different ways, in fact, that you can do that and we're going to examine them all in an upcoming lesson. But before we do I'd like to just take a quick detour and look at the Dev Tools for a moment. To examine a scenario you might find yourself in where you could start to ask the question, what is the parameter this is going to be bound to in this case? Let's start by discussing what the keyword this is for. This is an identifier that gets a value bound to it, much like a variable. But instead of identifying the values explicitly in your code, this gets bound to the correct object automatically. Now mostly, the rules for how the interpreter determines the what the correct binding is, resemble the rules for positional function parameters. The differences between positional function parameters and the keyword this are designed to support your intuition about which object should be focal when you're invoking a method or a constructor. There are a lot of misconceptions out there. So, let's clear them up by going through a list of the things that the keyword this specifically won't be bound to In order to start asking the question, what does the key word this refer to, we really need a code example where the keyword this appears. Here we have it appearing inside a function which is generally how you are going to see it. So if you notice the keyword this appearing somewhere in a function, what would you imagine it is bound to? Lets go through a quick list of things that people frequently think it's bound to although it usual is not. So first of all you might see this function definition here. Highlight it in blue, and you know that when your interpreter hits it, it's going to create a function object in memory. You may then conclude that the keyword this should refer to that function object, but it doesn't. As a next step sometimes people conjecture that and instance of that function is created and the keyword this refers to it. Now, in certain circumstances that's true. But in order to really get on board with that definition, I would have to ask, what is it that you imagine a new instance of this function would be? I mean, strictly speaking, what is this object in your mind? Later on we're going to go on to examine how this could be considered true but it's actually rarely the case that you're going to see code that looks like this. So let's say, for the sake of argument. But this is basically an error, generally speaking. You might then think that in order for the keyword this to mean anything it must be in a function that is contained within some other object as a property. Here was have an object ob2. That has a method called method that stores a reference to that same function object, so that object creates an object in memory and maybe that in memory object, where the function is a property, would be the thing that the keyword this refers to. This is actually one of the most popular misconceptions. But it's also not the case. And we'll see why in just a minute. The easiest way to think about this, though, is what if that same function was a property of two different objects? It doesn't stand to reason that the keyword, this, would be forced to choose somehow between the two of them. Taking it a step further, we could then claim that the keyword this will appear inside a function. And that function must appear inside the curly braces of some object literal. Or some other form of defining a function. So that object literal that surrounds the function definition might create an in memory object and that could be what we're referring to when we say the keyword this. But this is also not correct. Lastly, we know we will eventually call this function, and as we pass values in to be bound to the positional parameters of the function, we could imagine that that invocation creates a set of bindings, or a scope. That scope must be modeled somewhere in memory. And maybe it's represented as an object where a maps to three in this case, and b maps to four. We would either call this an execution context, or a scope. But this is also not what the keyword this refers to. As we recall from our earlier conversation about scopes, it's not the case that JavaScript gives you any memory reference access to these constructs. So that's all of the things that the keyword this doesn't refer to. What is it that the keyword this will refer to? Going back to our example of calling a function, we notice that there's a dot to the left of this example. When you notice a dot to the left of a function invocation, meaning it was looked up as a property of an object, you can look to the left of that dot and see what object it was looked up upon. The object that a function is looked up upon when it's being invoked, that object is what the keyword, this, will be bound to. I'm giving you an approximate definition that is useful to get you out of 90% of situations, because of course, it may not be the case we use a dot to access this function. We may, for example, use brackets. And of course, in this example, it's also the case that, that object to the left of the dot is the very same one that it was defined originally to be a property of. The fact that it's defined up here is a coincidence. We could just as easily have called that same function as a property of a different object provided it's stored as a method of that second object as well. In any case, it's not true that the object you find a given function stored within will be what the keyword this refers to, nor is it the case that an object, a function, was originally defined with is going to be what the keyword this refers to. In fact, it has everything to do with that call time dot and the object that we find to the left of it. Let's zoom in a bit on this idea, and see how it plays out in a bit more detailed code example. Start by considering this function that takes two positional parameters and makes no mention of the keyword this at all. Looking at the code you see here, what do you expect to be bound to the second positional parameter named "two"? Fill in what you think it might be. Alright, that was a trick question. In fact, there is no binding for the second parameter or any positional parameters until this function gets called. We'll need to pass in some values in order to meaningfully discuss this question. So, let's make some here. Furthermore, I'm going to make the variable names reflect the color of the value that they store. At this point, now that we have some values, we can finally call the function, passing in a couple of the objects that we've made, so we can see how they're treated. Input parameters to a function only have bindings when that function is actually running. So only now that we have an example of invocation can we really meaningfully evaluate what we expect parameter two to be bound to. So what do you expect to be logged in this example? The answer is that the two objects we passed in, green and blue, are going to be logged in our output. These variables referred to those two objects? For a moment, they were given the names one and two. The green object, stored as green in the global scope, was given the name one inside this function scope for that one invocation. And the blue one was given the name two. Furthermore, we wouldn't expect those bindings to remain true across every single invocation of this function. If all of this seems completely obvious to you, then you're in a great position for understanding the parameter this. Because in JavaScript, the keyword this behaves like a parameter in most of the important ways. The intuitions that you've built up around how to pass values into a function and how they'll get bound to the arguments being passed in at call time, all those same intuitions will hold true for the parameter this. So let's keep track of the output that we're expecting to see by putting it in a code comment here to the right of the line they created. We're ready to investigate what would happen if our function referred to the parameter this inside the function body. If we pass this as an additional input parameter at the beginning of the logging function call, in this case, what should we expect to be logged and bound to the parameter this while the fn function is running? Go ahead and write out your answer. This is actually a trickier question than it seems to answer. So, I'd like to put it on hold for a moment. Before we dig into this particular function indication, it will help us to investigate the more common usage of the keyword this. Which is as a parameter of a method indication. To call this function as a method, we first need to add that function as a property of an object. In this case, we'll make it a property of the red object. Now, when I call the function, I can do it immediately after a dot access on that object. We already know what the positional parameters would be based on the earlier example. But what about the this identifier? What object will it refer to? The answer is red. In addition to the two parameters being passed between parentheses, which of course get bound to the input parameters, one and two. I'm now passing a third parameter by calling that function on the right side of a dot access for property look up. The value that appears on the left of that dot will automatically be given the name, this, inside of that function invocation. This behavior is useful if we plan on doing much object oriented programming, since there will usually be a relevant focal object for any given method call. And that object generally appears to the left of the dot when the method gets called. Notice that I frequently use the expression left of the dot to discuss the idea of finding a focal object during method indication. But this is just an expression that I use to keep things simple. But all the same rules would apply, if you used brackets instead of dots to get access to the method. Now that we've taken a sidetrack, the question from before is even more interesting. If there is no dot, then how can we determine what the parameter of this would be bound to? What do you suspect it might get bound to in this situation? Surprisingly, in this case, the answer is the global object. When you don't have a dot to help you pass a specific binding for the keyword this, JavaScript binds this by default to the global object. This can be seen as similar to the fact that JavaScript binds undefined to positional parameters when we call the function without enough inputs. So if we had passed no inputs in between these parentheses, we would expect one and two to be undefined. A similar line of reasoning leads us to the conclusion that the default object of global would be bound to this whenever we don't have a dot. The dot is the mechanism by which we pass in a binding for the keyword this. So without a dot, you could expect that some default value to get bound to the parameter this. But what if you wanted to call a function and it didn't happen to be stored as a property of the object that you want the parameter this to be bound to? So imagine this function looks great but the keyword this is supposed to refer to a specific object. And that specific object doesn't have this function as a property. There would be no way, in that situation, to address this function as the given object dot anything. If this isn't stored as a property, there's no key you can use on that object in order to access the function. Besides the left of the dot rule that we just described, there's actually another way for you to specify the value that you'd like the parameter this to get bound to. Let's make a copy of that previous line which had the effect of assigning global as the default binding for this, and we'll edit the line with an attempt to specify exactly what we'd like this function to bind the keyword this to. By using a function's .call method, we get to override the default binding to global and override the left of the dot rule. In this case, we'll pass in any value we want and it'll get bound to the keyword this. When using .call, we pass in one extra value at the beginning of the argument list. And that value will be bound to the parameter this. So what would happen if we used .call on a function that was also being accessed as a property? Here we're using .call to pass in this new yellow object, but that method was already found as a property of the red object. In this case the answer is yellow. The use of .call overrides the method access rules, so this will get bound to the yellow object. One of the most confusing things for a lot of people about the parameter, this is how it will get bound within functions when they get passed as call backs. Consider this example where we pass our function to setTimeout, which will call the function for us a second later. As you can see, we aren't providing any values that could be passed as arguments to our call back function fn. So it seems hard to imagine that this code will work as we want it to. Let's focus on those positional parameters first, since they seem a bit more intuitive. What do you expect they're going to be bound to? Hint. Remember that you can't tell what value a function's parameter will be bound to, until you look at the specific indication of that function. So we'll need to go looking for the indication of the fn function. Take a moment to write out your answer This was another trick question because looking at this code alone, it would be hard to answer the question of how our callback will get called since we can't see the function indication here. In order to answer this question, we actually need to look at either the source code or the documentation for setTimeout. Let's take a look at how setTimeout might be implemented if it was written natively in JavaScript and we could go read the file somewhere. We'll pretend for a moment that it's defined in a file somewhere called timers.js. What would you expect to see appearing in this file? I mean, first of all, there'd be a function definition where setTimeout is a variable defined and made to point at some function. That function would, of course, take two arguments, your callback and the number of milliseconds to wait before calling that callback. What would happen in the body of the function? Well, first of all, of course, somehow the system delays execution of your callback by a number of milliseconds. Note that if you understand how JavaScript's concurrency model works, you know this actually couldn't be done in native JavaScript, but it's still a useful example to imagine. The next thing that setTimeout would have to do is refer to your function and it would have to somehow invoke it. Here, we're finally able to ask ourselves the question, what values is setTimeout likely to pass along to your callback function? Since setTimeout has no way of knowing what values you wanted passed to your function, perhaps it would be forced to simply invoke it with no parameters at all. If that were the case, what would you expect to be shown in the last position of the log output? The answer is undefined. When no values are passed to a function in vacation, the parameters get bound to the values undefined. Naturally the next question is, what would you expect the parameter this to get bound to? In order to answer that we must recall the rule that we plan to use when deciding what the keyword this will refer to. Take a moment to try and restate the simplified rule that we'll be using to determine what value this gets bound to. The answer is that we're supposed to find call time, look for a dot, and look to the left of that dot. Given that rule, what line of code would you be looking at in order to determine the binding for the parameter this? As with determining the parameter bindings, we needed to look at the last line of the code in set timeout where cb gets invoked. Looking there, we would notice that there is no dot, and so the rule about our default case is being exercised. So lastly, we should make an effort to predict what we actually expect to get logged as the binding for the parameter this within our function. What do you expect will get logged? The answer is the global object. As with positional parameters, no value is supplied for the parameter this, since there is no property access being done to get access to this callback function. And this hypothetical version of setTimeout isn't being written to use some mechanism, like dot call Given how setTimeout works when passed a function reference, what would you expect to happen when you pass in a method that was first looked up as a property of an object? Notice that we're using dot notation to find the method at the moment we go looking for it, to pass it into setTimeout. Again, let's start by considering how we expect the positional parameters to work. As before, they're bound to undefined since no values were passed in in-between the parentheses on the line where we call the callback. Furthermore, the setTimeout function wasn't passed any of the color values that might have been passed to the callback. And so the body of setTimeout wouldn't have any way of knowing what values you wanted passed in. The next question is what will get bound to the parameter this. Hint, remember where we have to look to determine the binding for the parameter this. It isn't in the function definition nor is it where the function is looked up on the object. The important moment is where the function is actually invoked. Generally, people find it tempting to imagine that since we did a property lookup on the red object, perhaps that lookup event would have some bearing on the keyword this inside the function. But this moment is irrelevant since only the moment of call time influences how the parameter this will get bound. Just as in the previous example where we passed in fn instead of r.method, the last line of setTimeout is still a free function invocation and not a method invocation with a dot. Therefore, this would still be bound to its default value, the global object. The problem of losing parameter bindings is pretty widespread since any function like setTimeout that takes another function as a calback may actually call that function differently than you expected. Callback functions are inherently designed so that they will be invoked by the system you pass them to. Thus, you generally have very little control over what the bindings will be for the parameter of the functions that you passed in. For this reason, you need to be careful about all the parameter bindings, including the parameter this, whenever you pass a function as an input to another function. Despite the fact that you see an object on the left of the dot when you pass the function in, this object will not be passed along as the binding for the parameter this. When the system you passed it to eventually calls your Callback Function. One way to pass the callback without complicating the parameter binding situation is to pass a different function, one that doesn't receive any parameters at all, including this. Then you just make room in the body of that function for your custom code. And inside that area, you reference your method and then you can do the indication yourself, passing along whichever bindings you want for the parameter this. We talked a lot about the keyword this, where it appears within a function. And some value may have been passed in to be bound to it. But what would happen if we saw the keyword this appearing in the global scope, not inside the body of any functions at all? Taking a step back for a moment, we should first consider what we expect to happen when we access parameters outside of the function scope that they were defined within. What would we expect to happen with this attempt to log the one variable? Since the parameter one is only defined inside the function named fn, we would expect not to be able to refer to it in the global scope. So attempting to do so throws an error. With that reasoning in mind, we might expect the keyword this to be inaccessible from the global scope as well. Instead however, the language has historically been set up so that you can refer to this from the global scope. And doing so, gives you that default binding, which is to the global object. This is another confusing aspect of the language and luckily that behavior was removed in the more modern specifications of the language. Finally, I'd like to cover one last way that the parameter this gets a different sort of binding. The pattern we're about to see here is built to support mechanisms, we haven't explored yet and will look at in more detail in the lesson on pseudo-classical classes. In this situation, we're calling our function with the key word new before it. And that will have an effect on how the keyword this receives its binding. The positional parameters are, of course, unaffected by the keyword new. They get passed along in exactly the same way as they always are. But the binding for the keyword this is likely to surprise you. It's quite possible you've encountered discussions on the internet of how the keyword new works. And if so, you might take a moment to conjecture what you think the binding for this might be under these circumstances. For reasons that can only become clear after a much longer discussion of JavaScript class patterns, the keyword this will actually get bound to an entirely new object that gets created automatically in the background as a result of the keyword new having appeared. In support of certain object-oriented paradigms, another object will be generated every time you make a call to that function with the keyword new in front of it. So the keyword this makes it possible for it to build just one function object and use that as a method on a bunch of other objects. And every time we call the method, it'll have access to whatever object it's being called on. This can be really useful for conserving memory, and it's only possible because we have access to the parameter this. As JavaScript developers we frequently make use of closures which are a concept many people find confusing. Can you explain exactly how closures work? Sure. Put simply, every function should have access to all the variables from all the scopes that surround it. A closure is just any function that somehow remains available after those outer scopes have returned. Now that probably sounds at least a little confusing, but as we look back at our code we're going to see specific examples of how that plays out and how we can use closures in our program. Let's refactor that Saga code from earlier, and run a new version in our simulated interpreter. So here's a crazy idea. What if we could somehow keep a reference to each of the Saga functions that we create during the invocation of new Saga? And we could keep them around forever, such that they were available long after those new Saga calls had completed and returned. So which of these techniques do you think we could use to retain access to the Saga functions even after the new saga calls the created then had returned? Would it work to pass saga to setTimeout or return saga from the new saga function or save saga into some global variable? The answer is that all three techniques would work and could be used to allow us to save access to the saga function even after the newSaga function has returned. So let's try this, let's make a global variable called sagas that will store an array for us, and we'll use this array for storage of saga functions. Then all we would need in order to have permanent access to each of these saga functions is to push them into that global array. At that point, we could choose to access these functions, even outside the scope they were defined within. The invocation of those saga functions could actually happen after the newSaga function that created them was done running. So let's try moving these lines of code down here in between the two calls to newSaga just to see how it would work. Let's try running this code with our simulated interpreter again. So this first line of code will create an array and put it in a global variable called sagas. And this will be where we store each of the saga functions eventually. Then the line that assigns a new value to the hero variable will run and create some random string, in this case Boy, to store into the hero variable. NewSaga is yet another assignment so a function object gets placed into the newSaga variable. And we're ready to do a lookup of newSaga, find this function object, and invoke it because of those two parens. Invoking any function creates a new context, and that context is where all the lookups will start. So first we add another variable to that context, foil. Foil is randomly selected to be ran, and here's the interesting part. The sagas array is now stored in a global variable, which means calls to that push should have a lasting effect on it that persists even after newSaga has finished running. What do you think is going to be added into this saga's array as a result of this line? The answer is we will store a function object in that sagas array. >From the f to the end curly brace is the definition of a function object, and that is the value that we're pushing into the sagas array. A lexical scope is actually just characters of code that you find in a file somewhere. And that's not actually a value that can be stored anywhere in a variable or as an element of an array. An execution context is one of these boxes that we see pictured here wherein we find stored key value pairs. And fundamentally this is not something you can even have a reference to. And similarly it can't be stored in an array. There is no anonymous function being called here. The closest thing is this function object. But since there are no parens appearing after it, we will not be invoking an anonymous function. And, therefore, we won't be getting the result of an anonymous function. So watch the sagas array as we run this line of code. At this point, a new function has been added to the sagas array. And even though that function is being referenced by a variable in the global scope, the function itself has the blue type of scope access because it's fundamentally a blue function that originated inside that red function. So we've reached the big question. What do you think is going to happen when we try to run one of these blue saga functions that was created inside the red context but is now being accessed from the green context? Remember the red context that it was created in has already completed and returned. So any variables that are referenced by this blue function from the red context seem perhaps like they should be unavailable. So, when we invoke this saga sub zero function, a blue box should appear somewhere in our diagram. Based on your understanding of how these contexts work, where would you expect that blue box to appear? The answer is that the blue box should appear inside the red box, because the context for a function will always be created as a child of the context that it was defined within. A simple way to think about this is that the word foil should be allowed to appear inside the body of this function because it's a variable from the surrounding context. It wouldn't make sense if this blue box appeared in the green box, because that would mean it had no access to the foil variable. So a new context always gets created in the same context as its function was defined within. In this case, that was the red context. Moving along with our program, we see that we can add a deed variable to the local context and then we run a log on all three variables. In this case, what would you expect the output to be? In this case, based on the current context the look ups would yield Boy Eyes Rat. As usual, the look ups are pictured with yellow arrows. As we complete that function, the context moves back out to the global context and we run it again. Running it again creates a second blue context that is distinct from the first. The new deed variable is added to the new context and running the log function, the first line creates a new deed variable that is distinct from the first. And the log function should have a different behavior this time. What would you expect the output to be now? So we're about to run the newSaga function for a second time. And the important issue here is that we will create a brand new red context, which will be the home for a new foil variable and two new blue contexts. The other interesting thing here is that the sagas array is going to now have two different function objects in it as a result of the second call to .push. Let's examine the situation further by imagining that there were even more calls to the two different saga functions here before the end of the program. Running the first saga function again should work just like it did the other times we ran it even though we've created a second newSaga context. And as we can see as we run the code, running that inner sagas function creates a new blue sagas context inside the first red newSaga context. That's because we're running the first of those saga functions. The first of the saga functions was created in the first of the newSaga contexts. What do you expect the output to be this time? It should be Boy, Pins, Rat. The lookups starting from this yellow outline would find Boy and then Pins, Rat. We're at another interesting juncture because we're about to run our second sagas function for the first time. What do you think is going to happen when we do? As usual, it will create a new context for the function invocation. But that context will exist within the second of the two red contexts that were created from calling this red new saga function. Behavior will proceed as normally until we get to the line that does the logging. What do you expect the output will be? For the first time, we will access this ET binding for a foil variable. That's because this is the first time we've ever run the second of these two saga functions that exists within the second of the two new saga contexts And now for our final interesting question. Do we expect that there will be any change to the type of output we get from it now that we've already run the second sagas function once before? What do you think the output will be this time? In fact this is a bit of a trick question, because there's no way to know what the output will be until we generate a new blue context for the saga function. Until we do there will be no binding for a variable deed that's relevant to this last invocation of the sagas column. So none of these deeds will be relevant to the final output of this final function call. Let's see what randomly generated variable it does produce. When we called this saga function, which of these two red contexts do you expect the new blue context to appear within? The answer is the first one. Because we are running the first of the two saga functions, it'll appear inside the first of the two contexts generated for newSaga. Running this function operates just as we've seen before, but now that we reached the log line we can finally ask the question. What do we expect to be logged as a result? And there you have it. The final lookup yields nothing more interesting than the previous calls to the first of the saga functions. It's as if this second saga function had never been called, or at least it doesn't matter whether it has been called or not. The two operate so much in isolation that it is unimportant whether or not other calls to other functions from other contexts ever happened. Our last call to the saga functions has finished, the context jumps back out to the global context and you've finished everything there is to know about closures. I've found that really understanding what the interpreter is doing when it executes my code and understanding variable scope and closures, really helps me in writing concise applications that other developers can easily read through and understand. How can our students use these features to their advantage in writing their own code? Well, it should become much clearer when we get to later lessons, where we start writing functions that would turn objects with methods on them. Meaning, functions that are stored as properties of the object. But more generally, any time you see a function with an input parameter that's quite static. Meaning, you don't expect the parameter to take on a new value every time you call the function. That's an opportunity to re-factor your code, such that you store the value in a variable from an outer scope. Because of the way closures work, the inner function will always have access to the outer scope variable even after the outer function returns. Like I said, we are going to see plenty of examples of this in the upcoming lessons. In this section we'll go over the simplest possible implementation of a class, which is a powerful form of functions that can be used to manufacture fleets of similar objects. So, let's go one step further past the decorator pattern that we built up just now. Since the object we are decorating is a brand new empty object, it kind of seems like we could just ask the carlike function to just build it for us in the first place. That is where classes come in. The only difference between the decorator code that you see here and a class is that a class builds the object that it's going to augment, whereas a decorator accepts the object it's going to augment as an input. So if we move the object creation into the carlike function and remove the obj function parameter in favor of declaring a local variable, then we would have what's known as a class, and we would give it a different sort of name to reflect that fact. So a class is a construct that is capable of building a fleet of similar objects that all conform to roughly the same interface. It's conventional to name your class with a capitalized noun, almost like a proper noun for a category of things. The functions that produce these fleets of similar objects are called Constructor Functions. Because their job is to construct the objects that will qualify as members of the class. So to recap, the class is the notion of a category of things that you'd like to build and all of the entailed code that supports that category. Whereas the constructor is simply the function that you use to produce a new instance of that class. The objects that get returned from these instructor function invocations, those are called instances, instances of the class. So when we call a Constructor Function in order to create an instance, that operation is known as Instantiating. At this point, we've reached an example of the functional class pattern because we have a simple function that produces instances of the Car class. Now unfortunately, the basic form of the functional class pattern does result in duplicated method, as we saw with the earlier form of the decorator pattern. The line adding .move as a property of Car creates a brand new function every time we invoke the Car constructor function. Looking at the diagram again, you can see that every instance of the Car class has its own unique version of the move method. We may prefer instead, to have it be the case that one function object is shared across all Car objects to save memory. To avoid having so many duplicate versions of the move method, we'll need to move the code that defines the move method outside the body of the Car constructor function. In this way, the interpreter will only visit that code one time. And therefore, only build one such function to be shared across all the instances. Rather than building a new one every time we invoke a Car. But notice, if we have moved the definition of the move method outside of the body of the constructor, then this function should no longer have closure scope access to the obj variable. The obj variable's where we'll be storing the instance of the car. So if this is off limits, the move method won't work at all. How can we write this function such that all the instances of Car could make use of it, even though it won't have access to the closure scope that those instances were created in The answer is that the parameter This provides us the functionality we need to achieve that. The parameter This is going to treat the object found on the left of the data call time as a function input. And therefore, it will provide us a name that we can use to refer to that object. So now that we've factored our Move method to be outside of the body of the car function, what would you expect the parameter of this to refer to when we invoke .move on this last line? Of course, since Ben is on the left of the dot when we invoke move, the parameter of this will be bound to Ben. So, we've arrived at the functional class pattern with shared methods, or simply the functional shared pattern. But there's still some cleanup we will probably want to do before it's fully refactored. For one thing, we see that there are two places that we have to name the move method. Once when we build the function in the first place, and another time when we decide we want to assign it over onto every car object. So, if we found ourselves building more functions and assigning each one as a property of the object, we would have to name them in two different places. There'd be two lists of all of the methods that belong on cars. This is problematic because you could easily find yourself correctly editing one of the lists and forgetting to edit the other. Perhaps, there's some programmatic way that we could iterate across all of the methods that we want to include on every car object and add them on automatically as a result of them having been in a list somewhere. There isn't necessarily a way to iterate over the variables in a scope, and so we're going to have to think of something clever. Maybe we could store all the methods we plan on adding to cars in an object in the first place. That way, it's easy to iterate over the object programmatically and add them all in a single line At this point, adding a new method to the Car class is as easy as modifying one line of code and then it will automatically be available on the object. If you're not familiar with the syntax of extend, you should look up an implementation that's made available in one of the many open source libraries that build this for you. But know that it is not a native JavaScript function. So to keep our example simple, we're going to go back to the old version of the code that only have one method to add to every Car. Let's go back to our diagram. In these most recent edits, we have gone from having a move variable that stored a function object to instead having a methods variable that stores an object. And that object has a move property pointing to the same function. You could say that this is better, because the methods object is now capable of storing as many difficult methods as you want to have available on every Car instance. One problem I'm noticing with this code is that the name methods, doesn't seem to make it very clear that the methods object is affiliated in some way with the Car class. We could easily confuse it as being perhaps a method container for some other class. Furthermore, in the current code it's a global variable, which is something we should avoid. It'll be nice if the methods object was clearly encapsulated somehow along with the Car class function, such that the two of them were bundled up together nice and neat. But it's just as easy to store an object like this methods object, as a property of another object as it is to store it in the global variable. So, let's use the object features of the Car function to make room for the object that stores these methods. Instead of using a global variable called methods, we will instead put a property on the Car function called .methods A lot of people get tripped up at this point, because they've forgotten that functions are just specialized objects. But in addition to the fact that functions have the power of being invoked, functions are also capable of storing properties just like any other object. Looking at the diagram again, you can imagine that the function object that is referred to by the variable Car might have a dot methods property pointing to the object that we're using to store all of our Car methods. It might be easier to reason about if you imagined that the Car variable stored an object instead of a function. >From this perspective, it's easy to imagine how the dot methods property could be a property of the Car object. But I would like to remind you of how similar a function is to a regular object. In that, it's allowed to have properties just like any other object. It is also important to point out that there is no interaction between the properties of a function and what you expect to happen when you invoke that function. The invocation of the function only makes the lines inside the body execute. Invoking a function has no interaction with any of the properties of that function. Now you might be tempted to imagine that because we've added a property to the Car function. Some interesting mechanism is going to be engaged or some rules about how functions work will start to become active. But there aren't any interesting rules that will become active as a result of the fact that we added a .methods property to the Car function. This is just simple property access, like we've always done. But this time, it's for the purpose of decluttering the methods object out of the global scope. All we've done is moved our methods object out of the global scope. And there's nothing special about Car.methods. Other than that, it's conveniently tucked away as a property of Car. So, we've seen that functions are extremely important in JavaScript and they create the core of JavaScript classes. As you described earlier, a JavaScript class is really just a function that's capable of creating many similar objects. Exactly. Anytime a function produces objects that all conform to roughly the same Interface of methods and properties. I would call that function a class, but it is important to know that this definition draws some controversy, because there are good arguments out there, that classes really shouldn't be boiled down so simply. In other languages, this is certainly the case, but in JavaScript at least I think that this definition provides us the most value. So, if we do broaden our definition of the word class, to mean any construct that's capable of producing a fleet of very similar objects. We should really examine every technique we can think of, that will satisfy writing, such a class. We'll do this by starting with our decorator code that we just wrote, and refactoring it into the functional class pattern. And from there, we'll move on to the prototypal and pseudo-classical patterns. And along the way, we can talk about the pros and cons of each technique. When writing software, code reuse is the practice of writing generalized code that can be relied upon to address a variety of similar goals. Whenever you notice that two parts of your code have similarities, there's an opportunity to factor out the similar aspects of it in to some reusable library code. So that you won't have to repeat yourself in either of the two original places So we want to dive in a little deeper on this idea of code reuse. And in order to do so, we should really define what we mean when we say code reuse. Well, when you're writing software, reuse of code is the practice of writing generalized code that can be relied upon to address a variety of different goals. Now, whenever you notice that two parts of your code have similarities, there's an opportunity to factor out the similar aspects of it into some reusable library code so that you won't have to repeat yourself in either of the two original places. So here's an example we can use to think about code reuse. Imagine you wanted to write a simple game that involves cars driving along a street. The player is on the run from a crime syndicate and has to avoid their goons, who drive around in these unmarked vans. Our program is going to need to keep track of a lot of data about each of the entities moving around the system, and so we'll use object-oriented techniques a lot here. Now that we know what we're shooting for, let's put these mockups away and focus on the code that we're going to write. So here's a file in sublime, where we're going to put some of the code for our game. I'm going to save this as run.js. Maybe we'll call the game run. So where should we start our program? Let's add some cars to the program, which we can represent using values that are stored in variable. So if we call the first enemy driver in this game amy, then we might make a variable for her car that we would give that same name. In that variable, we'll store an object to represent amy's car. As you add lines of code to your program, you'll expect a different in-memory model to be built up by your program as it's running. So here, I'm going to build a diagram that you can see what I believe the in-memory model should be as a result of the code that I'm writing. You'll see that in this diagram, we have a box, which is a global variable. And it points to some in-memory value. Now these two boxes are extremely different in that one of them, represents the idea of a variable and the other represents the idea of an in-memory object. Variables are allowed to point to objects and that's why this arrow extends from the variable to the object. To keep track of how far along the street amy's car is, her object should include a location property. And that property will point to some number reflecting her position. Now the number is an object to, just like nearly every value in JavaScript is. Here you can see the amy object, the object stored in the variable amy has a property .loc, which is pointing to yet another object. That object is itself, representative of the number 1. Now somewhere, your program might try to move that car further along the street. And even though the code for a real game would be more complex than this, we can show that change on just one line in order to keep our example simple. Now since there are many enemies in this game, there will be some point down the line where you'll probably find yourself building a second object and then you'll repeat a lot of the same code that you did already for the first car object. Now of course, the sample code that we see here in run.js is ridiculously oversimplified. But it gives us just enough of an example that we can start to demonstrate the techniques for improving it. So we should be asking ourselves the question. What parts of this code are repeated and might be good to move out into some area of reusable code. So just take a moment to look at this code and ask yourself, which parts you'd like to factor out. I see two of them. I see that we're repeatedly building objects that look pretty similar and I see that we are then incrementing the location property of those objects. I'm going to focus on the second of them. Let's take a look at how we would use a function in order to remove this code duplication of incrementing the location property So, at this point, what I want to do is open a second text buffer, a second file, which I'm going to save as Library. And, the idea with this is, I want to write code that's going to make it simpler for me to write this code later down the line. I want to write some generalized code that I can consume here in the consumption case, such that when I want to increment the location of any car object, I can use the code that's written here, that's supposed to be general and useful across many situations. I'm going to start by writing a function, then I'm going to edit it, so that it's capable of moving a car input object for us. So now, by simply calling that function on our two car objects, we have the same effect as we had before, but without typing out the incrementation logic each time. So now, we don't just have these two car objects being stored in amy and ben, we have yet another variable, storing yet another object. And, this object happens to be a function object. That function object is what operates on these two simple car objects and modifies their .loc property. At this point, it would be very reasonable to wonder what we've actually improved. It really seems as though there is more code in total here than there was a minute ago, and the lines that call, the helper function, are just as long as the ones that they replaced. There are two important differences that I can think of as to why it's valuable to factor repeated code like that out into a function. Take a moment to decide any reasons you can think of that would be compelling for doing such a thing. Let me show you one example of why it might be a good reason to do this. Basically, it's rarely the case that any piece of logic is so simple as what we see here, and you probably don't want to retype it over and over. So what if our code instead said this? Obviously, I would not want to type all of this code everytime I intended to move a car around. And, by abstracting it out into a function, it makes it much simpler for me to just issue the intent that I have and have that result in all of the changes that are appropriate. But an even more important reason is to improve your experience of refactoring your code down the line. If you decide you want to change how cars in the program are supposed to move, then there is only one part of this code that you will need to edit. It will just happen correctly in both of the places where you called that function. Imagine you wanted to alter the way in which your cars move around the program, and you added an equation like this, which happens to be nonsense, but let's say, you had something meaningful you wanted to put in there. If all the movement logic was in one place like this, you can be confident after you've edited this function that you've made all the changes you need in order for your program to start working correctly. So let's think about what other repeated code can be factored out here. Even though it's a tiny piece of logic, the code that adds a .loc property to a new car object is being written twice here. How do you think we could go about factoring that out? Well, we can use the same technique we did of writing a function that does work for us over and over again. Now, I'm going to give this function the name carlike. Since it's job is to augment an object with the properties needed to be considered a car. Now it's true that in this oversimplified example, the function we're going to be writing will do almost nothing. Since car seems to be pretty simple, they really only have a .loc property on them. But in a real program, objects have a lot more properties. So this carlike function should be made to take some car object as an input, then do some work on it and then return it. And when we call it on our car objects, we expect it to add this .loc property for us. As such, we'll need a pass the location value into carlike so that it knows what to set the car's location to. When a function like this one, takes in an object as it's input and then augments that object with some properties or functionality. The carlike function here would qualify as a decorator. It's common to use adjectives as the names for your decorator functions, hence the name carlike So notice back in our diagram that the object that has the dot loc property, each of these car objects in our program has not been generated from whole cloth anymore. We passed it through a decorator function. And when it came back out, it was given the dot loc property, pointing to whatever value it has. Decorators can add more than just simple properties like this number. Remember, functions are properties too. Maybe we'd prefer to call the Move Function using method calling syntax, which means we would look it up as a property of Amy before invoking it on Amy. If we want to do this, we're going to have to re-factor our code again. So take a moment to re-factor this code in a way that would enable us to use this method calling syntax with dot access To provide access to this function via dot notation on Amy and Ben we'll add a move property to each car as it's being built. But notice the function that we're adding there is no longer being used in such a way that it takes a first argument. Instead we will see that the target object is going to appear on the left of the dot when the function is invoked. Luckily, JavaScript supports the automatically bound parameter this. Which will refer to the object on the left of the call time dot. Rather than providing an input variable as a name for that argument, we can use the parameter this. It's very important to observe that there's exactly one of these move functions in existence. And it is being pointed to by the move property of multiple different cars in addition to the global variable. So what object do you expect the parameter this in the move function to be bound to when this last line of code is executed? The answer is that the parameter this in the move function is going to be bound to ben because ben is on the left of the dot at call time. It's worth doing a quick recap of how we expect the parameter this to behave. Again, it's almost exactly like an input parameter. But rather than being bound to the value that is supplied between the parens, it's bound to the value that's on the left of the dotted call time. So this function is going to log first ob1 and then ob2. Here are the call time parens and this is the binding for the first positional parameter. And here we have the call time dot and the binding for the parameter this. Back in our example, these are the call time parens. There's nothing being passed in and bound to positional parameters and here we have the call time dot and the binding for the parameter this Now that the move function is available on every single car and has been rewritten to use the keyword this. It's somewhat hard to imagine a use for storing it in the global variable, like move. Let's take the code for that method out of this area in the global scope and move it right into the decorator function. Take a moment to refactor this library function. So that the move method's code exists within the carlike decorator. Our code now feels a little easier to read because previously the move function was stored outside the carlike function. And it was at a different level of indentation, even though it was a property of the object eventually, just like the loc property is. At this point all the code related to the obj that gets returned is at the same level of indentation. But take a look at how this changes our diagram. In the old version, we had only one function object because it had been defined outside of the carlike function. Now, as a result of the fact that we moved the source code for that move method up into the body of the carlike function, we now have a new function being generated every time we run the carlike function. This is a high price to pay for the simplicity of having all of your code show up at the same level of indentation inside the body of the carlike function. People are often confused why it would be the case that moving the function definition up into the body of this function would result in there being many move methods, many different function objects, one per instance of a car. Let's open a new file to examine that point. This simple maker function builds and returns a brand new object. So after calling makeAnObject twice and storing each of the results in a variable, do you expect the two objects that are stored in these two variables to be the exact same or to be two objects that look quite similar because of the similarities in their properties. Another way of asking this is would they pass a strict comparison of their identity using triple equals? The answer is that even though the same exact line of code was used to generate the two different objects, they are themselves different objects. Changes you make to one object will not have any effect on the other object because they have different identities. They are as different as two real world identical twins. Identical twins look the same, but certainly each one has its own identity. The two objects even start out by having all the same properties, but no matter how similar they are in structure they will always be two different objects their whole life. Okay, that was easy. But what if the maker function had returned a function object instead of a plain object? Would you expect the two results to be the exact same function object or would they be two different objects. They would not have the same identity. Just like in the previous version of the code, which generated two different plane objects, this new code will generate different function objects every time makeAnObject gets run. So for all the same reasons, every time the interpreter visits the middle line of the carlike decorator, a new function will be generated as that car's .move method. Depending on how many cars we make, this could take up a lot of memory. But there's a slight advantage to putting the .move method inside the body of the carlike decorator function. Now that the .move function is being created every time, each one has access to a unique closure scope created when we invoke the carlike function, thus, we don't need to rely on the keyword, this, anymore. So refactor this code for me. Try to make it work such that the move method does not even refer to the parameter, this. It accomplishes all the same thing but without using the keyword, this. Instead of referring to the parameter this, which gets bound to a new value every time move is invoked, we could instead refer to the closure variable obj. Each time we call the Car like function, a new closure scope is created and therefore the obj variable will always refer to exactly one Car object Great job. At this point we're completely done with our exploration of different versions of the object decorator pattern. Generally, you would use the decorator pattern to add some functionality to an object that already had some functionality in it at that point. But our example is so simple that we just find ourselves passing in an empty object to the carlike decorator. So now that we've got this functional shared version of the code, we're ready to make a change that might improve performance a bit. Remembering back to how prototype chains work, can you think of some way we might improve performance by using prototype chains to achieve the same thing that this code achieves? As a reminder the way prototypes work is any object can be made to delegate its failed property lookups to another object. So, for example in this situation, if Ben lacks a property it's going to delegate any failed lookups for that property to Ben's prototype object Well, one option is, instead of using extend to copy all of the methods over, we might be able to use the prototype object to store all the shared methods and make our instances delegate to that shared prototype object. Looking back at our code, here is how we would expect that to play out. We might build amy and ben such that they delegated to Car.methods rather than copying all of the Car.methods properties onto amy and ben here when they're stored in the obj variable. That way when we go looking for amy.move, even though the amy object doesn't have its own .move property, we'll delegate that lookup to the Car.methods object which does have a move property. Let's see how that looks in practice. The problem here is we're using an object literal, these two curly braces, in order to build the brand new object, that's going to be an instance of car and whatever you use in object literal to create an object, you don't get to define what the prototype of that new object is going to be. So we're going to have to switch it up and use our other technique for creating objects, which is object.create that technique does allow us to set the prototype of the new object. Now whatever we put in here, in between these parenthesis, is going to be the thing that our new object delegates to. So what object do you expect we're going to need to pass to object.create in order to set up the right delegation relationship for every new instance of car. Note we aren't done refactoring the rest of the code yet, but before I move on I do want to get this line right. The answer is if we use car dot methods as the prototype for new instance, then fell property look ups to those instances, we'll fall through to car do methods. And thus every instance will appear to have a .move method. Even if we don't manually copy them over on this line. That means, we can get rid of this line entirely. We do still need to make sure this load property gets added to our new object, since it's no longer in line as part of an object literal. We're instead using this object that creates syntax. As of this change, we've arrived at the completed prototypal pattern of writing your class. This is not to be confused with the pseudo-classical pattern, which is coming up next. Notice how things change in our diagram. Whereas previously, we were copying all the properties from Car.methods, over to the new instance objects. Now, we're simply going to make those new instance objects, delegate their failed lookups to Car.methods. This is an important shift in that it allows us, to skip an expensive step of copying properties over, when we build a new object. It's interesting to note that if Netscape hadn't pushed for adding Javaesque keywords and features to the language way back in 1995, we might have been writing code very much like this for all of our JavaScript classes. The steps for making the class in this prototypal pattern are pretty clear. All you need is a function that allows you to make instances, a line in that function that generates the new instance object, a delegation from the new object to some prototype object, and some logic for augmenting the object with properties that make it unique from all the other objects of the same class. Since this pattern is so common, the language designer decided to add official conventions to support it. You see how we're making the methods objects here, and adding it as a property of the Car function object? If we plan to use prototypes for all of our classes, we'll probably be doing this every time. Since building a holder object for methods and attaching it as a property to the constructor function is so common, the language does this for you automatically. Whenever a function is created, it'll have an object attached to it, that you can use as a container for methods just in case you plan on using that function, to build instances of a class. The crazy thing is, this occasionally handy property, the one the language is going to build for you, is not stored at the key.method. Although we had chosen to store our handy method container object at the key.methods. The default object that comes with every function, is stored at the key.prototype. It's just a naming choice, but it has been a very confusing naming choice throughout the history of the language, and I'll explain why. But first let's refactor our code to make use of the fact that we're given this free, .prototype property, where we can store all of our methods. Since I know this object is going to be created for me, and all I really need to do is add a move method, I can take out the object literal. And all I really need to do, is define this .move method on an existing .prototype object. But Car.methods doesn't exist anymore, so we need to refactor the rest of our code to reflect the use, of the provided container object, which is now stored at Car.prototype. Right here in our diagram, you can see that the only interesting aspect of what has changed is that this function object is not storing the methods container object at the key.methods, instead, it's being stored at the key.prototype. People tend to get very, very tripped up at this point because they start to imagine that this .prototype property has some special rules about it that will influence how this code ought to work. But in truth, nothing interesting has changed. The only thing that's different is we've chosen to use a different name to talk about that storage object where we're putting all of the methods. And perhaps it's slightly interesting that the language provided that object for us, but that object does not have any unique or interesting aspect about it that we've discussed so far. So, to reiterate just once more. Using the key .prototype here, instead of the key .method is purely cosmetic. Don't get confused thinking about the possible effects that this might have on the in-memory model at runtime, since there really aren't any. Here's some examples of associations, you might be making in your mind that would mislead you. First of all, the Car function does not delegate it's failed lookups to the objects stored at Car.prototype. There is no such thing as car.move, for example. We never imagined that Car would delegate it's failed lookups to car.methods and so, we shouldn't expect that car would delegate it's failed lookups to Car.prototype. Another point is that result object from the Car function. Only delegate to Car.prototype because of our own call to this Object.create function. It's not because we're using the key .prototype to store this object that we have a relationship between instances and the Car.prototype object. So you should really see this .prototype object as a freely provided object for storing things with no additional special characteristics. Mentally, you can substitute the word .methods if it helps you reason about it. To underscore my point, observe that this Example function has the exact same relationship with the Car.prototype object that the Car function does. Both functions return objects that are set up to delegate to the object stored at Car.prototype. The fact that the prototype object is stored as a property of only one of those two function is completely immaterial. Both functions behave exactly the same as they would, if that prototype object had been merely stored in some global variable. Historically, the fact that this property is called dot prototype, has been very confusing for people learning JavaScript. By using this word to describe the methods container object, that's available on every function, JavaScript introduces an ambiguous 2nd meaning for the word prototype. So if someone says, object ones prototype is object two, a reasonable interpretation would be to think that field lookups on this first object should fall through to the second one. So, you might say Amy's prototype is car dot prototype, but this is not the relationship that car has with car dot prototype. In that case, car is a function object and field lookups on it will fall through to some function prototype, where all function objects their field lookups. The car functions relationship with car-dot-prototype is very different from the one that Amy has with car-dot-prototype. This other relationship reflects the second interpretation of the statement, "object one's prototype is object two". The relationship is that when a car function runs, it will create objects that delegate their field lookups to car dot prototype. So in this sense, you might say, cars prototype is car dot prototype. So to review, saying Amy's prototype is car dot prototype means something very different from saying cars prototype is car dot prototype even though those sentences look so similar. We can leave this discussion behind, but be aware that it's extremely easy to conflate these two uses of the word prototype, and it's well worth investing extra thought in ironing out exactly what the differences between the two uses are. I left one thing out when I said that the dot prototype objects that come for free on functions were just as uninteresting as any other new object that we could use for storing methods. In fact, these prototype objects come with one extra convenience property that almost no other object has. Every dot prototype object has a .constructor property which points back to the function it came attached to. Thus, there is a mutual linking between any new function and it's companion dot prototype object, because car links to dot prototype object, and prototype links back to the car object. Car dot prototype dot constructor is car itself. The main use for this feature is so that you can figure out which constructor function built a certain object. All instances of a class delegate their failed lookups to their prototype, and so they should all report as having the same constructor function. What do you think would be logged as Amy's constructor property? In this case, Amy delegates the failed lookup for a .constructor property to Car.prototype which does has that property. So Amy's .constructor property is reported as being Car. Furthermore, the instanceof operator works by checking to see if the right operand's .prototype object can be found anywhere in the left operand's prototype chain. Here, Car.prototype can be found somewhere in amy's prototype chain. With that in mind, let's peek at some functional class code again for a moment. What would you expect to be logged in this case? The answer is if we're writing in the functional style, the instanceof operator won't work. In this case, fido is a simple object that was created with an object literal, sSo it just delegates to object.prototype. Dog.prototype can't be found anywhere in fido's prototype chain. Interestingly, we're not going to talk about a version of the prototypal pattern that does not involve shared methods. When we were talking about decorators and when we were talking about the functional class pattern, we examined the technique of using shared methods or using methods that were defined in line in the body of the constructor. But the prototypal pattern really does not lend itself well to the same examination. Why do you think that might be? As I see it, function sharing via a prototype delegation is the very goal of the prototypal pattern. If methods were defined inside the constructor there really wouldn't be any reason to delegate the instances to any prototype at all. And that's it for prototypal classes. With all of this background information behind us it's going to be very easy to understand the pseudoclassical pattern. Prototype chains are a mechanism for making objects that resemble other objects. When you want two objects to have all the same properties, either to save memory or to avoid code duplication, you might decide to copy every property over from one object to another. But as an alternative, JavaScript provides the option of prototype chains. This makes one object behave as if it has all the properties of the other object, by delegating the failed lookups from the first object to the second one. Let's build up some objects that have a lot of similarities so that we can see how prototype chains might help us. On the right here, I'll show a picture of the objects that we're creating as we go and the relationships that they developed. Here we have a property lookup on the gold object. Let's consider every step of what happens when we do a property lookup for the key a in this object. The interpreter kicks off an investigation as to whether or not the gold object has the property we're looking for. Upon inspecting the object, the interpreter could tell that there is a pair available in this object that has the key a. The value that's associated with that pair is 1. And so the result of this lookup expression is going to be 1. In this case, our logging system would log value 1 out to the screen somewhere. My code assumes that there's some function called Log that already exists. In most environments, you would call it console.log. But, let's take a look at what happens when we ask for a property that we know the object doesn't have. First, that property lookup arrives at the object. And then the interpreter acknowledges the failure by providing undefined in response to this attempted lookup for z. And, so the lookup for z on the gold object, results in undefined which is what ultimately gets logged to the screen. Now, let's imagine that this program needed an object that bears a resemblance to this gold one that we already made. To achieve this, perhaps we could start by building a new object and giving it all the same values stored at all the same keys. We'll make a new object called blue and we'll start making it look exactly like the gold object by copying the properties over one at a time. Incidentally, there are helper functions out there that can help you copy all of the properties from one object onto another. It doesn't come with the language, but you could imagine doing the exact same thing with a simple foreloop. This arrow represents the process of copying over each of the properties from the gold object to the blue object. Now, although the effect of this copy operation on the blue object will last indefinitely. It's important to remember that the copying happens just at one moment during the program's execution. It is not an ongoing copying back and forth behavior that keeps the two objects in sync. In this case, there's only one property in our gold object, so the copying process is quite simple. The copying process is now complete and won't be repeated. So if our program later goes on to modify gold or blue, we'd probably only expect them to have the a property in common after those modifications. Let's try adding a new property to the blue object. Now of course, when we go to do a lookup on a property that got copied onto the blue object, we get the value we'd expect. Which was originally copied over from gold. And it's no different for the property that was added manually by our code. As with the gold object, a lookup for a property that isn't available on blue should result in undefined. Let's make another replica of the gold object, this time using a different strategy to achieve that similarity. Rather than copying the properties over one by one, the idea would be to give the rose object some linkage to the gold object. Such that whenever a requested property can't be found on rose, it uses gold as sort of a fall back source of properties. The Object.create function can create objects for you that have this delegation lookup feature. Just pass in your desired fall back object. And it produces a new object, the delegates failed lookups to the fallback. You can still interact with this special new object in the same way you would any other regular object. But when you ask that object for a property that can't be found directly on the object itself, it does something rather interesting. The lookup falls through, up the chain to the prototype object. So what do you think will get logged in this situation? The answer is 1. Since the prototype object does have the property, the lookup ultimately succeeds. It falls through rose and then is satisfied on the gold object. And passed out as if the rose object had the property the whole time. Notice that the apparent similarity between rose and gold is achieved at the very moment of lookup and not as a result of some earlier copying process. For properties that can be found directly on the lower object, the prototype chain is never consulted. Since the key b can be found directly within rose, this isn't considered a failed lookup. And so, the prototype relationship just doesn't come into play in this case. As usual, completely absent properties are reported as missing. What do you think will be logged in this situation? In this case z is not found on rows, it falls through to gold where it is also not found, and in the end, it evaluates to undefined. Let's investigate the main difference between these two techniques. That difference relates to what moment you would expect the value present on gold to influence either of the other two objects. Is that moment a single moment of copying or does it happen at every look up event? Modifying the gold object, reveals an interesting difference between these 2 techniques. Here, we're adding a new Z property to the gold object. What do you think happens when we try to log that new value 3 by asking blue for its Z property? The answer is undefined. When we try to log a new property by consulting blue, no property is found there and since no delegation relationship exists, it can't look anywhere else for other properties. The copy operation was one time. So, the relationship between gold and blue was over immediately. All that remains of those cloning efforts is this A property that we copied some time ago. But, what do you think will happen when we log the Z property of the rose object? The answer is 3. When we go looking for a z property on the rose object the failed lookup results in a fall through lookup to the prototype object. And the new value appears to be available on this other style of doppelganger rose. Let's take everything away except our picture of the prototype relationship between these two objects and consider this relationship just on its own. If this behavior was useful to us for making the rose object capable of resembling the gold object, are there other objects in JavaScript that might make use of this mechanism? For example, does gold delegate its own failed lookup somewhere? In fact it does. There is a top level object that every JavaScript object eventually delegates to. This is where all the basic methods are provided for all objects. We call it the object prototype because it provides the shared properties of all objects in the entire system. That way, when you ask an object for its dot two string property, you get access to a function that can do the appropriate work. Once you've access the function, you can immediately call it. And the object that you did the property look up on will appear to the left of the dot at that functions call time. Thanks to the way that the parameter this works, the shared function will work as expected, with the this keyword bound to the rose object, even though the .toString method was technically stored way up on the object prototype A number of other useful helper methods are available there too. And it's a good idea to look up the documentation about each of them. One of the most useful properties is .constructor, which makes it easy to tell what function was used to create a certain object. Like all properties, .constructor actually points to a different object that's stored elsewhere. People frequently confuse the object prototype with this constructor function used to make all objects. So let's visualize the two in different boxes for a moment as a reminder of the way it's really laid out inside your computer. Whenever you ask an object about its .constructor property, the object most likely doesn't have a local .constructor property, so the prototype chain gets consulted. The .constructor property on the object prototype points to the constructor function for making object and so that object is provided as the result. If you don't take any special steps, most new objects that you create will delegate to the Object prototype, but some of the special objects that you can make in JavaScript have extra features above and beyond the basic characteristics of all objects. Arrays, for example, have methods like .indexOf and .slice. Those array methods are stored in another prototype called the Array prototype. Since arrays behave a little differently from objects, the Array prototype even has its own version of some of the standard methods like toString. The Array prototype in turn delegates to the Object prototype so that the non-unique parts of an array can be inherited from the Object prototype. And not every single method will need to be reimplemented here on the Array prototype. Notice that the Array prototype and Object prototype both have dot constructor properties even though one delegates to the other. So what do you expect to happen when you query an array for its dot constructor property? The result will be the array constructor since the array prototype has a dot constructor property and won't need to delegate any further up the prototype chain in order to find it. So that's pretty much it for prototype chains. You should be able to use them to make objects that look very similar to other objects. Which is a useful technique for code sharing and for saving memory. Now that we've got this pure prototypal version of the car class, let's refactor it into the very closely related pattern known as pseudo-classical. The pattern we're about to build is called pseudo-classical because it attempts to resemble the class systems from other languages by adding a thin layer of syntactic conveniences. If we plan on making a lot of classes in our programs, and we do, there's a lot of code here that would get repetitive to repeat every time. Perhaps the language could do more of these steps automatically somehow. Which lines here seem likely to show up in every class you write and maybe seem like the language could provide some mechanism for doing automatically for you? These two lines look likely to be repeated in every prototypal class. After all, a prototypal class needs some object that it can operate on and then, it needs to make sure that, that object delegates to some prototype object and lastly, of course, it needs to return that object. So we can expect that all of these operations are going to happen in every single prototypal class. To alleviate all of that typing, JavaScript provides the keyword new. Whenever we choose to use the keyword new in front of a function invocation, our function is going to run in a special mode called Constructor Mode. In that mode, we can expect a lot of this work to be done for us automatically. So what is Construction Mode exactly? Basically, it's a way for your interpreter to insert a few lines of operations into your code because it knows that you're going to need them to be done whenever you're instantiating a new object. It temporarily makes your function run as if there was some extra code at the beginning and end. Even though you will never have typed that code. The operations it's going to insert are basically doing the same work as the lines you're likely to write in your prototypal classes. So because we're using the key word new here, we can expect this invocation of car to run with these extra operations inserted at the beginning and at the end. Whereas here, where the key word new does not show up in front of the invocation of car, these lines of code would not be inserted. So in the same program, we can expect this one function to be run with and without these inserted lines of code. Remember, they will never actually show up in the code as you type it. They only get run as a result of the fact that we are using the keyword new right before this particular invocation. Now even though I'm showing two different lines of code, one with and one without the keyword new, you would never do such a thing in your own programs. You're going to write functions that you expect to be run with the keyword new, or not run with it. But you would never write a function that you may or may not use the keyword new with. The purpose of it is to allow you to skip some of the work you're already doing. So, once you decide to use the keyword new with a given function, there's some inevitable refactoring you're going to have to do. I've added the keyword new to both cases, and I think it's time we delete some of the code we don't need anymore, since we know this is how we intend to run the function Let's look at this first line and what it's going to do for us. It's going to create an object that delegates the car.prototype which is what we're already doing. That means we can get rid of the part where we were doing that ourselves. It also seems to be assigning the result of that object creation to the keyword this. Now, even though you couldn't possibly write this line of code in your own programs, the interpreter is capable of finding values to the keyword this. It kind of makes sense and is in keeping with our understanding of what the keyword this is used for. The intention of the keyword this is to be a convenient way of referring to whatever the target object is in some object oriented function call. This function call is pretty object oriented. The intent is that we're going to build a new thing. So it makes a lot of sense that whatever that new thing is could be the target of the keyword this. Now that we have a way of referring to a brand-new object that's created to delegate to the car prototype, we might as well get rid of all of these new obj variables that we introduced. We can just instead use the keyword this. Lastly, we can tell that this return statement that will be inserted by the interpreter seems to duplicate what's being done above in the line that we wrote. It's unnecessary to have two return statements, and, in fact, the way this code would operate, we should never be able to reach the last line since the second to last line would already have returned from the function. We can get rid of the return statement that we wrote, as well, and just trust that this inserted return statement will do the work we need. We're done refactoring to avoid the duplication between the code we had written and the code that got inserted for us. But remember, this code is just a mental note to remind us what the keyword new does. So let's get rid of those notes because we know they are not actually going to show up anywhere in our program. Let's take away the extra white space so that we can see it written more clearly. This is what we would expect to type when we're making a pseudo classical class. If you look at the diagram of the object relationships. You'll notice that it hasn't changed, since the prototypal version of our code. And that's because the pseudo-classical version is really just a thin layer of syntactic convenience over top of the prototypal pattern. In fact, the primary difference between these two patterns is the number of performance optimizations that the JavaScript engines have implemented, that only apply when you're using the pseudo-classical pattern. Let's take a moment to meditate on the fact that this code, like many class patterns in Java Script, has two distinct and very different sections. This will be true of every pseudo classical, prototypal, and functional shared class that you write. One section, you will find specifying how all the instances of a class should be similar. In the case of the pseudo classical pattern, these similarities are generally stored as properties of the prototype object. In the other section, you'll be writing code that specifies how each instance should be different from all the other instances. As with most programming languages, this will take place inside the body of the Constructor Function, and it'll allow us to specify how one instance of the class will be different from another instance of the class. All of the work that gets done to specify that Amy and Ben have unique locations is done inside that Constructor Function. For now, this is just an interesting observation about classes, but knowing that these two categories of code exist for every class will become very important later when we start to discuss subclassing. Looking back at the functional version of this class for a moment, it's also interesting to notice that functional classes without shared methods make no such distinction. In this style, all the code for both categories appears in one place. The similarities and the differences across instances appear here, indented two spaces inside the car function. Depending on your perspective, you could call this an asset or a failing of the functional pattern. When people learn that JavaScript supports so many different class patterns, they frequently wonder which one they should be using or which one is best and sadly there just isn't an answer to this question. As a language, JavaScript takes remarkably few stances and tends to make the internal features visibly available to the programmer to play with. So rather than rights and wrongs their really only techniques and options. What we can do though is discuss the advantages and disadvantages of the different techniques to help inform the decisions that we will make about which patterns to use on a case by case basis. Subclassing was really easy when we were using the functional pattern here. But let's explore how we might do this if we were using the pseudo-classical pattern for our base class. How do we go about writing pseudo-classical subclasses? For practice, let's start this program from scratch. It'll be good to build up the program one line at a time, anyway. Since the pseudo-classical code we're about to write is going to look so different from the functional code we already wrote. Furthermore, let's use some different sample code in our run.js file. It'll be easier to think about this if we're only instantiating one instance of the superclass and one instance of one of the subclasses. So just like before, Van is a subclass of Car. Amy is an instance of van, and this new zed object will be an instance of a car. We won't examine the cop class here, or any instantiation of it, because we only need to see one example of a subclass to make the point. By reading this first line of code, I can tell that I'm going to need a car function to make instances of cars and it'll take an input to use as a location for the new car. Inside the Car function we will do the work that is specific to one instance of a car. In this case, adding a property that should be different across all cars. But what about that move property that Car instances like zed appear to need? Take a moment to decide where you think you would add that functionality for this pseudo-classical Car class. Edit the car class so that it exhibits the move function that we remember from before. Of course, we could simply add code that puts a new function property on every single new instance as the constructor is running, but this would mean we are creating a lot more function objects than necessary. Let's use the power of prototype chains to save memory. Recall that in the pseudo-classical pattern, any properties that you want shared across all instances go on the .prototype property of the constructor function. At this point, we are done writing our super class in the pseudo classical pattern, and instances of car should work as expected. But now, we need to move on to making our sub classes work. We start by writing a constructor function for the van sub class. So here we are building up a new subclass in memory. And that subclass is supposed to derive a lot of its behavior from the superclass Car. What code do you think we should put insider the Van function? Give it a shot. Hint: it's going to involve the loc input variable. I'm going to take a moment getting around to the answer to this question, because there is so many different mistakes one can make right here. Let's explore some of the incorrect options before we arrive at the right answer. A simple idea might be to repeat the code that we saw in the car function right here in the Van subclass constructor. Since there's so little of it. Notice this would have the effect of creating a loc property on every instance. And that loc property would point to the number in question. But that's not exactly what we want if it forces us to repeat the same code in two different places. But this poses a few issues. For one, if you ever change how instantiation works, you would have to remember to change both places. Furthermore, you can tell that the logic here is quite simple, but that's just for the purpose of our example. In most classes, there's going to be a lot more code in a super class constructor. You would have to repeat in the subclass. So we have a bit of a puzzle on our hands. We'd really like to simply run the Car function in the middle of the Van function. But in such a way that it modifies the new van instance that's being created. You might suppose we could simply call car the way you normally do with the keyword new in front of it. But this is problematic for a couple of reasons. What would you expect the effect of this technique to be on your in-memory model? Take a moment to imagine how this code would play out when it's actually running. For reference, here is the in memory model that we're starting to build up. The answer is that if we tried to call the Car function with the keyword new, it's going to have the effect of creating another new instance object, in addition to the one that got created in Rhonda JS, as a result of calling new van. Let's explore this a bit further. The code within the body of the Car function operates on some object referred to as this. What object do you think will be referred to within Car after being called with the keyword new inside Van? The answer is that it would refer to a brand new instance of the Car class, since Car is being invoked with the key word new. Recall that the effect of running any function with the keyword new is that that functions runs as if it had a bit of extra code in it. Particularly, it's going to set the keyword this to equal some brand newly created object. And just because we ran the Van function with the keyword new and created another different object, does not mean that the other function is going to run with that same object as it's context. These are two different object.create statments that are being inserted into two different functions as a result of two different appearances of the keyword new. In the diagram this would mean that any time you run the Van function with or without the key word new, it would have the effect of building a brand new object, that delegates to the constructor of the car class. If your running the Van function with the key word new to begin with, then you've already got a brand new object and you don't need a second one. Sometimes people try to solve this by assigning the result of the new Car invocation, this object that gets created during the Car constructor, assigning to the local keyword this. But only is it disallowed to assign to the keyword this at all in your own code, even thought the interpreter is allowed to do such things, it doesn't solve the fact that you wind up having two different object, one of which you would be apparently throwing away. So this solution just doesn't work. Simple enough. What if we were to call the Car function without the keyword new? Perhaps that would have the effect of simply running the Car function in the context that we wanted. Unfortunately, this doesn't work either. In this situation, what would you expect the keyword this from within the Car function to be referring to as a result of being evoked on this line? The answer is that the Car function would run in the context of the global scope because this Car function is being invoked as a free function invocation. . You would actually wind up with a global loc variable pointing to the number 9 and your Van instance would be completely unaffected by any code within the Car function. So, if we're going to run the Car function we just to make sure that it runs in the right context. Luckily, we have a way of running functions in whatever context we choose. The .call method of any function allows us to run that function in exactly the context we want it to. It basically means that the parameter this is going to behave even more similarly to a positional function parameter. Now we just have to decide what value to pass as our first argument so that Car can run in the right context. What do you think we should pass in? Well the answer is, we want to call this Car function in the same context as the new Van instance that's been created right there. Since that's being stored in the parameter this, we can just pass this along and run the Car function in the same context as the Van function is being called. We can get rid of this pretend line of code because it was only there to remind us what was going to take place as a result of using the keyword new. This is exactly how we want to call the Car function from within the Van function such that it operates on the right context. But people seem to find this line of code extremely confusing. So let's take a look at it for a moment. The goal of this line is to invoke the Car function such that it's parameter this, is bound to the Van instance and to do that, we are also going to have to use the keyword, this, inside the Van function since it's bound to the right object in there. At the heart of this confusion is the fact that there are two different parameters. In two different scopes, both of which are given the name this. But we must keep in mind that the parameter this behaves just like other positional parameters to functions. For example, it's probably not confusing that the loc variable from inside Van is being passed along as the first argument to Car, where it's coincidentally given the same name. Even though the two variables share the same name. We think of them as different, because they're in different scopes. The shared name is incidental and this line merely passes along the binding from one function to another. The same is true of the parameter this. It's just being passed in a bit different way. To underscore this point let's consider a snippet from a totally separate naf library. The double function calls the product function passing along its x variable to the product function wherein it's going to be given the name a. That example is uncontroversial but what if we were to use the same argument name in both functions. How would you expect that to effect how our code runs. In fact, there's no change to how these two functions would behave. The new example would seem almost as uncontroversial as the previous one. Even though both functions have an input named num, it's clear that those names are coincidental. The code behaves the same as if they were actually named differently. Since the two variables are in different scopes. Interestingly, the situation is almost exactly the same when we pass along the value 3 to be bound to the parameter this. If we use the same binding to the parameter this in our above function call, we have ourselves the same situation. Where two different parameters, in two different scopes, happen to share a name and again, we're just invoking the function a little differently so that we're allowed to bind the value to the parameter this. So it seems as though the Van function has a correctly implemented line that allows it to call out to the Car function. With that in mind, would you expect the lookup for amy.loc on this line to work correctly? The answer is yes. We've wired everything up correctly such that Van calls Car. In such a way that new objects like Amy get the location property attached to them. With that in mind, would you expect this look up for amy.move to execute correctly? Remember, amy.move is made available on car instances a little bit differently from how the loc property is. The answer is no. In its current state, the code will break when it hits the line calling amy.move. That's because the move method is only available on Car.prototype and the amy object doesn't delegate to Car.prototype. If any delegates to Van.prototype, than what does Van.prototype itself delegate to? Van.prototype delegates to Object.protype which means that amy doesn't have any relationship at all with Car.prototype. And so, amy won't have any of these methods available just because they're made available on Car.prototype. Remember the video about pseudo-classical classing, where I pointed out that there were two different categories of code going on in the Car class. This is the exact moment where that distinction becomes extremely interesting. So far, we've made it so that the differentiation code in the subclass will call out the differentiation code available in the superclass. But due to the fact we're using prototype chains to implement an inheritance, we also need to wire up the subclass prototype to the superclass prototype, to allow the similarity code to be inherited as well. Amy does delegate Van.prototype, but neither amy nor Van.prototype have any relationship with Car.prototype yet. In order to set up that relationship, we want to make it so that Van.prototype delegates to Car.prototype. This is how we are going to make the shared methods available from Car onto Van. If we succeed, then a lookup to amy.move will fall through the amy object, and up to the van prototype, which will fail. And finally, fall all the way through to the Car prototype. Ideally, we would be able to update Van.prototype such that it would delegate it's failed lookups to Car.prototype. In memory, we would expect it to work rather like this. The Van.prototype object should be made to delegate all the way up to the Car.prototype object. In this way, it would be very similar to car instances, because both would delegate failed lookups to the Car prototype property. But this actually isn't allowed in the official version of the language. Instead, we're going to have to overwrite the originally provided prototype object with the brand new object that we create. So what object exactly do we want to be assigning in place of the old Van.prototype object? It might surprise you that pseudo-classical subclasses will work just fine after a reassignment like this. And that's because the instance delegation is set up only when the constructor actually runs. This prototype replacement happens right alongside the constructor definition and so that's plenty of time before we actually instantiate any objects. People often propose that Van.prototype could simply be made to equal Car.prototype. But remember, JavaScript doesn't do any copying when you assign one variable or property to be equal to another one. If that was the case, then it would be impossible to add any methods to the Car prototype that weren't also on the Van prototype and vice versa. So adding a Van.prototype.grab would have the effect of modifying Car.prototype to also have a .grab method. In short, we definitely don't want our Van.prototype to be the exact same object in memory as the Car.prototype object. So instead of making Van.prototype equal the same exact object as Car.prototype, how can we make sure that the Van prototype will delegate its failed lookups to Car.prototype? Fill in the code for yourself. The answer is to use Object.create. If we want Van.prototype to be an object that delegates to Car.prototype we only need to pass it into the Object.create function and generate a new object that delegates there. By setting up vm.prototype to delegate to car.prototype, failed lookups on van instances like Amy, will fall all the way through to car.prototype when necessary, to find methods that are shared there. Another common mistake is to try and make an object that delegates directly to the superclass constructor function itself. Creating an object that delegates to car, instead of an object that delegates to car.prototype, won't work, because car instances themselves are supposed to delegate to car.prototype. This is an example of a much larger problem that you should be aware of. People are forever tempted to conflate a constructor function and it's companion prototype object. But the two serve very different purposes. Perhaps the most common mistake, is attempting to instantiate the superclass constructor as a method of creating something that delegates to its prototype. This has a nearly identical effect, with the sole exception that it runs the car function in the process of creating this new object, which is undesirable. The object.create function is actually a rather new language feature, and before the community knew too much about it, common practice prescribed setting van.prototype to equal a new car instance. But this causes a number of problems. Notice that if we use this technique, every time we made a car subclass like van, or any other subclass of car, we would invoke car, the function, as part of that process. The superclass constructor may also require some arguments as part of it's invocation, like loc. But we don't have any way of passing them in, because the new car prototype doesn't really have a meaningful location. The only thing that has a meaningful location is a car instance or a van instance. The abstract notion of all vans does not have a meaningful location. Since there's nothing useful we could pass in for the loc input variable, the function will run with all of it's inputs being bound to undefined. Imagine we were doing something with those inputs, like this dot access. What do you think would happen in the case where we tried dot access while having passed nothing in particular in between the parens on new car? The answer is that the constructor would throw an error message because loc would be set to undefined and trying to do .access on any undefined or null value throws an error. It's hard to write a constructor function that is robust against this kind of misuse. And we don't actually need to. Object.create sets up the prototype delegation that we need to just like new, but without running the constructor function in the process. Be careful though. Due to a long misunderstanding of JavaScript, this technique has been widely accepted and standardized on for many years. You'll see a lot of misguided documentation out there on reputable sites that endorses this broken pattern. So the Object.create technique seems to be the only that doesn't have adverse side effects. Finally, we need to make the grab method available on all Van instances without making that method available on any of the Car instances that are not Vans. As usual, we will add the properties that we want to be available on all instances of a class to the prototype object that is stored as a property on the constructor function. And it seems like we'd be all done, but there's one thing missing that belongs right here. Can you think of anything that we might of undermined, as a result of the fact that we overrode the prototype object with a brand new object we created? Looking at the diagram for a moment. Remember, that this object that we placed at the key.prototype on our Van function, replaced an object that came for free with the Van function. So is there anything you can remember about the original object that was special and important and might need to be put back? Actually, the object that got replaced had an important property on it that you might recall. Remember that each one of those objects that comes for free with a function at the key .prototype has a property on it called .constructor. And that seems to have gone missing when we threw away the original object and replaced it with our own So with the code the way it is, what do you think would happen if we tried to log what Amy's .constructor property stored? Surprisingly, the answer is the car would be logged. Let's examine why. The amy object doesn't have a local dot constructor property, but amy does delegate the van dot prototype. Van dot prototype is a brand new object that has been set up to delegate the Car dot.prototype. That brand new object does not have its own dot constructor property, much like any object coming out of Object dot create should not. At best, it is an object that delegates to an object that has its own dot constructor property. Car dot prototype has a dot constructor property because every single dot prototype object that comes for free with the function when it's created is given one of these dot constructor properties pointing back to the original function Since this object is not one of the objects that comes for free with a function, it does not have it's own .constructor property. And this lookup would fail and fall through twice, all the way to car.prototype. So since car.prototype.contructor is car, amy.constructor is also car. What code could you write to resolve this issue? It's as simple as adding a correctly linked .constructor property to that prototype object. Now, lookups for .constructor property would fall through from amy and stop when they hit Van.prototype. They'll report the right constructor because Van.prototype.constructor has been set to equal Van. And that is for Pseudo-classical subclasses. Congratulations. At this point, if you've been following through these chapters, you've learned a lot of different code reuse patterns, including functions, decorators, and all the major class patterns provided natively by JavaScript, as well as their corresponding subclassing techniques Congratulations. At this point you've learned about the most important and difficult language features in JavaScript, including scopes, closures, the keyword this and prototype chains. You also learned a lot of different code reuse patterns that are built on top of those features, such as function decorators and all of the major classing and subclassing patterns that are available within JavaScript. Good luck applying them throughout the rest of your Frogger project. Hi, I'm Markus Philips. I'm the Dean and Co-Founder of Hack Reactor an immersion school for software engineering in San Francisco. We developed an outcome driven and data driven approach to education called Rapid Iteration Teaching. I like to think of myself as the educational equivalent of Brad Pitt in Money Ball, but it may be more accurate to compare me to Joanna Hill. Before founding Hack Reactor, I led technical training initiatives at Twitter, worked on their back-end anti-spam systems and led the front-end framework team. I left Twitter at the end of 2012 to start Hack Reactor and the rest is history. Every second counts during an immersive program and our team has put a ton of thought into the materials that you'll be seeing here. This course covers the first four days of Hack Reactors 12 week curriculum. So you'll be getting a taste of the hyper fast learning that leads our students to a 99% placement rate. I consider these lessons the most important fundamental material you can have under your belt, before moving towards employment in any JavaScript stack. So whether you're new to JavaScript programming or you've already found it confusing for years. Together, we're going to find out just how clear and easy it can be when you approach it the right way. So we're going to start off by talking about scopes and closures. Since you really need to fully understand those aspects of functions and variable access before we can move on to more advanced topics of object-oriented programming. Then we'll discuss the parameter this and prototype delegation, which are the two main language features allowing for object-oriented JavaScript. Finally, we'll cover a number of different ways that you can write JavaScript classes and subclasses. By the end of this, you'll have a strong understanding of JavaScript's object-oriented features and how the code you write impacts the interpreters in memory model as your code is executing. To help us investigate scopes, let's write a program that helps us build zany sagas full of random words. Each call that we make to a function in this program, should help us string together a new combination of nouns and verbs, adding one more sentence in an ongoing saga about a hero. Once we start the program, all the stories will be about this same hero that was randomly selected for us. Each saga about this hero will feature a different randomly selected foil character. The program will call functions such that we string together a new combination of nouns and verbs, adding one more sentence to this ongoing saga. And that's it, it's a simple little program, let's see how we could implement it using the feature of Scopes in JavaScript. There's a number of different ways people use the word scope and first, I want to explore the simplest of them. The first use of the word scope is lexical scope. This usage of the word describes the regions in your source code, where you can refer to a variable by name without getting access errors. The specific rules for this version of scoping can be understood even without running your code, since it only concerns the area of your code where different variable names will have meaning. Imagine this file held the source code for a very simple program. In simple programs with no functions at all, there is exactly one scope which is called the global scope. Every variable in such a program would be stored there. We represent the global scope in these slides using the color green. Now in some JavaScript environments, global scope is shared across different files as a way for any part of the program to interact with any other part. If we add a variable to the program, that variable is to be said to be within the global scope and thus it could be accessed from anywhere else in your whole program. Now we want this program to help us generate stories that are all about the same hero. So let's put this hero variable into the global scope where every other line of code can reference it. Also for the sake of this example, we should pretend that there exists a function called aHero and that function returns a randomly generated name. We won't be investigating the source code or the run behavior of that function during this talk. After defining a variable in a lexical scope, you may make reference to that variable from anywhere else in that lexical scope. Global variables are the easiest, since there's nowhere in your code that you couldn't access them A new lexical scope is created every time you type out a function definition. The function definition spans from the letter f all the way down to this end curly brace. The two curly braces around the function's body enclosed the area of the code where different access rules will apply. Let's color in all the area between these braces to represent the region that will have new rules, and that we would thus consider a different lexical scope. Once you've made a new lexical scope by defining a function, it has a few more limits then the lexical scope around it. Although you can still access variables from the broader lexical scope containing that interlexical scope, and you can access variables that get defined inside that inner scope, the variables that you find in the inner scope can not be referred to from outside that scope. Outside these curly braces referring to a variable that was local to the inner scope will result in an error. So, what variables do you think would be available from within the body of the new saga function? That is to say what variables could you access in between these two curly braces. The answer is that all three variables are available inside the body of the newSaga function. The newSaga function is the tightest scoped function available and so it has access to all the outer functions. Note, to make matters slightly more confusing, JavaScript allows you to assign to variables you've never even declared before. In this example I took the var statement off of this assignment operation. So foil has not been declared anywhere in our whole program. When you do this kind of assignment, variables that you're assigning to for the first time will be added automatically to the global scope, and not to whatever scope you did the assignment in. This is actually a pretty bad practice because leaving the var keyword off is more often done by accident than on purpose. Even if you do purposefully decide that you want to do this, it'll be very confusing for other people reading your code and they'll probably assume you just made a mistake. Also note, that unlike a lot of other languages, not all curly braces in Java Script are relevant for scoping. Blocks on if statements or while statements and other looping constructs like that, do not create new scopes. Only the curly braces that you find on a function statement creates a scope. Scoping limitations are actually very useful. They allow us to think about less of our program all at once. So we don't want to subvert them by leaving off var declarations. So for now, just remember to declare every variable with a var keyword in whichever lexical scope you want that variable to live. So it seems like variables are being accessed correctly now in accordance with the rules of lexical scoping. But our program needs to actually call the new saga function in order for it to do anything useful. So let's call that function twice so that we can see two different sagas playing out. We also need to make sure that the inner function gets called. So let's do that twice as well. Meaning each saga will consist of two sentences. We're done listing out the lexical scopes in this program. We've seen how to differentiate one lexical scope from another, and we've learned the rules that govern them. It's time to talk about a somewhat different idea relating to a different usage of the word scope. When a program runs, it builds up storage systems for holding the variables and their values. These in-memory scope structures are called execution contexts. Execution contexts or in memory scopes differ from lexical scopes. In that, they are built as the code runs, not as it's typed. The rules govern which variables a program has access to at different points during the execution. Let's explore how variables will be available at runtime within in different contexts. As the program runs, it will be building up internal data stores for keeping track of all the variables that are available to different function objects. And I'm going to picture that stuff over here on the right. This will be a diagram or a picture of our in-memory system. Since each new run of a function is supposed to operate in complete isolation from all the previous runs, a new execution context should be created every time you run a function. Thus, for each lexical scope there may be many in-memory scopes created during execution, or there may be none. It all depends on how many times you run a given function in your code. To examine execution contexts, we'll need to actually run this program. So let's simulate that here. The yellow arrow will point to the position in the code where our simulated interpreter has reached, sort of like a debugger. Before this first line of code even runs, the interpreter will start out by setting up an execution environment for you. The first step will be to create an in-memory global scope context to hold all of the global variables. So let's visualize that execution context data store off to the right here. We'll use a similar color as the lexical scope region that it relates to. Here, our interpreter is building up a storage system for the global scope. The yellow border is around the interpreter's current execution context. That is to say, whichever one the interpreter starts its variable lookups in. So far, the global context is the only one that exists. So of course, it's the current scope. As the first line of code runs, the interpreter builds up a new key value mapping inside of the execution context, in order to keep track of the value that is bound to the name, hero. The aHero function randomly generated the value Gal, which will be stored in the hero variable. Like the line above it, this line implies a simple assignment operation. Now the value being assigned is a function that spans several lines. But the interpreter's going to ignore all the red and the blue code for now. They will only get run when the function is actually called. So, that line of code has the effect of adding a new key value pair to our global scope context. At this point, the execution context looks a lot like a collection of key value pairs, sort of like an object. Now noticing that similarity, it would be tempting to think that in memory scopes. And in memory objects are somehow actually the same thing. This is a deceptive similarity, since the two are kept so completely separate by the interpreter. And there are so many limits on your access to an execution context that don't exist to your access to an object. Many of the rules that we've learned about objects will also happen to be true for execution contexts, but you can never mix and match the two in your programs. Despite all of the similarities, they live in completely different worlds that almost never interact. Just as a few examples, you will never be able to store an array full of contexts, even though you can do so with objects. You can't iterate over the variable names in an execution context, the way you would over the keys in an object. So even though they are both key value data storage constructs, you're going to be interacting with the two in completely different ways. Moving on to the next line in our code, we see that running the newSaga () ; function should have the effect of creating a new execution context, so that it can make room for new variables that are local to that function column. Then, the new context will become the interpreter's new current context, for as long as that function is running. This first line will add a new variable to the current scope. The next line adds another variable to the red scope, this time holding a function value. At this point, we'll have to do a lookup on the saga variable, In order to know which function these parens are attempting to call. The interpreter handles this by checking whether the name saga has any meaning in its current context; the red context. The interpreter checks the scope of the current execution context, and finds that the saga variable is available locally in that red scope. The value found there is a function object. And the parens next to the word saga, tell the interpreter to invoke that function. Running the saga function will build a new execution context, and move the interpreter's lookup focus into it. The first line adds a new variable to that local scope, and now we do lookups on all three of our variables. Again, the interpreter will do this, by scanning outward from its current context, looking for the closest containing context that can satisfy a requested name. First it goes looking for hero, which can't be found in the containing context, and so it falls through. Falling through to the red context, the interpreter does not find a hero variable there either. Finally, falling all the way through to the global context, the variable is found there. The string being logged is beginning to get built up. Next, it goes looking for the deed variable. What will be the output of that lookup? Finding deed turns out to be easier for the interpreter than finding hero was. And the interpreter finds it locally without needing to consider any of the fall-through scopes. Lastly, the interpreter does a look-up for foil, which falls out of the local scope, but is found in the middle scope. Note that we're showing this fall through all in one step, but it requires a scan of the blue context, just as before. The interpreter is done with look-ups, and it sends the full concatenated string as output to the log in system. This was also the last line of the function, so the interpreter can jump back out to where that function was called and resume processing from there. Along with it, the focal context will shift out to what it was before the red context. Up until this point, the picture of the in memory contexts on the right has shaped up to look really similar to the picture of the lexical scope on the left. The only difference so far has been that there are actual values visible here, and in our code, of course, there are none. But both of them show one blue scope inside one red scope, inside one green scope. So what's the difference between in memory scopes and lexical ones? This starts to become clearer when saga runs for the second time. The process we just went through will repeat. But running Saga a second time will create totally new execution context instead of referencing the original blue context. This accommodates for storage of different bindings. As ever, the interpreter's lookup focus will also shift into the newly created content. The var declaration creates a new variable in this context. And if you like to think about the storage layout that languages use for your data, you could say that this variable is stored in a new distinct location from the first one. Now while this isn't necessarily the case, it's likely true and it's a useful way to think about it. What values do you expect to be logged by this line, given the current in memory conditions The variable lookups start from the current context, bordered in yellow, and scan out from there to any parent context forming the phrase GalTipsCow. With the blue function complete, the interpreter jumps back out to where that function was called and the current context moves out as well. Furthermore, this was all part of the first call to newSaga, which is now completed. Running the red newSaga function a second time would result in drafting a new separate red context, which itself contained two new blue contexts. Almost all the exact same steps would occur. And although they would each happen one at a time, let's picture them all popping up at once, so that we can see them without having to run the entire simulation one line at a time. Notice that the values found in these new contexts will be entirely different and it's actually stored in an entirely newSaga variable. Although the second saga function was created by the same lines of code that created the first one, the two would fail a triple equals test that compared them. Creating two equivalent looking functions, but have different identities, is exactly like what happens when you see an array literal appearing within a function definition. Calling that function twice creates two different array objects. And so, this line would log the value false because the two array objects do not pass a triple equals comparison. The same would be true of these two function objects, because they were created by the same lines of code in two different invocations of the newSaga function. What two strings do you think would be logged as a result of this second call to the newSaga function? The answer is that all the new values will be used during the lookups for the log function. Which results in logs of these new strings and new phrases. We now know a great deal about all three class patterns, functional, prototypal and pseudo-classical. Let's move on to thinking about the slightly more advanced code-sharing technique of subclassing. After that, we'll explore how we could achieve these same goals using a pseudo-classical pattern. Note that the pseudo-classical pattern is a lot more widely documented on the internet than the functional pattern that we're about to explore here. So, external resources may be confusing until after you've completed the section after this one. A class works great when you want to produce a fleet of similar objects as with the target code in this run.js example. But what if you wanted a second category of objects that was vaguely similar to this Car category? Maybe you decide that in addition to enemy vans, your game also needs cop cars that can be called to the player's aid. So you decide that cops would behave pretty similarly to vans, but they'd have a few important differences. You'd probably need to refactor this code so that the cops can behave a little bit differently. So imagine cal is going to be one of these cops. The cal object ought to have all the same vehicular powers as the other two cars did. What function could you use to build this object? So far we've really only discussed the similarities between regular cars and cop cars, and not any differences. So if our program was actually that simple, we wouldn't really need to differentiate. Both regular cars and cop cars just have a location and the ability to move. In that case, we could simply use our car function to build the new cop car cal. But as soon as we write any code that relies on the differences that exist between a regular car and a cop car, then we have a bit of a problem. We can't really add a cal method to every car instance because we don't really think that non-cop cars deserve that method. One naive solution would be to copy all of the code from the car class into a second class and then re-factor it. We'd probably give the two functions different names to reflect that they are different classes. Then in each function, we would add the code that would make that particular class different from the other. In this case, imagine that the grab method is something only vans should be able to do because it's the way in which the van is going to be able to attack the player. By contrast, this cal method is something that's only available to cops. Because it represents the way in which the player can get access to help from a cop. In this scenario we would have two different constructor functions that both produced objects that were basically identical with the exception of this new method, either grab or cal. This solution works. But as you can see, there's a lot of duplicated code here. Let's look for a solution that allows us to reuse that code, rather than type it twice What if we make a function that does all of that work up front and then we just let the Van and the Cop class do a tiny bit of customization for whatever is left to make them different from regular cars. We would call this new function we're building a superclass. That term includes the word class, because this function will be creating a lot of similar objects and it includes the word super, because these other classes will use the output from the superclass as their starting point. Let's name the function Car, since it's going to be creating objects that have the generic moving behavior. And then Van and Cop will be even more specific versions of it. Which parts of Van and Cop do you think could be moved up into the body of the Car constructor function? Well, for one thing, the creation of the object and adding a loc property seems like something we could do up in the Car constructor. Where we used to have object creation, we can simply call the Car function now and it'll produce an object that can act as the starting point for the rest of the subclass. Technically, we have a working superclass at this point, but there's still more repeated code that we should be able to move into it. Let's take the code for the addition of a move method out of those subclass constructors and move it up here into the superclass constructor. At this point, we have two complete subclass functions and one superclass constructor function that creates a bit of a starting point for each of those subclasses to build on top of. Looking at the diagram, you can see that we're achieving the exact same thing as before but with less repeated code. The Van and the Cop functions produce the same kinds of objects they always did, but they're allowing Car function to do most of the work for them first. But in addition to providing a basis for the Van and the Cop constructor functions, the Car function is also a full-fledged class itself. If my code ever needed to make simple Car objects that lack the more specific Van and Cop methods, then we could just call car directly. And with that we have completed our refractor to include a super class and two sub classes. Interestingly, the car class now looks exactly the way the van class did before we introduced the whole idea of cops into our program.