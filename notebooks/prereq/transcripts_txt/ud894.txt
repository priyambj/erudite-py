[MUSIC] Put this piece here and then take this one and put it here. Hi there. Have you ever felt like building a web application is like making something with tiny pieces and no instructions at all? JavaScript is flexible, so is the don which makes browser application development feel like assembling a million tiny pieces. You don't have to do this alone though. Front end frameworks such as Backbone, Angular, and Ember handle the common details so you can focus on what makes your app special. So welcome, I'm Richard Kalehoff, a course developer at Udacity and a front end application developer. I'm excited that you've decided to come on this journey with me. Let's discover the amazing capability that front end frameworks provide us developers. In this course we'll be taking a look at the major features of client side single page applications and some SPA frameworks. We'll work our way up from Backbone_ then build the applications with other popular frameworks. By the way, people have asked us why we're not covering react. React is an incredibly popular library for quickly updating the dom, but it only really handles the view, not the whole application. We're focusing on the complete application framework. Once you've completed this course, you'll be in a great place to learn react. When you finish this course, what will you be able to do? You'll be able to slip right into working with popular job script frameworks. And you'll also be able to evaluate frameworks to see if they meet the needs of your new project. JavaScript frameworks are incredibly powerful tools. They will empower you to build complicated projects with ease. They also help teams to get up and running quickly. All while maintaining code consistency and quality. Before we begin, I do want to stress two things. First, is that will be taking a deep dive into some pretty advanced JavaScript language features and programming concepts. This course builds on web tooling and automation, JavaScript design patterns and object oriented JavaScript. To really get the most out of the material, make sure you're comfortable with these topics discussed in these courses. Check in the instructor notes for links to these courses. Most importantly, make sure you're comfortable working with JavaScript objects, especially how prototypal inheritance works, functions, how lexical scope works, and closures with the data hiding capabilities that they provide. The second thing i want to stress is the importance of both watching and working along with me throughout the course. Don't just sit back and watch the videos, but take an active role, walk through the code with me and make sure you actually attempt the quizzes and challenges yourself. If you stick with it and carefully work through the code I know you'll come out with skills you can really be proud of. This is a challenging course. So if you feel like you're starting to get overwhelmed in some of the videos, stop, seriously. Sometimes all it takes for something to just click is just to take a break. Go for a walk around the block. Do something totally different to clear your head while I was making this course it felt like I walked around the block every single day. So, ready to get going? Let's do it. This is a fun little site. This is TodoMVC and it has the same Todo application written using many different frameworks and techniques, but all of them have the same functionality. Let's look at the backbone version. There are a lot of moving parts in front end framework-powered apps. I want you to play around with this site for a bit. Add some items, take a couple off, just mess around and explore what can be done. For this quiz, I want you to pay attention to how smoothly everything works and how there aren't any page refreshes. Then hypothesize on the steps that a framework must take to achieve this kind of functionality. There are no wrong answers, so write down as many ideas as you can come up with. Frameworks really are incredible. This is what I wrote down. Frameworks need to maintain chunks of HTML because different HTML content is displayed at different times. DOM manipulation because views are inserted and removed. Data processing because I can filter the data. And handling user interaction, because I can click on things and enter data and it responds. We'll be digging into a lot of the features that Frameworks provide. But if you want to get a head start, check out the links in the instructor notes. Some applications work better as a client side app than a server side one. Highly interactive applications, or ones that update frequently, often work better on the client. Which of these work better as a client side application? An email client such as Gmail, a blog page without comments, a contact form, a map with a search feature, a stock ticker or a blog page with comments. Check anything you think would work better as a client side application. An email client is a perfect choice, since you interact with your e-mail often and you may want to read it offline. A static blog never changes, so it's easy to leave on the server side. A form that goes to the server to send an email doesn't need anything special on the client. You're probably going to use it once. It's much easier for a searchable map to be a client side application. Think about having to wait for a new map tiles and the entire page refreshing if you want to move around, yikes. Something that receives real time data, like a stock ticker, should live on the client. You don't want to resend the page with every update. But change it locally instead. A blog page with a comment section could go either way. Normally the server generates a new page when you add a comment, though a client side program could collect all the comments from a database instead. A single page application is a self-contained page that has its own user interface and logic. It can talk to the server to send and receive data, then store that data locally. You can immediately interact with the data by modifying, deleting or creating new content. It's fast and there are no page reloads. You've already played around with TodoMVC, but I want to quickly focus on this MVC. What is it? MVC stands for Model, View, Controller and its a common design pattern for organizing software of any kind including web apps. Many frameworks provide a means for creating and managing models, views and controllers. Model refers to a data model. It's everything from the user information to any data that you might want to see. View is what users see and interact with. For a web site, the view is essentially any HTML, CSS and JavaScript that controls how a page looks and behaves. Last is the controller, this is the brain of your application. It sits between the model and the view and is in charge of passing data between them. It contains all the templating logic, routing logic and anything else that makes your app unique. If you want a refresher on MVC, I highly recommend checking out our course, JavaScript Design Patterns or the link in the instructor notes. Okay, now back to TodoMVC. When I add this item as a new task, I'm interacting with the apps of U, but the controller is watching this and is saving what I enter to the model. We've looked at single page applications in action and looked at a common way to architect them, but how do frameworks fit into this? Frameworks were created because projects required the same initial components, so developers were doing the same tasks over and over, write out the initial HTML, add standard default CSS, and perhaps include some initial basic JavaScript functionality. There are many coding principles, but two of my favorites are KISS, Keep It Simple, and DRY, Don't Repeat Yourself. Instead of doing the same steps over and over, developers came up with a base set of HTML, CSS, and JavaScript, and created starter projects from these files. These starter projects are used as a base or framework that can then be extended with project-specific code to create individualized websites. A framework is built so that it encourages you to write your code following standard patterns and to put your project's files in specific places. This helps to prevent spaghetti code, to keep everything organized, and to make it easier for new devs to get up and running. This is Cameron. You probably recognize him from some other courses around Udacity. Hey everybody, it's good to see you. So Cameron, we've been working through stuff with frameworks. Yes, frameworks are awesome. No, I love frameworks, they're so much fun. You get to build your app and just think about the logic of your app, without worrying about all the nuances that go into making your app work at the lower levels. That's right, and frameworks, the developers have already created a bunch of different components that you can just stick together, and so you don't actually have to worry about any of that complexity at all. Yeah, it's fantastic, like for instance, templating. Usually there's some kind of HTML that you want to display over and over, or display differently in different situations. And so with templating, you can just define that once, say what kind of information you want to go inside that template, and then when that data changes on your app, the template automatically changes, and it looks great. It's easy, you don't have to think about it. So at the end of the day, your workflow is so much faster and more efficient. That's right, and another thing is that they also handle events, so you don't actually have to worry about atEvent listener or managing state at the dom. [CROSSTALK] That's awesome, it's great, yeah. There's so much you don't have to worry about, because you have the best developers in the world, usually, working on these things. Maybe that's a bit of an exaggeration, but they're really good, and they know what they're doing, and so you're not really building this app by yourself. You're building on top of their expertise, which means that your app is going to be more performant, and there's a lot that you just don't have to do, which is great. That is great, yeah, less work is better. Definitely, the best code, or the code that has the least chance of being a bug, is the code that you don't write. There's probably a better way of saying that, but you get the idea. Exactly, yeah. Okay, so we're looking at angular and ember and some other frameworks in this course. But each framework is different, and each one provides its own set of benefits and detractions. So there are lots of different things you need to keep in mind as you're looking for a framework. Yeah, everyone is slightly different, they all have their own different philosophy. They all have their way of doing things, and they all also have different features. Usually, sets of features are fairly similar, but there can be some differences, so it's definitely worth experimenting with different frameworks to see which one you like more. And then when it comes time to build your project, it's worth thinking about what's going to go into it, so you can make the best decision about which framework best fits your needs. Sometimes there's not necessarily a best framework, it's just what you're most comfortable with and what you think you can move the fastest with. Right. I've got this instruction booklet, but that will give me step by step instructions on how to build this LEGO model. You know that it's organized, right? When you flip through it, you can see that each step is arranged in order and there are page numbers to help you find your place. All of the instructions take a common form, which means that you can easily jump to any page in the booklet and figure out exactly what the LEGO designers want you to build. This organization is helpful, it allows you to spend your energy decipher in exactly what you want to build rather than just simply trying to read the booklet. Frameworks are similar, they help us manage all of the coding complexity by giving us places and patterns for writing it. Some frameworks have their own set of conventions on how to name files.,where to put them and how to get them interacting with each other. Google Maps is a powerful site. And you probably use it often. But I want you to take a step back and think about this as a single page application. Frameworks and single page applications have a lot of moving parts. Sometimes it can be tough to see how the pieces interact with each other. With that in mind, for this quiz, I want you to look for what makes the URL change. Where templates are used. And what events are fired while working with the map. Write down what you find. Dragging the map around updates the URL to a new location. This maintains application state and lets you get back to this specific view. Google Maps uses a standard template to display the current location's information. Changing the location just updates the sections of the template. Events fire when you drag the map around, click somewhere, and with a whole bunch of other interactions. We've talked about how frameworks provide templating, URL management and event handling to control an app's data. These are the V and the C in MVC speak, but where is the data or the M in MVC? How is the data being managed by the client? Does it live on the client? And what happens with the data when we stop using it? If we take another look at the to do NVC site, we'll see that it doesn't start with any data. This is a common scenario. The app starts out empty waiting for the user to provide the data. Then when data is added more features appear. Now that we have our data, what happens to it when we're done with the site. To do NVC used local storage to save the user provide the data. This, however, is not permanent, and is only saved on this computer. If I open up the developer tools, go to the resources tab, and open up local storage, you can see the tasks I entered. If I delete these entries and refresh the page, you'll see that the tasks are gone. Browsers can make use of web storage, like local storage or index DB for temporary storage. But typically, a framework will send their data off to a server to be saved. Then, when they need that data, they'll just fetch it from the server. For example, firebase is a platform that lets you store and retrieve data. It has a rest server, and can easily be integrated with a front end framework. Welcome, everybody. We have Dhruv here with us today and he's a product engineer at Udacity. So Dhruv, tell us the story about how you learned your first framework. The first framework I used was in college, it was Ruby on Rails. And people will usually teach you frameworks as a starting point into building your first application because it takes away a lot of the decisions and complexities for you. So you can just jump into a framework, learn it, and ideally get building your first application in a couple days. So that was the first general framework I used. The first front-end specific framework I used was Angular. I used it in a summer internship in my senior year. And again, at the time I thought it was like nothing I'd ever seen, but it helped me get moving quickly into routing, building views, and generally getting the fundamental design patterns of the web quickly. So now that you're working with one framework, how difficult was it to switch to a new framework? The truth is a lot of these frameworks come from radically different paradigms. So Angular and React have very different philosophies about things. But a lot of them do share commonalities. So for instance, if you go between Angular and Ember, both are generally MVC frameworks, and if you know one, you get the guiding principles or the idea behind the others. A framework like React comes at it from a very different way. But knowing another framework helps you evaluate another framework you're using. So knowing Angular helped me understand a lot more about why React is useful, what were the guiding philosophies that made it unique and appealing to developers, and understanding the trade-offs that came with it compared to a system like Angular or Ember. Okay, so if you are learning frameworks, you shouldn't just find your first one and stick with that for life. You should experience the other ones, build something with them, see what are the needs of your application, and then pick the best framework for that. Definitely, I think that's a very good answer. There are some frameworks that are fairly impractical, but I learned them anyways because they, again, teach you philosophies and ideas of approaching programming that are unique. So in particular I checked out Elm lang, which is a very functional approach to doing front-end programming. I've looked at ClojureScript a lot, again, another very functional perspective to doing programming. And these have all affected how I view the frameworks I use today. And in addition to just looking at what works for you at this given point in time, it's also worth looking at what the general community is working towards. Because if you work with the community, you're going to get a lot of tools, a lot of resources that you wouldn't get otherwise if you choose a very niche framework. So there's a lot of considerations to make, but understanding that not all frameworks are perfect and that every framework might not be perfect for the job you're choosing is a very good place to start. So what is some advice that you would give to students that are looking to dive into the world of frameworks? To start by not looking at the fine-grain details of how to implement X, Y, or Z in a framework, although you'll have to do that in your app. But at some point, to take a step back and try and figure out what's the philosophy of this framework. A framework is essentially some really smart people somewhere have designed this intricate system to help you accomplish something. There's a lot to learn in just looking at how it was designed, and you can reuse a lot of those concepts in future things you build. So the first thing is just looking at the framework, understanding it, and understanding how it was created or what the decisions were. Frameworks are always going to be good at some things and bad at some things. Understanding those trade-offs and learning to appreciate those. Frameworks are incredibly powerful. And an invaluable resource when developing complex interactive single page applications. With all of the stuff that frameworks do for us, I don't want you to forget that these frameworks are primarily made up of regular JavaScript. In the next lesson, we'll be taking a deep dive into the Backbone framework, to see how it maintains features like templating, event handling, and state management. [MUSIC] Welcome back. I hope you enjoyed the previous lesson on the common features of frameworks. In many cases, frameworks seem like magic. I want to strip away some of the magic so that you'll better understand how your code and framework code fit together. In this lesson we'll be diving into backbone and the utility library underscore. Backbone is a highly opinionated framework in the NBC family. It uses underscore for its templating, and has its own event management and routing systems. We'll uncover how these features work. I want you to follow along with me in your own browser and code editor this lesson. I'll be doing the majority of my work with the Chrome dev tools so that I can take advantage of break points. It'll make it easier to open up the frameworks internals and get a clear idea of what's happening. Keep in mind that the point of this lesson is not to write backbone, the goal is to demystify how frameworks do things and for you to realize that frameworks, they're just JavaScript. If you want to build backbone apps, check the instructor notes for a link to our learn backbone course. So let's pop the hood and see what templating has for us. Look at this one little bitty itty Lego piece. Did someone painstakingly put each of these little circles on top, or take a huge piece of plastic and chisel it down to this? Did someone carefully mix the colors together to create just this right shade of green? Now think about asking these same questions for every single one of these pieces. There's no way that each piece was made by hand. They used a mold or template. Using a mold, you can make thousands of pieces incredibly quickly. Depending on which mold you use, you've already determined the size and shape of the pieces. One thing that the mold can't decide though is color. It's dynamic and is chosen near the end. So a template gives you a starting point with a default structure and content. But just like color, you might need to provide specific information before it's usable. Let's see how we can use underscore's templating capabilities to add custom data to our app. We will be going through a lot of detail here, and I highly suggest that you follow along with your dev tools open, navigating through the source code yourself. Digging into a framework source code is the best way to really see how it works under the hood. As we're going through this, don't get bogged down with all the code. Focus on how the template gets converted from HTML to a function. That's right, a function. A function that waits to get called with data. Here's the app we'll be using as we work through this material. And this is the HTML file for the app. Let's look at how these rows end up like this when the template starts out like this. There are a couple of things we need to pay attention to with the template. First is the ID here. It will be used to select the script tag, and its contents. The second thing are these characters here, and here. These are called delimiters. A delimiter is just a fancy name for a sequence of one or more characters used to form a boundary. We need these delimiters to separate the HTML from what will become JavaScript variables. These delimiters are broken into starting delimiters here, and ending ones here. The specific sequence of characters is the default for underscore. If I open underscore.js in a new pain, we can see them here. See how interpolate has the angle bracket. Percent sign. And equal sign. And the closing delimiters here. This middle section captures anything between the starting and ending delimiters. Evaluate, interpretulate, and escape all have different starting delimiters. We'll see why this is important and how these will be used later. So we have this template and it's filled with these special delimiters. But how does it get converted to what's seen in the browser? In app JS on this line, the template is fetched from the DOM and this HTML content is returned as a string. This string version of the template is then passed into underscores template function. This template function is where all the magic happens. Let's take a sneak peek at what the template function does by copying this code and pasting it into the console. We can look at the result of the template function, by checking the source property. The template function returns the function itself. Functions are extremely powerful, and the template function makes use of a JavaScript constructor function. Let's look at how a constructor function works. You're probably used to seeing in writing the code here, to create an object, an array, and function. These are in the literal format. These lines down here produce the same end result, but are in the constructor format. The constructor format for each of these is not recommended for several reasons. It's not readable, it can be harder to work with, and it's slower. But the constructor function does offer one benefit over a function literal. It can dynamically create a function at run time. Remember that underscores template functions job is to construct a function. It does so by using the constructor function format. Here is a function that takes two numbers and adds them together. It's written in the literal format. This function does the same thing, but it is written using a constructor function. The last argument to a constructor function is the body of the function. Any arguments before the last one will become parameters for the function. This makes constructor functions really handy, because they can create functions with a dynamically supplied body. So addr1 results in 3 and addr2 gives us 7. This make function accepts one argument and returns a newly created function. I'll call make and pass to it the string fun. This returns a new function. This is fun function is waiting to be called with some data. If I pass biking, I'll get the string biking is fun returned to me. Passing in climbing, or broccoli, makes them fun too. I want you to write the numLetters function. It needs to take a letter and return a newly created function, then call that function with a number. This number will be how many times the letter should be returned. For example if I call numLetters with the letter a, I'll get a function back. Now if I call LotsOfAaas with the number 4.3, four as will be returned. For a tip in writing your constructor function, it might be helpful to know that you can break up a string into several lines with a backslash. For example, these two variables hold the exact same string. Alternatively, you can concatenate your strings together. All three of these form the same string, without any line breaks. numLetters accepts a letter, and returns a newly constructed function. This function accepts a number, rounds that number, then adds the letter to result, once for each number. And finally, it returns it. Now that we have a handle on what constructor functions are and how they're created, let's dive in to underscore source code. Keep in mind the things we've been discussing so far about template delimiters. Don't get bogged down in the nitty gritty details of the function, but focus on what is happening to the template string that's passed in. Let's do this. I've got the developer tools open to the source tab and I’ve open the projects at file. When this line is run, remember that it converts the template to a string and passes it to underscores template function. This function is defined in underscore on line 1415. As a tip, you can press control g and type in the line number. Now, let's set a break point on this first line. Refreshing the page with command or control r will pause execution right as it's starting to build up the template. We can see that we got to this line from f j.s by checking the call stack. Remember that the text variable holds the contents of the html template. Chrome will show us what a variable holds if we now mouse over the variable. If you're feeling adventurous, how about you pause the video, and see if you can step through the code yourself. If you get stumped, or even if you make it all the way through to the end, come back, and we can go through it together. These lines here determine what delimiters to look for in the template. If you want to override the default delimiters, you can pass them in as part of the settings argument. This matcher variable is the set of delimiters. Since we didn't override them, they're the ones we looked at already. Matcher is a regular expression. Regular expressions are out of the scope of this course, but it would be helpful to know the basics. You'll find some resources on regular expressions in the instructor notes. These buttons over here let us step through the code. And I'll use them as we move through everything. This line starts the new source string. The rest of the function will add to this string. This is what will become the body of the constructor function. These lines here take the text and replaces it with the contents of the matched delimiter. Let's step through one loop to see how it works. Replace user's maitre which if you remember is a regular expression. To search for a starting and ending delimiter pair. The first one it found is stored in match. The delimiters that were found in this match were the interpolate ones. Looking at the current scope, the match's content is stored in the interpolate variable. If the contents were stored in the escape variable, then that variable would get saved to a T variable. Which gets wrapped in underscore's escape function and is added to the source string. If the contents were stored in the escape variable then that variable will get saved to a T variable which gets wrapped in underscore's escape function and is added to the source string. If the contents were stored in Interpolate, then it gets directly added to the source string. If the contents are stored in evaluate, then it gets directly added to the source string. Interpolate and evaluate are similar, but interpolate will insert the contents. While evaluate will actually run the code. The replace function loops through the entire text string until it finds all the delimiters and adds their contents to the source string. The next few lines add a little bit more to the front of the source string. We've been using the t and p variables already. This is where they are created. All of the hard work of building up the source string is finally about to pay off. A new function is created with the source string as the last argument. Remember that the last argument to a constructor function becomes the body of that function. This new function is stored in render. Now this render function, and this template function are very important. Template will be called at some later point with data. When template is called it calls render and passes along the data it receives. Believe it or not, that's the end. Underscore adds a source property to the function, which we used earlier, and then it returns the template function. The template property now holds the result of compiling the template. Which means that this is a function and now it's just waiting to be called with some data. That happens right here, so lets add a break point and refresh the page to see how it works. The template function is called with the model's attributes. We can step into this function call by clicking on this button here. This takes us back to underscore, back to the function that we just build up. Data is the information for the menu item. Remember that render is the function that we've built up in the previous video. The render function is called and the model's data is passed to it. Let's step in to render and see what's going on. We are now inside the function that was constructed from the HTML template. It looks a little complicated but here's the start of the TD and here is its closing tag. The content of the TD will be an empty string if the property is missing, or it will be the property itself. So these lines all form one big string and are stored in p, then p is returned. We can check p on the console to see what is being returned or we can see what this function returns over here. Returning from this function takes us back to template and from here we go back to App dot JS. Finally after its long arduous journey the template that's now populated with data is inserted into this element. Wow, all of that to compile and render a template, before we leave underscore, I need to mention one more thing about variables and the way they're referenced in templates. Would you say there's a steep learning curve after learning one to moving on to your 2nd or do concepts kind of crossover between that? Yeah concepts definitely crossover because all the Frameworks are trying to accomplish the same thing. So if you figure out to do one thing in one Framework, when comparing it to the next Framework you can be like okay, I know in Angular, I can do x, y, and z like this. And if you know this Framework the first thing you look for is like okay, how do I do x, y, and z in this Framework now? And it's pretty straightforward and luckily these Frameworks are very competitive so they try to compete with each other. So they set their documentation up like that. Like hey coming from Android check it out this is how you do this in Angular. Or hey coming from React, this is how you do it in this Framework. So you can definitely bring stuff over and I know from experience that works because I actually tried to learn to React while I was learning Angular and I just didn't get it. I was like this is kind of crazy. But after I mastered Angular I went back to React and I built a couple apps in a day. So it was pretty straightforward after that once you learn one they're all just the same. because it's not so much the syntax and how their Framework does it, it's what the Framework is trying to accomplish. And you notice that all Frameworks are trying to accomplish the same thing. So once you know that you're good. Okay so what is some advice that you have for students just diving into the world of Frameworks? Like I said there's two steps of learning. There's the practical side where you just you know how to use it very very well. You might not know what those methods and functions and objects as you interact are doing, but you know the result of them so you know how to use it very well. So I would say, focus on that practical side. A lot of people want to dive right in and try to understand how all of it's working, the internals and stuff. It's actually very scary if you do it that way, especially Angular. Angular is one of the scariest Frameworks on the inside. It is almost like magic, at first. So I would not recommend trying to figure out how Angular works internally, at least, not yet. But instead, get very very good at using Angular, the tools that it provides, and the only way to do that is just build a lot of stuff. Start off with a small app that teaches you one example and then eventually go up to bigger apps that maybe work with servers. And eventually you've built four or five, six things that you can say, hey, I've learned all the concepts of Angular and you feel pretty comfortable using it. And once you get there, then maybe if you're up for it, jump into how it actually works on the inside which is only going to enhance your skills on the practical side. Underscore's template function is very powerful, but it can't work if it's called with bad data. Here's a template that tells people they need to go to the beach more and lists some items to bring along with them. This is the JavaScript to compile the template and pass it some data, but if you tried compiling this template it wouldn't work. Either Underscore doesn't want you to go to the beach or there's a bug. Look at the code and select the lines that are causing the problem. Thankfully Underscore isn't against you going to the beach, but there's still a bug. The bug is on line 11. The equal sign here is wrong. Remember that by default, all backbone ending delimiters are just %>. When this template is compiled, Underscore finds the opening and closing delimiters and captures everything in between. Which means supplies.towel, and this equals sign. Later on when this is used in the constructor function, JavaScript will think that this single equal sign here is being used for assignment. Except there won't be anything on the right side, so it throws an error. We've gone through backbones template function, now I want you to write your own template function. Your function must have a set of default delimiters, allow for custom delimiters to be passed in, handle simple replacement and return a function. The returned function should be called with data to be inserted into the template. And the number of times the template should be logged to the console. For example if I have this template, I should be able to pass this string into your template function. Your template function should then return a function. I should be able to call that function passing a data for each one of these variables. The last argument to your function is the number of times it should log the completed template to the console. So let's see how it should work, I'll pass the string to the template function and get a function back. Then calling the function with data and a number, logs the message to the console that number of times. Don't forget that your template function needs to be able to handle custom delimiters. This is definitely a challenging quiz. Filling out your own templating function will help nail down how this works, and it lets you build up a collection of code that you've written, that you can use later. If you're ready to tackle it, click the next button. If you need a hint stick around for a second. Still here? Okay, I didn't use any regular expressions in my solution. Instead I use a combination of JavaScript split and indexOf methods to search for a delimiters. There are many ways to solve this quiz, but this is what I came up with. I'm using an array to store up the different sections of the template and then join them together to become the body of the constructor function. First I set up my delimiters and some variables. This section here updates the default delimiters with any custom ones that are passed in. Here I split on every occurrence of the starting delimiter. Then i loop over each segment, find where the closing delimiter is. I grab what's in the middle, which will become the variable. And then I add the remaining stuff after the closing delimiter. Then I join each of the different segments back together and add a loop to log the template once for each time. Then I create the function. Then I join each of the segments back together and add a loop to log the template once for each time. Then I create the constructor function. One tricky part is that the body of the function has to be a string, but those quotes are removed when inserted into a constructor function. So for something to be a string inside of a constructor function, you have to wrap them in two sets of quotes. That's what these wrapInQuotes function calls are doing. Down here there's a message informing the user about which item they've chosen. In this case, we haven't selected anything yet, so it assumes we're starving and tells us to pick something. If I pick something to eat like strawberry pudding, the message changes to remind me which item I've selected. Now how does Backbone handle monitoring events? In app.js we have a view for the SelectedItem message. Just like before we get the template from the DOM, convert it to a string, and pass it to underscore's template function. These buttons are part of a MenuItemView, and that's where the button and the SelectedItem message are wired together. This is where we set up the events for each menu item. When something with a class of SelectedItem is clicked, JavaScript will call the selectItem function which is right here. Backbone creates a record of all the events it needs to listen for. It keeps track of everything that needs to happen when that event actually runs. And when the event occurs, it triggers all the code that needs to run. We're going to look at Backbone's on function in isolation, this way we can really focus on how it works. Let's first create an empty object. Now we'll take this empty object and add in all of Backbone's event functions. Since it has Backbone's on method, I can now set up an event for this object to listen for. Finally, I'll trigger that event and pass it some data. Backbone took this string and passed it to the callback function and logged out this message. Let's dive into on and see how it's doing this. I've opened up Backbone source code here. And let's refresh the page so that we know that we're starting from scratch. And now let's set up that object again. We need a break point here so that chrome will pause when we try to call on from the console. Great, now we can call on to get the ball rolling. There will be several function calls in quick succession. The important thing to notice is that new information is being passed along with each call. First, InternalOn is called, and adds this object. InternalOn adds an events property to the object, which is the result of the call to Events API. EventsAPI is called and passes the on API function. The existing events, if there are any, or an empty object. The event name, the callback, and some other contextual data. Let's step into eventsAPI. EventsAPI checks if the event name is an object. A string of multiple space separated events, or a single name. Our event is log. So we end up down here. The empty list of events, name, and callback are passed to OnAPI. When we started by calling on down here in the console, everything up to this point has been verifying information and adding new things that are getting passed along. We finally reach the bottom of the stack. Pay attention to what's going on in this function. Since this is our first time through, events name doesn't exist yet so an empty array is created. Both events name and handlers points to this same array. We didn't pass any options, so these are just undefined. Handlers is the new array that was just created and an object containing the callback function is added to it. If we look at the current scope, you'll see that there's an event's object with a log property that's an array of one object. That object has the callback inside it. The rest of the process is returning this events object. Lastly and most importantly, remember that this event's object is stored as a property on the original object. And that's it, so Backbones on method adds an events object to the object. Each key is the name of an event to listen for. And each value is a list of callbacks to run Jack is having his birthday in a couple weeks and there are a number of gifts I need to buy and put together for him. I've extended the jack object with the backbones event functions. And this is how jack's events object needs to end up. I need you to help me get prepped for the birthday party by calling backbones on method and passing it the correct information to make jack's event object look like this. The catch is that you need to do this using just two calls to on, see if you can figure it out. If you get stuck pop open the DEV tools and walk through backbones on method. The event's object has properties for each one of the event names. So we need to have birthday, party and present's events. The callbacks need to be added to the right events. So purchase needs to be added to every single event. The presents event also needs to call the build function. So it needs an additional entry. These are the solutions. Remember that backbone's events API function can handle an event name that's an object, a single string, or a space separated string. If it's a space separated string, then it will split on the space and add the callback to each event. So far we've created our object and built up the list of events to listen for, let's figure out what happens when we trigger one of those events. We need a break point here so that Chrome will pause when we try to trigger the event. These lines pull out the arguments that are passed. In our case that's an event, so the arcs variable will be in a ray with the string and event in it. Then it calls the events API function, just like it did when we used on. This time trigger API will be used as the iteratee. Just like before, events API checks if the event name is an object, a list, or just a single word. Then it calls iteratee, which is the trigger API function. Trigger API pulls the callback out of the event object and then passes the call back and the arguments to trigger events. Just like the on method, most of the time is spent setting and passing along data. This function here is what actually runs the callback function and the data. This first line sets up a bunch of local variables. Then it checks how many arguments were passed. In our case that's just one, so it jumps to here. And it pulls out the event out of the events array, gets the call back, and calls it with the argument. After that, Backbone just unwinds and returns all the way up the chain. Backbones event functions have been added to the jack object. What will be logged to the console when the following code is run. Will it be Buy a bicycle, sword, clarinet. Buy a bicycle, Buy a sword, Buy a clarinet. Buy a bicycle or just buy a. Buy a bicycle will be logged. Backbone's trigger-events method passes arguments to the callback function, using call. So each item should have its own parameter. Since bicycle is first, bit's stored in presence and gets logged out. It's important to realize that both sword and clarinet are sent along with bicycle into the callback function. They just aren't stored or used. We've been digging through Backbone's event system, and now I want you to create your own. You need to create an event tracker function that accepts a name for the object. Then extend event trackers prototype an add on, notify, and trigger methods. On takes an event and a callback, notify takes another event track or object, and an event. Trigger takes an event. And the data that will be passed to the callback. This might seem like a one off quiz. But you can use this to build up your own library of custom functionality that you've written. If you're ready to tackle it, click the next button. If you want to hinder to stick around for a second. Okay ready for those hints. Each event tracker object manages a list of events and callbacks. Very similar to how Backbone's on method works. But the object also has a notify property to track the list of other objects to notify. Would you like hint number two? Okay, the trigger method needs to loop through the events list and call each of the callbacks. And loop through the notify list triggering that object's trigger method. Now there are a number of different ways to solve this quiz, so don't worry if yours doesn't match up exactly with mine. I set up the event tracker function here. Each object keeps track of a list of events and a list of other objects to notify. Then I extend the function's prototype. Just like backbones on, this function add the callback to the event's list of callbacks. Very similar to on, notify adds a list of objects it needs to notify for each event. Trigger loops through all of the callbacks and invokes them. It also loops through the list of objects it needs to notify and triggers them too. And that's it. So, an event tracker object can manage its own events. It can also let other objects register with them to get notified when an event happens. Pretty neat? Here's our food router, and here's the call to start monitoring the app's history. Inside food router is the list of routes and the functions to call when those routes are visited. When the URL changes to /clear, call the clear function. Let's add a breakpoint where we create the new foodRouter router, then refresh the page, which will pause right at the breakpoint. Let's step through how everything gets set up. This calls the parent Router class, sets up some options, and then binds the routes. _bindRoutes is the important function in all of this. It gets the route from the foodRouter router and starts cycling through them. It takes the last route, passes it and its callback to the route function. The route function takes the route and converts it into a regular expression. This regular expression will be used later when matching the browser's URL. If the callback is a string and not a function itself, it gets the function from the foodRouter object. It then calls Backbone.history.route, passing it the route and a callback function. This function will be called later, but see here that our original callback function will be executed when this function gets run. Backbone.history.route adds the route and the callback to its list of handlers. Then we just work our way back to bind routes, and do all that again for the next route. I was just at Yosemite, and now I've decided to create a soon to be world famous website that aggregates important information if you want to go hiking. But I can't seem to get the routing figured out. Going to the site's home page should activate the home function. I also want to let people look up specific mountains. So when the route is mountain/ some ID, I need the mountain function called. And then people should be able to download brochures. This right here should be able to be anything, and then download/whatever should load the download function. I need to turn these URLs into routes that Backbone can understand. Can you help me finish the mountain router by adding in the correct routes? What is the route to call the home function? What about the route to handle the mountain and its ID? Enter the route here that will call the download function. For help with figuring out the ID and the brochure, it might be helpful to review Backbone's documentation on route parameters, specifically params and splats. The home route is the base URL, so we just need to call home. The mountain route needs an id, so we need to capture that with a route parameter, and then call the mountain function. This is just like the one above, except that instead of a single value, we use a splat to capture anything after download, and then we'll call download. Backbone has cycled through each of the routes in the food router router and added them to Backbone.history.handlers. The Backbone.history object is what actually takes care of managing the state of your application. It monitors the URL for changes, and when it sees a route that's listed in its list of handlers, it calls the function. Let's take our last dive into Backbone source to see how it does this. Let's add a breakpoint here to pause the execution and start working through the code. Reloading pauses at the breakpoint, so let's step inside start. These lines determine if the app can use the hash change and pushState events to monitor the URL for changes. Since we didn't tell Backbone to use pushState, it will default to hashChange. If we want to use pushState, we could call start like this. Backbone gets the current URL fragment here. This is a precaution in case the app is loaded with one of the routes already in the URL. This section will run if we said we wanted pushState and hashChanges also available. This section will load if the app is loaded in an iFrame. Older browsers do not support the addEventListener API. So if the app is loaded in an older browser, it will set addEventListener to a function that calls attachEvent. This section sets up the listener for either pushState, hashChange, or if neither one of them is available, then it fall backs to polling the URL for changes every 50 milliseconds. We're checking for the hashChange event, so we add this listener here. We're done with this part, so I'll click Resume to finish running through all the code. Now that check URL will be called when there's a hashChange, let's set a breakpoint here and walk through it. Let's click this button to change the URL's fragment. checkUrl gets the current fragment and calls loadUrl. loadUrl is what compares the new URL against the list of handlers. It gets the current fragment, then it goes through the list of handlers for some that have a route that matches the current URL. I'll add a breakpoint here to let us skip over the details of some. It's paused right here at the breakpoint. Checking the scope, we can see that this handler is the one for the clear route. It tests the route against the current page's fragment, and they don't match. So I'll click Resume to get to the next handler. Now it's checking the select route. Notice fragment right here. The fragment starts out with select, so the test does match. Remember when we walked through what happens when a router is set up? This is the callback function that was created. This line gets the parameter from the URL, then it executes the callback function that's set up in food router. After that, it just returns, and that's it. We finished digging through how routing and state management work. But don't lose track of the big picture. Backbone.history.start sets up an event listener to watch the URL for changes. When it does change, Backbone cycles through its list of handlers, looking for one that matches the URL. When it finds one, it executes the callback function associated with that route. In front end applications, the URL can change all the time. So it's important to realize the work that frameworks go through each time the URL changes. When clicking a link that loads a new route, how many times is Backbone's getFragment method called? Type the number here. And which Backbone methods is it called from? Enter the method names here. The answer is two, get fragment is called the first time from inside check URL. The second time it's called is inside load URL. It's important to realize what goes into changing URLs so you can keep your app nice and snappy. As you've seen, a lot of work goes into building a good framework. And I learned so many things as I was creating this lesson. But I want to know, what are the top three things you've learned from digging through the source code of Backbone and Underscore? Enter your list here. As I was creating this course and trying to demystify frameworks, I kept realizing that frameworks, they're just JavaScript. There's no magic to them. A framework is built up of pieces of functionality. For example, if we found a better templating system than Underscore's, we could swap it out and give backbone a different one. Well except that I learned Underscore's template function is a real powerhouse in converting a template to rendered HTML. We aren't ending here though, so don't toss out your realizations. In the following lessons we'll be looking at larger frameworks. The concepts that you've learned in this lesson transfer over to those frameworks too. Wow, can you believe the amount of code we just waded through? We first looked at templates which are just strings. They use delimiters to section off where JavaScript data will appear. Underscores template function returns a function. We then call this function with data. Then we saw how backbone handles events. It takes an event object and stores an event and callback function in an _events property. When the event is triggered on the object, it runs the callback function. And we just dug into how routing and backbone.history work. The app's router sets up the routes and their callback function in backbone.history.handlers. Then backbone.history.start watches the URL for changes. If the URL matches a route, then it runs the callback function. These three abilities, templates, events, and routing, are key aspects of how frameworks make developing complicated apps easier. In the next lesson, we'll move from looking at the inner workings of Backbone to Angular, a framework by Google. [MUSIC] Welcome back. We've been looking at how frameworks help developers become more productive. And we've taken a deep dive into specific features of backbone and underscore. In this lesson, you'll be using the Angular framework to put together a simple app that lets you record menu items for a specific meal of the day. We'll be diving into Angular version one, which is a mature and stable framework. Angular two is currently under development and is not backwards compatible with Angular one. Just as a local model is built up of a number of different pieces to form a complete design. Frameworks are built up of different techniques and concepts. Learning the concepts and this lesson will make it easy to snap on concepts from Angular two or another framework. As we go through this lesson. I encourage you to work through each of the steps yourself. Build up the app along with me. You'll learn a lot by watching me work through building up a project. But you'll learn so much more if you build it yourself. Angular is an awesome framework. And when we're finished, I hope you'll love working with it as much as I do. Angular is an open source framework. Created by Misko Hevery and is maintained by Google. But what's so important about Angular? Why should you even care about it? Angular is a powerful framework. That can manage your entire application. If you don't want all that power though. You can pick and choose from Angular's list of features. It doesn't force you into any specific file structure or way to organize your code. This can be very liberating. The downside, though, is that every Angular project you work on could be different. So Angular lets you control the app structure and capabilities. Keep in mind Uncle Ben's advice. With great power comes great responsibility. Another one of Angular's awesome features is two way data binding. Two way data what? Here's a trimmed down version of how a template gets its data. Here's a data object that gets fed into the template. This is a very high level overview, but pay attention to name In both of these sections. A typical framework retrieves the data and displays it in the template. It's a one way singular fetch of information. Angular retrieves its data in a similar way. With two way data binding the information you add, delete, or change in the browser updates the underlying data object. Why don't we take angular for a spin and see how amazing it is? Angular's concept of two-way data binding is one of its claims to fame. It's a very cool feature but the power of it can get a little lost if you don't see it for yourself. I want you to try it out and see how easily it turns a static site into an interactive one. Here's an app that helps create awesome name tags. But typing in my name doesn't do anything. To complete this quiz, add this code right here to the H1 in main.name HTML. Then go back to the browser and add your name to the page. Change the text to orange. And add a strikethrough to the text. While you're exploring the app, pay attention to how quickly and easily you can change the page's content. The link to the starter code for this project is in the instructor notes. When you finish building the template, the feedback extension will give you a code. Enter that code on the next page. First I need to add this code to the main.html file. Here's the main file, so I'll add the code right here. Now whatever I type shows up in the name tag. How quick and easy it was that? Typing in my name and checking these check boxes dynamically updates the name tag. You're seeing several Angular concepts at work here, two-way data binding, directives, scopes. All of these come together to form a dynamic and interactive app. Let's look at how these concepts fit together. The Angular framework is made up of several different components. We'll be looking at how each of these components interact with each other as we work through this lesson. But it's helpful to see roughly how they all fit together before diving into the specifics of each one. The first thing we'll look at is the module component. Think of a module as a container that stores the different parts of an app. Like any framework, Angular provides a templating system that lets you format the HTML structure of your application. This is the view part of the NBC framework architecture that Angular follows. The controller is where you set up the initial state and logic for a view. The scope is what binds the template in the controller together. When the user interacts with the template and changes some of the data, the scope watches for this change and updates the controller. On the flip side, if the data changes in the controller then the template is updated. Directives are markers on a template that tells the Angular HTML compiler to attach special behavior to a DOM element. A service is closely tied with controllers. You would put view independent logic in a service. Then you can use that service in many different controllers. For example, a service could be used to fetch and store a user object. This one service could then be used in multiple different controllers. An Angular app doesn't need a router. But the more complicated an app gets, the more likely it is that you'll want one to help manage the application state. Our router will watch the URL and load the correct template and controller. Let's take a look at how to add Angular to an existing project. We need to start thinking about the different components of Angular and how they interact to form a specific feature or complete website. For example, if I asked you to build a new feature for our toy store, but displayed a sidebar with the deal of the day, which of the following Angular components should you create? A router, a template, a service, a controller, or a module? Since the side bar will appear on every page of the site, a new entry in the router isn't needed. A template absolutely needs to be made. Remember that a template is a bit of html. The sidebar will need html, so we should create a sidebar template. We won't need a service since this new feature won't be used anywhere else on the site. We will need a controller though. Remember that a controller sets the initial state for a view. What will the deal of the day item be? Will it have a description or a price? All of that information will be stored in the controller and passed to the template to be displayed. A module is a container for all of these things. Since we just need a sidebar feature, we don't need a unique module. For the next feature of our site, I need you to create a checkbox to save the item for later. This new save for later checkbox should appear here on each individual item page and have its own page that lists all items that have been saved. Which of the following Angular components would you need to create this feature? Because the save for later feature will have its own page where customers can view items they've saved for later, a new entry in the router will be needed. The save for later check box will be added to the item template but the page that lists all items that have been saved will need its own template. So a new template will need to be created. I'll come back to services in just a minute. Just like the template the items controller will have a new property to track if it's been saved for later or not. But the save for later page will need a controller. The save for later information will be used by several templates, the product page, an individual item page, and the save for later page itself. Since all of these need access to the same information, we need a service to keep track of everything. Then we'll let each template's controller have access to that service. Our app is already housed inside of a module, so we'll just add our new feature to the existing module. So this feature used almost all of the concepts we'll be looking at in this course. As you're learning each new concept keep in mind what it should be used for and how they all fit together. The Angular framework is very relaxed in how you can use it. If you just want to use some of its features and not the whole framework, then you totally can. But to stay organized and consistent with our apps, we'll use a project scaffolding tool called Yeoman. Before we do that let's see how easy it is to add Angular to an existing project. Here's a simple app that lists some information about a brick. I want to give customers the ability to enter a number of bricks and calculate how much it'll cost. This is a simple request and can easily be done with Vanilla JavaScript. But let's see how easy it is to do with Angular from scratch. First we need to link to Angular in the project. Then to bootstrap Angular, we need to include an Angular specific attribute called ng-app on the body element. Now Angular will run. Awesome, except we're not really seeing anything. Angular is actually working. We just haven't told it to do anything. To actually see something, we need to add some special code that Angular will use to display the information. In the index file is an input field for the user to select how many bricks they want to purchase. And here's a section for the cart that will show the total price. But how do we get these two sections linked together? We'll look at this in more detail when we get to the section on directives. But I'll add this Angular attribute to the input field. Then I'll use this same value down here in the calculation. Looking at the browser, we now have an interactive app. Granted, this is a very simple app, but isn't it incredible what we've accomplished without even opening a single JavaScript file? So I just added the code directly to the existing index file. That's fine for small projects, but if you're app grows or if multiple developers are working on an app, you'll probably want some organization and consistency. Let's look at Yeoman to see one way professional Angular projects are built. Here's the project, and we can see a pretty organized file structure. Project files go in the app directory. It's got a single HTML file and several directories, with the two important ones being views, which is for templates, and scripts, where all the JavaScript lives. Notice that the HTML file includes angular down here at the bottom. Let's do a little cleanup by fixing the indentation here, and here. Most likely, you'll want to include analytics in your project, but for now I'm going to remove the Google Analytics code. And for the last bit of cleanup let's remove these nav links. The angular generator bundles grunt into its workflow. Grunt is a task runner, and out of the scope of what we'll be covering, but you can find more information about it in the instructor notes. We'll be using grunt to serve the project files and reload the browser when any files change. To start the server, just run grunt serve on the terminal. And here's our project. Lastly, the angular generator package provides generators for every Angular component. We've just used this first one to create the app, and we'll be using most of the others during the rest of the lesson. It might be a good idea to bookmark this page so you can refer back to it. We saw that angular can be quickly and easily added to an existing project just by including a link to angular, and adding the NG app attribute to the page. But to keep a consistent and organized project, we'll be using yeoman and the angular generator package to create our projects. Now that we know how to get up and running with the new angular app, let's learn how to create modules. When you get a Lego set from the store, the pieces inside are in sealed little bags. Larger sets like this one have multiple sealed bags. All of the pieces in one bag create just a portion, or component, of the model. After building each of the components, you can combine them together to form the completed model. An Angular module is just like this cardboard box. It's a container that houses all of the different components of an angular application. If the box is like a module, then this bag might be a controller, and this little bag could be the router or a service. Applications aren't limited to just one module. When an application becomes more complex, it's a good idea to break out the different features of the application into modules. This keeps your app more organized, manageable and easier to test. When we used a Yoman to generate our app, we gave it the name udaciMeals. This became the default module for the app. The generator creates the apps model inside appJs. The module is created by calling Angular.module, passing it the name of the module, which can be anything but automatically uses the name provided on the terminal, and passing it in a ray of dependencies. Remember that Angular applications can have more than one module. If this app depended on other modules, then those modules are required for this app to function. Those modules names would be listed here. So, this tells the angular to create the udaciMealsApp module and that it depends on dep1 and dep2. This tells Angular to create the udaciMeals app module, and that it doesn't depend on any other modules. So this creates the module. To get the module, we would write angular.module, and give it the name of the module we want to get. These two forms are very similar, but do totally different things. If you're creating a module, make sure you pass an array as the second argument, even if the module does not depend on anything, it needs to have that array. Also make sure that you create your module before you try getting it, or Angular will complain. I've created this Angular app for you to work with in this quiz. For this quiz you need to create a new module named legoBricks. Then add your legoBricks module as a dependency to the apps existing module. A link to this project is in the instructor notes. When you've completed these steps, the feedback extension will give you a code. Enter that code on the next page. First i created the Lego bricks JavaScript file, and then I included it on the page. Remember that to create an Angular module, it's angular.model, the name, and then an array of dependencies. Since this module doesn't depend on anything, it's just an empty array. This module needs to be added as a dependency to the app's main module. To do that I just added the name of the Lego bricks module here. It's good to understand how Angular works without a generator and to be able to build files manually. Great job doing that. Now that the module has been created, we can use it to bootstrap the application. To bootstrap our app, we need the attribute ng-app and set it equal to the name of the module, which is udsc MealsApp. Using Yeomen to scaffold our project has helped us out again, because it automatically added the code to bootstrap the app for us. The code right here is called the directive. This is a mini preview on directives, but they're awesome and very powerful. When Angular loads, it scans your HTML for this specific directive. You can only use ng-app once and it tells Angular two things. First, this element contains your application. You can put this anywhere, but if we put it on a div somewhere down in the page then Angular will only be loaded inside that div. Second, it tells Angular to load the Udsc MealsApp module and all the components that it contains. There are some other things to be aware of when using ng-app. Look in the instructor notes for details. You may not always be able to use Yeomen, so I want you to try bootstrapping an Angular app by hand. You need to create a module with the name legoBuilder and bootstrap the application using the ng-app on the body tag. A link to this project is in the instructor notes. When you have completed these steps, the feedback extension will give you a code. Enter that code on the next page. I created the Legobuilder file and added it to the page. To create the module, I called angular.module and passed it the name. Remember that to create a module, there needs to be an array of dependencies. There aren't any for this module so it's just an empty array. Now that this module is ready, I just need to bootstrap the app. The empty app directive is used to bootstrap an app and i gave it the name of this module. Every Lego kit comes with a booklet that's used to create the model on the cover, but it's just a guide. If you want to create the model with a different look, then you'd choose differently colored pieces. So this booklet is a template to create the model with a specific look. Let's see how templates work in Angular. Get ready because it's kind of complicated. Yep, that's it. Just plain old regular HTML. There isn't any fancy templating language or special way to format the code. If you can write HTML, then you've already mastered templating in Angular. Okay, so Angular templates are written in HTML, but how does the dynamic data get there? How does green get here, or my unbreakable password, where does it come from? Most of the HTML will be the same for every user. Only these parts here will be different. These dynamic parts will be set in a controller which will fetch the data from a database. We'll look at controllers in more detail shortly, but for now, let's use this as our controller. To create dynamic content in the template, we need to use Angular expressions. Expressions in Angular are just double curly braces where you can put variables or simple mathematical operations like addition. In this case, I've got username right here in my controller. So I'll replace Richard K with user.username. Make sure that you surround this with double curly braces so Angular will realize it's an expression. Now I'll update these last ones. And now we have an Angular template that contains dynamic expressions that get their data from a controller. Sometimes it can be a little tricky to convert a mockup or site with static content into a dynamic one. For example, here's a portion of a template. Which of these sections should be converted from hard coded content into dynamic expressions? For each one you think should be converted into an expression, enter that expression in its text box. For example, if you think that Green should not be static but might change, type out that expression here. There are a lot of differently colored bricks, so the color should be dynamic. Each brick will also have a different size and price. The section heading will not change no matter what brick is being displayed, so it doesn't need to be dynamic. Now for the description, this one's a little tough. It really depends on what the rest of the text is. If it's a generic description of bricks, then the same description can be used for every brick. If it's specific for each brick, then it will need to be dynamic. This description looks kind of generic, so I'm choosing to leave this hard coded. So these three should be converted to dynamic expressions. To convert these into variables that will be set in a brick controller, I'll convert green to brick.color, two by four to brick.size and three cents to brick.price. Don't forget the double curly braces to actually make these expressions. We've looked at tempelating and how it works in angular, now let's take a look at controllers to see how a template gets its data. What would you say would be the learning curve of learning Angular? The learning curve is actually kind of like jagged for Angular because there's many levels of Angular. The way I like to think about learning framework is you learn it as a user so you know how to use it very, very well. But then you learn it as a developer where you actually know how it works and you contribute to it. So on the user side it was pretty straight forward. It was kind of steep at first, and might have had to do with my skills in JavaScript and generally, they were not that good at the time. But I like to think of it as, actually the less you know is probably better because Angular introduces a lot of new concepts. And if you don't have to unlearn something to learn Angular, it's probably a lot easier. But the learning curve was, I guess it depends on how you go at it if you read books and stuff it's going to be kind of jagged, you're going to read this blog that says do it this way, and this blog says this way. But actually, if you just dive right in and start building stuff with it, you'll realize that it's actually not that difficult, it's pretty straight forward and you can probably get an app done in a couple hours. So just keep building with it. And the on the developer side, learning how Angular works internally, being able to contribute to it, that just took forever. [LAUGH] I mean I literally had to take Angular apart, rebuild it from scratch, and all types of stuff to really understand how it works. What are some recurring job script techniques or concepts that you found most useful when learning a framework? With this day and age for sure is modules. Having some type of module pattern in JavaScript. Because on the web every line of code you write is going to be in a global scope and that's just not good. So, frameworks introduce some type of module pattern to encapsulate your code. So adopting that pattern whether it's through the framework or using something like ES6 or your own module pattern, that's definitely a way to go. I'm totally used to writing everything in modules. That's one thing, another thing is get used to understanding how component architecture work because every framework that's going to come up from here out is going to be using a component architecture. Which is based off of the web component standard that's going to be standard real soon. So, just wrapping your head around modules and components is just going to leap you bounds towards mastering all things web development. We've looked at templates, the visual side of an application. And modules, a container that houses and encapsulates the different components of an application. Now it's time to add in controllers. This is where we really start to see Angular coming together. But first time to play with some more toys. Every Lego model can be put on display but not all of them actually do anything. This LEGO car has wheels and it can move. It's not just for show. The power of single page apps is that you can interact with them. Angular controllers gives us the ability to provide both data and functionality to an app's templates. Let's add some data to our apps. We can use Yoman to generate the files we need. Let's make the controller first. We need the yo angular:controller command. And let's create a controller named menu. This creates a menu file in the controllers directory. It also updates the index file to include this new controller. While we're setting up our app, I want this project to start with a clean slate. Let's remove this default main file here, in the controller folder. And in the view folder. Now in our new menu controller let's delete the functions default content. A controller just like the other components in angular lives inside of a module. The modules already been created. So we get it and add the controller to it. To actually create a controller use angular's controller method. The name of the controller comes first and then the function. A controller is a constructor function. Properties of the constructed object can be used as variables in templates. Lets add properties for an ID, a name, an image, and a rating and i'll use these values. We've added properties to the controller and the controller to the module. So Angular knows about our controller, how to create it and the data to use when creating it. Let's add this controller to the template, but first we actually need a template. Let's run yo angular view menu to generate an HTML template with the name menu. The generator creates our template in the view's directory. Now that we have our template we can add it to the page. This line is left over from the main file we deleted. Let's update it to use our menu files. We can swap out main here for menu and main controller we can replace with menu controller as menu. Just like we use that strange ng app attribute called a directive to add a module to the page. We need to use this directive to include our new template. The directive to load the controller is, ng dash controller. Then we pass it the name of the controller we want, menu controller. And the variable name to use for instantiation. Menu. I promise we'll look at directives very soon. Refreshing the page shows us the templates contents. Not very exciting, right, let's update the template to include our data. Here's what the generator gives us by default for our template. And here's the structure I want. With the HTML structure set, we need to add in the dynamic content. Remember that dynamic content needs to go inside an expression. For the heading we want the menu item's name. So that's menu.name. Remember, menu here comes from the ng-controller attribute which creates an instance of the controller and names it menu. Adding the rest of the information gives us this final template. On a side note, we're not adding the items image with an image tag just yet. We'll fix this in a bit. And here's our app. Notice that our templates receiving its data from the controller, and everything's displaying correctly. Awesome. What do you think about what we've learned so far? You now should have a good understanding that a controller provides the initial state for a template. And how to use expressions to display that information. I've created a sample project in angular using Yeoman. The link for this project is in the instructor notes. To complete this quiz, you have to take this hard coded template and change it so that it gets its data from a controller. So you'll need to create a brick controller and add it to the module, add the controller to the template with the name brick, add properties to the controller with the data from this template, replace these hard coded values in the template with expressions that get their value from the controller. In the end, nothing will look different in the browser, but that's okay. The app will now get its starting data from the controller. When you finish setting everything up correctly, the feedback extension will give you a code. Enter that code on the next page. First I'll use Yeoman to quickly generate a controller named brick. I'll add this new controller to the template with the NG controller directive. The controller is brick CTRL, and I'll reference this instance as brick. Now I'll copy over these values from the template into the controller. I want these values to be pulled from the controller. So I'll change green to brick.color and wrap it in double curly braces. Remember that this brick here comes from this instance of the controller here. Now I'll just update the other values and I'm done. We've looked at creating modules and controllers, and applying them to templates using Angular specific attributes, called directives. But how does Angular actually make the connection between the data and the template? When data changes in the website. How does it update in the controller? It all depends on Angular scope. Angular scope is an object that refers to an applications data. It's the bridge between the template and the controller. And is the vehicle for Angular's two-way data binding. Data gets set initially in the controller, then when the engine controller directive is added to the template. The template now has a context for its expressions. When the expressions change in the template, the controller is updated. Let's see all this in action. See how Angular added an ng-scope class to this div? When Angular compiled this template, it solved this directive. And created a scope object that's associated with this element. So when it came to the expressions in the template, it could resolve them from the scope. Checking the scope for the divs shows us a lot of information. The scope has an ID. It also has a parent scope. Inside our parent scope is our menu property with the data from the controller. In the list of properties on the scope object is $$watchers. Watchers. This is a list of things that angular is watching for, for changes. There is one watcher for each expression. Here's the one to watch the menu image property for changes. If Angular sees a change in one of the watchers, then it will update the property in either the controller or the template. At first, it's hard to understand how two-way data binding works between templates and controllers in Angular. Scope is the key that binds them together and performs updates when either side changes. Here's a template that I'm building for my new coder-only theme park. This template is backed by a controller that has properties for each of these expressions. Think about what we've just been looking at with controller properties being available to a template because of the scope object. With that in mind, how many watchers will the scope object have for this template? Enter the number here. Each expression has a watcher, and there are six expressions. So you might think that the answer is 6, but since these two expressions are the same, the answer is 5. One watcher for each unique expression. This one was a little tricky, so great job working through it. How are you doing with all the stuff we've looked at up to this point? You should have a good grasp on how the components we've looked at so far all fit together. Where the data gets sent and how the data appears in the template. Remember don't get overwhelmed with all of the different parts of angular. Just like with lego bricks, each new component is its own unit and snaps on to some other component. As you're working with the new component just try to mentally place it in this map. Then try and make the connections between it and the other components. Now it's time to snap on the next angular component, directives. Now we've looked at a couple of them already. NG App to bootstrap the entire application. NG Controller adds a controller and scope to an element. NG Include, which fetches, compiles, and includes an external HTML template. Directives are fun to work with. And as we've seen with these directives, they can be very powerful. But what is a directive exactly. Angular JS is documentation says that directives are markers on the DOM element that tell angulars, HTML compiler to attach a specified behavior to that DOM element, or even transform that DOM element and it's children. So a directive is something you place on an element to tell angular to do something. We've already used ng app and ng controller, but angular provides a ton of other directives. There's ng- show, ng- class, ng- model, ng- repeat, ng- source and ng ng-click just to name a few. To see a complete list of directives, check out the link in the instructor notes. The ng-if directive is simple but very powerful. It either creates or removes an element based on the validity of its expression. In our template we display the rating here. If the rating for a menu item is higher than four, then this expression is true and we see this text. So if I change the rating down here to 4.3 then everybody will know that strawberry putting is fantastic. ngClass is a very cool directive. It can accept several input types. But I'm passing an object with a key of warning and a string value. If the menu's rating is greater than 4.5, then the highlight class will be applied to the element. If I set the rating to 4.6, then the text will have the highlight class. You can also combine multiple directives on one element. Both of these directives are on the element but only one of them is being applied since the rating is 4.3. Another directive that you've actually used before is ng-model. This directive is applied to input select and text area elements. To see this in action, let's add a new section for reviews. Here's the text area where a customer will write a review. Down here is where the info will appear. We're using ng-if to display some text while the review box is empty. Typing something in the text box will create a new property on the menu object in the scope. ng-model has a lot of moving parts to it and can do a lot. So definitely check out its documentation link in the instructor notes. This next directive. ng-repeat Is incredibly useful if you need to loop over items in an array. I've updated the single menu item in the controller to an array of menu item objects. Back in the template, we can now loop over this list of items using ng-repeat. When angular compiles the HTML template, it will loop over this section once for every menu item. It will also apply a new scope object for each one. Every time we loop through the list, we'll reference the menu item as just item. Since we're using item instead of menu now. We need to update our expressions. And there we go. Just this little bit of template code is used to make this dynamic view. How awesome is that? Let's now transition this image from text to the actual image file. We'll do it with another directive. Because angular expressions are compiled after the HTML is downloaded and parsed by the browser, just sticking an expression in here would make the browser look for an image at this path. The NG source directive waits to add an image until after the compilation step. And here are our images. ng-if, class, source and repeat. All work with existing data. To actually interact with an app, we use the NG click directive. Let's add a couple of new buttons for changing the rating. ng-click for this button will increment, passing at the current menu item. This button will decrease the rating. Here are the functions that get called. I'm using this crazy calculation instead of this one. Because JavaScript doesn't handle mathematical calculations with decimal numbers like we expect. Increasing a rating will add a tenth of a point while decreasing it will remove it. What's really cool is that all of the directives work together perfectly. If we increment this item over four, then the message appears. Over 4.5, and the class gets added. I just love directives and they make building powerful apps effortless. We've only looked at a handful of directives. So make sure you know all the ones that angular ships with and how they're used. Directives are awesome, and they really take the difficulty out of creating powerful templates. I've created this controller for a toy store and you need to create a template for the store that will display its information and allow customers to interact with it. Make sure you review the store's information in this controller. Then create the storefront template. Use expressions and directive to display the store's name, the number of brick colors that the store offers. Create a list of the items in this.bricks and give it the id Color list. For each item in this.bricks, display an item for each brick size that displays the size, quantity, and price. If the quantity is below ten, make sure to give it the low stock class. If it's below five, display a more is coming soon message. Give each item a buy button that will decrease the quantity by one, and a return button that will increase the quantity by one. Make sure to give each element the required ID or class name. I'll give you a preview of what i came up with. Here's the name, the number of colors offered and a section for red, blue and green bricks. Each brick size has an entry with its data and each one has the buy and return buttons that also triggers the messages and the low stock class. The link to the starter project is in the instructor notes. When you finish building the template, the feedback extension will give you a code. Enter that code on the next page. I created the storefront template and added it to the index file. Then I added the ng controller directive to add the Lego store controller to this template. First, I display the basic information of the store's name, and the number of bricks it offers with a couple of expressions. Then I used ng-repeat to loop through each of the colors. Then I used another nested ng-repeat to display each color's item size. So this is what we currently have. Now I need to add the classes and the more coming soon message. I used ng-class to test the item stock levels. If they are less than 10 then I add the low stock class. Then I used ng-if to display this message if the quantity is less than 5. Now to hook up these buttons so that they actually work. When this button is clicked, I need to tell the store which color and size were bought. The same information needs to be passed when the return button is also clicked. In the controller, I created these functions to change the bricks quantity. And that's it. We used a number of different directives in this quiz. But I hope you see the power that directives give us. I mean look at how small this template is and yet we have an app that displays dynamic information and lets customers interact with the data. I'll say it again, directives are awesome. Dependency injection is a way to design software so that code, like a function does not have its dependencies hard coded into it. Instead, the information that the function needs is given to the function when it's called. There are a number of reasons for this. It decreases the coupling between a function and it's dependencies. It can decrease the complexity of that function. And it makes it easy to configure the function if it needs a new or different dependency. This topic can be a little convoluted to work through though. So I've got some friends to help me explain it. We've got Brittany. Hi. Cameron. Hello. Kogure. Hi Walter. Hi. And Mike. Hey. Here's what a typical day looks like in a dependency injection world. [SOUND]. Hey, what's up, Brittany? Hey, Cameron, what's going on? Well, I've got a lot of tires, any kind, any shape, any size. Great, and where do you sit? Over there. Okay, great, thanks. Cool. Hey. Hey. I just got in and I've got that- Okay, what do you got for me? Blue bricks? Okay, of what sizes? One by the ones. I think there's like a two by two. There may have been like a bridge four by- Okay, okay, you have it all. Got it. Where do you sit? Over there. Okay, awesome, great. Thank you. You're welcome. Hi. Hi. Reporting for duty. Okay, okay, okay. What do you have? How much do you have? And where do you sit? Red bricks. A whole bucket full of them. Over by the wall, third from the left. Okay. Thank you. Man, another prop for a course. [NOISE]. No. Hm. Hey Brittany. Hey what do you need babe, because whatever it is, I got it. Yeah, I need a prop for an upcoming course. I can do it, but I still need some red bricks, some blue bricks, and some tires. For the blockades I'll need- Okay, okay. I got it don't worry I'll be right there. Okay blue bricks plus red bricks plus Walter, tires. Okay. Quick we need blue bricks. Walter, Walter, Walter, we need red bricks. My god [NOISE]. Let's go. You need tires? Yes. All right, let's do it. Let's go, okay. Okay. He's got the red bricks. We got wheels right here. We got the other bricks right here. Okay, are we good? Yeah, we're good. Okay, I gotta go back to work. Thanks, Brittany. [SOUND] So that was a fun little skit to make. But dependency injection is an important architectural software pattern, and I want to make sure you understand what's happening. Instead of being in charge of all of the bricks and the tires myself, I just depended on these outside resources to be provided to me. Brittany, the injector in our real life app, knows where all of the information and services are. Whenever an app needs some service or information it tells the injector its requirements. Then the injector fetches those requirements and provides them to the calling code. Then the code uses those services to accomplish its task. Dependency injection is heavily used in Angular. We'll make use of it ourselves in the next video on Angular services. [MUSIC] Remember that a service is where you would put view independent logic. At first, services seem very similar to controllers, both of them provide data to an application. A major difference is that services are not intended for just one view. A service is not tied to a specific controller but can be used by any number of controllers. For example, this user service has information about the logged in user. And account controller could use the user service to supply data to its template and there's also the navigation controller which needs the user information. The user service can be injected into both controllers since it's just a source of data and functionality. In our app we might want data from the menu items to be displayed in other locations. So let's generate a service to detangle our menu data from this specific controller and template. Then we'll see how we can inject it into a controller. We can generate a service with the Angular generator by running yo angular service and providing a name for the service. Well this should look familiar since it starts out exactly like a controller. We get our apps module. Create a new service with a name. And then provide the function. Just like with controllers, when we call service on the module, this name and function are being stored with Angular's injector. When a controller asks for service with this name, Angular knows where it's located and how to create it. Since the food finder service will be in charge of all menu information, let's move this data to a JSON file and convert it to proper JSON. We'll use the food finder service to fetch this file. Let's create a get menu function and use jQuery to fetch the JSON file. So we've extracted the menu and set up the service. Now we just need to hook the service and the controller together. The format to inject a service into a controller looks a little odd. So let's take it step by step. First I'll highlight the entire function, then I'll copy it and delete it. To inject something into a controller we need to pass an array of things to inject. So add an array, give the names of the services we want to inject. For now it's just a food finder service. Then pace the controller back in. The service is now being injected into the controller as an argument. To use the service though, the controller needs to store it in a variable. So we'll add a variable with the name menu here. To get the menu we need to call foodfinder's getMenu function. Since getMenu uses jQuery, it returns a jQuery deferred object similar to a promise. We call then, and when our data gets returned, we can set it to this items. Since the this keyword is contextually based, this in here isn't the same as this out here. We'll just use lexical scope to fix this. Typically the variable vm for view model is used. And we're still showing the exact same information. But now the data is not tied to this specific view. There's no limit to the number of services that can be injected. Anything that needs to be injected comes first in the array. Then the function that's receiving everything comes at the end, and has variables for each injected service, in the same order. The Bricks a Bunch Store, and the Lots O Brick Store have been bought by the same company. Since management doesn't want to keep track of two separate inventories, we need to combine them. Your mission, should you choose to accept it, is to create a Brick warehouse service and extract each store's inventory to it. Make sure to inject this service back into each controller, so that the stores still have access to their information. Then create an add to cart button for the Bricks a Bunch items. Clicking the add to cart button should decrease the stock for the item by one. Since you're changing the stock for this item in the warehouse, the total count should change here and here. A link to this project is in the instructor notes. When you've completed these steps, the feedback extension will give you a code. Enter that code on the next page. I created the brick warehouse service with Yeomen, then I injected the service into both controllers. Since both controllers now have access to the warehouse service, I extracted and combined each store's brick data into the warehouse. The Bricks A Bunch store only sells red bricks, so I connected the store's red bricks with the warehouses. The Lots O Bricks store sells all bricks, so I connected each color to the warehouse's color. I decided to keep these names so that I don't have to modify anything in the template. Everything's the same now except that the inventory levels are shared between the two stores. Now I need to add that Add To Cart button. In the Bricks A Bunch template, I added a button that calls the controller's addToCart method, passing in the size. The controller just passes this data to the service. Since the service is shared by both controllers, when one controller changes the shared data, the other controller sees the change and its template is updated to reflect the new stock level. Services are a great way for two different views to share a common source of information. So our app isn't the most exciting or interactive website that's ever been created. Let's spruce it up a bit by adding an order manager to it that will track what we're eating each day. We'll build up this order manager with templates, controllers and a service. We'll need to create the service that will be responsible for managing the orders. This service will need to keep track of what has been ordered for each day. To do that we can create a simple object to keep track of each day's items. We also need to keep track of the currently selected day, so the user will know which day they're ordering a menu item for. For this service to be useful, it needs to manage this data. Consumers of this service should be able to get the current list of orders. They should also be able to get and set the active day. And last they should be able to choose an item for a meal and then remove an item from a meal. The order manager is now capable of tracking anything the user wants to eat for any meal. Let's create a template and control it to let the user keep track of their menu items. We need a template that will display our orders and a controller that will set the initial state for the template's expressions. Now let's add that template to the page. To get the data to our template we need to inject the order manager service into the controller. Remember we do that by passing an array of items to inject and then the controller function as the last item in the array. Now we can set the list property of the controller to the orders returned by the order manager. The controller is all set, so we can now start modifying the template. We want to show the orders for each meal and we want to repeat this list for every day. That means we need the ng-repeat directive. The first time through day will be Monday and menu category will be this object. So now let's add the data to our template. So we can now track orders but the user doesn't have any way to pick a menu item. In the menu template we'll add this section where the user can pick when they want to eat this menu item. And we'll need a button to let them actually pick the meal. When the user clicks on this button we'll send along the item's name and when they want to eat it. We'll need to create this choose item function. So in menu.js we'll create it. Order information is managed by the order manager service, so we need to inject it into this controller so we can pass along the data. Order manager already has a method to let us add an item so we'll just pass the data to it. Now we can select an item and choose when to eat it and add it to the order manager. How cool is that? Except we can only pick items for Monday. Let's fix that. In the order template we need to make it so that when we click on a specific day, we'll update the order manager's active day to that one. So if Tuesday's clicked, we'll pass that along and tell order manager to update its active day to Tuesday. We just made a bunch of modifications to our app and it's really starting to come together. If you got lost along the way, just step back and remember what we're trying to do. Services maintain our data. We inject services into controllers, so that controllers have access to that data. And then we display that data in templates. And again, services aren't tied to specific views or controllers as we saw with the order manager service that we injected into two separate controllers. Angular's got a ton of moving parts, but we finally made it to the last one we'll be looking at, routing. Up until this point we've worked with apps that have just one view. And that's fine, but it's not very functional or interactive. Single page applications typically have many different views or screens that you can interact with. A router handles loading these views based on the URL. When we generate an angular app with Yo Angular, it asks us if we want to include a number of modules. One of the options is angular-route. This routing module works well, but it's kind of limited since it doesn't allow for nested views. We want to have specific sections of the page update and change while the rest stays the same. So instead of using this angular-route module, we'll use the community built routing module called UI Router. The documentation for the UI Router module is incredibly detailed. Make sure to also check out the website in the sample app to see all of the functionality UI Router offers. Since UI Router doesn't come as part of the default installation, we need to add it to our project. The Angular generator uses Bower to install Angular. So let's use Bower to install ui-router. Don't forget to add the -s to save ui-router to the Bower config file. One of the files that's created when we generate an app with the yoangular command is a Grunt file. This file manages a lot of the development process, from watching files for changes to reloading the browser. One of the cool things is that it can pair with other commands, like the bower command we just used. When we installed ui-router with bower, grunt saw that and included it in our index file. Everything that we've been building up to this point has all been inside our udaciMeals module. We created the module and then attached controllers and services to it. Ui-router is a module itself and contains its own inner components. Back when we created our module we passed an empty array of dependencies. Now we have to add ui-router to that list so we can use it. Just like injecting a service into a controller, to inject one module into another we just add the name as a string. So this is injecting the ui-router module into our udaciMealsApp module. A word of caution though, all over the docs it's ui-router, but when you include it it's ui.router. This little guy's tripped me up several times. So watch out that he doesn't get you too. We've looked at why ui-router is better than the default router module. We've added ui-router to our project, and we've injected it into the udaciMeals module. Let's take a look at how to set up ui-router to manage the state of our app. Before the model is created, we can use a config method to configure how it gets set up. The config method takes a function. UI router includes a lot of functionality. Two components will be using our state provider and URL provider. We'll inject both of these into the config function. Providers are like services, but only providers can be used for a module configuration. We can now use state provider to set up the different states of our app. Let's start out with the default state and call it home. To add a state to our app, we call .state, give the state a name. Again we're gonnause home, and give it a configuration object. With the URL for the state. The template to use our app is already using the default template. So we'll link to that. And the controller to load for that template. Review state provider to set up a state for the app. We need to use URL router provider to load the home state by default. So the app state management is all set up. But there's one last thing, we need to tell UIRouter where to insert this template. We can do that with a directive UIView. We have access to this directive because we've included the UIRouter module into our project. UI router is now handling our app's state. Let's add a new state for an individual menu item. Let's create an item state. We also need to create the template and controller for this item. Pay attention to this right here, the colon id. We can use dynamic content in our routing. Let's quickly generate a template and a controller for an item. I've also created a few JSON files with more details about the menu items. When the URL is item slash some menu ID. The ID will be accessible in the either controller by using the state param service. We'll also add in a food finder service, so that we can retrieve the item. We'll use the get item function and lookup the item by its ID. Then when it's returned the JSON file, we'll set it to the item's data property. The get items function is very similar to get menu. Except that it gets a single item specified by the ID. Let's make the name a link to that item's detail page. UI Router gives us the ui-sref directive to switch between states. We want to switch to the item state and pass along a value. The state expects an ID which we'll set to the items ID. Now it's just filling out the template for the item. Let's have it show the item's name, the image of the menu item, and its rating and description. And now our app can be in the default state with the menu showing, or it can be in an item state. How awesome is that? The true power of UI router is in nested views. Let's add a nested view to the items detail page. Let's add a state to see an item's reviews and one for its nutrition facts. To add a nested view, we need the same name as the main view that this one will be nested inside. So that's item. Then we need a dot and then it's the nested views name. We need to generate both of these templates. But we don't need controllers because they'll just inherit the item's data from the parent route scope. Here's what we have for the nutrition template and over here is the one for the reviews. See that for the reviews template uses an entry repeat directed to loop through all the reviews. Lastly, I added some reviews to the item JSON file so that they'll have something to display. So UI router knows of the nested item and the templates to use. We need to tell UI router where we want these views to appear though. We need the UI view directive again. But since we want them to display on an items page, we need to add it to our item.html. Finally, we need to create a link for each view, and we now have nested routing. Nested views in at management can be very complex and complicated. UI Router makes this incredibly easy though. Our store is currently displaying all the information on the home page, but marketing needs a way to send customers to a specific URL for red bricks, one for blue bricks, and one for green bricks. The cart should also have its own dedicated page. To complete this quiz, you need to add the UI router module to the app, then configure the app so that loading each of these URLs displays the correct template. We currently only have a home link, so you'll also need to add a link to each of the brick colors and the cart. As a last step, create a nested route for each brick color that will display the cart if the user clicks on the view cart link. A link to this project is in the instructor notes. When you've completed these steps, the feedback extension will give you a code. Enter that code on the next page. Since all of these changes depend on UI router, I installed that first and added as a dependency to the apps module. I set up the configuration for the module and injected state provider and URL router provider. Next I added a home state and made sure that any unknown states redirected to the root floating bricks slash red is supposed to show us all the red bricks so I set up a state for that, this loads the bricks template and uses the red bricks controller. I did the same thing for the blue and green bricks. Notice that i use the same template for each, but each one has a different controller. I was able to do this because I set the variable name for each one to brick. And finally i added the current state. With all the states that have added navigation links to the index file. The links use the UIS ref directive and point to the appropriate state name. Each item now has its own page. But i still need to add the cart to each item page as a nested view. Remember that a nested view uses the name of the parent a dot and then its name, so I used redBrick.cart. Since this is displaying the same information as the cart page. I gave it the same template and controller. Then I created nested card pages for both the blue brick and the green brick pages. For the cart to display on the item page, I used ui-view again. And then I added a link to navigate to the nested state. Since all brick items share this view, I couldn't make this red brick.cart. Because that would load the nested cart view only on the Red Bricks page. So I left the main state dynamic by not providing it. So this will load redBrick.cart on the Red Brick page, blueBrick.cart on the Blue Brick page. And greenBrick.cart on the Green Brick page and we're done. For a bonus though there's a lot of duplication going on between the red brick, blue brick and green brick states. Instead I created one brick state that determines the controller to use by the URL. Since we only have one brick state now, I can clean up all the nested card states down to just one. Since there are no longer individual states for the items. I needed to update the links to pass along the data in the URL. This is a much more organized state management structure. Congratulations. You should be extremely proud of the work you've accomplished. Can you believe that a short time ago Angular was this other worldly entity? Now not only have you worked through a lot of Angular's complicated concepts like scopes and services. But you've built several applications in Angular. We've been discovering what Angular offers and how it works I encourage you not to stop here though. There's so much more to angular that makes it a fantastic framework. Go on and learn about the differences between services and factories. The application bootstrap cycle. The details of two way data binding by looking at how Angular Digest works. And creating your own custom directives. Let me know what you find. What are you still doing here? Go build something amazing. In the next lesson we'll be taking a look at Ember, a framework that helps you build ambitious web applications. Come back and check it out. [MUSIC] Hey, welcome back. Have you ever wanted a framework that comes with its own build tool, will automatically generate and maintain your apps file structure, and keep your templates and data in sync? Then you're probably looking for something like Ember. And we're now going to look at an Ember framework. As we go through this lesson, I encourage you to work through each of the steps yourself. Building up the app along with me. You'll learn a lot by watching me work through building a project, but you'll learn so much more if you build it yourself. Ember describes itself as a framework for creating ambitious web applications and boy does it help you easily create ambitious apps. It's an extremely powerful framework and is powered sites for companies like Netflix, Groupon, Discourse, Twitch, Yahoo and even Microsoft. So Ember will be able to handle anything you could throw at it. Ember enables you to create powerful apps with ease because it favors convention over configuration. You have to name and organize your files a certain way. Depending on the kind of file, you also have to place it in a specific location in the project's file structure. At first, this might seem daunting to maintain, but using Ember's command line tool, it couldn't be simpler. Another benefit of this strict app organization is that every Ember apps structure is the same, and developers new to your team will be able to jump right in. Doesn't Ember sound awesome? Let's get going so you can build your next project with this powerful framework. Ember is an advanced framework built by and others who are pushing the boundaries of the JavaScript language. So Ember makes use of JavaScript language features that sometimes haven't been standardized yet. When building Ember apps it's important to know how to use JavaScript promises which makes it easy to write and manage asynchronous code. ES6 modules, some files in an Ember app are included into other files using modules and imports. And ES6 Syntax. Features like arrow functions, destructuring, and template strings. But don't worry, this isn't too important because we can write everything using standard ES5. We have a course on promises, so check that out if you have any questions. Links to these topics are in the instructor notes. Ember CLI is recommended by the ember team as the de facto way of building and developing a new amber application. It's incredibly powerful, and we'll be using it to generate our ember app, create new template, and component files, and maintain and update new routes. You can do a lot more than just these tasks though. So let's see what it can do. Running ember --help gives us a list of subcommands with their own set of options. There's a lot to scroll through but we can do just one comment at a time by using the help flag. And passing the name of the sub command. I'm going to clear the screen so that there's not all this clutter. Then to see just the new command. Run ember -- help new. Ember new is the command we will use to create a new app. Notice that running this command will create a new directory. I like to keep stuff I work on in a project's directory. So when i use ember to create a new project, it'll create the app's folder in here. Let's create our app. A name is required, so let's give it the name UdaciMeals. This command does a number of things. It creates an Ember app's default file structure. Creates an initial commit. Runs npm install. And runs bower install. Installing the dependencies can take quite a while, so I'm just going to pause for a second until it's finished installing everything. And it's finished. Let me clear the screen again. Another thing that Ember CLI includes is a built-in server. We don't have to worry about installing a server or dealing with some third party code. This is really awesome. But the server needs to run inside of our project, so we need to move in there. Running Ember serve will start the server. We can view our app at localhost:4200. Switching to the browser shows us our Ember app with some starter content. An entire development server in just one command, isn't that awesome? Ember CLI is an amazing tool that's always in development, sometimes a bug will pop up from time to time. While recording this video I ran into a bug myself. There's a story about it in the instructor notes. If you have any problems with Ember CLI check out the project's issues on GitHub to see if a fix is already in the works. Or check the forums to see if what you're running into has already been solved. Ember-CLI has a number of shortcuts and aliases for its commands. For this quiz, I want you to explore some of the options that the Ember command provides. Use the help flag to learn if the command on the left does the same thing as the command command on the right. If ember serve -- port 9001 does the same thing as ember s- p 9001 then check this box. If ember new amazingProject does the same thing is ember n amazingProject, then check this box. If ember -- help does the same things and as ember help, check here. And lastly if ember generate component menu is the same thing as ember gen component menu, check this box. Both of these commands do the same thing, so this one is true. The new command does not have an alias, so running this command will not work. These two also do the same thing, so this is true. The generate command does have an alias, but it's not gen, so this is also wrong. Generates alias is just the letter G. We'll be using it often to build our app. Professionals try to do as little work as possible while achieving the same outcome. Why work hard when you don't have to? We'll be generating a lot of files and typing out the letter G is a lot faster than typing out the word generate. Ember gives you these shortcuts for free, so use them. Here's the project in Adam and let's look through some of the files it gives us. We've got a bunch of files for set up, package managers and testing. Up in the directories the important ones are public, dist, config, and app. You put your static assets like font files and images in here. When you're ready to move your site to the web, Ember can build and bundle everything together and put it in here. Configure is where you add code that changes the configuration of the project or if the project needs to change based on the environment it's in. But probably 99% of your time will be spent in the app directory. Let's go through it. Ember is highly dependent on routes. So router dot.js is not hidden away in a folder. We'll be looking at routes and routing next. Here's the apps index file, we actually won't really be touching any of this. Here's the project's main set of file, we also aren't going to be doing anything in here either, templates are very important to Ember. Any HTML we write will be in here. Remember when we looked at our app in the browser and it said welcome to Ember? That file is right here. Styles is for where we can put any custom CSS for our project. I said routing is important to Ember. Not only is there router file, but there's also this routes directory. This is where individual route files will live. We'll be looking at this next. Models is where we would put schema files for the apps data. If we want to add additional functionality to our templates, we'd create helper files and place them in here. In Ember, controllers are very similar to components and are actually being phased out in future versions. So we won't be working with controllers. Ember makes it really easy to create our own custom HTML elements. It refers to them as components. The functionality goes in here, while a component's HTML file goes in here. All of this was generated with the ember-new command. Ember favors convention over configuration, meaning that Ember has its way of doing things and as long as you do it the Ember way, you won't have to worry about configuration. An example of this is where to put a file and how to name it. A component has to live in the components directory and be named a certain way. We don't want to worry about all of embers conventions though, so we'll just use embers CLI to generate and maintain our files. The first thing to do with a new app is to set up routing. So let's set up some routes. The first step to learning Ember is to understand how routing works. When an Ember app is loaded, the router's job is to match the URL against the list of routes. When it finds a route, it loads that route's route file and renders the associated template. Right now the base route loads the application template, but we can add to the list of routes that Ember manages. We can add a menu route that loads the menu template. Now, menu here and menu here don't have to be the same. This is what's matched against the URL, and this is the name of the template. We could just have easily have named the template something like food. So we have our application view and we can display our list of menu items, but we want to be able to view just one item at a time. There we go. Now, /item/strawberry-pudding will use the item template. That was easy, except what about when we want to view the chicken salad? We don't want to create a route and template for every single menu item. We can use Ember to make URL matching dynamic. Instead of listing each route to look for, we can do this. Ember calls this a dynamic segment and will match anything between this slash and the next one. So the router captures the dynamic segment and passes it to the item route. A route file is where you put the business logic for a template. The template is then rendered with data from the route file. Awesome. We've looked at how routes pair with templates and what dynamic segments are in a route. Let's take what we've learned and start building out our app. Wait a minute! Remember, we don't want to create routes and template files by hands, we're too lazy for that. We'll use Ember CLI to create everything for us instead. Let's generate a route that will handle things when the URL is slash menu. So we'll use Ember's generate command, but remember that generate has an alias of just g. So I'll use that since it's shorter, and we want to generate a route. And we want that route to match the URL menu. This commanded a number of things for us. We'll skip these first two for a second and come back to them. Notice that the generate command we just ran modified the router file and added this line here. This menu route we'll call the menu.js route file and then load the menu.jshbs template. It also created a file for testing. This is why Ember CLI is so incredibly awesome. It did all this force with just one command. So the generate command added just this line to the router. This menu route, loads the menu routes file, then it loads the menu template. We'll come back and look at these files in detail soon, but first let's add some content to the template file so we can see something in the browser. I've added this HTML here with headings and images for a few menu items, I've also included the image files and a bit of CSS. Back in the browser, we don't really see anything. Hm, when working with routes and templates, make sure you're actually loading the correct route. Adding menu shows us the template. Awesome. Ember is constantly improving, which is really great because there's an active community and bug fixes are usually just one update away. But that also means the API might change suddenly. So it's very important to know about Ember's documentation and to refer to it often. Using Ember CLI to generate a route will create a route file and a template file with the same name, and that's what i've done here. For this quiz, I want you to use the Ember docs to create a route that matches Lego, but loads the bricks template. Here are the specific instructions for this quiz. A link to the starter code for this project is in the instructor notes. When you finished building the template, the feedback extension will give you a code, enter that code on the next page. Ember uses the queue unit testing framework, and I have created a number of tests that you need to satisfy. These tests help guide you through completing the assignment. Once all the tests have passed, the feedback extension will give you a code, enter that code on the next page. You can find a link to this project's test page in the project's read me file. As you're hopefully coming to realize, everything starts with a route, so the first step is to create the bricks route. According to Ember's documentation, we need to pass an object with a path property as the second argument to the route. This path property is what the URL will match against. This is what needs to be Legos, not this. So the Legos path uses the bricks route file and the bricks template. In the bricks template I've added the required HTML and I'm done. Making Ember load a template that's named differently from the URL is straightforward but has always seemed a little backwards to me. Make sure you don't get tripped up between the order of the two of these. The first are the route file and template that will be used, while the second is what the URL will match against. Let's create a route where we can view the details of each of our menu items. Remember that all of the items share the item template. Let's generate the item route. This updates the router, creates an item route and template file and a test file. Remember that this is just shorthand for this. To add a dynamic segment for this route, we need to modify the path. Remember that dynamic segments have to start with a colon. This will hold the name of the menu item. Let's add something to the item template so we'll have something to see. I'm hard coding in a menu item's name, image, rating, and description. We need some way to get to the item page from the menu, so let's add a link to each item. Now we can get to an item's detail page. Right now though we've hard coded this menu item into the item template. So even if I try to view the strawberry pudding, I'll still get the ham and goat cheese croissant. We'll fix this in a bit. We currently have a main view which shows nothing, a menu view, and an item view. Let's say that an item has stats, like nutrition facts, but we only want to show them if the user wants to see them. Better yet, what if we want to send a link to a friend that takes them right to the strawberry pudding's nutrition facts? We can do all of this with ember's nested routes. Ember's nested routes are really powerful, and make building seemingly complex applications, well, actually pretty easy. When I think of a template, I think of just a chunk of standalone HTML. Ember templates can also be thought of as containers. The base container is the application template, and contains all other templates. Any site-wide HTML should go in here, like a site's header, navigation, and footer. The menu template is contained inside of the application template, and the item template also goes inside the application template. We want to create a nutrition template that's contained or nested inside of our item template. Everything starts with a route, and that will be item, and then the dynamic segment, which will be the menu item's name, and then nutrition. How does amber know how or where to insert the item template into the application template, or nutrition into item? We'll look at that after we generate the nutrition template. Let's create the nutrition route, and have it nested inside the item route. Again, ember CLI updates the router, and creates a route file and a template in a new item subfolder. Notice that nested routes are created inside a function that's been added as a last argument to the containing route. Let's add some content to the nutrition template, and let's add a link in the item template to the nutrition view. Fantastic, the app's really starting to come together. The application template contains item, and item contains nutrition. Do you see these here? This tells ember to insert nested templates right here. You can do anything with this code, though. Move it anywhere you want, put it inside HTML, or even delete it. Careful when deleting them, though. If I delete this one, then no other templates will show up, since they don't know where to be nested. So I'll return each one to the way it was. The way ember handles nested routes is one thing that makes it a fantastic framework. So it's important that you're comfortable both generating nested routes and working with them in a nested format. We're going to be working with our toy store again. You're going to be working with nested routes and then modifying their templates. Here are the instructions for this quiz. Make sure to go in order, If you try to do this second step before this first one it won't work and you'll get a blank page. So start at the top and work your way down. The link to the starter code for this project is in the instructor notes. When you finish building the template, the feedback extension will give you a code. Enter that code on the next page, have fun. Ember uses the queue unit testing framework, and I created a number of tests that you need to satisfy. These tests help guide you through completing the assignment. Once all the tests have passed, the feedback extension will give you a code. Enter that code on the next page. You can find a link to this project's test page in the project's read me file. Okay so the thing we need to do first is generate these routes. Without them we can't do any of these other steps. We need a route for toys, and another for bricks. Now we need the nested routes red and blue. Remember that to nest a route within another route, it's the container route name, a slash, and the nested routes name. [BLANK-AUDIO] Now that we have the routes, I can have the navigation links. Remember that the application template is the outermost containing template. So I put the links in there. Here's the link for the instructions. So, I'll add it right after this. Now it's just filling out the individual route template files. The bricks template also needs links to the nested route so I'll add those. Remember that the nested routes are in their own directory. I'll update them with their required text. We've touched three layers of templates in this quiz. The application template that contains all others. The toys and bricks templates, which are both nested inside of the application template, and then the red and blue brick templates, which are nested inside of the bricks template. Nested routing can be a complicated project. With ember though, it's incredibly easy to create and work with nested routes. Welcome back, everybody. Today we have Allan with us here. Allan, describe some problems when you're first working with a framework. What did you experience? When you're first learning a framework there's a lot of overhead that you need to learn that's specific to the framework. I mean, it's not just like learning a language. Take for example AngularJS. Even if you are an expert in JavaScript, you can't start off right off the bat developing AngularJS. There's some nuances or a caveats or things that are done differently within those different frameworks. Like for example, AngularJS has different modules, factories. It's interesting, for some frameworks, in order to print, hello world, to display on a web page, you need multiple lines of code. Whereas like if you're just dealing with straight HTML, CSS and JavaScript it's pretty simple to do. So for students that are just starting out into the world of frameworks and trying to learn their first one, what would be some advice you'd give them? I would say, first and foremost, you need to be very comfortable with the language. Each framework kind of ships, or usually ships, with their own DSL or domain specific language. But if you don't understand the base language, you're incurring a lot of technical debt, professionally as well as personally. As far as advice to extend generally to any framework and students jumping into it, another thing I would recommend is definitely do not be afraid to jump into the documentation. It's supposed to be your mainstream or largely-supported frameworks. The documentation is excellent. Take for example, AngularJS or Ruby on Rails. You should have that bookmarked and always, always visit it. I mean, if the documentation's good then most of your questions will be answered there. So you've worked with a couple of frameworks. >From learning your first one, what was it like transitioning to a new one? A good question, so when you're transitioning frameworks, you don't lose all the knowledge that you gained from learning that initial framework. And part of the value of learning frameworks is that a lot of the best practices are kind of built in, if not forced on you with configuration, or with convention, rather. And so you're able to translate a lot of those best practices to other frameworks. Or even if you don't have a framework, you can build your application with some of those best practices that you learned from previous frameworks. Okay, so learning your first framework might be a little tough, but then the slide is a lot easier for learning a new one. Yeah, there's a lot of design patterns that are common throughout frameworks. For example, MVC, model-view-controller, that's something that exists across most of our front-end frameworks or our full-side frameworks. Okay, so learning your first one might be a big push, but then after that, then it's a lot easier to switch to a new one and learn a different style of framework. For sure, every framework's different. They all have their different nuances and caveats, but the general themes and best practices are pretty consistent across all of them. Handlebars makes it really easy to create concise and expressive templates. Pair that with dynamic data in a simple handlebars template can handle a lot of information. We'll look at loading dynamic data after this quiz. But for now, I've done it for you and saved the data to a variable named model. For this quiz you need to use this model variable which has all of this information and build out a handlebars template that displays all of it's information. You'll need to use HTML, Handlebars expressions, conditionals, loops, the whole nine yards. Make sure to build the template in the stores.hps file. I've already created this file for you so all you have to do is worry about building out the template. Here are the instructions you need to follow. One thing to be extra careful about is to give everything the correct class name. Let me give you a quick preview of the end result. I have a section for red, blue, and green bricks. And each color has its own set of bricks. Some of the bricks are on sale and I indicate that here. Remember that all of this information is already provided for you in the model variable. You just need to create the handlebar's template. A link to the starter code for this project is in the instructor notes. When you finished building the template, the feedback extension will give you a code. Enter that code on the next page. Ember uses the queue unit testing framework, and I've created a number of tests that you need to satisfy. These tests help guide you through completing the assignment. Once all the tests have passed, the feedback extension will give you a code. Enter that code on the next page. You can find a link to this project's test page in the project's read me file. I was able to get all of this functionality in just 11 lines of code. I'll show you what I did and we'll see how your solution matches up against mine. Remember that the data is stored in a model variable. I'm going to get a copy of all of this, so I don't have to keep switching back here to reference the data. I switched in my code editor, and I have the store handlebars template here, and this scratch file with the data for reference. Read a section for each one of these items. Handlebars gives us the each block to let us loop over information, but what are we looping over? Remember that this data is stored in model. So we're going to be looping over that. The first time through the loop, item will be this object. The second time, it'll be the blue bricks object, and the third will be green. Then it's just accessing the properties off of the item object. We also need to display each of the bricks. So that means another loop. Notice that this is in each loop, inside of another each loop. Handlebars can handle some pretty complicated structures. To keep things organized, I put each brick item in its own container div. The template is now displaying all content. The last thing to do is handle the bricks that are on sale. Since not all of them are on sale, we need to check which ones are on sale before adding the class. So we'll use the if conditional expression. So if the item is on sale, we'll give it the on sale class. If it's not, then we don't do anything. And that's it. Once you learn the basics, handlebars is an easy to write and easy to read templating engine. And it's baked right into ember templates. Pretty neat? As things stand right now, the app's templates are just displaying static HTML. So no matter which menu item we view, we always get the same one. If you recall, every time we generated a route it updated the router, created a template for that route and created a new route file. In addition to everything else routes do in Ember, they're also in charge of loading the data for that route. The data, or model, is set or fetched by this route file. Let's update our app to not use static html, but instead use dynamic data set by the route file. When the URL is /menu, this line matches. It calls the menu route and loads the menu template. This is what a default route file looks like. Some things that are important are that we have access to the Ember object, up here, and that when this file is used the Ember route class is extended with an object that we can customize. A bunch of things happen when a route is loaded, and Ember gives us specially named functions that we can use to hook into these specific events. Ember gives us a number of different hooks that we can use in a route file. One of the most important hooks we can use to gain access to the loading of new data is model. This hook is responsible for returning the model or data. Remember what's being returned is an object. If this syntax looks weird, it's the newer style of JavaScript to write this. Since Ember lives on the freshest version of JavaScript, I'll stick with Ember's standards and keep my route hooks like this. I've extracted the data for the menu items into a json file in the public folder. This file is available in the instructor notes. Now, we can use the model hook to retrieve this data file. The Ember object has j query aliased to the dollar, so we can use j query to get the file. Because this is the route model, the data in the template is stored in a model variable. There's a handlebars helper log that we can use to log out a variable. Here's that object logged to the console. And here are the three menu items with their data. Now that we have dynamic data set from the route, let's update the static template with expressions that will evaluate this data. First we can get rid of these two and leave just this one list item's HTML structure. Then let's use that each helper to loop over the model. Now it's just updating the static text with their dynamic counterparts. These two will change to item.name. The image here is item.image and the link will use the item's ID. Everything still looks the same but now it's being dynamically fetched and displayed. Great work. I've created a JSON file with data for each of the menu items. These files are in the instructor notes. The process to get a menu item's data is almost exactly the same as what we just did with menu. When the URL is item/ some item name, Ember calls the item route. Again, we use the model hook to fetch the data. But how will Ember know which item to get? The item will be stored in item_name. The model hook is passed a params object and we can get the item name off of that object. Now let's update the item template. Just like updating the menu template, we need to replace the static info with the dynamic data provided by the JSON file. Remember that the data returned from the model hook is stored in a model variable. And now we can finally see the other menu items. Awesome. Have you noticed that clicking back and forth, though, shows us a blank page for a few seconds? Let's fix that. The problem is that we're using an anchor tag to link to specific URLs instead of letting Ember manage the URLs for us. Ember provides us a template helper called link-to. The link-to helper needs to know which route it should link to. We want this link to link to the item route. So item should go here. The item route needs to have an item, so we need to give one to the link-to helper. One thing that would trip me up in the beginning is that this one needs quotes, but this one doesn't, since it's using the local item variable. Using link-to with nested routes is very similar. Because the nutrition route is nested inside item, the route we need to reference in the link-to helper is item.nutrition. We don't need to worry about which item to use, because to display the nutrition template, we'll already be on this item page. Ember knows that and handles that for us. For more information on the link-to helper, check the link in the instructor notes. Now there are no page refreshes and all transitions are smooth and instantaneous. And what's cool is that the back button works with all of this too. This one's going to be a two-parter quiz. For this first part, you need to create the website for a bakery and fill it with some static content. The website will need routes for the store and then routes for some of the things it sells, such as cakes, cupcakes, and cookies. Once you've generated all these routes, add an additional link for the store's home page here. Each route will need a heading so make sure you review these instructions for exactly what to put as the heading for each page. You're going to fill out the cookie page with some actual content. I've created this table for you with some data that you'll need to use on that page. Let me give you a quick preview of what I came up with for this first part of the quiz. I have a store route now, the store has links to its baked goods. All of these are nested routes. Clicking on the cookie link displays all of the information from the instructions. As you can probably tell I'm a world class designer, so I hope you can make your website look at least half as good as this. Actually I highly doubt you could make it look any worse than this. But the goal is more practice with generating routes, working with nested routes and creating templates. The link to the starter code for this project is in the instructor notes. When you finish building the template, the feedback extension will give you a code. Enter that code on the next page, good luck. Ember uses the queue unit testing framework. And I created a number of tests that you need to satisfy. These tests help guide you through completing the assignment. Once all the tests have passed the feedback extension will give you a code. Enter that code on the next page. You can find a link to this project's test page in the project's read me file. First things first with an Ember app. Nothing happens without a route. So we need to generate all of the routes first. Now that the routes exist, we can add the link to the store in the navigation. The nav is in the application template. Here's the home route. So I'll add the link to the store right next to it. Loading the store route should give us links to the different types of baked goods. So we need to add links to each one. There we go, now to add the headings for each page. The cakes template gets the heading All Cakes. The cupcakes one gets All Cupcakes. And the cookies one gets All Cookies. And we're almost done. We just need to add the HTML with the cookie data from the instructions. I've gone ahead and filled out all of the data. Notice that there was a lot of duplication going on to display the information. We'll take care of this duplication and these hardcoded values in the next quiz. This is the second part of the two-parter quiz. In the first part, you created a store app with static content. In this second phase of development, you'll need to convert the app to a dynamic one. To do that, you'll need to create a JSON file with all of the cookie data. Make sure to store it in the public folder so that the route file can access it. Once the JSON file exists with the correct data, update the cookies route file to retrieve that data. It should return an array of objects, one for each cookie. In the last step, you'll want to update the cookie template to remove all the hardcoded data. The link to the starter code for this project is in the instructor notes. When you've finished, the feedback extension will give you a code. Enter that code on the next page. Ember uses the QUnit testing framework, and I've created a number of tests that you need to satisfy. These tests help guide you through completing the assignment. Once all the tests have passed, the feedback extension will give you a code. Enter that code on the next page. You can find a link to this project's test page in the project's readme file. All things start with a route in Ember. But we already have our routes, so there's nothing to generate. We need to take all of this data and move it to a JSON file. Here's the file that I created. Notice that it's an array of objects with one object for each type of cookie. I put this file in the public folder inside of store directory. Now that we have data that can be retrieved we need to update the cookies route to get this file. Remember that a model hook is where we fetch data for route. I'll use jQuery to get the JSON file which then gets returned. And that's actually all we need to do in this file. Pretty simple? Now that the cookies template is being given the data we can replace all of this with the dynamic content. Since the data is stored in an array we can use an each block to loop over the data. Since we're looping we only need one of these containers. Each time through the loop, the cookie will be stored in this cookie variable. So I just need to replace these hard coded values with an expression. There we go. We've removed over half of this file by cutting down on duplication and instead, looping over the provided data. Typically you won't retrieve your data from a local file. You'll usually fetch it from a database, API, or third party website. But the steps are pretty much the same. You fetch the data in the model hook, you return it, and then you consume that data in the template. Ember makes all of this pretty seamless and easy to use. The code here inside the each block is understandable because we've been working on this code for a while, but if you take a step back and try looking at it as if you're a new developer to the project this code isn't all that semantic. It doesn't describe what it is. What if we could replace all this code with this? with Ember we can this is a special kind of expression called a component. A component is powered by its own template in JavaScript file. Let's create this menu item component. A requirement for components is that their name has to have a dash in it, so we can't create an item component, so let's name it menu item instead. This creates the component file that lives in the components directory and a template file for the component that lives in the components directory which is in templates. Converting this code to a component will take several steps. First, we need to move the HTML from here to here. Then we need to call the component. Think of a component as a closed box where no information from the outside world can get in. So even though we're using the ID invariable here, this item doesn't have any connection with this one. So all of these look ups fail. We need to pass the variable on the outside to the one on the inside. There, now the item inside the commode and has its data passed in from the outside. And just so you know these two don't need to be the same thing. I could have named this one food and updated all of these to food too. And now this would still work. We still have one last step to completely transition to using this component. Components are like custom HTML elements, and have a default dom element of a div. We need to update that to a list item. In the component file, we need to add a tag name property, and set it to li. Since the list item also has a class, we can give the component a class with the class names array. The component will now automatically be wrapped in an li with this class, so we can remove them from the template. Now we have a more semantic and descriptive menu template. If a new developer comes along the easily be able to understand what's going on. And if they want to alter what html is being used for this menu item, there's a dedicated template for that. A couple of quizzes ago, you used data returned from a route, and marked it up with HTML and Handlebars expressions. This is what the app looked like at the end. Here's the store template that I ended up with after completing that quiz. For this quiz, you need to create a Lego brick component that replaces the content here in this inner loop. So the code in the inner loop needs to be replaced with a new Lego brick component. With a new component make sure that the resulting HTML structure looks like this. Each color has a section and a heading. Each brick component has its own container div with the necessary classes. The component then displays the bricks info. The on sale class that's used might be a little tricky when converting this to a component, check the instructor notes for some helpful links. The link to the starter code for this project is in the instructor notes. When you've finished, the feedback extension will give you a code, enter that code on the next page. Ember uses the queue unit testing framework. And I created a number of tests that you need to satisfy. These tests help guide you through completing the assignment. Once all the tests have passed, the feedback extension will give you a code, enter that code on the next page. You can find a link to this project's test page in the projects read me file. I'll use the generate command to create a new component. Remember that Ember requires a component to have a dash in its name, so it has to be lego-brick, not just brick or lego, or lego brick without a dash. It has to have that dash in there. I like taking things step by step, so let's extract all of this inner loop data over to the components template. Now to have this code show up, all we need to do is call the component. Remember that variables in a component are blocked from the outer scope. So these have no meaning. So for the brick value in here to be equal to this one out here, we need to make that connection. Now the inner brick value is equal to this outer brick value. Remember that, by default, the component wraps all of its content in a div. Since this div is also here we have an extra unneeded layer. We can remove this div, but then we'll lose our styles. To fix this, we'll apply a class to the component in the components file. I'll move these classes to the components className property. But how do we work with this class? To handle this, we need to use the classNameBindings property. This checks a property and then applies a class. To have it check the item's sale value, we need to pass this value into the component. Inside the component, the sale property is the value stored in item.onSale. Back in the component file we can check this value. If it's true then we can add the class on-sale and now we can delete this wrapping div element. We still have the same end visual result, but now all of the brick content is located in one place. So we've separated our concerns and have a dedicated file to update when things need to change. Great job. All app is almost complete. As a last feature, let's give our users a place to record the menu items they've selected for a specific day. Here's our app in its current form. It displays menu items with the title, image and details link. We want to add in order tracker that will track what menu items have been picked for a specific day and meal. To keep that modular we will create this new feature as a component. We also need a way to let users choose the item and the meal. So let's add a drop down with options for breakfast, lunch, and dinner and a choose button. When we create the order tracker component, we'll have HTML that will display the selected menu item, for a meal but how do we or how does Ember keep track of this information? We need some data structure that will keep the two of these in sync. This is what a service is for. An Ember service is an object that can be used by different parts of an application. If Monday is the active day, then picking strawberry putting for lunch will update the service. The order tracker is consuming the service and will see this change and update itself. So this order management tracking feature is what we want. Let's build it. Remember that components must have a hyphen in them, so let's name the component order-tracker. While we're here, let's create the service, too, and let's call it order-manager. The order manager service needs to keep track of the active day. We'll have the active day default to Monday. The service will also need to manage the orders that have been placed. I've created a menu selection object that will hold the orders for each day. So this is the data that the service will need to manage. Now we need to give it some way to update this data. The service needs to be able to change which is the selected day. It also needs to add an item to the selected days meal. And then it needs to be able to remove an item from the menu. Remember that we're extending the service class with an object. So inside a function we can directly access one of the data properties. Instead we have to use Ember's this.get to access a property. Or this.set to change it. Here we have the order tracker component and its template file. We want the template to be able to use this data, so we need to make a connection between the component and the service. We use Ember to get the service and stored in the order manager object. It's all very readable, we inject this service into this component and refer to it by this name. Now in the order tracker template we want our users to know which day they're picking food for. So we reference the orderManager object and then the selectedDay property off of the service. Now let's add this component to the application template. And while we're here, let's change the heading to make it something more exciting. I had to restart the server on the terminal for the changes to take effect. So if you don't see the data from your service, make sure to restart the server. And here's the order tracker template that's pulling the data from the service. We also want to display the menu item that's been ordered for each day, so let's add that to the template. We need to display entries for every meal, so I've added breakfast, lunch, and dinner. We want this information for each day so we need to loop over the list of days. Let's use Ember's each in helper to loop over the days storing the key as day and the days order as menu order. Let's use these variables to print out the day and the chosen menu item for a meal. So here we're printing out the day. And here are the menu items for breakfast lunch and dinner. And there we go. We're showing a meal time for each day. Now to add a button to each menu item, so we can select it for a specific day and meal. Business has been really good, so the bricks a bunch stores expanding. The existing Lots O Brick store currently only sells blue and green bricks. Management wants the Bricks A Bunch store to still sell only red bricks. While the Lots O Bricks store should sell its blue and green bricks, and red bricks. These two stores need to share the same number of red bricks. For this quiz, you need to create a brick warehouse service. Both stores should have access to this service. Brick information should be extracted from each store, combined, and put into the service. Here's the specific information that you need to follow. The link to the starter code for this project is in the instructor notes. When you finished, the feedback extension will give you a code. Enter that code on the next page. Ember uses the queue unit testing framework, and I created a number of tests that you need to satisfy. These tests help guide you through completing the assignment. Once all the tests have passed, the feedback extension will give you a code. Enter that code on the next page. You can find the link to this project's test page in the project's read me file. Let's use the Ember CLI to generate the service for us. Now that the service exists, we can move the data from the individual routes into the service. The instructions say to put everything in a bricks property, so I'll just move everything over. So here's the data from the bricks a bunch store. And the blue and green brick data is from the lots of brick store. We're actually almost all done with this quiz. Now that the warehouse manages all of the data, each route just needs to be updated to retrieve the data from here. I've injected the brick warehouse service into both route files, and I'm referencing it as just warehouse. Now instead of having all of this hard coded data, let's just get it from the warehouse. In the bricks a bunch route, I'm calling this method, that I need to create on the warehouse, service. This just returns the red bricks from the list of bricks. I'm making this method on the warehouse instead of accessing the red bricks directly, because we want our warehouse to be in charge of handing out the data. This way, if the service needs to record whenever the red bricks are accessed, we can just add a line to this function. It's a separation of concerns. The service is in charge of all the data and the route just asks the service for data, instead of accessing it directly. Let's do the same thing with the lots of bricks route. Just like with bricks a bunch, I've replaced all the hard coded data with a call to a method on the warehouse. This function needs to be created over there. So all this function does is return the complete list of bricks. So, visually speaking, our app is the same to customers. But architecturally it's more organized, with a service being in charge of all of the data, and the routes are just accessing that service. Now go forth and make your apps more organized with services. Let's add a drop down so the user can pick when they want to eat the menu item. I've added a dropdown with options for breakfast, lunch, and dinner. Now we just need a button. There we go. We're now set with all HTML content. But choosing an item still doesn't make it appear up in the order tracker. Let's wire the different parts of our app together. Ember controls user interaction through actions. The default action is a click. So adding this action to our button will listen for a click. It'll call the chooseItem function and pass along the item's name. This function is defined in the menu items component's file inside an actions object. Let's set up the action and action handlers. Clicking the button now calls this function with the items name. We need to create this function in the Component File. All actions need to be inside an actions object. Note that this is actions with an s while this is action without an s. the function is called choose item and it receives the menu name. When the button is clicked. The order manager service needs to be updated with the new selection. We don't have access to the order manager in this component yet. So we just need to inject it. Now have access to the order manager service under this name to update the service when the bun is clicked, we first get the service and tell which meal to add the item to. Remember that this method already exists on the order manager service object. I've hardcoded the default meal time to breakfast but users really should be able to choose the meal. I switch things around to use this property which still defaults to breakfast but with this set up we can use the template to update this property. This adds an action to the select element that fires on change instead of one being clicked. It calls the change category function and passes along the value that was selected. The change category function just updates this field. Now we can choose a menu item and have it show up in the order tracker. How awesome is that? Now we just need a way to let the user cancel one item and change the active day. We'll add both of these to the order tracker component. So if a menu item has been picked for a meal, we want to let our users cancel it. This will check if a menu item has been picked. This is just an x symbol that, when clicked, will remove this day's breakfast item. Let's create this action handler in the component file. This remove function tells the order manager service to remove the menu option for the meal time of the past and day. To let users choose the day they're adding meals for, we'll add an action to this div. Remember that we're looping over each day of the week. So this day will change with each loop. Clicking this div will call this action passing along this day. The set day to function just tells the service to update the selected day and we're finished. Our app displays content handles user interaction and manages data and it does all of this instantaneously and with no patriot precious. This project is in the same state as we left off last time. There's a Bricks A Bunch store and a Lots O Brick store. And both of them get their data from a service. What you need to do is add a cart feature that will list everything in the cart. There won't be anything in the cart by default, so you'll also need to add a button to the Lego brick items that lets a customer add the brick to the cart. Here's the specific information that you need to follow, the link to the starter code for this project is in the instructor notes. When you've finished the feedback extension will give you a code. Enter that code on the next page. Ember uses the queue unit testing framework and I've created a number of tests that you need to satisfy. These tests help guide you through completing the assignment. Once all the tests have passed the feedback extension will give you a code. Enter that code on the next page, you can find a link to this project's test page in the project's read me file. You're probably getting sick of me saying it but everything starts with the routes so we need to add the cart route. And since we're already here let's generate the shopping cart service. Now we can add the navigation link for the cart in the application template. I've added some fake cart content for now so that we can work on the cart template. To get access to this data in the shopping cart. The shopping cart service needs to be injected into the cart route. There we go and now we'll return all cart content from the model hook. This get cart function just returns the contents of the shopping cart's cart property. It's simple enough, but allows us to separate our concerns. Now that the shopping cart's data is being passed through the model hook to the template, we can loop over that data and display the brick's color, size and price. The store now has a cart page, and shows us the default content returned from the shopping cart service. Now we need to create and add to cart button for the brick items. I've added this button that calls and add to cart function when clicked. This function will need to know about which brick is being added so we need to pass along the color, size and price. Let's create this function. Remember that action functions go inside an actions object. To add this data to the cart, we need to access the shopping cart service. Now that we have the shopping cart, we can add this data to it. The addToCart function gets the cart, and then adds an object with the brick data to it. Since we can now add items to the cart, let's clear out this default data. So the cart page doesn't display anything since the cart is empty. But adding an item to the cart causes it to show up on that cart page. Perfect. The last step is to decrease the quantity when it's added to the cart. Everything's already set up to handle when the button is clicked on, so we just need to tell the warehouse to put one item on hold. We're telling the warehouse to reserve one brick with this color and this size. This first line gets the current quantity and decreases it by one. The bottom line sets the quantity for this specific brick to the decreased size. And with that we're done. The app handles user interaction and passes information to different parts of the app using services. Great job. You've done amazing work. Really, you should be proud of all the hard work and effort you put into learning Ember. You've worked with Ember CLI, Ember's file structure, the handlebars templating language, components and templates, consuming services, and handling user engagement with actions. You now have a solid foundation to continue learning more about Ember. Yep, there's still more to it, but the Ember docs are full of helpful information. I hope the app we created is your first of many Ember apps to come. As you're working on your next Ember project, make sure to share with me, and the other students in the forum. I can't wait to see what you create.