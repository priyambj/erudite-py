[BLANK_AUDIO] [MUSIC] But seriously, that speech was great. Aw, thanks. [LAUGH] I was actually super nervous when they called shopping list plus plus. I just kind of panicked. May I? Yeah, sure. Wow, this is elegant. Personalized everything. This is amazing. Yeah, it's a lot heavier than you'd think it'd be. Yeah. Hey, have you had one of these macaroons? No, I actually haven't eaten anything all day. I would kill for an right now. I think Walter's at the store, if there's only some way we could contact him. Hey, we could use the app. Of course. Here, get my phone open. And I'll just go ahead and scroll through my shopping list. And Walter is in the store, that's awesome. So, lets go ahead and add insta, delicious instarito. [MUSIC] [NOISE] Wow. Looks like he picked it up. Yeah, that's super fast. Yeah. What do we do now? Hey. What about teach. Right, let's teach this class. Yeah. Hey. [LAUGH] Hello there, and welcome to Firebase Essentials for Android. My name is JP and I'm a program manager for Google with Developed Training. More recently, I've been involved with Google's cloud courses on Udacity. Hi, I'm Lyla. I'm an android course developer at Udacity. I've worked on developing android apps, as well as android for. So by now, you've probably guessed that Lyla and her team are the creators of shopping list plus plus, the wildly successful collaborative shopping list app written in firebase. You've recently seen it in action when Walter, Lyla's roommate, ordered us in as instarito. Right. But what you don't know is how we got here. In this five lesson course, you will take on the role of shopping list plus pluses first developer hire. And in doing so, you're going to help us integrate the Android app with a firebase backend. You know, if you don't know what firebase is, it's a platform for building mobile and web applications where you can read data, create authentication methods, and also configure security and permissions for your data. When you're done, you're going to know how to create a app with a backend that can support something like a chat application or Google Docs, or even the backend for a multiuser game. Yeah. And I'll be collaborating with Lyla discussing firebase theory. I'll also introduce some examples that you can use when you're building your project. And I'm the course's app architect, which means I'll be walking you through the code examples and talking about sort of design issues with you. I'll also ask you to implement features for the app. So you might be wondering what exactly do you need to know to begin this course. Well basically, you need to be able to build Android apps that can connect to the internet and read data. You also need to understand the Android lifecycle in UI, specifically responsive design, and you should know GitHub and GitRepos. Basically, if you've completed the developing Android apps and completed the project for that course, you should be fine. Mm-hm. And there's actually a couple things that you do not need to know for this course. For example, you don't need to know how to configure servers or do anything with backends. So, Lyla, one question, what does students want to know if this course is really for them? Well, that's a great question. And actually, we thought of that. So, we typed up a full list of prerequisites and you can go ahead and check out the instructor notes for those. So I think with that, maybe this is a good time to take a trip down memory lane and go back in time and see how everything began. [MUSIC] I still don't like the resolution on these images. Darn it. Yeah, a lot of people have been commenting about how the sheep just don't look real enough. [SOUND] And didn't your investors say something about wanting you to identify a larger target audience? Yeah, well, maybe. I'm starting to wonder if Bale Buddy is going to be the destructive and transformative app that I originally dreamed of. There might not be enough shepherds in the Bay Area. It's too small a market. Baa, hey, don't bleat yourself up about it. Ha-ha, real funny. All right, well, back to the drawing board. Let's see. I'm thinking some sort of app maybe about like, crap. Walter, did you forget the whiteboard markers again? I just went to the store, you should've told me this earlier. Kagure had the same problem yesterday when we needed toilet paper and WD40. Yeah, it goes both ways. I was at the store picking up these cheesy flakes, they were on sale. And then, Walter did the same thing. But you know what, I have dinner for next week. [LAUGH] Can't be good for your credit score. Crap, I'm running out of gas money. This is super inconvenient. [SOUND] If only there was some way that we could communicate, something collaborative, that would be right there in the store with you, something like an app. Great Scott, I've got an idea. So JP, I did initial competitor analysis and I estimated what the user base is out there, and kind of what the cash opportunity is, and I gotta say things are looking pretty good. Now there are a couple of other competitors in this space. But if we focus on things like the realtime update nature of the app and the collaborative nature of the app, I think we really have the runway to make this idea take off. Great, so you mentioned some initial wireframes for the app? Yeah. I think we'll want to divide this into stages. We can call these versions and release the app to testers accordingly. Version 0.1 is where we'll decide what kind of stack we're going to use. Once we've done that, we'll take the minimum viable product, also known as the simplest version of the app. That version will be focused on writing and reading one piece of data from the online data store that we just set up. Sounds good, and then in version 0.2 you could build out the other screens, create the bulk of the data that gets stored in the database, and decide how to visualize it and connect it to the database. We're going to need to add user authentication at some point. That could be for version 0.3. You could add a sign in and create account screen to the app that will allow for authentication and user accounts. That sounds good. And in the 0.4 release, we can cover how to use all the user data that we just grabbed to allow for sharing user lists. Also, since we're accumulating all that data, we'll probably want some way to sort and filter it. And you'll need to adjust security and permissions at some point. You don't want to have your data just laying around for anyone to access. Maybe that's shopping list plus plus 0.5 or maybe that's 1.0. Okay, so it looks like we have a pretty good road map of the app sketched out, but I'll keep checking in with you both to make sure that we're on track. Okay, so the next question is, what kind of backend stack do we want to use? Now, I really want to get something that's going to be quick to set up, because we should get Shopping List Plus Plus in users' hands as fast as possible. I'm pretty solid with Android, but it's been a really long time since I set up a server. Well, maybe you don't need to set up a server. Have you ever heard of [SOUND] Firebase? Hm, well, I'm intrigued, I have heard of Firebase, it's like a fancy database, right? It's fancy, all right. Okay. Seriously, Firebase is a collection of services, including a database that can serve as a simple backend for your app. Okay, that sounds great, but is it easy to use with Android? Very easy. It has an SDK for Android as well as iOS and JavaScript. With Firebase you write a little client side code, and then Firebase takes care of all the rest, some authentication and access to data. Well, I definitely like the idea of not setting up a bunch of server code, so I guess I could read up on Firebase a little bit and kind of prep the GitHub repository for the developer. In the meantime, I'll poke around and set up an account, so you and your developer can poke around with the SDK. All right, that sound great! Follow me, and let's get started with Firebase. Let's start by looking at the Firebase site. Sometimes UI's for websites change so if anything seems out of place, check out the instructor nodes for the most up to date information. We're going to create a free account, so let's first see what's included. As you can see here, the free account gives you a good amount of included storage, unlimited users and some static hosting. That last part might be useful later on if you ever want to make a web app in addition to your mobile app. Now to create a free account. Click on Sign Up, and enter an email address and password. Once you're account is created you are redirected to your account page. This page shows you all of your apps in Firebase. But what is an app in Firebase? In Firebase, an app refers to a Firebase app backend. This backend includes a database and support for authenticating users and tracking if they're logged in. But, for shopping list plus plus, we also have our client code which runs on Android. So to be clear as we continue through the course, here's what we mean. When we say your app, we're referring to the shopping list plus plus app you'll be helping me create in Android. When we talk about your app's backend, we're referring to one of these online Firebase app backends. So now, looking at your account page, you will see the card titled My First App. This is a starter Firebase app backend available when a user creates a new account. If you're just playing around with Firebase, this is where you'd go to explore the functionality. However, for our purposes we are going to make a new Firebase app backend for our shopping list plus plus app. First click on the gray card to the left of My First App. You'll need to name your new app. I will go ahead and type mine in the app name field. Notice that the app URL is populated with the base URL for his app. Every app has a base URL associated with it. And this URL is where you'll go when you want to access or edit your data. URLs must be unique. So now, since I've just taken that URL, you'll need to use something a little bit different. You could use any name that is 20 characters or less. Containing alpha numeric characters and hyphens. For example, you could name your app like I did, shop list plus plus hyphen, and your initials or something else if you prefer. Select create new app. You should now see a card for your Firebase app backend here. Click on the URL, or manage app button and you'll be taken to your Firebase app backend. Notice how the URL is what we originally typed. As long as you're logged into your account you can go to this URL to get a view of what's going on with your data. Right now there's not a lot going on. Your entire database is equal to null. Now we could manually type some data in here. But instead, let's start with making a new Android app, hooking it up to this Firebase app backend, and writing your first data from the Android app. I'm getting ahead of myself a little bit, though. I'll give you a moment to make an account now, and when you're done, copy and paste your app's root URL here. The root URL is just the base URL of your app. You will need this for the next step, when we hook up the Android app to the Firebase. So paste or type your URL here. Here are the answers. So how did you find this exercise? Now if you found it difficult because you misread a question or had trouble typing the class names correctly, that's not a big deal. If you had trouble because you're not super familiar with the Android framework or the Java, I would take some time to brush up on both of those topics before continuing. I've put some resources in the instructor notes to get you started if you need them, and please trust me. You'll enjoy making this app more and learning Firebase if you're not also trying to learn Java and the Android framework at the same time. I'll show you how I got to these answers, but before we get to that, let's just take a look at what the app actually does. Right now, it's two screens, a meal screen and a shopping list screen. Now meals are a feature that you're going to implement much later in the course, so we're not going to focus on them right now. Shopping lists are what you're going to be working with in the immediate future. If you're curious what this sliding motion here is controlled by, it's done by a layout manager called Viewpager which you'll see in the code soon. In this area here we're going to actually be listing out all of the shopping lists that we make. I took the liberty of putting a single list item for one shopping list here, that's not filled in with any data yet. The green floating action button down here is for adding a new list. When I press it, it opens up a DialogFragment, and here I can enter the name of a new list. Now, when I hit create, eventually it'll add the list to Firebase and show it on this screen. It doesn't do anything yet, but that's because you haven't incorporated Firebase yet. Not to blame anyone, though, you're new. And that's pretty much what I've coded for you so far, so let's take a look at the actual code now. Here, I've got a list of the packages and classes that are in the app. In the main shopping list plus plus package, I've got a UI package and a Utils package. The Utils package contains a class for utility functions and a class for constants in the app. Meanwhile the UI package contains code related to all the screens in the app. In it you'll find the main activity which controls the first screen you see. There's also a base activity class which all activities in the app extend from. It's meant to do some setups that's common between all the classes in the app. Then we have these two sub packages here, activeLists and meals. And those are for the two major parts of the screen that we saw. In activeLists we have the ShoppingListsFragment, which controls what we see on the ShoppingLists screen. And AddListDiaglogFragment which is a dialog fragment that appears when you press this green plus button. The two classes here are similar to the classes found in activeLists, but they're for meals instead. And before I forget, you also have a ShoppingListApplication class which you'll use to set up global application state. The first question was, what's the name of the class that creates and controls the meals fragment and the shopping list fragment? And you can answer either MainActivity or more specifically, section page or adapter. Let's go ahead and take a look at the MainActivity class. Okay, I'm going to go ahead and open up main activity. So here we are in the main activity class. And if you scroll down to here, you'll see that SectionPagerAdapter is a public inner class, and it's extending FragmentStatePagerAdapter. Scrolling a little farther down, I can see there's the logic for switching between the fragments and getting the titles for the fragments. Farther up in MainActivity, here in the initialized screen method, which is called in MainActivities on create. And here I'm actually making the section pager adapter and setting everything up so that's part of the screen. Okay so the answer for what's making those fragments is section pager adapter but I would have also accepted main activity. The next question is, what is the method called when the green floating action button is clicked? And we're given a hint that the XML on click method is used. To solve this one, the first thing you should do is try to figure out what layout XML has this floating action bar button in it. Now it seems to me like it's pretty necessary to this part of the shopping list screen here, so I'm going to guess that it's part of the ShoppingListsFragment. Let's take a look at that code. Here I am in the ShoppingListsFragment. I'm going to scroll down to the CreateView method, which is where the layout typically gets inflated. And here in the onCreateView method, I can see that it's inflating a layout called fragment shopping list. So I'm going to go over here to the res directory, layout and open fragment shopping lists. Okay and down in this file, I see that the fab is right here, woo! And somewhere in here there should be an OnClick attribute, here it is. And since the method that's calling is showAddListDialog. So that's the answer to the second question. When I click the green tab, this is the method that's immediately called. So the next question is, what static method do you call to create an AddListDialogFragment? If you remember from a second ago, when you pressed the green fab, it called a method called Show AddListDialog. So this is probably where the List Dialog gets created, so I can see how it's created. Okay, I'm here in the main activity class. And I'm looking at the method showaddlistdialog and right here in the first line, I create a dialog fragment using the static method new instance. Using new instance is the best practice to create fragments due to how the fragment lifecycle works. When you destroy your fragment such as when you rotate the screen of your phone, it rebuilds the fragment from scratch. The issue is it rebuilds it using a save state bundle. If you create your fragment using a constructor and you pass a lot of parameters in there, those all get lost if they're not stored within that bundle. By default, the fragment is recreated with the instructor. Okay, so now I'm in the AdListDialogFragment class, and I'm looking at this new instance method. Now, you can see here, what's it's actually doing is it's using the empty constructor to make a new ListDialogFragment and then it is sending a Bundle of Arguments. Now this Bundle of Arguments doesn't contain anything yet. But in the future, you can add some parameters here, shove those arguments in this bundle, and then attach the bundle. And that'll let you pass values even between rotations. Hopefully, you're at least a little bit familiar with the fragment life cycle in Bundles because we will be using those in the future. Let's take a look at the final question. And that final question is what method is called when you press the Create button in the dialog? So you press the tab, a dialog pops up and then you press the Create button and what method gets called? The answer to this will be in the AddListDialogFragment class, so I'm going to go ahead and open that up. Okay here I am in AddListDialogFragment. Okay, and now I'm going to scroll down. And here's where the dialog builder is actually building the dialog. And here's where the Positive button is set up. We see that it's made to save the string create. So that's actually the Create button, this positive button. And when you click it, this onClick method occurs and that adds a shopping list using the addShoppingList method right here. So you could have said onClick but addShoppingList is more interesting. Right now that is not doing much, but that's because you are going to code this. Okay so if that wasn't too tricky, you're now ready to learn some Firebase. Okay, you've set up an account. And with that, I'm off. Wait. J.P., where are you going? It's 10:00 AM, gotta head back to my day job. But I like where this is going. Okay, you got it, J.P. I'll check in with you after the developer and I figure out how to write some data to Firebase. All right, it's just you and me for a bit. Okay so you've got your online Firebase backend and you've got an Android app so now it's time to connect the two. There are four steps to do this. You'll need to do these steps for any Android app that you plan to use Firebase in. Before we start, I've linked a quick guide for setting up Android in Firebase if you prefer text to me talking to you. Okay step one, install Firebase. So the first thing you're going to do is you're going to add the library to your Android apps gradle file. So I'm here in the build.gradle file. Okay and you're going to add two pieces of code and they're in the instructor notes so don't worry about copying them off the screen or anything like that. First is down here in your dependencies and what we're going to do is declare that we're using Firebase as part of the app. And that you needed to run the app. Now, let's see what happens if I run, well I get this error here about duplicate files. And to avoid that, you need to add some packaging options. So to fix this error, I'm going to need to exclude those duplicated files and I do that by adding a packaging options directive inside of Android. You're doing this with the same build.gradle file and I'm just going to scroll up and put it right below the signing configs. And as easy as that you've installed the Firebase library as part of your app. If you're looking for alternative ways to install the library such as if you were using Mavin or another build tool those are included in the Android Quick Start guide, which is linked below. So step two, you need to add some permissions to your Android manifest file. Is there a permission that Firebase is likely to need? If you said yes, the Internet permission, you are absolutely correct. Your Fire-based data store is online, so you're going to need to be able to access the Internet. I'm going to add that permission now. Okay, so you've added Firebase to Gradle and you've also added the Internet permission to your Android manifest. Next you're going to need to initialize Firebase in your app. The Firebase library needs to know about your Android context object, so this initialization needs to happen before you do anything else with Firebase. And to ensure that I'm going to do that in a Android application class. Specifically the shopping list application class here. This class is really good for any kind of global setup that you need to do. So it's a perfect place to put this Firebase initialization code. And that's what the code looks like. Firebase.dryAndroidContext. And you pass the NA context. Now an application is a context. You can also do this in the on create of an activity class, but I'm doing it in the application because I want to make 100% sure that I can use Firebase anywhere in my code. Okay, and I'm going to do one more sort of optional thing to get us ready. As JP mentioned, I'm going to go over to the Constance class in utils. Right here under Firebase URL I'm just going to make a constant. And I'm going to call it Firebase URL. And what I'm going to set that equal to is a string here which represents the URL that JP mentioned. Remember every Firebase app has a URL associated with it, so you should put yours here. Now I'm actually going to put something a little bit different than just the root URL string that I was talking about. I'm going to set it equal to this build config constant called unique Firebase root URL. And to explain what this is, let's take a look at the gradle properties file. Which is right here. So the gradle.properties file is a file that sits within the root directory of my project folder. And it basically lets me set some config things for the app. And why this is important is because I've decided that I'm not going to track the gradle.properties file with git. It's included in the git ignore. So you can have a different gradle.properties file than I have. So, here I've put my shopping list plus plus Firebase URL and you can put your shopping list FIrebase plus plus URL and it's going to be fine because the get repo is not going to overwrite this file. And then this unique Firebase key value point here is read in the build.gradle file, right here in this built type section. You can see here that I have unique Firebase root URL, and I'm setting that to the unique Firebase root URL constant that you saw. And then just going back to the constants file. You can see I'm actually using the constant here. So you don't need to do this in any app that you're not planning on sharing the code with someone else, but it's sort of a useful tip if you want to share your Firebase code among different people, and they're each going to be using a different Firebase database. And that's it. If you haven't been following along, take a moment now to go ahead and pause and make these changes to your app. The instructor notes have all the little snippets and things that you need. And once you're done check this box. It seems like the simplest thing we could do from our Android app. Would be to add a single piece of data to the Firebase database. If you remember, here's my shopping list screen, and I got this floating action bar button here. It's supposed to add a shopping list. When you press it you've got the nice dialogue, you can enter a name. [BLANK_AUDIO] But when you press Create it does nothing. Let's have it store the name for the shopping list I enter here, in Firebase. Whenever we interact with our Firebase data, we need to create a Firebase object. This object, here, is tied to a specific Firebase database that's specified by this URL. Right before this, you should have saved your URL in a constant that we called FIREBASE_URL. So for us, we can use the FIREBASE_URL constant as a argument, here. Now this Firebase ref object here has a lot of methods that you can call on it. Many of these methods we're going to go over in detail and they're all referenced in the Firebase DOCs which I've linked in the instructor notes. The two that we're interested in right now are the child and the .setValue method. Your online Firebase database stores everything as key value pairs. What this code will do is make whatever is put here the key and whatever is put here the value. So, if we were to type "listname" right here, we'd be making a new data entry in Firebase, or node, that had the key of "listname", and then we'd set it to whatever value it has here. I'm going to go ahead and do this in the code. The code that I'm interested in is inside AddLIstDialogFragment. Specifically, when you hit the "Create" button, it calls this addShoppingList method, which is currently blank. So, what I'm going to do is make a new Firebase reference. And I'm going to pass in the constant that I made for the Firebase_URL. And then I'm going to take that reference. And I'm going to say, go to a child called ListName. That's going to be our key. And I'm going to say set the value there. And what I'm going to set it to is what the user entered in the text view of that dialog. And if I scroll up. [BLANK_AUDIO] We already have an instance variable up here, storing in reference to the EditText in that dialogue. So scrolling back down, I'm going to set this string to what's stored in the EditText. And then I'm going to pass that string in right here. Okay, let's run this code. Okay, so I've got the code up and running. I'm also going to go ahead and open up my Firebase dashboard. Okay, now moment of truth, I'm going to click the plus button. And I'm going to type in a list name, and well, I don't want to ruin the surprise of what happens when I click that create button. So go ahead and try this yourself and tell me, what do you see on the Firebase dashboard here? Okay, so when I press this button I see that the Firebase database updated to have the data. Now this is actually a pretty complex thing that just happened here. Notice how I didn't need to make a new AsyncTask or start a background thread or anything fancy like that, Firebase does it all for us. And I'll actually go ahead and put my app on another phone. And I can actually make a new list with this. [BLANK_AUDIO] Press the Create button. And I see it's also all contacting Firebase. Now right now, we're just writing data to Firebase. We're not reading data yet. So even after the change happens here I'm not seeing it in my app. We'll fix that a bit. But first, let's learn a little bit more about data and Firebase [MUSIC] Hey there! So, I was just calling to say you're doing great work. You got your fist bit of custom data written into database. And it only took a few minutes. [MUSIC] JP is calling. Hey JP, we just wrote our first data to Firebase. And we didn't even have to write a single Async task or need to deal with threads. I'm glad you like it. Yeah actually, while I have you on the phone, quick question. So you've looked at the dashboard longer than I have. So how is data actually structured in Firebase? It doesn't look like a relational database to me. So what is this Firebase data that I'm editing? Well, you're right about it not being a relational database. So let me show you what it looks like. Let me pull up my screen. First, SQL has a tabular format with columns and rows, like Excel or a Google spreadsheet. However, in Firebase, data is stored in JSON. It's basically a simple declarative language used to describe objects and data. It's a lot more flexible than a tabular format, since you don't need to strictly define rows or headings. JSON contains a nested structure similar to XML. And also like XML, JSON can be represented in a tree structure. Yeah, I remember JSON from working on developing Android apps. I think it was the format that both OpenWeatherMap API and the movies database returned. Hm. And if your developer's unfamiliar with JSON, take a moment to close this hangout and check out the links provided in the instructor notes to get you up to speed. All right, so if I'm understanding you right, the dashboard is basically a visualization of my JSON tree. And the Firebase object that we're calling methods on in the Android code that's also an object representation of a JSON tree, right? Yep. Hm, okay so what kind of things can I actually store as values in JSON? It looks like here I stored a string as a key and a string as a value, so does that mean that any type that JSON normally accepts is okay? Right, let me explain. Well yes mostly, the keys are always strings. The values stored in the tree can be passes in as Booleans, longs, doubles, lists, maps, and some specific types of objects. There are also Java types that can be returned from the tree. List and maps can contain more lists and more maps. And objects can contain other objects or lists of other objects, meaning you can have nested data structures within data structures. I know the dashboard is pretty powerful when you want to look at your data, although it's hard to tell when you don't have too many entries. Here's a look at it right now. Okay, so here we are at Firebase's Example Datasets. These are some public data sets that are freely available to access. You can access the data and use it in your app, though you can't write to the data set. They're also good examples of what larger Firebase databases look like. So while I take a look at the links I just sent over, why don't you pick one that looks interesting so that we can discuss one of the more populated data sets. Let's see. I'm liking the look of that Cryptocurrencies Data Set. You know, I might want to incorporate BitCoin and DogeCoin shopping into shopping list plus plus someday. And for the developer, if you're not sure what a Cryptocurrency is, the short answer is that it's digital money. And the long answer is in the instructor notes. Anyways, yes, Cryptocurrency it is. Sounds good. Let's take a look at the Cryptocurrencies Firebase dashboard to see what a mature Firebase database looks like. Here, I've got an app dashboard that looks a lot like mine, but with a bit more data. I can see here that I've got three different key value pairs. And instead of BitCoin having one value associated with it, it has a map with five child key value pairs. Look at the URL, this is known as the root URL because it's the main page for your Firebase database. One of the cool things about Firebase is that any of these collections of data, which I'll call nodes, has a URL associated with it. For example, I can click on this node that says dogecoin. I am then directed to a page that just shows the dogecoin subset of the data. Similarly, the URL has updated in the address bar, and in the bread crumb of the interface. If I click on a child node of dogecoin, like bid, I can see the full path for this in the address bar and in the bread crumb. So every piece and subset of data in the database has a unique URL. This is the location of the data, also called the database location. Just like a URL or file location, you can enter the unique URL in the address bar and see the specific data you are interested in. It is important to understand how these paths specify the location of your data. Since you use these paths to refer to data that you're reading and writing. Now let's navigate back to the root URL. You might notice how the database will occasionally flash yellow. Yellow means that something is changing. In our example, it might indicate the time when the Bitcoin is last updated. Notice how the parent objects of the changed value are also changed. Whenever a child is changed, all parents also flash yellow, because a part of them has changed. As you add and remove data from your app, you'll see similar types of interactions. Whenever any child data is added, removed, changed or moved, the parents also flash yellow to show that they have changed. What's the URL for ask in litecoin? When you press the plus button to make a shopping list name for the first time, what color does your database flash at the root node and at the location of the list name? If you already have data in your database, you can delete it using the dashboard. To answer this question, let's start by clearing our database. Then, we'll open up the app, press the plus button, enter a name, and then press the create button. Looks like it flashes green for the list name node and yellow for the root node. It flashed green here because you're adding the list name value. The route node flashes yellow because it is the parent of a node which has changed. When you made additional changes to the list name, you'll notice it no longer flashes green and, instead, both flash yellow. In this case, the list name is being overwritten and not created. Now that you know a little more about data, Lila will show you how to read from the JSON database. All right, so we're almost ready to start reading data from the firebase. The Firebase? Yeah, the Firebase database. You know, maybe we should all sync on what terminology we're going to use, especially since the developer is just joining us. It'll be good to get our language a bit more straightened out. I was just talking to some of the Firebase engineers in the office about it. Let me go over the terminology that they suggested. The entire Json object is what we'll refer to as the Firebase database. Which is part of the Firebase app back end. These here are known as keys and they're associo on the right with values. I can also call a specific key value pair a node. A key value pair that represents a key in all the data in an analogous Java object I might also refer to as an object. If a key value pair has a bunch of objects inside it, such as this dodge coin key. I might call it interchangeably a list, map or a collection. If a key holds a single value I will refer to it as a property of a node. Each node besides the root node has a single parent. For example, the parent of this bit node is lite coin. Nodes can also have zero or more children. The children of light coin are credits, updated, ask, bid, and last. Each node is said to have a location also called a database location which is identified by its URL. This is the root node. This is at the root URL. Well, great, that works for me. All right, so why don't you and me actually talk about how to read data from the Firebase database. We've got a simple write example up and running where we know that we're creating one shopping list. And that shopping list is stored as JSON data in the Firebase database. But that's only half of the story. Let's see how we can get data from the Firebase database and display it in our app. In the standard database model, you might think of your data storage as a resource to get data from. If I wanted to display, say, the name of a shopping list, I'd probably start a different thread in the app that's requesting the shopping list. Something like an asynch task. And I'd use this separate thread to connect to the data storage and ask it for the data that I'm interested in. Then, that thread would wait a bit and the server would respond. Finally, the app would then take the response that it got from the database and update the UI. Now, if I expect this value to change, I might regularly ping the data storage to see if the value has changed. And then, I'd wait. And each time I'd wait a little bit and the server would respond back to me. And to make things a little bit simpler, I could do this with something like a sync adapter. Now, this model of making a request, waiting, and then receiving data and putting into the UI is known as the request response model. The issue with this model is that, because you're constantly pinging the server, it can create a lot of unnecessary network traffic and be a bit annoying to manage. Firebase takes a much different approach. Instead of constantly refreshing data, you tell the server once let me know if anything about this data changes. Then, let's say, something about the data does change. Once Firebase gets the change it'll send it out to all of the apps that are connected to it. And then, it's up to your app to take this data and update the UI. So, the Firebase steps are, you set up a listener once and then whenever the data changes you receive the data and put it into the UI. So, in Firebase data ping you. So, what does this look like in practice? Here I have drawing of a table in Firebase. This is the root node. It has children a and b. And it has a children c, which has some value. B has a children d and e. E has some value. And d has one child f which has some value. Reading a Firebase database is all about listeners. Okay. So, this is my best attempt to represent a listener. It is a drawing of an ear. And the listener will be attached to a specific node in your database. And it will also be connected back to the app itself. And that's this first step where we attach a listener. When the data changes, this listener will trigger part of your Android code. It's a lot like how, if you press a button, a on-click listener is called. It's just the button press is changing a piece of data somewhere. When your Android code is triggered, it's actually also passed an argument which is the updated data which was in Firebase. You can then use this updated data to change the UI. In this way, you've got a connection with some sort of data in Firebase that'll immediately update the UI whenever it changes. I should mention that the listener doesn't need to attach with the location with a single piece of data. It can actually be attached to a location with multiple children, like B here. The location can even have grandchild. And so on. Then, if any part of this tree changes, the listener here will be triggered. So, if this value here changed to nine, the listener here would trigger. And it wouldn't just send b back to the app. It would sent b and all of it's children, including d and f, even though f and d did not change. What's neat is that the Firebase SDK deals with all of the threading and all of the asynchronicity. So, you'll notice that I didn't make an async task. I don't have sync adaptors. Basically, the only things that I need to worry about are choosing which data to listen to, and then providing a method that can handle the data that comes back from the listener. Which will usually change something that the user sees or experiences. Okay. So, here I am in my apps dashboard. My data tree is right here. It has a root node, and then one child, listName, with one piece of data. In this case, I want to know when listName changes. So, what URL location do you think that we should be listening to for changes? And when that location changes, what should we do with the data? Here's a box to enter the URL. And here you can describe, in your own words, what you want to do when the listener is triggered. To answer this first question, let's take a look at the database. As JP showed us, I can actually click here on list name, which is the specific piece of data that I'm interested in. And up here, I can actually see the URL that is specifically related to the list name piece of data. Here I've got the name of my shopping list app, shoppinglistplspls.firebasedio.com, and then we have the name of the key, which is just listName. So I can copy this, okay, and the next question is, when the listener that's attached to the list name is triggered, what will you do with the data. We're going to want to update the UI here. It has a couple of text views in here, which we'll probably want to change using set text, and we can update that text view using whatever the user entered. All right, let's get to it. Let's take a look at the code for making a listener at the listening location, then we'll see how to use the data that we get from the listener to update the UI. As you said, we're going to need to listen to the node list name, which is a child of your root URL. Now these two lines of code are basically equivalent. You can either pass in a full URL string specifying the exact node that you're interested in, or you can take a reference to any part of the database, and then use the child method to drill down to exactly the node that you're looking for. Again, these two are interchangeable, so use whichever that you like. Now that you have the exact location that you want to listen to, you attach a listener using the addValueEventListener method. This method takes a ValueEventListener object as a parameter, and just like with a click listener, you'll usually make a new anonymous subclass. ValueEventListeners have two methods that you need to override, onDataChange and onCancelled. OnDataChange is the method that's called whenever data at this reference location changes. I'll say it again, whenever it changes. This means that as long as we've got this listener attached, JP or myself or Walter, or anyone else in the world, could update a value here, and onDataChange would get called for all phones on which the app is installed. onCancelled, we'll talk about more later, but, basically, it's triggered if you either can't attach the listener to something, or if the listener gets detached. All right, so that's the general structure, let's write some code. What I want to do is update this view, here. This whole part of the app is controlled by the shopping list fragment class, so that's where we should start looking at the code. So here I am in the shopping list fragment class, and specifically I'm in the onCreateView method. Since your listeners update your UI, generally you want to put them in the onCreateView method, or the onCreate method, so I'll start by making my firebase reference object. And then, I will create and attach a listener to that reference. Then, in the onDataChange, for now, I'm just going to write a log statement, and I'm just going to make an error statement so that it's easy to see. [BLANK_AUDIO] Okay, let's try running this on my phone. So I know it's super small here, but I ran the app on my phone, and it says the data changed. Then, if I go to update the data, it says the data changed again, and whenever I do it, it'll say the data changes. You might be wondering why the listener triggers when the app opens, after all, nothing was getting updated. The reason is that, when you first attach the listener, it automatically calls itself once. This is so that you'll have some initial data in the app, even if nothing is actively changing when you start the app. All right, let's do more than just call a log message. If you look at the onDataChange method a little bit more closely, you'll see that you'll receive an object called a dataSnapshot, so what's a dataSnapshot? So you have your Firebase Database, and you have a listener attached to, let's say, this Node B, here. When B or any of B's children nodes change, a dataSnapshot is taken. The dataSnapshot is a read-only copy of the Firebase state when the data gets changed. Once you have a dataSnapshot, just like a photographic snapshot, it won't change, and this snapshot that gets sent back includes the node that you were listening to as well as the children nodes. So that's the object that you have access to here. Now, you can call a lot of different methods on a DataSnapshot, and here are some of them. For example, you can call child method on a DataSnapshot the same as you would call a child method on a Firebase reference object. The DataSnapshot starts where you were listening to, and if I were to call child D, it would move the child down here. Then I could call something like the getValue method, and it would return the value at this location, which in this case is 1. I could also call it the getKey method, which would return the key at this location, in this case, D. The snapshot includes everything of the node that you were listening to and all of its children, but it doesn't include the parents of the node you were listening to, so you can't transverse the whole tree. Okay, so I'm concealing some code that I put here that got me the shopping list name, and here I set the TextView that I'm interested in to the list name I just got here. This mTextViewListName, I'm going to scroll down, was initialized here in initializeScreen. Okay, but back to this code that's hidden from you, so I've got a DataSnapshot of the data. Which method that we just talked about do you think I need to call to be able to get the name of the list? Go ahead and change the code in your app so that it displays the list name, and then answer that question. Is it getKey(), getValue(), or child(), that you call? Okay so here's the answer code, and here's an image of what our data snapshot looks like. You were listening to the list name location in the database. It has no children nodes, so the child method is not one that you'd use. That's because you already navigated to this location here. So now the question is whether we want the key or the value. This is the key and this is the value. The key stays the same. The value stores the list name set by the user. You can think of these data structures as representing objects. Each key is like a member variable of an object and each value is the value of that variable. The name of the member variable doesn't change, but the value can update quite a bit depending on what is being stored. In fact, the comparison between JSON data and an object is not at all farfetched, and we're going to see this shortly. All right, cool. I've got a shopping list name that anyone in the world can update. Let's call on some users and see what the big picture looks like. Okay, we have three of us using the version of the app that you just created. When the app starts up, it attaches a value event listener. This listener gets triggered immediately, it takes a snapshot, and it delivers the snapshot of Dummy Data to us immediately. So all of our apps read Dummy Data. Okay. Let's say my roommate Kagure changes the name of the shopping list to Kagure's List. What happens with Firebase? It occurs in milliseconds but it's fairly complex. Okay, go for it, Kagure. Once she does this, the app sends the data to a specific location in Firebase. Base URL plus listName. And the value in Firebase changes to Kagure's List. Because listName changed, the listeners triggered, and a snapshot is taken. Because we were all sitting at the same location and it changed, we all get the updated data in the form of a database snapshot. Then the onDataChanged has triggered all of our apps with this data snapshot. And if you wrote your code correctly, then everyone's UI display changes to seamlessly show the updated data. And the same thing happens no matter who changes the data. One person will change it, and it updates for everyone. And that's what's so cool about reading and writing data in Firebase. Great you want take a look at the app that I'm making? Sure. And wait for it. I'm not sure what I'm looking at. It says house shopping list. And then there is nothing underneath like who am I shopping with? What items are we buying? You have anymore data on this? Well it's an early prototype. Okay. Okay but I hear you saying it seems like you want more data. Bingo How did the initial user test go? Did they like it? They seemed underwhelmed. J.P., the users want more data to be shown in the app. Well, we should give the people what they want. Yeah. Implementing a list of list ends sounds hard and a bit beyond version 0.1, but we could start by trying to store two pieces of data with a shopping list instead of just the name of the list. We could store the name and the owner. The owner will need to be a dummy value though since we don't have any user accounts working. Well I have heard that you can convert simple Java objects into firebase database JSON. So we could make the shopping list an object with two fields and then store it in the database. I'll take a look at it with our developer. When you're working in Java and storing data. You might find that it be really great if you could just save an object to the database. In this case I bet you'd really like to store shopping list object which let's say has a name and an owner to start. Now it is possible it fire base to make a hash map with a collection of key value pairs, and then you can use that hash map to change your data and fire base. You can easily forget a key value pair though, so this is not the recommended way to do it. The expert recommended way to do this is to make a POJO. AKA a plain old Java object. And then you can use Firebase's built in serialization capabilities to both put Java objects into the database and take back out Java objects. To allow the Firebase STK to do this, our object structure needs to adhere to a few simple rules. And here they are. Let's go ahead and take a look at each of these. The first rule, is that every instance variable must match your children's key names in Firebase. When your object goes into Firebase, it's basically going to look like this. You'll have some sort of root node and then a bunch of properties that correspond to member variables of the object. And these keys here need to match the member variable names exactly. Also, the types for all these variables should be Java types that Firebase could handle. And those types are booleans, strings, logs, doubles, lists containing objects that are any of these, maps containing strings and objects that are any of these. And any other Firebase POJOs. These two values happen to be strings, so we're all set there. Rule two, you must have at least an empty constructor in your POJO object. You can make other constructors, and you don't need to use the empty constructor but it does need to be there. And rule three is that you need a public getter method for every member variable. For example here's a public getter method for owner. It should say get in the member variable's name in CamelCase. Okay, so let's do this in the code. The first thing I'm going to do is actually make a new package, and I'm going to make it here on this level, the main shopping list plus, plus level. [BLANK_AUDIO] And I'm going to call this package model. And it's going to have all the POJO that I end up having in my app. So inside the model package, I'm going to go ahead and make a new class, and I'll go ahead and call that class shopping list. All right, let's start by making the member variables that'll be the properties of my object. There's only two and they're both strings. To satisfy the second rule, we're going to need to make an empty constructor. Now I find that using keyboard shortcuts when making these objects is a complete life saver. The keyboard shortcut that I use is control return on a Mac or alt insert on a Windows machine. I've included these in the instructor notes. Okay, so this opens up the generate menu and I'm going to go to constructor and I'm just going to hit select none, which generates an constructor. And while I'm at it, I'm also going to make a constructor that has all of the variables [BLANK_AUDIO] I'll just select both of these and hit okay. Now rule two doesn't prevent you from creating a constructor like this. It just requires that you have this empty one. Okay, so for rule three I need some public getters. I'm going to use the same generate shortcut to make getters. And I can just select all of these and click okay, and then I have my public getter methods. Now we only have two variables right now, but when you have a bunch of member variables, it's really important to make sure you make getters for all of them and you don't miss any of them. All right, so that's actually it. Your POJO is done and ready to be used. So I'm going to integrate it with the rest of my app. We'll start with updating the right portion. Now remember the right happens in the add list dialog fragment. So I'm going to open this. Okay so I'm going to scroll down to add shopping list which is where I actually do the right, and I'm going to make a new instance of our shopping list object, and I'm going to go ahead and pass it the user entry for the name. [BLANK_AUDIO] And then we need an owner. Since we don't have user accounts yet, I'm just going to put a string that says anonymous owner. [SOUND] And we'll update that as soon as we get user accounts. Okay, and now instead of just setting this value here, ListName to a single thing, I'm going to go ahead and comment this out. Instead what I'm going to do is do ref, going to get a child. So I'm going to call the root known active list and that's just an arbitrary key for this object that I'm adding. And then I'm going to set value and I'm going to just pass in that shopping list. Okay. So, we also need to change the code where we grab the data from Fire base. And that is in the fragment class over here, shopping list fragment. Okay now we actually need to change the read code. First things first, so here, instead of having a listener attached to list name, I'm going to attach it to active list. Okay. Then we can actually keep using the get value method. But we have to tell it. That we're expecting a shopping list class, so we pass the object class in here. And we actually don't need this cast anymore. And this is no longer a string. It becomes a shopping list, and we're going to go ahead and call it ShoppingList. All right let's line that up. Then here I don't have a list name to reference anymore but I do have a shopping list which has a get list name method. Cool. Now I actually need to reference to another text view that I could put the owner text in. So I'm going to go down to the bottom of this class and here's where I initialize all these. Okay and I'm going to go ahead and make a TextViewOwner. Okay, and I'm going to grab the view of the id.text_view_created_by_user, which is an I.d which is found in the layout for this fragment. Okay, now I actually haven't declared this so I'll go to the top of the class, declare it. [BLANK_AUDIO] Okay. And now back down here. [BLANK_AUDIO] In the listener, I can get this new text view that I have and I could do set text. [BLANK_AUDIO] Get the shopping list. And then get the owner. And then here, I've gotten the owner. OK, so now what I want you to do is make those edits for yourself, so that you could see both the shopping list name and the shopping list owner. And then, I want you to break it. Go ahead and remove one of the getter methods, and tell me what error you start getting as soon as you don't have one of those public getters. Okay, cool, so I can start adding different list names. And I'm updating now to both show the name and the owner. And even though the owner's not going to change in my app from anonymous owner If I was able to change this. I could see that it actually does update in the app. So that's pretty cool. All right but let's break the app, that's a bit more fun. Okay, so here I have this shopping list class that we both just made. And I am going to delete one of these public getters because no big deal this is probably not that important. And we'll go ahead and compile that. We don't need that anymore. Okay, so it compiles just fine, okay so I'm going to run it on my phone. And the first thing it does is it crashes. Well, that's no good. Let's see what's going on here. Okay, and I'm sorry that this is so hard to read but if you have very good eyes, you'll see that right here it says, failed to bounce type. So, if you accidentally forget one of your getters you get a failed to D bounce effort. So, if you forget to add one of your getters, you actually get this failed to D bounce error. And this is what happens when the underlying serialization library, which is called the Jackson Object Mapping Library, can't turn your firebase data into the Java object that you want to. And this is the error that you get when the underlying serialization library which by the way is called the Jackson Object Mapping Library. Can't turn your fire base data into the job object that you want it to. It'll compile, but it'll blow up at you and give you this sort of cryptically named error. If you get errors it's probably something that's happening in your model POJO. Is everything okay? You seem a little pensive. [SOUND] Yeah I'm just thinking. You know choosing a back end stack for an app is a huge decision, and I'm definitely convinced that Firebase is a good option given how easy it is to set up, but is it the best option for the project? There are other database solutions out there. I know there's no SQL and SQL Solutions. There's Oracle, there's Parse. I guess we could even build our own back end if we really wanted to. So I'm just kind of wondering why not any of those other options? First of all Firebase consists of a database and a collection of services which is sometimes referred to as back end as a service. Let's look at a few other database options, and then compare them to Firebase. Oracle and SQL are both examples of relational databases. These databases are often transaction based with rollback functionality. They're generally used for larger enterprise applications requiring a large number of read write operations. They're not good choices for Shopping List Plus Plus because they don't handle real time applications natively. Parse is similar to Firebase in that it is a back end as a service. It is a no SQL implementation and uses MongoDB as its database. For Shopping List Plus Plus it's a better choice, but it still requires third party support to build real time applications. Firebase is also implemented as a no SQL solution with the database being one large JSON object. There are not tables, or collections, or documents like MangoDB. Also Firebase is hosted in the cloud, which makes it easier to access data on any client anywhere in the world. Finally Firebase gives you complete control for organizing data and changing your schema. This offers amazing flexibility and is great for prototyping applications. So Lila while it is possible to build a collaborative mobile applications with either Oracle or Parse it takes additional planning and requires additional integration with third party services. Firebase implementation is designed from the ground up for real time and collaborative applications like Shopping List Plus Plus. Okay, so I can see how the Firebase database is a better choice than other data options out there. But are there other features that are part of the platform that are a good fit for shopping list plus plus? Well, knowing what you want to do with your application. Here are the top reasons why I think you should use Firebase. Data that is available in real time, so users all get updated shopping lists on demand. So if Walter adds some items on a shopping list, you'll see these immediately. Synchronization handled by the client. Regardless if the client is online or offline. This ensures that clients that were turned off or maybe in airplane mode get the freshest copy of the data possible when they come back online. This is also helpful because you can still add items to your shopping list when you're offline and have those changes available to Walter when you're back online. Easy to implement authentication methods, all without writing a lot of clients. With this, Walter can use e-mail and password or his Google Plus account to log on. Well in addition to what we've talked about, another benefit is Firebase's two tier approach. Many applications use a three tier approach where the middle tier contains business logic or some application server. But this introduces complexity and system management issues. For shopping list plus plus, it's not necessary. Instead, with Firebase you use a two tier approach. Basically, this is a client server model where you communicate directly with the database. It's cheaper, easier to maintain, quicker set up and in the case of Firebase, highly performant. All right, that sounds pretty good to me. Although I do have one more request. Do you happen to know any developers that are actually using Firebase? Sure I've actually got a Firebase developer advocate here with me right now. Well, shoot. I'm a bit busy getting our first user set up with the app but the developer has some free time. Maybe they could join you. Sure. That'd be great. Hey, if you want, you can take the company skateboard. [MUSIC] Hi, I'm joined by Jenny Tong, the Developer Advocate on the Firebase team. Welcome Jenny. Hello. So I've got this friend who has developing an app and considering Firebase. Who's wondering if you have a little time to answer some questions. Of course. So, I guess the most basic question is, do you have some examples of Firebase being used in the real world. Yes, a few examples come to mind of a few great uses of Firebase. One is Go To Meeting which uses Firebase for real time signaling between clients. So you know when somebody's taken the mike to speak. Another example is Twitch TV, which does video game streaming. They use it for signaling all their streams coming online. My favorite is probably Warby Parker's location in New York. Warby Parker uses it to control the pneumatic system that delivers your glasses to you. Right while you're waiting. That's really cool. Mm-hm. So why did these developers go with Firebase? What was unique about Firebase that made it the choice for them? So, I think the thing that makes Firebase unique because there's a lot of options for building back ends for you is just how easy it is to use Firebase. People usually get pretty comfortable with Firebase after a few hours and have a production-ready app within In a couple of days. That's awesome. So in your opinion what is like the killer app or the most differentiating piece of Firebase? So I think the applications that work best with Firebase are ones that are going to be generating a lot of structured data from user interactions. Like one of the classic cases of this is chat which is one of the deceptively hard things to build on your own. So things that you can model, think of as a track communication between multiple people work really well in Firebase. So just expanding on that, in your opinion what are the classic uses? What are the best apps that are suited for Firebase? The best apps that are suited for Firebase. So any situation where you have like low frequency information or medium frequency information coming from mobile apps or web applications, that need to be synchronized back and forth between multiple platforms. [INAUDIBLE] Web and mobile. All those combinations, or even signaling internet of think systems and you don't want to build up independent infrastructure for each one of those. All right well Jenny thanks a lot for your time today. You're welcome. Wow, this is looking great. I think you both did a great job in version one, I mean point one. Mm-hm, yeah actually it was super easy. It was just a matter of installing the SDK and getting her up to sync the Firebase. Well, you've also done your homework, and Firebase seems to be a great choice considering your requirements. That is true. And you know what, we've been doing so much work, I think it's time for a break. I could really use some sleep, and there's actually some shows I've wanted to catch up on. Hey [CROSSTALK]. So yeah, we downloaded the app, and I got some friends to download it too, and we're really confused. Category keeps overriding the name of my shopping list. Okay, well could this wait until tomorrow? No. No it cannot wait because Jeff has been trying to order toilet paper since, I don't know, an hour ago? So you need to fix it. No, no, excuse me. Fix it! Fix it! Fix it! Fix it! Fix it! Fix it! Fix it! Fix it! Fix it! Alright I'll fix it! So, on to version point two. Hi everyone, hi. This is my twin brother Palter, he loves phones and shopping. Sup. Hi. All right, so well the question today is what do you want out of a shopping list app? That's a great question. What do you think, Palter? Well, I think what you really- Okay, I know instarritos. Whoa, interrupt much? Sorry, Paul. It's Paulter. It's a family name. Okay. to clarify multi touch Instarrito interface. I have a better idea. What about an app that let's you take regular drivers like you and me, and pick each other up and go to the grocery store. Isn't that Uber? Ooh, or 64 bit synchronized Instarrito support. What is that even? Look, I think we really need to be focusing on the gut reaction. Right? So maybe even have swipe support. Swipe right for cream puffs, swipe left for broccoli. I don't know. That's ridiculous. Who wants to be swiping for their food all day. Now cloud based API. This is a shopping list app, right? Mm-hm. Yeah. I'm not even sure how you add stuff to the list. How do you add items to the list? [BLANK_AUDIO] Okay, so I've got a great idea about what to do next. Yeah? Wasn't trained by developing that Instaritto API, but I think we should focus on building out the core app functionality. Here, let me show you. Here's our [INAUDIBLE] again and in version to the app, we're going to work on the shopping list screen and the shopping list details screen. Right now the shopping list screen only has one list, but instead what I want is for us to have a collection of lists. Now, you should be able to click on each of these lists, and it will take you to a shopping list detail screen, which is where will actually show what items are in the list. And then we'll be allowing users to collaboratively add and remove items from any of these lists. To do that, you and the developer are going to need to a lot more than just set value. You'll need to master the different methods of reading and writing with firebase. All right, ready to start coding? Hey there. So I was thinking, why don't you warm up by working on the detail view for the shopping list. I've been working on a detail view for the shopping list object. It's in the activeListDetails package that I just gave to you. Nothing is hooked up yet, though, to actually display this screen. Could you make it so that when you click on the text of the shopping list right here It opens up a detail view of the shopping list? And the name of the shopping list on the detail screen should exactly match the name of the shopping list that you clicked to open it. This should be a review of some of the Android code and Firebase skills that you learned in version 0.1 of the app. And actually, one more thing. So I've been working on a new workflow for us. And basically how it's going to work is I will describe a new feature and I'll send you the specification document. And that document will include my thoughts on the feature and how exactly the feature works. Also a couple of implementation tips that I can think of. I've written one for the detail screen interaction that I'm looking for. Care to take a look? [INAUDIBLE]. So we have the details screen up and running, sort of. And, well, basically what I want to be able to do is edit shopping list names. I mistype texts all the time. If I accidentally type something like, I don't know, grassery list or shipping list, I should be able to change it before all of my friends see. I know what you mean, I'm all thumbs sometimes. So, could I ask a favor? Go for it. So while I'm busy creating the different screens for the app maybe you could chat with the developer. Kind of get them up to speed on all the ways you can write data in Firebase. Sounds good let me pull up my screen. There are five write and remove methods for Firebase, depending upon what you want to do. The four write methods are, setValue, which is the most basic write operation. It writes or replaces data at the specified database location, replacing any existing data at that path. Update children, which is a method used when you want to write to specific children of a parent node but without overriding other child nodes. Push, the push method adds to a list of data. A unique ID is generated by push based on the timestamp each time a new child is added to a specified database reference. This allows multiple clients to add children to the same location at the same time without any write conflicts. Run transaction is used for complicated data. For example, when there are multiple concurrent operations. Using this method keeps data from being corrupted when you have multiple people updating a single object like a counter. In addition to the four write methods the remove value method allows you to delete data at a specified location. In addition to the four write methods the remove value method allows you to delete data at a specific location. So, you might have noticed that I preemptively added a little Edit Name button in the Menu Bar. If you click on it, the Edit Name dialog pops up. Now that you know more about Firebase's four write methods, can you add the code so that the app actually updates the name of the Firebase shopping list? Here, I'll show you what I mean. Right here is the Edit List button that I was talking about. When you press it, it'll show a dialog. You should be able to type the name in here, and then press Edit Name to edit the name of the shopping list. Shopping lists contain a few properties, and right now the listName is the only one that we're making directly editable. The name of the owner will not change. Right now the owners are all named anonymous owner, which is rather ominous sounding, but we'll worry about fixing that when we add user accounts in the next version. Now the timestampLastChanged property is interesting. It should update whenever we change any part of the list, so when we change the listName, timestampLastChanged will be modified, but it won't be directly modified by the user. So, when we change the listName, timestampLastChanged should also change. It's worth noting that, in the future, this area will contain a list of items in the shopping list, but that will come later in this version. Right now, just focus on making the name and the timestamp change using the right methods we just talked about. I'll send you a full spec right now. Have you ever noticed how sending off these update requests feels a little like you're sending messages off to the Firebase void, unsure whether they're complete or are received? There. Hello, are you there? Lila, are you there? Okay, well, at least you're still connected. Let's talk about completion callbacks. One aspect of writing data we haven't discussed is the completion callback. Completion callbacks are useful if you want to explicitly return the status of a completed write operation. For example, if you use a completion callback when a write is successful or fails, an object will be returned describing the success, or in the event of an error, failure of that write. For example, if you use a completion callback when a write is successful or fails, an object will be returned describing the success or in the event of an error failure of that right. We aren't using completion callbacks in ShoppingList ++. However there are a few situations where using completion callbacks would be useful. A basic use would be to provide detailed debugging information in the dev and test phase. For example, to provide an explicit way to verify that data is being saved. Another use would be to use a completion callback to fire when a value is returned that is outside of a threshold. As a comparison, have you ever seen the all changes save to drive message in Google Docs? It doesn't hurt to provide users with a little assurance that their data has been saved to the cloud. Similarly, sometimes chat programs will tell you when the message has been sent to the other user. [BLANK_AUDIO] My gosh, you are so annoying. Ow, ow, I didn't, why am I. You. Stop. Roommates, cut it out. All right. Now. What has gotten into you two? Some anonymous owner has gotten into my grocery list and changed it all to components. I swear, I didn't do anything. Lila, we need a way for each of us to have a separate shopping list. All right, all right. Well, I'm going to work on user accounts in the next version, so I can't do that right now. But what I could do is give you guys multiple lists. Yeah, that sounds reasonable. Fine. Good, now why don't you two make up. I guess I can forgive you. Good, Grace? There, isn't that beautiful? All right, now we can all get back to work. You could make a case for many of these methods. For example, you could choose to use the list name as the key here. Then you could use setValue and pass in the list as an object to add a new list, much like we do here. You could generate the URL location like this. You'd make a new Firebase reference at the base URL. Then you go to the child activeLists, and then you make a new child, which is the name of the current list, so setValue is definitely possibly an option. Now, updateChildren will only edit the key value pairs that you pass it, so it's a little bit clunky for creating a new list. You'd have to convert your object into a hashmap, so it's really good for editing a couple items, but in this case, we probably don't want to use it. runTransaction doesn't make a huge amount of sense. You don't need to worry about two people both editing a previous version of a list. Since we're making a completely new list, two users are not trying to edit the same data, and the order that people make their lists in isn't extremely important. So the actual answer is a combination of both push and setValue. How do you use this combination, and why is it superior? Well, push creates a new key for you, so instead of relying on something like the list name, you can allow push to make some sort of key. Push creates the key for you, and then setValue actually sets the shopping list at that location. Now you might be wondering, why do we really need to use this push thing, and why's the key so important? Well, let me tell you why. I just said that using a combination of push and set value is the best option for adding new shopping lists to the Firebase database. But let me show you why instead of just telling you. Right here is where we have our list of shopping lists. This is all the data for one list and here's all the data for another list. And for the sake of space, I'm not drawing out the whole tree for every single shopping list. Using the three other methods besides push, we need to choose what to use as the key for each of these objects. A reasonable approach might be to choose the name of the list as the key. Consider a scenario where we've written the code for user accounts. And in this scenario, we'll say that both my roommates Walter and Kagure have their own user accounts. And we'll say Walter has one list, which is named grocery list and Kagure has one list which is named party supplies, and they're represented here. Let's decide that at some point while using the app, Kagure decides that she wants to make a list called grocery list for herself. It's completely separate from Walter's grocery list that he's made for himself. At this point, if we're using keys for names, we'd run into the issue of having two lists that have the exact same name, and therefore the exact same URL location. So what would happen? Well, if there aren't any permissions that are protecting lists from being overwritten, Kagure's list could simply overwrite Walter's. Walter would probably not be super thrilled to find that his list has been randomly overwritten. If we had permissions that kept users from overwriting other user's data, then Kagure would be in this position where she's being denied to write a list called Grocery List. So maybe if Kagure was feeling particularly like she really wanted a list called Grocery List, she'd make something like Grocery List 1. And the next person could make something like Grocery List 2, and Grocery List 3, and so on. This isn't the best user experience, and this is kind of silly. Just because one person has a shopping list named grocery list, that doesn't mean that nobody else using the app should also have a list called grocery list. Another option is to not use list names as keys and instead to try to find something else that is certain to be unique. Enter Push. Push generates a unique ID for you to store a list under and it ensures uniqueness. Here's some examples of what push keys look like. They're sort of bizarre collections of numbers and letters. Via Firebase magic, this ordinary string has the extraordinary attribute of being completely unique. So when Kagure wants to add her grocery list, push will generate a unique key for her, thus allowing for both Walter and Kagure to have grocery lists. Okay so hopefully right now you agree that using Push is a good choice. Now Push only generates this key, so you also need to use set value to actually generate and store this value here. What I want you to do is update this button so that it adds a new shopping list to the Firebase database and if I keep adding lists I should see my data growing here. Now you could watch me do it, but you're a developer, so why not try it yourself? I'll send you a spec. And actually, in addition to implementing Push, could you also add a timestamp created property? It should store when the list was created. It's always good to keep track of these things. Before you get started, you probably want to go ahead and flush the database. You're making a big enough change right now that having old data could create errors or confuse you. To quote, unquote, flush the database you can go to the Dashboard and delete it. [BLANK_AUDIO] It's scarily simple, just click this little red x. Obviously, in a production app and a lot of times when you're in development, this could be really disastrous. So if you're worried that you might want to revert back to the dataset that you had before, you could always export your data here. It spits it out as JSON and then if you ever need the data back you can import it here. But this is sort of throwaway data. What? Where did my shopping list go? Lila? Got to go but I'll send over the spec right away. About the four write methods in Firebase. But it sounds like you want to read from the Firebase database as well. It's time to become fully Firebase literate. Reading data in Firebase is all about Listeners. You set a Listener and then define what it does whenever it receives new data or changes to existing data. It's always triggered with initial data and then it is triggered again whenever there is new or changed data. There are three ways to add read Listeners in Firebase. AddValueEventListener receives events about changes to data at a specific location. AddChildEventListener receives events about changes in the child locations of a given Firebase reference. It is useful when trying to keep track of lists of data. The third method is addListenerForSingleValueEvent. AddListenerForSingleValueEvent looks almost exactly like addValueEvent Listener. But it does only one read when you make it. [SOUND] What's on your mind? Well, so I've been chatting a lot with the developer about the order of certain events which got me thinking. Let's say you have a user. Hm-hm. And the user does a couple of edits. If there any way you can know how Firebase sends these edits to the server or what order they're processed in, or what order they'll trigger event listeners in? I was just working through some of these scenarios earlier today. It turns out that Firebase does have what they call Event Guarantees. Which are guarantees about how Firebase will handle your data. Let's take a look. Firebase provides several related guarantees for database events. All Firebase operations performed locally by your app will immediately fire events. Events are notifications such as a child node was added or a child node was changed. This is helpful when there is network latency or loss in internet connectivity. In these situations, when connectivity is reestablished, the app will receive the appropriate set of events and all the clients will catch up with the current server state. Another guarantee is that of Eventual Consistency. This means that events will eventually reflect the correct state of the data even when temporary events such as separate clients writing similar changes to the database at approximately the same time, prevents an immediate update to the database. After some time passes, the database will become consistent with all the changes. A third guarantee is Event Order. Rights from a single client will always be written in to the server and broadcast out to other users in order. If a single client performs right operations to three locations in its Firebase database, those three operations will be delivered to all currently connected clients in the same order that the originating client sent them in. Finally, Firebase guarantees that whenever something is read from the database with a value event type object. For example, add value event listener or add listener for single value event, it is triggered last. This is in the case where you have both child event listeners and value event listeners on the same location. The child event listeners will be triggered first. So when data is stored or when it changes the order is, data is written or updated, the data is then synchronized to a data snapshot, child events are triggered, and then the value events are triggered. Now that you know the various ways to read and write from Firebase, you might have noticed that to update a piece of data there are a lot of moving parts. You can call a write method to update the data, then the data's changed in the Firebase database. This triggers your listeners which you've added, and finally the UI is updated. With so much going on, when you're trying to debug what might be going wrong anywhere in this process, it can be a little tricky. So let me tell you about a helpful method that I've been using to track what my code is sending and receiving from the Firebase database. So here I am in my ShoppingListApplication class. If you find like you need to debug your app you can type the following in. Firebase.getdefaultconfig.setloglevel.l- ogger.level.debug. This turns on Firebase's debug mode. And in debug mode, you get a printout of useful data in the logs about what is sent to and received from, from Firebase. So let's run the app and see this in action. With the app up and running, I can open up the logcat output and change it from Verbose to Debug. Okay, so I've cleared the logs. I'm going to go ahead and add a shopping list. And we can see here that, in the logs, I actually get a lot of information about what was just set and where it was set. I made this list called Let's Go Shopping with an anonymous owner, and here's the timestamp info. And here it shows the data that was being sent through, you can scroll over a little bit. And if I go over to my dashboard, I can see that it has in fact been sent to the database. Knowing how to both use the debug logger level and to make sure that you keep checking what's going on in the dashboard, will help you really make sure that your app doesn't have any bugs in it. So now, whenever you run into a bug, you can always try turning on the debug logger level as well as comparing what's going on in the dashboard. Hm. We've got all these methods and we know when they'll happen. I think you're probably ready to make a ListView in the UI code so that you can add these items. [NOISE] Wait a moment. JP wants to join the hangout. Hey JP, how's it going? Good. Good. I just wanted to check in on the app. I'm having a pretty good time. Our new developer is getting up to speed very fast and Firebase isn't giving us any trouble. We're currently trying to figure out the best way to display lists of data. Well I haven't looked into it yet, but have you heard of the FirebaseUI. Yeah, I actually remember reading something about that. It's a Firebase library, right? Okay, I should probably look into that to make sure we don't start writing code that somebody else has already made. Glad to be of service, send over a demo when you got it. Will do. All right, I think I've got a link here to the Firebase UI. This is all coming back to me, actually. Let me show you my screen. So here's the Firebase UI package on GitHub. It contains a Firebase array class, a Firebase list adapter class, and a Firebase recycler view adapter. Before I go much further, I should mention that this section requires an understanding of ListViews, adapters, and how they work together. If you need a refresher of ListViews, I've provided some links in the instructor notes. Please pause now and watch these to get up to speed, or the rest of this section might be very confusing. Before we dive into any code, let's talk about how these classes work together with your app. Now the goal of Firebase list adaptor and Firebase array, the two classes we'll be using, is to use the Firebase SDK to keep your list of online Firebase objects, such as your shopping list objects, synced with data displayed in a ListView. The general idea is that you have a ListView, and this ListView is hooked up to a Firebase list adaptor. Firebase list adapter is backed by a Firebase array, but at least synced to your Firebase database. Changes in the Firebase database it updates the array. The array notifies the adapter that the data set has changed. The Firebase array data converts it into a POJO, and then uses the POJOs to make the items for the ListView. All you need to do is update the item in the Firebase database, and that will start this whole chain process. These classes work together. Ways that you can add listeners for reading from a Firebase database. Listeners, what method is used to attach a listener to sync a local Firebase array, with a list in your Firebase database? You could just look at the source code, but you should be able to figure this out from what you know now about read listeners. If you said addChildEventListener, you'd be correct. We've got a list of shopping lists. Each of these single shopping lists is a child of this root node here. If we attach a listener here. Using addChildEventListener, we will get notified when anything happens to the children. And unlike the value of EventListeners, instead of getting all of this data returned to us, we'll get data specific to the child that was changed or removed or added. Because of that, addChildEventListener is the way to go. You know that the FirebaseArray class uses ChildEventListeners. And it does that by implementing the ChildEventListener callback interface. The point of the FirebaseArray class is to keep a collection of items that are in the Firebase database, in sync with a bunch of matching database snapshot objects that are in the fire base array class. Specifically the snapshots are stored in an instance variable called m snapshots. So Firebase array uses these child event listeners to see when things are added, removed, changed, or moved in the Firebase database and then make the changes in its own internal array list. And then it triggers the Firebase list adapter which makes all the visual changes. I was actually messing around with the Firebase array code a bit earlier and created a little mini project. And you can use this mini project to get practice using some of the child even listener code. This is all optional, but if you'd like to get some practice writing code with some ChildEventListeners, I'd suggest taking a deep dive into the code of the Firebase Array and Firebase listed after classes. It'll also make it a bit more clear about how the internals of these classes work. I'll send over my code now and you can take a look. Now, that you've wrapped your head around what the Firebase UI is actually doing, let's pop it into our code. Here the general steps that I've laid out to get things up and running. I've taken the liberty of already doing steps two and three for you. There's already an mListView object in the code for you. And I've also made an XML layout called single_ active_ list. You've actually already used this layout to display one list. Also, that describes in greater detail how to do all this stuff. The most complicated slash interesting part is in the fire-based list adapter. There's this method called PopulateView, which is meant to be overwritten. PopulateView is a method that supplies two key arguments. First is a view that is the inflated version of the layout that you gave the adapter upon creation. It also gives you a POJO, which in this case, will be a Shopping List. It's then your job to take this view, grab the sub text views, images views, and whatever else there is in the layout, and then, appropriately fill it with data from the POJO. Okay, I'll send over the spec now so that you can add Firebase UI to Shopping List Plus Plus. Have you ever had that experience where you fix one bug, and it just creates, well, more bugs? You might of noticed that we lost some functionality from the app. You can actually no longer click on items to open up detail views. This is because we've removed the layout we were clicking on, and destroyed the on click listener. Let's think about this as an opportunity to rethink how we actually open our details list activity. Okay, I'm here in ActiveListDetailsActivity. If I scroll down to the onCreate method I make a new Firebase reference here and I attach a ValueEventListener to that Firebase reference. This is the URL that we're listening on and it's statically attached to whatever's stored in ACTIVE_LIST. Now that we've got a lot of lists, we're going to need to change this URL so that it's referring to the specific list that the user just clicked on. Which means if I go over to ShoppingListsFragment here, in this onClick listener here in ShoppingListsFragment that's attached to the ListView, I probably want to pass on some information about the list item that I just clicked. And we can easily do that with a intent extra, so what you should be asking yourself is what extra data do you actually need to send over so that you can make that specific URL to the list that you're interested in. So should we send over the push ID, the shopping list name, or the Firebase reference object pointing to the specific shopping list? I think that the push ID sounds like a good idea. The end goal is that we're going to make a value event listener. And we need to have a Firebase location to do this. The shopping list name is not part of the Firebase location. I can actually show you that the list name is not part of the list location by going into the database, clicking on one of these lists and we can see our URL location up here. It's the base URL, active lists, and then the push ID. There's no name in here. So shopping list name is not a good choice. Now we could try to use a Firebase reference object that's pointing to the right location. But putting anything in an intent, other than a primitive value or a string, requires serialization of one form or another, which adds code bulk. The push ID is the only changing part of the location of a shopping list and it's essentially just a fancy string. So this is easy to pass in an intent extra. So push ID makes the most sense. I'm here in the shopping lists fragment class. When you click on an item on the shopping list screen this code here triggers. Get ref is a method in firebase list adapter that returns the firebase reference of an item. The key of the shopping list is the push ID. So you can use get ref and get key together to get the push ID and then pass it to ActiveListDetailsActivity as an intent extra here. Opening up ActiveListDetailsActivity here, and scrolling down, we see the first thing we do is grab that push ID from the intent, use it here to make the fire base reference, and then attach a value event listener to that location. So this ensures that we're listening in the appropriate location. Now you're also going to want to make sure that the dialog for editing the list name works. If you look at the edit list name dialog fragment, you see it extends this edit list dialog fragment. This is a super class that I made that abstracts out some of the common methods setup and variables that are needed by the edit list name, edit list item name and add list item dialogue fragments. Since all of these classes edit a single shopping list in one way or another, they will all need the push ID eventually. So I'm going to open up this edit list dialog fragment super class. [BLANK_AUDIO] And what you should of done is in this new instance helper here, added the list ID as something that gets passed into the super class. And then down here in the onCreate I'm setting a member variable to that list ID. So basically in all those classes that then extend this super class, I have mListId available to me. I know you didn't write this code, but hopefully the connection between the dialog fragments makes sense now. So going back to making sure that EditListNameDialogFragment works, I'm back here in that class. I'm going to scroll down, and doListEdit is the method that gets called when the positive button gets clicked. And again, this is something that's set up by the super class. And we can see that I'm using the mListId here and generating the correct reference that you need to be able to update that list name. Aw, yes! You're now able to create many shopping lists. And get an ever expanding list of lists. Now when you open a list, I've provided in the drop down menu this little menu item that says Remove list. It opens a dialogue for us to be able to delete the list. But I haven't connected it to Firebase yet. Could you do that next? Before you implement remove, I got a quick question. Given what you know about how the FirebaseListAdapter works, and that this is a class that helps keep an array on your phone, in sync with an array from Firebase, what should happen when you click Remove? So, your options are, you manually remove the ShoppingList from the FirebaseArray, and this triggers an update in the Firebase database via a listener. Option B, is that you manually remove the shopping list from the Firebase database instead of from the FirebaseArray and then that in turn updates the array. So this is basically the opposite of option A. Option C is that you actually have to go and write the code to manually remove the shopping list from both the Firebase database and the FirebaseArray. And D is that you actually don't have to do anything. The data is actually automatically removed from both the Firebase database and the FirebaseArray via a listener. Once you've answered this question, I'll send over a spec for the remove functionality. In this case the correct answer is B but let's see why. FirebaseListAdapter and FirebaseArray are providing the logic to receive events from the database. Answer A doesn't make any sense. The FirebaseArray is stored at a variable called M snapshots within the FirebaseListAdapter. As such, it's encapsulated within the FirebaseListAdapter and there are no methods in FirebaseListAdapter that allow you to write to its contents. So you or your app's code cannot actually change anything in FirebaseArray directly. Because of that, you manually removing ShoppingLIst from FirebaseArray is just something you can't do. C is incorrect for a similar reason. Again you can't manually remove things from the FirebaseArray. Now the FirebaseArray does have a bunch of on child listener methods and this is because it implements the child event listener interface. Which reactively changes the underlying array when the Firebase database changes. Which is what this could connection here is showing. So, if you were to manually remove the shopping list from the Firebase database, that removal is automatically pushed to the Firebase array. Now Inter d is just a little bit funky. While Firebase does make a lot of stuff happen for you automatically, If you want something to be removed from the database, you can't just sit around hoping that it'll happen. If you're using your app, and let's say J.P. deletes something, it could seem like magic that both your database data and your Firebase list adapter just so happen to update. But ultimately somebody, somewhere is using the app to manually make a change to the Firebase database. So D really isn't a correct answer. Hey there, so I've got one more sort of lingering question in my mind. I know we're using all these Firebase UI classes for basically everything in the app to do with lists. But I'm confused why Firebase array doesn't just grab an array list. Hey, looks like J.P.'s texting me, and he wants me to go to Google and talk to a Firebase expert. Well that's pretty cool, but I'm not free. I told Kagure I'd cheer her on in the finals of the Cheesy Flakes cheddar cheese cook off championships. Hm, but you're available right? Why don't you head over there right now and report back what you learn. want to borrow the company bike? [MUSIC] So how does Firebase treat lists in arrays? So, lists in Firebase deviate a little from the traditional array concept you're used to. The big difference is in Firebase, we always have these key value pairs. That value might be an object with more keys so you can have this hierarchical structure, but it's always a key and a value. An array in a traditional situation is a key value pair where the key is an integer, and the pair is whatever data is stored in that array. Firebase doesn't quite like that. You can put in integer keys, you can make an exact normal array structure in your Firebase. But when you're building real time applications that deal with information that's changing quickly, or a lot of new information that's being added. There's a really good chance that two people are going to try and add the same new integer key at the same time. So if we have four items and then somebody adds a fifth, and another person across the planet adds a fifth, one of those people are going to win and the other one's going to lose their data. That's why in Firebase, we use this concept of pushing in with these unique push ids. These are pretty much globally unique identifiers that will be sorted in the same way as integer keys, where if I push in later it will appear later and they essentially function like an array. The only difference is instead of having one, two, three, four as our keys, we have these long complicated stings. But once it's in there you can pull the data out, you can look through it, you can do everything you would on a normal array. Especially if you're using one of our helper libraries. It's just the structure looks a little bit different in your Firebase. So why did Firebase take this approach. It was mostly our concern for the real time aspect. We wanted to make it really easy to build data that multiple people were editing and collaborating on at the same time. And like I said, you can run into these race conditions where you have multiple people trying to add onto the same list. And the integers, it's just too likely that two people will write to it at the same time. Using these unique keys, we can guarantee that if two people, or 100 people in the world will write to this location at the same time, they're not, no one's going to lose their data. No one's going to get overwritten by someone else, they'll all be unique, all the data will be there. And you can ensure that all your users interactions will be safely stored in Firebase. So what are some of the pros and cons of this approach? Well the con is that it's a little unusual. People are used to dealing with lists as arrays, they're used to those integer keys. And when people look at their data in Firebase they see this familiar push method that comes in any of our SDKs, and they assume it's going to act like a normal array. Which for many reasons it does, but the big change is that we use these unique IDs. So, that's probably the real big difference that people see, is just that, it's a little unnatural. But as soon as you realize why we make these decisions, and why we're helping you to make sure that your application scales and runs efficiently at any size, then it makes a lot of sense. Well, are there any times that you need to use an array, and how would you do it? There are definitely times people want to use arrays, and it typically has to do when you're integrating with an older system, or some existing application that is very committed to using these traditional arrays. And you can do that in Firebase, you can use integer keys in your Firebase, it's completely fine. The important part to remember is just that if you have a lot of people writing to this data at the same time, trying to change that array, trying to add in new things, you're going to run into issues. But if you have, for example, a dot net application that every 24 hours it's pushing in a list of your top 100 users into Firebase, you can use normal integer keys just like a normal array, and that's fine. because you only have your one server ever writing into Firebase. There's not going to be any erase conditions, there's not going to be anything like that. So that's completely okay. And Firebase does do some handling to help transition that into a normal looking array, especially if you're exporting JSON through our traditional rest API, which is what you would be doing if you were using dot net or any PHP, any of these more traditional stacks. So yeah, there are definitely situations where you can do it, and we support those, we just generally don't recommend it for any quickly changing, quickly moving data. Now you mentioned push IDs, how are push IDs generated, and what makes them so great? So push IDs can be thought of as a globally unique ID, they're not a traditional GUid that you've seen before, but for all intents and purposes they are completely unique, and they're a little magical in that they're lexigraphically sorted. Which means that if I push in now, and I call it pushing in later, it will sort as you'd expect, it'll come later in the list. We do that by basing it off of the time of when you pushed in, we look at an apec. And we say, okay, what is a nice version of this that we know will sort properly. And then we also add in some extra logic on top of that to make sure there are no collisions. So if I have a server running that's pushing in 10,000 items, we make sure that, even if you push those all in on the exact same millisecond from the same machine, there will be no collisions. So it is a lot of logic behind it, but the important part is they're just strings that will lexographically sort in the correct order. And they're so great just because they avoid all your race condition problems that you might have using traditional arrays. Well Abe, thanks a lot for your time. I think it's going to really help my friend out. I think she's going to be able to continue to developing your Firebase app, and, yeah, appreciate it. Awesome, thanks so much. [BLANK_AUDIO] [SOUND] [BLANK_AUDIO] [SOUND] Okay, I think we're ready to add items, take a look. Each item that you request from the store, be it a juicy intsarito or some delectable cheesy flakes should be represented as a object in the Firebase Database just like a shopping list is. This is because items are going to have a few things associated with them. For example, items will have names, they'll also have an owner for who requested the item. Eventually I think we'll also want to store things like whether the item has been bought and who bought the item. The point is that an item like a shopping list lends itself to be a Pojo. So first things first, you're going to make a pojo for an item. Then you'll need to update the UI to both create items and display lists of them. We'll just start by making the Pojo. It should contain these two properties. And for owner, we'll just stick with the string anonymous owner, like we've been doing for the shopping lists. Remember to follow all of the rules for making Pojos that you learned before. I provided a link to the material about making Pojos in the instructor notes, if you need it. When you're done, go ahead and click here. Now that you got a POJO, you might be really eager to start inserting items into your code. But hold on a second, lets talk about performance. I want you to consider a couple of different database organizations, or data structure organizations that we could use for shopping list items. Here's one I'm going to call Data Structure A. We have our root, our active list, and then here's the data for each of our lists. When we add items, we'll go ahead and add them inside of each of these lists. So, here are our lists of items within our shopping lists. So for example, this shopping list here who's name is stored somewhere in here, lets say Smores Supplies, has four different items each with their name and their owner, and this shopping list has two items each with their name and their owner and so on. This basically has all the information for a shopping list bundled together in nice little shopping list objects. This organization matches what we're used to when we think of Java objects. You'd probably have an array list of items within your Java shopping list object. Okay, let me show you something a little bit different, here's Data Structure B. It starts out pretty similar, and then instead of storing items as part of the shopping list, we make an entirely new node. Maybe call it something like shopping list items, and then store the items for the shopping lists here, separately. So, my question to you is, which data structure is preferable. All right, here are two data structures side by side. To analyze which of these data structures is better, I want you to take a look at the two main screens that we have in our app right now. This right here is the ShoppingLists fragment screen. And as you can see, it has all of our shopping lists, and then we have the active list details screen, and then we have the active list details activity. And this is of course, the activity that will contain all the items on it, as well as information about specific lists. Now, before you answer this question, I want you to consider this fact. Each time you grab a data snapshot, it takes a picture of a specific portion of the database. If you take a picture of active lists here, it contains all of these active lists and all the children nodes. If you take a snapshot of push ID K6215, it will also contain all of its children, but none of these other nodes or parent nodes. When shopping list ++ hopefully becomes very popular, we're going to have a lot of shopping list items and a lot of users, and we want to minimize the data sent between the server and the app. So if you had to choose one of these two data structures solely for getting all the information that you need for the shopping list fragment screen, would you choose A or B? In the same way, if you had to pick one of these two data structures for active list details activity, which one would you pick A or B? To answer the question of which of these two data structures you think is better, I want you to think about the requests you need to make to display the data on the two main screens of the app. Let's look at the active lists details activity first. We don't have any items left, but eventually we do plan to have them here. So we should be picking a data structure accordingly. If you decide to go with Data Structure A, you simply need to attach a listener on the list that you're interested in, such as this list right here and then that will contain all of the data that you need to display this screen. You have all the list properties here such as the owner and the edit time. And then you have all of the items, which I'll display here. Now with data structure b, you'd actually need to attach two listeners. You need to attach one here to get the shopping list data. You need to attach one here to get all the shopping list data. And you need to attach a corresponding listener here to get all the shopping list items. Now you're retrieving the same amount of data in Data Structure B as you are in Data Structure A, but in Data Structure B it just happens to be in two different places. Overall that's an extra listener. So it looks like Data Structure A is a better choice for ActiveListDetail screen. But let's go ahead and take a look at ShoppingListsFragment. On this screen I simply need to get a list of shopping lists. If we're looking at Data Structure A and I attach a listener to active lists, I would be grabbing all of this data. And that's great, but it also includes a lot of item data. Now looking at the screen, you might notice there isn't actually any item data that's displayed here. So essentially you're downloading a lot of extra data, which doesn't sound too great. In comparison we have data structure B, and similarly we could attach a listener to activeLists and that would grab all of this data. And because the item data is separated out down here, you wouldn't be grabbing any of that item data. So in this case Data Structure B is a much better option because you'd just receive the data that you need. And the disparity between how good Data Structure A is and Data Structure B just grows bigger as you start to get more users and more items. Overall pulling down extra data is a much bigger deal than making an extra listeners. Listeners were built to be pretty lightweight and when you're using Data Structure B on the details page, you're actually not requesting any more data. So Data Structure B turns out to be the better option overall. Now that you've decided how to structure your data, it's time to write the code that will write these shopping list items into the correct location and read them as well. Okay, so on our shopping list page we currently have a useless button for adding more items. When I click Add Item here it doesn't really do anything. Here's what I want you to do. When you click the fab and you enter the name of the item, and you press Add Item, what it should do is it should see what shopping list you're on. Go to a node called shopping list items. Use the push ID for the shopping list that you're currently on, and create an item under that push ID. Did you catch all that? Let me show you a quick example. Say I've got a shopping list with the push ID, 1234. When I want to add a new item, such as bacon to this shopping list, it'll go to this node shopping list items, make a node with the same key as the shopping list up here. And then put the bacon item there. If I wanted to add lettuce and tomato to the same list, with the key 1234, they would also be added to the node shopping list items, with the child one, two, three, four. Now, you might have noticed that I didn't tell you what the keys for these would be. What you want to make these keys is up for you to figure out. And just to drive what's going on home, let's say that I have another list with the push key 1999, and I wanted to add cooking oil. That would look like this. Instead of adding it onto the list of items in 1234, you would go to the list 1999 and make a new item there. Getting the data to add in the correct place is the trickiest part of this exercise. Remember that you should have saved the list ID in a member variable called mListID. Just like when we started to have multiple shopping lists, start by just getting the data to appear in the Firebase back end. Once you've got the data correctly adding itself in the back end, then you should set up a Firebase list adaptor that will display your items here. This actually really isn't much different than when we added the Firebase list adaptor in the shopping list fragment. So you can refer to that if you need to. I'll send over the spec now. And finally, sorry, before I forget. You should remember also that when you delete a list, using this Remove dialog, that it should also delete all the items that are associated with the list. Okay, good luck. This was a pretty tricky group of features to pull off, it actually had three parts. The first was to make sure that you were correctly writing item objects to the Firebase database. The second was to then get those objects and make them display in the app. And finally, you had to make sure to fix your cleanup so that when you removed a list, it also removed the list of items. All right, let's start with the first step, which is just making sure that we add items to the right place in the back end. So I'm going to go to the AddListItemDialogueFragment class. Okay, I'm going to scroll down until I'm here in the do list edit method. Now this method is basically going to do two things. It's first going to construct an item object POJO with the input that the user gave. And, then it's going to send that POJO over to the correct location in the Firebase database. Here's where you make the POJO, it's pretty straightforward. Right now, I'm just passing in this mItemName variable. That's equal to the value that you could get from the edit text in the dialogue. Saving it to the correct place is a little bit more complicated. I get the reference for where items should be saved in the shopping list, here. Let's see what this URL here is. So this is a combination of the base FIREBASE_URL and the FIREBASE_LOCATION for SHOPPING_LIST_ITEMS, which is the string shoppingListItems. Okay, so we have that base URL and then we go to the child that's equal to the ListId. You have to make sure that you're setting mListId correctly, it should be the push ID of the shopping list that you're adding this item to. Okay so now that we have this itemsReference, where do we want to actually want to store this particular item, and what methods are we going to use to store it? You still need a unique ID. Remember when we were mapping this all out and we didn't quite know what ID we were going to use for the items? Well there's no reason not to use a push ID. Again, it's a unique ID, so it's handy for the same reason that using it for the shopping list was handy. Basically, it makes sure that each of your shopping list items are definitely unique, separate items. Okay, so I do that here, I take my items ref and I get a push ID which makes a new Firebase ref for me with that push ID. And I go ahead and I save that push ID here in the item ID. Now hopefully you remembered that you have to update the time stamp last changed whenever anything about the shopping list updates. So that I could bundle the whole update together in one fell swoop, I decided to use update children instead of set value. This allows me to update something in the shopping list object as well as to create a new item elsewhere in the database. You can't use POJOs with update children so I used an object mapper class to get a hash map version of my object. And then I put both the updated time stamp and the new item into a hash map and push that all with update children. Okay, so let's see what that does. Okay, so I'm going to go into movies snacks and add some popcorn. Okay, and we can see here that it actually made a shoppingListItems node. And here's the push ID of the shopping list that I was adding to, you see that these two match. And here's the push ID for the item, so it's the shopping list push ID, the item push ID and then here's the actual item itself. Okay, so it looks like we're adding items to the back end just fine, so that's great. To get the items to appear here, as you can see in this sort of finished version of this step, you also need to add a Firebase list adapter. You might have noticed that there's a ActiveListItemAdapter meant specifically for this purpose. Within this class you should overwrite the populate view method. The code down here is for the little delete icon that you see. Right now it just calls this method remove item which doesn't do anything yet. Okay, so that's the populate view method inside the actual adapter, but then in the active list details activity class, you actually need to set up the adapter. So I'm going to scroll down and here's where I set up the adapter. It's pretty straightforward and it matches how you set up the adapter for the shopping lists. Okay, so at this point you've done two things. You've both successfully written data to the Firebase database and you're also reading out those items into this list adapter here. But there's one more thing that you needed to do in this code step and that was to update removing the shopping list. So I'm going to go to the remove list dialogue fragment, scrolling down. Here's where I remove the list. Now I could've used remove value twice instead of update children, but this would make two calls to the server. Using remove value is the same as using set value at the same location, and passing null. Similarly you can pass null to update children to remove a value. So I'll use update children, and pass null to these two locations here, the location of the actual list and the location of all the list's items. The mListId is all I need to specify which shopping list I'm talking about. And because I used update children, I don't have to make two different calls to the server. Whew, well, that was a bit tricky. It's also an accumulation of everything you've learned in this version of the app, so really great work for sticking it out. So then I said that Android isn't a horse. [LAUGH] One sec. Sorry my phone appears to be crashing. That's not good. No kidding. I think it has something to do with Shopping List ++. Ever since I downloaded the newest version and started using it my phone's been really sluggish. And sometimes it feels like it gets super warm, which is pleasant during the cool nights I spend coding, but probably isn't great for the phone. Hmm, any ideas what could be causing the slow down? Hm, well I've been so wrapped up with getting the features out the door, I haven't even thought about what might be going on. It's probably some sort of memory leak, and it probably has something to do with not cleaning up the listeners. Right, I'm looking at the docs now, there's a detach listener that looks useful. Hm, well I'm surprised that or Walter or one of the other users hasn't complained- No! My phone! It died! Why? Shoot, I should probably see what that was all about. Wait! Well, I got the docs here. At least you and I can go over removing listeners, and maybe you can fix the app. The code you're looking for is removeEventListner. To use this method, you'll pass in the event listener. However, the single location has multiple listeners, you need to make sure to go through and remove each listener. Keep in mind this doesn't remove child listeners. You'll need to call removeEventListner(childEventListener) for any child listeners. Lastly, Fire based list adapters will also need to be cleaned up. Generally, you should keep a reference to every listener and location you add, and then remove them in an onDestroy method. However, for Firebase list adapters you can call the handy cleanup method to have them self destruct and destroy any references they're holding on to. Okay, what did I miss? Is everything okay? Well, Kagure's okay. Her phone, poor thing. I told the developer about removing event listeners. Great. Can you remove them and then fix up the memory leak? So if you were to give guidance about where to put all these fancy read listeners in your activity, what would you say? You know, that's a great question and I'm not entirely sure. Eh, it was mostly rhetorical. I've actually done a little reading on this one. Here's what I found. Here's our friendly Android life cycle, where we create and destroy our Fire base listeners is a typical developer trade off. Memory versus network traffic in this case. Remember that every time you recreate a listener, it pings the database. And listeners are also so big they can be kept around for a long time, in which case they leave a memory footprint. So, there are some different rules of thumb that you should go by when you're actually creating or destroying your listeners. If you're going to come back to the activity a few times, you should make your listeners in on create, and get rid of them in on destroy. This is because your activity will be going in and out of the visible life cycle, and therefore on start and on stop, and on resume and on pause will get called many times as your activity lives. You put your listeners in any of these methods, you'll be generating unwanted network activity by continually recreating listeners. If the activity is likely to be a one off activity, you should consider making your listeners in on start, and cleaning them up in on stop. So you might be wondering what I mean by one off activity. Well, some sort of activity that the user is unlikely to return to. Such as a login screen. A user will probably log in once and then sort of use the app for a while. They might even minimize the app and do other things and come back to the app, all without visiting the login screen again. Now why not just put these in on created and on destroy? Well, on stop will be fired sometimes significantly earlier than on destroy will. And because of that you'll end up freeing up the memory sooner. With all of that said, the engineers at Fire base did build listeners to be relatively lightweight, but just like cleaning up your listeners, this is another best practice to keep your app running smoothly. Wow, you did a Latin version point two. There's a lot on this screen, it's looking pretty slick. Well it wasn't just me, we've been hard at work. Do you want to look at the y frames? Yeah sure, let's review what we've done. In version zero point two the app, you made the fundamental screens of shopping list plus plus. This included the main screen with all the lists, also known as the shopping lists fragment, and the shopping list detail screen, also known as the active list details activity. In order to do this, you needed to master reading and writing data. You also learned about the FirebaseUI library, which helps you easily show up to date Firebase data in the list view. At this point, you've got an app that can be edited by a bunch of users simultaneously, which can add lists, rename them, and delete them. Inside of those lists, we've also got items that any user can add. And on your own, I'm going to have you work on the edit and delete functionality for those items. If your users work well together, I'd say this is a pretty useful app. Well, JP, that's actually why you're here. Take a look. Wow, do humans even eat those? I don't know. It seems that we have a troll in our midst. Well, have you considered another option? Maybe something from outside your group of roommates? Anyone who told them to? But I hadn't shared the code with anyone, unless. You. You. Who have you been talking to? You're under a non-disclosure agreement. Was it Grocery Grabber? How much did they pay you? How much? You know, another way to solve this is to implement user authentication Firebase. With user authentication, you can share accounts, you can create lists and add items to lists. Interesting. That's actually not a bad idea. Yeah and Firebase user authentication is really pretty easy. Well, I better read up on user authentication, but I'll see you both in version point three of the app. Welcome. Please confirm your name. JP. Full name. JP Soucheck. Please verify your identity. Come on. I just want to see Lilah. What is your date of birth? September 12th. Father's middle name. Peter. Social security number. Come on. I just want to get through the door. Please put your eye next to the scanner. Scare. Mother of an Android. Eye scan verified, you may entry. JP, hey. So what's up with the whole door thing? Well you know given our recent trolling, I really decided that I think authentication is a priority for us. We need to know what user's identities are so that we know that they are who they say they are. Anyways, I made these cool wire frames. In fact, for version 0.3 of the app, the developer and I are going to work on the login flow. Luckily, Firebase makes authentication dead simple. It has support for email login and a bunch of other providers such as Google login. We're going to implement both. And then, once we actually know who's logged in, we can implement some cool functionality, like letting users signal that they bought items, or that they're in the store shopping. This will allow anyone looking at the list to easily see things like, Walter's in the store, or that Kugare has bought cheesy flakes. Right where do we start? Hm, well I should actually continue working on these login screens a little bit, but maybe you can talk to the developer about authentication. Let's talk about authentication. Firebase provides a full set of authentication options which can be easily configured. Options include email password, Google, Facebook, GitHub, and Twitter. Documentation is provided for each option. When a user authenticates in Firebase, a token is generated which is valid for the length of time specified in the Firebase log in and auth page under session length. For e-mail password authentication Firebase compares the e-mail password against a stored hash and then generates a Firebase token. For social providers such as Google, Firebase gets an OAuth token from the provider in the authentication process and then generates a Firebase token. Let's briefly look at the user log in authentication screen in Firebase. Here you see the user log in and authentication screen inside the Firebase application. You can enable email and password or other social providers here. For email and password and for Google, Lila will show you how to configure these as authentication methods, but before that, let's take a brief look at some of the methods you can use for authentication. Remember, these methods are provided by Firebase. As a developer, all you have to do is call them and Firebase does the rest. createUser() creates a new account with a specified email and password. Auth with password attempts to authenticate the fire base with giving credentials. Auth with OAuth token attempts to authenticate the Firebase within an OAuth token and the on off method listens for changes in the user's authentication state. This is useful when you want to determine the authentication state of a user, and subsequently force a user to log in if necessary. So now you know how to enable the email and password provider. Why don't you change the Android code to allow your users to be created? I've sent you the login screens I've been working on, and they're in a package called login. We plan to support two types of login that we're going to use for the app, email and password, and Google sign in. I'll give you a moment to look at them. We've got two new activities here. First is the LoginActivity, which supports both email password and Google login. Second, we've got the CreateAccountActivity. This creates new users with the email password login provider. Now I haven't added any of the Firebase authentication capabilities yet, so what I'd like you to do is start by adding the code for making a new account in the CreateAccountActivity. Afterall, we can't log anybody in if they're not created. Here's some code that I copied over from the Firebase documentation. It's basically showing you how to use this createUser method to make a new user with the email password provider. To start you get ahold of a Firebase reference, then on that reference to call createUser, passing in both the email and password that you want to associate. Taking a quick look at the CreateAccountActivity, I've made two edit texts for you that have this information that you need. The name up here is not something that createUser takes. We'll discuss how to incorporate that data in a bit. This third parameter is something known as a ResultHandler. The ResultHandlers have two methods, onSuccess and onError. And these get called depending on whether the new user you're trying to create, let's say onecooldude@gmail.com, is successfully added as a new user. If J.P. successfully adds himself, the code end onSuccess is called. If you used ValueResultHandler like I'm doing here, when onSuccess gets called, you get an extra little map of information that contains additional login information for a new user. And just a quick note, when you're creating a user you actually don't log them in. You have to call a separate method to do that. Now, in Shopping Lists Plus Plus' login flow, we don't even want to log them in when they're on this page. We have a completely separate activity. The login activity and that's where we log our users in. Now that's pretty much all you need to know about onSuccess. The other method in your ResultHandler is of course the onError method. And this gets called if anything happens and the account is not successfully created. So why might JP's account not be successfully added? Well there's actually a Full Error Listing on the Firebase documentation, which provides some insight in to what could go wrong. For example, there could already be an account using that email. Or the user could have typed something that isn't perceived as a valid email. To be able to know which of these errors occurred, you'll need to use the Firebase error parameter, which will match one of these errors given here. That's the argument shown right here. And once you've figured out what error occurred, let's say onecooldude was already taken, you might want to give a helpful message to the user in some way. Okay, so can you take this more generic code here and put it in our app so that when the user types in their email and their password it actually makes a new user for them? You'll know you're successful when you can go to the Firebase dashboard and see your new account. So I'm here on the User Login & Authentication page. And if I scroll down, in this area here you'll see when new accounts get created. But don't worry about actually signing in these new users, that's going to be our next step. Okay, looks like users are making accounts on our backends, so that's cool. But, none of them can actually login. Before my roommates start a riot, let's add some login functionality. Here's a quick overview of what happens behind the scenes when you login with Firebase. In the code for your app, you'll call authWithPassword(). This sends a message to your online Firebase database to try to authenticate the user. The online Firebase database has a hidden credential data store, which includes hashes of emails and passwords of users that have been created in your Firebase. Firebase is doing the hard work of actually checking the credentials. And if successful, it creates something called an AuthData object and adjacent web token. This adjacent web token, also called a JWT, is a token that is automatically stored for you by the Firebase SDK. It gets stored in local storage for you app, and this arrives between between app reloads. It's this token that allows your user to stay logged in even if they close and then reopen the app. Then again, this part is automatically taken care of for you. So you don't really need to worry about JWTs or doing anything with them. The AuthData object, on the other hand, is something that's explicitly returned to your code. And it's an object that contains basic data about the user. So then when you get the AuthData object back in your app, you can use this data to update your UI. As a developer, from your vantage point, all you really have to do is call this method here and then get a AuthData object back. The rest of this is handled by Firebase. Here's some code and it's also from the Firebase documentation on how to log a user in. And you might notice that this is incredibly similar to the code for making a new user. We start by making a reference. We then call the authWithPassword method on that reference, and we can pass in data from the UI, such as the email here and the password over here. Now as our third parameter we have a authResultHandler. And instead of calling on Success or on Error, we have onAuthenticated or onAuthenticationError. Now onAuthenticated gets called when everything just sort of goes fine with your authenticating. The user gets signed in and at this point you have access to this fancy authData object. And besides just having access to the authData object, Firebase also knows that you're logged in, which is important for the permissioning rules which we'll talk about in version .5. The AuthData object has a bunch of really useful methods. I'll talk about a few of them here. You can use AuthData.getUid to get a unique user ID that is associated with your user account. The user ID is the first thing you should think of if you're trying to exactly identify who this user is. Now, email is also good for the purposes of identifying exactly who the user is, at least in our case, because both Google Login and the email password provider accounts will have emails associated with them. So you might be wondering how you get a hold of email from the AuthData object. Well, the getProvider data method returns a map of data specific to the provider that you're using. And for the email password provider, that includes the email the user inputted. So you could get the email by doing AuthData.getProviderData.getEmail. So when you're using the email password provider, you can get the email by using getProviderData.getEmail. You can also get other things from the getProvider data map, such as a link to a gravatar profile image. I've included some information about Gravatar images in the instructor notes below. But basically it'll give you a link to a generic profile image of the user. And it'll give a sort of pixelated face if they haven't set a Gravatar profile pic. So in your app, if you ever wanted to use profile pictures, this would be a way to get ahold of something. And getProvider is another method that you might need to use. It tells you how the user logged in. Right now you're going to be setting up login through a email and password provider. But there's also Google, Twitter, Facebook, and GitHub. But you only get access to all of this AuthData information if your login went successfully. If there was an error, such as the extremely common one of accidentally typing either your email or password wrong, onAuthenticatedError would get called instead. And you can handle this in a similar way to how you handled errors with user creation. What I'd like for the shopping list plus plus app is that you do the same thing where you call set error on one of these input texts over here to instruct the user how to correct whatever they've done wrong. Okay, I'm drafting up the spec and we'll send it over right away. But in the mean time, could you do me a favor and look up what Firebase error is returned if the user mistypes their password? Also, what errors return if they mistype their email? You can find a link to the Firebase errors Java doc in the instructor notes. Looking at the documentation, we can see that if the user mistypes their password, that would be a INVALID_PASSWORD error. The specified user account? INVALID_PASSWORD error, which occurs when the specified user account password is incorrect. Meanwhile, if they mistype their email. And again, we're assuming that it's not somebody else's email and that they didn't mangle it so badly that it's not an email anymore. In that case, they will get a USER_DOES_NOT_EXIST error, because it will look like a valid email account, but it's not in the system yet. Okay, cool? Good luck with handling both of those errors, and I'm sending this back over right now. At this point you should have most of the server side, Firebase, and Google stuff set up. So let's go back to our Android app and talk about what we need to do to get that ready for Google login. The big picture goal is to get an OAuth token from Google and then hand that token over to Firebase. And this is all going to happen Android app side. Once you've gotten your OAuth token, the process is very similar to logging in with email and password. You call Auth with OAuth token, then Firebase uses the OAuth token to get data from Google, after which Firebase creates for you that handy JWT, and of course your AuthData object. And then finally you get your AuthData object so that you can update your android UI. Now getting an OAuth token from Google requires a fair amount of boilerplate code. And I've linked to Google authentication example, so you can take a look through it. Let's take a quick look at what's going on in our app. Okay, so I'm in the LoginActivity class, and if you scroll down you'll see that here, prefaced by this large comment, is all of the boilerplate code that I took to get the token. So really all this code is just to get that OAuth token and it's nothing too special but you can read through it. Now, I've left the interesting part of connecting the OAuth token to Firebase for you to do. Now, there are more things that you need to do with Google which are outlined in the Firebase and Google Authentication to be able to get that token. These include adding some libraries to Gradle, generating a config file, and adding permissions to the manifest. I'll provide you with the links in the spec document with how to set all of that up. Once you've got the OAuth token, signing into Google is almost exactly the same as signing in with email and password. Instead of an email and password, though, you provide the provider name which in this case is Google and that special OAuth Token. The result handler works exactly the same though. If the user is logged into Google and give shopping list plus plus all the correct permissions then onAuthenticator will be called and you'll have that handy dandy authData parameter. You should do the same thing with a user who logs in via Google as a user who logs in with email and password. Your app should send them to the main activity and not take them back to the login page if they click the back button. Okay, let me send you the spec. Great, I'm loving that the app now has login functioning, but now what? The app looks exactly the same. Yeah, well the Firebase database knows you're logged in but the Android app doesn't. And therefore it isn't doing anything different. So I've got access to this AuthData object immediately when the user logs in. I"m just not sure what the best thing to do with it is. Yes, sheesh, I'm just reading about this. There's actually a couple ways you can get information from Firebase about the user's authentication state besides just the on authenticated callback. Interesting. Tell us more. Sure, let me screen share. So you want to keep track of users authentication states, and for that there are several methods. You can use a callback method, an event listener, or specifically retrieve the current authentication data for a user. You've already learned about on authenticated. With this method you can trigger code as soon as the user logs in. But sometimes you might move to different activities in the app and continue to need the user's authentication state. You can use an authentication state listener, just like the normal Firebase listeners, will tell you exactly when data changes in the Firebase database, an authentication state change listener will tell you exactly when Firebase knows a user is logged in or logged out. And when you don't need the listener, you can use removeAuthStateListener to remove it. The getAuth method retrieves authentication data for the currently authenticated user, or null if the user is not authenticated. This method is synchronous, which is useful when restricting access to valid users of your application. This is how the flow goes. The user logs in with the app, calling auth with password or auth with o-auth token. This triggers the unauthenticated callback. It could also trigger any authentication state listener you've added. Finally, if I call get auth, it will give me a valid auth data object at this point. Great, so does that solve your problem? Well I guess the answer to that one is, it's just the AuthData object, give us all the information and everything that we need for the app. I don't see why not, what's everything in the app? What will change in the app bases on what user is logged in? A lot. For example, if Walter is logged in, and he creates a list. It should have is name as the owner of the list. Similarly, if he adds an item, it should be attributed to him, so that way we know who requested what. It could get more complicated from there. I probably want to add things like it only shows lists to the users that either made the list or have the list shared with them. I'll also want to record who says they bought which items. And maybe have even some way of signaling that users are currently in the store and shopping. Hm, that's a lot. It is, but for now, let's make this just a simple goal. Number one, have a user log in. And then number two, that effect should show up in the app. Here, let me show you one of the screens. So my first thought is, does the AuthData object contain all the information that we actually need to be able to make this change? And the other thing I'm thinking about is, how are we going to get the data from the login activity to the main activity? After all we get the authData here and then somehow in the main activity we have to pull up the information, Walter's list. So basically what's the best form for this information and what's the best way to move this information around in our app, great. And I think maybe we should tackle the first question first. Okay, so, what do you think? Does the authData object contain everything you need to display this data here? Let me know what you think. Hm. Yeah. You're right. The authData object doesn't contain everything you need. To be able to display Walter's list on the shopping list page. Remember when you were working on the create user activity? The user inputs his or her name here. But we didn't actually get the opportunity to pass that information to Firebase when we create the user. This is problematic. We're now gathering some data that is outside the scope of what Firebase saves internally for us and gives us in the off data object. And in cases like this, we're going to need to start explicitly storing our own user data in the Firebase database. You've made a good point. Hm. So Firebase is not storing all of the data that you need to represent a user in the AuthData object. Don't get me wrong, when you log in, Firebase does provide a bit of information about the user, and it passes along most of that information in the AuthData object. But the pivotal thing is that you can't control the properties that are stored in the AuthData object. If you need to associate data with a user beyond whats in the AuthData object, you need to explicitly store it in your own Firebase database. And because Firebase doesn't store a lot of app-specific data about the user. This is a fairly common practice among devs. Many developers will have user objects that hold app-specific user information that not available in the AuthData object. So, as we have done other times in the app when we need to create new data, we are going to make a POJO. Yehey! Your POJO should include a Name, an Email for convenience although it is technically part of the AuthData object. And a Timestamp for when the user joined. Now, what I want to know is where in the code should you add your new users to Firebase? Well, there are two ways that a user can log in. With Google and then with email and password. And the code watch would be a bit different for each. So I'm going to start with a spec for implementing the email and password functionality. Okay, so in what class do you think you should create and write your users to the Firebase database? Specifically for the email password provider. You can put your answer here. The answer is in the CreateAccountActivity class. Specifically, I'm going to scroll down, so here in the onCreatAccountPressed method, you call createUser, which creates the user in what I'm calling the Firebase credentials data store. And then, if it's successful, it'll call onSuccess. And then, this location is where you should create your own user POJO, which would contain all that extra app specific data, and then you can put that POJO in the Firebase database. Okay, so to reiterate, you should be doing two things. First, making a user POJO, and second, adding the code here to then effectively create the user in your Firebase database. I'll send over the spec right now. When a user logs in with email and password, you make a user object. Now, we also need to make those user objects when they're logging in with Google. This might seem trivial, but it does actually raise one good question about how we deal with user creation flow. Take my roommate Kagera. She has a Gmail account, and she also has a Google account. When she creates an account with this email it creates a new user. So then what happens if she logs in with her Google account that's associated to the same Gmail address? Should it make a new user? So I'm going to make a somewhat executive call and say no. In general I think it's safe to assume that if they have an email with the email password provider, and they have the same email with the Google provider that this in fact the same user. And because it's the same user they probably don't want their data split up into two different but very similar accounts. So, before I send over the spec, quick question. So what we want to do is be able to associate a person's password email sign in with a Google sign in, if they're the same. So given that, what should we use for the key if we want to associate these two accounts? Here are some options, what do you think? For a key for the user, we want something completely unique. For the same reason that we wanted a completely unique key for shopping lists, and shopping list items. We also wanted to be something that's easily accessible from AuthData. We also want a piece of data that we can have on hand when the user is first created. In relation to the keys uniqueness, two users could have the same full name, especially if they have a common name and we get tons and tons of users using ShoppingList++. So, this probably not a good option. Now, we've been using push IDs in this situation, but given that we have a unique UID and an email, do we really need to generate a new unique ID? Not really. If we wanted something like that we could use the already generated UID. So push ID is a no. That leaves us with either using the user's email or the user's UID. Now, UIDs are usually the go-to choice. They're uniquely generated for each user of Firebase. Now, because it's going to generate a different UID if a user signs in and makes a user with Password/Email versus with Google, the UID is actually not a really great option for our scenario. But because the two things that these accounts share is an email, and usually an email is only associated with one person, email is actually a pretty good choice for us. But there is one issue with using emails as a key. By nature, emails contain periods. And periods are actually not allowed as part of a Firebase key. So I'll give you some advice about how to deal with that in the spec that I'm about to send you. There's a few things that I'd like you to clean up now that we actually have user data to use and users logging in. First, I'd like you to remove all mention of Anonymous Owner. We know who the logged in users are now, so we shouldn't need to fall back on this. Instead, you should store the email address of the current user. I'd also like you to finish the goal we had in all of this, which was to change the main activity screen to show the user's name and then lists, like this. We're also using the encoded version of their email as the key to their user data entry. Because of this, if we simply have the encoded email everywhere in the app, we can easily load up any associated data with the user. When the user logs in in the login activity, we have access to their email through the off data object. And at that point we can encode it, which I'd like you to do in step three. And the fourth thing that I'd like you to do, is to store the encoded email as the current user in shared preferences. You should also store the provider that's being used there as well. This will be helpful because it will allow you to easily grab this information anywhere from the app. It also makes this information available to us on load, if the user happens to close the app. Okay, the full spec is on its way, let me transfer it. We've got sign up and login working. So I think the next task is to implement logging out. I'd also like to implement what happens when the user gets kicked off. So when can a user be kicked off? Well, usually when a user logs in they don't stay logged in for ever and ever and ever. And you can actually control how long Firebase will allow you to have a logged in user via the dashboards session length property right here. Just get to it by clicking on the login and off tab. Selecting a value here affects all forms of login. I'm going to go ahead and set this to one month. Now being kicked off is an automatic thing, whereas logging out is something that you choose to do. But both of these two actions should have the same effect. And that is to clear the user data out of shared preferences and to take you back to the login activity. Both of these actions will also trigger an AuthStateListener. So we can take the code that does this and put it inside of the AuthStateListener and then we'll be set in both scenarios. Now being kicked out because of session time-out is something that Firebase handles for you, but you're going to need to hook up the login button to have the correct behavior. To log out a user you simply need to get a Firebase reference and call unauth on it. That'll log out whatever user is logged in on the client. I've already written the log out menu option for you. You just need to make it visible. And I'll send over more details about that in the spec. Hopefully that's enough to get you started. And good luck. Along with all the other changes that you've been making in the app, now that you know who the owner is, you can start implementing some rudimentary premissioning. For example, there are some things in the app that only the owner of a list should be able to do. I'll start with two pretty simple ones. Only the owner of a list should be able to edit the list name, and only the owner of a list should be able to remove that list. Now if the person looking at that list isn't the owner of the list, they shouldn't even have the option to be able to do these things. You know who's logged in, and you should be able to grab list data for the database. So, could you write the code that will only show these options if the user is the owner of the list? I'll send over the full spec now. Take a look. Hm. What's up? So it looks like I misspelled my email here as americanguyw1521@mail.com instead of @gmail.com. But it's still letting me log in. Actually yeah, it's not really checking whether the email address actually exists or whether you own the email. It just kind of checks whether it's formatted like an email address. Hm, interesting. Wait, so hypothetically, someone else could sign in with someone else's personal email address. Yeah, I guess, if they wanted to. Intriguing. Shoot. I think I forgot my password. Does that mean I'm locked out of my account? No, here, let me log in, I can reset it. No, that's okay. I'll just make another one under my correct email address. What? It looks like it's already taken. I bet it was J.P. [NOISE]. We seem to have some users that either by mistake or on purpose are signing up with email addresses that don't exist or are not theirs. This issue's made worse by the fact that we've associated Google login emails with the email password logins that the user enters. This is starting to look like a major security issue. Here, let me show you. All right. So here's Walter. And here we have an evil hacker. Let's say that Walter logs in with Google and that his Google account is associated with his Gmail account which has the address americanguyw1521@gmail.com. When this account was created it also creates a user in our database. So he logs in and he's all happy and he makes some shopping lists. Okay, so the hacker figures out Walter's Gmail address because maybe Walter isn't too shy about sharing it. He puts it up on a social networking site or something like that. And then what the hacker does is he makes an account through email and password, that uses the same email address. And with how we've set things up, he can still choose whatever password he likes and it's fine for him to use this email. Because the real Walter never made a user in fire base with an email and password, just with Google. With the code as it is now. These two accounts here are associated, and they are considered to be the same user. So the hacker has now essentially gotten into Walter's account because the same email address was used for both. And all those new permissions that we added such as only the owner can change the name of the list, or only the owner can delete a list are meaningless because well, the hacker has gotten into Water's account. So he can rename Walter's list as much as he likes and poor Walter is powerless to do anything about it. As we start writing more code related to ownership of the app, Walter is going to get the ability to make lists that are private to himself, but with this security flaw, a hacker would be able to see all of Walter's items and lists. Now you might be saying let's unassociate the two email addresses. But this would still leave an issue that the hacker could enter the account and sort of masquerade as Walter. It would also mean that Walter could not use his own email address if he ever decided to make an email password provider user. So I think a better way to go about this is to try to think of a way that we can have the user prove that they actually own the email address that they've put in. To do this, you could employ a creative use of Firebase's password reset functionality. Here I am in the Login and off tab. And if you scroll down, you'll see the section that's all about password resets. In your code, you could trigger for a user to receive a password reset email. And here's where you can configure what that email will will look like. You can configure things like what the subject of the email will be or who it's from. And if you scroll down a little bit more, here's the actual body of the email. Now, this includes a token string and this token string is basically the reset password that is generated for your user. So with all of this in mind, here's the new flow that I'm thinking of. First, when the user signs up, they'll no longer be asked for a password. Instead, the screen will just take their email and their name. This is the information that will be used in the call to create user. We'll generate a sort of dummy password that we're going to throw away pretty quickly, because if creating that user is successful, we'll immediately reset the password using the resetPassword method. Immediately after resetting the password, an intent will open the user's default email app. Now, resetPassword is the method that triggers that email to be sent to the user and it uses the email address that they entered here so as long as they're connected to the Internet they should see that first email in their email inbox is the password reset email. And they can go ahead and open that email and get a randomly generated password. They can then copy the password that's in their email and navigate back to the app. When they return to the app instead of seeing the create account activity screen instead they'll see the log in activity screen. And we can even be nice and pre populate the email up here with whatever email they originally gave us. Then if we instructed them to copy the password here, they could paste it here and sign in. And for now, the first time that the user signs in, we can actually use fire bases change password method to then change the random password that was originally generated for the user, to the reset password that they just put in. And then this way we can confirm that the user at least has access to the email account that they put in here. Okay, now this is by no means perfect. For one, it makes the reset password the user's permanent password, and the reset password's fairly hard to remember, it's just some sort of random string of numbers and digits. Also, when you call the resetPassword method, whatever password is generated only works for 24 hours. So there is a scenario where a user could create a new user, get the reset email and then get busy and decide not to sign in, and then try to sign in after 24 hours and lose access to their account. But for beta version 0.3, I think this is a pretty good flow, and it does remove the most glaring security flaws of our current login process. Okay, so let me quickly show you these two methods that are new to you. The reset code is pretty straightforward. Just like everything else that we've been doing with authentication, you should grab a Firebase ref. You can then code reset password on that Firebase ref, and all it really needs is an email address that's in the system, which means an email address that you've called create user with. If this reset password call is successful, it will send an email and take it here, and if it's not successful you'll get the error down here. This might happen for example if you put in an email address here that doesn't exist in the system, you'd get the user does not exist error that we've talked about before. When the user signs in for the first time, you call change password method. This will take that same email address of the user, as well as the old password and the new password. You can use the reset password for both of these. Now you should only change the password if this is the first time that the user is logging in. I'll leave it up to you to decide how to check whether the user has logged in before or hasn't logged in before. And if you forgot why calling changePassword is important, it's because the users reset password that they received in their email is only valid for 24 hours. Now if Shopping List Plus, Plus was going into production immediately, what I'd have you do is create some extra screen so the user could change their password from the reset password to something that they could memorize a little bit easier. But, again we'll start with this. Okay the full spec is on the way, so good luck. [BLANK_AUDIO] Ugh, son of a SQL, this milk is older than I am. [BLANK_AUDIO] [SOUND] Hello? Hey, Kagure. So I'm making a cake for the V3 launch party, and we're out of milk. Milk? Yeah, you can use mine. Yeah, it's a bit old. Any chance you're at the store? No. No, I'm not. I have a debt to settle. [MUSIC] Okay. [MUSIC] Man, where am I going to get some milk? [SOUND]. Hey J.P. Hey Lila, how are preparations for the V3 launch party going? Do you need anything from the store while I'm here? Actually really great you called, I could use milk. Sure thing. That makes me think. Now that we're actually storing user data, we could do a lot of interesting things with that information. Like, I don't know, show who's bought what. Or you could also show them who's shopping. That all makes sense, a lot of sense actually. All right, version 0.3 launch party canceled. Back to coding. To start, I'd like a feature where I can say I bought eggs from one of my shopping lists. And then, everyone that shared on that shopping list sees that I have, in fact, bought the eggs, wherever they happen to be. I'm imagining a style that would have a strike-through like this and that would say who bought the item. I've been thinking about the best way to break this one down. And here's what I came up with. To start, you can update the items to track whether they are bought or un-bought. And then, you can also add an attribute to see who bought them. You can then add a click listener to the adapter that would allow items to be toggled between bought and un-bought. So, all you need to do is press on an item and then it would be considered bought by you. And if you pressed again, it would be un-bought by you. Finally, we should probably change how the item looks in the adapter if it is bought or un-bought. That's what I was talking about when I mentioned having a strike-through if the item was bought. And maybe even having some text to show who bought it. Now, these three steps relate to different things. The first one involves changing around a POJO. The second one involves writing something to the database about the status of the item. And then, the third one is reading the status of the item from the database and then changing the UI accordingly. So, this is really not too different than the stuff that we've already been doing. Okay. So, why don't you talk me through this one and what you're going to do. Given what you know about Firebase, what POJO should we be changing? Answer that here. Then, in the on click listener of the adaptor, what write method will you call? Finally, in what method will you change how the item looks when it's bought or unbought? Okay, let's recap. So for changing your POJO, you should change your shopping list item. And I think it'd be good to change it by adding a Boolean for whether the item is bought or unbought, as well as a string that includes the buyer's email. Next, when you're buying or unbuying items, it's probably good to use update children to flip the bullion and set the buyer. We're not making a whole new item, so push and set value don't really come into play here. Run transaction is used in situations where users could overwrite each other's data, and it would be disastrous, which is not really the case here. And no, it doesn't just happen magically when we change the POJO, we do need to call method. To show whether an item is bought or unbought, you should update the populateView method in your active list item adapter class, because the populateView method is where you determine what each of the item list items look like. Your plan of attack and reasoning for changing the fire based schema sounds good. So, I give you my blessing to implement buy and un-buy. In the end you should have this functionality, where the style changes as seen here. If the item's bought it should be crossed out and it should say who it was bought by. If it was bought by you it should simply say Bought by You. If it was bought by another user, say the user's name right here. Now if the item hasn't been bought yet, you shouldn't see a strike through, and you should also still see this trashcan icon which allows you to remove the item. Items that have already been bought can't be removed. One final note, you should only be able to unbuy an item that you've bought. If Kagure says that she bought some jam, Walter should not either by mistake or on purpose, be able to un-buy that jam she just bought. Only Kagure should be able to un-buy an item in case her figure strayed and she bought it buy accident or something else happened. Okay so makes sense? All right, well I'm sending over the spec right now and I'll check back in with you in a little bit. When I started these last version three updates, there were two things that I really wanted. First was to know if somebody had already bought something. On me and my roommate's limited budgets, it kind of sucks to double buy Cheesy Flakes. The second thing I wanted was some way to know who was shopping. If I'd had known that JP was in the store, I would have been able to just call him immediately instead of randomly calling all my roommates. Now, you've effectively solved the first issue. By implementing buy and un-buy it's pretty clear whether an item's been bought or not. So, can we try to add this feature here? I am imagining a button that when clicked put's you in shopping mode. When you're not in shopping mode you can't buy or un-buy things. Shopping mode would signal that you are in the store and actively shopping, and when your not in shopping mode you couldn't accidentally buy or un-buy things. But if you were at the store, you could click this button, turn on shopping mode, and be able to buy and un-buy things. This would also signal to everybody that you are in the store at that moment. I'm going to provide you with an updated layout that includes this button here. Something should probably change in the Firebase Database, but to tell you the truth, I'm not sure what. What do you think should change in the Firebase Database to support the shopping mode that I talked about? And remember, the goal is to eventually be able to know who's shopping in the store. Here's some options that I came up with, which one do you think is the best? Option A would be to change the item POJO to have a boolean, and this boolean would basically represent whether the list that the item was a part of is currently being shopped on. Option B would be to actually change the shopping list, POJO itself, to store a list of who's currently shopping. Option C would be to change the shopping list POJO to have a boolean that represents whether the list is being shopped on or not. And option D would be to not change either the shopping list class or the item class, but to instead change the user class to store for that current user, what shopping lists they are currently shopping on. Now, I do think that shopping mode should be on a per list basis. After all, one shopping list could be for outdoor supplies and another shopping list could be for food. So users shop on specific lists and not universally, just to make that clear. All right, tell me what you think. Okay, let's look at what the data would like in these different options. Here's a diagram that I made of what our data structure currently looks like. We have activeLists, shoppingListItems, and Users. This is all the data for one shopping list. This is the data for another shopping list. Here we have the associated items on the shopping lists, and here's each item here. And each of these little clusters is a different user. So three users and we have two shopping lists, and this first shopping list here has one item. The second shopping list has three items. Okay, so here's our current data. So option A was a little crazy, it basically was to take each of these items and add a boolean. And when the associated shopping list is being shopped on that boolean would be true. For this list it would look something like this. You'd have an extra piece of data for each item. And if this list started being shopped on the value for each of these items would be true. Now this isn't the best solution. Because when somebody's shopping on a shopping list it affects the whole list, not just specific items. I'm essentially copying the data three times here. Now option C is essentially what option A was but instead of having the Boolean on the list items which was a little bit strange, we could put the Boolean on the list. Basically we just have a Boolean here, which says whether the list is being shopped on or is not. And this is pretty good, except it's not storing any information about who is actually doing the shopping. So I could see that somebody was shopping on a shopping list, but I wouldn't be able to know, in specific, that it was J.P. So Option C is kind of outta the running as well. Now Option B, would be to similarly add some data to the shopping list, specifically a list of users that are currently shopping on that shopping list. And B looks pretty good. You know if a list is being shopped on and it's easy to see what users are shopping on that list. On the shopping list page, they make it really easy to print out who's shopping on the list. Now D is a somewhat similar solution. But instead of having a list of shopping users in the shopping list data, we can have a list of shopping lists in the user data. It makes it pretty easy to see whether a user is shopping on a list. The issue with this solution is that when you want to know who's shopping on a specific list, it's inefficient. In this scenario, you'd have to iterate through all of the users in your database. And see which ones in this list of shopping lists had the list that you were currently looking at. When you get hundreds of thousands of users, that means you're doing a query that's looking through hundreds and thousands of user objects and that's a pretty lengthy search. So in this case, option b is the superior option. Attached to each list, you'll add a list of users who happen to be shopping on that list. If this list of users empty and doesn't exist than you know that there's nobody shopping on the list. Okay, so that clarifies what you should be doing for the data and I'll send you the spec right now. Okay, now that you're storing the list of users who are shopping, can you make the information visible to anyone looking at the list? Here I'm looking at the active list details activity screen, and right around here I'd like you to say who's in the store shopping. I'll send over spec right now with more details. So how'd all the logging code go? It went great, I'm actually having a launch party for version three soon. Let me show you all the screens and features we made from the wireframes. We're now supporting email login and Google login. We also created a pretty cool reset password flow where users are sent their passwords via email and therefore verifying that they actually own the email that they've given us. But we worked on more than just login in this version of the app. We used the login data to change what the app actually looks like. The app now controls what the user sees based on who they are logged in as. Also, we can keep track of who buys what items and allow for users to signal that they're actively shopping on a list. Yeah, and now we're halfway through our projected final launch. Anyways, we're having a little 0.3 launch party, you should come. I'll see what I can do. [BLANK_AUDIO] I wonder where Walter is. It's taking him a really long time to get back. Whoa, are you okay? I'll be okay. Walter, what happened to you? Well, after my normal wrist workout routine, I was trying to organize my shopping list for the big benefit. But now that we've got about 20 users, it's been much harder to find my lists. I just had to keep scrolling and scrolling and scrolling. It's okay. Let it out. Well, then a bunch of users who didn't even have anything to do with the benefits started adding a bunch of items. Maybe they were confused. Or maybe they were bored and just trying to find someone to torment. In any case, I had to delete each item one by one. Then I had to go in and manually add 50 items. My wrists started hurting and I typed through the pain. My gosh. What is wrong with you? Can't you see he's in pain? We can't celebrate. I'm sorry Walter. This actually is sounding like something we have to add. A way for users to kind of limit who can see and edit items on their shopping lists. Yeah, and some sort of sorting functionality might not be a bad idea either. Well, with Firebase queries, we could tackle the sorting functionality. Sharing might be a bit more difficult. We'd have to think about designing the database as the user base grows. We could look at that in version 0.4. Yeah, that sounds like a great idea. I'll get looking at that right now. It sounds like Walters wrists are getting better and adding users is a big turning point for the app congratulations. Whoa Laila you look terribly tired. Is everything okay, when's the last time you slept? Yeah it's been awhile. We do a lot more user data now but I'm not sure it's anything to celebrate. Still struggling with just exactly how to implement sharing. Walter asked for sorting data. And, well, that's pretty easy to filter and sort our shopping lists. As it is it makes me think of bigger and badder looming questions. And what are those? I'm just I'm terrified about what happens when we start getting thousands of users. I know too many as it isn't a problem right now. Heck it's even hard to get my roommates and Nana to use the app in its current state. But the decisions they make about data now will affect the future. Our current model we made was somewhat randomly put together. Without any rigorous thinking about performance. I'm not even sure what the best way to dissociate users and shopping lists is. Yeah I could see how that could be stressful. Why don't you walk me through the exact kind of functionality you are working on in and worried about. [SOUND] Let me pull the wire frames. So we could have the settings activity show different sorting options. And then on the items page, we could differentiate between the bought items and the non bought items. The bought items would all be on the bottom and crossed out instead of mixed in randomly. As for how the data of the firebase database itself should be organized, I just don't know. Finally, I want to implement some sort of sharing functionality. Right now all the lists are world viewable which doesn't make a lot of sense when we get tons of users. What I'd like to happen is that the users can make lists. But they're private until their shared with other users. Do you know what the sharing flow will look like??? So I was thinking something like a user can add friends and then once a friend is added. They can click a little check mark box to show whether the list is being shared with that friend or not. And I was thinking of trying to filter to allow for basic auto complete functionality. Well the first part where you sort of list sounds easy. Firebase has some basic filtering and sorting function I built into it. So you shouldn't worry too much about that. [SOUND] So what do you think? Can we tackle sorting? I can make the UI screens. You know what, why don't you take it easy for a bit. I'll chat with the developer about sorting. Sometimes in our apps, we want to have certain elements at the top of the list, such as those which were edited most recently or that were created first. So, when querying for records, there are four ordering functions in Firebase. Firebase can sort by children or grandchildren, keys, values of a named property, or by its priority and key together. Here are how these functions work. OrderByChild)() allows us to order by a specific descending key. For example, if we have an item called desserts and it contains an attribute for types of sweeteners, we could order all desserts based on the children. If your sweeteners were white sugar, agave, Stevia, coconut sugar, honey, and molasses, this would allow you to sort them alphabetically. So you'd have all the agave desserts first, followed by the others, with white sugar last. Similarly, in the 2.4 release of the SDK, Firebase introduced what it calls deep path queries. Put simply, it's the ability to order by any descending key, not just direct children. So you could have desserts, and a child could be ingredients, and within the ingredients object you could have a property called sweeteners that you could then sort by. OrderByKey(). OrderByKey() will order the key in ascending order by key name to produce an alphabetical sort. OrderByValue() will order by the value of the child nodes. This type of sort can be useful for numeric values. OrderByPriority(). The orderByPriority() method can order by priority, however, while it is still a supported method in Firebase, it's not suggested. It's a method that was used before orderByChild() existed. For each of these query operations, there is a defined order by which the values or keys are sorted. For orderByChild() and orderByValue(), the sort order is the following. Return null, a value will be equal to null if the property doesn't exist. This is more pertinent for orderByChild(). Then return false. True. Numeric values. Then strings. Then objects. Why differentiate that numeric values come before strings? The Firebase database is extremely flexible as to what type of data it contains. For example, there's nothing to say that you can have a list of desserts all with a child sweetener where some of the desserts have a sweetener value that is a number, others that have a boolean, and still others have a string. It would be odd, but at least you'd know how it would be sorted. For orderByKey(), data is sorted in ascending order. With keys, they can be sorted as 32-bit integers first, then keys with a string value coming next. And, as you might expect, when you use orderByPriority, the sort order is primarily determined by the priority in key. One point to note when you're implementing sorts is that queries can only order by one key at a time. For example, if you are calling orderByChild multiple times on the same query, an error will be thrown. This is to keep Firebase operation snappy and get you the data fast. Now, you might be wondering, what happens if I need to sort by two things? Since Firebase doesn't support this yet, the best way to handle this is to use sorting to do the first level of the sort and then sort the data client-side with your own Android code. You should also consider sorting client-side if you already have the data available to you, because this will save you a query call to the Firebase database, which will save your users money on their data plans and keep your database from getting pinged as much. You won't be implementing client-side sorting in this version of the app, but it's an option you should be aware of. In the spec which also do send, I describe how to take the new settings activity class I just sent you, and allow the user to choose between sorting by published time, list name, and owner email. But before you get wrapped up too much in Android Studio, I had a quick question about sorting. What order by method do you think each of these different sorts we'll need to use? As a hint, remember that push IDs have a sort of special property to them. So think about it and let me know your answers here. When you're thinking about using the orderBy methods, you should always take a look at your data structure. Here under the root node, I have activeLists. And in activeLists, there's a bunch of shopping lists. Now the shopping lists are what we are sorting. And because of that, the location that you're interested in is the location activeLists. It is the parent of all these shopping lists. So you'll make a Firebase reference location here. And then you'll use the orderBy methods on it. And the question is for each of our three sorting options, sort by list name, sort by owner and sort by publish time, which of these ordering options should we be using? So my thought for order by name and order by email is that we should use orderByChild. That's because for each list, and you can see a full list expanded out here, there's a owner property and a listName property, and that's what we want to sort by. It is the child of the list objects that you're looking at that you want to sort all these lists by. And depending on which property you actually want to sort on, you should put that property in as the argument that you pass in. Okay, so that's looking good for those two. Let's talk about publish time. Okay, so orderByChild is a good choice for these two. orderByKey doesn't make a lot of sense for sorting by listName or owner because here the keys are listName and owner. And you're not actually taking the value into any account if you tell it to sort by key. orderByValue would be used if these top level lists here weren't objects. Now we know they're objects because they're composed of a bunch of different properties. But if there's a single value, like this push ID just had a single number or single string associated with it, then you could use orderByValue. But it doesn't, it has children and so you need to be using orderByChild. And you wouldn't choose orderByPriority in this case because that method is deprecated just in general. Now ordering by publish time is a little bit different. While you could choose to order by child, a better answer is to order by the key. So how does ordering by key work in this case? Well, the keys for all these lists are the push IDs. And if you remember, push IDs have a special property. Push IDs are created, in part, using the time that they were actually made. And when you sort a bunch of push IDs lexigraphically, they are sorted by the time that they were created. So because the push IDs, which are the keys, have this property, you can use orderByKey. And because for each of these objects there's only one key, you don't have to pass any arguments in here. It's very clear what we're sorting by. Okay, so to summarize for sorting by listName and owner you can use orderByChild. And for sorting by the time created you can use orderByKey. All right. As discussed, we'll use order by child so that the user can sort by name. And then you'll use order by key for ordering the list was sorted by when it was made. So now that we've got that settled, I'll let you implement the ability to sort shopping lists. I'm sending you the specifications now. Nice work, now I think ordering methods can actually be used to solve another issue. Here take a look. When I start shopping mode and I buy something, it crosses it off, which is great. But what would be even more great is if when I cross an item off, it could actually be in a different part of the list. So maybe down here I would have all the items that I've already bought and separated up here it would be the items that haven't been bought yet. I have a feeling that using a sorting query you could separate out the bought items from the un-bought items. I'll go ahead and send over the spec which outlines exactly what I want, and maybe you can take a stab at it. Okay, JP, I've been procrastinating long enough. I need to do something about privacy and chopping the sharing. Right now, when you click on the my list screen, you see every single shopping list. And while it does show you who owns each list, it still shows you all of the lists that were created even from strangers that you frankly, don't care about. Instead of this being a free for all. I think the best idea would be to implement some sort of sharing. Here, let me show you what I've got. My plan is that when you make a list, only you can see and access that list. So if I have my generic grocery list here and I just made it. Only I can actually see this. But what I'll do is, I'll add a little share button up here. Clicking share opens up a list of your friends. Out of the hundreds or thousands of users, or hopefully, hundreds of thousands of users, that they'll someday be. You probably have a smaller circle of friends that you actually want to share shopping lists with. So we'll store the data of who you say that you often share shopping lists with. And then you could add additional friends by clicking this button down here. And this will take you to the add friend activity. And this activity here would have a list of all users of the app. So you can scroll through the users and find one that you want to be your friend, say Kagure. Press her name. And that would add her to the list of your friends. Then, with any of these friends, you can click the little plus icon here and that will turn the sharing on. So if this is Walter's screens and he just clicked this, then he'd be sharing with me. Then when I open my version of the app, I'd be able to see the new list that Walter just shared with me. That sounds good, Layla. So I have another idea to add here. What if we design the data structure like this, let me show you my screen. Here, you've got your list of users and in each user is a list of push IDs for the shopping list they own and are shared on. We can set them to some dummy value like, true. JP, so that does sound interesting but I'm already seeing one problem. The issue is, how do you use the Firebase list adapter with this kind of data. The Firebase list adapter will be passed to location. So, I could pass them this user list location that has all these children. And then I'll try to display all these children. So I could display a list of these push IDs pretty easily. But ultimately, I'm going to try to be using that populate view method to make a list item that looks like this. But I can't get this data here unless I make some additional listeners, and it just sounds like a lot of overhead. Yeah, that's rough. You could duplicate some of the data or possibly use some Firebase built-in filtering capabilities to only grab the list you have access to. I'll look into those but honestly, right now Im beat, I'll check in tomorrow morning. You should get some rest. Nah, I've got some coffee. So, I'll think about it a little bit more. It's just so important to get the data right. I don't think I should work on anything else until the developer and I have a plan. If only there were some way to know how users would use the app and what kind of performance constraints you need to deal with. [LAUGH] Yeah. Well, it's not like we could see to the future. I certainly can't. [SOUND] All right, good night. [SOUND] Walter, you're up late. I find my mind is most clear when the moon is in the eleventh house. Mm. Wait, what? So life update. I decided that I wanted to upscale it my current career. So I signed up for Udacity's fortune teller and future seer nanodegree. Mm, interesting. Man, I wish that there was some way that I could see into the future of ShoppingList++. With things so up in the air with the data structure, man, a little foresight would be really helpful. Here, why don't you just take this amulet? It'll light up prophetic visions of the future beyond. Just say what you want to see three times before you go to sleep. Walter, this is amazing. Can I keep this? Yeah, sure. I'm on to bigger and better things now. Now I'm going to go turn Palter into a frog. Yeah, a frog. What will happen to shopping list plus plus. What will happen to shopping list plus plus. Okay, that's the last of it. I'm going to take this box out to the curb now. I got one more really hard thing to do. Okay. Hey there. So, I've done great at our Internet connections. The video is a bit spotty. I'm switching to voice. I've got some bad news. Shopping list plus plus is officially bankrupt. You know we had a good run. But after we hit more than 100,000 users, we just couldn't keep up. Even with your rock solid coding abilities. This is one of the hardest calls I've had to make. But I'm afraid I'm going to have to let you go. Seeing a shopping list plus plus isn't the company anymore. I know, I know it's terrible. And I am so, so sorry. But since we've got enough capital to have you on for another week or so, maybe you could spend a little bit of time going into the engineering specifics of why this all happened in the first place. Let's go over the data schema one last time. As you probably remember. We had that big data redesign. Now, unfortunately I was more involved on the Android app side. And I wasn't closely following what our data engineers did to our database. But here's a bit of example code for the redesigned that shows the basic data structure. Obviously the production code was a lot bigger than the small data sample that I'm going to show you right now. Basically what the data team did, was they stored the shopping lists that the user owned within the users themselves. So here, under Walter, we can see all the lists that he owns. And each list has all of its details including all of its shopping list items. Everything seemed to be going fine. But when we had our big surge of users in August, things just slowed to a halt. Reviews of the app especially complained about the shared pages and the main shopping list page being very, very slow. So now ShoppingList++ is ruined. Not to mention my personal finances. J.P. is also looking into what exactly happened. But until then, maybe you can give me your thoughts. Looking at this data structure, tell me what do you think happened? What did we do wrong? Thanks for getting back to me on that one. The issue here is the level of nesting that we see. For example, everything is pretty much in the user mode. Meaning that, when we need to download the information about Walter, which is all stored within here, you also download all of Walter's lists. And Walter's lists, in turn, include shopping list items. So, let's say that you wanted to at any point display a list of users that are in the app. You'd have to download all of this extra data for every single user just to display something like their name. [MUSIC] It sounds like JP is calling. Let's see what he has to say. Hello, I've been doing a lot of research into what might have gone wrong along with the thoughts from the developer. Glad to hear it, what could we have done differently? It's a bit hard to describe without a picture here, let me show you. Firebase has the ability to nest data up to 32 levels deep. But don't let that tempt you, generally speaking nesting data is a bad idea in a NoSQL database. When you create a data structure with deep nesting, it hurts performance and can result in a disastrous design. This is because in Firebase when you read a data node, you also retrieve all of the children of that node. And remember, Firebase is designed to be a real time solution for mobile applications. Taking something like 20 seconds or longer to read in data doesn't qualify as real time. So what's the solution to this challenge? The solution is to denormalize your data, which is basically the process of ignoring how objects might normally be nested, such as having all items contained within a shopping list. And instead focusing on adding some extra data and or regrouping data to make getting the exact data you need for your app simple. This results in queries that have the needed information to return results but not at the expense of performance. So let's look at a before and after example in Firebase. In shopping lists ++heyday, there was an internal chat application. That's all gone now, but we can still look at the schema. First, let's look at the anti-pattern for this chat app. The chat app had rooms, users, and messages. Let's say the main screen of the app was a list of rooms that the user can enter to chat in. For this, we need to grab a list of chatroom names from the database, which would involve us getting the data from here. In the first example, we see that in order to list the names of rooms requires the entire room's tree to be downloaded to the client. We have all this extra data we don't want. Imagine how much data would have to be queried if you had a thousand rooms worth of data. Let's look at a denormalized example. Here data is split into separate paths, which in turn allow for the information to be downloaded in segments related to what the app actually needs. The list of users is downloaded as needed. Messages are fetched separately. And this allows the application to remain performant. Okay, so given all that, I've come up with a couple of alternative ways we could have structured the data. What do you think we should have done? Before you dive in, I wanted to give you some tips so that you have a foundation for analyzing the different database schema options. First and foremost, when you're making your database schema, you should be clear what you're optimizing for. With Firebase, the first thing that you're trying to optimize for is the amount of data transferred over the network. You want it to be as small as possible. This means that you shouldn't be pulling down tons and tons of data every time the user changes a shopping list item if you don't need or use that data. Of secondary importance is the number of network requests that you make. When you're writing to your database, this means being aware of whether you should use updateChildren or setValue. setValue is great for writing data to one location in a database, but if you need to write data to multiple locations in a database, it's better to use updateChildren. For reading, analyzing whether a series of network requests is excessive is a little bit more complicated. Mainly, you want to be aware of how many listeners that you're making. I'll show you an example of how you can tell how many listeners that you're creating. Say that you want to have a screen that shows a user's friends. One way you could organize the data is to have a list of friends' emails for each user. If we had six users, there'd be six friends' emails listed here. Now, in the UI, it looks like you want to display the name of the user. So what you'd probably end up doing is using the email here as an index into the users data structure to be able to grab the name. To count listeners, there'd be one here to get all of your friends' emails, and then for each friend, you'd have another listener that would then grab their name. If you have six friends, that is a grand total of seven listeners. But there are other alternatives that you can think about. If, instead of just storing the email here, you stored the email and the user's name, this means that you would only need one listener to display this data. Another alternative would be trying to cache the user data on the client side. But at the end of the day, what you should really be thinking about is if these extra listeners seem to be affecting the users. If they don't, then you could decide that the data structure's okay the way that it is. But you should always be aware when you might be generating a bunch of overhead by adding tons and tons of extra listeners. My second tip is to think about the future. And we really messed up with this one with ShoppingList++, and look where we are now. You should try to think about the parts of your database that are going to get very big. For example, you might ask yourself, how many users am I going to end up with? If the app gets extremely popular, you could end up with millions of users. On the other hand, another thing we store in our app are shopping list items. So you might be wondering how many shopping list items might we have for a single shopping list. Maybe ten? Certainly the number's unlikely to go over 100. So when you're trying to make a trade-off between a data structure that would divide up the number of users that you need to search through or display on a screen versus one that would optimize for the number of items displayed for a single shopping list, you would probably want to choose one that favors the number of users. Remember, we kind of already did optimize for shopping list items by dividing them up based on the shopping list that they're part of. So, at least, that was good on us. In tip one, I clarified what you're optimizing for in general. To apply this specifically to your app, you should be using your activities as guides. And what I mean by that is, take all of the activities that are in your app, and figure out, what information do they need from the database? For each activity, you should be optimizing the database so that it's able to quickly retrieve the exact information that it needs, again, with minimal data transfer and not too many network requests. My next tip is basically to take denormalization to heart. Don't be afraid to have data that seems like it would be related in different parts of the app if it optimizes displaying for one of these activities. Just make sure that you always denormalize with a purpose. A deeply nested database is often a symptom that somewhere in your app, you're going to be forced to download a lot of unnecessary data. If you see that you have a many-leveled nest, you should quickly look into whether or not this is actually the case, and of course fix it if it is. But if it's not the case that you're downloading a lot of extra data, then a little nesting can be fine. All right, with all of those tips in mind, here are some suggestions about how we could have reorganized our data structure had we thought of it earlier. Out of these, check off the ones that you think might have actually helped. In the instructor notes below, I've given detailed explanations about what exactly each of these means and what the data actually looks like. So make sure to take a look at those before you answer anything. Before I give you my thoughts on which of these suggestions is valid and good of the scenario, I want to re-remind us of these data tips. The key to deciding where data should be, relies on what portions of data that you're going to need at the same time. And that's really about using your activities as guides. If you don't need the same doubt at the same time, you should think about denormalising. Again remember, that we're optimizing for making a minimal number of data transfers. Remember what you're optimizing for, you don't want to have to make a million different listeners to get all the data that you need for one screen. But more importantly, you want to optimize your data structure in such a way that you're allowing for minimal data transfer. Suggestion one suggestion two could be compared to one another. Let's take a look at what one looks like. For both of these were going to extract out shopping list items. For suggestion one, I just have a simple list of all items. And then embedded within the item, is the push idea of the shopping list that it is associated to. Let's take a look at option two. For option two, I similarly have de-normalized out shopping list items. But instead of these being a list of items, there are sub-lists for each shopping list push ID. And you'll notice the item itself does not contain a shopping list push ID, because you have to push I.D. up here. This is our original design for where we put items in shoppinglist++ from way back when. So just looking at suggestion number one, and number two, which again, are very similar, which one do we think is better? So here's data structure number one again. And number one might seem like a better option. After all the data is less deeply nested. When you want to get all the shopping list items that are part of a certain list, you do a query, which selects out all the items that have the same shopping list push ID. But the issue is that you need to make that query in the first place. Remember, shopping list items is going to get long so eventually that query could be looking over millions of items. With suggestion number two, if you organize your shopping list items so that they're already grouped by list, you don't need any sort of extra processing. So actually, where we put the shopping list items way back when. Which is what it says, that option two is the better of these two options and better than what we have right now darn those data architects, that did not design for Firebase. Why did I hire them? Anyways, lets look at suggestion number three move the list of user's shopping on a list to it's top node. Have them organized under the push IDs of the list they are a part of. All right, let's see what this looks like in data. Okay, so here's suggestion number three, we have one of our list push ids and then this is showing that Walter and I are shopping on that list. And it is denormalizing the data. Again, we've taken usersShopping out of users. But you gotta ask, is there a purpose that we are doing this for? Remember, on the active list details screen right here, we need to be able to say who's shopping on the list. And also here the shopping list fragment. We say how many people are shopping on the list. So whenever we are using the shopping list data in our app, we're actually also using the data for who's shopping on the list. Separating out the shopping list users from the shopping list object therefore it doesn't make a lot of sense. Because there's never a point of the app that you need to display or use the list of shopping users on its own separated from the shopping list. Okay, so I say no to suggestion three. Okay, so this is suggestion four. And again we've denormalized. We took user friends, which used to be inside of the user objects, and put them on the top node. So instead of having a user friends category in Walter's user data we've denormalized it out here so that the fact that Walter is friends with me is up here, and not embedded with, inside his user information. So is this helpful? Okay, so looking at our screens again here are the two screens that have to deal with shopping lists. And I'm actually going to pull up the screen that shows the friends as well. So let's think about our screens again. These two screens here, will probably need to get user data. For example, to be able to display while as lists, you need to get the user. And just in general, to do things with permissioning about what you can actually click on a list you need to know who the current user is. But these screens don't need to know anything about who the user's friends are. The share lists screen on the other hand has a list that lists out the user's friends. So it does need this user's friend details. But because here we're using the user object without needing to know anything about the user's friends. It makes sense to separate these two things out and sort of denormalize the data. So that action forces actually looking pretty good. Okay. And finally, we have suggestion five which is to move the shopping list out of the user class. And here's what that would look like. We move the shopping list out here into activeLists. So that's looking pretty good. And suggestion five is actually a must when we're grabbing user data, which we do on basically every screen of the app, we don't want to also be pulling down all the shopping lists associated with them. Now this still leaves us with some interesting things to say about sharing. But it does pinpoint where our original problem came from, with the shopping list fragment taking so long to load. Okay, so it looks like we should have implemented suggestions two, four, and five. Well, that would have been good to know before all this happened. Gee, nest egg! My goodness. Thank God. It was only a dream, it was only a dream. A dream of the future. Make sure to keep data denormalized. What will happen to ShoppingList++ with denormalized data? What will happen to ShoppingList++ with denormalized data? What will happen to [INAUDIBLE]? [MUSIC] Walter, do you have any idea when they're going to turn the heat back on? I'm just not sure how else we're going to brave this harsh San Francisco summer. No heat if we can't pay the bills. I guess we'll have to keep burning these ShoppingList++ promotional posters for warmth. Man, I really wish that we could call JP right now. Did someone say my name? My gosh. JP, where do you come from? Well, I've been living in your crawl space. Like Walter, I invested everything in ShoppingList++ during its heyday. Although you had that pesky technical issue about many-to-many relationships and didn't have any users yet, I was sure it was going to be a viable product, so here I am. Hey, since we've got nothing better to do, why don't you tell us a little bit more about that technical issue? You can use the last of my worldly possessions to help, my tablet. It might be helpful to cover the basic types of relationships you can have in a database. Databases organize data. And these pieces of data can have relationships with one another. There's one to one. One to many, many to one. And many to many relationships. And example of a one to one relationship is the user and the e-mail address. We say one to one, because each user has one email address and each email address is associated with one user. At least in shopping list plus-plus this is how it was. If instead, we'd allow each user to have multiple email addresses, this would have been a one to many relationship. Because one user could contain many email addresses. Another example of this is shopping lists and items. Each item exists uniquely in exactly one shopping list, and therefore, has one container shopping list. But if we look at a shopping list's relation to items, it contains many items. An example of a Many to Many relationship is the relationship between users and shopping lists. If we didn't have shared shopping lists and you just made lists for yourself it would be a one to many relationship. Each user would have a collection of shopping lists they own and have access to and each of these shopping lists would have exactly one person who could add them the owner, but that would be a pretty lame app. Instead, each person has a collection of many lists to have access to. And each list has a collection of many users that have access to it. As you might example whereas a one to one relationship is pretty easy to show in your data. And even a one to many relationship is about as complicated as a list. Many to many relationships get a bit more tricky. I've provided some links in the instructor notes below that talk in more depth about these relationships. When everything is constricted to tables things get a little more interesting than in our Jayson world with how you represent things like many to one and one to many relationships. That's pretty interesting stuff. Given everything J.P. just said. What do you think of the relationships between these different values in the app? Go ahead and pick the relationships here. All right, let's take a look at this first one here. The relationship between a list and the time stamp that it was last edited. Thinking about list and timestamps, each list only has one timestamp for when it was last edited. For example, this generic list might have been edited at 12:05, and this other generic list, maybe was edited at 3:50. It would be impossible for a list to have two different last edited timestamps. It's just one. And then similarly, each of these timestamps is directly associated with one list. The single timestamp object is generated for each list. So it's impossible for a single timestamp object to be associated with two different lists. This is a classic one to one relationship. As far as users and friends go, a single user could have a couple different friends. For example could have J.P. and Walter on her friends list. So this is not a one to one relationship. It's not a one to many either because Walter in turn could be friends with more than just. Perhaps Walter's friends with [INAUDIBLE] and Polter. Since each friend could be friends with multiple other users. This relationship is many to many. So what about items of the users that own these items. Each item has exactly one owner. Which is to fight with the item is added to a list. For example, Walter could add cheesy flacks to a shopping list, and then this item would be associated with him. He could add a tomato to another shopping list. And similarly the tomato would be associated with him. Same goes for if J.P. added a insta reader to a shopping list. Now even though each of these items is only associated with one owner. A single user can have multiple items associated with them. So items and users are an example of one to many relationships. So what exactly was happening with shopping list plus, plus, why everything is so tricky? Well, I can explain what the data structure look like and then, maybe you can explain what the larger issue is. Here, give me the tablet. So this is what our final data schema looked like. The developers were swan enough to make sure that all of our data was denormalized. Here you see we separated out shopping list items from the actual lists. And we did this because when we list the shopping lists on the shopping list fragment page, we knew that we didn't also want to download all of the items. And you can see that relationship here. In the same way, we move shopping list out from under users. And instead, put them in their separate denormalized node. To know who has access to them, we store the owner as well as the users that list was shared with. Now, the issue that users were experiencing was loading up the shopping list fragments screen here was super slow. This screen here combines a list that the users both shared on with lists that they own. For each user, this only amounted to about ten or 20 shopping lists. But it was sluggish to load up even these ten or 20 items. If you're wondering why, Walter, well, I think our developer can explain a little bit more about what might have been going on. So Walter, building off the developer just said, the problem was with the many to many relationship between the users who were on a shared shopping list and those shared shopping lists. We needed some way to represent this relationship. Shopping lists could have a bunch of different people associated with them and users themselves could be associated with a bunch of her shopping lists. In this example here, A has three different users associated with it, and, JP, for example, has three different shopping lists that he's associated with. And what we needed was for the data that's associated with the shopping list, for example, shopping list A, to have some sort of reference to these people that are shared. And what we needed was some way to be looking at a shopping list And know the people who had access to that list. And also be able to look at a user and know all the lists that were associated with them. The decision that we made about our database was that we would store the shared members as part of the shopping list itself. For example, you can see them right here for the shopping list, the Wilderness Survival List. This made looking up whether a user had access to a particular list very easy. There are problems, though, that arose when we had to deal with displaying the shopping list fragment for a user that had a huge amount of shopping lists. There are two main issues. First was the amount of data that we were manipulating. Now FarBase provides some methods for sorting and filtering data and they work very efficiently. We were able to use these methods to go through the hundreds of thousands of shopping lists and grab the lists that were specifically owned by the user in question. We were also able to use these methods to go in and filter out only the lists that were shared with the user. Again, these were speeding queries when we had less data. But with hundreds of thousands of shopping lists to sift through, even Firebase's lightning fast query language began to slow down. And we did the search twice once for trying to find out if the user was an owner of a list. And again to try to find out if the user was shared with the list. So that was the first issue. The second issue was that it was tricky and annoying to combine the results from these two different queries in Firebase UI. These two listings should be combined to make a master list of all the shopping lists that a user had access to, and this required some sub-classing of the fire base list adapter. We had to rewrite a lot of code, and it just wasn't very clean. You know, after the fact, they found out that issues involving two way many to many relationships are common. So, I did a little bit of research on my free time, since my retirement I've got a little example using a chat app that you might find informative. Here, let me see that tablet. It's important at this point to emphasize that many to many relationships are important to get correct. Consider how users can belong to a group and groups can contain a list of users. For reasons such as these a two way relationship must exist and needs to be accounted for in your database design. Let's look at this model in the fire based dashboard. Here is a first attempt at producing two way relationships. But when it comes time to decide which groups a user belongs to, things get complicated. We can monitor all the groups and iterate them every time there is a change, but this is costly and slow. Even worse, what if Walter isn't allowed to see all of these groups? When we try to fetch the entire list, we'll get an error telling us the operation wasn't allowed. What we would like instead is an elegant way to list the groups Walter belongs to and fetch only data for those groups. An index of Walter's groups, can help a great deal here. Didn't we just duplicate some data by storing the relationship under both Walter's record and under the group? Yes, this is a necessary redundancy for to a relationships. It allows us to quickly and efficiently fetch memberships. Even when the list of users or groups scales into the millions. Or when security and firebase rules will prevent access to some of the records. When in doubt remember data storage is cheap, the user's time is not. That's fascinating. Actually, while you were talking I took the liberty of drafting up a couple of different ways that we could have dealt with that tricky to many many relationship that you were talking about. What do you think we should have done. And into these five I've come up with another tip which basically is that data storage is pretty cheap but the user's time is not cheap. As just mentioned, if you find yourself in a situation where Where duplicating data can make reading and writing to the database more efficient for the client app you should do it. It's better to duplicate data than to create more Firebase back end traffic. Now we're actually already doing this in our code. For example with our user data. Here we have some user data for Walter. And we copy again all of this user data into our user shopping list. Now this might seem somewhat unnatural to developers. Usually, developers for their best not to create duplicated data. But let's get to the root of why you do that. Well you usually do that because it's easy for duplicated data to get out of sync if you're not careful. To deal with this, Firebase makes it easy to keep duplicated data consistent. By using deep path updates. Here is some code for actually doing one of those fancy deep path updates. And you should note that it's using the method updateChildren to deal with that duplicated data. What you do is you simply make a hash map with all of the changes that you need to make bundled together. So for example let's say that the Walter user object appears two different places in the database. And just for this example, let's say that you can change Walter's name around, and if you do change Walter's name, you want to change it in both of these places. In that case we take the hash map and we put each of the locations and the new updated name value. So, this location and updated name is for this location in the database And this location and updated name is for this location in the database. And we update his name to the exact same thing in both places. And because we use the updateChildren method, either all of these updates are going to occur or none of them will occur. This approach though does make it easy to make a mistake. If you're sleepy and let's say forget to add all the correct places in the code that a user needs to update. Then you'll still get into an inconsistent state. One approach to deal with this is to create helper method for each collection of objects that needs to be updated at once. So for example for the user object, you could create one such helper method. And then the entire job of this helper method is to take in as a parameter the property of the object that you want to change. And then that helper method will create a hash map that adds all of the different places of the database. That that property would need to be changed. Okay So with all of that in mind I want you to take a look at the five alternative database options that I put in the instructor notes below. And I want you to pick which of these database structures you think is the best for ShoppingList++. And here are the screens if you need them for reference. All right, so I'm going to take a look at each of these options, and we'll go ahead and dive right in with Option Aim. Now there are some very good things about Option Aim. Namely, I have this user lists node right here. When I want to display all of the lists that Walter is involved with, I could simply attach a listener to this user list note here,and this gives me all the lists that he has anything to do with. The issues that we're kind of regressing to a worse data state. The data here contains a pretty big nesting issue that we've seen before. Remember, you don't want to put a shopping lists inside of users because that means whenever you take a look at Walter's user information, you're also grabbing all of this extra shopping list information. So A probably is not the best option. Okay, here we are with B and we see we solved the problem that I just mentioned. We've denormalized and user lists are no longer part of the user objects. So we can see here we have a list of users and each user has a list of the shopping lists that are associated with them. We also have the sharedWith property which is inside of the shoppingList. And that's looking pretty good. So let's keep B on the back burner as an option that we might want to consider. Okay, I'm going to load up option C. Option C is actually very similar to option B. The only difference is that we've taken the sharedWith node, that used to be a property of a userList, and we've de-normalized it and moved it up out here. So before where's this have been part of the list K3MhMmVa, now it's been scooted out over here. So is this actually an improvement or are we just de-normalizing for de-normalization sake? If you look at the shopping list fragment screen, it actually doesn't contain any information about which shopping lists are shared with whom. And if you even click on one of the shopping lists, this doesn't really contain any sharing information either. It's only when you start getting into the sharing flow. So the shared with information actually doesn't have to be deeply tied to the list itself, and it's okay and probably better to de-normalize it by putting it up here. So option C is actually looking even a little bit better than option B. All right, let's keep looking at database options though. D is an entirely different approach. We continue to have a master list called active lists of all shopping lists of the database. And then again embedded within the user class, we have user lists. But instead of having a huge amount of extra data for each list, we just add the push ID for the list, and then true if the user has access to it. So this is an interesting approach, but let's look at the shopping list fragment screen here. So for each of these lists that we can see here, you're going to need an extra listener that basically looks up this push ID in the master list of active lists. And that's not the end of the world but it will create a lot of extra listeners. It also continues to sort of clog up the user class with extra data that could be de-normalized outside of it. So I prefer C over D. Now option E is kind of combination of option C with the duplications of lists and user lists removed. The thing is that is that user list was useful. It was a prime example of how we were going to duplicate data and save users time. Even with the shared with lists, it's hard to get a specific location that you can attach a listener to. Which will have all of the shopping list data you need to display. Again, you could use the information in shared with to do searches through the active lists. It's kind of the opposite problem of what you were doing before. Instead of searching through active lists, you'd have to do these sort of searches through the shared with node. If I wanted to find all the lists that I was associated with, I'd have to do a search of all of shared with and look for those lists that I was actually on. Again, shared with could get very big. So this search would again require querying and filtering. And would just generally be slower than having a single location that you could attach a listener to, that had all of the lists that you have access to. So at the end of the day option C is looking the best out of all of these. Well it would have been great if we knew that beforehand. Two-way relationships. Gosh! That was worse than the last one. Remember, data storage is cheap. The user's time is not. What else could go wrong? What else could go wrong? What else could go wrong. [MUSIC] Corporate mandated work time is now over. Lunch time for sectors 113, 114, and 115. Please enjoy your lunch. [SOUND] There's a protein clump in my instarito. I really can't eat this. 9443, Walter, you have to keep up your strength if you're going to keep filing these tax returns. You remember what happened to 1253? Her name was. But really, I wish our corporate overlords Grocery Grabber LLC would pay more attention to food quality. You'd think they would, considering they started as a food company. I wonder what Shopping List++- Quiet. You must not speak the forbidden name. 9443, Walter, I know times are hard. Sometimes I wish I could talk to JP. But I haven't seen him since he joined the resistance. [MUSIC] JP, what happened to you? I've suffered a terrible injury at the hands of the robot army that controls our every move, but it was worth it. Do you remember back in the days when Grocery Grabber was just a small company competing with Shopping List++ instead of the evil megacorporation that runs our very lives? Yes, and we shan't forget. Well, back then, the evil programmers at Grocery Grabber had discovered a little-known rule in Firebase. [COUGH] This rule could be added to a Firebase security and rules document. With this very rule, they could read data more efficiently and faster. Hundreds and hundreds of thousands of lines of data. It allowed them to eventually take over. Here, let me pull up an astral computer screen. [SOUND] So now you can see, if only we'd used Index On and Value, Grocery Grabber's corporate takeover would have never happened. So let's take a look at how they work. Index On tells Firebase which child keys your app uses in queries. A notes key is indexed automatically, so there is no need to index them explicitly. Using index on is optional, but it will dramatically improve performance. You can use index on in conjunction with order by child to optimize queries. In this example, you assign a rule to the children you want to optimize on. You can use index on with order by value. Which will optimize queries on a value rule. Intrude in sector one. They've discovered us on the network, I can't close the connection. [SOUND] JP, thank goodness you're okay. Any reason I wouldn't be? Say did I tell you I got someone from the Firebase team that offer to chat with us about data best practices? No, but actually I think that might be just the kind of guidance that we need. It's incredibly important that we get the stuff right. Crap though, I've got Bouche Ball game with the investors. Do you think that you can take notes? Or better yet the developer can come over to Google. Yeah. That sounds like a player. Want to bar the company Hello and welcome. I'm here with Abe again and I'm joined by Puff, Puff is also an engineer in the fire base team. Welcome, Puff. Thanks for having me. So I'm trying to advise a friend on how to correctly come up with a database schema for firebases. I imagine there could be some pitfalls. Is there an issue in getting your schema right up front. Now one of these Firebase really allows you to be flexible about how you structure your data. And that's one of the great benefits of using a scheme on this no sequel database. Unfortunately, it's also one of the pitfalls because people tend to not think up front of how they need to model their data. And that's one of the things where at some point during the lifecycle if your application you need to start hammering down to structure. You need to start validating your data. If you don't you're going to run into issues later with either scalability, or especially when you're an Android developer, you need to start mapping your schemaless JSON into your Java classes. And that becomes progressively more expensive if you make changes later on in the cycle. An important point thing to note about Firebase is that when you start, when you get a new fire base, you can pretty much do whatever you want. You can write in any type of crazy structure, you want to when you're developing, and when you're testing. And this is easier on web then it is on Android where your structure can be very, very loose, but once you get something in your this is what we're going with this is how we're building. You can lock that structure in. And you can write schema validations and you can make sure that the only data in your firebase matches these rules. Okay. Initially, it's very free form. But once you have you have it more concrete about what you're building and how you want to build it, you can lock it in just like you would in any other database. So when you're developing apps and you're first laying out your scheme, how do you go about doing it? Do you sketch it on paper? Do you build, so you take some JSON data and sort of model it? How do you go about actually doing it? I usually start with just some some code where I write some of the sample data. Is that the same as you did do? Yeah. I think for sure, if you get a little bit of code where you start saying, all right, here is a very loosely defined user creation page. Well I can start writing what a user object looks like. I start figuring out what I need. And then that data can start showing up in your Firebase right away because it's so easy to get up and running with, that then you can be like I need this profile information or I need a list of their likes or whatever. And you can just start very free forming, building out your data structure. And then once you're confident with your structure like I said you can lock it in. But up until then you can just very casually add in things where you need to and experiment with the structure. For most cases, I find that works. Sometimes if it's a very large app and you know there's going to be tons of different types of data in there I'll whiteboard it out and sketch out like, all right here is this and this will have a list that points to this other type of data or something like that. But it's much more common that I just start playing around and then develop a structure that way. Yeah and it actually because what you then notice is that after you figure out your structure and how you want to store today tell what data you want to store mostly. Then you start worrying about scalability of the day time. And that's something you can then do later so you now know which data you want. Now let's think about how we can make this scalable. So. But starting with some exploratory coding and just structuring today takes you go is very common. Great so what are some of the biggest mistakes you see new developers doing when they design a schema? I think people, because firebase can have this very complicated nested structure. Where you can essentially mimic any Json structure you have, which could be users and then under users a list of user names, and under that each user could have a list of their friends, which could have a whole bunch of profile information about them. They could have a profile, you end up with this very nested structure. And that doesn't work very well in it's very hard to be specific about your what you're loading if you have this very complicated deep structure. So that nesting, I think is a very common issue. It does, it's not that it doesn't work, it's just that it doesn't scale as well. And also it's very natural. You see, that lots of developers, right, I mean most of us come from a sequel background where we work with relational databases. And there you cannot do hierarchies very easily. So when you get to a hierarchical database like Firebase, it's very natural to want to start building these nested structures, because you've never been able to do them. And that's when, as Abe says, we need to start paying attention to not overly nesting the data, because you're going to run into issues later on. So you typically want to stay relatively flat in your data structure. And that's That's not very appealing to developers coming from SQL backgrounds. Okay do you guys have any good like war stories some like where you give assistance to customers that had some hiccups because they didn't follow best practices? Yeah you don't get to a quarter of a million developers without some war stories so. No what we see quite often is that people start gathering lots of data and long lists. And that is fine if you need all the data, but one of the ones we saw was we had a developer that was tracking couriers, were delivering packages across the city, and each courier was, I imagined him being on their mopeds and their phone was pinging the Firebase server. So there's lots of data being generated. And they were keeping this data in one long list, which would last essentially for days on end, and that would be half a million items easily. And they were showing this in a dashboard and things were sluggish in general. It was not the performance they were looking for, so it's like well, okay how many items do you want to show in this list and it turns out they were actually showing like, at most the last five minutes of data. And this is one of the things that you have to start explaining to them or if you only want to show five minutes of data then why are you keeping a day's data in one big list. Because you will have to query all of it's to just get the top ten items. That's a very common one we see where people are not separating their active data from their historical data. And yeah, these hurt so we see this quite often. You have something for us? Yeah, another common issue related to that is people will go and they'll build some application with Firebase really quickly because it lets you do that and they'll start getting a ton of data. And then they'll make one mistake in their code and they will clear out their Firebase. This is not normally possible, if you're adhering to what our best practices that we provide in our documentation. Which is basically that you restrict things in your Firebase, you say only this type of data can exist here. Only these people can write to this and that. That way when you're developing, you don't accidentally delete all your Firebase data. But because we don't enforce that because in the early like we want you to be able to experiment and play around. We don't know if you're trying to clear out your Firebase because you're tired of the structure you made. Or if you made a mistake in your code and you know some bug it's cleaning it out. So we see that a lot especially like things like hackathon where people are trying to write code very quickly. And they're like, I'll not bother with the security rules, I won't bother enforcing a schema, and then they make one mistake, and they're like, where is all my data. And the answer is, it's gone. Luckily, we have backups for that. We do backups of your Firebases all the time, and we can recover that if it's important mission critical data. But in general, it's a very easy mistake to make if you're not following our best practices and implementing security and validation roles. Good point. Last one I remember is I was talking to a game developer and they were doing a IOS app I think, where you got to vote on either the blue egg hatched or the red egg would hatch. And they were looking for okay, so we would probably use transactions to keep the count right? Of who voted for what. And this is a common one where it's like well how many players do you get and how often do they or how how fast do they vote? They had half a million in like thirty seconds and that's typically something where if you start doing transactions, yeah it will not skill very well anymore because everyone will be hitting that same counter at that time. So there you see that you know you need to stare into a direction where you're actually instead of increasing a counter you keep the votes and start counting them separately. And it is always fun to explain because yeah people are used to doing transactions. Well guys, really appreciate your time today. Thank you very much I'm sure that our developer will really go take this advice and continue on developing their app. Cool, okay. Glad we could help. Yeah, thanks. Given everything that we know now, let's review our current agreed upon and de-normalized data schema design. I've made some generic json to map out what we've discussed for the final data design. And I went ahead and I included it in the instructor notes. Be careful about not overwriting your database with it. You can always make a new fire base app back end if necessary. To frame all of this, let's think about the screens that we're interested in. The two that we've been talking about a lot are the shopping list fragment and the active list detail screen. And remember the goal is to allow users to be able to create lists and share lists. And then they should only see the lists that they either own or are shared on. Okay, so I'm going to load up the station and open up our back and sort of walk you through what's going on. Here are our top level nodes. Following our discussion of two way mapping between users and the list they own, I think the best way to handle this sharing functionality is to have a list of shopping lists for each user. Here, let me show you. We're going to have this node here called userLists, and this will contain for each user a list of the lists that they have access to. That means if JP, myself and Walter are all in the shoppinglist++ system. Then there would be a separate list of shopping lists for each of us. And again these would be the list that we either own or shared with us. So in this case Walter has one list shared with him. And if he were to create or be shared on with another list. That would also appear here. And this is actually pretty much all of the information that we need for the shopping list fragment. You could go ahead and attach your Firebase list adapter here at the encoded email address of the user who is logged in. So if Walter is the one logged in, then we could attach a listener here and it would very easily display the list that he owns. Since we got the shopping list fragment figured out. Let's think about the active list detail screen. For the list detail screen we'll need the list information which we can grab here from the list of user lists. And we can get that because at that point we should have the encoded email of the user and the push idea of the list. And that gives us enough information to drill down to the email. And then the push ID to get that list information. And from here we could get things like the user's shopping on the list and the list name. And then, as we've already been doing, we de-normalized and had the shopping list items up here. And we can use that same shopping list push ID to get the shopping list items for the list, as we've been doing. Okay, so that explains the use of both the user list and the shopping list items. Now at this point you're probably thinking that this design has a non-trivial amount of data copying. Here each of us has our list of lists in user lists. And if we each make four different lists and we owed them this is what it would look like. But let's say that cougar A decides that she wants to share her book club snacks list with all of us. What this would then do is add a copy of book called snacks to each of our lists. A total of three more copies. Now this design here makes reading for the database lightning fast. We never have to search through a list of all shopping lists, or pull down any extra data. But, you're probably thinking that there must be some downside to all of this copying. Well, there is. Whenever you change anything about the shopping list, such as to change the list name to book club snacks. You need to do this for all copies of the shopping list. So now instead of changing something in just one place you need to change it in four different places. And more importantly when you update a list, you need a way to know quickly if there are other copies of that same list in the database without any extra sorting or filtering. For example if you're just looking at this wilderness survival list here. You have no way to know whether it's been shared with other users. And for that we have a node called shared with. Let's take a look at it in the database. So here's shared with, let's notice kind of like shopping list items. For every list that is shared, you will have an entry and share it with. And the key of that note will be the list push ID. Inside of that node will be a list of users that that shopping list has been sharedWith. So going back to our book club example, when you want to update the value of a list such as the list name, you have one place where you can look up all the users of the list to share it with. This allows you to construct the various URLs that you'll need to get to the user list of the database. Because now you have access to everybody's encoded email, you have both parts the encoded email and the push ID that you need to get to a specific list. Okay, so at this point we've talked about sharedWith, shoppingListitems and userLists. We're going to keep around our list of users, which we'll just have all of the users that are in our app. And this is functioning as it did before. We'll also make some userFriends lists. But I'll talk more about that when we go into implementing those screens. Okay, so if you want to take a look at this database structure yourself, you can load up the JSON file with the instructor notes. Once you have a handle on what's changed and what's sort of going on here, we'll start the refactor from the huge list of shopping lists that's currently stored in the active list node to this new user lists centric organization that I've described. Okay, since we changed the data model around, we're going to need to do some refactoring. Let's see what classes we're going to touch. This is a pretty big change in the way that we're thinking about our data, so I'm going to try to divide up these changes into steps. The first step is to delete old constants. I'm going to be here in the Constants class. You're going to remove the whole active list node and as such, there's some constants that you're going to no longer need. If you move these constants you can easily see the places in your code that were getting data from the old active list location. There's one here, which is just the word active lists that was being appended to your URLs. And then down here, in the URL constants, we also have a constant that we can remove. Okay, and now when you run your code you're going to get a lot of errors from the different places that we're using these constants. You can go through those errors or if you really squeamish about breaking your app. You can right click or use the keyboard shortcut and use the Find Usages command. Okay, let's go to the next step. The next step is fixing up the read operations and this should be fairly quick. You should think about the screens again, and which parts we'll need to read for the new data location. For example, all of this is list data, it probably needs to read from the new data location. And this list name over here, also list data, probably needs to read from the new list location. Updating writing will be a bit more difficult. Remember, whenever you change some detail about the shopping list, other than the items, it's going to need to change in multiple places now. It'll need to change in the owner's shopping list and in the shopping list of all the users that the owner has shared the list with. So I have a couple of thoughts of the best way to approach this. See if you remember a discussion about using updateChildren? Not sure when we had it, but basically, updateChildren is preferable to set value because it allows you to update a bunch of different places a good database all at once. And therefore, you don't need to worry about consistency issues. Now that we've got a bunch of shopping lists that we want to keep in sync, it'll be even more important to use updateChildren. This will keep you from getting into inconsistent half baked state, where some users have updated lists and others don't. You might also remember that I talked about making a helper method, and this method is specifically for keeping copies of the same object synced. And this helper method would be specifically for updating a property of a shopping list in multiple places. The method could take information about the shopping list and the property to update. And then, make that update to the appropriate locations throughout your app using key value pairs in a hash map. When you're generating this hash map for using updateChildren, remember that every list is going to have an owner and eventually they'll all have a shared with a list. We haven't implemented sharing yet, so right now just focus on the code to update the owner of the list. It seems a little silly because you're using updateChildren to only update one property but I'll make the switch to using shared with a lot easier. Whenever and wherever you change a property for a shopping list, you should be using this method that you just made. Okay, so here are all the thoughts I have about the refactor and I've also included the finalized database schema the notes again. Why don't you take a look at the spec and then update the out. Thanks a bunch. Okay, great job with the refactoring to normalize the shopping lists. While you were working on that, I made two new screens for sharing. Let me show you what they look like. You might have remembered the sharing flow from when I mentioned it before. So you have some list open. Let's say a generic grocery list. And you can click the share icon. The Share icon will take you to the new Share List activity that I've created for you. Here you'll see a list of your friends. And if you want to add a new friend, you can click the Add New Friend button. This takes you to the Add Friend activity, which has a list of all users in the app. If you want to add one of them as a friend, you simply need to click their email address, and you'll be taken back to the Share List activity with the new friend added. Things get more complicated when you actually want to start sharing the lists with these friends. But for now, let's start with just this ShareList AddFriendActivity interaction. All that I want is for you to make it so when you click add friend, you see a list of users, you could select the user, and then they end up here in the ShareList. Right now, displaying the list of all users of the app should be pretty straightforward. After all, you know how to use Firebase list of actors. And you have a location in your Firebase database that contains a list of all users. But what about this list of friends here? Remember that our database design included a node called user friends, which I've been told I haven't talked much about. Let's take a look at that node in the database design schema. So here's the database design that we're going for, and we can see the user friends node here. If we expand it, you'll see that we're going to have a list of user emails. For every user that has friends, they'll be a list. And then under each user email, they'll be a list of friend emails. You can go ahead and put an entire user object here, so that you'll have access to the user's name. So getting that list of users that you need to show on the sharing screen is a simple as attaching a list right here. To the encoded email of the user that you're interested in. Okay, I'm excited for you to add these new screens, and I'm sending over the exact specifications, and the code, for the new screens now. Okay, so now you have a list of friends. But not the ability to share lists with those friends. I'm going to split up the actual sharing code into two parts. The first thing we'll do is to simply keep track of who is shared on what list. The second part, is making sure that when a user is shared, they get a copy of the list in their own user lists. And then on top of that, whenever a list anywhere is updated, that all of the copies of that list are simultaneously updated. Let's start by focusing on this first part. Okay, so here we are back at the sharing flow. And we're going to focus on the share list activity specifically, because we already dealt with how to add friends. When I press the great plus button here, there needs to be a change in both the UI of the share list activity and the data in the database. So let's talk about what the change will look like. Well for the UI that change is pretty easy. I'll see green check next to the name of the person that I just shared the list with. In the database, you're going to be changing around what is in the shared with a list. We can see the change here. Since I added Lyla, in shared with under the same push ID as the list I'm interested in. So right here. We have the user data for the user that I just shared with. So basically, when you press this plus button, it should add that user's user data to the Shared With list for the shopping list that you're sharing. And again, that shopping list is specified by the push ID here. And when you press the button again, it should remove that user from the shared list, and put the UI back to the gray plus button. Alright, hopefully that's enough for you to get started. I'll send over the spec right away. We have an app which has a list of friends and you can add those friends to the shared list here just by clicking this button. And you can also remove them. Pretty cool. So, it looks like we're effectively keeping track of who is shared on what lists. So now it's time to actually change around the user lists to add shopping lists when they're shared with the user. This is a fairly complicated task. So here's some thoughts that I had about how to break it down. My recommendation is that the first thing you should do is to add or remove a list to a users list. So when you press the plus button. And becomes green. You should actually take that list and add it to the user list of the friend that you're sharing with. Conversely, if you press the green check to unshare it. To remove the list from your friend's user lists. Also, a quick reminder, whenever you're changing around who's shared on the list, it should update the timestamp last changed for all users. Okay, so once you've got that working, you can change or update map for all with value to update the lists for all shared users. Right now, it's doing it pretty effectively for the owner but you should have this method also update for anybody that's on the shared with list. For updateMapForAllWithValue to actually be able to do this, you might need to change the signature to include passing in a shared with list. And since you're probably going to be changing around that method signature, you're also going to want to update all the places that you call updateMapForAllWithValue. So that you can pass in that shared with list. You might find that you're calling this method from Adapters and Dialogs. And that gets a little bit more tricky. Let me give you some tips. For Adapters, you could set a list of shared users much like you said a shopping list in an Adapter. Let me show you in the code. In ActiveListItemAdapter of a ShoppingList member variable. And that shopping list member variable is actually set here with this setShoppingList method. Okay, so now if I go over to active list details activity, I'm here in the onCreate method and a lot of stuff happens. I'm scrolling down. But, one of the things is I get a listener that grabs the shopping list. So it's the activity shopping list member variable. And then passes in the shopping list into the adapter. So you could do something kind of similar in the activity. You can grab, in the activity, you can grab the shared with list. And then when that changes you can pass that into the adapter. Dialogs are similarly a little bit tricky. Now, you can pass in these shared users into a new instance method, much like you would a primitive value. But shared users is a hash map, and, if you remember, in the new instance methods,we're putting all those values into a bundle. So, you might be wondering how to put a hash map into a bundle, well you can use Bundle's handy dandy put Serializable method. And similarly you can pull it out of the bundle by using Bundle's handy dandy get Serializable method. You just have to remember to also cast it to hash map. All right so I'm not going to lie, this is a pretty big update. But I know you're ready for it. Read the spec carefully, work incrementally, and reach out if you need help. I'll also go ahead and add a link to adding log level debugging information in the instructor notes. Okay, best of luck and I'll send over the spec right now. I've recently been thinking about why we use update children instead of lots of set value instructions. I'm guessing it has something to do with data consistency. Frank said he was just talking with somebody else about consistency issues. want to see if I can find him? Yes, but I've got a doctor's appointment to check out the medical side effects of truth-seeing amulets. Hm. The developer's free, though. Yeah, you should come over. want to take the company sailboat? [MUSIC] Hello and welcome. I'm here with Puff, an engineer on the Firebase team, and we're here to talk about how to keep data consistent in Firebase. Yeah that's going to be fun. So, Puff, I get how you do initial design. But how do you ensure that your data can remain scalable afterwards? Yeah, that's a good question, it's always, always tricky, right. When we do the initial data design, lots of software engineers are database modelers by education. So we try to minimize the duplication of data. We go through all our database normalization forms. And then we notice things don't scale up very well, and we need to start denormalizing a bit. So in Firebase, that pretty much comes in the form of duplicating data. So instead of having one place where you store the bit of data, you actually store it in every place where you might need it. So if you have a chat application, for example, you have a list of messages and a list of users, and every message belongs to one user. So it's very, very natural to want to just store the ID of the user and look the user up. But that means that every time you need to display a message, you need to look up the user that the message belongs to. And it might be easier to actually store the minimal information you need to display for a user, like the user name, next to every chat message. Because then if you want to show a list of chat messages, you just load the messages and you don't need to do a lookup yet. So that's a very common thing we see, and this is data duplication. It's not very natural, but it's how you can keep your data scalable. Puff, would you explain what atomic updates are versus the opposite sort of method? Yeah, sure. So the scenario we just had where you have a chat room and you have the users separately, but you keep the name of every user with the message that they post. And let's say that the user wants to change their name, right. So the first thing you need to do is that you update the user name in their user profile, but then you need to loop through all chat messages and update the names there. So the simple way of doing this is actually write your first update or set value on the user profile, and then you find all the messages that they have, and you loop through them and update them one by one. That works great. The problem with it is that if somewhere in the middle, the user closes the Android app, then you have, yeah, there will be no more updates being sent, and you have half of the messages updated and the other half won't be. And that's what atomic updates solve. So with atomic updates, we build the entire, both the changing of the name, and the fanning that data out into every chat message, we put that in a single command to the Firebase database. So that command can be pretty big, but it's either going to completely succeed or it's not going to happen at all, so. And this is very beneficial if you're updating duplicated data. So what are the major ways that people keep data denormalized in the world of Firebase? It's mostly about duplicating data. So I often tell people to model screens in their Firebase. So the information that you need in a screen, try to get that into one location or as few locations as possible in the database. And so that's what we had before with the chat application, right, where you store the user name with each message even though you will also have their name in the profile. And you will see this quite often. So we see people, if you're having a list of bank transactions, for example, you might want to duplicate the credit card information for every bank transaction. So this is one where we see it quite often too. And essentially, they're all variations on the same theme, where you duplicate the data into multiple places so that you only have to read fewer locations. So, Puff, are there any times when you can't use atomic updates? Yeah, there are, so atomic updates, right, the update either makes it to the Firebase database or it doesn't. So there's no inconsistent state that you can have. We have one other way of doing that, that's when you use a transaction. And atomic updates and transactions, they are sort of similar, although they're completely different APIs. Why you would want to use a transaction is if you also want to get the previous value in there. An atomic update can write to multiple locations, but you don't know the current value on any of the locations. If you need to know the current value, for example if you are going to increase a counter or keep the balance of an account, then you need to still use a transaction, you can't use atomic updates. So I just want to make sure on this one, Puff, and just make sure our developer really understands this one. Are there any other limits to atomic updates that we should know about? Not atomic updates per se. One of the things, I think in the course, we focused a lot on using atomic updates from the Android client, and they work great there. But as you are updating more data, your update command, the network traffic will get bigger. So there's a certain limit where it's not a good idea to do this from a client anymore. If you're building a social media app, then, if a user on your app has a million followers, then probably you don't want to write all that duplicate data from an Android device, because it just becomes too much data that you're sending. So in that case you most likely want to do still use the atomic updates, but you want to use them from a server. It's still the same mechanism, you still use the same API, but you're moving it off of the client device to an environment where you have probably better network connectivity, and more memory available. That makes sense. So, Puff, thanks very much for time. I really appreciate your help. Sure. You're welcome. I think it's going to really help our developer out. Cool, that's why we're here. All right, thanks a lot. Sure. All right, cheers. Now let's hit the pool. Okay. So, I've got some good news and I've got some bad news. What do you want to hear first? Stark as always. All right, well, I'll tell you the good news first. So, the beta testers love the ability to share with their friends. You can see that here Paulter's rating about it. Well, as much as Paulter raves. Bad news is that we've got a couple of one and two star reviews complaining that they're having trouble finding their friends in the massive user accounts. Katie here says that she loves the sharing feature. But with over 400 users, she can't find any of her actual friends. I'm thinking maybe the thing to work on next to deal with some of these issues is some sort of auto complete searching functionality. And, I'm guessing we could use of Firebase's query features to implement this functionality. I'm going to think about how you might implement it a little bit more. But, while you're waiting, why don't you jump on a call with JP to learn a little bit more about range queries in Firebase. Sorting is great, but sometimes you need more than sorting. For example, what if you need to section off pieces of data querying on all of the shopping lists which were edited in the last 30 days only? Or only show shopping list items bought by a specific user. When you need to make this type of query, we use what are called range queries and Firebase. To use these, we take one of three methods. startAt(), endAt() and equalTo(), which allow you to grab only a specific section of our data. startAt() will create a query at a specific starting point. Only child nodes that exactly match the starting point and or greater will be returned. endAt() is similar child node they have a value less than or equal to the given value will be returned. Going back to the desserts example, maybe we only want desserts that are exactly 322 calories. So, we would use this statement. equalTo() will filter range queries based on exact matches, either returning child nodes which match a specified value or a specific key value pair. Maybe we were on a diet and only want desserts that are 200 calories or less. In this case, we would use the following. Let's say we're trying to eat everything we can. Maybe we're training for a marathon. So, let's say we're not interested in any low fat desserts. We only want desserts with 358 calories or more. Unlike sort by criteria, you can combine startAt() and endAt(), and you will get what is in between these values. For example, if we had very strict dietary requirements, perhaps we only want to eat dessert between 200 and 400 calories, we could use the following code. Notice how in all cases we start with a query by child. This allows us to specify what exactly we're looking for when we say startAt() or endAt(). And startAt() and endAt() our inclusive. So now that you are familiar with these range queries, let's practice what you've learned. These questions are about the shopping list plus, plus database. Don't forget that you have to specify query by child and which child you are querying. How do you get all the users who joined after September 30, 2015 at midnight? How do you get the items in a shopping list bought by a user with the email address Laila@gmail.com? If shopping list items include a property price, how would you find all items with a price equal to, or greater than to, and less than $10? Okay, while J.P. was talking to you, I found out how we could perform searches in Firebase. Here's an example statement that I want you to look at. What this code does is it returns all the lists names that start with do. Let's break this statement apart. Ref is a Firebase location, in this case it's a reference to all the shopping lists of a user. Next, you need to order the objects in that location by whatever property you want to search on. In this case we're searching on the property list name. If you want to search through values or keys you can order by those constraints as well. And then we have this startAt ednAt. The startAt says begin with all words that start with do. Remember, startAt is inclusive so there could be a list name that's just do and that would be included in the results returned by this query. Okay, so we're starting our words that begin with do and we're ending at words that begin with do and then this tilde. So what's the purpose of this tilde? Well the tilde has the special characteristic of being one of the last characters of the ASCII alphabet. All right, now they give a little bit more of an idea of what this is actually saying let's see what it does in practice. Let's say that I have a user with these lists in their user lists. Ref here would be referring to these lists. Now these are currently ordered by the time which the user saves them, but we're going to do an order by childless name which will sort them by their lists name. So, here are the sort of lists, notice how the space here comes before all the characters in the alphabet. So do space comes before don. So I've done these two commands now I'm going to startAt do. And what that means is I skip over things that start with da and di and I start at this one that starts with do. I ended do told again tilde, again tilde is character that comes after all of the other characters. It's kind of like saying endeAt doz, but tilde actually comes after Z as well as punctuation in the ASCII alphabet. So I'm trying to find things that fall between these two. Do not delete this list as one such thing. The space character comes before the tilde character so it's included. Same thing with donut run. Don comes after do, and don and comes before do~ because n is before tilda. Similarly with donut run, donut run would come after the string DO, but, before the strike DO [INAUDIBLE], because you is before told them. Dpans misspelled list, on the other hand, does not start with do. It starts with DP, which comes after do, so it would not be included in this range. So this is what we end up with. And these are the lists here that are returned by this query, which happen to be all the lists that start with do. Hopefully that makes some sense, but I've got a couple questions just to make sure that you're following. Okay, so here's the same list of shopping lists, and I've gone ahead and put them in order for you. And here are two queries that are similar to the query that I just showed you, but with something a little different in each. This one doesn't include the endAt and this ends at doZ. Note that this is a capital Z and it actually does matter. Given this query, check off the lists that would be returned. Similarly, given this query check off a list that would be returned. This one's a little bit more tricky so I highly suggest that you check out the ordering of the ASCII alphabet before answering. I've included it in the instructor notes below if you need it. So here, if you leave off the endAt, what happens? Well, we still have the same startAt, so we're not going to take Dan's shopping lists or dinner requests, because they start before do. Without endAt, there's nothing to stop us from selecting everything else in this list. All of these lists come after the string do. So selecting all these is the correct answer here. Now, in this case, we still have the same startAt, so again, we're not going to include Dan's shopping list or dinner requests. But we end at doZ. Because I don't know the ASCII alphabet off the top of my head, let's take a look at a web page. Here I've loaded up the Wikipedia web page. I'm going to scroll down to the ASCII table. All right, and here's an ASCII printable code chart. So reading, this we have space comes before exclamation point comes before quotes, and you can see the decimal values increasing here. So we have all these characters, notably numbers here, some more punctuation, and then after that, we have all of the capital characters, and then only after that do we have all of the lowercase characters. So the capital Z comes before all of the lowercase characters. Meaning that anything that starts with do and then a lowercase character is not going to fall within the range. The one thing to note is that the space character here does come before the capital Z. What this means for example is that do lowercase n is not going to be included, as are none of these other ones, but do space will be. So that's what I think the answer is to these two. Okay, you're almost ready to add this feature to the app. One caveat. Let's say you search for users whose emails start with d. When we eventually have thousands of users, this could be 50 users, 100 users, maybe 1,000 emails that start with d. We need some way to limit the number of responses returned. JP said he'd tell you about limit queries, so I'll send you to talk to him. Sometimes when you search for something in Firebase, you get a huge number of responses, but that's not always ideal. For example, sometimes you might want to find the first 20 results, but ignore the rest. So for situations like this, you want to truncate your query results by using limit queries. Firebase has two limit queries, limitTofFirst and limitToLast. Each method will limit the number of children returned from a query. For example, if you set a limit of three, when you use limitToFirst, the first three children will be returned from the query. LimitToLast functions similarly with the only difference being that it will return the last three children. Both methods can be used with orderByChild or orderByValue. OrderByChild to choose which attribute to query. OrderByValue to return a limited set of results for something like a leader board. I think you're ready to implement a simplistic autocomplete feature for users in the app. I'm sending over the specifications about it right now. Take a look. All right, I'm now sharing a Googler shopping list with Frank, Jenny, and Abe. The sharing feature is pretty slick. I'm glad you like it. It certainly wasn't an easy road to get to this point. Let's take a look at what we've accomplished in the wire frames. At the start of version 0.4, we added some basic sorting functionality to make it easier to find shopping lists. This helped users organize their lists. But what we really needed was sharing. After some prophetic guidance, we decided to go with a denormalized data structure that would support our need for quick look ups of users' shopping lists. This increased the amount of data we were storing but ultimately saved the users time. Right, and after that data change, you were able to make a sharing flow. Where users added other users to a friends list, and then turn sharing on and off. Furthermore, we simplified this flow by adding auto complete search functionality when typing in user emails. Great work. Great. And now I'm off to do some guerilla marketing. Do you guys know who Ariel Parson is? I think it's my dermatologist. Wait? No. No. No idea. No. No one I know. That's great, do you know what this means? This means that there is somebody out there that is not either a direct friend, family member, or pet of someone in this room that's using Shopping List++. That's awesome. I know, high fives all around, high fives, high fives. High fives, JP! You seem a lot more energetic. Yeah, I don't know if it's that red black caffeinated insta I had or the fact that I've finally been able to get some sleep, but man, I feel great. That's good to hear. That's good to hear. This is a real person. I know a real person. No, that's not what I meant. This is a spambot or a malicious user. Nah. I mean, come on JP. It's not like somebody's trying to hack into our system. Well, I hate to burst your bubble but now the app is released, aren't you at all concerned about security? Not now JP. Tonight, we dance. [MUSIC] [SOUND] [LAUGH] [MUSIC] Hey team. So, things are lot more chiller out here since the Point Four launch. The users are happy, our investors are happy. And now that we've got sharing implemented, most of the features we want in the app are basically done. I've even had enough capital to hire Paulter on as our attorney and data scientist. That's so great to hear. It sounds like you're on track to a very successful launch. Wait, JP. You're doing that thing. What? The thing you do when you're worried about something but you don't want to say it. Well, you're both doing so well. I don't want to rain on your parade. I was just wondering if you looked into some of the other features Firebase offers? Okay, like what? Well, for example, in version .5, if you have time, you could look into providing some basic offline access. Firebase provides a few methods to make it very simple to cache and persist your data locally, even when you're Internet connection is shoddy. After that, you might want to take a look at Firebase's offerings for authorization and validation. It jSon database like Firebase, you can accept basically any mishmash of key value pairs. Firebase allows you to write some data rules server side. Then enforce the structure of your data. In addition, you can write permission rules that based off of your users authentication tests, allow you to control read write access to the data. Okay, JP. We'll think about it. Right now working on a slide deck for investors. But, I guess I could have the developer look at some of that. But really JP its not like anyone is actively trying to attack us. [MUSIC] Have you thought any more about offline access? Mm-hm. I'm just thinking about the gift shopping I'll be doing during my vacation in Hawaii. I'm not sure how my cell network access is going to be out there and it'd be really good to not lose all my shopping list data when the internet connection is flaky. Well. Well, I guess it's a fair point but, I don't know the more you think about it the more tricky it sounds like it be to set up. So first of all you need to be caching the data locally somewhere which would necessitate using maybe a sequel like database or something like that. You'd also be needing to cache kind of the stuff that the user does when the app is offline. So say you were to buy. I don't know some tiki masks or something offline. You would then need to send that data that you bought that to the phone when you reconnect. And frankly, we just don't have the engineering resources right now to even start implementing that. Firebase is actually doing some caching by default as well as queuing any actions your user makes offline. Well, actually that's awesome. In that case don't we just get offline access for free? Some of the time. Okay, well. I'm wrapped up in important business decisions. So maybe you can talk to the developer about all that offline stuff. Sure. You do know your camera is on right now? Yes, yes it is Okay let's talk a little about how Firebase deals with offline access and data in general and what you get for free. We have two clients your phone in my phone for example. And let's say my phone isn't connected. Maybe I put my phone into airplane mode. But I still have shopping list plus plus up on my device. In this situation, my client keeps a local cache. This includes all the data that was in the app the last time I had access. I can keep making changes and see them immediately. In actuality, every client of Firebase app maintains its own version of active data. And changes made for this local copy of the database trigger actions locally first before data gets written to the server. So it's not just a matter of it works offline. It's actually by design. Anyway when I'm connected again, the app will get updated based on the changes I made offline. In that situation my client will push the correct events to the server, the ones I made offline, and I will get the changes from the server based on the changes you made. This is what you get for free with Firebase. So you can keep the ways to deal with shoddy connectivity for free. It doesn't cover every situation though. For example, you're probably very judicious about cleaning up listeners in Shopping Lists++. This means that when a user navigates away from a screen, the listener is probably cleaned up. This is great for memory performance, but it also flushes our local cache of data. So say you're online and it shows you your lists, then you go offline. Changes you do on that screen are saved locally while you're looking at the data. But when you navigate away from an activity in them back, It actually won't display the data because we destroyed the listener. The solution though is not to remove our clean-up code for listeners. Instead, there are two other options that you should be aware of to leverage what is saved in the local Firebase cache. They are setPersistenceEnabled, and keepSynced. setPersistenceEnable keeps any data you download from the database around in the local cache. This would solve the problem I mentioned before with cleaning up listeners. It also saves data between restarts of the app. Let's say you're shopping for a very, very long time. You've been recording all these purchases you're making and then your phone runs out of battery and shuts off, closing the app. If you didn't use setPersistenceEnabled, any data that wasn't sent to the server isn't saved for free. Since setPersistenceEnabled is so useful, you might be wondering when you shouldn't use it. There are two downsides to using separate setPersistenceEnabled. It does use more disk space to store your data locally. Another downside is that if you were offline and used lots of addListenersForSingleValueEvent, it will query the local storage if offline. If you then come online, it will not query the database again. This makes it possible to show old data to your user and can create tricky bugs to find. If you want to cache additional parts of the database that you don't have listeners for, the method keepsSynced is available to you. For example consider this. You're a user and you load up your list of shopping lists but you haven't clicked on any specific shopping list. Imagine you go offline. And then select one of these lists. What will you see? You'll see a shopping list with no items. You never had a listener for these items. So the local cache will not of save these items. Using keepSynced though, you could explicitly say listen to this data, and it will keep the data sync locally. Then, if a user clicks on a shopping list, even when you're offline, you'd see the items when you open up the activity and the state of those items would match what they looked like the instant the app went offline. Again, the downside of using keepSynced is the amount of data you store locally. Even though these methods use a little extra memory, they are important to know about so you can keep the most important screens of your app working seamlessly for users, even in flakey connectivity or offline situations. Hey again. So it turns out that JP might not have been that crazy when he asked for offline access. So I have been getting some complaints from some of our users about erratic behavior in shopping marts. In some stores, for whatever reason, when they don't have internet access a user will make changes at then the next time they open up the app, those changes won't be recorded. Could you maybe look into fixing this? Using the method set persistence enable should the trick. You can put in the application class for shopping list plus plus to ensure that it gets called as soon as the app starts. You can look at the solution code in the instructor notes but I just wanted to take a second to show you what the app actually looks like now. Before we set persistence enabled as J.P. showed you, when you navigated between different screens, the listener would be destroyed, and with it the data. Now that we have separate systems enabled, let's see what happens going to go into these two shopping lists. They're the same shopping list, and they're currently sync up because I'm online. Now let's go offline with this phone, and will add an item. And then we'll kind of navigate around a bit. As you can see, even though I navigated away and back, and the listener was destroyed, this item is still here. And I can navigate around the app a little bit more. Create another shopping list. Go take a look at that. All this stuff while offline and then when I go online again we can see that it syncs up. Pretty sweet. [MUSIC] Mm! Mm! [SOUND] [MUSIC] All right. We're one day closer to launch. And we've got tons of traffic on the site. Things are looking pretty great. Excellent, well I just booked my trip to Hawaii. With the launch so close, I'm sure nothing could go wrong. [LAUGH] Yeah. That's funny. What? It's probably nothing. I don't know, but take look at the data structure. I must have not deleted one of my test shopping lists. Hm, these are data seems to have a couple of fields that I don't really remember putting in there. And some of these emails look a little bit off. Man, I must be really out of it. It should be easy that to fix though. What if while you're fixing that, you also future-proofed your data by creating Firebase security rules? This would help both make sure you don't accidentally introduce anything to your data structure you didn't mean to, and protect your app against those with malicious intentions. Well, it does look like we have a little bit more time before lunch. Hey, developer, are you still with us? Maybe we could talk a little bit about security. So Firebase provides us with a bunch of features for free so, is it doing anything automatically to protect our data? Not anything automatically that I know of. But why don't you check it out. Yeah, check it out. Okay, well about the security and rules tab of the dashboard. Well, this seems pretty unsecured. It's a little bit troubling. Why do you say that? What about all that permissioning and log in flow stuff you talked about when designing version point three. That was client side security. So, here we have the Firebase server and the client side app. Anyone using the shopping list plus plus Android app will get any of the security and permissioning that I built into the app itself. Things like needing to be logged in before seeing any data in the app, or needing to be the owner of the shopping list before seeing the share icon to share your shopping list with friends. But again, this is all client side logic the server knows nothing about. By default, the server itself is wide open, allowing our data to be written by anyone or anything. Now if all communication is done via the Android app things are okay. But say in hopefully the near future we make a iOS app and a web app for Shopping List plus plus. And as a team what we probably do is try to implement the same security features in the Android app in both of these other apps. Now I'm not iOS programmer or a web app programmer. So I just kind of have to hope that who's ever making these two apps knows what they're doing. Let's say that the iOS girl knows what she's doing. But whoever made the web app was a little sloppy and introduced some security bugs. So even though these clients were implemented correctly. One client being implemented incorrectly jeopardizes the entire database. This is where you might be wishing that there was just one place where you could enforce what can and can't be done with the data. Because otherwise again we're relying on every single client to implement security perfectly and in the same way. Right and that's the purpose of server side rules. Namely those Firebased security rules I've been hounding you about. All right, all right JP you're right. We should do something about security. Come to think of it. Jeez. What? Well I just realized there's an even bigger security flaw than just writing a web app with a bug in it. Remember when we first wrote our Android app I didn't have to do anything to verify that the app was owned by the same person that owned the Firebase. So going back to my data here is a JS fiddle and it's just some arbitrary JavaScript here. And basically I just copied this from the quick start guide for writing JavaScript for Firebase, and if I run this it actually affects my Firebase over here. And this could have been run by anybody, I mean, there is nothing that required me to verify where this code was coming from. So it looks like, basically anywhere. Anyone in the world can write, read data to our database. Okay JP, it looks like we kind of are open to security threats. So why don't you tell me what we can do with Firebase security rules? You got it. So let's talk about security in Firebase. Taking a step back, when we say security, we can divide this up into three subcategories. Authentication, authorization and validation. We discussed authentication in version 0.3 of the app when we added the ability to log in using Firebase. Authorization is about controlling access to your data by specifying who has read write permission and to what objects in your database. Authorization is often used in conjunction with authentication. This is a fancy way of saying you can have somebody log in and then only allow them to look at information related to them, such as limiting the list of shopping lists they can access. The final form of security, validation, is used to check that the data conforms to some expected standard for the structure of the data. For example, validation rules can specify exactly what properties a shopping list object can contain, or verify that an e-mail address contains an at symbol. Lyla was worried about either herself or somebody else adding these unnecessary. And in some cases malformed feels to shopping less plus plus. Given that, which of these three topics should we start talking about to solve that issue. Right. you'll need to learn a bit more about validation rules to protect the structure of the data and protect malformed trash data from getting into the database. All right. So, J.P. gave you a very good summary of what the options are, available to you. When you use firebases rules and security language But, what do these rules actually look like. Before we dive into validation, let's take a quick look at how these rules are structured. You already saw an example of what rules look like ,when we looked at the dashboard before. In fact clicking here, is where you'll need to go to edit your rules. Once you're in the Security & Rules tab, you could write your rules here and save them using this button. Any changes that you save, will immediately affect any read or write calls sent to your Firebase database. These rules should also look familiar from when in Version 0.4, we talked about using index on and value rules, okay. So, here are the default rules, the rules themselves are adjacent, which look similar to your firebase database itself. There are string key value pairs, which are separated by colons nd everything that's considered an object or list. Is surrounded by curly braces, as seen here, remember that these strings are enclosed in quotes. If you're not super familiar with this sort of adjacent syntax, I've provided a link to a sample rules file. That you could look at to base your rule syntax off of. So, what are these rules doing? Well, these are the simplest of simple list rules, your rules file will always start with this rules object here. And then usually, the children inside of it mirror the structure of your actual database. In this case, these rules are providing access to the entire database, no matter what the structure happens to be. It's read and write viewable and there are no validation rules, so there aren't any structural constraints here. Including these two rules is actually important, because by default access to the data is false. So, you do need these rules to explicitly say, that read is true for the whole database and right is true for the whole database. Because if I actually deleted this and saved it, by default, nobody would be able to write anything to the database but I would do that. Normally your rules are going to mirror your database structure. So for example, if I wanted to write some rules to validate the structure of my user node, I might write something like this. As you can see here, I've got the exact route name of the user and here, I've got the key names embedded of all the properties. So your key names here need to match exactly what's shown in your database and they need to be nested in exactly the same way. Now, you might be wondering what this key here is all about. the dollar sign followed by a word, indicates what is noted firebase as a wildcard variable. Now wildcard variables have a couple different uses but the most common one is, to represent dynamic keys like push ids. And in this case, user emails, because remember, under the user node is a list of user emails. The keys of which we can't guess in advance. Now, once you've laid out this structure, you can start defining rules for the user object. When you want to write a rule for a particular location, you go to the location in your rules file that mirrors the location in your database. And this is your first example of a rule, the Kiva rule is always a dot read, dot write or dot validate value. And the value of a rule will always be something that evaluates to a boolean and this is important. Because when a user tries to read or write at that location, the value of this boolean affects whether they're actually able to do so. Now, these expressions that evaluate to billions can get pretty complicated, they can include comparison and logical operators. And Firebase also provides additional methods and internal preset variables that allow you to get a value at the current location. Or compare to other locations of the database. For example, there are methods that let you look at the data at children and parent locations of your current location. So if necessary, you could do comparisons between the value of name of the value of email. Or even the value of name and someplace totally else in the database. Okay, so once you've written this out and you actually start to try to read or write data at certain locations. All of the applicable rules along the path to that location, will be checked. Validate and write rules are checked whenever a value is written, and read rules are checked whenever listeners are attached. For example, if I try to write in this location, with a value Lyla, any rules that are at the lylafish@gmail.com location. Which is this variable here, there aren't any rules here, and at the name location, which has one validate rule here. So total, because this is a right, these two rules would be checked, now let's pretend that this right rule wasn't here. This was actually the rule that was giving me the ability to write to this location. So if you ever tried to do something like that, where you don't have permission to do the action that you want to do. The on cancel callback method Will be triggered in your code, and it will be given a FirebaseError Of type PERMISSION_DENIED. All right, I've just thrown in lot of information at you, so let me take a moment to summarize. Your rules file as found in the firebase dashboard in the security and rules tab and the rules themselves are written in JSON. The actual permissions will have keys that are .right, .read or .validate and they will always have values that evaluate to either true or false. If there is no read or write rule at a location or its parent locations, then it will default to false. When you are writing your permission rule, you'll place it in the rules location that mirrors the database location that you're interested in. If a user tries to do something that is not allowed by the read, write or validate rules. The FirebaseError will be returned to them and its value will be Permission_Denied. Okay, and those are basically the facts that you need to get started. So go ahead and we'll start laying out some of these rules. Now that you got the basic structure of Rules down, let's talk specifically about validation rules. Validation rules are primarily used for enforcing the structure of your data and the format of your content. Take a look over here. This is the start of a validation rule for a new value being written in the listName field. And in plain English what it's saying, is that the value that's written here must be a string. And it's placement where it's nested inside userLists and then these two wildcard variables, and the property name listName makes it specifically a rule that affects the listName values. So let's take an actual look at the variables and methods that are used within this expression itself. First I'd like to point out this variable called newData. When you're writing your validation rules, you're almost always going to need a way to refer to the value that is either currently there, or that their users try to write to that location. Because of this, the Firebase rules language provides two predefined variables specifically for these values. And they are data and newData. You can use these anywhere within your rules. Now data refers to the data as it currently is, and newData refers to the data after a write has taken place. In the rules language, these have the variable types of RuleDataSnapshots. And they're called DataSnapshots, because they can either be a single value or a whole portion of data in the Firebase database. So just to be explicit, if I had a shopping list with something like Lyla's List, and then I went to edit it. Lyla's List would be the current value, which would be stored in data. Awesome List. Lyla's Awesome List, would be the value that'd be stored in newData. Now as I stated, both data and newData are what's known as RuledDataSnapshots. And RuledDataSnapshots have a bunch of methods that you can use in the rules. I'll go ahead and link to the API docs, where you can read to your heart's content about all of these methods. But here are a couple of interest. Because these are DataSnapshots, which know their location in the tree. You can use the parent or child method to navigate to other nodes in the tree. This lets you do cool things like create rules that compare one of the database to another part of the database. For example, if you wanted to access the owner value from your listName rule, you could write newData.parent, which would take you from listName up to the parent here. Then .child('owner'), which would take you down to the owner. Then finally val, which is a method that lets you get the current value at that variable. And for the user lylafish at this specific node, this rule would return this value here. And then you could use it in something like a comparison. In this case this is a kind of silly validate rule that doesn't make much sense. It's saying that the newData that you're writing for the listName must be the same as the owner's email. So you'd have a bunch of listNames named after owners. But hopefully that gives a little bit more insight about how you might be able to use the parent or child methods. Note that the ability to use parent in the rules is somewhat different than the DataSnapshots that we've been using in our Android app. When you get a DataSnapshot on the client side, you can't see anything that is the parent of the location that you requested. In the rules though, you can look at any other part of the database in order to make a rule. Which is why you can use a method like parent. Now as I mentioned, you can use the value method, and that'll give you a primitive value back from a data or newData object. In addition, you have methods that check for the type at a current location. And exist is actually a really helpful method to use when you're writing rules that are specific to whether a value is being added or removed. And with that, we can see that this isString method here, is one of the type method which is making sure that the value stored in newData is a string. Let's see an example of a little bit of a more complicated rule here. So here we've added another little bit to this rule. And basically what this says, is that newData is both a string, and that this new listName has at least one character in it. >From this example, you can see that JavaScript Logical and Comparison Operators are available to you. In addition, when you're dealing with values that are strings, there's a subset of Javascript string methods and properties which are available to you. newData.val().length is one such example, the length value is available to you. And another helpful one is the matches method, which allows you to match a string against a regular expression. For example, if you wanted to validate data at a location to see if it's in the form of an email address, you could use standard email address Regex. And then use matches to do the actual comparison. So that's pretty much the summary of writing a single validation rule. In addition, there are a few other things that you might want to keep in mind. The first is that whenever you write server side validation rules, you should also be writing the corresponding client side validation rules. For example, in the dialog where somebody changes a shopping lists listName, you should go ahead and check that that listName's actually greater than zero characters. There's no sense wasting one are your users' data plans, by pinging the database with improperly formatted data. So go ahead and save them and yourself that useless network traffic. Second, remember that validation rules are only checked when you're actually writing data. This maybe pretty straightforward, but they're not checked when you read data. And finally, validation rules are not checked when you're deleting data, otherwise you'd basically never be able to remove anything from the database. For example, if I try to set a listName here to null, and it was checking validation rules, then it would complain that null is neither a string nor has a length greater than zero. But it doesn't do those checks, and instead you don't have any validation checks when you're deleting something. Okay, so now that you know how to write a single rule, let's talk about validating an entire structure. The rules that I just showed you were great for validating a single property. But to deal with malformed data on a larger scale, you're also going to need to validate object structure. With Firebase rules, you can first require that certain properties must exist in the object as well as validate that those properties are the only properties that exist in the object. To require the existence to certain properties you could use either the hasChild or hasChildren method. The hasChildren method is if you want to verify for multiple properties and you can see it being used here. This rule requires that the name, email timestampJoined and hasloggedInWithPassword are properties that are included within any object that is saved at this location. hasChildren is pretty simple to use. It takes an array of property key names as shown here. And it's placed directly in the object. Now hasChildren requires that these properties exist, but it doesn't say that those are the only properties that can exist within the object. If you want to do that, you can add the following code. You make a wildcard variable in the top level the object and set its validation to false. So how does this work? To understand going on, you have to understand how wildcard variables work. When you write an object to the database, the properties of that object will be matched with all of these named variables first. So if an object that saved at this location has a name property, it will check the validation rules in here. If it has the email property it will check the validation rules in here. Now if that happens, as in if there is an extra property, it immediately validates to false. So two things. Note first that there's nothing special about the name other. It can really be dollar sign anything. Also, for this to work, you have to explicitly list out all the correct properties. Using both hasChildren and a wildcard variable, you can be sure that your data is structured exactly how it's meant to be. I've just told you a lot about validation rules, and I'd like you to start creating some for shopping list plus plus. Now writing validation rules is pretty straightforward. In fact if you'd like, I could walk you through creating one of these rules right now, start to end. Here, let's take a look at the user front node. When you're writing the rules for an object, take a look at the actual object itself in the database. So let's look at userFriends. So here's the main node userFriends, and it's going to have an arbitrary number of children for every user that has friends in the database. And then for each user that has friends,they in turn have a friends list, and they're also going to have arbitrary number of friends. The friends themselves have pretty much the same properties that we just saw. Okay, so first things first, let's map this out in the rules. We can see here that we have user friends. Those two match. And then here we have a wildcard variable for the users encoded email, and then we have another wildcard variable to represent each of the friends, and then each friend will have this structure of properties as matched here. Okay, so it looks like pretty much the structure matches the structure. That's good. Now this is not actually doing any sort of validation yet. Notice I haven't written a single validation rule. To start, we could write rules that make sure that all of the correct properties are present in the friend encoded email object. So I'll go ahead start by writing a new data has children rule right here. This rule will make sure that all these properties exist And also go ahead the write one for the timestamp joined. Now this only makes sure that these properties exist. It doesn't make sure that they are the only properties that exist. And it doesn't protect against writing other arbitrary properties that could be wrong. So do that, we have to use the dollar sign or wildcard variables as I described earlier, so I added those variables here. At this point, you're completely confirming the structure of the user object. Now you could write more specific rules for each of these properties. Generally, you could start by doing a type related validations. For example, the name should be a string. And just continuing down, the email should also be a string, has long to do with password is a boolean, and timestamp is a number. In addition, we could do a further validation on the email with the regular expression I showed you before. So it's a string, and its value matches the format of an email. And that's a pretty good start for ensuring the structure of the userFriends node. You may notice that these rules for user friends look similar to the rules that we wrote for the users themselves. I could essentially copy the user validation rules for a user objects stored here and paste them for the user validation rules for user objects stored in the user's node. But copying and pasting this user structure throughout my rules kind of makes me cringe a bit and it also makes the rules a lot harder to maintain when I want to change one thing. So I did a little bit of research on how to simplify my rules, and on the Firebase and rule security page, they suggest the Bolt compiler. The Bolt compiler is a officially supported high-level modeling and security language that compiles to Firebase JSON rules. And Bolt's pretty cool because it allows you to abstract out some of this repetitive validation code, among other features. Now, before you dive into the Bolt quick start, it should be noted that using Bolt is completely optional. Also, you should have a firm grasp of the rules language itself before diving too far into Bolt. The compiler is self described as a bit experimental. Meaning that it is relatively young and actively being worked on. So there are still a few kinks and things might change. With those caveats. Let's take a look at how you'd write the rules that you just wrote. But using bolt. To start, you'll need to set up. Now if everything goes smoothly, this should only take a few minutes. And involves first downloading npm. Npm stands for a node package manager and is a JavaScript package manager. Bolt is written in JavaScript, hence the need for npm. Once you have npm you can install Bolt. I've provided the instructions in the instructor notes, so take a moment now and install Bolt. Once you have Bolt installed, you can write a rules dot Bolt file. Ended the directory with your rules stop.bolt file, you could then read the following in a terminal. This will convert the bolt file into a JSON rules file which you can then copy over manually into fire base. So let's see the bolt file for user friends might look like. Remember the bolt is a modeling language. This means that it allows you to write typed models for your fire base object and then it generates all the necessary validation code. We have a user type, a timestamp type and an encoded email type. This allows you to abstract out all the qualities of a user or a timestamp into one place. These objects here can contain property keys and you can specify the type of each of these properties. This EncodedEmail type extends a string which means that everything that's an encoded email will also be a string. But there's an additional validation that the string has to have the format of an email address. And we can see up here that this property email is using this type EncodedEmail. Now this is all well and good. But it isn't saying where in our rules. To use these types. To do that you have to use something that both calls paths. Now instead of forcing you to write out the nested JSON structure. You right paths and then specify the rules within the path. You could also say the value. At the location that is referenced by the path. Is of one of the types that you defined above using is the type that it is. So here we're specifying that whatever is stored at the path userFriends, userEncodedEmail, friendEncodedEmail is a user object. And then in turn, we say what's stored at users and then userEncodedEmail is also a user object. So the validation for these two things is going to look exactly the same. And then once you've got your bolt file you can save it, and then run this command that I showed you before. Which then in turn generates a json file, which should look pretty darn similar to the json file that we just made. And that was with very minimal, to no, Copy and Paste. At this point you see a few examples of validation rules. So can I throw you out there and have you write the rest of the validation rules while I attend to other things around the company? I've written up two specs. So the first one will just get you up and running with the validation rules for a shopping list item. The others will let you finish off the rest of the validation rules. Here take a look. [MUSIC] All right, JP. The developer just finished up the validation rules. And I know that you've got your flight to Hawaii, and I've got some rest and relaxation to catch up on. So, I can finally close this pesky rules file, right? Well, I mentioned authentication, authorization, and validation. You've done two of three. JP, you're killing I me. More rules? Then, I guess those validation rules are pretty important, and the data is looking a lot cleaner. Right, and remember none of the validation rules are checked when something is deleted. Meaning someone could just delete the whole database with some JavaScript and also, what's the point of having someone log in without validation? Okay, okay, then I guess the developer and I could read up a little bit more on authorization. Now that you know a little bit more about both write rules and validate rules, you might be wondering what the exact differences are between the two. After all they are both executed when you try to write data to a database. Part of the difference is in their use. Validation rules should be used to ensure the correct structure and format of data, whereas right rules deal with who has access to write to that data. Functionally, the fact that write rules cascade down and validate rules do not is very important. Write rules should be used to map out portions of the data structure that particular users have access to write to. Whereas validate rules should be used to deny a user with write access if they're trying to do something strange to the data. Write rules therefore become about giving access to someone. Whereas validate rules can be used to further restrict improper data editing. For example, you could use a write rule to say that a user could alter an item's properties if they're the owner of the list or shared on that list. But say you want to also verify that there are some true things specific to each property, to make sure that the property is being used correctly. For example, you could validate that they change the item only to words that start with capital letters. Or you could do something like check that the user is shopping at a list if they want to edit the bought property of an item. And finally, another functional difference that I've mentioned but is very good to be again reminded of is that validate rules are not executed when something is deleted or removed. And basically what this means is that if you ever need to restrict access to deleting or removing items, you'd need to use the write rule for that. Okay, hope that clears things up a little bit. Using the process that I just showed you, I went ahead and made up a little bit of a draft for the rules that I think we might want to use in ShoppingList++. And I just outlined them in English, because I'm going to want you to eventually implement these. Now, just as a caveat, I know this is not a complete list. I'm sure there's plenty of additional validation rules, and maybe some read-write rules that you can add into this. But it's at least a start. Okay, so let's take a look. I started off with the users note here. And it probably looks pretty darn familiar. I think the biggest thing to point out is, I went ahead and indented this hasLoggedInWithPassword property. And I tried my best to do some indentation to imply where I think the rule should be placed. But as always, use your best judgment about rule placement. The rules pretty much follow what I explained before. So let's go ahead take a look at userLists next. Scroll down, and this is for a specific user. I decided that we're probably not going to have read or write rules for the entire list of all user lists in the app. But for a single user shopping list, there is a read rule, and it basically says that each user should be able to read their own lists. But there's no real reason why any other user should be able to read another user's shopping lists. That's probably a bit of a privacy concern if they could. Now I didn't put a write rule at this level, because that would basically say that somebody could do a bulk write, like write three shopping lists at once. And you never really do that in the app. You always write one list at a time, which is why down here I have a write rule for a single list. For single lists that are part of a user list, you need to give specific write privileges. And what this permission here is basically saying, is that the owner of the shopping list, which is different than the owner that I mention here. But the owner of the specific shopping list that's being written can add that list, or can delete that list. So an example of this is that within the app, the delete menu option should only be visible to the owner of that shopping list. So say Kaguri has a shopping list that she creates called list A, and she shares it with Walter and myself. Now she's the owner of that shopping list. But that shopping list is now in Walter and my user lists, because we have access to it. As the owner of the list, she has the permission to be able to go ahead and delete that shopping list. And she then needs to go into each of our user lists and delete that shopping list from our user lists. And with this write rule she should be allowed to do that, because she's the owner of that specific shopping list. Okay, but note that we don't give any editing privileges at this level. And that's because I didn't want to make it so that all of the properties of a shopping list could be edited or editable in the same way. So down here for each of these properties, I define who can edit them more explicitly. And I also have a couple of additional validate rules that go beyond the structural stuff that we talked about before. Okay, so next, our shopping list items. There's no part of the app where you're reading all shopping list items in every single shopping list. So again, this is for a specific shopping list. Anyone who is shared on the list, or the owner of the list itself, should be able to read the items, so that they can be displayed in the active list details activity, activity. Writing is a little bit more complicated since it varies from property to property. Since you add items one at a time, the only write action that can be done for the whole list is to delete it. Anyone who's shared on the list could add a single item. And furthermore, if the item is not bought, I say that either the owner of the list or the owner of the item can remove or edit the item. This is not entirely true, since in the app the owner cannot edit items. But for the sake of brevity, the rules won't specify that you can't do that. Again, if you want to take the time to get a little bit more specific in the rules, that's awesome. Okay, so just as I did with user lists, I go down here to the specific properties and have some additional write and validate rules. For example, we have validate rules that make sure that if an item is bought, it has a boughtBy user. Okay, let's go down to the sharedWith node. Like items, the sharedWith node is tied to a specific shopping list. And this node needs to be readable by anybody that is on the list, because every time you update a list property, we have this lookup where you see who else is shared on the list, and then use that to then update everybody else's shopping list. Writing to the shared list, which basically means the ability to share that list and add and remove users, is restricted to the owner of the shopping list. And they can either completely add a user or completely remove a user, but they can't edit specific properties of users, which is why I explicitly say add and remove. Finally, userFriends is restricted both read and write to just the user that owns that list of userFriends. Okay so this is just a draft summary of the rules that I came up with, and again if you think there are a couple of additional rules that you'd like to add, definitely go for it. I encourage you to add them and make ShoppingList++ more secure. I've been working through how you'd write super simplistic read it write rules using true and false. But that's kind of useless in the shopping list plus plus world where we want to read it write based off of who's logged in. Yes, connecting your authorization to your authentication. That should be very easy your developer just needs to know a bit about a few extra variables here, let me show you. As you know Firebase provides helpful variables that you can use in your rules. You've already learned about two of these, data and newData, which are essentially variables that you can use in your JSON Rules for the previous state of the data and the new state of the data. In addition, you have access to root, now and auth. Root is a variable that represents a rules data snapshot, much like data or new data, but it's of the root Node for your data. Now is a variable, that stores the timestamp, representing the exact time on the server. You can use it to write rules to check for things like whether the timestamp is before or after the current time. For example, the following rule could be used to check that somebody isn't trying to write a timestamp that is in the future. And one of the most important variables is the auth variable, this variable has two pieces of information. The provider and the uid of the user, if they're logged in, if the user is not logged in, the auth variable is equal to no. This variable allows you to check whether someone is logged in and is a specific user. A lot of the permissions to edit lists and shopping list items, dealt with who the logged in user was for any rules related to who the user is you'll need to use the auth variable. Beyond representing dynamic keys, wildcard variables are also available to you in the rules themselves, they take on the value of the key that they match. So if you had a messaging app that had lists of messages a user posted, this would allow you to write rules that compare the dynamic key of an object with the value of one of its children. Here we're checking that the user ID property of a message matches the user ID that it's listed under. If you learn to use these simple variables, writing your read-write rules will be easy as pie. You know how to actually write rules now, so why don't you write a read rule for the users node. The exact rule is, a user must be logged in to see a list of users. Can you go ahead to write the rule in your json rules now? I'll send over the spec. The most common thing that you do in the rules, besides checking if the user is the owner of the list, is to check whether the user is shared on the list. A prime example of this is the read rule for the shoppingListitems. So using the sharedWith table, can you check if the current user is shared on the shopping list? So if you're talking about a shopping list and you go over to userLists, and you look at the details of shopping list, you can see the owner's here. But because we've de-normalized some stuff, there are kind of parts of a shopping list which are located to different parts of the database. One example being shoppingListitems, and also sharedWith. Both of these are associated with a single shopping list. So let's say we are looking at the items for this shopping list, shopping list K7J-8k, and remember that shopping list owner is [INAUDIBLE] as shown here. If I'm over here in shoppingListitems, I could drill down and I don't really see who the owner of the shopping list is. That's not stored here. The owner of each of the items is stored here but, not the owner of the entire shopping list, which is important for some checks. And this leads to kind of long and difficult to read rules for shoppingListitems when I want to say something like the owner the shopping list can read these items. So can you think of a better solution for getting the order of a shopping list and using it in the rules for a shoppingListitems and sharedWith? Maybe you could draw some inspiration from the UND mapping note that you just created. I'll go ahead and send a respect right now. So in this case, this first one here looks like a pretty good rule. Let's break it down. Okay, so the first part of the statement is here. And what this part of the statement does is basically look up the shared with data for the listing question which remember, stores the key that has the same name. And this part of the rule right here gets us the email of the current user as I showed you before. Now, if this email is part of the sharedWith list, then it'll be equal to something other than null. And if this email isn't part of the sharedWith list which means that, that user hasn't been shared with on that list, then this whole value will be null. We do that comparison right here. And that gives us the correct answer for the rule. You are doing awesome work. To recap, let's talk a little bit about what you've done. So the first thing that you did is you defined a rule structure at that mirrors our actual database. Then, using that rule structure, you created validations for both properties and entire objects. Next we figured out what kind of read and write rules that you need for each root node. And that's all been laid out for you in a spec. So now we're ready to actually implement those rules, of course using those handy UID mapping and owner mapping rules that you just made. But before I throw you in the wild of writing read and write rules, I wanted to give you a couple of tips and tricks about troubleshooting. Because you might be wondering, how do you actually test a rule when it's not working? So my first tip is a oldie but a goodie, and it's basically to turn on the debug mode. This gives you access to all sorts of good data. In the case of a read, it will show you the exact location you're trying to read from. And in the case of write, it'll show you the exact data that you're sending to the app, that might or might not be getting denied. In addition though, Firebase actually provides you with a simulator to test out reading and writing data. And the simulator's pretty cool because it allows you to very clearly see what's happening with your permissions. Okay. So, in the Firebase dashboard, you can go ahead and go over to this Simulator tab and, for our app, because login is so important, you're going to want to select a Custom Auth. The provider doesn't, matter but the UID does. This will make it so that when you're using your read/write rules, in this case the provider isn't important, but you should put in a UID of a pre-existing user in your app. In my case, I'm going to go ahead and put in UID. And I just copied and pasted this over from my data here, where if you look at the UID mappings, you can grab her UID. Okay, so I put in UID, and I can press Authenticate. And this will basically make it so I am impersonating. And then, here, I can simulate different read or write rules. Write rules allow you to also specify some data that you tring to write. So, for example, if you wanted to test that rule that you just created, you could find a shopping list that is shared on, another list that she's the owner of, and finally a list that she has nothing to do with, and make sure that they all give the correct responses. So, for example, I'm going to get a shopping list that is shared on. So over here I'm looking at lists. Okay, here's one that she shared on, and it has the name K7J0. So I'll go over here to shopping list items, go to list K7J0, and then I'll go ahead and open that link in the other tab. I'll copy this location, and then over here in the simulator I can put that location that I just copied here. So basically, I'm now doing a simulated read for shopping list items for that list that she was shared on. Okay, and I'm already authenticated as her. So, I could come down here, and I'm authenticated as. I'm trying to read at this list that she's shared on. I can press simulate read, and it says here that the read is allowed. It even goes through each of the rules of these different steps. So you get a lot of output information and it will tell you, actually, if there are multiple rules along the path, which one it passes and which one it fails. So it's very useful. And so, similarly, I can take a list that she's not a part of, which she's not a part of this list. And I can simulate a read. And it would show that the read was denied, and point out which of these rules was false. Finally, Bolt could be a pretty helpful tool for writing rules, including read and write rules. As I mentioned, checking whether a user is shared on the list, or the owner of a list, is a fairly common rule. You've also probably seen that it's a little bit long to write. Bolt allows you to write functions, and then use those functions in different places. And this is, essentially, gives you a pretty easy way to make fairly similar rules in a bunch of different parts of the rule stock. So here's a quick example of a function in Bolt, and I'm not going to go over the semantics of all the [INAUDIBLE] to some of the bolt documentation for that. But, basically, it's doing the look up in that UID mappings table to get you the encoded email. And here's another function, which when passed in a ListID parameter, it goes into the owner mappings node and gets you back the owner email for that list. And here's yet another function which combines these two other functions to get your encoded email and compare it to the email of a list. So, you might write up a bunch of functions in Bolt, and then in your paths part of your Bolt file, you can write something like this. And what this rule is basically doing is saying, for a list name in a specific shopping list, the owner of that shopping list is the only one who can change the list name. And while he had to write all these functions, you can now use this owner function in as many places as you want. So there might be ten places in the app that you want to check for ownership. All you have to do now is write this isOwner function call. A full explanation of writing functions in Bolt is accessible in the instructor notes, but hopefully this is enough to prove to you that using Bolt might be a good idea. So now that you know the different options for troubleshooting and debugging your rules, do you think that you could write the rest of the read, write, and validate rules that I'm giving you in the spec right now? So the developer and I have written all of these rules. Good job by the way, and the rules are in the app. Well that's a load off my shoulders while I get packed. Wait up. You didn't let me finish my sentence. All of your hulabaloo about security has me paranoid. You're welcome. Mm. Okay. Okay. I guess it is my fault you're on this security kick. What's the problem? Here I'll walk you through it. Our decision to use email as the key for the user is causing a lot of issues. This boils down to the fact that the only secure and verified method for knowing who a person is in the security rules, is using the off dot UID. You don't automatically have any sort of email associated with the account. And this is of course why we made our mapping node from UID to email. Unfortunately, this connection here is a very hard thing to secure. Let me walk you through an example. So, we have our hacker here. She has no sort of special permissions to access our Firebase app. But she is JavaScript and Firebase savvy, so she could execute some arbitrary JavaScript code on our app. And she could write pretty much any JavaScript code that she likes as long as our database rules permit her to either do the read or the right. So let's take a look at the rules that we have right now for the UID mapping node. Our rules say that anyone logged in can read a single UID from the UID mappings node and if you are the user who's associated with that node, you can write data to it. As long as you're adding data for the first time. And we further have a validate rule just to make sure that the value is in the form of the encoded email. Okay. So the first thing that our hacker could do is execute a create account command. The first issue that I'm seeing here is that since she's doing this outside of our Android app. She could basically bypass that whole nice reset password logon flow that we have. So there's nothing that's really forcing her to prove that she actually owns the email that she claims that she owns. But she calls this create user command. And this should work. The Firebase backend will return to her a you UID. So now she has a UID that she has legitimate access to. So, here's a sample of a UID mappings table, and the question is, is there anything in the rules that stops the hacker from making an entry like this? Basically an entry where she uses the legitimate UID that she got for herself and then associates it with some email such as my email. No I guess not. After all the only rule is that they're adding an entry associate with their own user and that's a new entry. So yes, that seems bad, but what does it mean for the app? It means terrible, terrible things. Here, let's take a look at the database. Literally every rule trusts that the UID mapping tells you what email the UID is associated with. So if we can hack that mapping it essentially gives our hacker complete access to all of my shopping lists. And that's a pretty major issue. So again, issue number one is that there's not really a real way to enforce our reset login flow if somebody is executing code outside of the Shopping List plus plus Android app. And issue number two is that with just a little bit of JavaScript code a hacker could easily impersonate another user. And that's because our UID mappings table is currently insecure and it's actually pretty tricky or potentially impossible to secure in our security rules. And you're launching version .5 when? In a week. [SOUND] Sweet Nexus that's my ride to the airport. Okay, I'll tell you what. I think I can ask Puff to chat with you. He's actually in the SF office today and might be able to swing by your office. Well, that's actually incredibly convenient. And my cribbage match got rescheduled so, awesome. Well then I'll tell him to take the company. Two person man experimental flying electric vehicle. Excellent. Thanks JP and safe travels. Hey there, I'm sitting with Puff, and he is a Firebase engineer at Google who will hopefully be able to help me with a security issue that I'm having with my app. Let's try. Yes, so let me explain a little bit about what's going on. So I basically have two issues that are very interconnected, and they all boil down to the fact that I'm using the user's e-mail as basically in place of their uid. So the first thing that we do in the app is when they sign up with an e-mail and password. I have this really nice flow where I basically use Firebase's reset password functionality to make sure that the user actually owns the e-mail that they say that they do. But I realized when I was writing the security rules, that if somebody isn't using my client app, and they're instead either just writing their own JavaScript or using a badly made app of some other variety, that they could get around this flow that I have, this really nice flow that I've set up. So I realize there's no way to really trust that the user owns the email that they said they did. And that on top of that, I've got the email basically everywhere in the security rules. And I just don't know how secure that is, how to make that secure in the security rules. So you are a security rules guru. Can you help me? That sounds to like a good challenge. Okay, let's take it one step at a time. Okay [LAUGH]. So the first thing is indeed your e-mail verification flow, right? Because you are using Firebase's reset password flow, which is great and it's a great use of that flow in your Android app. But the problem that you run into now is thhat since the code runs on the user's phone in their Android app, you have to trust the user to write back their e-mail address into the database. And that is where you now have a security problem is that correct? Yes, I mean if they're using the app, things should be fine, but if they're not using the app, if they just write their own JavaScript. Exactly, so and this is what we see very, very often with developers that are using Firebase. You want to trust that it's your code modifying the database. But there's really, since Firebase is a cloud-based database, there is no way to be guaranteed that it's your code that's writing. The only thing you know is which user is writing to that database. And that's what you see with the Android app, right? You can verify that it's the user that signed into the Android app that is writing the e-mail address. And you can do the same, no matter if they wrote their own Android app or even if they were using a JavaScript client. You can verify that it's that user that's writing the email address. What you can even validate is that what they're writing is an email address. You can validate that there's a at in there, right. You can validate the value. But you cannot verify that it's actually the correct email address. That that's where you're essentially losing the security battle. Yeah, I mean we're doing that type of stuff for validating that it looks like an e-mail address. So basically what I'm hearing is that it is either very hard or impossible to do this kind of stuff on the client side or with the security rules. Is that true? Yeah, the problem indeed is that you must verify the e-mail address in an environment that you trust. And you should not trust the user's Android phone. So the only option there is actually to take the same flow that you have on the phone and move it to a trusted environment. And typically then you think of a server, right, where you essentially take the same flow, and you run through it. So the user, right, you sent them an email with a password reset type thing in there. Essentially a shared secret. And they can only validate that they own that e-mail address by typing that secret code into some interface that you defined. The flow is exactly what you do today. The difference is that it now runs on an environment that you can trust, and that means that it runs under somebody else's identity. So that's also how you secure this flow in the security rules, is that you verify that it's written from a trusted identity and not from just the user that is running the app on his Android phone. So I really like what you're saying that basically the flow itself doesn't have to change, we can probably use at least similar code to what we already have. The thing that makes me nervous is when you say a server. So how sort of hheavyweight are we talking about? What would I need to do to set up something like this? Yeah, and this is a very common question we get them on firebase, as soon as we mention Running server code. This is not your typical infrastructure server. This is essentially a trusted device that runs to same type of code that you would run on the Android phone or on a web page, but it's now runs in a trusted environment. So you could run this, I always say that a lot of my maintenance scripts run in JSFiddles. I'm not saying you should do that. But since I don't myself run, these are for my own research type databases, since DRs are not really production. I just run to maintenance whenever I feel like it. But it is trusted, because only I have access to these scripts. So only I can run them. Just like that you could run them on a small Google Compute Engine instance, for example, or on an EC2 instance. And it can really be like this smallest one you that you can get there because you don't need to do a lot of work. Or if you really want to, you could even run it on your own Android phone. You'd have the exact same code. It runs on your phone and since it doesn't run on my phone, you know that you can trust it. Interesting. I guess I just have to keep my Android phone on all the time. Yeah, that's the only thing you need to do. So I mean that doesn't sound like the scary type of server, I suppose. But we're kind of already in the thick of things. Are there any options for working without a server that could still get us where we want to go? Yeah. This is going to get more challenging. So this is where you need definitely to add some steps into the current flow. So right now the program that you have, seems to be that you trust that if two accounts have the same email address written into their profile data, that it's the same user. And that those are the accounts that you want to merge. And this is something that you you should not do, because right as we covered before, you cannot trust that the email address they write is an email address that they own. So you really must find another way to get these people to agree to merge these accounts. So a very common approach would be to actually put in a mutual agreements type of flow in there. So instead of merging the accounts like you do now, you actually require that a use proposes to merge an account. And that then, the account that they want to merge into has to accept that proposed merge. And since you already have your friends list, you sort of have the mechanism in place there to identify which account you want to merge. So you don't even have to rely on the email address there. You can also have them select the accounts that they want to merge into. Okay, so a lot of extra code on the client side is in there. Yes, definitely. So besides adding sort of bulk of the client side app, would this add any kind of bulk to the security rules themselves, or what would that look like? Yeah definitely. You need to write some security rules for it, like the place where these users meet up and agree to merge their accounts. And I've written some examples for that, to to essentially highlight how that would work. That's super helpful. I guess we'll take a look at those later, so So, all of this conversation just got me thinking. It would be so much simpler if the off variable just had the email embedded it, instead of limiting us to just having the UID of the provider. I've heard about custom tokens, not really sure what they are. Can I use that to my advantage in some way? Yeah, that would solve a lot of this problem. Cool. Yeah, if only I had told you that sooner. [LAUGH] But, no, what you would do is you would need to mint a custom token, as it's called. And essentially, what that means is, we have all kinds of libraries that you can use on a trusted environment, so that you don't ude on the Android device of the user. But you can run them on pretty much any server environment or any other trusted environment. Essentially, you'd get to encode whatever information you want and you sign it with the secret of your fire base and you then use that as the off variable in your security rules. And that means that you can put any information you want in there. So if you've already verified the user's email address, for example, you can just put it in there and then in your security rules you can say auth.email and use it directly instead of having to load it from your mapping table. That actually sounds pretty awesome. Are there, so this seems like something that people probably do fairly commonly. Are there any sort of prepackaged or third-party options or options that you would suggest that already could get me up and running with creating custom tokens quickly. Yeah, definitely, so for custom tokens, typically if you have your own existing user table then you need to start making your own tokens. But if you want to integrate with all kinds of existing like social providers like to Google or Facebook but also, provider's firebase doesn't support like Linked In. And then you could choose Alt zero and date. Essentially, means the question taken for you and provide a lot more information to the author board that you can use. Okay. Cool. So basically what I'm hearing, is that I could run a tiny bit of server code on even my own Android phone, but will probably somewhere better than that. And then that would verify that the users are actually own the email addresses that they say that they own. And that I could use a service like auth zero to then attach that email address to the off token and easily use it throughout my rules. Yeah. Well Puff that sounds like a plan. So, thanks for taking the time to talk to us today, I'm sure you have important things to get to at Google. The funny thing is, that before we started talking I really was not a security believer, I didn't think it was that big of a deal. But what I'm realizing is that security is something that you need to be thinking about even at the stage that you're thinking about how your data is going to be organized, and it's super important to get right. So, thank you so much for showing me that. No, thanks for allowing me to explain this, because indeed security is very important with Firebase. Right when you start data modeling, as you say, you must also figure out how you want to secure the database. Because if you don't, you never know who you can trust in this world, do you? [SOUND] JP, how's Hawaii? What? I could hardly hear you over the sounds of the jungle. Let me go over to that tree. Okay, J.P. That's better. So how are you and the developer doing besides all the craziness with launching 0.5? Pretty good. I submitted Shopping List Plus Plus to the Abbie's like you suggested. We're a bit of a long shot what with Grocery Grabber having just released their next version, but you never know. That's awesome. And let's see, besides that, well we finished everything on the wire frames. Woo hoo. That's great to hear. Why don't you take me through everything you guys have done for old times sake? Sure thing. Shopping List Plus Plus is turning into a fully fledged experience, and it's all thanks to you, the developer. Starting with version 0.1, you made a very basic prototype that just read and wrote some data. In version 0.2, you flush this out more by incorporating FirebaseUI so that you could list out shopping lists and shopping list items. In version 0.3, you added user accounts as well as a bunch of functionality like letting others know that you're in the store shopping and marking that you've bought items. Version 0.4 might have been our most triumph moment when you overhaul the data structure to allow for shopping list sharing. You also added some pretty snazzy sorting features. In version 0.5, you added offline functionality so that the app caches data even when it's not on the screen. Also implemented a bunch of read, write and validation rules to make sure that our data is properly formed and that only the correct people have access to it. Nice, so I gotta ask, what about that big security flaw you talked about? Well, for the short term, I basically got another engineer to separate our password and email flow. But we'll be looking into incorporating a simplistic server, maybe the later version. Hey, Gregory and Walter are here, and they want to say hi. Dujippi! My friend. Hey. Hey guys, great to see all of you. Actually, I might need to sign off. I don't like the way that parakeet is looking at me. Okay, bye. Bye. Bye. Have fun. Well, that was an informative blast from the somewhat recent past. Man, I can't believe that just three months ago, I was sitting at a meeting with the Bay Area Shoppers Group. You've come a long way, and you've come a long way too. You now know how to read data into Firebase. You also know how to take that data and display it in real time in a Firebase app. Let's not forget users. You also know how to create authentication methods for email and another provider such as Google. And you've learned how to create firebase data schemas to avoid things like nesting data while also denormalizing your data. This really helps you grow and scale your apps. You've also learned how to filter and sort your data. Finally, we learned how to use Firebase's security rules language to make our apps status secure. That's a lot. That is a lot. You know what? I feel like you deserve this API as much as I do. Yeah but more than a cell phone duct taped to a cheap trophy, we hope you feel empowered to create your own apps in Firebase. Actually that reminds me, I have another venture that I wanted to talk to you about. And I can actually send over the spec right after we all take a well deserved rest, so yeah, let's go ahead and do that. Speaking of which, Holder's taking forever with that Instarito. Yeah, where is he? Where is he? Where is he? Where is he? Where is he? Where is he? Where is he? Where is he?