So you have this great idea for an app. It will sure become so popular, probably the entire world will download it and it will become a crucial technology in every person's everyday life. This thing is sure going to bring you fame and fortune. No, no, no, no, no. Hold up. Fame, yes. But fortune, the money, where's that going to come from? Didn't think of that. You're always raining on my parade. Fame without fortune. That will be terrible. What are we going to do? Take it easy. That's why we are here in the first place. We're going to look at AdMob, where you can get paid to show ads in your app. Hm, that would be great. How do we get started with that? We'll kick it off by looking at some monetization models. But first, shouldn't you properly introduce yourself to the audience, our students? What students? That's right, I'm so sorry. That was very rude of me. [COUGH] Honored student, welcome to the AdMob lesson. This one, Is all about the money. Okay, so to get started, let's look at some alternatives you have available to monetizing your app. And when we go through these alternatives, let's look at how easy it is to start making money using this alternative. How it supports a good business model where you can make long-term revenue, and finally, what value this monetization model provides to the user. So, let's start with our first alternative, paid downloads. This is where the user needs to pay in order to even download the app to the phone. So how about easy to launch for paid downloads? Well perhaps it's kind of obvious that this is very difficult to do. And you have to have an app where the user really knows the value of your app beforehand and is willing to pay for it. Compared to overall number of apps, there are very few that can do this. So a paid downloads monetization model is definitely not easy to launch. What about long-term revenue? Well, once the user has paid up front for the app, they don't expect to be charged anymore. So only using paid downloads will limit your revenue to the number of users downloading the app. So paid downloads has a limitation when it comes to sustaining long-term revenue. Then what about user value? A paid download definitely has a high use of value. After all, the user is willing to pay up front to get this app. So they really want it. All right, let's look at another alternative, subscription. This is where the user pays a certain amount regularly, for example, monthly. So is a subscription monetization model easy to launch? The answer is definitely not. Again, you're asking the user to pay up front, and even more, you're asking them to pay, for example, every month. It is a huge decision for the user to want to do this. So what about long-term revenue? Yes, spot on. The user will continue to pay for your app as long as it provides value. So you will continue to get revenue from all users of your app, not only at the time when they downloaded it. And what about user value? Same thing as for paid download. You have a user that is willing to make an up front financial commitment to use your app. So obviously, your app provides a very specific and high value to the user. And both these monetization models, paid downloads and subscription, can be configured in the Play store when you deploy your app. Okay, now let's look at displaying ads in your app. Is this monetization model easy to launch? Yes it is. In particular, if there is no charge for the app, users understand that you have to make money from something. What about long-term revenue? The answer is yes to this one too. As long as your app is used, you will be paid for displaying ads, so this supports a long term business model. What about user value? As it turns out, ads do provide great value to the user. As we will see, AdMob, the platform that we will look at in this course, is very good at serving ads which are relevant to the user. And ads which are relevant to you is a good thing. And now for the last alternative we will look at, in-app purchases enable you as a developer to advertise and sell digital goods right in your app. For example, they can mean new levels or items in a game. So is this model easy to launch? Yes, in-app purchases are very easy to launch. The user does not have to pay for anything up front. What about long-term revenue? Well since you can offer and engage the user with new digital goods all the time, in-app purchases have a great long-term revenue potential. Then what about user value? Well since the user is engaging with the app, and you control what to advertise and sell, it will be very relevant to the user, so great user value as well. All right, so those are some of the monetization alternatives available. And as you can see, ads and in-app purchases provides a great way to make money from your app. They are easy to launch, they provide great long-term revenues, and they align well with the user values. And in this lesson, we will be specifically be looking at displaying ads. All of the previous monetization models we looked at can of course be combined. Which combination of common monetization models do you consider to be most natural? Using ads together with in-app purchases. Having a subscription model together with in-app purchases. Using paid downloads, and combining it with in-app purchases. We're using paid downloads and combining it with subscriptions. Check all that apply. As it turns out, in-app purchases are combined very often with other monetization models. So therefore, ads and in-app purchases, subscription and in-app purchases, paid download and in-app purchases, are very often combined. However, combining paid download with a subscription based charging model is probably not that common. So, as I said before, in this class we will specifically look at displaying ads. So how can you display ads in an app? And perhaps the first question of all, where do ads come from? Well, ads normally come from companies out there that want to advertise. We call them the advertisers. And in addition to the classic ways to advertise like TV, commercial signs, or when you browse the Internet, the advertisers want to reach all the mobile users out there. Now how can they do that? While mobile users use apps and you as a developer creates these apps that the users use. So we have a great story here, we have the advertisers that wants to display ads, then we have you the developer that wants users to use your apps. But as we saw before, users are typically not willing to pay a lot of money for your apps.But what if we could connect the advertisers with your users, and the advertisers could pay you to show adds to the users? That would solve everything, but how can you get in touch with these advertisers? That's exactly what this lesson is all about, and the platform that enables this, is called AdMob. AdMob can retrieve ads from a huge number of advertisers. So when your app requests to display an ad, AdMob will select from all of these advertisers to get an ad to display. And this is a very complex flow, for example it needs to consider ad bidding, how much did advertisers pay to display the ad compared to other advertisers. Ad displaying how many times has an ad been shown. And spending caps, how much is an advertiser willing to spend on displaying ads this month. But fortunately, you don't need to think about any those thing as an app developer, because AdMob is hiding all this complexity for you. AdMob will select the ad that should be displayed in your app. You only need to use a simple API that we 're going to look at, and then it will do all the magic to retrieve an ad from the advertisers that makes sense in your app. Time for a quiz. Which of the following statements are true? Advertisers communicate directly with mobile users, AdMob sends ads to apps, and apps display ads to users. Check all that apply. Let's look at the answers. What about advertisers communicate directly with mobile users? This is not correct. The apps communicate directly with the mobile users, not the advertisers. What about AdMob communicates with advertisers? This is correct. AdMob is the platform that retrieves the ads from the advertisers. What about AdMob sends ads to apps? This is also correct. Apps are asking AdMob for an ad to display. What about apps display ads to users? This is also correct. You're the app developer and you are displaying the ads to the users of the app. All right, so let's now talk about the different types of ads that you can have in your ad, and what they look like. In this lesson, we will focus on the following types of ads, banner ads, and interstitial ads. Banner ads only covers a portion of the visible screen, so they can be shared with content displayed by your app. And if the user clicks on the ad the webpage will be opened that has more information about the ad. Banner ads can either be text or an image, like the one you see here. Interstitial ads on the other hand, will cover the entire screen. That makes it really important to decide when to show an interstitial ad since your app can not display anything while the interstitial ad is being displayed. Interstitial ads are perfect when there's a natural break in your ad. For example, between levels of a game. In addition, to text an image ads, interstitial ads can also show video content. These two types of ads, banner ads and interstitial ads, are the ones that we will look at in this lesson. And although this lesson will focus on banner and interstitial ads, there is one more ad type called native ads. And as of May, 2015, native ads are still in beta. Native ads give you much more freedom to customize the look and feel of the ad. This is accomplished using two different templates. App install native Ads which can drive app installations by advertising the app. And content native ads which allows for a more generic combination of text and images that covers a broader scope. But in this lesson we will focus on banner ads and interstitial ads. So let's look into more details. So as you can imagine, there are different situations where you use banner ads and interstitial ads. Since banner ads just covers a portion of the screen, it allows the user to engage with your app and see the ad at the same time, while interstitial ads take over the entire screen, so the user can't see anything except the ad. How do we make money out of this? I was just coming to that. As an app developer you can earn money whenever you display an ad in your app to a user. Or if the user clicks on the ad. So this is the way ads can help you earn money. And although, it sounds very easy, you have to remember that you need to create an awesome app, so you have a big enough user base looking and engaging with the ads. So, let's look at the app that we will build in this lesson. It will have three activities. The main launcher activity you see here, which has two buttons, the banner ad and the interstitial ad buttons. Each of these buttons will bring you to a separate activity, showing a banner ad and an interstitial ad. So when I press on the banner ad button, you will see a banner ad being displayed onscreen. And we have this entire area above to display your app contents. I can also click on the ad. And you see that we navigate off our app to see more information about the ad. And we can also go back and continue to interact with our app. And when we are clicking around here, you can see toast messages appear on the screen. These are messages that our app will generate so you can see how the app interacts with the add and also note that the banner acts as text banner because this is a test ad. And what I will tell you now is very important, so pay attention. When we are developing our app, we will use test ads because advertisers do not and should not have to pay for real ads while you are developing. Using real ads during development is a violation against the terms and conditions and it can result in your accounts being banned. So this is really, really important. Now, let's go back and look at the other parts of the app. We can also click on the interstitial app button. And that brings us to another activity with two buttons here. So we talked about, interstitial ads use the entire screen when they are displayed and they also support video content. Therefore, we first load the interstitial ads and after they've been loaded, we can display them. So this button here will load an interstitial ad. You can see that it's loaded and now we have the option to show the ad. So we press on this show button and here, you can see the ad come up. And again, when developing our app, we use test ads. And that's what you see here, a test interstitial ad. And as with banner ads, we can click on the ad which will bring us to the content and then we can go back. All right, so that's the app we're going to build. So let's get right to it and do some coding. So let's get you started building an app that can show ads. Some of these steps we assume you are familiar with since you should have taken the location lesson before this one. So in Android Studio, I want you to do the following things, create a project with a blank activity, add the metadata com.google.android.gms.version to the manifest, add the dependencies to your build.gradle file. And also add the following permissions to the manifest, android.permission.INTERNET and android.permission.access_network_st- ate". The Internet permission is required since we're going to fetch ads from the Internet. And the access network state allows Admob to check if an Internet connection is available before trying to fetch the ad and check here when you're done. So, let's look at the app that we will build in this lesson. It will have three activities. The main launcher activity you see here, which has two buttons, the banner ad and the interstitial ad buttons. Each of these buttons will bring you to a separate activity, showing a banner ad and an interstitial ad. So when I press on the banner ad button, you will see a banner ad being displayed onscreen. And we have this entire area above to display your app contents. I can also click on the ad. And you see that we navigate off our app to see more information about the ad. And we can also go back and continue to interact with our app. And when we are clicking around here, you can see toast messages appear on the screen. These are messages that our app will generate so you can see how the app interacts with the add and also note that the banner acts as text banner because this is a test ad. And what I will tell you now is very important, so pay attention. When we are developing our app, we will use test ads because advertisers do not and should not have to pay for real ads while you are developing. Using real ads during development is a violation against the terms and conditions and it can result in your accounts being banned. So this is really, really important. Now, let's go back and look at the other parts of the app. We can also click on the interstitial app button. And that brings us to another activity with two buttons here. So we talked about, interstitial ads use the entire screen when they are displayed and they also support video content. Therefore, we first load the interstitial ads and after they've been loaded, we can display them. So this button here will load an interstitial ad. You can see that it's loaded and now we have the option to show the ad. So we press on this show button and here, you can see the ad come up. And again, when developing our app, we use test ads. And that's what you see here, a test interstitial ad. And as with banner ads, we can click on the ad which will bring us to the content and then we can go back. All right, so that's the app we're going to build. So let's get right to it and do some coding. So let's get you started building an app that can show ads. Some of these steps we assume you are familiar with since you should have taken the location lesson before this one. So in Android Studio, I want you to do the following things, create a project with a blank activity, add the metadata com.google.android.gms.version to the manifest, add the dependencies to your build.gradle file. And also add the following permissions to the manifest, android.permission.INTERNET and android.permission.access_network_st- ate". The Internet permission is required since we're going to fetch ads from the Internet. And the access network state allows Admob to check if an Internet connection is available before trying to fetch the ad and check here when you're done. Now lets go into the specific things and implement a banner ad in our app. Here are the things we will do. In android manifest, we will add an activity called AdActivity. Then its time to add code to our Banner Activity to actually display a banner ad. Then, we will add our banner ad to banner activity. This involves adding a banner ad to our layout file and then adding code to display that ad. Okay, so let's start to look at how we add the AdActivity to our manifest file. So if we open the manifest file, this is how we add the AdActivity. So you got the name of the activity right here. And then you have another attribute called configChanges that you should set to the following string. So what is this activity doing? Because, as you can see, it is not an activity that we have created ourselves. This activity is used in banner ads to actually launch the ad viewing in case the user clicks on the ad. And it's used in interstitial ads to actually display the ad. So where we press the Show interstitial Button here. It is what makes this screen appear. All right, so that's how we add the AdActivity to the manifest file. Let's now look at how we add the banner ad to our layout file in Banner Activity. So if we open up the banner activity layout file, you can see that we've created the standard relative layout. And the thing that we've added to display a banner ad is this AdView element here. This is the definition of the banner ad that will appear in this relative layout. And as you can see, we have many standard android attributes here to control the layout. And then we also have two specific attributes here that controls the banner ad. First we have ads:adSize which controls the size of the ad. There are many alternatives you can specify for the size of the ad and you can look these up in the ad size class. We're going to use a constant called BANNER and then we have something called adUnitId here. So what is this? We'll adUnitId is the ID of an ad placement. So if we go back to this picture, the ad unit ID is something we define in the AdMob interface. So when our app is requesting an add using a specific ad unit ID, then AdMob will know which type of add to serve to your app. With an add unit ID, you can also specify the media type that the add should be in, if it should be an image, a text or a video clip. But wait a minute, you may say now. We haven't set up any account in AdMob yet, and we're not ready to display and get paid for real ads yet. We're just in development and testing phase right now. And that's correct. So before we show you how to move your app to production, we will be using a test ad unit ID. Let's go back to Android Studio. So here's our definition of the ad unit ID. It's set to this string here. And this particular adUnitId is an ad unit ID for banner ads that will serve test ads. So this is the string that you should use in your application now. And as you can see, I've actually not hard coded this string, but it's a string resource. So, in line with android best practices, I've defined this string resource over here in strings. Here it is. So now it's very important that you enter exactly what it says here. Otherwise this is not going to work. All right, let's go back to the layout file now. And now there's only one little thing left before we can start coding. Notice that these things don't have the usual android prefix. They have ads as the prefix. Well by default, the ad's name space is not included here so we also need to add this line up here. This line gets the ad:namespace into the layout file so you have to add that otherwise this won't compile. All right. That's it for the layout file. Let's now switch to Java and see how we code the banner ad activity. And you may be amazed how simple this code is. The first thing we need to do is declare this member here, which is an AdView. And after setting our layout, we retrieve this view using findViewById. We then create an AdRequest using a builder and finally we load the adRequest, into the view. That's it. With only those steps, we're able to write an app that talks to AdMob and gets us connected to a huge advertising network that are eager for you to show their ads and are willing to pay for it. So now it's your turn to do these things. Remember, add the AdActivity to the manifest file. Then, in the banner activity, add the banner ad view to the layout and then add the code to display the ad. Check here when you are finished. Good luck. Okay, so let's see what our app should look like with a banner ad. So here I've started the app, and I can now click on the banner ad button. And when I do that, you can see that the test banner ad is displayed at the bottom here. And remember, the reason why you see a test banner ad Is because we use to test banner ads unit id that we talked about. And if I click on the banner ad you'll see that it brings me to the details for the ad. And remember the reason this is happening is because we've added the ad activity to our manifest file. And of course I can go back to our app by clicking here. And that's it for our app so far, but let's take this one step further and actually hook into the different activities that can be triggered when you use ads in your app. Let's look at add listener. Okay, so now when we have started with our first ad app, let's look at the AdListener abstract class. AdListener provides you with information about the ad loading process and how your app and user interact with the ad. It has the following methods, onAdFailedToLoad, which is called when there is a problem loading the ad. This method also takes the error code as an argument. And these are the ERROR_ constants in the AdRequest class. Then we have onAdOpened, which is called when the user clicked on the ad. onAdLeftApplication is called when the ad opens another app, for example, a browser. And finally, onAdClosed, which is called when the user is about to return to your application after clicking on an ad. So by extending this class and overloading these methods, you can get callbacks for all of these different events. And once you've implemented your adListener class, it's very easy to add it to your view. Simply call addListener before you do loadAd. And that will now be your task, to add an addListener to your app. Here is what you should do. Create a class calls ToastListener that extends the AdListener. Overload the AdListener methods and display an Android Toast message for each of them. If you don't know what an Android Toast message is, please check out the Android documentation. Also implement the method called getErrorReason. This method should return a human readable string based on the error code received in onAdFailedToLoad. And finally, set an instance of ToastListener in your AdView. Check here when you're done. Okay, so let's look at the solution. First of all, you can see that I created a ToastAdListener class here. And if we open up this file, you see the ToastAdListener extends the base class AdListener. Then you can see we have a ToastAdListener that takes a Context as an argument because this Context object would be required later on when we send the Toasts. Then we have our implementation of the AdListener methods. onAdLoaded, sending a Toast with the message onAdLoaded. onAdOpen, sending a Toast with the message onAdOpened. onAdClosed which sends a Toast with the message onAdClosed. onAdLeftApplication, also sending a Toast with this message. And then the onAdFailedToLoad, that takes an errorCode as the argument. And we're performing a switch on this errorCode to see what the error actually was. And for each of the error cases, you can see that we assigned a human readable string to the field mErrorReason. And, at the end of the switch, you can see that we're also sending a toast message with the onAdFailedToLoad plus the reason in parenthesis. And finally, for this class, we create the getErrorReason method that returns the error reason. Now, let's see how we can add this adListener to our view. So, we go to BannerActivity. And you can see here that before we build a request and we load the ad, we're doing setAdListener on our View object with an instance of our newly created class ToastAdListener, passing the context as an argument. And that's how easy it is to get these callbacks. Let's check out the demo. So, let's look at this in our app. If I click on Banner Ad now, you can see onAdLoaded is shown on the screen at the same time the test banner is loaded. If I click on the test banner, you can see onAdOpened and onAdLeftApplications are being displayed, because the ad was opened and we left our app to display the ad. I can now go back to our app, and you see, onAdClosed is called. Let's see what happens if I turn the phone into flight mode. So I go over here to Settings, turn the phone into airplane mode, go back to our app. Now if I click on the banner ad, You can see onAd failed to load with Network Element being displayed. So all our callbacks are working fine. Okay, so now you're well on your way to use ads in your app. And the time has come to implement, an interstitial ad. So to implement the interstitial, here's what we'll do. We will implement the interstitial activity that will contain two buttons for the initial text, Load Interstitial and Interstitial Not Ready. The Load Interstitial button will have a call back method called loadInterstitial. When this method is called, we will disable the button and then change the takes to Loading Interstitial. The other button will have a property in interstitial activity called mShowButton. It's callback method will be showInterstitial. And for the first part of this we will leave that implementation empty. As you can see, when the activity is loaded, this button is disabled. Therefore, we will set it to disabled in onCreate. And finally for this first step, we will create a string resource called interstitial_ad_unit_id. This string resource we will set to the following value. And as you may have guessed, this is the test ad unit ID for interstitial ads. So let's look in more detail how these things are implemented. So we're going to create two buttons. One with the text load interstitial, and one with the text interstitial not ready. Let's first look at the layout file where these are defined. So this is going to be in the interstitial activity. So we open the activity_interstitial layout file here. Here you can see a linear layout that has two buttons. The first button is our load button. It has the text Load Interstitial. And when we click on the button the loadInterstitial method will be called. The second button is the one showing Interstitial Not Ready. And when this button is called, the showInterstitial method will be called. And as you can see, I haven't really hard coded the text here. These are actually string resources that we'll define in our string resource file. So if we look at the definition of these constants, we go into our Strings resource file. The interstitial_load constant is set to Load Interstitial. The interstitial_not_ready constant is set to Interstitial Not Ready. I've also defined a constant called interstitial_loading that I set to Loading Interstitial. We'll use that later in our code. Here you can also see that we have defined the interstitial_ad_unit_id. This will be the ad unit id that we use for our interstitial ad. And as you can see, I've hard coded it to this string here, which is the string you can use to display test interstitial ads. Similar to this constant up here which is the test ad unit id for banner ads. All right, so now when we have our layout file in order, lets look at the actual code. So we go into the interstitial activity java file. So first of all you can see that we've added a member, mShowButton. And in onCreate we call our parent's onCreate. Then, we set the content view to the layout file of the interstitial activity, the one we just looked at. We find the button using, findViewById, providing the showButton in the layout file as an argument. And then we disable this button. When the Load Interstitial button is clicked, we, again, disable the show button. And then we change its text to Loading Interstitial. And, as you can see, this text is also something we've defined in our resource file, the interstitial_loading resource we just looked at. So we get this string resource using getResources and getString. And for now the show interstitial callback will be empty. We will add code to this callback later, but as you can see, this callback can't even be called right now because this button is always disabled. So here is a demonstration of the skeleton app that was just created. So here is our main window, and if I click on the Interstitial Ad button, I will launch the Interstitial Ad activity. You can now see that we have the two buttons here, Load Interstitial and Interstitial Not Ready. The Interstitial Not Ready button is our mShowButton member of the Interstitial activity. And as you can see, this is disabled since we disabled it in our code. Now, when I click on Load Interstitial, you'll see that the text of this button changes to Loading Interstitial. Now it's your turn to implement this. Let's see what we did. We created two buttons in the layout file of InterstitialActivity, Load Interstitial and Interstitial Not Ready. We defined a callback for Load Interstitial to be loadInterstitial. And in this callback we disable the button Interstitial Not Ready, and we change the text of Interstitial Not Ready to Loading Interstitial. To be able to disable and change the text of this button programmatically, we need to define it as a Property or a member of our InterstitialActivity class. This member had the name mShowButton. We define the callback for this button to be showInterstitial. And for now, we left the implementation of this callback empty. We also disable this button in onCreate. And finally, we defined the interstitial_ad_unit_id to be this value in our string resource file. And remember, this value is to test ad unit ID for interstitial ads. Now it's your turn to do all of these things. And check here when you're finished. All right, before we go into the code of displaying an Interstitial Ad, let's discuss this a little bit. Because there are two important things to think about with Interstitial Ads. The first one, is about the format of an Interstitial Ad. As we know, the Interstitial Ad consumes the entire screen of the device. Therefore, it's important not to interrupt the user while they are engaging with your app. So the first important things to think about, is to display Interstitial Ads with our natural breaks in your app, for example, between levels in a game. The second important thing with Interstitial Ads is to prepare the loading of the ad before showing it. Why is this important? Well, loading an Interstitial Ad can take time, in particular, if the network is slow. When the time has come to display an Interstitial Ad, you don't want the user to sit there and wait for it to load, you want it to be displayed immediately. Therefore, we load it in advance. We prepare the loading before we're showing the ad. So how do we do that. Well, let's start by looking at the class Interstitial Ad. This is the class we use to load and show an Interstitial Ad. So it has a method called loadAd. But this method is just requesting the ad to be loaded and to avoid blocking the UI thread, it will return immediately before the ad has been loaded. So how do we know when the ad has been loaded? By setting an AdListener, we can overload to onAdLoaded method. So when the Interstitial Ad has finished loading, this method will be called, and we can then proceed to call show on the Interstitial Ad. So, this is the flow that we will implement in our app. You should also know that Interstitial Ad has a method called isLoaded. So if you're not interested in knowing exactly when the ad has been loaded, then you could simply call loadAd. And when the time has come to show the ad, you check if the ad has been loaded. If it has been loaded, then you call the show method. Otherwise, you do not show the ad at all. Now let's check out the code to implement this flow. Let's open up the InterstitialActivity Java file. The first thing we've done here is to add an InterstitialAd field called mInterstital, there are no changes to the onCreate method. So let's go and look at the loadInsterstitial method. This code should already be there because we set it in the previous exercise. So let's look at the other code. First, we're creating an instance of the InterstatialAd. Then, we're setting the AdUnitId. And we set it to this string that will return test InterstitialAds. And this string, we defined in our resource string file, so we have to get it using the getResources().getString and then the resource ID. And now comes the flow that we talked about. Here, you can see that we're setting the listener for the InterstitialAd. Let's talk about this in a little while. But we're setting a listener here and then the execution drops down here. So now, you can see, we're creating an AdRequest using the builder. And then we're calling the loadAd method on our InterstitialAd instance. Providing the AdRequest as an argument, and as we saw before, this method will start the ad loading process, but it will return immediately before the ad has been loaded. That's where our listener comes into play, and as you can see, we're creating an anonymous class here based on our ToastAdListener class. And as you can see, we're overloading the onAdLoaded method. So since we're setting the listener here, this method will be called when the ad has completed loading. So we call our parent method that will display the toast message, since that is what we defined in the ToastAdListener class. And then we set the text of our disable button to Show Interstitial. And we also enabled that button. That means that the user can now press this button. And when that happens, the showInterstitial callback method will be called. So what are we doing is showInterstitial. Well, with simple check if the Interstitial Ad has been loaded, and this may seem like an unnecessary check, since we know the ad has been loaded since onAdLoaded was called. But we're doing it any how. And then the time has come to actually show the Interstitial Ad, and when this happens, the ad will actually be displayed in full screen mode. And for the button, we go back to a previous state, setting the text Interstitial Not Ready and then disabling it. And finally, going back to our listener. If the ad could not be loaded, the onAdFailedToLoad method will be called. In that case, again, we show the toast message and then we set the ErrorReason to the text of the button. That's it, that's the code we have to implement the Interstitial Ad. So let's look at our app now when we've implemented interstitial ads. So if we click on Interstitial Ad here, you can see that we have two buttons here now, Load Interstitial, Interstitial Not Ready, and Interstitial Not Ready is disabled. Once I click on Load Interstitial, the text of this button should change, we should get an onAdLoaded() callback. And once the interstitial is loaded, the text of this button should change to Show Interstitial, and it should be enabled, so let's try that out. So I click Load Interstitial here, title changes, onAdLoaded(), is called, Show Interstitial is now enabled. All right, so that works. Now if I press Show Interstitial, you can see onAdOpened() is called and we can see our interstitial ad. And if I click on it, onAdLeftApplication(), and we get into the details of the interstitial. Can go back, close the interstitial, the ad is closed, and now you see we're back to the original state. So what if I disable network connectivity here? So now we're in flight mode and pressing Load Interstitial should fail. So I press Load Interstitial, you see onAdFailedToLoad, so this is the callback with the reason for the error. And you can also see that we've displayed the error reason here and the button is disabled. All right, so everything works. All right, so now it's your turn to implement an interstitial ad. Here's a check list so you can keep track of all the things you need to do. First of all in the load interstitial method, I want you to create an interstitial ad object and assign it to the member of the class. Then set the ad unit id to the test interstitial ad unit id that we just looked at. Create an ad listener that inherits from toast listener and overloads the following methods. When onAdLoaded is called, the show button should be enabled. And when onAdFailedToLoad is called, there should be an error message, and the button should remain disabled. Then create an AdRequest and load the interstitial ad. For the showInterstitial method check to confirm that the ad is loaded and then show it. Then reset the button by disabling it and setting the text to loading interstitial again. Check this box when you are finished. So now it's time to look at how you can show real ads and see how much you can earn from them. This is done by creating an AdMob account. Let's go back to the following picture. So what we'll see in this section is how to create real ad unit ID that are associated with real ads from advertisers. And that when you use them, you will actually load these real ads. So let's look at what we'll do. First of all, I'll show you how to create an AdMob Account. Then we'll look at how to add an app to this account and then we'll see how to create Real Ad Unit IDs. So this will be similar to the test ad unit IDs from the perspective of syntax. But they will actually be tied to real ads created by real advertisers. And all of these things we will do from the AdMob web interface. Let's start by looking at creating an AdMob account. So now we will look at the things involved when registering an AdMob account. This type of account is needed when you show real ads, but it's not required during test and development, as we've talked about before. So this is the registration page for an AdMob account, and the first thing we want to do is to sign in with our Google account. So we sign in with our email address, and then our password. So now we're signed in with our Google account. The next thing we need to do is to provide the information for an AdSense and AdWords account. These are Google products that AdMob uses, so when you sign up for AdMob, you also need to sign up for these products. So for AdSense we will fill out the country and territory, and whether we want a individual or business account. And observe that this cannot be changed later on. The Payee name which must match a bank account name. This field you may not be able to change either, so it's important to get it right, and then the address And then we click Continue. Then we have the AdWords information. And here we only need to fill out the time zone and the billing currency. And then we click Continue. Now you need to read the program policies and the terms and conditions. I have already read these documents, so I can immediately accept these conditions. Now, we're ready to create our AdMob account. And then click Get Started. So this should now be your landing page. And as you can see, you now have a Publisher ID. This ID is a unique identifier for your AdMob account that you may use when you, for example, contact support. The next step is to monetize a new app. So we click on this button here. And that brings us to the page where you can add your app. So how does AdMob know about your app? It does so by searching in the Google Play store or in iTunes App Store. Yes, that means that before you can connect your app to AdMob, it must be available on one of these two outlets. So the Google user I registered the AdMob account with has already published an app to the Google play store. So I will search for it here. And as you can see, I've found the app here. And I will select this app and attach it to the AdMob account. Now it's time to create an ad unit Id. So let's start by creating a banner ad unit Id, by clicking on banner here. So let's look at the configuration options here. The first thing we have is the Ad type, which can either be text or an image or both. So in most cases, we want to select both, to have the highest probability of finding a matching ad. A text ad is typically a clickable title with one or two lines of text beneath it. You can actually see an example of it here. An image hack includes graphic. And you can specify multiple different sizes when you define that in the layout file. Then we have the refresh setting. This specify how often a new ad impression should be generated. You can select no refresh. Or a refresh rate between 30 and 120 seconds. The recommended is to use a refresh rate between 45 to 60 seconds. The text ad style allows you to customize how text ads are displayed. So they look good in your app. You can choose a standard layout but you can also customize it. With your choice of colors. I'll just choose Standard for now. And finally, we have the Ad unit name. This is just a name that helps you find the Ad unit ID later. Now we click Save. And as you can see, this gives you an ad unit ID. That you can use in your application to display real advertising. Let's look at creating an interstitial ad unit ID. So we go down and create another ad unit ID. This time we select interstitial. And first of all, for the ad type, you can see that we also support video here. That is because an interstitial ad covers the entire screen. The interstitial timeout defines the maximum number of seconds that we are willing to wait to receive the interstitial ad. If this time expires, then the onAdFailToLoad method will be called. And then we also give it an ad unit name and save it. So now we created an ad unit ID also also for an interstitial ad. Let's click Done now. And here we can see the ad units that we've created. There are also lots more options that you can set for ads. For example, which categories of ads you want to display. You can do that by going here, Allow & block ads. And you can see lots of different categories here, and whether your app allows that ad category to be displayed. But let's go back to the main page. And this is our dashboard. You can now see the estimated earnings for your app displaying ads. That's it for the basics of the AdMob interface. There are lots more options. For example, how you can promote your app, or analyze the behaviors of ads and users. But those are more advanced topics. But now, you know the basics of earning money to show ads in your app. Phew. That was quite a lot of steps involved. But it is actually not that complicated. Considering that you are now connected to a huge amount of advertisers out there. Who would love for you to display their ads and get paid for it. So do you get it now? Do you now understand how you can earn money from an app? Yeah! And the great thing is that we haven't even started coding our app yet. This way we can plan right from the start how to get ads in our app. Creating a great experience for our users. That's right. Designing your app from the start with ads in mind is the way to look at it. I got these ad things cold down now. I can't wait to get started! Hold on. Hold your horses. We've barely scratched the surface. There are so many more things to learn and use for ads. For example, analytics. So you can see how the user interacts with your ad. There is mediation, to interact with additional ad networks, and house ads, to cross promote your ads in our purchases. And then you can also. Okay, Okay. I understand, but don't confuse the student. Dear student, look at the instructor notes here for lots more information. And since there is so much more in ads we might just create the sequel lesson to cover those. Now, you're talking. And, you there student, have enough to get started. That's right. Happy coding. You're probably familiar with many of the services that are offered by Google. And if you develop applications your users likely are too. Perhaps they need to find a location or see what's interesting nearby. They're using Google Maps. Maybe you want to monetize your apps so that app usage is rewarded and your users, they don't have to pay upfront. Google Ads is your friend. As well as these, we've got lots of great APIs for you, storing files in the cloud with Google Drive, accessing Goggle Analytics. Signing into your application, integrating with Google Fit and much, much more. In this course, you'll learn how to use these services in your apps. You'll see how easily you have the power of Google at your fingertips, allowing you to build better apps. Before you can get started, let's take a look at getting the tools that you need. You'll be building your apps using Android Studio, which is available at no cost to you and can be downloaded from developer.android.com. If you want some help in setting it up, check out the Android Fundamentals course at the url below. To build applications that use Google Play services, you need a development environment. And to install the development environment there's two main things that you'd need. First, is Android studio. You can download Android studio from the developer.google.com site. When you install Android studio, you get the ability to use the Android SDK Manager, that you can see here. And using the Android SDK Manager, you should install the Google Play Services SDK. You'll see it as an item on the list, under extras, near the bottom of the screen. Make sure that you install the most recent version of this. I would also recommend that you take a look at the Android Fundamentals courses offered by Udacity. There are two of them at the moment, and I strongly recommend that you at least take the first. And it's really not a bad idea to take the second as well. These will give you a head start in Android development and teach you many of the concepts that we'll be covering in this course. Here you can see that I'm running a very simple app that I've called LocationLesson1. You build this application using Location Services and the techniques that you'll use for building this application can be used across many of the different services that you'll learn in this course. So, how did we get here and how did we build this? Let's take a quick look. So, to build an app like this one for location services and many of the other services that you'll be encountering in this course, you're going to do the following steps. First of all, the easiest way to get started is to create a new app using a Blank Activity in Android Studio. Once you've done this, you'll edit the build.gradle to add the services libraries. You'll using something like this, but the version number may change. Then, you'll edit AndroidManifest.xml, to tell your application that you're using these services libraries, and the particular version that you're using. When you put this value, integer Google Play services version. When you do a gradle sync, the correct version number will be put in for you. So it's good just to use this string. And then finally, in AndroidManifest.xml you're probably going to be adding a bunch of permissions as well. In this case I was doing location so you see I set users permission for access_fine_location. Depending on the activity or depending on the type of application that you're building, you'll be putting different permissions in here. When building an app that uses the Google services, you'll generally use an Asynchronous Programing Model that looks a little bit like this. In the onCreate of your activity, you create a Google API client. And then in the onStart of your activity, you connect that Google API client to the relevant APIs. In this case Location Services. In order to use this, you're going to need to override a number of different methods. One is OnConnectionFailed, which the services will call whenever the connection drops and you need to handle what to do. Generally just reconnecting. One is OnConnectionSuspended, which is very similar to OnConnectionFailed and will be called if the connection gets suspended but not necessarily broken. And you might want to cache some information. When you succeed in making a connection to Location Services, Location services calls back to OnConnected, telling you that you're now connected to the services. And in the case of something like location, you'll then create a LocationRequest. They had passed to Location Services to get your location details back. And it would call you back with OnLocationChanged, letting you know that your location request details have changed, and there's new location information available to you. And you'll get a Location object, which you can then use to write to your screen. So in the application that we just saw, that location object included a latitude, and I was able to update my screen and write the latitude to it. Now this programming model isn't just limited to location services. As I've said, many of the services that you'll be using during this course follow a very similar programming model to this. You're going to have an OnCreate and an OnStart. You're going to have a GoogleApiClient that you connect to the services that you want to use. And then you have to handle certain overrides. Usually, they'll be OnConnectionFailed, OnConnectionSuspended, OnConnected, and then an override that's specific to the services that you're using. In this case, it's OnLocationChanged for location services. Don't worry if you don't know all of these by now. Take the best guess that you can and by the time you finish this course, this will hopefully be second nature to you. So first of all, you'll create a blank that uses your desired API. What do you think that would be? Secondly, you extend your activity with the blank call backs. Which call backs do you think they would be? Third, you also extend your activity with the blank listener in case the connection fails. And then, finally, after connecting the blank, you'll wait for the blank callback. What do you think these will be I'll give you a clue. The answer in one and the beginning of four are the same. And which callback do you think you'll be waiting for when you connect to the services? Once you've done all of this, you'd then follow the requirements of your specific API. Fill out the blanks and then continue. So the correct answers are here. First of all, you'll create a Google API client that uses your desired API. In the example I showed earlier, I was using the location services API with a Google API client. With others, you may be doing login, you may be doing maps, you may be doing other things, but you'll still be using a GoogleApiClient for that. You'll next extend your activity with the ConnectionCallbacks. These are the heart of the asynchronous programming model, where the services can call you back whenever something important happens. You'll also need to extend your activity with the OnConnectionFailedListener. In case the connection fails, so that you can handle it gracefully. And then, finally, after connecting the GoogleApiClient that you created earlier on, you wait for the onConnected callback. Once you get the onConnected callback, you know that your ApiClient is connected to the services. And you're able to make the calls on those services. And then once you've done that, you can follow the requirements of your specific API. Like for example, as you saw earlier on, I was doing location work, so I also had an on location changed method, that was firing whenever the location changed, as a result of the location request. You'll see all of this in much more detail in the location services module, as well as all of the other modules. This sequence will be used in every app that you build and you'll want to be sure that you know it as you move through the rest of the class. Since this sequence is so important, take some time to think of a good way to remember these steps and then maybe go post in the forum about it. Also take some time to read what other people have said. You might find a methodology that works for you. Some APIs will also require you to set up credentials and access using the Google Developers Console. For example, in the maps course, you'll need to enable your map to use the maps API. And if you look here on the left, there's APIs & auth. When I select that, and I select APIs, and then I select enabled APIs, you can see the APIs that I've enabled. And one of the map apps that I build, I'm using here the Google Maps Android API version 2. You'll also need credentials for some of your apps. So for sign in maps, and some of the others, the system needs to know which apps are using which resources, and as a result credentials need to be enabled. And here you can see I've selected credentials. And here you can see I've generated an API key for the apps that I've built that are using Maps. As you need them, you'll be stepped through everything that you need to do on the Google Developer's Console in the lessons, but it's good to have a look at it. Go to console.developers.google.com and have a play around. You've now gotten everything you need to get started with building Android apps that use Google Services. The API's that you've installed, give you access to all of this functionality. And they give it to you in a consistent way. Remember that Google API client that you saw for accessing your location? It's the same object, and very similar code to what you'd use to access Google+ or Maps or Wallet or Drive. You can learn these in any order you like. But the most important thing is to get started and to get coding. So, you'll see just how easily you can harness all this goodness. You should go and take the location module first, because many of the concepts you'll need for the others are covered there. Let's go.