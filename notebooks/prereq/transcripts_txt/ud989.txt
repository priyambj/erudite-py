Welcome to the class where you get serious about web development. By the end of this course, your code will be professional, and professional code is what will get you your next job. You'll be able to build an organized application, both with or without an organizational JavaScript library or framework. You'll also be able to look at those libraries and figure out how to use them. And you'll understand why using libraries can be a good idea. So, what's the progression of this course? First, we'll build an application together the way we already know how. Then we'll look at some of the problems with what we know, and learn some techniques to solve those problems. Next, we'll move on to learning frameworks. And finally, we'll learn to pick up some code we've never seen before and how to tackle that otherwise scary process. The final project will be a neighborhood map. It'll be completely self-led and good enough to put in your portfolio for job interviews. Now, I want you to take your time with this course and projects. Don't rush. Together we'll be fundamentally changing the way you think about application development, so give yourself the space and time to learn it properly. And take some time also to embark on projects of your own outside of the class. Find some time to play. Now, this course will be challenging at points. So, if you're having a rough time at any point, it's not you. This is by design. You might feel scared, like I did when I first learned this, and it's normal to feel that way when you learn anything new. But you will get there. And your successes, well, your successes will be thrilling. Bask in them. Back in mid 2010, a video game researcher by the name of Ian Bogost, released a simple Facebook game, actually a satire of social games. In the game, you click on a picture of a cow every six hours, and he named it Cow Clicker. Surprisingly enough, the game took off and got legitimately popular. Now, when I was thinking about a project for this course, yes, this one that you're taking right now, I had a realization. Cow Clicker became viral, and cat pictures account for at least a quarter of the internet. In fact, it's widely known that everybody likes cat pictures. So why not combine them, I thought. And so, your first application will be Cat Clicker. Now your cat clicker application should have a picture of a cat, and a number that increments when you click the cat. Pretty simple, at least for the first version. You'll get an official spec sheet for the project in a moment. Now the next several exercises will be based around this Cat Clicker project. Although you could technically get by without actually doing the project, I strongly, strongly urge you to do it. Later in the lesson, you'll learn a scalable approach to building apps. And by building it your default way here and now, you'll get to compare this version of Cat Clicker to the final version once you're done with the course. That final version will be in a word, awesome. But it's always important to be able to see how far you've come. And besides, for the first iteration of this project, you won't be alone. I'm going to give Andy a call. He's a coworker of mine, and he will be doing this project with you. [SOUND]. Hello? Hey. How's it going Andy? Oh, hey, man. You taught yourself programming, right? Yeah. I started working at a few years ago, and I've actually used our courses to learn how to program. Makes sense. Would you be willing to build a version of Cat Clicker along with the student here? yeah, I can probably build Cat Clicker. I'm not sure how pretty it'll be. Nah. Do, don't worry about it. That's the whole point. By the end, you'll have a great tool set for working on these apps. [SOUND] Now, Andy will be doing this project with you. You may not feel 100% comfortable in JavaScript right now, and some of this may not still be super easy, but you can do it. Do give this a shot, and build it the best way you know how, and after you're done, we'll talk about the next steps. At the end of this self-driven exercise I'll show you my code and we can talk about some of the differences. Now that you've built Cat Clicker, I want you to reflect on a few things. Let me know in the boxes below, how hard was this for you and how do you feel about your code? And how many times did you click your cat? There are no right or wrong answers for this quiz. Mainly I just would like you to reflect on your experience so far. After you share your reflections, we'll talk to Andy and see how he's doing. Andy, how'd it go? It wasn't too bad. I got the cat clicker working. [LAUGH] It wasn't too bad? Yeah. Well okay, so what parts were more difficult for you? It wasn't bad at all. I mean, I was just, I'm just rusty with JavaScript. I hadn't used it in awhile. I'm used to Python syntax. Okay. I was forgetting to declare my variables. Forgetting semi colons. And, I'm still just not very fluent with, you know, manipulating the DOM through JavaScript. So, there's a lot of Google searches to just figure out how to do some pretty basic stuff. Cool, but you got it working, overall? I got it working, yep. My div, with the cat ID, increments its count, when you click on it. Awesome, good job. So, congratulations. You just wrote a program. Awesome. But it would never end there in reality. When writing software, it's very common for requirements to change. In fact, it's usually the case. Requirements can change because you got an idea while you were writing the application. They can change because you have a fickle manager. They can also change because the needs of your target audience have changed since you've started working on the project originally. Now, this course is ultimately about teaching you to write extensible and well organized code. Largely so you can react to those changes in the project requirements. Let's talk to a few other experts in software development, and see how often requirements change for them. Requirements change for every single project. In fact, almost every single meeting for a project leads to a requirements change. Requirements can change at any time. They can change weeks before the project, or they can change the night before it launches. We change requirements on the engineers all the time. Well at university, in engineers are actually responsible for defining their own requirements. But regardless of whoever is defining the requirements they keep changing all the time because the product keeps evolving. And the requirements change because we keep on discovering new ways of improving the user experience. And that leads to often changing specs and requirements for the product. Now things are changing for your project, and for Andy's too. [SOUND] I've got Andy on speed dial, number four. Hey Andy can you come down to my desk for a second? Great, thanks. [SOUND] Now, the project manager has changed the requirements in two different ways. First of all, there's not one cat anymore. Now there are two cats. Second of all, the cat name should be above the cat image. So how you implement that is completely up to you, but I would recommend avoiding the most naive of solutions. Don't just hardcode the cat name and the dom, or in the document. Instead, store that in a JavaScript variable, and then update the document. Hey Andy. Hey, what's up? So the project requirements have changed. Okay. Cat clicker duo. Ooh, let me guess. Two cats? Two cats. Can you do it? I didn't plan for that, but I think I could probably figure it out. Awesome. Nice work. Now, you should be done with Cat Clicker Duo with two cats in your program. Now let's take another minute to reflect on your experience. How hard was it this time? How do you feel about your code, and are you happy with your method for cat duplication. And how many times have you clicked your cat by now? Then we'll check in with Andy. Hey, Andy. How'd it go? It went okay. I have two cats and it's working, but the whole process was a little frustrating. Frustrating in what way? So you're not going to like this, but I. oh. Basically just copied and pasted all my code from, you know, the first cat, made a second cat. Had a cat one and a cat two. Account one and account two and all that sort of thing. It seems like a quick and easy method, right? It was quick, but it wasn't easy. Why? Wait, why not? So I forgot to change one of the ones to a two, and so when I clicked on one of the cats, it kept incrementing both of the cats, and that isn't the best, the best way to do things. I see. Now here's another question. If hypothetically, I were to ask you to scale this from two cats to say, five cats. What would you say? Like, does it, is it scalable? Part of me wants to say no. [LAUGH] I don't want to do that. [LAUGH]. But this method probably wouldn't, and I, obviously this method would not be the best way to do it. sure, it could work. I would probably want to find a better way to do it. That's probably a wise approach. Yeah. Now if I were hypothetically to ask you and Andy to do this, and scale up to five cats, there is one thing that you probably should be aware of, and that has to do with closures. When you're adding eventless centers to elements, several elements, in a closure inside of a loop, there's an easy trap you can fall into. Now, the next node is going to be a reading node. It's going to tell you information about when you might fall into that trap, and how to get out of it. As I hinted at in the last lesson, your boss really likes cats. They want even more cats. In fact, they want Cat Clicker Premium. Now obviously, you'll run out of screen space if you add too many more, so your boss wants you to build a list of cats on the side. And when you choose a cat from that list, the cat is displayed in the cat area. That will mean quite a few changes to your application. You'll need to find a way to build a list of cats. You'll need to add selection functionality to the list. You'll need to display the correct cat when the list items are clicked, and of course, you'll need to keep each cat's number separate and accurate. I'll provide you with an official spec sheet for the new application in a second. And my advice to you is the same. Try not to repeat yourself, and make sure that you choose some cute pictures of cats so they can comfort and console you if you feel frustrated. After this step, we'll go over the code together and we'll start talking about some useful organizational techniques for resolving some of the problems you're likely running into. Now, that last task may have been a bit harder than the previous ones. This will be our last requirements change, so let's take a few minutes to reflect on the difficulty of this last step. I have the same question as I have had before. How hard was this step for you? How do you feel about your code? And how many clicks do you think your cats have gotten? Additionally, I'd like you to reflect on your solution for this project. Are you happy with it? Are there problems that you can foresee with it? What would happen if I asked you for more changes? Does your code feel brittle or flexible? Simple or complicated? After this reflection, we'll start to get more serious and we'll talk about solutions. I'll reveal how I organized my code for the project, and we'll start moving towards becoming professionals in our code organizational techniques. If the previous exercises were difficult for you, it might be because you're code organization isn't ideal. Now, that's nothing to be ashamed of. Up until now, you've learned HTML, CSS, and JavaScript, and you've learned some pretty advanced features of JavaScript too, but one thing you may not have learned about is code organization. Hey Andy, so how'd it go this time? Pretty terribly. It probably took about ten times longer to get five cats working than it did for two. Which doesn't make a lot of sense. Oh that's rough. Yeah. I had a lot of divs, if that's, is that a good thing? [LAUGH] A lot of divs with cats and buttons and, you know, cat one, cat two, cat three. And I tried to, in the JavaScript file, iterate over all of those. And bind the buttons to the counters for the different cats, but everything kept, kept getting down to the very last cat. Mm. That was that closure issue we were talking about. It was. That was where the 10x time increase came from, was figuring that out. But I mean it's working. So, that's good. But, I, I, I don't want to keep making things this way. Story time. This reminds me of when I first started building things with wood. So, I went down to Home Depot. I bought some wood. I bought a hammer and a box of nails, and suddenly I could build things. I went crazy with it. I built all kinds of small things, occasionally hitting my finger, but generally, I was successful. Eventually though, hammers and nails didn't quite cut it, so I saved up some money and I upgraded. I bought a screw gun and some screws. I bought a chop saw. I even bought some of these. And I built all kinds of cool things with these tools, and the things I built were much better because my tools were better. Then I wanted to build an actual structure, like something I could stand on. And guess what? I didn't trust my own designs. I knew that if I took my methods from all those small projects and scaled them up, I'd build something that wouldn't hold my weight, which would be bad. Now, I didn't need to go out and buy new tools. I had everything I needed, everything physical at least. What I did need was some organizational guidance and some new building techniques. So, I spent some time experimenting. I discovered that if I separated out my sections of my project into different pieces that attach to each other, it'd be easier to build, potentially more stable, and much easier to change later. Then eventually, I Googled around and I got even better techniques that way, things that would have taken me a long time to figure out on my own. And this is exactly where you are right now. You have great tools. You know JavaScript. You know the features of the language. But you do need to learn better organizational techniques so your applications are stable and bug-free, cleanly written, they scale well and are extensible. Spaghetti code is easily avoidable once you know how to avoid it. First though, let's talk about the problem. Things get really messy when you connect things together. And an application is ultimately all about connecting pieces of code to each other. But if you connect all the pieces to all the other pieces, suddenly you can't move anything around anymore. Now, you may have noticed that I'm not at my desk. I don't have my computer. Everything is white. It's actually a little weird. That's because we're in concept land, and the whole point of concept land is to not think about code. So, sit back, relax, and let's just talk in concepts and metaphors for a moment. [SOUND] Here's the metaphor. Let's go back in time to the invention of the telephone. See, when there were only two telephones, things were pretty simple. The phones could connect directly to each other, and then we're done. Two telephones means one connection. Now let's add another. Now we have three phones and each phone still needs to connect to every other phone. That means three connections. Let's add another one. Now we have four phones, and each phone still needs to connect to every other phone. That's four phones and six connections. Now, this is a pretty shape here, but it's not very good if you have a bunch of wires all over the place. Let's add several more. With ten phones, we have a lot more connections. 45 connections, in fact. I'll tell you, this took me awhile to draw. So you can imagine what 11 phones, or 15 phones, or 20 phones, or 2,000 phones would be like. So here's a table of what we've learned so far. As it turns out, the number of connections is ultimately defined by the equation n times n minus 1, all over 2, where n is the number of phones. Now, if you're a math geek, this is related to n times n plus 1 over 2. But in this case, n is one less than the number of phones. So I've simplified to this equation here. So now that we know that, how many connections would a small town with a population of 2,000 have? That would be 1,999,000 connections. I'm not going to draw this one for you. So, how do we build this in reality? I'm sure you probably have a better solution in your head already. Let's make every phone connect to a hub. Now, how many connections do we need? Well, if you think about it, for every phone you have, it connects to one thing rather than n number of things. Let's take a look at our chart again. If we have two phones, our number of connections will be two. If we have three phones, our number of connections will be three. Four phones will be four. Ten will be ten. And 2,000 will be 2,000. As you can see, with two and with three phones, we end up actually doing better off or the same with our original direct connection method. But generally speaking, this shows you that connections are complexity. If you saw these two things on a graph, this one would go kind of like that. This one would linearly increase. So now we know that we should minimize our connections. It turns out software development is very similar, so let's take a look at that. Let's get back to the real world now. Now that we've talked about separating things out, let's talk about what separation of concerns specifically means for writing applications. We can separate our code into a few fundamentally different pieces. In this course, we'll refer to them as M, V, and O, model, view, and octopus. Octopus, you ask? [SOUND] Yes, we have Larry the octopus to help us out. Now, let me tell you a little bit about Larry. Now, Larry really dislikes disorganized code. Actually, Larry hates disorganized code so much that Larry has decided to do something about it. Larry separates our concerns. Now, what does that actually mean? Well, no matter what the size of the application, programmers like to organize everything in a few buckets. Let's talk about them one by one. First, the view. This is all the stuff the user sees and interacts with. That includes DOM elements, input elements, buttons, and images. Basically, this is the user's interface to your application, both for giving your application data and for reading data. Now, speaking of data, here in the model, this is where all of the data is stored. That includes data from the server and from the user. Now, the model and the view are connected, specifically by our octopus. [SOUND] Our octopus is what provides the separation of concerns that we so desperately need when we're building applications. Now, you can think of the octopus as the thing that holds things together, but also keeps them separate enough to allow changes in individual pieces without upsetting the rest. In other words, I can change my view here without disturbing my model. Or I can change the way I'm storing my data without disturbing my view over here. If you search around the web, you'll find all kinds of acronyms, like MVC, MVVM, MVP, and MV*. These stand for a Model View Controller, Model View vVew model, Model View Presenter, or Model View whatever. Fundamentally, the C, VM, P, and asterisk are all solving the same problem, separating our model from our view. Now, you'll see all kinds of discussions online about how different these all are from each other and in what ways. But all of those discussions are assuming you already know that they're basically the same thing. So, we'll worry about the differences later, and for now, we'll consider these all versions of the same thing, [SOUND] and we will name them Octopus. Let's say I wanted to build a calendar app, kind of like Google Calendar. Which of these parts of the application do you think would be considered part of the model? The array of calendar events in the application? The buttons for Day, Week, and Month? Or the render function for the calendar area? The array of calendar events is where the data is stored, so it's part of the model. The other two, the buttons and the render function, both belong to the view, since they're responsible for what the user actually sees and interacts with. Let's say I wanted to build a YouTube playlist app, it would let a user type in URL, and play the videos one, by one from this playlist for the user. Which part of these applications would be considered part of the view? Let's go through these one by one. The input is part of the view because the user uses it to interact with the application. The video-playing area is also part of the view because it's what the user sees. The array is not part of the view. It's part of the model since it's the data that the application is using. And our function here is part of the octopus. That's what ties the model and the view together. The view calls this function when a user types in a URL here and presses Enter. And the function adds a URL to the model, or data. Remember, the octopus' job is to connect the model and the view together. Now that we have the concepts down, let's go through some actual code. You can find a link to the repository that contains this application in the instructor notes. So here we have a pizza ordering application. You can click on this Add Pizza button here to add pizzas, and each pizza has its own unique number. We can also click any of these X buttons to remove the pizzas. And you'll notice that if we add a couple more pizzas, it starts off where we left off. Seven, eight. Now let's take a look at the actual code behind this. More specifically, the model that's driving it. Now before we dive into the JavaScript I'll just mention that we have an HTML file here and we've also got a style.css file right here. You can go through this code on your own if you'd like to figure out how it works, but it's relatively simple. Just some HTML dom nodes and some CSS selectors and properties. The JavaScript is where the heart of this application lies. We have var data. And if we scroll down we also have var octopus and var view. Let's take a look at the model up here. Now in this application the model is just called data. It doesn't necessarily have to be called model per se, but that's its function. And you can see that our model is just a simple object with a couple properties inside. It's got a property for the last ID of the pizza and an array of pizza objects. With such a simple example it may not seem obvious why we want to separate this out. But bear with me. [SOUND] Sometimes our model isn't so simple and we'll see examples of this in the near future. The view is a bit more complicated than the model in this application. It's an object, as you can see by this open bracket right here, and it has two methods, init and render. We call init to get things set up, and we call render to update our view. Now, the HTML is also part of the view, so I've opened up index.html. You can see we have a button here and an unordered list for all of our pizzas. There's also this script template down here, which is just a fancy word for some HTML that we're going to use again and again when we make the pizza objects. Let's hop back into our app.js. First, let's go over our init function here. Now, for the moment, I'll ask you not to get too mired in the details. We're really looking at the overarching organization of the application, okay? So, simplified and glossing over details, we're doing the following. First, we're adding an event listener for the button which runs the addPizza function. Then we're grabbing some things from the DOM and we're storing them to variables, so that way, we can use them in our next step. Then we're adding a click listener for the pizza list. And if we're clicking on a remove pizza button, we're running the function that figures out what we've clicked on, and then ultimately calls the removePizza function. And lastly, we're telling the view to render itself. So, speaking of rendering itself, what does that render function actually do? In a nutshell, it clears the pizza list entirely and re-renders all the visible pizzas. Not very smart or optimized, but it works just fine. So, clearing the pizza list, and here, getting the visible pizzas from our octopus, which we'll talk about later. And for each one of those pizzas, doing the following, filling in the template HTML with the pizza ID and then adding it to the pizza list in the DOM. So, this view here is not particularly smart. But it is separated out, and that's what's most important. All of our view logic is in one place, rather than scattered throughout our entire application. We'll see the ramifications of this in the next node. All right. So, we've talked about the model and the view, but you also may have noticed the octopus object floating around. Now, what the heck is it doing? Well, as we discussed before, the octopus is what is tying our model and our view together. Now, you may have noticed that the model and the view both never directly talk to each other, and that's by design. Our octopus is the only thing that connects them. I like to imagine the octopus as a sort of buffer, connecting the view in the model, but also letting them move more independently than if they were wired directly together. That means you can change how your app looks without messing up your model code, and vice versa. So, the octopus is doing things to help out our view and to help out our model. Let's go through those things. Our addPizza function gets called by the view and adds a pizza to the model. And lastly, tells the view to update itself. Our removePizza function is also called by the view whenever you click on one of the little x's. It figures out what pizza was clicked and it sets the clicked pizza's visibility to false. And once again, it calls view.render. You may notice these are the only two places that our data object, our model, gets mutated or changed. Once again, the view never changes the model directly, only the octopus. Now we've got two more functions to go. getVisiblePizzas is a function. It's almost like a tunnel that the view uses to get the data from the model. So rather than the view saying, hey model, what pizzas do we have? The model asks the octopus and the octopus goes and gets the pizzas. Now, why doesn't the view just do it directly? Well, there are two reasons. First of all, as we discussed before, it's very important to separate out your view and your model. If you don't, you end up with some pretty nasty code as your project gets bigger. But the second reason is that this getVisiblePizzas function doesn't just return the pizzas directly to the view. It actually filters them for us. It takes all the pizzas from the model and it filters them, and it only returns any pizzas where pizza.visible is true. So if we go back over here to our application and you add a whole bunch of pizzas and then you remove a bunch of them, the way the application works, is that 1, 2, 7, 16, and 17 in this case, these all exist in the model, but so do all of the other pizzas we ever made. That getVisiblePizzas function in the middle on the octopus is taking all of the pizzas and only giving the visible ones to our view. And lastly, we have our octopus.init. When you call that, it does all the necessary things to get our application up and running. In this case, the only thing it has to do is tell the view to initialize itself. So, once again, big picture, if you have your model and your view, your octopus is the thing that connects them to each other. They never talk directly. So all of these functions are different ways of getting between the model and the view. Now it's your turn. Let's move on to another more real-world example. Now, this right here is a groundbreaking new application called Udacity Retain. Aside from a snazzy name, it, it does have some pretty good organization when you look at the underlying code. So let's do just that. We have an HTML file, a CSS file, and a JavaScript file. If you look at the JavaScript file, we see a pretty similar organization in this app as we saw in our pizza application. Now, we just spent some time going over the pizza application together just a moment ago. So, go ahead and clone this repo and get it onto your local machine. Then take a look at it and try to figure out roughly how it's organized. You will see some similarities between the pizza app and this app here. Now, if you have a moment of disorientation, that's normal. Anytime I look at someone else's code for the first time, it takes me a bit to get my bearings. [SOUND] So don't worry if it takes you a few minutes to start understanding things. Feel free to comment things out and see what breaks. Add comments as you figure out what things do and notice the big picture. Does the model ever talk to the view directly? How about the view to the model? Now we're going to implement the new feature. The new feature is super simple. Right now, the notes go in chronological order from past to present. We want them in the reverse order, so the latest note appears first in the list. Where should we make this change? Does this belong in the model, the view, or the octopus? The change goes in the octopus for a few reasons. First off, we don't want to mess up the data that we already have. And second of all, we don't actually need to change the data itself. It's just the way we're getting the data from the model to the view. Now, why not the view; why not put this in the view? Well first of all, the view shouldn't pull things directly from the model. Remember, they shouldn't talk directly. So as long as we're going through the octopus, it makes sense to give the view only what it needs. Now that being said, technically you could put this functionality in the view. But for my model view octopus example, I'm going to leave it in the octopus. The octopus is where I want all of the real smarts to live in this organizational paradigm. Whereas the model and the view themselves, are relatively simple. Now if you use other organizational libraries, they all have different opinions about where exactly different functionalities should live. But in all of those cases, they're consistent and well thought out. So for MVO, we're going to keep all of the smart functionality and the filtering and everything, in the octopus I'm going to show you where I put my code. Over here in the octopus in getNotes, instead of returning model.getAllNotes, I'm going to instead return model.getAllNotes.reverse. So my octopus, when it passes all of my notes over to my view, it actually reverses it for the view. The view doesn't have to worry about it. Now, I would like you to try to implement another feature. We're going to add a date to every new note that we create, and we're going to display that date too. Now, let's just talk generally about how we're going to do that, and then I'll set you off to do it yourself. So first of all, we're going to need to store some kind of date when we make a new note. Now I'm going to open up the console because one great way to do this would be using Date.now. When you run Date.now, it returns a big number which represents this current moment in time. If I run it again, you'll see that the number has gotten a little bit bigger. So, that's how we store our date. We're going to need to put that inside of our addNewNote function. That's where it creates the object literal, which becomes our note. So, now we're not just storing content, we're going to store a date. So that changes our code so that way, it's storing a date every time we add a new note. We don't need to change the getNotes function because it just returns all of our notes, including their content and their date. And it reverses them for the view. And speaking of the view, that actually needs to change as well. Now that we're storing dates for our notes, we probably want to display that date as well. Now, you can add that in the HTML string down here that we're generating. I'd suggest putting it in an element with a class of note-date, so that way, the CSS that I included gets applied properly. Now, one last thing. Before when we were experimenting with this, we were creating notes that didn't have dates applied. So if you go back into your console here and you run localStorage.clear, it'll wipe away all the persistent storage. So when we press refresh, we don't have any notes anymore and all of our notes will then have that date property that you're adding. And now, I leave it to you. Go forth and add date stamps to your notes. I'll show you my implementation. First off, I'm using date.now, and I'm storing it to dateSubmitted in this object literal. This is what becomes our note. By the way, in case you're interested, that number is the number of milliseconds since January 1st,1970. Fun fact. Well anyway, this is simple enough. I'm just storing our current time into the dateSubmitted property. Now, I've also added something down here in the view. Down here in the view, I've added a little piece of functionality to the render function. When render is called, the date gets put into the HTML string. Now a little note about this thing here. I'm actually making a new date with that number, and then I'm converting it to a string. That ends up looking something like this. Now it's not the most beautiful, readable date, but you can go in and use some of the date methods to make it better if you'd like. But the coolest thing is, if you look back the amount of code hasn't really changed much at all. We just have this one new line in the view, and this one new line here where we create our notes. Now one quick sidenote about this being in the octopus. Strictly speaking, you can make the argument that this is kind of dataish. Maybe it should be in the model. And that's a totally legitimate argument. In fact, a lot of organizational paradigms and frameworks put this kind of a thing in the model itself. Now for simplicity in this particular example, I'm not doing that. I'm just creating an object literal right here, but later on in the course, you'll see some of the interesting and slightly more complicated ways that people form models. In future lessons, you can always come back to the examples we went over here and use them as inspiration or guidance. I'm really excited about this next lesson. Coming up, we will be implementing separation of concerns, for cat clicker. Doing it right. You'll experience the differences between your, previous spaghetti code implementation, and our new, well organized implementation. It'll feel really good, so let's do it. I'll see you in the next lesson. I'm sitting here with Mike Wales. He is one of our front end developers. How you doing? Good. So what are we talking about? We're talking about getting things with no context whatsoever. [LAUGH] Like this interview. This interview. Okay. So, have you ever been in a situation where someone has handed you a whole bunch a code, written in a framework you've never seen before? Okay. You've never seen this code itself before. Mm-hm. And you hardly know what it does. And they give you some task to do. Oh yeah, all the time. All the, really? [LAUGH] Yeah, it's pretty common. Tell me a little bit about the feeling behind that. Like what, what does it feel like when someone hands you this big mess? Yeah. It's a daunting task at first because like you said, they've handed you a big mess and you have no idea what's going on. So you just got to, you kind of have to make a plan of attack. And how are you going to figure out what's going on? And how are you going to get the right amount of context to accomplish the task that's been handed to you? Yeah, I mean one of the things is it feels like a big mess, not because it necessarily is but because you don't have that context. It's just new to you. Right? Exactly. Yeah. So how would you go about getting that context? The first thing I would do is try and track down what libraries or frameworks that application might be using. And hopefully it's something popular or something well-documented. And I would just dive into the documentation of that library or that framework. Now, are you looking to get a lot of specific information, like really become an expert in this framework or are you looking for a big picture? No, not at all. Yeah, just a big picture. Just kind of where is stuff at in this framework. What are the best practises that this framework establishes just so I can figure out, because I mean I have this task I need to accomplish. I don't have the time to sit here and learn a whole framework. So just to kind of, or where do I need to look in the application code to get this problem solved? Yeah, and pretty much all organizational libraries and frameworks are the same. Right. I mean, they all have models. They all have collections. I mean, they all call them different things, right? Right. Like for example, Knockout calls them observable arrays rather than collections, or something like that. Yeah, my goal would just be to find out what does this framework call it and where is it at. Got it. So that's to enable you to figure out, in your code that you've been given, where to look to implement the feature that you want to implement. Exactly, otherwise I have to sit there and read the entire application code, and who knows how long that's going to be. All right, that makes sense. So, what about if your framework, or library, doesn't have documentation, or doesn't have good documentation? Burn it all down and redo it. No. [LAUGH] [LAUGH] Don't do that. Don't do that. I'm kidding- Then you just have to, you have to spend the time to read through the application code and, and just understand it. And you should estimate the time required for that task to now be like five times as much as your original estimate. Mm. So legacy code can be pretty difficult. Absolutely, if it's not documented well. Yeah. Awesome. Well, thanks for sitting with me, Mike. Mm-hm. Now we're going to get our hands dirty with a real code base. No more small example applications anymore. We'll be working with a well-written and complete to-do application called TodoMVC. TodoMVC is actually a project where professional developers have written exactly the same to-do application in all these different popular organizational libraries and frameworks. It's meant to let people see the differences between libraries and frameworks. Now, given your knowledge of KnockoutJS, you could take a look at the entry under Knockout and understand most of it pretty quickly if you apply yourself. But that is not what we're going to be doing this lesson. After all, this course is not about learning KnockoutJS. We've learned separation of concerns with our model view octopus paradigm, and we've learned about Model View ViewModel in Knockout. And now we're going to see how another organizational library does it. Once you're done with this lesson, you'll feel empowered to pick up projects that you've never seen before and learn them. Now, this new code base that you're going to be working with will be based on one of these, but I'm not going to tell you which one. You're going to have to figure that out. Go ahead and get the code from the GitHub repository in the instructor notes and then we'll explore it all together. I'm going to take a moment, to get this repository onto my computer. First I'll make a directory called todo. I'll cd into it, and I'm going to say git init. That'll make an empty git repository. I'm also going to say git, poll and this URL here. Once that's done, I should be able to say git log, and sure enough, there are all of the commits. And are the same commits that are here on GitHub. I'm going to hop back to my terminal, type Q to get out of that. And also, if I happen to pull it up in my finder here, you'll find that, indeed, we do have a to-do application right here. Now one of the very first things I do when I get a new project, is I run it in the browser. Now sometimes this means setting up a local server or installing this or that. And all those instructions are usually in the read me. In this application, you can see there is no read me, and because this case is fairly simple, we can actually just run it directly. Literally by clicking and dragging index.html, here into the browser. If you have a local server setup already on your computer, go ahead and use that. And if you want to explore local servers and learn how to get them set up,. Check out the link in the instructor notes. We're going to move on right now. In this case, we can see we're looking at a to do application. This is really convenient, because we need to make a list of things to do. Here's some good things to do when you first get a code base. First, I always run the application to see how it works. Then I like to explore the file structure and see what I can infer about the code organization. It's also important to look at what JavaScript files are being loaded. Sometimes people will use module loaders, which is just a fancy way of saying, a library that loads other libraries in the correct order. In this case, we don't have any complex stuff going on. Things are staying simple. So we can just look in the bottom of the index of that HTML file. To see what JavaScript files are being loaded. It's also super important to spend some time figuring out what all these libraries actually do. You probably already know what jQuery does, but what about the other libraries that are being loaded. Now these are four of the key things, that I like to do when I am first exploring a code base. Now we've already run the application, in fact, I just did. I'm running it right now. It's very convenient that it's a to-do application. Take a few minutes right now, to explore the file structure, look at what JavaScript files are loaded, and figure out what those libraries do. Sometimes that means looking at their code, but most of the time, it means Googling for them and seeing what their homepage says. Once you've checked off these tasks, I've got these questions for you. There's a library being used whose name starts with a U, what's that library called? What's the name of the organizational library being used to separate our concerns? How many views do you see in this application? And this last question, isn't a question, it's a statement. Only check this check box, when you do feel comfortable moving on. If you need to play with the application more, do it. If you need to explore the file structure or look at what java script files are loaded, or figuring out what these libraries do. If you need to do any of that, do it now, before you move on. Once you do move on, I'll go through these, and I'll tell you what I see. Here's what I see, the first thing I'm looking at is the file structure and from that I call tell that we probably have two views. One thing is called app view and one thing is called to do view now I'm choosing to explore my file and folder structure here in sublime text. But you could also do it here in the finder, it's just not necessarily as easy to see everything at once here I can open up multiple folders at once and see all of the files inside. Now, I can infer from the naming of these views, that this one is the view for the entire application and this one is the view for each to-do item and speaking of to-do items, we also have a model for our to-do. To-do.js. Now you may also remember that we also have things called collections at least that's what they're called here. In Knockout, we called them observable arrays and from the name, I can infer that this is probably just a collection of to do models. So we've got two views, we've got a model for each to-do, we've got a collection of to dos, and then we also have this router thing. And if you remember from before, although we haven't used them in this class, routers are just like views, but for the URL instead of the page itself. Now there's also this weird thing called Bower now what the heck is that? Well one simple way to find out is to Google it if we search Bower, we get bower.io and we click. It says Bower, a package manager for the web. So if you've never heard of Bower before, you can just read this web page and it'll give a high level overview of what it is. It says web sites are made of lots of things, frameworks, libraries, assets, utilities, and rainbows Bower manages all of these things for you. Now I'm not going to get into any more depth of what Bower is but feel free to explore it on your own suffice it to say, it keeps track of all of the various libraries that we're using. Now, what libraries are we using? Let's go back to our editor, and we'll look at all the things that Bower is holding on to for us. We've got Back Bone, we've got Back Bone dot local storage we've got jQuery, we have to-doMVC Common and we have Underscore. Now let's make a couple of guesses, of course you can Google these things and make those guesses a definite, but I am going to guess that because to to-doMVC is a project, where the same app is built in all of these different frameworks. To-doMVC comment is just going to be a bunch of assets that are used in all of those various projects a CSS file, a base JavaScript file, and it looks like a background dot PNG. Those are just resources that are common to all of our to-doMVC projects. We're only working with ones so we don't have to really worry about what that is now, if you explore a little bit further, you will find that that base dot CSS file is the only CSS file that we're going to be caring about. If you need to make any changes to the CSS, you can feel free to do that. And in fact if you open it up and you look through, there have been some changes that have been made by me specifically so we can get ready to do all of the various things we're going to add to the project. Let's take a moment to look at all these others jQuery. We've talked about jQuery before. jQuery is a DOM manipulation library it also lets you make AJAX calls to servers and has some good utilities. If you need an overview of jQuery, go ahead and take a look at the website and if you need more in-depth jQuery, feel free to take a look at our course on it. We've got BackBone and BackBone.localstorage. Now who knows what BackBone is maybe you do. But maybe you don't. So let's Google it BackBone.js aha! BackBone js gives structure to web pages by providing models, collections and views. So it looks like this is our model view whatever. This is our organizational library BackBone.js if we go back to our code there's one more: underscore. So what's Underscore? Well once again we can hop over and Google it. Underscore.js. Underscore.js is a JavaScript library that provides a whole mess of useful, functional programming helpers without extending any built in objects. Blah, blah, blah, blah, blah. So it looks like Underscore just gives us a bunch of utility functions, which makes it easier to write JavaScript. Now, they talk about functional programming, that's beyond, way beyond the scope of this course. But even if you don't get into functional programming at all, Underscore.js does have a whole mess of useful functions. And sometimes it's nice to include Underscore rather than reinventing the wheel over and over again. Let's explore a little bit more. If we go to our index.html file. The page that gets loaded, we'll notice a couple interesting things here were loading our CSS. Base.CSS exactly what we were looking at before. And if you go to the very bottom of the page, you'll see all of the script tags. Loading to do nbc common base.js jQuery Underscore BackBone, BackBone.localstorage, which I'm going to guess is a plug in for BackBone to work with local storage. And then all of our JavaScript files to-do in the models. Collection, both views, the routers, and app.js and if we look around a little bit more, we'll notice these peculiar script tags. Normally you have script, without a type, or with a type of text slash JavaScript. In this case it says text/template so these represent snippets of HTML that our JavaScript can use to display things in our app. For example, item template is going to be the template for displaying a to-do item. If we ever wanted to make changes to the way our to-do items render. This would be a good place to do it, because this is the template that they render based off of. So let's return to those questions really quickly. The library whose name starts with a u is Underscore. The organizational library that is used to separate our concerns is BackBone. How many views do we see? Two views, app view and to-do view and hopefully this all makes enough sense, that we are comfortable moving on In this video, we'll take a look at the website for Backbones JS. Now everything I do in this lesson you can do on your own. So if you're feeling especially brave, pause the video right now and explore the site on your own. And remember that we're just looking for a high level picture of backbone. We're not trying to get into the nitty gritty. This page here, Backbonejs.org is actually the documentation for backbone. Now we're going to look through this page and get an idea of what exactly backbone is, and roughly how we can use it from a high level perspective. The first paragraph bolds a couple words, models, collections, and views. So we can infer that, the models are our data and collections are collections of models. In our original model view octopus paradigm. We just had normal arrays. In our model view, view model paradigm with knockout, we had observable arrays. In Backbone, they're called collections. And we also have views with declarative event handling. We'll get an idea of what that is, in just a moment. Let's scroll down a little bit and just skim through the introduction section. The first paragraph says when working on a web application that involves a lot of JavaScript, one of the first things you can do is to stop tying your data to the DOM. It's all too easy to create JavaScript applications that end up as tangled piles of jQuery selectors and callbacks, all trying frantically to keep data in sync between the HTML, UI, your JavaScript logic, and in some cases, not our case, the database on the server. So this sounds very familiar. This is what lesson one was about. Writing a spaghetti code application and figuring out, you know maybe it's not good enough. The second paragraph says, with backbone you represent your data as models. Which can be created, validated, destroyed, and saved to the server, if you have a server. Now here's the fun part. Whenever a UI action causes an attribute of a model to change, the model triggers a change event. All of the views that display the model state, can be notified of that change, so they're able to respond accordingly, re-rendering themselves to this new information. This also sounds familiar. This sounds exactly like what Knock Out was doing. Keeping track of the way things are connected, so that way it can selectively re-render certain parts of the view when the model changes. In a finished Backbone app you don't have to write the glue code or the octopus code or at least a lot of it, that looks into the DOM to find the element with a specific ID and update the HTML manually. Instead, when a model changes, the views update themselves on their own. Now, I'm going to stop here. At a very high level, it's basically the exact same thing as we've done before, keeping our concerns generally separated from each other. Now, if you look around on the web, you'll find all kinds of shaky statements about what Backbone is. It's not Modelview Controller, MVC. If we look on Wikipedia, we'll find that Backbone.js it says, is based on the model-view-presenter and the Actor model application design paradigm. So we're not going to talk about this second part. But if you read the rest of the Wikipedia article, at least as of now when I'm recording this lesson. It doesn't mention MVP ever again. Now, this guy named Addy Osmani, who's a developer who really understands this stuff and who wrote the code we're going to be modifying, wrote a blog post about this, Understanding MVC and MVP For JavaScript and Backbone Developers. This sounds like a wonderful article for us. Unfortunately, it's really, really long so I'm not going to go over it right now with you. But I would like to point out one particular area of it. About halfway down, he says, in this respect contrary, to what might be mentioned in the official documentation or in blog posts, Backbone is neither a truly MVC/MVP nor MVVM Framework. It's in fact better to consider it a member of the MV* family, which approaches architecture in its own way. There's nothing wrong with this, but it's important to distinguish between classical MVC and MV*, should you be relying on advice on classical literature on the former to help with the latter. In other words, what he's really saying is, Backbone doesn't exactly follow, the MVC model view controller, or model view presenter, or model view, view model parallax. Backbone kind of does things a little bit differently. So now we know a couple things. Definition like MVC and MVP and MVVM. Are not the be all end all. We also know that MV asterisk, means patterns that do it differently form our traditional patterns. And to make things stranger if you read a little bit more between the lines, you'll find that Backbone is pretty agnostic about how you organize the communication between the different parts of your application. So what we're going to do, is we're going to rely on the code that we're editing. To dictate how things are done. And we're going to check the documentation when we need help or when things don't work. So, it may seem strange to say, but in order to make a few changes to a particular project, sometimes we don't have to understand it fully. Its important that we remember, we're looking for a general organizational picture here. Not a super detailed one. We aren't going to learn backbone.js really really well. All of this documentation is here to help us, we're not going to understand what every single piece does. If we had to learn a library 100% before we could make any changes, that would be impractical and unsustainable. Let's take a step back from all of this and, talk to Jacques, one of our Front End Developers. About strategies that we can use, to start adding to a project, without the code that we add, sticking out like a sore thumb. I'm sitting here with Jacques, one of our lead front end engineers. Do you like tofu? I do, well, well prepared tofu. Well prepared? What does that mean to you? There's a whole spectrum of, of, sort of, the preparations of to, of tofu. And, I- What about like, a hunk of tofu from Costco or something? Just a raw hunk of, of tofu. Yeah. Probably not the most delicious. Okay. Why? It ha, it, there are so many things you could do with it that would add additional flavors to your, to your tofu. Okay, so there's a saying that I heard, well actually that I made it up. It's called be tofu. And to me it applies as well to code. Do you have any idea what I'm talking about? Not really. All right, so here is what I mean by that, tofu to me is pretty bland, it's fairly uninteresting, it doesn't really have a flavor of it's own. It does, but not really, so if I get dropped into a code base. What I want to do as a programmer is I want to be tofu. I want to look around me and just absorb and seep in the flavors around me, or the culture. Right? The way that the people wrote the code? I want to write mine just like that for consistency. If they use jQuery, I'm going to use jQuery. If they're not using jQuery, I'm not going to use jQuery. If they don't put semicolons, well, I'll be really unhappy about it, but I won't do that too. [LAUGH] note, always use semicolons. Always Can you tell me an example of maybe of when that may have happened to you? Yeah When you dropped into a codebase and it wasn't exactly the way you would have written it? But- Yeah, absolutely. When I first joined Udacity, it was on launch weekend. And there was already some code going, and once the code is rolling, especially when you're trying to get stuff done on a deadline and there's not really a, a good place to say hey, we might be able to do this better. Sticking with that culture means that at least your code is consistent. Mm-hm. And what that means is that once you get the accent of the code down. And you will from working in it. You know, from, from experiencing it and, and coding around in it. It's much easier to understand the code base as a whole. That consistency is very important. So, it's basically really important to have your one code base have one single accent for consistency. Yeah, absolutely. Because when you start working with the code. If you have to shift your mental model about how this is written, every time you open up a file, or within a file, say. Mm, from line to line? It's really hard. And so that's why having that, that consistency will at least let you, once you know what the, sort of the local dialect is. You, you can speak in that, you can write in that, you can read in that consistently. And you don't have to spend all of the overhead shifting your mental model around about how this code is written, you know what this means. So it seems like this is being polite to other coders that come along. Yeah absolutely and to yourself. To yourself? It's going, future you is going to come back to this code and go, why are there, why do half of these lines have semicolons? So you want future you to not hate past you. Yeah. Which is currently present you. Exactly. [LAUGH]. And that's like, a huge part of being a good engineer. Mm. Is not getting future you angry at present you. It's really hard, you don't always do it, but that's absolutely the goal. Awesome. So consistency within a code base even if it's not necessarily your specific style, it's really important. Absolutely. Awesome. Thanks, Josh, for sitting down with me. Definitely. Remember kids, always use tabs. Now that we know we should be tofu, let's explore the actual code that drives this application. Let yourself marinade in it as we go through. Like tofu in sauce or something. Now as we go through, think not only of how the code works, but how different changes would affect the behavior of the application. By constantly thinking about how we can change the application or break the application in different ways, it'll let us start thinking more like the original developer was thinking. So, let's explore. First, we have index .html. At the very bottom, we have all of our script tags here. One thing you might notice is of all these custom script tags here they run in a particular order. Our model todo.js runs first, then our collection, then both of our views. Then our router, then our app. Now a lot of times, the order of all of this does matter. My intuition tells me that the reason app.js is last, is that it gives all of the other files a chance to get set up before the app actually gets kicked off with this line here. So let's see if that's true. Let's take a look at our model. Now there's a particular pattern that we're going to see again and again with these files. Var app equals app, or an empty object. Meaning if app exists, don't do anything. If app doesn't exist, set app equal to a new empty object. So whichever one of these is first, there won't be an app variable, and it'll get set to an empty object. And then we have the module pattern, an IIFE. Immediately invoked function expression. So we have an open parenthesis, a function, a bunch of code here, close parenthesis, and then we run it immediately. This function here is not named, doesn't have a name. It's an anonymous function. And it's wrapped in parentheses here and, and immediately invoked. What that means is, any variables that we declare inside of this function, don't pollute the global scope. They don't go up onto the window object, meaning they don't accidentally overwrite any variables that may already exist. And we can see that inside of this function we've got app.Todo equals something. In this case, a Backbone.Model.extend, and we pass it an object literal. And that goes all the way down to here. Or at a higher level, app.Todo equals this thing. Let's take a look at our CollectionsToDo.js. We have the same pattern. Var app equals app or an empty object. Then we have an IIFE, an immediately invoked function expression. And down here we say var Todos equals this backbone collection. At the very bottom we say app.todos equals a new Todos. Now, don't get mired in the details of what's going on here. Just look at the big picture. We're creating an app object literal and then we're saying, app.todos equals some stuff. Or, app.Todo equals some stuff. If we look at the routers, same thing. App equals app, or an empty object. If we scroll down, app.TodoRouter equals some stuff. Both of our views do the same exact thing, app equals app or an empty object. App.AppView equals some stuff. In this case app.TodoView equals some stuff. So, as all of these files run, it creates an object with all of these various properties on it. TodoView, appView, our router, our model, our collection, and finally at the very end, app.js runs. So what happens there? Well, we say jQuery in this case, so when the document is loaded, run this following function, new app.AppView. Now why exactly that works? I'm not sure right now because I haven't looked at the documentation and figured out how we kick off a backbone app. But I do know that the reason that these are first so that way that app object can get set up. Now we should have some idea of where the various functionality lives because of our previous experience with other organizational paradimes. Our views are the stuff that the user sees and the stuff the user interacts with. Our router is just like the view except for the url bar. We've got the model, which is todo.js, and we've got a collection which is a collection of models for all of our various todos. And then app.js right in this line kicks it all off. Let's take a look at index.html. The other thing that we previously saw was all of these bizarre script tags with type equals text/template. And that's a chunk of HTML which is a template for something that may repeat or be some kind of a dynamic view. Here for example, we've got the view for the items. Now in the next video, we're going to make some modifications to this code base here. Now it's time to modify our application. And before I do this, I'm going to suggest, that you initialize a Git repository, so you can always revert any mistakes you make. I always do this. In my case, when I got the code base from GitHub, I made that repository. And sure enough. I'll use PWD to see that I'm on the desktop inside of my to do folder, and I can say, get status, and sure enough, there is a give repository. Get log, shows me that it turns out I've actually made some commits. Now if you do this, you'll see my commits as well. You won't see any commits by yourself, because you haven't made any yet. But as you make changes, if you like the changes you make. Go ahead and use get to make commits and keep track of whats going on. I'll type queue here. Now if you really want to you can skip the git steps steps but I highly recommend learning it at some point. If you don't already know it Udacity is a version and there are tons of other good resources around the web as well. Using version control means, its easy to experiment and that's the exciting thing. We're not going to mess up our application accidentally. Since gits, our version control system, is keeping track of what we change and when, we can play with code without fear. If we mess up, we just ask git to revert our changes and we try again. Now, I've already initialized my repo, but if you have to initialize a repo. Git init is the command that you'll use. I just wanted to point that out, because this is my favorite command because it rhymes. Get init. Now, enough about get. Our first feature modification will be a simple one. We need to make it so that way, to do items that are marked as completed. Show dash dash, done at the end. Now, there are lots of ways you can make this happen, but some art much cleaner and simpler than others. Here's a good way of going about it. Before you start, ask yourself a couple questions. Should this change the way data is stored, or is it only a cosmetic change? I like to consider that profound or cosmetic changes. Is this a big change, or is it just the way it's visualized or shown? Another question to ask yourself is, where could this change be implemented? The view file? The template? Where? And lastly, but most importantly in my mind. Is there something already like this? Does something already happen visually, when an item is marked complete? If so, like for example the check mark, where is that implemented? Maybe you should implement your change, in the same place that this change happens. Be a detective. When you're done, we'll continue. I figured out a way to implement this change in only the index.html file. Remember, that's where the templates are stored. Now, I haven't used Backbone a ton, and there wasn't an answer waiting for me. So, I had to figure it out myself. Let me go through my thought process. The first thing I noticed is when we check a box, something actually happens here. Where is the code that makes that happen, I asked myself. Well, I remembered that each one of these is rendered based off of a template, and that template is here in the HTML file. So I scroll down and found it. And sure enough right here is the input, the check box. And it says, input class="toggle" type="checkbox", and this weird thing. So what the heck is that? It turns out this is the way the template conditionally adds things. This here is interpreted logically, it's not just normal HTML, it's actually interpreted by Backbone. And it says, completed? 'checked', or empty. So if completed, is true, then add the checked attribute, otherwise add no attribute. Now what I wanted to do is I wanted to add a done text to the end of the title. So I figured, this looks like the title right here. I could probably just do the same thing here, right here. So when completed is true, we want to spit out checked. Let's save that, and go into our browser and see what that looks like. If I hit refresh, you'll see that it says run the application checked, explore the file structure checked. Modify our application, nothing's here, but if I click the checkmark, sure enough, checked. Now that's not exactly what I wanted it to do. I want it instead to add the text, dash dash done. Let me save that and go and refresh. And sure enough, dash dash done. So I tested it. It worked. And then I went back and I added an exclamation point because I was really excited. So that really was only a couple of steps. First I noticed that something changed when we checked the box, and that's what I wanted to change. I found the code that made that happen in the item template in our HTML. And I looked at the syntax that was making this happen. And I basically copied it, changed it up a teeny bit, tested it, it worked, and then I added the exclamation mark. So that was pretty simple, and it's because I've done this before. Not this problem, but I've gotten code that is not my code, and I've had to find a way to integrate my changes. And ultimately it's the practice that helps. We aren't learning to solve individual problems anymore. We're ultimately learning how to be a detective. Well, a Tofu detective, actually. One who can track down where the change should be made and then integrate seamlessly into the code that's already there. Ready for your next challenge? Now this one may seem much harder, but it's not actually as bad as it might seem at first. Right now if you click on one of these, nothing happens. But if you double click on it, it'll actually put you into edit mode. I can type again, and press enter. And sure enough, it just changed the to do application item. But that's not very intuitive, so let's add an edit button that shows up next to the delete button. You'll notice when you hover over one of these. You also get a delete button that pops up. If i type some nonsense in here, when I press enter sure enough I can roll over and press the x button and it will go away forever. Now we want to add an edit button just like this x button here. Just right next to it instead, so there will be an x button and an edit button. Now I did a little bit of work for you. You won't have to write any CSS for this one. If you make a button with a class of edit-btn, it'll get all the proper style to appear in just the same way as the x button. Now you're job is to figure out where to put the button code. The actual button, physical button. And how to wire up that button, so when you click on it, it edits the note. Remember first, be a detective, then be tofu, when you actually make the changes. Best of luck. I implemented the changes in todo-view.js and in index.html, which is the place where our templates are. Now, I had to figure this one out as well, so here's the thought process I went through. Now, first I knew I had to add the edit button in the same place as the delete button, so I had to figure out where that was. One way to do that would be to pop in to our developer tools here and take a look at what that button actually looks like. And if you poke around, you'll find that the button has a class of destroy. So, that's what we're looking for. Let's close the developer tools here and let's go look around for something with a class of destroy. Here it is right here, inside of the same place as before, the item-template. Remember this is the HTML that is going to represent each one of our items. So that's our x button. We want to have an edit button as well. I'm literally going to copy and paste, but I'm going to change the class to that class name that I gave you, edit-btn. If I save this and I go back to the browser and refresh, sure enough now, I should have two buttons, and they look exactly how we want them to look. Now, the only problem is when I click on the edit button, nothing happens. Why not? Well, it's because I haven't wired it up yet. So, now that I've tested it and the button shows up but it doesn't do anything, I need to figure out where is this edit functionality going to live? Well, think about it. The edit functionality already exists. It happens anytime I double-click on one of these items. So, I need to find where that happens and maybe consider putting the click on my little edit button in that same area. So, if I poke around, it turns out I'll find that in the todo-view.js. If we go over here and scroll down just a teeny bit, this right here is the events object literal that binds these things to these functions. So, how does this actually work? I mean, we'll find edit functionality when we double-click on a label, so that seems pretty simple. My guess would be that this is the event, click or double-click. This is the CSS selector, .toggle or label, and this over here, toggleCompleted or edit or clear, is the actual functionality. If we scroll down, sure enough, there is toggleCompleted and there is edit. It says in the comment, Switch this view into editing mode, displaying the input field. So, yes indeed, this is exactly what we want right here. So, we have a double-click on label resulting in the edit, and we also want a click event on what? Well, in case the answer isn't popping out at you, let's think about how that destroy button works. In index.html, this button has a class of destroy. When you click on it, something happens, so let's go ahead and take a look and see if we can figure out how that works. When you click on .destroy, run this function. When you click on .edit button, run this function. When you double-click on label, run this function. Now, I'm kind of intuiting this just by reading the code. When I first did it, I'd no idea if it was actually going to work. But because experimentation is cheap and there are no high stakes because of our version control, we can always revert our changes, I'm going to experiment and try it anyway. I'll save it, go back to my browser, hit refresh. And now, if I roll over and I click, sure enough, it runs the edit functionality. I can hit Enter to get back and I can do it with any of these, including these that have not been checked, so that's pretty cool. Now, I can also confirm this in the documentation. events and then an object literal, let's look that up. If we go to backbonejs,org, and we scroll down to the area where it talks about views, sure enough, right here at the very top, we have Backbone.View.extend events, and then inside of this, we've got these various things. It turns out this is indeed where we specify our declarative events. We can click on this and read even more about it, and understand exactly how it works. Right now, I'm not going to go into this, but just know the documentation does exist, and if the documentation ever fails you, a Google search will actually do very well as well. Oftentimes, Google searches will link you more effectively to the part of the documentation that you need. So, once again, not a very hard process. The specific details of what code I wrote? That doesn't matter. The point is my thought process. Figure out what you need and then be a detective to figure out where it could best fit in. And lastly, be tofu. Fit your code in as if it was already there originally. Make it look exactly the same. You'll notice I did not put a space before my colon. The reason is because the code here does not put a space. I did put a space after. And again, that's because that's what the code here has done, so I'm just going to emulate that. So now we have modified our application times two. We can check that off, and we have one last thing to do. We're going to add a new feature. Now before we move on, go ahead and check in your changes if you're using version control. That way, you can start right here before you do any of this stuff. That's particularly important because this challenge is going to be a little bit more difficult than the modification challenges. Our new feature is going to be a priority button. So now there will be a little exclamation mark button for each one of these elements. When you click on it, the task will be highlighted in red so you remember to prioritize it over the others. Unless it's checked off, in which case it won't be read at all. Now once again, the CSS has been done for you. When you add the priority button, give it a class of priority-BTN. When a task is marked as prioritized, the LI should get a class of priority. Now just so you remember that, I'm putting that information down in the instructor notes. Now, once again, I'll remind you to be a detective first. Look around for similar functionality, and see where it's implemented if you can. And if you find something you're curious about, pull up the documentation for Backbone.js, or do a Google search to try and figure out what's going on. Go ahead and implement that priority button, and good luck. The three places that I implemented this change were 1, the index.html file where the template was. 2, To do view.js. And lastly, todo.js, the place where we store all of our data in our model. So I had to figure this one out too. So, here's the thought processes I went through. So first off, I knew I needed to add a priority button in the same place as the other button, our Delete button and our Edit button. So I had to remember where that was. Sure enough, it was in our template code in our item template in our index.HTML file. So I'm going to go ahead and copy the Edit button, and I'm going to paste it, and I'm give it a class of priority button. Before I do anything else, I'm going to go ahead and test this. Sure enough, in the browser, it works just fine. When you roll over it, there's a little exclamation point, and when you click on it, nothing really happens. Of course, that's not unexpected; we haven't wired it up yet. So, now we have to remember where did we wire up those other buttons? That's right, it was in our Todoview.js. If I scroll down just a teeny bit, it was in this events object literal. I can put it anywhere I want in this entire object literal, but I'll go ahead and put it right here. So what's the event? The event is going to be a click because when I click on the priority button, I want something to happen. How do I get to the button? .priority button, and what's the functionality? Well, gosh, I do not know, actually. There's no function down here, that toggles the priority of a button, and that's of course because it's a new feature that we're creating. So it's up to us to define this. What's something that looks similar? Well, we're toggling the priority of a button, it turns out we already have a function called toggle completed. Let's take a moment and look and see what that looks like, and that's just down below here. Toggle completed is a function, which says this .model the thing that we clicked on's model .toggle. So, because we're on this wild goose chase we have to go and see what that looks like. Now where are we going to find a toggle method on a model? My guess is it would be on the to do model, in to do.js. So, sure enough, our to do dot JS file is not very big. It's just got this defaults thing and this toggle thing, and the toggle thing is exactly what we're looking for. It toggles the completed state of the to do item. How does it do that? It says this dot save, completed is not this.get completed. Now, this is the kind of stuff that we don't necessarily know because we don't know Backbone very well, and it would be great to take a look and see what this.save does and how it works, and this.get and how it works. So if I were you, I would go ahead and look them up. I'm not going to look them up in this solution video, but, suffice it to say, this dot save takes in a property here with a value and the value gets saved to the model. So, this dot save completed changes the completed value of our Todo. And what does it set it to? It sets it to not this dot get completed. So, if this dot get completed returns true we're setting it to false. If it returns false we're setting it to not false, or true. This is just basically a toggle, which is exactly why it's called toggle. If completed is true it sets it to false and if it's false it sets it to true and that's exactly how we want our priority thing to work. So for now I'm going to go ahead and do a very similar kind of a thing here. I've got toggle, and I'm also going to make a new thing that toggles the priority. So, I've gotten this far. What do I want to save it as? I'll say priority. Priority is going to be the opposite of this.get('priority'). Now, if I poke around the documentation for backbone models I'll also find information on this guy right here, that's the defaults. When you make a new to do, what are its defaults? It has a title of nothing, it has a completed value of false, and I also should add something for the priority. I'll say priority is false. Now I have something called togglePriority on our Backbone Model. So now when I create to do items they don't just have a completed state of false, they now always have a priority of false. And they also have a function to toggle the priority. And that's exactly what we want to make use of over here in our view. So instead of toggle completed function this.model.toggle. I'm going to do the exact same thing but with toggle priority. I'm going to go ahead and save this, now one thing you'll notice is I'm being tofu even in my comment. Toggle the "priority", and you'll notice I wrote this exactly the same way because in this case, the tildes on either side are saying this is code, and then the quotes are saying we're talking about a string. Same with editing down here in this comment, and so, of course, my comment is going to look exactly the same. I am missing a comma here, I'd better not leave that off. If I did leave that off, you'll find errors in the console, which is always a good place to check when your application doesn't work, and it would say, hey, something's wrong here around line 73. All right, so now I've got a toggle priority. I've got a toggle priority on the model, which I'm using right here. And let's go ahead and save it all, and refresh, sure enough, it does not work because I haven't finished wiring it up. The thing I forgot was here in events. I'm saying when I click on the priority button what happens? Nothing yet. I need to say toggle priority. That's the name of the function or the method on the view down here that I just made. And that will toggle the priority of whatever elements we're talking about. Whatever to-do we're talking about. Now if I go and I refresh and I click, still nothing's quite working. Now why would that be? I'm setting a priority state on the model anytime I click on the button. So, either I did something wrong before, or I'm doing it all right, but I'm just not seeing it. As it turns out, the thing that I forgot is I forgot to actually show it here. That would go over here, in index that HTML. Remember that the CSS was written that way you would add a class of priority on the LI. So where in this LI template do we see the actual LI? Hm. Well, if we look around, we don't see it. It's kind of of a problem, huh? So, maybe this wasn't the right place to look, for how to add the LI. So we've got the template, what else is responsible for rendering the elements? Let's take a look at the view, again. Our to do view, again. Once again, we're on this wild goose chase and we have to be a detective. Now once again, I also want to remind you that this is just my process, this is how I would go about trying to figure this out assuming that I hadn't done this before and I didn't know backbone.js. If I had to work on this code base for months, I would learn Backbone. But until then, being a detective can be useful. So we've got our events thing, and that's for the actual click. How is it rendered, again? Let's scroll down and see if we can find anything interesting. Well, here is render, that seems like exactly the kind of function we'd be looking for, so let's see what happens. There's this code here, we're going to ignore it because if you read this comment, this is just for fixing a little bit of a backbone local storage bug. So this isn't really interesting to the functionality of the application. This is the meat of it. It looks like it's taking this element, the actual elements behind this, the LI. And it's setting the HTML to, the rendered template. It's also telling this element to toggle, to turn on or off the class if completed whenever this is true or false. Now it's also, wait, wait a second, wait a second. Toggle class. That seems like something we might want to do. So, what is this line doing again? It's setting a class of completed. If this.model.get completed is true. Hm, so, if this model says that it's been a completed event, it adds a class of completed. We want to do exactly that, but for our priority button Eureka. So, let's see if this works, this.$el. So that's the element itself .toggleClass priority, and it'll set that class of priority on, or enable it, if this .model.get of priority is true. Now let's see if that works. Let's hop back into our browser and try this one more time. I'm going to uncheck these, and if we hit the exclamation mark, sure enough, eureka, it works. Now we can prioritize some of these. We'll say add a new feature's really important. And then as I check them off, the priority red goes away, and here's our add a new feature. Pat yourself on the back, we just added this feature. And especially pat yourself on the back if you came to this kind of a solution on your own, without looking at the solution video. Awesome work. Now, if you did it, I would recommend, even though you know the solution now, going back and trying to do this by yourself, without referencing my solution. Do remember that the whole point is for you to be able to do this on your own. To be a detective on your own, and to implement functionality like tofu. So your code looks like it's always been there. Good work. Now this is something you should be proud of. It's hard to learn JavaScript, but it's even harder to learn it well. Now you may still feel a little bit shaky around implementing things like this, but that's completely normal. So, I'm going to give you a few other ideas on how to change your todo application. Because although it's cliche' to say, practice does make perfect. Here's some things that you can add to the todo application. Let the user set the priority status when their creating the todo item. Let users filter or sort by that same priority status. Expand the priority status feature to have more than two levels. Right now it's either priority or not priority. What if there were different levels of priority? Priority one, two and three? What about adding a recycle bin for recovering deleted todos. You could add colors, so that way people using your application can associate different todos with each other by using colors. You could add a whole labeling system for sorting and filtering. And those are only the ideas that I came up with, there are tons more things that you can do with this particular application. Some of these are fairly trivial to implement, and some of them are quite a bit more work. And here's the best part, if you make any of these changes or any others, they'll be your changes. You will also be making whatever CSS changes are necessary, and that is exciting. You're finally at the point where you can do this stuff completely on your own. So here's my challenge to you, try it. If you're feeling hesitation or trepidation, go ahead and change your attitude from, oh, I don't know if I can do that. To, I know I can do that, my self. It might just take me a little bit of time, or I might need to do some research. And that right there, that change is the hardest part. It's changing your mind, you're not grappling with the code, or the technical problem. You're grappling with yourself. So, take your hesitation, throw it out the window, and do it. Start on the project. Start solving the problem. Now here are two things that have worked for me that I would like to share with you. The first is to be a detective. Remember that in the world of computer programming there is no magic at all. So any code that you have and any problems that you have, are discoverable and understandable. You can go in and you can change things. You can change the way they work, and you can fix them. So remember that, there's no magic. The second thing is, I'd like you to write code everyday. That's a challenge. John Resig, the original author of jQuery wrote, the feeling of making progress is just as important as making actual progress. So, I'd like you to add this to your calendar, every single day make yourself a notification, or a reminder, to write some code. So congratulations. You've made it through this course. But don't let it stop here. Keep the momentum up, keep building things and reading, and learning, and exploring. And as you build cool things, go ahead and share them on the Udacity Forum, because it's always good for other students to see what you've been building, for you to see what they've been building, and we always love seeing what you guys built. Keep it up, good work, and have fun. We'll see you later. Do you remember Cat Clicker? Do you remember the pain on Andy's face as the project requirements changed again, and again, and again? I remember it very well. Poor Andy. Well, a, anyway. Our final version has two main areas. It's going to have a list of cats, and a cat detail area, where you can click on the currently selected cat. Well as it turns out, the last few lessons have gotten us ready to build Cat Clicker, and this time we'll build it right. Now, I'll tell you from personal experience. Even though, I've built a lot of applications and structures with wood, too, for that matter, one thing I hate doing, is planning. But every time I don't plan things out, they end up taking much more time. And by the end, I wish I'd spent the extra time to plan. So, let's take some time and plan this out. Let's go over the problem again. We want to build an application with a list of cats, and when you click on the cat in the list, they will display in the cat viewing area here. And what's more, the number for the number of clicks should always reflect the number of the current cat. We're going to go through this right now and figure out what should belong to the model, the view or views, and the octopus. First, let's identify the model and the view portions. Of the following things, choose whether they belong in the model or the view. The clickable list of cats here, the current cat display, and the array of cat objects which is driving all of this. The array of cat objects will definitely be in the model since it is the data that represents our cats. The clickable list of cats and the current cat display are both part of the view. They are things that the user sees and interacts with. Now let's review the model and view in a bit more detail. The model is going to be super simple. It's just our data, an array of cat objects, with properties for name, click count, and image URL. Nothing new here. Now the view, well, actually, if we want to, we can split this up into two views. First we have the list of cats, and second, we have the cat viewing area. Both of these views will be pretty simple. They'll just have render functions that redraw the respective areas. And they'll have click handlers registered for the various cats up here and for the image down here. Now, why am I splitting them up into two views? Well, here's a good way to think about this. Think about how separate they are functionally, not with regard to action, but with regard to what gets rendered. The list renders the list of cats. When does this re-render? Well, right now, it only renders one time, at the start of the application. This other part renders cat details and it gets re-rendered every single time you click on the cat. Now, they're both separate visually and in terms of when they get rendered. Separation does make some sense here. Now, if you wanted to make them one view, that would work just fine, but it's generally a good idea to separate out functionality into smaller chunks whenever it's possible. Now where is Larry, our octopus? How do our model and our view connect to each other? Well, let's think about what things happen in our app and maybe we can sort this out. So, first of all, the app loads up. We start with a blank screen. First the list gets created, then the list view populates with cats. Larry the octopus does both of these things. Now, not for rendering it on the screen, that's the job of this particular view. But our octopus is what tells this view to render itself in the first place. In other words, the octopus gets things going. Then the octopus changes the current cat in our model. Current cat gets set to this first cat. When that happens, the octopus says, hey, go ahead and render this view here and then the current cat view gets rendered. Now again, the rendering of this view here is not the responsibility of Larry. But Larry the Octopus does tell that view when to render. So now the octopus has gotten our model started, gotten our views started and everything has gotten rendered. Now let's talk about the case where the user has clicked on a cat. Well, the octopus is keeping track of where you click. So if you click on this cat here, the octopus will run a method with increases this counter, first, in the model, and then in the view. Now if a user clicks on a cat up here, let's say on this second one here, then the octopus does the following thing, first it changes the model. The current cat is now being set to Purr and then it tells the view over here, to re-render itself. So to recount, when the app loads up, first Larry initializes the model. Now in this case, we just have simple data so that doesn't mean very much. Then Larry tells all of the views to render themselves. Then finally out octopus says whenever you click on any of these things, do this particular or that particular piece of functionality. And then tell the respective views that have changed to rerender themselves Now let's take Andy's spaghetti code and identify what parts of it belong where. Because as it turns out, you can do this. If you separate functionality into these three buckets, model, view, and octopus, you can take spaghetti code and refactor it to be organized and extensible. You can find the repository with Andy's actual code in the instructor notes. Now, the first thing I do before refactoring is I run the app itself. I play around with it and figure out what the functionality is, and that will help me understand the code later on. It looks like you can click any of these buttons here and you'll get a different cat. You can also click the image of any of the cats to increment the number for the cat. Now, go ahead and hop into Andy's actual code and see if you can figure out how Andy is displaying the different cats. The answer is that he's keeping a separate view for each cat, and showing and hiding them. Let's take a look at Andy's HTML. It looks like he hard coded all five buttons, and all five cats, down here. Now if we had asked him for 15 cats, this would be a very long file. The other thing to notice is that he doesn't have a single area to show the cat. Every cat has its own view, if you will. And as I mentioned before, if something bad happened and somehow two of these were shown at the same time, that could break the way the application looks. Next we'll take a look at the JavaScript. In Andy's JavaScript file, one of the first things we see is the hideAllCats function. As you can see, he's going over all of the cats and hiding every single one of them. The first two things we see are var cats and var buttons. These are variables, and in them is stored a J query collection of the cat class objects, and the button class objects. And the next thing we see is the hide all cats function. What Andy is doing here is looping over all of the cats, and hiding each one of them. Now this isn't the best way to do things. If you have many, many views for a single area instead of one. A bug in your code could easily make multiple cats show up simultaneously, breaking the layout. And as we saw before in our HTML, each cat does have it's own view. So that's kind of bad news. But in terms of classifying what these things are, they all seem view-like. This represents the cat views. This represents the buttons and then this function here is the function that hides all of the cats, effectively changing the rendering of the page. So, all three of these things seem very view-like. If we continue looking at the file, we'll find two more functions, bindButtonToCat and bindCounterToCat. And you'll also see that these two functions will get called here in for loops where we go over all of the buttons and all of the cats, and run this for the buttons and this for each of the cats. So what do these two functions effectively do? They effectively add event handlers to our buttons and to our cat images. In this one, when you click on a button, it hides all the cats using our function, then it grabs the cat with the ID of cat 1 or cat 2, and shows it. In bindCounterToCat, it's saying, whenever you click on the cat, do the following, get the click count from the DOM, parse it into a number, and then re-update the DOM with the new counter. So, now, where do you think Andy's model effectively lives? Where is he storing his data? The answer, it turns out, is in the DOM. Like I mentioned before, in bindCounterToCat, it gets the current number from the DOM. It finds the counter object, grabs the text out, turns it into a number, adds one, and then updates the DOM with a new number. So where is that data coming from again? It's coming from the DOM element. Now the number of clicks shouldn't be stored in the view or octopus areas. Remember that the model is for data. And the number of clicks belongs in the model. But Andy is storing it in the view. And that's a problem. So, we've established that Andy is storing his data in the DOM, and that's one of the reasons that his code has become kind of spaghettified. I'd like to take a moment to defend Andy. Thank you Ben. Sure. In his defense it's really easy to justify storing your model in your view because it's so easy to do. For version one of Cat Clicker he didn't set up anything special to store his data. He just asked for the data out of the view, updated it and put it right back. But as we can see, that did not scale very well when his project got much bigger. The biggest issue with Andy's code is that he stored his data in the dom. Or, more generally, he didn't separate his view and his model within octopus. In fact in his code, the model and the view were the exact same thing. And that's what got him into so much trouble. I think it's about time we tried building Cat Clicker again, but this time we have better organizational skills. You'll be doing the same project we ended with before. The application shows a list of cats that when you click on one of them it updates the cat detail area with the clicked cat's details. Now the primary thing you need to remember is to separate out the view entirely from the model. Use an octopus for communication between the two, never do it directly. Personally, I would build it with two views. One for the cat list and the other for the cat detail view, each with their own render methods. And remember to never have the model and view talk directly to each other. That's very, very important. Once you're done, I'll show you my model of the octopus implementation. Here's the spec sheet for Cat Clicker Premium. Go forth and build it. Remember that with our model view octopus paradigm, the view and the model should never communicate directly with each other. That means you should have put zero for this one right here, and zero for this one right here. All the rest of them are fine. We know that we can go between the view and the octopus, and the octopus and model, and vice versa. Now if the number you put in here or here wasn't zero, you may want to consider pausing this video and going back to your code to see if there's a better solution that you can come up with. Now, I do want to be clear. There is no single one right answer, as long as you're separating concerns. So rather then compare my code to yours, instead look at how my code is organized and draw inspiration from that. Now to show out, I'll show you my index.html file. This is very simple. I have a ul called cat list and a div with an id of cat. It has a cat-name, cat-count and cat-image inside of it. These things are things that the view is going to hook on to and update whenever it's told to render. Let's dive into the JavaScript now. First, we'll take a look at the model. Now, in this case, the model is simply and object literal with currentCat set to null and cats being this very large array of objects. Each one of these objects represents a cat and inside of each of these cats, I've got clickCount, name, image source and image attribution. Now lets scroll down and look at our octopus. In our octopus, I have the init method, which starts off the entire application. I also have a getCurrentCat and getCat function. The view calls both of those in order to get the current cat or all of the cats, so that way you can render properly. We also have a setCurrentCat function. You passed it in object and it sets the CurrentCat equal to the object that you pass in. And lastly, we have incrementCounter. What that does is it takes our current cat and it increments it's ClickCount. Now whenever that happens, it tells the catView to render. Let's take a quick look at our view before we see the flow of the application. First, we have the catView. The catView is object with an init function and a render function. I've separated these out, so that I can render it whenever I want to, but init only gets called once. For example, I don't want to grab all of these DOM elements from the DOM every single time we render. I may as well just do it once and store them here on the catView. Similarly, I only want to add the click listener for the catView once. Now the reason is because as I click between cats over here in index.html, it just changes this information here. It does not replace the entire div. This div is always here and this image element is always here. So, I can add the event listener one time. And then no matter cat I change to, these elements will always be the same, they'll just have differing content and a source attribute. And lastly in our catView init method, we call this.render, which will update the view. What does render do? All it does is it gets our current cat from the octopus, which of course, gets it from the model. And then we set the count element and the name and the image to the clickCount and the name and the image source of our CurrentCat. Remember that these on the left hand are the DOM elements, so that's our catListView. Render gets called over and over and over again, but init only gets called once. We'll see where that gets called in just a moment. Let's take a look at our catListView. Our catListView is actually a bit simpler. Here we have our init method, which only gets called once. We grab the catListElement from the DOM and put it in this variable here and then we say, render ourselves. Let's see what render does. We first get the cats from the octopus, which of course originally would get it from the model, then we empty our ul, which lists all the cats. And then we go over all of the cat objects and we create an li and we do all of the necessary stuff. That being setting the text content equal to the name of the cat and adding EventListener. Now here's my little closure trick that I had to do in order to make this EventListener inside the for loop work and you'll find that this is a common thing that you'll have to do. If you're adding EventListeners inside of a for loop, you actually need to create a larger function, pass in your cat and then return the function, which does the stuff that you want with that cat. So ultimately, all of this code says, when you click on the element, tell the octopus to set the CurrentCat and then render the catView, because it's changed. And lastly, add all of our lis inside of this for loop that we've created to our CatListElement, the unordered list of cats. Now, let's run through this really fast. Octopus.init, this makes everything happen. When this gets called, the following things happen. We say, hey, model, set your CurrentCat property equal to model.Cats 0. In other words, the first cat in the list. And then we say, catListView.init and catView.init. We tell our views to initialize themselves. And then the views handle all the stuff they need to do without the octopus needing to get involved. Now if you liked to go over this code, you can find a link to it in the Instructor Notes. I would definitely suggest you dive in and see if you can figure out exactly how every part of this works, then compare it to your code. If you want to go back to your code and make any changes, go ahead and do that now, but don't copy my code. Remember, this is not my project, this is your project. So, only use my code as organizational inspiration. Once you're satisfied with your version of Cat Clicker Premium, go ahead and click to continue on. At this point, you should have a well-built cat clicker. Nice work. Now, I'm changing the requirements one more time. I promise this is the last time I change requirements on you. But I wanted to give you an opportunity to fly on your own. We're going to add an admin mode. When you click the Admin button, it makes a new area visible with the cat's name, URL, and number of clicks. If I go in and change the name, say to Fluffy, and then I hit Save, it should update the model with the new information, and of course, tell the views to refresh, which also hides admin mode. So what will you need to add? First of all, you'll need to add some HTML for the Admin button and all of this stuff here. That will probably involve a button here, a button here, some inputs, labels, and a form to contain these. And come to think of it, you can add a Cancel button too. In terms of the model, you'll probably want a property in your model for whether or not the admin view is showing. You can set it to true or false with your octopus function. And then based on whether it's true or false, the view will render this or not render it. In your view, you'll have an it function. Which I'll call, once. That'll add the event listeners to all of these buttons here. Just for a review, adding event listeners means we're telling these elements to listen for certain events. In this case, click events. So whatever the user clicks, we run the function. Now what about the octopus? In your octopus you will have a function for opening the view when you press the Admin button. A function for closing the view when you press Cancel. And a function for updating the current cat with the new values when you press Save. We'll call this version Cat Clicker Premium Pro! Also, remember that this exercise here is not meant to be super easy. Another thing to notice is that the layout of my application keeps changing. That's to emphasize the fact that we're not focusing on CSS. Your application doesn't have to look necessarily very pretty. Just as long as the functionality is there. Once you're done it won't be a ton of code, but if it takes you a while to do this, that's by design. Do remember that the more often you work with well-organized code the easier changes like these will be. Those last few processes were probably a bit easier than what Andy went through. I mean, you saw the pain in his face when the requirements changed and when he was reflecting on the process. If you organize things well it's much easier to add things later, and that's the point. Separation of concerns is great, especially when you do it well. Now, sadly not all projects are organized well. Every company has legacy code, even Udacity. So how do we deal with it? We're going to take a few minutes to rest our brains, and we'll hear from some experts on our software development team here at Udacity. They all had a ton of experience with writing good code, but also have to spend time bringing legacy code up to date. We'll talk to Nick and Jacques about two opposing methods for bringing code up to date. I'm sitting here with Nick Artman. He's one of our front-end web developers. Thanks for sitting with me. Absolutely. So, tell me a little bit about refactoring. What's one way that you might go about it? So, refactoring is the process by which you take a piece of code and make it more readable and more maintainable without changing its functionality. So that means, you might want to break up large functions, or complicated functions without changing the way that they're accessed by the outside world or the other components of your application. Got it. So basically you're taking the organization, which we'll say in this case is already all right, and you're taking the big unmaintainable or difficult to understand functions and you're breaking them up. But it's important not to change things in terms of the way the components interact with each other, right? Precisely, this makes sure that you increase readability, maintain ability and ease of working with your code but without breaking the contract that you have between you and the other developers you're working with. And the contract that the pieces of the app have with each other as well. Exactly. Awesome, that sounds like a good method. Thank you for sitting with me. Absolutely. I'm sitting here with Jacques one of our lead front end web developers. Hi. Hi. So I was talking with Nick about architecting a little bit. You know, like you've got some code it's not necessarily up to snuff and you know you just move things around a little bit to get it up to snuff right? So what if I were to give you a piece of code that's like that but worse. You could sort of still tease parts of it, you know, around and, and sort of get into the modules or the separations that you're interested in and then replace those pieces as, as you work on them. So, if the, if the code's not stuff that you want to keep around separating it out means you get to burn little pieces of it at a time and replace them and upgrade them and make them, make them better. That makes sense. So what if I give you some code that's even worse than that? Like, lets just say, big mess of spaghetti code. If you can't tease it apart, or if there aren't good ideas that you'd like to keep just burn it to the ground. Just start. Just take it all away and rebuild that functionality. Just like that. Wow! Okay. So I guess you're giving me permission to burn horrible spaghetti code to the ground? Absolutely. You will thank yourself in the future. What if it's worse than that? [LAUGH] Nuke it from space. [LAUGH] Have, have a friend delete it for you. [LAUGH] Don't even, don't even look at it. No, no. Just, okay, so, wonderful. Now you have permission to delete horrible, awful spaghetti code from your projects. Huh, so you, you actually have done this? Yeah, oh, absolutely. Have, have you ever nuked something from space? Between Nick and I, we, we have done that absolutely like, hey could you get rid of all of that, I'll, I'll replace it. Oh, boy. [LAUGH] Fantastic or horrifying. Or, or terrible, yeah. Terrible. kind of both. Awesome. Well, thanks for sitting with me and talking about this. Absolutely. Now that we've heard from some experts, let's take some time to put their advice into practice. On the next screen you'll get the repository information for a not so well designed school attendance application. Clone it to your machine, check out how it's working, and refactor it. Make it awesome. Now, it'll be up to you to decide how to go about this. Is this code completely a mess? Is this a burn it down and rewrite it from scratch situation? Or are there pieces that are salvageable? Remember, before you start doing, take a moment to figure out how it's working, and what's good and bad about the code as it is. Evaluate how much needs to change and figure out your strategy. Once you're done, we'll talk to the author of this code and see what their motivations were for building it the way they did. Now, before we meet the person who built this horrible, horrible code, and you may know him, first I'd love to hear from you about your experience. Did you mostly use the burn it method, or the refactor in place method? Well I'll tell you what I did. I burned it all down and started completely over. Now I want to reiterate, I didn't write this code. In fact, let's meet the person who did. I'm sitting here with Mike, one of the web developers at Udacity. I heard you wrote some pretty bad code recently. Yeah. [LAUGH] That was quite the experience. Yeah, I actually remember, because I gave you that bad code assignment. [LAUGH] You did. So, so basically in a nutshell, what did I tell you to do? You, you came up with an app idea, and you just told me, all right, now forget all the things you know to do right, and, and do it wrong. And try to make it a rough experience. So build a spaghetti code app. Build a spaghetti code application. And how did you feel? I was really excited because I knew I didn't have to maintain this thing. I was just going to crank out an application for you really quick, get it done in hour or two and and just get code on the screen and feel super productive. So I was, I was kind of excited to not have to put whole lot of brain power to it and just do it. Yeah it's kind of old habits in a way right. Yeah, yeah. Because everyone kind of learns spaghetti code and then learns how to organize their code later on. It reminded me of like ten years ago. Like the type of work I was doing. [LAUGH]. So you had this app. You didn't have to maintain it. You felt great about it. Mm-hm. How do you feel by the end? Pretty bad. [LAUGH]. Really, why? Well it was a miserable experience when it got to the end. There was a point that I actually coded myself into a corner. Oh. And I had a problem that I knew, like I knew myself was a simple problem to solve. But, because of the way I had built the application it was no longer a simple problem to solve, it was actually really difficult. And then I just felt bad because I, I knew where this code was going. I see. Well, actually, Nick Artman one of our other front end engineers- Mm-hm. Likens it to diving for the finish line. Yeah. And if you dive for the finish line too early, well, you get scraped up. Right? And things seem really bad and it takes a lot more effort to go then and finish the, the race. That's-. That's a very good metaphor about it. I basically told you to die right out of the starting block. [LAUGH] Right. Yeah. I, I thought I was done with the application before I had ever started it really, and so I was just [NOISE] trying to get stuff done and if I would have taken my time to like, really plan it out ahead of time and, and know what I was going to do throughout everything it would have been a much more enjoyable experience. All right. So if you want to blame someone for this experience you can blame Mike. You told me to do it. If you want to blame someone for this experience, you can blame me. Bad advice. [LAUGH] Awesome. Well, thanks Mike for sitting with me. Uh-huh. Hey. Nice work fixing up Mike's awful, awful code. [LAUGH] I still blame him even though I may have told him to do it. By now, you should feel pretty good about yourself. Let me give you some context. Oftentimes when people learn separation of concerns, they learn it by using a framework or a library like Angular or Ember or Meteor or Backbone or Knockout. There are a lot of them. And some of them start to think of separation of concerns as something that you need a framework or library to do, but not you. All the stuff we've been doing has been vanilla JavaScript and jQuery, no organizational frameworks at all. That's more than could be said for a lot of novice developers, so awesome, awesome job. Now, from what we've seen, any project that updates the DOM based on data with JavaScript can be refactored to use separation of concerns. So now we're moving onto our last project for this lesson. You may have built the resumé project in a previous course. I've linked the course and the instructor notes below. If you took that course, we'll be refactoring your project to be more awesome. If you didn't take that course, I'll give you the repo for the associated project. We've seen that any project that updates the DOM based on data using JavaScript can be refactored to use separation of concerns, so that's what we'll be doing for the resumé. Now, you'll all have less guidance on this project and more autonomy and flexibility, which is exactly how things are in the development world. So, if you have code of your own, make a new branch in your resumé project repository. We're making a new branch so we still have the original version. Do all of your work in that new branch. If you don't have code of your own, check out the repository down in the instructor notes below and take a look at the readme file so you can figure out how to do the project, keeping separation of concerns in mind. Then, refactor the project to properly utilize separation of concerns. This might be as simple as providing a view object with a render function on it and ensuring you don't mutate the model from it. Remember all the different ways we can refactor, either by modifying the current files as they are or doing some version of burning it and rewriting. You've gone through a lot by this point, you've written an application with separation of concerns in mind and you've also added a completely unexpected feature to it. That is nothing to sneeze at, that's impressive. Now rock-star developers will often write code entirely in JavaScript with no organizational libraries, and that's what we just did so seriously give yourself a pat on the back, it's impressive. Sometimes though, it is useful to use an organizational framework or a library to give you the features you need, without needing to do a ton of work at the beginning. We'll learn how to use one of them, and what they name their octopus. So, keep going, keep the momentum up, you're doing great, and there's some really fun stuff coming up. Model view octopus is everywhere, but most people don't call it an octopus. They have much more boring names for it. Sorry, Larry. MVC stands for a Model View Controller. MVVM stands for Model View ViewModel, that's one word at the end, ViewModel. Model view presenter is MVP. You might run into all three of these in your professional career, but don't panic like I did when I first learned. They are all just different ways of solving the same problem. How do we separate concerns so we can minimize connections? So, with MVC, our octopus is called the controller. With MVVM, we call it the view model. And MVP, we call it the presenter. Now, if you Google these terms, you'll find tons of articles and forum threads discussing all the differences between these three different paradigms. But those articles usually assume that the reader knows that they're fundamentally at their core the same thing. They're [SOUND] all octopi, just with slightly different personalities and preferences. Now let's take a few minutes to unpack the words, library and framework. Now, this is another difficult topic to cover because of the inconsistencies. You see, it's not a single person or entity defining these two words. It's a community. And so, the usages of these words in the community can be a lot more loose. Now, you may have heard the word framework used when describing CSS frameworks. But we're going to remove those from the discussion. CSS frameworks generally are not JavaScript, although they sometimes include it. And including CSS frameworks in the discussion just confuses everything. >From here on forth, I'm just talking about purely JavaScript libraries. So, what's a library? A library is just a bunch of JavaScript that someone else or some other people wrote, packaged up, and distributed. Or in fact, it could be JavaScript that you wrote and packaged up. There are a lot of things we do over and over again as developers, like making AJAX requests and manipulating the DOM. And as we do this again and again, we don't want to have to keep writing the same code over and over again. In this case here, I've decided not to rewrite it three more times for three more projects. And instead, I set aside this AJAX code for reuse in all of my projects. Libraries take it one step further. Rather than have every developer write their own AJAX function, why not just make an AJAX library and distribute it freely for everyone to use? And while we're at it, why not make a library that makes DOM manipulation easier too? Now, that's exactly what people actually do. If you search on the web, you'll find all kinds of AJAX libraries and all kinds of DOM manipulation libraries. jQuery is a great example of a library for DOM manipulation, AJAX, and much more. Now, don't be confused by all of my colors here. All I'm bringing out is that jQuery has an AJAX library built into it and a DOM manipulation library built into it. If you really wanted to, you could probably separate these things out and make them work separate from the rest of jQuery. We're not going to do that, but it is important to keep in mind that everything in jQuery is just some JavaScript that some other people wrote already. And we can use it rather than rewriting all of its functionality from scratch ourselves. And what's more, the good libraries will often make allowances for older browsers, abstracting away some of the browser differences and issues so you can spend time focusing on building your app rather than supporting older browsers. So, now we know what a library is. It's just a bunch of code that someone else wrote that we can use in our application. Now, when we talk about libraries and frameworks in this class, we're generally talking about organizational libraries and frameworks. And jQuery here is not an organizational library. It does give us a bunch of useful great methods. But it doesn't give us anything to help us organize our code. Now let's talk specifically about organizational libraries. Organizational libraries are libraries, just like jQuery, but instead of focusing on AJAX and DOM manipulation, they focus on application organization. MVC or MVVM, what we know as model view octopus, and often some other things as well. Now, there are a lot of organizational libraries out there, but they're all solving the same problem in fundamentally similar ways. They do have slight differences in organization or implementation, and that's what the documentation is for. But by now, if you understand the basics of separation of concerns, then you can understand any of these organizational libraries. Now, what about frameworks? What is a framework, and how do they differ from organizational libraries? Well, while scripting this course, I talked to a bunch of people about this question because I was a little fuzzy on it myself. And it turns out, everyone has a different answer and none of them fit 100% with what libraries and frameworks call themselves. So let's take a step back. Here's the real issue. It's not one person or institution defining these words. It's a community of thousands and thousands of developers, and they aren't all on the same page as each other. Some people say frameworks are collections of libraries. Some other people say that frameworks call view render methods, while the libraries require you to call them. There's a wide range of definitions, and if you do want proof of this, do a quick Google search and start counting. In fact, if you look at the edit history for the Wikipedia pages on JavaScript for libraries and frameworks, you'll even see disagreement among the editors themselves. So, what is the difference between an organizational library and a framework? Well, it feels like a cop-out, but I would say, don't worry about it too much. Organizational libraries and frameworks both solve the same problem and in similar ways. So, to me at least, it doesn't matter a ton what we call it. It just matters that we can use them regardless of what they call themselves. I'm sitting here with Nick Artman. He's one of our lead front end web developers. Thanks for sitting with me. Sure thing. So wh, I was learning JavaScript, I had this feeling that if I don't do it all by hand, if I don't actually write all of the code, then that makes me somehow less able or less awesome or something like that. I felt some shame around using frameworks and libraries. What are your thoughts? That's actually a misconception that I've encountered amongst a lot of people. Because as engineers we want to build a lot of things and we want to make sure that we prove that we can do it. And while it's interesting to experiment with new technologies and with trying to replicate things that you've seen other people doing, the core of good engineering is taking what has been built before. What is well tested, what is documented, like a good framework or library. And using it to build something even greater. Mm. Okay. That sounds really good actually. So how frequently would you say you tend to use libraries versus just writing code on your own? So I in fact, use libraries and frameworks every day. For example, on our site, we use the Underscore library to help fill in bits that JavaScript doesn't have natively. And we use the Angular JS framework to give us automatic updating of our page when we modify our data model, and advanced features like that, that would take us a lot of time to write ourselves, but the Angular team at, works on that as their full time job, which benefits everyone in the community. So rather than writing it all from scratch you just use a library or framework that's really well tested and solidly built. And it sounds like you write a lot of code in frameworks. Absolutely! And there's no shame in it. In fact, it is leveraging the work of other people to make your work go even further. So if someone came to you and said, hey, I like to write everything from scratch. Would you hire them? I would tell them I love their tenacity and I love their drive, but I'd want to sit down with them and show them that they can take other's work, such as jQuery and Angular and many libraries and many frameworks out there, and build upon them, and make an app that is theirs. Not just kind of a rewrite of something that somebody else has already solved. Mm. It's always great to advance the state of the art, but, except for learning, you don't want to just reinvent the wheel. Mm. Got it. Awesome. Well, thanks for sitting with me. Sure thing. Remember when you learned about for loops, if statements, functions? Those are fundamental concepts in programming, and if you're ever writing code in other languages, you'll see these concepts again and again. Now, the same goes for certain concepts with code organizations. Here are some of those main concepts that you'll see over and over again. The first on our list of fundamental organizational concepts is models. Now, we've already talked at these. Models just represent your data, and models can be stupid, like a JavaScript object literal as shown here. Or they can be more intelligent, as in most other organizational frameworks, and as we'll see in a bit. Next, we have collections. Collections are basically smart arrays. And what are they filled with? Models. Now, remember, models are just data. Even if they're intelligent models, they still represent data. So, collections of models are collections of data, just like our cats array in the previous lesson, but a little bit smarter. Now, we've talked about octopuses at length, but if you bring them up to any other developer, they won't know what you're talking about. Octopuses in the real world are called things like controllers or view models. Here's another thing we've already talked about in-depth before. Views are the things that draw the interface and allow the user to interact with the interface. We also have a similar thing called routers. Now, this is new to you technically, but only kind of. Routers keep track of the state of the URL, which in a way is a view-like thing. The URL is something that the user can interact with and see. Often, routers are used to track the state of the application. Now, we're not going to get into routers in any more depth than this, just conceptually. But just know that they're very similar to views, just for the URL bar up here. Don't be afraid of them. If you can understand views, you can understand routers. Now, organizational libraries often look very different from each other. But no matter which you use, you generally see these same five things over and over and over again. The concepts are all the same, and that means once we have a solid understanding of these basic concepts, we can feel empowered to learn new organizational libraries. Let's talk about Knockout JS, the organizational library we'll be using in this lesson. Now, since Knockout is an organization library, we'll get most of the same things we've talked about before, models, views and octopus, but they don't call it octopus. In Knockout, it's called a ViewModel. If you go to knockoutjs.com, you'll find a whole bunch of information here, including some of these unfamiliar terms. Let's spend a minute unpacking some of these terms. First, we have ViewModel. The ViewModel is similar to the octopus that we know and love. It's the thing that connects and separates the Model from the View. The main difference for now is the name. Also keep in mind that the word ViewModel is one word in this case. So when we say MVVM, VM represents one term, not two, the Model, the View, and the ViewModel. Next, we have declarative bindings. Up until now, you've been connecting your DOM elements with your data in the model by writing code in the octopus, and probably there have been a few times that it seemed especially tedious. A lot of the methods that we write in the octopus end up doing the same old thing, simply passing a value this way or this way. Now, rather than write all of that tedious logic in the octopus or the ViewModel, Knockout lets you connect these two using bindings that you put in the HTML. Now, it's important to point out that it still is going through the ViewModel to get the data. We are not connecting things directly. The difference here is that instead of writing a bunch of code in the octopus, or the ViewModel, which goes and grabs portions of the view, we're going the opposite way. We're putting the logic in the DOM in the form of bindings. We'll get into them in more detail in just a moment. But suffice it to say that bindings are a great way to make the connections between the view and the ViewModel without writing a lot of repetitive functions that ultimately do the same thing manually. Next, we have automatic UI refresh. UI stands for user interface. And Knockout will watch your model data and automatically refresh the view when it changes. Effectively, that's some of our octopus code that Knockout is responsible for doing automatically. And if you set up the right declarative bindings in your DOM, Knockout will actually watch things in your view like input boxes and automatically update the model when view stuff changes. Sometimes that's called two-way binding. And lastly, we have dependency tracking. Sometimes your model data depends on other model data. For example, if we were to get our clicked cats levels, which increase as the cats get more clicks, the level data right here would depend on the clicks data. Knockout lets us create that relationship where one model depends on another and will automatically track those dependencies for us and update things accordingly. So, these four terms are some of the important new terms that you probably should know if you're working with Knockout JS. And in fact, if you ever pick up a new framework, always go to the website and look for these kinds of terms that you don't already know and figure out what they mean. Usually, the concepts, once you think of them in English, are not very hard. Now, in terms of these last three, they'll make even more sense once we do it ourselves. Here I have a simple example of an app built with Knockout. This example was built by Ryan Niemeyer, and you can find the link to it in the instructor notes. In this app, we have a button and a number that updates when you press the button. If you click the button too many times, it notifies you and lets you reset with a different button.s Now, rather than show you the example code here, I'm going to copy all of this into Sublime Text. Now, I'm not going to pay any attention to the CSS in this example, just the JavaScript and the HTML here. I'm also going to change this to say Click rather than Click me. That way, we can see this entire line. Let's pay special attention to the HTML in this example. The counter is a span with a data attribute on it. Now, the buttons and the notification area all have data-bind attributes too. And it's those data-bind attributes that connect up the view with the rest of the application. Knockout reads these and starts watching the buttons and updating the views. Now let's go through these one by one. Our counter here says data-bind equals text: numberOfClicks, so let's remember that name right there. If we look at the JavaScript, you'll find numberOfClicks is actually a ko.observable. Now, we don't quite know what that means yet. We'll talk about that in the next lesson. But the point is, that's the way things are connecting up. The data-bind attribute here is the way we tell Knockout that we always want that span to show the value of numberOfClicks. Whenever numberOfClicks here changes, Knockout will change the view automatically. Now let's look at the Click me button here. Its data-bind attribute says, click: registerClick, disable: hasClickedTooManyTimes. It's important to notice the comma right there. This and this are two separate bindings. What these bindings are saying are, if the user clicks on this button, run the registerClick function over in the view model and disable the button when hasClickedTooManyTimes is true. And sure enough, if we pop over here, we'll see that registerClicks is indeed a method on the view model. And we'll also notice that this.hasClickedTooManyTimes is something too. This is a ko.computed, and that we're also going to talk about in the future. Don't worry about it too much. If we hop back to the HTML, let's see if you can guess what this and this do. So, I've got two questions for you. What do you think data-bind equals visible hasClickedTooManyTimes really means? Your possible answers are every time the div is visible, this function will run. When the user clicks on the div, this is set to true. Or when this is set to true, the div will be visible. Only one of those is correct. Here's your other question. What do you think the second one, button data-bind equals click resetClicks will do? When the user clicks on the button, the resetClicks function will run. When the user clicks on the button, a reset variable will be set to 0? Or when the number of clicks is 0, the button is visible. Once again, only one of these three is correct. Give it a shot. What do you think? This third one is the answer to our first question. The visible property in data-bind makes the element visible when a variable is true, and vice versa when the variable is false. Our second answer is this first one here. The click property in data-bind will run a function when the click happens. So, when we click on this button, the resetClicks function will run. Knockout handles models a little bit differently. Instead of storing our data in a plain old object, or as a simple value, we use a special kind of Knockout object to keep track of our data. That's called an observable. If you open up the Knockout home page and pull up the terminal, you can actually run Knockout code. Now, before we actually get into how observables work, I want to dispel any magic. Observables are not magical objects. These are just objects with special functions on them. Let's go ahead and make an observable in the console here and run console.dir on it. I've made var foo equals ko.observable. I'm giving it a default value of 0. And if I run console.dir on foo, we will see all of the stuff that's inside of it. As you can see, foo is a function, so we can run it, and there's also all kinds of stuff on it. Now, we don't know what any of these functions do yet, but that's what the documentation is for. The point is there is no actual magic going on. This is just JavaScript. Now, I'm not going to cover everything about observables, but I will cover the basics of them for you. If you want more detail, take a look at the Knockout documentation. Let's make an observable to keep track of our favorite number. When we make an observable with Knockout, we pass in the initial value. If we want to get the value, we just run it, favNum with no argument inside. It returns 42. So rather than saying var num equals 42, and then just getting the value by typing num, I've created a ko.observable, and to get the value, I need to run it as a function with no arguments. Now, why is it that we need to run this function rather than just get the value directly? Well, as it turns out, there isn't currently a great cross-browser way to run some code when a value updates normally. So let's say that var num equals 42 is being shown somewhere in the view. If I change num to 43, the view has no way of knowing that that is changed. All we did is change a value. We didn't actually run any code. The way Knockout gets around this is by making it so you have to run a function in order to change any values. So if I want to change my favNum to 43, all I do is run favNum, and instead of passing in nothing, I'll pass in 43. When I do that, now favNum is 43. Now, the point is, I've run code when I ran this. favNum is a function. When favNum gets run, and something get passed in, it changes the value that's stored inside the model somewhere. And it runs some special code which notifies anyone who's using favNum, whether that's another model or the view. See, observers notify the view model when the model changes. And what's more, Knockout runs some extra code that figures out what parts of the view need to be updated when the view model has been notified. It's actually really, really cool. Back before, we had to call view.render anytime something would change. But Knockout is smart enough to know that when these things change here, certain other things need to be notified, and then eventually something needs to get re-rendered. So if you use normal values here, Knockout won't be keeping track of them for you. If you use observables, Knockout will keep track of them for you, and it will intelligently manage any views that need to get changed or other models that depend on our data that just changed. With our previous model view octopus organizational pattern, to make a number in the model, we would literally say var myNum equals 5. How would you make a variable in the model to store a number with Knockout? Go ahead and use an observable, and set the number to an initial value of 5. The correct answer is var myNum equals ko.observable (5). I'm here with Jacques, our lead front end engineer. Hi. Hi. So, documentation. Love it? Hate it? You really need it. You really need it? yeah. It's, it's not the best, it's not the most fun thing to write. it's. The most amazing thing when you start working on a project, and there is documentation. So, what about reading documentation? Reading documentation is a core thing that engineers do, all the time. So, if I were to give you an API, or a piece of software, or something like that, and asked you to work with it, and let's say that I didn't allow you to use documentation. Would your productivity, okay, and also let's say you are 100% productive before. Without documentation where would you be? Oh, I would be in the 20% range. I mean. Really? Yeah, we'll coz your going to have to parse, I mean, it depends on how big the code is. You know, I can sort of read through it and sort of figure out what's, what's going on, if I have access to that, to that code, if it's not just a black box. But even then, you know, that means I have to go through and fully understand the inner workings of what someone else has come up with. And without documentation, that's hard! That's a lot of time spent understanding something that could have been very easily handled with, this hands back this object. So, what would you say to students, who are taking our course, who are learning to read documentation? I mean, like, I, I know when I first started programming, I had a huge resistance to reading documentation, and furthermore, I felt like it reflected negatively about me as a programmer. Like, I don't already know this? I'm looking up string.split or something like that, which I use all the time. What's wrong with me? Absolutely nothing. I mean, it's, it's, programming, you know, we're, we're making, you're taking an idea about what you want it to do, and, you know, what you want your code to do, and turning into reality, right? And. Mm-hm. The nitty-gritty of what the fourth argument for this built-in API is, is not really an important thing, right? You know, and if it's something you use literally all of the time, it'll eventually get stuck in your head. And until then, just look it up. It's, there's, it absolutely does not reflect poorly on you. We look up stuff, all the time. And it's stuff from the most arcane randomness that you can think of, all the way down to, how are we going to split a string. Right? Hm. I mean, that, that comes up, and if you don't have it on the top of your head, if it's faster for you to go look it up than it is to sit there and try and type a bunch of things into the console, and figure it out, go look it up. So, it seems almost like it's like writing with English. So, if you're writing a paper, and you are looking up a word, for example, and you look it up again and again and again, eventually it'll, it'll get stuck in your brain. But the fact that you don't have it the second in time, doesn't reflect negatively on you as a human being, or as a writer. No, no, absolutely not. I mean as an engineer, your ability to, to be an engineer, to be an effective engineer, is not that you have everything committed to memory. If you use something enough, it'll be in there. So it's not memorization. Absolutely not. It's building with pieces, and then, if you don't remember how to use the pieces or the tools, then you look it up. Exactly, and I mean, if you were to hold up an engineer who knows every little nitty bit about some package, or framework, or whatever, and makes terrible programming decisions, versus somebody makes good programming decisions, and looks everything up, this guy is the guy you want on your team. Yeah. Yeah that makes sense. All right, so, don't be afraid to look things up. [LAUGH] It's important. Absolutely. Awesome, thanks Jacques. Mm-hm. In keeping with the importance on consulting documentation, I'm going to ask you to consult the documentation to answer a few questions. First off, Knockout has a special way of dealing with arrays of things. What is that called in Knockout? Observables, computed observables, smart arrays, observable arrays, collections, or magic unicorn hiccups? That's right. Magic unicorn. No, I'm kidding. The real answer is, observable arrays, although that would be funny. Your next question is ultimately, how do you use observableArrays differently from regular arrays? First, how do you create them? Now I'll let you read these three options. And your second question is, how can you add and remove things from an observableArray? The first answer is, by storing the result of a ko.observableArray() to a variable. And just like observables, you have the option of passing in a normal array as the initial state. And the answer to the second question is, by just calling the array methods, like pop() and push(), directly on the observable array. The developers of Knockout have made this very easy. You can treat observable arrays almost the same as you treat normal arrays, with the primary exception being how you retrieve values. What are the benefits to using observable arrays? Why do you think they exist? And what do they let Knockout do? Your choices are, Knockout will handle the array performance more efficiently than native JavaScript methods. The second is, Knockout will update the changed data in the view, rather than re-rendering everything. Or three, Knockout will render rainbows everywhere, which will distract the user from long load times. As much as I wish this would work, because it would make performance optimization so much easier. The actual answer is the second one. Knockout will update the changed data in the view, rather than re-rendering everything. This means if you only change one little part of your array, Knockout will know that only that piece has changed, and it won't have to re-render the entire view. Only the part that changed. One particularly interesting thing about observables, and observable arrays, is that they're actually functions. If we hop over into the console here, I can verify that this page has knockout by typing, ko, sure enough knockout is this object. If I make a new observable array I can say, ko.observableArray. And inside I'm going to pass it its initial array. Sure enough, that returns our observable array. Now I'm going to go ahead and make a variable, I'll call it foo. And now we can call console.dir on foo. Now before I run this, I just want to point that this observable array here, foo, is a function. I can validate that by typing just simply foo. And sure enough, you can see that it's a function. Now remember that in JavaScript functions are also objects. And if we extrapolate from that, we can infer that functions will also be able to have properties on them. Let's show that by typing console.dir foo. Sure enough if we open this up we can see all of this stuff on our function. Now as a side point this might look familiar. It's very similar to how jQuery works. If we go to jQuery.com, Inspect Element and go to our Console. We can type jQuery and we can see that jQuery is also a function. However, if we type console.dir jQuery, we can see we get this function with a bunch of stuff inside of it. What this means is we can run jQuery like a function just like this, or we can say jQuery.something. Now the same goes for Knockout. Our observable array, we can run it like this and get the value or we can go ahead and say foo., and I'll say push(5). When I push the number five into this array, it returns, just like push normally does, the total length of the array. And now if I run through, I can get back 1, 2, 3, 5, with four of them in there. So in this way Knockout and jQuery work similarly. Observables and observable arrays are actually functions with keys on them as well. Just like jQuery is a function with a bunch of keys and methods on it. Now many people don't know this, and they use jQuery and Knockout very successfully. But it's wonderful to understand a bit more about what's actually going on under the hood. Now we're going to spend some time building cat clicker together with Knockout. You can find the files I'm using at the repository linked in the instructor notes. Now, here's our out index.html file, but we're going to put that aside and open up app.js. As you can see, we're starting with absolutely nothing here. First, let's make a ViewModel so we have a place to put things. Now, if we only type this, nothing special will happen. We'll just end up with a function called ViewModel, but it won't ever get run. We need to tell Knockout to apply our bindings to this ViewNodel. Now, I'll go over what that means in more detail a little bit later. For now, let's just start our app by typing ko.applyBindings and a new ViewModel. Now let's hop over to our browser, hit refresh, and ensure that nothing pops up in my console. When I'm developing, I go back and forth a lot to make sure I don't run into errors. Now let's go back to our app. We need to put something inside our ViewModel here. For now, I'm actually going to put our model here in the ViewModel. Now, this may seem confusing at first. You may think, but Ben, aren't we supposed to separate things? Well, the most important thing for now is that the pieces are functionally separate. For simplicity in this example, we'll define our model stuff here inside the ViewModel. But even though the model is being defined inside the ViewModel, the functionality is separate. Now, in a few lessons, we'll see a good way to separate out our model data more cleanly, but for now, we'll go with this. So, what do we need in here? Well, we need the same fields as before, name, click count, image source, and, because we appreciate our artists, image attribution. And there's our model for a simple version of cat clicker. Now, what about our ViewModel? We obviously need an incrementCounter function. But if we look back at our previous code from the last lesson, you'll notice we don't need most of the functions we wrote before. For example, before, we had a getCurrentCat function, which allowed the view to get it from the octopus to get it from the model. We don't need that anymore because Knockout will handle the view to model and model to view synchronization for us. The only time we need to write ViewModel methods are when we need to actually change something ourselves. In this case, this.incrementCounter is going to set the clickCount to be itself plus 1. As you can see, this.clickCount with nothing in the method is getting our clickCount. We're adding 1 and then taking this whole thing here and storing it inside of this.clickCount. Effectively, what we've done here is say count plus plus. In this case, it's this.clickCount, and this.clickCount is a Knockout observable. Now all we need to do is make our HTML connect up with this. Let's keep working together and wire up the view. Now previously, when we were doing model view octopus, the octopus was grabbing on to these elements by their ids and then updating them whenever view.render got called. Now, Knockout doesn't actually need these elements to have ids. It just need us to put data bindings on them. Now, the very first thing I'm going to do is remove the ids. Removing the ids is not necessary, but I'm taking them away just for clarity. In a real situation, I might have a class on each of these describing what they do. That way, our CSS can hook onto it and style it and make it look pretty. So now, our h2, div, and image all have data-bind attributes here. First, let's talk about the h2. We want the h2 to be wired up with the name of the cat. In fact, more specifically, we want the text of the h2 to be whatever the name of the cat is. Knockout's binding for this is text: name. Whatever the name property is on the view model over in our JavaScript file, that's what the text of this h2 gets set to. And in fact, if we hop back over to our app, we can see there is the name right there. Its initial value should be Tabby. If I save my work and I hop back over here and refresh, we should see the name update with Tabby. Let's hop back to our HTML. This div here is going to be very similar. The text inside of the div is going to be a click count. Now, the image itself is going to be a little bit different. First of all, we know that when we click, we want increment counter to run. We also want the source attribute of this image to update as the source changes. In this simple example, it won't change, but we still want to use Knockout's binding system to do this. To put multiple bindings inside of a data-bind, just use a comma. The way you bind an attribute inside of Knockout is with the binding attr colon, and then an object literal here with source to whatever you want to bind it to. In this case, in app.js, it's called image source. If the image source observable were ever to change, then the attribute, source, on this image would change. Let's save this and go back to our browser and see if it works. Sure enough, the image pops up, and when you click, the number increments. Pretty cool. Now, once again, these bindings are the things that are connecting up the view and the model, and Knockout is handling all of the logic to make that synchronization happen. Knockout has another kind of model data object, called, a Computed Observable. Computed observables are really nice, because they can create a value when they're accessed, rather than just retrieve it from somewhere. One good example is fullName. That should take your first name and your last name, combine them together, and return it. Maybe if there's a middle name defined, it should add that in too. Now, it doesn't make any sense to store the fullName as an actual string here, because that's redundant. We already have all of the information we need, to figure out the full name. So, rather than store it as a string, why not store it as an action, as a function? So, that's exactly what we do. We store fullName as a special kind of function, and when you want to get the full name, you run that function, and it returns the first name plus a space, plus the last name. The great thing is, when all of your variables are observables, or computed observables, you can treat them all exactly the same. So, it's just as easy for us to use, but we get the benefit of having a data object that computes itself, based on other data that we're storing. Now that we've talked a bit about computed observables, for which of these examples would we likely use one? A list of cats, the full name for a cat based on the first and last, the number of clicks for a cat, the image URL for a cat, or the cat's title based on the number of clicks? There are between zero and five correct answers, inclusive. Let's take a brief moment to look at the big picture of what we've learned. Now, we've learned a whole bunch of new terms so far. Under models, we've learned about observables, computed observables, and observable arrays. Now, we really haven't learned anything new regarding the ViewModel. It's just our functions that we need to run sometimes. But we definitely have learned something new about our view. We've learned about bindings. Now, just as a quick review, our observables are the variables that we're storing in the model. But rather than them being simple variables, we're utilizing Knockout's observables functions in order to keep track of when things change. We have computed observables, which are computed whenever they're accessed based on the value of other variables. Our observable arrays are very similar to observables. We want to use those whenever we have repeating elements, such as multiple cats. Then if you add a cat or remove a cat, Knockout will know which one changed and it will re-render the view automatically. And speaking of the view, bindings are the things that tie this together with our models, via our ViewModel. Declarative bindings are the data-bind equals blah blah blah. Now that we've done this bigger picture review, let's go ahead and dive into computed observables and see what they're like in practice. Now we need to figure out how to use computed observables to add functionality to our application. Specifically, to add a cat name feature and a cat title feature. In order to learn how to use them, we'll take a look at the documentation together. Now first off, every librarian framework has its own documentation and libraries without documentation are not very effective to use. So, if documentation is missing or especially poor, nobody will want to use the library, and it won't take off. Chances are if you've heard of a library before, it probably has pretty good documentation. Now Knockouts documentation, is actually more of a series of articles here, rather than a traditional documentation site. That's okay though because most of the information we need is here. If you find the documentation lacking there is probably a blog post by someone else illuminating the thing you're looking for and to figure that part out I usually start with a Google search. Now let's take a look at computed observables. Now Knockout's documentation gives us a pretty good first explanation here, introducing the concept of computed observables. In this case, they're saying if we have a firsName and a lastName, both observables, Bob Smith, how do we get the fullName? Well rather than putting the joining logic Bob plus space plus Smith. Everywhere, all over the place, instead we can define a computed observable. Computed observables are awesome, and they're pretty simple to implement in Knockout. All you have to do, is run ko.computed(), passing in the function that computes what you want. And an optional suggested argument for the thing that maps to the this keyword inside that function. Basically, because of the way ko dot computed works, when we pass in this for the second argument, that ensures that we can use the this keyword inside the function. And this means that we can use our other observables, because we have access to the this that they're on. So again, in summary, this.fullname equals ko.computed, and then a function which simply returns firstName added to space, and then added to lastName. Now we can use it like any other variable, this.fullName pretty cool. Now I'd like you to implement levels for your cat. Let's say that new cats have a level of newborn cat. After ten clicks, they get up to infant. Go ahead and use computed observables to add cat levels to your application. Now remember, you'll also need to add something to your HTML so you can show it. Hey, I'm a pretty fast clicker. I already got up to 110 here. Can you do better? Here's another challenge for you. Implement an array of nicknames for your cat and use a control flow structure to display them all. Control flow structures in Knockout are ways of doing things programmatically in your view. They're similar to if statements and loops, but in your bindings in the HTML. For example, what if you could have a bunch of nicknames and you want to put each one in its own div? In my example here, I've put all of my nicknames in their own li element. Now, if you wanted to do that, you could use the foreach binding to render each one of them in that particular way. Now also, as with anything new, the phrases that Knockout uses can be intimidating. Control flow sounds a little bit scary. It's just a fancy word for things that are non-linear, like loops and conditionals like if statements. Now, this time, I'm going to ask you to figure out how to actually implement this. Open up the Knockout documentation and click on that page right there. Read the page that talks about the foreach binding and have at it. Now, actually before you have at it, remember to commit your code in a repository at each step so you can always reset if you code yourself into a corner. And if you do get stuck or, for example, aren't sure how to get the actual array item into the bindings, read the documentation more thoroughly. All the answers you need should be there waiting for you. When I work with data-bind in Knockout, I often get it a little bit wrong, and sometimes it feels discouraging. So, if that happened to you during this exercise, it's not you. It comes with the territory. And the best programmers can keep their chin up and keep working at it despite things breaking. Also, your solution may look different from mine. That's also okay. There are many ways of doing this. So, look at my solution more for inspiration rather than for the right answer. That said, here's my solution. First, I added an observable array in my ViewModel. I also chose some of the cutest nicknames ever, Tabitha Tab Tabby Catty Cat. Now, in the HTML, as you can see, I've added a div down here for our nicknames, an h3 to make it look pretty, and I made a ul with a foreach binding. This will take this li and do it again and again and again for each of the nicknames. And these li's have a text binding of $data. Now, I used $data because I had to get to the actual data in the array that we're looping over. Now, this is great for simple things like nicknames or months or lottery numbers where the data is super simple, just a string or a number or Boolean for that matter. Now, if you filled your observable array with objects on the other hand, you would write the name of the property that you wanted out of the object. This is great when you're looping over objects that are a bit more complicated, maybe objects that represent people or products. But in this case, it's just a bunch of strings. Coming up soon we'll be adding multiple cats, so we're going to get ready by moving the model to a separate area. Because if we left the model where it is in the ViewModel, we'd be putting all of this into a for loop, and making it again, and again, and again. There's gotta be a more separated and readable way to do this. All of this code that I'm selecting here should move into a special function which will make us new Cats. I'm going to cut all of it. And wow look at how simple our ViewModel is. We'll call this function Cat with a capital C. As you can see, all of the cat logic is here inside of our Cat function. And our ViewModel down here is super, super simple. Now, we do still need to actually make this cat. I'm going to store our cat in a currentCat variable, specifically, a Knockout observable. And instead of passing in an object literal, like this,. I'm going to pass in a new cat and that should work. Well, almost. We actually just changed where our cat lives. Now instead of finding our cat's properties right on the ViewModel, we need to look inside of the currentCat variable. So over in our html, we need to make a couple changes. So here in our html, we need to change all the data-bind properties that are looking for cat-related properties. They all need to be currentCat.name, currentCat.title, et cetera. That's because, once again, our cat is not living on the ViewModel anymore, our cat is living in the currentCat observable. And remember, we put the parentheses here because currentCat is actually a knockout observable, which is a function. In order to get the currentCat value, we need to run that function and it will return the value to us. Let's hop over to our browser and hit refresh. Sure enough, everything seems to work just fine. We have our nicknames, our cat image, and all of this. If we try to click, however, we get an uncaught TypeError, undefined is not a function, line 34. In our code, app.js, for me line 34 is this right here. Now what's the problem with this? What is this.clickCount? Well, this represents the ViewModel and there is no clickCount on the ViewModel. Remember, clickCount is now living inside of our currentCat. In this case, I need to save this.currentCat.clickcount is going to be this.currentCat.clickcount plus one. And now if I hop back into the browser and I hit refresh, sure enough my clicking works just fine. Go ahead and make those main changes. First of all, moving your cat into a separate cat function. Secondly, updating the bindings in your index.html file. And finally, updating our increment counter so that way it can get the click count properly from the model. Go ahead and make those changes. Now it's your turn again. Take a look at width in the Knockout documentation to see if there's a way to make a reset HTML changes a little bit simpler. We want to avoid seeing current cat again and again and again and again in our HTML. Now this one might require a little bit of extra research. You'll have changes here in your HTML and also likely in your app dot js in the increment counter function. You'll find the documentation page for with in the instructor notes. Take a look at that documentation and their examples to wrap your mind around what with is for. And if you're having trouble with your bindings, I'd also recommend giving Knockout's page on binding contexts a read. That link is also in the instructor notes. First let's dive into the HTML. I took the entire div that surrounds our cat, and I said data bind equals with current cat. That means that all of the data binds inside will be relative to our current cat. So when we say h2 data bind equals text name, we're really saying current cat.name. Same with title and click count and image source and nick names. That's a pretty simple change. However, for the click binding here we need to say increment counter and run it on the view model. Not on current cat, current cat does not have an increment counter function. If you look through the documentation you'll find that with, with, you can use $parent, to get up out of the scope. Or in this case, instead of the word, scope, knockout calls it a binding context. Now the incrementCounter method is the real main thing that need changing in the app.js. Now it used to say this.currentcat.clickcount, and then this.currentcat.clickcount plus 1. Now this is the tricky part. Here's what it looked like previously. When we would click on the cat, we were clicking on the view model binding context. We hadn't created a new binding context with width binding yet. So when we clicked on the image, we were effectively within the binding context of the view model here. But when we added the width here, now when you click on the image you are within the binding context of currentCat. So here in app.js we don't need to say this.currentCat anymore because we're already in the currentCat binding context. Instead we can say this and this represents the binding context of the current cat. So this current cat binding context.click count. Now that's one way we could have approached this. Let me show a different way. So once again this is what we had before. This .currentCat.clickCount now this we've already established just now represents the currentCat's binding context because of the width in our index.html. So rather than say this, the currentCat context, we could instead say var self equals this while we're here in the view model. Then we can use self here and here. Now we're not using this which represents the binding context when you click on increment counter, we're talking about self which represents the view model here. Sure enough that also works. Now neither of these two methods are better or worse than the other, but it is important to know about this trick here. Whenever you want to access the outer this. In this case the view model, you can store it somewhere. In this case I'm storing it to self. And now inside of functions that are nested, I can say self.foo, self.var, self.currentCat. Now my special this keyword isn't messing me up. Self is always going to be defined as the view model, because I defined it right here. Keep this trick in mind. Some other developers write var that equals this. And then they use that throughout their entire function. But whether you call it self or that, it's a very good method for keeping a pointer, keeping a way of accessing our outer this, and not getting confused by our inner this. Now if you want to take a minute right now and go and refactor your code feel free. Remember that neither of these two approaches here are right or wrong. Both are just two different ways of solving the same problem. Now, our Cat function isn't very smart. It makes the same cat every single time. I'm going to refactor it a bit so we can make all kinds of cats. Now, right now, when you call to make a new cat, it just runs this function and does all of this stuff. But we're not passing anything into it. Let's pass an object literal into our Cat constructor function. I'm going to call it data. Now, if someone gave us, say, an array of cat data, we could easily make those different cats by saying new Cat and passing an object literal. See? Thinking ahead is good. Now let's go through the steps to make this work. Now, before we tackle this part here, let's tackle what gets passed in. Down here when I say new Cat, I'm going to pass in that object literal. Later on, we'll actually have multiple cats, so we'll be doing this again and again and again for each Cat object. Now here are the various properties for the same cat that our Cat function up above was making over and over again. Now we're passing them into the Cat constructor function. Now up at the top, instead of actually setting these values like this, we're going to actually set them based on the data that gets passed in. So, this.clickCount will actually be equal to data.clickCount. >From the object literal that we passed down below into here, we'll set the clickCount of that to the cat we're creating. We'll do the same thing for all the rest of them. Now, this.title stays exactly the same because for every cat, if the clicks are less than ten, the title will be Newborn, less than 50 is Infant, etc. That's hard coded into the cat. And now, rather than having our data actually explicitly set here, we're setting the data down here where we create these cats. Now we're ready for more cats. Let's add them in the next video. Now let's add those other cats. First I'll copy all my cat's from our last cat clicker. And I'm putting the cat data at the very top of this file. Now I've put the cat data at the top of the file, but I also could load this data from a server. And when the list came back from the server, I could add them to the application. That'd be trivial to implement, and you can do it for extra credit if you want. Now what am I going to do with this array of cat objects? Well, down here in the ViewModel, I'm going to want to create cats, and I'll want to store them in an observable array. I'm going to call it, catList. Now you'll notice I'm not passing in the array at the top of the file right into this yet. That's because I need to take that data and make a new cat out of each of those objects. I'm going to loop over all of our initial cats. And for each one of the cats, I'm going to put it into the cat list. Here we are doing a very similar thing as we did. Here, but instead of passing in an object literal, we're passing in each of the cat items in that initial cat array at the top. You'll also notice we're using the var self equals this trick. That way if we say this dot cat list, we don't end up getting confused with what this function believes that this keyword maps to. Self is always going to map to the view model. So self.catList is going to map to this cat list. This observable array right here. Now I am forgetting one other thing which is the nicknames. I'm going to grab our nicknames from tabby up here and I'm going to put them in our initial data. I'm also going to add a nickname from Tiger to Tigger, Scaredy to Casper, Shadow to Shooby, and Sleepy to Zzzzz. Now my initial cat data has nicknames. And in the ViewModel, I'm looping over all the initial cats. And pushing a new cat with each of the cat items into the cat list. Pretty good. I'm also going to change this right here to this.catList, item zero. That way we're not creating a new cat for the current cat. Here we're making all of the cats we need, we don't need to create another one. We just need to access the 0th element in the cat list or our first cat. Now we have a bit more work to do. First, we need to make all the cats show up in a list. That should be a list of your cats on the screen that users can click on. You should be able to do that entirely in your HTML with bindings. Second we need to make the cats in the cat list clickable. When you click on the cat name in the list, it should change the current cat observable to the new clicked cat. That means we'll need to make a function for setting the new current cat. Those are the two main things that you still have to do. Make the cat show up, and make the current cat change when you click on one of those cats on the list. Now take your time with this one. Don't make a bunch of stabs in the dark. The amount of code you'll need to do all of this is actually pretty small, so take the effort to really try and understand what you need to do. And what tools you have to do it. Oh, and once you're done, give yourself a high five. You deserve it. All right. So let's go through the changes that I'm making. So, first of all, all of these cats are going to be in an unordered list, and each one of them will be a list item. Now, how do I make an li for every single one of our cats? I can say ul data-bind is foreach: catList. That will make an li for each one of the items inside of catList. And inside of the li, I'm going to add data-bind as well. It's going to have text as the name of the cat. If I save this and refresh it in the browser, let's see what happens. And sure enough, we get the list of all of our cats here. Pretty good. Now we've got our cats showing up in a list, all we need to do is make the current cat change when you click on one of them. That second part is a little bit more difficult. We know that we need a click somewhere in here. We don't necessarily know what it will be yet. But we want a click on this list item to somehow wire up to something inside of app.js. Now like I said, bindings can be a little bit difficult because it's a little bit more difficult to visualize where you are, what your binding context is. I might normally feel inclined to do something like this, on click, setCat. And then in our app.js, down here in the ViewModel, as it turns out, that's not going to work. Here's why. When you click on this, it looks for setCat within this binding context, which is within the cat itself. What we need to do is get up outside of that binding context to the view model. The way we get up out of a binding context is using $.parent. I'm going to save both of these, and I'll put a console.log statement in here just to make sure. If I go back to my browser here and I refresh, sure enough now, when I click on this, I get console.logs of hi. Now, rather than running console.log, all I have to do is update the current cat. To access the current cat, I'm going to use self.currentCat. Remember, self is referring to the ViewModel and that is where currentCat lives. And what are we going to set it to? Well, if you look in the documentation for click, you'll find that when you click on something and it runs a function, it passes in the object you clicked on, specifically the model we're talking about. So when setCat gets run, and the clickedCat model gets passed in, we're going to set the currentCat to the clickedCat, to the one we just clicked on. Let's save this and hop back into the browser and see if that works. Now if I click on Shadow, sure enough, it changes. And if I click, you can see that Shadow has his own counter and Tiger has his own counter, etc. So now we've made the cats show up in a list. We've made the current cat change when you click on one of them. I hope you've given yourself a high five. Although giving yourself a high five is kind of just a clap, so go find someone else and give them a high five. You just built together with me a pretty amazing app, and a lot of it was driven by you doing it yourself, going through the documentation, learning things on your own, and trying things. Seriously good work.