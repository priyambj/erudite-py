In this final lesson you will add additional OAuth options to your application. More specifically, log ins for users with Facebook accounts. Adding more OAuth options expands the potential amount of users that can use your site with existing accounts they already have. Let's walk through adding Facebook log ins to our web application, and then talk about adding any other OAuth 2 providers you might like for future applications. So, this may come as no big surprise by now, but the first thing we must do is register our app on Facebook in order to create a client ID and client secret. Go to developers.facebook.com and follow the steps to create a web application. Once the app is registered, I'm going to manually create a file called fbclientsecrets.json to store these secrets. I will provide a skeleton.json file, where you can place your app id and app secret in the instructor notes. The next step is to add the client side functionality to login.html. Facebook has two options for doing OAuth login. Import the Facebook JavaScript SDK, and use the Facebook functions. Or construct your own Auth manually. Since our web application only uses JavaScript from the client side. I will create an implementation that uses the SDK to create a log in button and retrieve the short lived access token. Similarly to the Google Plus function, I will create an Ajax call to send this token to my server. On the server side I will manually trade this token for a long lived token with Python. So, let's dive into the code. Inside the login.HTML I will first add the code to load the Facebook JavaScript SDK, as shown here. Be sure to substitute the value here with the code for your APP ID. This next function calls the SDK asynchronously, so that the rest of the page can load without it. The code here uses the Facebook SDK in order to create a Facebook log in button. I can write whatever I want inside the Facebook button here. This button also specifies the scope of authorization my app wants to request. When my button is clicked I'm also going to invoke this send token to server method. So now we'll create a send Token To Server method here inside of one of my script texts. This function here retrieves my short-lived accessToken. Here, I'm just showing how I can use the Facbook SDK to also make API calls. Now I sent the access token to the server via Ajax, along with the state value. I will name the route fbconnect, which I will now implement on the client side. Inside my project.pi file I will create a route and function called fbconnect. Similarly to my Google login, I will verify the value of state to protect against cross-site reference forgery attacks. I will then exchange this short-lived token for a long-lived token here. Notice that I have to send my app secret along to Facebook to verify my server's identity. This token includes an expires field that indicates how long this token is valid. Long term tokens can last up to two months. I'm going to strip the expires tag from my token since I don't need it to make API calls. If the token works, I should be able to make API calls with my new token like so and populate my login session. Facebook uses a separate API call to retrieve a profile picture. So I will make that call separately and populate the login session with the URL for the user's profile picture here. Now I can use the exact same code from my Google login to retrieve a user or create a new one. And go ahead and send that welcome splash screen that we had before. In order to reject the access token when the user's ready to log out I will create a FB disconnect function like so. If the request is successful then I will depopulate the login session accordingly. But let's take a second to re factor and make a disconnect function for easier expansion to other providers. I will create a new value in login session called provider and set it equal to Google and G-Connect and Facebook inside FB-Connect. Now when I log out, I can just call this disconnect function, figure out which session I'm logged in under and then log out accordingly. Now that I have a login and disconnect function, I'm going to add the following code to my header template. Now a link to login appears if the user is logged out. And a link to disconnect appears if the user is logged in. Whew. Well that was a lot of code, but let's see how it looks now. I'll fire up my server and visit my restaurants page one more time. Now when I login, I have the option to login with Facebook or with Google. And logging out is just a simple click of a button. Pages that don't belong to me I cannot edit. But if I'm logged in and I'm the owner of a page, I do have the editing option. We've successfully added two O op providers to our menu application If you would like to add other OAuth providers, the first place to start is always the developer page of that provider. Implementations may have slight variations like we saw between Google and Facebook. But the overall flow to obtain, verify, and use tokens for APA calls should be the same. I will provide some helpful links on a few other OAuth providers in the instructor notes. You've made it to the end of this course on implementing OAuth 2 for web applications. Hopefully this class has provided you with the tools and resources necessary for going out and implementing logins on your own web applications. However we have only discussed the tip of the ice burg. If you're interested in learning more about OAuth or web security in general. I highly encourage you to check out some of Udacity's awesome courses, as well as some other links that I've provided in the instructor notes. Thanks for watching, and when it comes to web security, always make sure you play it safe. [NOISE] Hi, I'm Lorenzo. And welcome to Authentication and Authorization. In this class I'll be your instructor as you learn to add security features to your web applications. Allowing users to log in on your site using OAuth 2 providers. By the end of this course you will not only have an understanding on how to securely implement log ins and permission systems, but also have a basic understanding of how web security works. And some potential things to look out for when exchanging sensitive information across the web. To accomplish this goal you will be provided a restaurant menu application. If you completed the fullstack foundations course, you've already created a version of this application. You will make the app secure by restricting access to unauthenticated users. This means that you'll be able to share it safely with the world as part of your portfolio. You will also have the knowledge and hands on experience to implement similar systems on your future sites. In order to get the most out of this course, you should be familiar with Python and the Flask web development framework. A basic understanding of JavaScript and using jQuery to make Ajax calls will also be needed for this course. If you'd like to brush up on any of these topics, check out some of the links provided in the instructor notes. We will be using Google+ and Facebook sign ins for this class. So that means you'll need accounts on both of these sites in order to do the exercises. If you don't have these accounts links are also provided in the instructor notes. In the first lesson of this course I will discuss some of the basic concepts of web security. Including the difference between authentication and authorization, and some of the related security concerns that they address. You will also learn the necessary flow of information for all security. And play with some of Google's OAuth features in the Google OAuth2 playground. [SOUND] In lesson two we will go more in depth on the different types of OAuth2 options for clients and servers, implement logins and logouts, and secure our menu pages for authenticated users using Google Plus sign-in. [SOUND]. In the third lesson you will create a local permission system. Protecting the data of each user from being modified by other users. [SOUND] And in lesson four, we will explore other oauth2 providers such as Facebook and GitHub to allow multiple sign in options for our users. [SOUND] [NOISE] To better understand what you will be learning, I would like to point out a few similar topics that will be outside the scope of this course. Cybersecurity and cryptography are very complex topics that form the foundation of web security. OAuth handles a lot of this complexity for us. Therefore, this course will focus on implementation more so than the mathematics and theory behind this technology. In a bit, we will see some of the challenges of implementing your own web security to better advocate the use of trusted frameworks like OAuth 2. In this course you will leverage existing OAuth 2 providers such as GitHub and Google to allow users to securely sign in to your web applications. But we will not cover creating your own OAuth 2 server. If you're interested in more details on these subject though, please feel free to explore the links in the instructor notes Authentication and authorization are the two main principles of web security we will cover in this course. So let's first talk about authentication. Authentication is the process of verifying that you are who you say you are. If you've ever logged into a website or service, you've used authentication. Actually you've probably used authentication outside of your computer as well. For example, we can verify a person's identify by comparing a trusted document, such as a license or passport, with the physical appearance of that person. If the picture and information match with the person standing in front of us, we authenticate that they are who they claim to be. Of course, this isn't a foolproof system, but for many use cases, the human eye if sufficient at recognizing if a picture and a person do not match. Even in the scientific world there are also ways to ensure the authenticity of artifacts. For example, you can use carbon dating to ensure that a fossil is indeed 300,000 years old, and not just the skeleton of some goldfish that died two years ago. An example of authentication on the Internet can be seen when we visit verified websites. If I land on a page that has a secure connection, such as PayPal.com, this green icon appears on the page. This indication is the browser letting us know that the website has been verified through a trusted certificate authority. This means that the browser recognizes this web page and can verify that it is indeed the real PayPal.com, and not an impostor page. But most relevant to this class is a website user authentication system. With a unique user name and secret password, you are proving to a website that you are indeed who you say you are, granting you access to the website. While the identity information in many cases can be public, like your email address or user name, the password is something that only you should know. And since only you should know that it serves as proof to verify you are who you claim to be, the owner of that account, and therefore authenticated and logged in. It's also important to note that whenever there is a process of proving the truth of something, there are always people trying to cheat the system. This is why there are many security concerns you have to be aware of when using, and even more, when implementing authentication. A lot goes into implementing authentication systems. As you're creating your own restaurant menu application it's important to consider the following aspects of web security. Requiring strong passwords from users prevents a hacker from simply guessing a password and gaining access to private information. We use strong encryption by implementing a mathematical algorithm to make information virtually impossible to decrypt by someone who doesn't have the right key. Ensuring secure communication between client and server to make sure your private information does not become public at any point along communication. Securing password storage in an encrypted database, such that no one can gain access to your users' passwords. Implementing password recovery, so that if a user forgets their password there's a way to create a new one quickly and securely. Adding two-factor authentication, a highly recommended extra layer of security that requires a password and a special key to access private data. And including protection against man-in-the-middle attacks to make sure there is no malicious system interfering with the data being transmitted or pretending to be a trusted website. >From the problems listed here, what do you think are the three most important? Great job. It's hard to prioritize just three security features for a website, but luckily with Oov, we won't have to compromise. All of the security features discussed in the previous video are important, but the implementation details are different for each one. Some have to be implemented on the client machine, using the browser and JavaScript, and others need to be implemented on the server. And sometimes, security features must be implemented on both endpoints to properly function. As a full-step web developer, it's your job to make sure security is properly implemented in the right place. Look at the following security features below. Decide if they should be implemented on the client side, server side, or both. If you're unsure, check out some of the resources in the instructor notes. Requiring users to use strong passwords can be implemented in different ways. You can check for it only the client side with JavaScript, but that would be very insecure. As the client could work around it if they figured out a way to mimic the HTTP request sent from the browser. If we make sure that an insecure password cannot be saved in the server, then we effectively prevent our user from making weak passwords. But they won't figure that out until the server responds with an error. We could implement a solution that is user friendly and secure, however, by doing both. Informing the user on the client side if their password is strong or not. And then preventing weak passwords from being stored on the server site as well. Securely storing passwords has to implemented on a sever site in the database where the passwords reside. And protection from man in the middle attacks has to implemented on both sides. Since sensitive information can be coming from both the client and the server. Let's see in the next video how using third party authentication simplifies implementing these concerns for us. So we see now that there are a lot security concerns to address regarding authentication if we implement it ourselves. But, chances are, someone else has already solved these problems before. Developers have created free and open solutions we can use to authenticate users on our web applications, simplifying the process of adding web security without having to reinvent the wheel with each web application. Instead of authenticating the user by yourself, you could ask a trusted third party to take care of the complexities of user authentication. Then the third party can communication back to your application that the user was authenticated against their third party security system, allowing your application to not only securely interact with the user but share data between your app and the third party authenticator for a more streamlined user experience. As an app developer, this allows you to worry less about the authentication part, and spend more time and effort on your application logic instead. Here, let's do a quick example about how third-party authentication works. Let's say I created a web application and want to allow my users to be able to log in with an existing third-party profile, like Facebook or Google. So I don't have to create another username and password just to use my site. By implementing third-party authentication, communication between all involved parties must happen. As a user, you must first communicate with my application, which will then take you to the third party's login to verify your identity. My application also verifies it's identity with the third party app and waits for a confirmation of user trying to log in. The third-party app requests to share your information with my application, and then allows my application to access your third-party account. Once my application receives confirmation from the third-party app, you are now logged into my site. My application may also have access to certain things in your profile, like your profile pic or latest status updates, to make your user experience even more complete on my site. But wait a second, you might be thinking, hey, not so fast, web app. Just because I want to log into your site, doesn't mean I want you to have access to my entire Facebook profile, especially without my knowledge or permission of what you're using and when. And you'd be absolutely right. Clearly, if there's some third party involved you want to know what kind of information is being shared about you. This is where the concept of authorization comes in. Let's talk about that now. If authentication asks, are you the person you claim to be, authorization deals with the issue of, do you have the right to the resource you are trying to access? When you're trying to gain access to an exclusive or restricted area, having the right kind of authorization is what will get you past the door. Even if you can effectively verify you are who you claim to be, sometimes that just isn't enough if you aren't on the VIP list. So being authorized means that you have been granted the right to do something. But in the context of user login systems, authorization can also be used to authorize some third party to do things in your name or have access to some part of your data. And this is what happens when you use third party auth providers like Google+ or Facebook. The first time you log in, they will ask if you want to grant the initial website access to some of your data, like a unique ID or email address. The same principle applies to mobile apps. When you install them, they ask for permission to use certain phone functions, and you can then either allow the installation to proceed or not. Another example of authorization is the access control in an operating system. Even after you are authenticated and logged in, you cannot do everything. There are certain things that require passing additional authorization checks. Authorization is what can allow users into an application, while still protecting its most valuable assets. In many cases, authorization happens after authentication. But it's important to know that these two concepts of security can happen disjointly as well. I will provide a few examples of some ways authorization can happen without authentication. If you find a key to a club's back door, you can get in without showing your ID because the lock doesn't care who you are as long as you have a key. Coupons and discount codes are a great way for shoppers to save money. The possessor of one of these coupons is authorized a discount, many times without having to identify themselves in any way. Dropbox and Google Drive support sharing a file via long randomized URLs. Anyone who possesses a link can access the file without authenticating an identity. But people who do not possess the link cannot access the file. But the link can be shared over and over again without the consent of the original creator. Logging in as root to a UNIX system doesn't authenticate you as a particular user, just that you know the root password. That's part of why it's considered more secure to disallow direct root login and use sudo or su instead. So someone has to authenticate, and their login as a particular user can be logged. Some web systems grant an authorization cookie once a user has been authenticated. A cookie's just a code that a browser can use as a pass to access private data. A browser with a cookie has authorization to specific user information without having to log in with each request. If you steal a cookie then you have access to the user's files without knowing their authentication credentials. This is called session hijacking. If you're curious about session hijacking works and how to protect your sites from such an attack, some links are provided in the instructor notes. Logging into a Unix system checks your user name and password against a special table of user names and passwords that can only be read by the group user. Group authenticates you as a user, and logs you in to the machine. Once you're logged in, if you attempt to access a file, this is when authorization is at play. Before you can read or write a file to a Unix system, the operating system checks to see if you are authorized access to that file. This isn't authentication because since you are already logged in, you do not have to authenticate yourself again to access the file. If you have the right password to a zip file, you are authorized to open it without having to identify who you are, so this is authorization. When you cross a border into a country, you must first present a passport to identify who you are and what country you are from. So that's authentication. Although, between some countries, a passport is sufficient for entry, many countries require a visa for entering another country. The visa can specify the things you can do, like work or study, and how long you're allowed to stay in the country. So this is definitely an issue of authorization. The most often used standard for authorization currently is OAuth. It is an open standard that was specifically designed to be used on the Web with HTTP. As you can see, there are many service providers that use OAuth. Another popular standard that you may have heard of is called OpenID connect. This is just a technology built on top of OAuth 2.0. Most big providers have adapted to use OAuth version 2, and that's what you will use to connect to Google+ and Facebook for your web app. Let;s talk briefly about some of the pros and cons of using third party authentication and authorization. If you use third party authentication, authorization, you don't have to think about how to encrypt and store user passwords. We can just let the OAuth provider worry about that. Another bonus is that, users don't have to fill in another form to create an account on your site. Less friction for signing up should hopefully lead to an increased number of users on your site. Also, it means that users don't have to remember another password for your site, and you don't have to keep their password secure. That means if your site gets compromised, you didn't just leak your users' passwords to the attacker. A neutral issue to point out is that users need to have an account on a third-party provider site in order to log in to your site. If they already have an account such as Google or Facebook then that's great. They can quickly be signed into your app with just a few clicks. But if they do not, then there's an extra step of making an account they may not be willing to go through first before coming back to your site. For this reason, you want to support login via sites that are very popular and already have a lot of users. Having Google and Facebook login is a good idea, and can be beneficial to you and your users. But it's important to make sure that you're using all providers that hopefully already cover a large portion of your potential client base. So there's a strong case for using third-party providers to store user credentials and then use that for your own site. But there are also some downsides to this approach as well. Maybe some of your users already have a third-party account but don't want to use that account on your site for privacy concerns. Most people don't like using apps that could potentially post to their social media networks on their behalf. This is an important reason to keep the OAuth scopes. The resources you request permission to access to a minimum. And request access only to things your app actually needs. Just because you're authenticating with Google doesn't mean that you have to ask for permission to mess with all the users Google resources and information. And even though you can authenticate with Facebook, it would be a good practice to let the user know you're app does not have the authorization to spam all of their friends. If you're going to create a web app that works completely offline, or under intermittent internet connections, a local authentication system may be a better option. The security for most OAuth providers is pretty good, but maybe it's not enough for the application you're creating. If you need the ability to change the requirements for password strength, or implement your own form of two-factor authentication. Then, third-party authentication may not be the best option. These are all cases where you might consider creating your own OP system. However, remember, that if you do decide to do it yourself, you'll need to address the many security challenges to make sure that both your servers and your user accounts cannot be compromised. Google has created a web application where developers can test making API calls for the Google suite of products. Let's walk through how to use this Playground, and then you'll have a chance to practice using it on your own. Visit developers.google.com/ofplayground and follow along. Once you login, you'll see a layout like this. Here on the right hand side, we have a list of all the options of Google products we can use to make API calls using OAuth. Let's go ahead and select Google OAuth 2, API version 2. Here, we're give a list of URLs, with descriptions of the APIs that they implement. Let's select userinfo.profile and see what that does. We now must grant authorization from Google OAuth Playground to use this API. The app is given an authorization code that it can exchange for access and refresh tokens. Clicking here initiates this trade of a code for tokens. And we see that we are granted an access token for about 3,600 seconds, eh, which is about an hour. Now, using the access token we can make calls to the Google+ API server. Here we can see a list of all the possible operations we can use. I will click the V2 user info option, and then go ahead and send off the request. Here I can see that Google+ responded with a JSON object, complete with my name, picture, gender, locale, and a link to my Google+ profile. If I click on this link for picture, I can see that it is indeed my account that it's connected to. Now, it's time for you to play in the OAuth Playground. Explore some of the other options and data that you can retrieve using OAuth and the API functions. Depending on the products you have tied to your Google account, you may be able to retrieve information for more of these accounts. Share your findings with some of the other students. Congratulations, you've reached the end of the first lesson. You should now have a better understanding of how OAuth works and some of the challenge to address before implementing security on a website. In the next lesson you will add login functionality to a web application with Google+. See you there. Now that you have a basic understanding of authentication and authorization, it's time to see how OAuth 2 makes it all happen. In this lesson, you're going to learn about the different types of OAuth implementations, also known as OAuth flows. And then, you'll use one of these flows to add security to an existing web application. The term flow in web security refers to the way information is exchanged between a client, server and OAuth provider to ensure secure communication across the internet. The specifications for OAuth 2 provide a lot of flexibility for developers to implement a security flow that works best for the project at hand. OAuth allows for a flow that can happen on the client side. This means that all of the code to authenticate the user is initiated via JavaScript from the user's browser. This implementation is very useful for single-page browser-based web applications. OAuth also supports mobile authorization, such that mobile device apps can authenticate and gain access similarly to a browser. Another possible and very popular flow is on the server side. Server side flow allows the server to obtain an access token to allow the server to make API requests on behalf of the user. The user has the option to set a timeout or revoke access to these tokens at any time. Each of these implementations has various pros and cons. Client side authentication is quick and easy, but a lot of trust is placed on the browser or mobile device. And the server cannot make API calls to the OAuth provider on behalf of the user. Server side implementation gives more power to a server side application, but the server is now responsible for securely implementing session checking for its users and secure storage of these access tokens. Choosing the right OAuth flow for an application really depends on the specific needs of a particular application. If you are interested in learning more about each of these flows, I have provided some documentation in the instructor notes. Google+ uses a hybridized flow for logins that requires authentication to happen on the client, but allows the server to make API calls on behalf of the client. This lesson will focus on the design and implementation of this hybridized flow. Google strongly recommends using a hybridized auth flow in order to take advantage of all the benefits of a Google Plus sign in. Let's see how this flow works. A user opts to log in with the Google account, and is redirected to a Google Portal for granting access to your application. The user authorizes your app on the client side using the JavaScript API client. The Google server sends a one-time code along with an access token back to the client. The client then sends this same special one-time code back to your server. Then your server relays this one-time code back to the Google API server. And in return, your server's given an access token from Google, enabling it to make its own API calls, which can be done even when the user is offline. This one-time code flow has a security advantage over a pure server side flow. This is because, with one-time codes, Google provides tokens directly to your server, without any intermediaries. Even if a one time code is discovered, it is extremely hard to use without your application's client secret. A client secret is a special code Google issues to verify your application. You will make a client secret in your first app in just a few minutes. In the next few videos, I will show you how to implement this flow on your restaurant menu application. If you have already taken full stack foundations, you're familiar with the restaurant menu app that you created by the end of this course. Here in this course I have that same project with some added bootstrap and styling to make it a little more aesthetically pleasing. In this lesson, you'll add the Google OS log in to this web application. In the instructor notes I provided some instructions on downloading and running a copy of this code on your own machine. Before we get started coding, we must first create a client ID and client secret with Google in order to be able to communicate with its API libraries. In your browser, visit console.developers.google.com. And log into your Google account and follow along. Once you're logged in, go ahead and click the Create Project button. Let's name our project Restaurant Menu App. Google automatically creates a project ID for you. You can change this project ID, but it needs to be unique. So let's go ahead and leave it as is for now. Let's click Create. And when Google's created your project, it'll automatically take you to the Project Dashboard. Go ahead and click APIs and auth on the left-hand menu. Then select Credentials. In the OAuth 2.0 section go ahead and click Create new Client ID. Make sure Web application is selected and then click Configure consent screen. The consent screen is the screen that will be displayed when my app tries to connect to a user's Google account. I must specify at least my email and a name for the product. Let's go ahead and put restaurant menu app. Let's save our changes, and then click Create Client ID. Now that we see that our web application has a client ID complete with email address, client secret, redirect URIs, and JavaScript origins. Now let's go ahead and click Edit Settings. In our authorized JavaScript origins, let's go ahead and add http://localhost:5000. This is needed for our local version of code to work. If you've been using the IP representation of localhost, 127.0.0.1, this should also be included in the JavaScript origins if you want that URL to work. Let's go ahead and click Update. And we're ready to use our client ID and client secret to add OAuth to our application. If your app is accepting requests from an authenticated user, you want to be sure that it's actually the user who came up with that request and it isn't someone tricking them into sending it. Anti-forgery state tokens protect the security of your users by preventing anti-forgery request attacks. The first step to protecting against this type of attack is by creating a unique session token that your client side code returns alongside the Google generated authorization code. In later steps, you will verify this unique session token with your server when a request is made to verify that the user is making the request and not a malicious script. Let's go ahead and open our applications project.pie file and add a few new lines in order to generate our unique session tokens. I first need to make a few imports in order to add this functionality. I already used the word session in this code to refer to my database sessions with SQLAlchemy. So, let's go ahead and import flask version of sessions and name it login_session using the as keyword in python. This login_section object works like a dictionary. We can store values in it for the longevity of a user's session with our server. I'm also going to import the random and string python libraries, which I'll use to create a pseudo-random string that will identify each session. Now let's create a new routing path and call it /login. I will then create a showLogin function that creates a state variable. State will be 32 characters long, and be a mix of uppercase letters and digits. Now, let's store state in our login_session object under the name state. To see what our state looks like, we can return the following string. Now, if we save and visit our /login page in our application, we get something that looks like this. Each time we refresh, we're generating a new state variable that we are passing on to the client. For cross-site request forgery, the attacker would essentially have to guess this code in order to make a request on the user's behalf. Later on, we will check to make sure the user and the login sessions still have the same state value when a user tries to authenticate. Now that we have our login sessions in place, lets go ahead and make an actual button that the users can click to log into our app. Create a new file in your templates folder and name it login.html. Add some opening and closing html tags. And nested inside of them some opening and closing head and body tags. Inside of the head tags, I will add the following scripts. This will create an anonymous function that inserts a script into the DOM of the login.html page. Now, inside the body, let's create a div to hold the actual Google sign in button. Go ahead and make the div ID equal to sign in button. Add a span with the following code inside the div you just created. Let me point out some of the important attributes inside this span tag. This data-scope parameter specifies what Google resources we want to be able to access. Looking at the Google documentation for OpenID, we see that this asks for the user's name, their profile picture, and their email address. Which is enough information for this project. Also be sure to replace your client ID with the value that you generated when you registered your web application with Google Plus. The data redirect URI parameter sets a post message, enables the one-time use code flow. In this data-accesstype equal to offline means that our server can make requests to the Google API server even if the user is not logged in. The value of the data cookie policy attribute, determines the scope of URIs that can access the cookie. We use the single host origin, if our website only has a single host name, and no subdomains. The data-callback parameter specifies a callback function. If a user clicks and grants our application access to their profile, this callback method is called, and given the one time use code, along with an access token. And this data-approvalprompt set equal to force means that our user has to login each time we visit the login page, and doesn't check to see if they're already logged in. This is useful for debugging your app, but you should probably disable it in production since it gets kind of annoying. Change the logout function so that now it renders the login.html template. Save your changes and visit the login.html page. Now we have a nice Google login for our users to click. Once we're logged in, the button doesn't do anything interesting, just yet, since we still have to let our server know that the user has successfully authenticated. We'll get to that in the next exercise. So we've written the code that goes out to Google to authenticate. Now let's write a callback method to handle the response that Google sends back to the client. Remember that along with a successful response, the Google API server will also provide a one-time code to authorize our server, and an access token that the client can use to make API calls from within the browser as well. Just before the closing body tag in my login.html page, I'm going to add opening and closing script tags. I will define the sign-in callback function that takes in an authResult object as input. If that object contains a parameter called code, then we know that the authorization with the Google API server was successful, and our one time use code is present. Now that the app has been authorized, we can hide the Google+ sign in button. Now, I will use jQuery to create an Ajax call that passes the one time code Google gave the client onto the server. I will specify it as a POST method here. The URL this method will call I will name /gconnect. I will define this method on my server in the next video. Along with this method I pass the server state token as an argument to verify against the cross-site reference forgery attack. Setting processData to false indicates that we do not want jQuery to process the response into a string. Furthermore this application/octet-stream indicates that we are sending an arbitrary binary stream of data. And the charset equal to utf-8 indicates that it is formatted using a universal character set called Unicode. Here we specify the data that we're going to send along to our server, the one time use code. When we receive a 200 or a successful response code from our server, let's return a successful login message to the user, and then redirect to the main restaurant's page after about four seconds. If the server has any additional response information to pass to the client, we can present it with this result variable. So, let's go ahead and add an empty div named result that we can populate with a response method just above the opening script tag. In the event that an error was returned by Google, I will report this error to the console.log. In the event that no response was returned by my server to the callback function, I will return this error message to my result div. Before I can test and see if this works, I will create the server-side G-connect page that will accept the one-time code for my client's callback function. On the server side, I must create a function that handles the code sent back from the callback method. But before I can do that, I need to import a few libraries in my project.pie file that will be necessary for this function. The flow_from_clientsecrets method, creates a flow object from the clientssecrets JSON file. This JSON formatted style stores your client ID, client secret and other OAuth 2.0 parameters. We will use this FlowExchangeError method if we run into an error trying to exchange an authorization code for an access token. We can use this FlowExchangeError method to catch it. We will also use the httplib2, a comprehensive HTTP client library in Python. The JSON module provides an API for converting in memory Python objects to a serialized representation, known as JSON, or Java Script Object Notation. The make_response method converts the return value from a function into a real response object that we can send off to our client. And requests is an Apache 2.0 licensed HTTP library written in Python, similar to urllib2, but with a few improvements. Now, going back to the console.developers.google.com page, and opening the Credentials menu, I will click the Download JSON object and rename this file to client_secrets.json. And store it in the same directory as my project.pi file. I will then declare my client ID by referencing this client secrets file. Now I'm ready to create my server-side function. I will make a route and function that accepts post requests, and call it gconnect. I now confirm that the token that the client sends to the server matches the token that the server sent to the client. This round trip verification helps ensure that the user is making the request and not a malicious script. Using the request.args.get method, my code examines the state token passed in and compares it to the state of the login session. If these two do not match, then I create a response of an invalid state token and return this message to the client. No further authentication will occur on the server side if there's a mismatch between these state tokens. If this statement is not true, then I can proceed and collect the one time code from my server with the request.data function. Next I will try and use this one time code and exchange it for a credentials object which will contain the access token for my server. This line creates an oauth flow object and adds my client's secret key information to it. Here I specify with post message that this is the one time code flow my server will be sending off. Finally, I initiate the exchange with the step two exchange function, passing in my one-time code as input. This step to exchange function of the flow class exchanges an authorization code for a credentials object. If all goes well, then the response from Google will be an object I am storing under the name credentials. If an error happens along the way, then I will throw this flow exchange error and send the response as JSON object. Now that I have this credentials object, I will check and see if there's a valid access token inside of it. I will store credentials.access_token in a variable called access_token. If I append this token to the following Google URL, the Google API server can verify that this is a valid token for use. In these two lines of code, I create a json GET request containing the URL and access token. I store the results of this request in a variable called result. If my result contains any errors, then I send the 500 Internal Server Error to my client. If this if statement isn't true, then we know that we have a working access token. But now let's make sure that we have the right access token. Here I grab the ID of the token in my credentials object and compare it to the ID returned by the Google API server. If these two IDs do not match then I do not have the correct token and should return an error. Similarly if the client IDs do not match my app is trying to use a client ID that does not belong to it so I shouldn't allow for this. Lastly I will check and see if a user is already logged into the system. This will return a 200 successful authentication without resetting all of the login session variables again. So, assuming none of these if statements were true, I have a valid access token and my user is successfully able to login into my server. In this user's login session I will store their credentials in Google Plus ID. Next, I will use the Google Plus API to get some more information about the user. Here, I will send off a message to the Google API server with my access token. Requesting the user info allowed by my token scope and stored in an object I will call Data. Now, Data should have all of these values filled in, so long as the user specified them in their account. So I will store the ones I am interested in, such as the user's name, picture, and e-mail address, and store it in my login session. If this worked, then I should be able to create a response that knows the user's name and can return their picture. I can even add a flash message to let the user know that they are logged in. Let me save my changes and try logging in again. And look, my user now sees a login page and is then redirected to the restaurants page once they know that they're signed in. Now, let's add some code to disconnect the user from the Google account, logging them out of our web application. This is done by telling the server to reject its access token. Let's create another route and method, both called gdisconnect. I'll grab the credentials from my login object session again. If the credentials field is empty, we don't have record of a user. So there's no one to disconnect from the application. I'll return a 401 error for this case. Now I will use the access token and pass it into Google's url for revoking tokens like so. Then I will store Google's response in an object called result. If a response of 200 was received, then I successfully disconnected the users Google account from my application. Using the del command in python, I will delete the credentials, gplus_id, username, email address and picture from my login_session object. Then I will create a response to indicate that a user successfully logged out of my application. If I got any other response back from Google besides the 200, then I assume something went wrong in the disconnect process. And return a 400 message to the client with a statement of what happened. Now, when I visit the /gdisconnect URL, my user successfully logged out of my application. So, now that you can log a user in and out of your website, let's use the logins to protect pages that we don't want anyone on the internet to be able to access. We can verify that a user is logged in by checking to see if the login session has the username variable filled in. Since we populate it with each login and delete it upon each disconnect, if a username is not detected for a given request, let's redirect to the login page. Prompting a user to go ahead and log in to continue. Decide which pages should be visible to the public and which ones should be private for users. Go ahead and add this functionality where needed in your application. There are different places in the code where you can check to see if a user is logged in. But keep in mind how that impacts the user experience. For example, it would be kind of annoying to fill out a form only to find out that you can't submit it because you're not logged in. We can have the restaurants.html and menu.html pages public facing so anyone can see the menus created. Then we could protect the new, edit and delete pages for our restaurants and menu items. In order to keep users not logged in from modifying the database entries So now we have a menu application that is only visible to users logged in with their Google accounts. This adds some security to our website, but I still see one big problem. We protected information from outsiders modifying users' data, but what about users modifying other users' data. In lesson three, you will implement a local permission system that allows each user to have customized data that only they can modify. So you now have a web application that protects modifications from being made by people who aren't users. But what's protecting users from having their data modified by other users? In this lesson you're going to learn to implement local permissions and protect pages based on each user, and not just by the fact that they're logged in. Let's create a local permission system that leverages the information stored in the log in session object, and uses server side logic in the database to control the user experience based on provided credentials. In order to implement this local permission system, our database has to start storing information in a more user specific manner. We need a table of users, so we can identify what data belongs to whom. Our restaurant and menu items tables should also be aware of their creators for each entry. A user ID column should be added to both the restaurant and menu items tables. And finally, a little backing code to hook everything together. So let's get started. The first thing I want you to do in order to add a local permission system. Is to create a user table in your database. We could store alot more user information in this table. But for the sake of simplicity it should have a layout similar to this. Also modify the restaurant. And menu item models, such that they have user_id as foreign key relationships. Look at the code for the Restaurant and Menu Items classes in the database setup dot py file, and see if you can figure out how to add these modifications. I will show you my answers in the next video. I've created a new user class here like so, similarly to the Restaurant and menu items classes. In both the Restaurant and MenuItem classes there is now a user_id variable, and the relationship declaration to establish a ForeignKey relationship between these items and the user that created them. I'll read in the database output in the create_engine to restaurantmenuwithusers.db. So we don't override our old database just yet. You can go ahead and run database_setup.py and it will create a new database complete with our user functionality. There's a new lotsofmenus.py found in the instruction notes that will repopulate the database and set the user ID for all the restaurants equal to one. Go ahead and run this as well. The sample code for this video is available in the instructor notes. Now that we have a database that supports creating users, let's write up some codes to interact with it. For this project, I want to point out that our back end code will look up a user based on his or her email address associated with their login. So logging in with a Google account and a Facebook account tied to the same email address will provide the same level of authorization. To get started, open up your project.pi file and be sure to import the user model that we just created. I want to walk you through three methods you should add to your project.pi file that may help you deal with getting user information. The first is createUser. It takes in a login_session as input and creates a new user in our database, extracting all of the fields necessary to populate it with the information gathered from the login_session. It then returns the user ID of the new user created. The next one is getUserInfo. If a user ID is passed into this method, it simply returns the user object associated with this ID number. And, finally, is getUserID, which will take an email address and return an ID number if that email address belongs to a user stored in our database. If not, it returns none. In your code, you should also add the user ID field when you create a new restaurant or menu item, like so. In the instructor notes, you'll find a version of project.pi that contains these new code additions. Now, I want you to add some functionality inside of your G Connect method. When a user logs in with her Gmail account, we are going to see if her email address is already in the database. If not, then we make a new user account for her locally. After either making a new account, or retrieving an existing one, we store her user ID in the login session. Use any combination of the three new functions presented in the last video to help you compete this task. Let's run getUserID on the e-mail address stored in our log-in session. And store it in a variable called user_id. If user_id doesn't have a value, then we can go ahead and create a new user and pass in the login_session. Then we take the result of that answer, and store it in our login_session under user_id. In the downloadable section, I've added some public templates, for when a user is not the owner of a restaurant or menu page. These templates do not contain options to Add, Edit, and Delete. Add code to your project.pi file that checks whether user is the owner of a restaurant or menu item. If they're the owner render the original template, if not, render the public page. Also, make sure that the Create, Edit and Delete functions always check to make sure the owner is the one issuing these commands before executing, in case the user tries to visit one of these pages via the URL. For show restaurants, I'm only going to differentiate whether a user is logged in or not logged in, since the only option on this page is to create a new restaurant. So, using the same logic to see if there is a username value inside the login session, I'll render one template or the other. For the show menu item, it's a little bit more complex, since now I need to protect each menu, based on whoever created it. So if the user isn't logged in, or isn't the original creator, let's render the public menu. Otherwise they are logged in and are the creator. So we can go ahead and render the original menu.html. I also added alert messages to protect my create, edit and delete functions, just in case the user tries to visit a url that they aren't authorized to access. All of my code additions can be found in the instructor notes. Using OAuth2, you have secured your restaurant menu application and created local authorization to user specific resources. But this application should offer alternative login options for users who don't have a Google Plus account. Let's dive into lesson four and see how we can accommodate for this.