This question is simply crying out for recursion. We're given a recursive formula for the Stirling numbers, which is S(n, k) = kS(n - 1, k) + S(n - 1, k - 1). What we need to think about, though, is the base case, which isn't given. When do we stop? Well, if we have some objects, and we want to split them up, if we have more piles that we're going to split them in, some pile will be empty. That's not allowed. That means that if we have more piles-- piles is the k and object is the n-- if we have more piles than objects, we want to return 0. We can't do it. That's one case. If we look at our formula, we need to stop in other cases as well. We can't just return 0 all the time, because then our sum will be 0. What happens when these two values are the same? Well, if the two values are the same. If n equals k, then how many ways are there of splitting up the objects into the same number of piles as there are objects? Well, there's just one way. The other case we need to consider or we can consider, is if k is 1. What if we want to split the objects up into 1 pile? Well, there is only one way to do that, so we can return 1 there as well. Now to look at the code, I'm just going to code those two conditions. If we have fewer objects than piles, then there are no ways to arrange the objects. If we have the same number of objects as piles or if we have just one pile, then there's one way to do that. If we're in neither of those cases, then we're going to return the formula that we were given-- the recursive formula. That completes the Stirling number part of the question. For the Bell numbers we just need to sum the Stirling numbers for k equals 1 up to n as stated. We need a variable to keep track of the total that we're going to return, and then we need to step through the values of key from 1 up to n. For k in the range 1 up to n + 1. Don't forget the +1 on the end, because range stops one before the second input number. Then we just need to add the Stirling number n, k. Finally, we need to return the total. For this question you're asked to modify the compute ranks code in order to take into consideration whether links are reciprocal or not. What we want to know is is aÃ¢Â†Â’c a reciprocal link? It's a reciprocal link if there is a path from c back to a of at most length k where k is a number that's given to us. If there is a path back then we won't include a in the calculation for c's rank. I'm going to look at values of k-- k = 0. I'm going to ask is aÃ¢Â†Â’c reciprocal? Then from that I'll be able to tell whether to include a or not in the calculation of c's rank. This is the link we're looking at. If k = 0 the only links that are excluded are the self links--link to the page itself. So aÃ¢Â†Â’c is not reciprocal in this case, and we should include a in c's calculation. If k = 1, we're looking to see if there is a direct link back from c to a, and there isn't. So a Ã¢Â†Â’c is not reciprocal and we should include a. If k = 2, we need to see if there's a path of length 2 from c to a. If we start at c, then we can only get to d. That's just one of the two links we're allowed to click on to get back to a. What we want to know now is can we click on one link from d to get back to a? The answer is no. We can't, which means that aÃ¢Â†Â’c is not reciprocal. We should include a. If k = 3, we're going to do the same again. We start at c. We go to d, using up one link. Then we want to know if by using two clicks we can get back from d to a. Let's have a look at that. From d we can get to b. Then that uses up one link, and then can we get to a with one more link? Yes, we can, because there is a direct link from b to a, which means that aÃ¢Â†Â’c is reciprocal and we should not include a. If k Ã¢Â‰Â¥ 3, then there is definitely a path of length at least three in there, which means we should not include a for any values of k Ã¢Â‰Â¥ 3. Now we're going to code that. We're going to code a procedure to check whether aÃ¢Â†Â’c is reciprocal, and then we're going to edit the code and compute ranks to take that into consideration. This is the supplied code. I'm going to change it to include a second input k. Then we want to know whether we have that reciprocal link or not. We include the page. If we don't have a reciprocal link in the graph, we're going to include node in the calculation if the link nodeÃ¢Â†Â’page is not reciprocal. I just need to adjust the spacing here, and that's all the change that we need to do to compute ranks. To code it's reciprocal link, I'm going to use recursion. If k is 0--that was the first case we looked at in the example-- then we have a reciprocal link whenever the destination and the source are the same. In that case, I'll return true and otherwise we return false. If k is not equal to 0, then it's at least 1, which means if there is a direct link from the destination to the source, then there is most definitely a reciprocal link. If that's not the case, we're going to look at every node that is linked to from destination. We're going to check if there is a path of links from that node to the source of length k - 1. We're already used one step going from destination to node. That leaves us with k - 1 steps left. If there is a path--in other words, if reciprocal link graphs in the same graph-- we've got the same source. We've got our new node, which is hopefully one step closer to the destination. If that's true, then we're going to return true. If there is no node for which that's true, we're going to return false. That completes the procedure. For this question I'm going to explain how we take an input string, which in this case is dot dot dot x dot dot dot dot, and we change it according to some rules. Now the rules are: look at three characters in the string and change the middle one according to the rules that we have here. Don't worry about the numbers for the moment, I'll come to those later. So for this particular three, we have dot dot x. Now dot dot x says change the middle element so that it's an x. So on the next string, the new string, that position is going to be an x. The position before it dot dot dot well dot dot dot becomes a dot in the middle. Now at the ends we want to link around so this dot here has to its left a dot and to its right a dot, so we have dot dot dot again and dot dot dot says change the middle to a dot. Now moving along, the next one we have to fill in is dot x dot. Dot x dot says change the middle to an x. x dot dot, change the middle to an x dot dot dot again, middle is a dot dot dot dot, middle is a dot dot dot and then the first one is the last one here so dot dot dot again is a dot. Now that completes one change of the string and we're going to repeat that again. So, That's the first generation. This is the second generation. Now normally when you do this, you'd start at the beginning of the string but just to explain it, it was easier to show you one in the middle. So this time we'll do it from the beginning of the string. So looking at the line above, we see that the first element in the string has a dot to its left, and a dot to its right, so it's dot dot dot, so that's a dot. Now we have dot dot x, and dot dot x, that's number two here, gives me an x. dot x x is an x, x x x is a dot. x x dot, is a dot. x dot dot is an x. dot dot dot, is a dot. And dot dot dot is also a dot. And we can continue like that. And so after five generations, we have the string dot dot dot x x dot x x. And you see we have quite an interesting pattern building up. Now, we can do this for lots of different choices of these dots and x's in blue, on the second line. In fact, we can do it in 256 different ways. And in order to decide what pattern we're going to use, what rules rather, we can give this rule a number. Now, wherever I've got an x on the bottom row, I'm going to add up those numbers, so 2 + 4 + 8 + 16, and that gives me 30. So this here uses pattern 30. Now instead of pattern 30, we could choose a different pattern. Let's say we choose pattern 69. Now 69, is equal to, now we have to look at these numbers above and work out how to make 69 out of those numbers. Well, 128 doesn't go into 69, so we don't need any of those. 64 does so we want a 64. We don't want any 32's. We don't want any 16's, nor 8. But we do need 4, don't need 2, and we do need 1. So 64 + 4 + 1, 69. So that means, that we want 1. That means were going to replace dot dot dot, the middle element by an x. No 2's. We do have a 4. We don't have an eight. We don't have 16. We don't have 32. We do have 64, and we don't have 128. So, we could start off with the same input as before, which was, dot dot dot x dot dot dot dot. So when we have a dot at the beginning, its neighbor on the left is a dot, and its neighbor on the right is a dot, we have dot dot dot, and that's replaced with an x. dot dot dot again, is an x. dot dot x, is a dot. Remember, we are looking down here. dot x dot, That's number 4, is an x. x dot dot is a dot. dot dot dot is an x. and dot dot dot is an x, as well. So that's line 1. Continuing with the same thing, I'll fill in a few more lines, so that we can see what happens with the pattern. And now I come to line 6, I see that I am getting exactly the same as I had in line 5, which means that line 7 will also be exactly the same. Now, some of the values give you these patterns that just becomes stable, others are just chaotic and so there's lots of different things going on that can be quite interesting to look at. Now to come to the actual code. What I'm asking you to do is to take as input, a string, which is a string of dots and x's, a pattern number, which is between 0 and 255, and you're going to have to use that to work out where the dots and x's go. You will be supplied with this information here, in other words, the numbers that correspond with the x x dot. which is the pattern that you look up. And finally, a number of generations, and that's a positive integer. 1,2,3,4 and so on. And your output should be the generation, or the string at that generation n. So, for instance, if the input string was, as we have here, the pattern was 69 and the generation was five, you would return '.x.x.x.x' For this question, there are a couple of different things you're going to need to do. You're given inputs which are a string, a pattern number and generations-- the number of times you're going to apply the pattern to the string. The first thing we're going to need to do is to take the pattern number and convert it into some sort of pattern that we're going to be able to use to apply to our string. The second thing we're going to need to do is create a new string by applying the pattern to string, and we're going to do that generation times. Finally, we're going to need to return the last new string that we create. Let's first look at how we can create the pattern from the pattern number. We're given a number of each of the patterns, and one thing I noticed about these are they are actually the powers of 2. I'm going use that in my code. You don't have to. You can use the numbers as they are there. But I decided to use them as powers of 2. Now, if you're given a pattern number, you need to find out whether 128 goes into that pattern number. I'm going to do integer division by 2^7. If that's 1, I'm going to know that X X X corresponds to X in my new string. That's my rule. I decided to make a dictionary. X X X is going to be my key and X is my value. If it's 0 then X X X, then X X X would correspond to a dot. Once I've done that, I need to see what the remainder is. What the rest of the number is after I've subtracted 128 from it--if it was 1 or nothing. I can use modulo for that. This is going to be my new pattern number. On my new pattern number, I'm now going to divide by 2^6. Again, if it's 1, I'm going to make the corresponding pattern a key with value X. If it's 0, I'm going to make the corresponding value dot. I'm going to continue running through all the values here--all the numbers here-- down to the bottom, seeing which ones correspond to an X and which correspond to a dot. The way I'm going to do it is to use these numbers here and run through those backwards. Onto the code. I said that I was going to set up a dictionary of my patterns. I'll initialize patterns to be the empty dictionary. I'm going to write all the patterns so that I can refer to them. For convenience, I'm just going to let n equal the length of the string, because I'm going to use it several times. I've got two things to do. I've got to build my patterns dictionary, and I've got to make a new string by applying pattern to string. I'm going to do that generations times. First, let me build the patterns dictionary. As I said, I'm going to loop through the numbers 7 down to 0 in reverse order. Do exactly as I said before, check whether pattern number is divisible by 2 to the power of that number. If that's equal to 1--strictly speaking, I don't need to actually say ==1, because 1 counts as true. But just for readability I'm going to put it in. If it's equal to 1, then I'm going to subtract power from the pattern number. If it's equal to 0, then the corresponding value is dot instead of x. That completes the dictionary, and now we go on to the loop, which is going to run generations times to change the string into a new string. For j in the range of 0 up to generations, I'm going to make a new string, which is the empty string. I'm going to loop through the old string or through the indexes in the old string. What we're going to do now is step through the string, looking at every pattern. So we need to build up our pattern. What is a pattern? It's the central character that we're looking at, and it's the neighbor the left and the neighbor to the right. Just let's think about that for a moment. Does this cause any problems at the end of the strings? Because if i is 0, we're right at the beginning of the string. What happens to i - 1? Well, we get -1. Because Python allows us to index from the reverse of a string, that's fine. That will be the last element of a string followed by the first one, followed by the second one, which is just what we want. Let's check the other end of the string. If i is the last element of the string, then we've got a problem. This element here is after the end of the string, so we're going to get an error. What do we want it to be? We want it to be the first element of the string. And in order to do that, I'm going to use modulo n, because i + 1 when we're at the end of the string i is n - 1. Plus 1 gives me n, and n modulo n is 0--the first element of the string, which is what we want. There we have our pattern. We need to look up our pattern in the dictionary, and we need to add whatever the character is that our central character changes to-- that i changes to--to our string. Looking it up in patterns, I'll get that character. Once it's run through the whole length of the string, then I make my string equal to the new string and the loop continues. Once that's done generations number of times, I return the new string. That completes the procedure apart from a couple of typos. That should say for i in range, and I managed to change my variable name here. It should say pattern instead of patterns. For this question, you're asked to define a function, pick_one, which takes as its input a Boolean and a Boolean can be the values True or False. If the value of the Boolean is True, you're going to return the first input. I'm going to call that true_response. If the it's false, you return the second input--false_response. I've named them like that so I don't forget which way around they are. In order to define the procedure, I'll call the first variable boolean, with a lowercase b. Don't forget the colon. What we need is we need something that happens when the Boolean is true, and if I do if boolean, then the code underneath this is executed when boolean is true. In that case, I want to return true_response. Otherwise, when the boolean is false, I want to return false_response. These are the first six triangular number, and they're formed by taking the position and summing all the numbers from 1 up to the position. For the first number we have 1. For the second number we have 2. Note that unlike Python we're indexing from 1. N equals 3. The third number is formed by summing 1 + 2 + 3, which is 6. The fourth number is 1 + 2 + 3 + 4, which is 10. Now, how are we going to get these numbers--1 to 4--here to sum? Well, Python has a nice way of doing that, and that's using range. Now, we want the numbers to start at 1, and we want them to finish at 4. Now, the way range works is I take the first input and starts there, and it finishes at 1 less than the last input. In order to get 4, we're going to have to take the range from 1 to 5. When we come to write our procedure, we're going to use and instead of for. That means that our range will have to be from 1 up to n + 1. Now we're ready to write the procedure. The procedure name is "triangular," and it takes an input, which is a positive integer n. We want to output or return a number--the nth triangular number. I'm just going to call it "number." We want to loop through all the numbers 1 up to n in the range. Don't forget the +1 there to make sure we go up to n. We're just going to add each of the values i as we come to it in the loop. Then when we're done we're going to return the number. For this question you're asked to decide which of the procedures run in linear time. That is, the running time scales linearly with the length of the input. What we need to make sure is that there aren't too many steps. If we have a look at the first procedure, we initialize a variable--that doesn't take very much time. Then we have a for loop, and the for loop iterates through the input list here. If nothing happens in here, then it will iterate input list times. In order for it to be linear, the steps within the for loop must be in constant time. What are we doing? We're just comparing the variable maximum with an element, and then if the comparison is true, then we're setting maximum to be the element. This is just looking for the maximum element in the list. That's just a constant time operation there. So that is constant time, so procedure 1 does run in linear time. Now onto our second procedure. What's it doing? It's taking the first element of the input list and adding it onto sum. Sum starts at zero and then adds the first element of the input list, and then the input list is set to be the second element onwards in the list. Then it keeps summing. Now, how many steps does this take? Well, it just cuts off the first element each time in the list. That's the one that we've already added on. Then the list continues as long as it's not empty. This is actually performed the length of the input list times. One thing we always need to look at when we're doing this is to check whether they're constant time. You're told in the question that both of these are constant time, which means that the whole procedure runs in linear time. Now onto procedure 3. What it's doing is running through the list, checking each element against every other element. If you're not checking at element against itself and the two elements are the same, then return false. Otherwise, return true. It's checking whether there is a repeated element in the list. Now, looking at how it's done it, this inner loop here runs through all the values of j. In the worst case, when the input list of i is never equal to the input list j-- when i and j are different--this will run through the whole list. This is going to go through length of input list times in the worst case. The inner loop for j--that's going to go through that many times. Now, it's going to go through that many times when i = 0 and when i = 1 and when i = 2 and so on. It's actually going to go through that inner loop length of input times. That's squared and if it's something squared, it's no longer linear. So this is not linear time. The correct answer was procedures 1 and 2 run in linear with respect to the input list, and procedure 3 does not. For this question, you're asked to produce a list of words from a string, which is separated either by white space or tags. You've got to strip out all the tags. We have tags here, here, here, here and here. Now, we can't just remove the tags completely, because then we'd have "Title" and this written as one word, and we don't want that. The first thing I'm going to do is I'm going to remove the tags. I'm going to search for the first tag, the opening tag and the closing tag, and then I'm going to remove the whole of the tag. But I'm not just going to remove it. I'm going to replace it with a space, because replacing it by a space means that I don't have the problem with things like "Titlethis" being run into one word. Once I've got all the tags replaced by spaces, I'm going to use the split that we've used before, which splits on white space. Having several spaces in a row is not a problem, because split removes the lot of them. Now to look at how to code that. We're asked to define a function remove_tag. It takes a string as its input, and what I'm going to do first is I'm going to look for the start position in the string--the start position of the first opening bracket. I'm also going to need to find the end of the bracket--the end of the same tag. Just to be on the safe side, make sure I find the right one, I'm going to start by looking at the start position. I'm going to start the find from the initial opening bracket and so I'll find the next closing bracket. Now, that would find the first tag, but I'm going to have to do this multiple times if there is more than one tag in the string. While I have an opening tag--remember, if we have the string we're looking for non found, then it returns -1. As soon as we haven't got -1, we're going to keep looking for the tags and removing them. Now to actually remove the tag, I'm going to break the string up. I'm going to take the part before the tag and the part afterwards and joint them together. I'm going to take the string up to start. Now, this will actually exclude the opening tag, because it ends at one position less than start. I'll replace the tag with a space and then I'll put the rest of the string after the tag at the end. Now, I'll start at one position after the end, because end is the position of the closing tag, and we don't want to include that. Now I've got a new string. I'm going to see if I've got another tag that I'm going to have to remove. I'm going to look for the next opening tag. If I find an opening tag when it comes to the top of the while loop, it'll go through again. If I don't find another opening tag, the while look will finish. In that case, I want to return the string but not just the string. I want it split into individual words. Then I'm just going to split, and that almost completes the code, except that I've misnamed the procedure and called it "remove_tag" instead of remove_tags. And now we're done. For this procedure, we're going to write a converter which takes a dictionary and a date as its inputs. The dictionary converts the number of the month to the name of the month, and the date is in the format month/day/year, which I've written up here so we don't forget the order. The output should be in the form day, name of the month, year. How are we going to split up month, day, and year? The way we're going to do that is to look for the forward slashes in the string. The first forward slash we can find at the position between the month and the day. Everything up to the first forward slash is the month. The month is equal to everything up to the first slash, and that's exclusive. It's doesn't include the slash itself. The second slash we can find by looking from the first slash onwards. We look at the position one after the first slash to find the second slash. We know it's somewhere there. We can't say it's exactly two steps after or one step, because the day could be one digit or two digits. The day is between the first slash and the second slash. Note, that we have to add 1 onto first because we want to go 1 position after the slash and it's inclusive for the first place here, and exclusive for the second. Then year is the date from 1 position after the second forward slash. So now we've got the day, the month, and the year. We need to turn it into the format to return it. We're going return the string which is day and the space, then the month, and then the year. Now month we need to look up in our dictionary. We're going to look it up in the dictionary, but we can't just put month in straight away, because month is a string and the dictionary uses a number as it's index. We have to turn the string into an integer. Then we need a space again, and finally, the year on the end. That's the first method. The second method is much shorter. It uses a procedure you've seen before but something that you may not know about that procedure. I'll show it to you just for completeness' sake. We can get the month, the day, and the year by splitting the date and using an input for that split. Now, split without an input just splits on white space. Split with input splits on whatever that input is. Date.split will split into month, day, and year. We can use a triple assignment to get those out straight away. Then we just need to return exactly the same as we returned before. That's a very simple way of writing it, which does exactly the same as the first one. For three procedures you were asked to determine whether they terminate for all inputs which are natural numbers--1, 2, 3, 4, and so on. When we have a while loop and its condition is True, that's always going to mean that the block underneath is performed. The loop will just keep going and going and going. It will never fail at the condition. The only way this will terminate is if something within the block causes it to terminate. We see we have a break here. Now what we have to determine is whether that break is always reached. Here we have n = n - 1. When n is a whole number, it just steps down one step at a time each time it goes through the while loop. Eventually, it will reach 0. So this condition here will succeed, and the break will be reached for all natural numbers n. The procedure will return 3. For this one, it does terminate for all inputs n. For procedure 2, we can give an example when n = 4. Let's see what happens. Is n equal to 0? No, it's not. We return 1 plus the procedure 4 - 2, which is 2. Then we look to see if we put 2 in here for n, then, no, n isn't 0. We return 1 plus the procedure of 2 - 2, which is 0, and call it again with 0. N is 0 so it returns 0. That works okay. But what happens if n = 5? When we get here, n - 2 = 3, so we call the procedure again with n equals 3. N is not 0, so we come to here again. This time we have n is 3, 3 - 2 is 1. Call the procedure again with n is 1. N is not 0, and we come to here again. We call the procedure with n - 2, which is 1 - 2, which is -1. We've missed 0, and we're never going to get to 0, because we're always decreasing n. This procedure will not terminate for some n. In fact, it won't terminate for any of the odd numbers. For the final procedure--will this terminate? We put in the value of n, and we call it again. We can see that we're decreasing n by 1, by 2, and by 3. For large n, we don't need to think about it, but what happens when we get near the base case? Are we going to always be able to terminate or not? If the input is 6, we're going to get 5, 4, and 3. The 3 will be okay. Then on the next round when we have 5, if we input 5, we'd have 4, 3, and 2. Well, that will be okay, because 2 will be less than or equal to 3. If n is 4, then we're going to have 3, 2, and 1. That's okay. All of these are small enough. When n gets small, we don't have a problem because of the less than or equals, which means this is going to terminate for all natural numbers n as well. The correct answer is that procedure 1 will terminate, procedure 2 will not terminate for all n, and procedure 3 will terminate. For this question, you're asked to define two procedures. The first one takes a match as its inputs along with a replacement, and it outputs some sort of structure, which you'll be able to use. In the second procedure, apply converter, which will change a string according to the match and replacement. I'll just do an example. aaabaa--if this is our match and replacement, the aba will be replaced with b. The next string we'll have will be aaba. Then we've got aba again, so we'll replace that with b. There are no more matches, so we stop. You can see at each step it's changed, and when we change it no more, we stop. What our code is going to do is continue. As long as we've made a replacement at the previous step, we'll do a step again. If we haven't made a replacement, then we'll stop. On to the code. What structure do I want? Well, I'm simply going to make a list where the first entry in the list is the match, and the second entry is the replacement. Apply_converter has as its input a converter which we made in make_converter. That's a list, and the string that we want to change. I said that I was going to continue changing the string as long as the string was not the same as it was before. We're going to have to keep track of the previous string. At the start there isn't a previous string. While previous is not the same as the current string, I want to carry on with the loop. As soon as I enter the loop, I want previous to be equal to string, and then I want to look for the match in the string. The position of the math we can find using find, and we're looking for the first word in the converter. If we find it, then we're going to replace our string with a new string, which is the first part of the string up to the position, not excluding it-- the start position of our match. We replace that with the replacement, and finally we want to concatenate the part of the string after the match. We find it's position by starting at the beginning of the match and adding on the length of the match. Then taking that to the end of the string. As long as we've made a change, the loop continues. If we haven't made a change, the loop ends, and we return the string. For this question, you're asked to find the element which occurs most often consecutively in a list In this case, it's 5 because there are three 5s in a row, and that's more than any of the other elements in row. There are more 6s, but they're split. They're not in one consecutive list. I'm going to talk about this as a sublist. We're looking for the longest sublist of the same element repeated. Now, in order to do that, we're going to have to keep track of some things. We're going to have to keep track of our best element as we go. We're going to have to keep track of how long the sublist containing the best element is. As we go, we're going to have to keep increasing our count as we find another element that's the same as the previous one. For 6, we're going to have to keep track of the fact we're looking at 6 and the number of 6s that are occurring, so we can compare them with these two values here. I'm going to introduce two more variables. I'm going to introduce current and the current length. To start off with, we haven't got any information, and we look at 7-- well, that's my current one, and there's one of them. Okay, I've got one 7. That's definitely the best, because I haven't got anything else before, and there's one of them. Now we move on from 7 and we get to 6. Well, there's one 6. Move on again, and that's not better than we had before, so we're not going to replace best element with 6. Now we come on to the second 6--oh, well, now we've got two 6s. That's actually better than we had before. I'm going to replace the 7 with a 6 and the length with 2. We haven't got 6s anymore, so we're not going to increase the count for 6. We're going to start a new count for 5. We've got one 5, two 5s, three 5s, and now we're out of 5s. Let's compare that with our best element from before. It was 6 and there were only two of them, so 5 and 3 is better. There are more 5s. Now we're not dealing with 5 anymore. We're dealing with 6 again. There is one 6, two 6s. Now, we compare the number of 6s with the number of 5s, and there aren't enough. We're not going to replace the values there. Then we come onto 7. There's one 7. Again, we're not going to replace the value. Our procedure should return 5. Now let's look at the code to do that. We're going to define a procedure, longest_repetition, which has a list as its input. Now, when we first start, we don't know what the best element is. I'm going to set it none. It has length zero. If it's an empty list, then there isn't a longest repetition, and the length would certainly be 0. Our current--well, we don't have one either. That's going to have length 0 as well. What do we do? We looped through all the elements in the input list. What are we going want to check? Let's check to see if current is equal to the element or not. If it's not equal to the element, then let's make it equal to the element, and let's reset the current length to one, because we've now got an element , so it must occur at least once. We don't know yet whether it'll occur more times, because we've only checked that first time we've seen it in this sublist. If current is equal to the element, then we're going to increase the length by 1, because we've got a second one so our sublist is 1 longer than it was before. In either case, we want to check whether the element we have is greater than the length that we have stored as our best length of a sublist at the moment. If it is better, then we're going to replace our best element with the current one, and we're going to replace our length with the current length. So when these for loops run through, all that there's left to do is return best_element. That completes the code. For this procedure you're asked to reverse a list, and any elements that are lists within that list you're also asked to reverse. I'm going to label the elements A, B, C, and each of these elements needs to be in reverse order. C, B, A. Now C is itself a list, which means that C is going to have to be reversed as well. B is a list, and A is just a single element. Well, when it's a single element, that's it. We're done. A is fine. B we're going to have to reverse. Each element in B is now just an element. It's not a list. That's fine. Finally, in C it looks like we've got a lot of work to do here, because we've got 4 and this list of lists. Those need to be reversed. Four is okay, but 5, 6, 7--that's another list of lists. That one needs to be reversed, and so on. We're going to have to keep going until we get down to looking at the elements themselves which are not lists. That gives us the structure for our procedure, because we're doing the same thing over and over again to smaller parts of the lists, that really lends itself well to using recursion, and that's what we're going to do. No we're going to define the procedure deep_reverse. The first thing we're going to check is whether we have a list as our input. We're going use this function is_list, and if p is a list, then what we are going to do is create a new list, an empty list. We want to go through the elements in the original list in reverse order. In order to do that, we're going to count backwards. The last position is the length of the list -1. Then we want to go length of list -2, -3, and so on, all the way down to 0. We can do that using range. For i in range the length of the list -1. Because range stops one before the second input number, we have to go to -1 because we want to end at 0. We also want to tell it to count backwards. We want to count in -1 steps. What do we want to do? Well, we just want to append each element of the list in reverse order. But we don't want to just put the element in, because remember we've actually go to reverse each element as well. We're going to call the procedure again on each of the elements of the list. Then when the loop has finished, we're just going to return the result. Now, we haven't got a stopping condition yet. When did we stop when we were doing the example? We stopped when we got to an element that was not a list. So our else condition we just return whatever that element is. That's our base case for the recursion. Welcome to CS101. I'm Dave Evans, I will be your guide on this journey. This course will introduce you to the fundamental ideas in computing and teach you to read and write your own computer programs. We are going to do that in the context of building a web search engine. I'm guessing everyone here has at least used a search engine before. Like Google, DuckDuckGo or even my personal favorite - DaveDaveFind. You type in what you are looking for, and voila - in literally a blink of an eye, about a tenth of a second, back come the results. This might not be enough to make you wise, but it is pretty amazing. A goal of this class is to turn some of the magic of the search engine into something a bit more understandable. Our biggest goal tho is to learn about computer science. Computer science is about how to solve problems, like building a search engine, by breaking them into smaller pieces and then precisely and mechanically describing a sequence of steps that you can use to solve each piece. And those steps can be executed by a computer. For our search engine the three main pieces are: finding data by crawling web pages, building an index to be able to respond quickly to search queries, and ranking pages so that we get the best result for a given query. In this course we will not get into everything that you need to build a search engine as powerful as Google, but we will cover the main ideas and learn a lot about computer science along the way. The first three units will focus on building the web crawler. We will talk more about that soon. Units 4 and 5 will cover how to respond to queries quickly. And unit 6 will get into how to rank results and cover the method Google uses to rank pages, that made it so successful. But first, let's talk about how to build a web crawler that we are going to use to get data for our search engine. Let's get started by asking Sergey Brin the co-founder of Google what the most important thing is in building a search engine. So let's get a take how to decision. We've been here before right. I think the most important thing if you're going to build a search engine is to have really good fun corpus to start out with. In our case, we use the world wide web, which at the time was significantly smaller than it was today. But it was also very new and exciting, there were all sorts of unexpected things there. There are lots of other really interesting corpuses of information. And, of course, we've worked on one for books and one for people's, for your email, individually. There are many, many interesting corpuses out there and I think you should pick the right one that you will be excited about searching yourself. The goal of the first three units in this course is to build a Web crawler that will collect data from the Web for our search engine. And to learn about big ideas in Computing by doing that. In Unit 1, we'll get started by extracting the first link on a web page. A Web crawler finds web pages for our search engine by starting from a "seed" page and following links on that page to find other pages. Each of those links lead to some new web page, which itself could have links that lead to other pages. As we follow those links, we'll find more and more web pages building a collection of data that we'll use for our search engine. A web page is really just a chunk of text that comes from the Internet into your Web browser. We'll talk more about how that works in Unit 4. But for now, the important thing to understand is that a link is really just a special kind of text in that web page. When you click on a link in your browser it will direct you to a new page. And you can keep following those links as a human. What we'll do in this Unit is write a program to extract that first link from the web page. In later units, we'll figure out how to extract all the links and build their collection for our search engine [D. Evans] We're going to have many quizzes throughout each unit. The point of a quiz is to check that you understand what we've covered. Some of the quizzes will be fairly straightforward just to see if you've followed what we said. Other quizzes will be more challenging and require you to put together several ideas that we've covered. The quizzes don't count towards your grade. You'll be able to try them as many times as you want until you hopefully get the answer right. It certainly will be valuable to try to get the answer right the first time. But they shouldn't be stressful. They're meant to keep you engaged in the lecture, make sure you're understanding things. After each quiz there will be an explanation of the answer that will often go in more depth than just answering the quiz correctly. So for the first quiz and to get started practicing doing quizzes, our question is: "What is the goal of Unit 1?" There are 4 choices. You can check all the choices that you think are good answers. So the goal is to get started programming, the second choice is to learn some important computer science concepts, the third choice is to write some code that extracts a link from a web page, and the fourth choice is to write code to rank web pages. So that's the first quiz. Check as many answers as you think are correct. So the answer is the first three are correct. We want to get started programming, and we'll get started programming very soon. The most important thing is to learn some computer science concepts, and we'll do that as we get started programming as well as along the way. And the third goal is to write code to extract a link from a web page. That'll be the first thing that we do to start building our search engine, and collecting the corpus that we'll need for the search engine. The fourth choice is not true. We're not going to get to the point where we write code to rank webpages this unit. That's something that we'll be covering in unit six. So let's get started with programming, and programming is really the core computer science. Most machines are designed to do just one thing. This is supposed to be a toaster, more of a representational drawing than an accurate one. And a toaster, we can do more than one thing with a toaster. We can put different things in it. We can toast bread, we can toast muffins, maybe it has some things we can use to change its behavior a little bit. We can turn a setting to make it toast for longer or shorter. But it's pretty limited in what it can do. Everything it can do is a variation on this basic functionality that it was designed for: this basic process of putting toast in, heating it up and getting the toast to pop out. If we want to change its behavior to do something really different, we'd have to physically alter the machine. We could maybe take the parts out, and put them together in a new way. If we're really creative we could make a bicycle from the toaster. That would be a pretty big project, though. So without a program a computer is even less useful than a toaster. You can't do anything without a program. The program is what tells the computer what to do. And the power of the computer, is that, unlike a toaster, which is only designed to do a few things, a computer can do anything. A computer is a universal machine. We can program it to do essentially any computation. So anything that we can imagine, anything that we can figure out how to write a program for, we can make the computer do. And what the program needs to be is a very precise sequence of steps. The computer by itself doesn't know how to do anything. It has a few simple instructions that it can execute. And to make a program do something useful we need to put those instructions together in a way that it does what we want. So we can turn the computer into a web browser, into a server, into a game-playing machine, into a toaster, without anywhere to put the bread. But it can do anything we can imagine: at least any computation we want to do. The power of the computer is that it can execute the steps super super fast. So we can execute billions of instructions in one second. The program gives us a way to tell the computer what steps to take. So there are many different languages for programming computers. The language we are going to learn in this course is the language called Python, like the snake. It is also named after Monty Python. The important thing about Python is that it gives us a nice high-level language that we can use to write programs. And that means instead of our program running directly on the computer, the programs we write will be an input to the Python program which runs on the computer. What Python is is called an interpreter. That means it runs our programs, it interprets them, executes the programs that we wrote in Python language by running a program in a language into the computer can understand directly. Now it's time for a quiz to see if understand what a computer program is. So which of the following are computer programs? Check all that apply. A web browser like Firefox or Chrome or Internet Explorer. The Python interpreter. The Python code that you'll write in this class, and you'll start writing Python code very soon. A slice of toast. The calendar application on your mobile phone. Check all of the ones that are computer programs. The answer is, all of these are computer programs except for the slice of toast. In general, if you can eat something it's not a computer program. The programs that you write in this class will be Python code. Those will be input to another program, which is a Python interpreter that follows instructions in your code, and it does that by following the instructions in its code. And you'll be able to run all that using your web browser. So, now let's get started. Running code in the Python interpreter. For this class you don't need to install any new software. You can run Python right in your web browser, and you should see something like this in your web browser once the video stops. There are two parts to this, there's the environment where you can edit code, so let's type code to print 3. So print is a Python command that prints something out, and then after the print, we can have any expression that we want that is valid Python, and we'll talk more about what expressions are in Python. Now we're just going to print the number 3, and when we click Run, it will run this code and show us the result down here. And the result of printing 3, we see the output 3. We can do more interesting things. So, we can print an arithmetic expression, so I've got 1 plus 1. Now we run this. We see both outputs, so first we printed 3, we see the 3 here. Then we printed 1 plus 1. We see the result of 1 plus 1 is 2. We can write this more clearly by having spaces. We can have spaces between the parts of our expressions. So we can have one plus one with spaces between there. that's a little easier to read, when we run that, we see the same result. The result is still 2. And we can make more and more complex expressions, so let's print to result of 52 times 3 plus 12 times 9. This will print out the result of multiplying 52 times 3, and adding that to multiplying 12 times 9, and we get 264. You can check that yourself to see that Python got the right answer. We can use parentheses to group expressions. So, if we use parentheses, we can do what we did before, but putting parentheses around grouping the multiplications and grouping the other multiplication. And we run this, we see the same result without the parentheses, that means the same thing as we had when we add the parentheses like this. If we put the parenthesis in different places it means something different. Now what it means is 52 times the result of adding 3 plus 12 which is 15 times 9. And so we get the result 7020. So we can combine any expressions that we want like this. For example if we wanted to compute the number of seconds in a year, we can compose many multiplications. So we'll multiply 365 days times 24 hours in a day times 60 minutes in an hour times 60 seconds in a minute. We can do all those multiplications together and we get this result. Which is about 31 and a half million seconds in a year. So now it's time for your first programming quiz. You've seen enough to be able to write a Python program. And your goal is to write a Python program that prints out the number of minutes there are in seven weeks, which is the amount of time we have for this course. You'll do that by entering your code in here. And then you can try different things. You can try running the code. See the result. And then when you've got an answer, you can click to submit that answer and see if it's correct. So there's lots of different ways you could have solved this. You need to use the print command to print out the result. And then we want an expression that calculates the number of minutes in seven weeks. There's seven weeks, each week has seven days, so we can have seven times seven for the number of days. Then to get the number of minutes, we need to multiply that by 24 to get the number of hours And then multiply again, by 60. That should give us the number of minutes. So let's see that in the Python interpreter. And now we hit Run, and we see that we have 70,560 minutes. Seems like a lot of time. It's going to go pretty quick, and we hope by the end of the seven weeks, all of you will be accomplished Python programmers. Congratulations, you've passed the quizz and you've actually written your first program. It might not seem like much of a program but that's all a program is. It's just instructions to tell the computer what to do. To be able to write something more interesting, like a web crawler well, we are gonna need to learn to write more complex programs. So now that you've written your first Python program, you might be wondering why we need to invent new languages like Python to program computers and spend all the effort into learning a new language, rather than using some language like English or Mandarin that we already know. And there lots of reasons for that. That natural languages like English and Mandarin are great for people who grew up speaking them for day-to-day conversation. But there are many reason that they wouldn't work well for programming computers. The first one is ambiguity. Natural languages are inherently ambiguous. Different people can interpret the same sentence to mean many different things. When we program computers, the computer needs to interpret that program. And we want to make sure that the computer interprets the program the exact same way that the programmer, who wrote the program, intends for it to be interpreted. So here's an example of the kinds of ambiguities that come up in natural languages like English, and we'll do this in the form of a quiz. So the question is, would you rather be paid $100 weekly or biweekly? So these are the choices, you can prefer to be paid $100 weekly; you can prefer to be paid $100 biweekly. It depends, or you are an altruist and you don't like to be paid at all So there is no real correct answer to this quiz if you really don't like money, I guess you could prefer not to be paid at all. The closest thing to a correct answer is that it depends, and it depends on how you interpret the meaning of biweekly. We could look that up in the dictionary to decide how we should interpret it, and if we look up biweekly in the dictionary, what we see is the definition of biweekly, which is right here. It says happening every two weeks is the first definition. The second definition is happening twice a week. If you have the first definition, you'd rather be paid weekly, assuming you'd like more money. If you have the second definition, you'd rather be paid biweekly. Maybe that's the problem with paper dictionaries, that they're not very precise, because they're old things. Let's look up a more modern dictionary, let's see what Wiktionary has to say about this. So, here's the Wiktionary entry for biweekly, and if we scroll down, we can see that it has two meanings. Occurring once every two weeks, occurring twice a week, this is chiefly in the UK the American dictionary didn't seem to think that. It seemed to think both definitions occurred in both countries. So, this is a pretty big problem. If we wrote a computer program and the program was doing our payroll and had to decide what it meant to pay someone biweekly, we want to make sure it understood that the same way the programmer did. So that's one important reason why we need to invent new languages like Python to program computers, rather than using natural languages that we already understand. And that's because we don't really understand languages like English or Mandarin, that there's lots of things that different people will understand different ways. And this happens at the granularity of words like biweekly. It also happens in complete sentences where there are many different ways to interpret the same phrase. Another reason we don't use natural languages for programming is that natural languages are actually very verbose. To write a program, we need to describe exactly what the computer should do in very precise sequence of steps. If we had to describe all those details using a natural language, that would require a huge amount of text. So we'll see soon that with a programming language like Python, we only need a few lines of code to describe a complicated thing and describe it in a very precise, step by step way. So I want you to think about as we write programs in this class, how much more detail you need to actually describe in English, precisely how to do what we're describing with a few lines of Python code. So in order to learn about programming, we need to learn new language. This will be a way to describe what we want the computer to do in a much more precise way than we could in a natural language like English. And it's a way to describe programs that the Python interpreter can run. One of the best ways to learn a programming language is to just try things. You can try that in the Python interpreter that's running in your browser. Let's, for example, try running print 2 plus 2 plus. In English, someone could probably guess that the value of 2 plus 2 plus should be 4. In Python, when we try running this, we get an error. And the reason we get an error is that this is not actually part of the Python language. The Python interpreter only knows how to evaluate code that's part of the Python language. If you try to evaluate something that's not part of the Python language, it will give you an error. Errors look a bit scary, the way they print out. But there's nothing bad that can happen. It's perfectly okay to try running code. If it produces an error, that's one of the ways to learn about programming. The error we got here is what's called a syntax error. That means that what we tried to evaluate is not actually part of the Python language. Like English, Python has a grammar that defines what strings are in the language. In English, we can make lots of sentences that are not completely grammatical, and people still understand them, but there's some underlying grammar behind the language. Those of you who are native English speakers, might have learned rules like this in what was once called grammar school. Those of you who learned English as a second language, probably learned rules like this when you were learning English. So, English has a rule that says you can make a sentence. By combining a subject with a verb, followed by an object. Almost every language has a rule sort of like this. The order of the subject and the verb and the object might be different, but there's a way to combine those three things to form a sentence. The subject could be a noun. The object could also be a noun. And then each of these parts of speech, well, we have lots of things they could be. So a verb could be the word eat. A verb could also be the word like, and there are lots of other words that the verb could be. A noun could be the word I, a noun could be the word Python, a noun could be the word cookies. The actual English grammar is of course, much larger and more complex than this. But we can still think of it as having rules like this that allow us to form sentences from the parts of speech that we know, from the words that make those parts of speech. The way we're writing grammars here is a notation called Backus-Naur Form. And this was invented by John Backus. So John Backus was the lead designer of the Fortran programming language back in the 1950s at IBM. This was one of the first widely used programming languages. And the way they described the Fortran language was with lots of examples and text explaining what they meant. And this is a shot from the actual manual for the first version of Fortran. This works okay, many programmers were able to understand it and guess correctly what it meant, but was not nearly precise enough. And when it came time to design a later language, which was the language called ALGOL, it became clear that this informal way of describing languages wasn't precise enough. And John Backus invented the notation that we're using here to describe languages. [D. Evans] The purpose of Backus-Naur Form is to be able to precisely describe exactly the language in a way that's very simple and very concise. So each rule has the form like this where on the left side there's a non-terminal. Non-terminal means something that we're not finished with. All the words written in blue in the grammar are non-terminals. Sometimes they're written with brackets around them. I've just used blue to distinguish the non-terminals like this. Then there's an arrow, and then on the right side there's a replacement. The replacement can be anything. It can be a sequence of non-terminals like here. Sentence can be replaced with subject followed by verb followed by object. It can be 1 non-terminal like here. It can also be a terminal, and the terminals I've written in black. What's special about the terminals is they never appear on the left side of a rule. Once we get to a terminal, we're done, we're finished. There's nothing else we can replace it with. So all the rules have this form. We can form a sentence by starting from some non-terminal, usually whichever one is written at the top left-- in this case the one I called sentence. And then by following the rules we keep replacing non-terminals with their replacements until we're left with only terminals. Here's an example starting from sentence using the grammar above. We can start with sentence. We only have 1 rule to choose from where sentence is on the left side, so we're going to replace sentence with subject, verb, object. Now we have a lot of choices. We can pick any of the non-terminals we have left. Find a rule where that non-terminal is on the left side. We can pick any of the rules where it's on the left side and do the replacement. So I'm going to start with the left one. We'll pick subject. We only have 1 replacement rule for subject. We can replace subject with noun. The others stay like they are, so we still have verb and we still have object. Now we can keep going. We can pick the first one again. It's still a non-terminal, so we can still do replacements. With noun we've got 3 choices. We can pick any one of those choices. I'm going to pick the first one. We'll replace noun with the terminal I. Now we've got a terminal. We're done with that replacement. Verb and object stay the same. I'm running out of space, so I'm not going to write them again because now we can use rules to replace verb. As a separate step we're going to find a rule that matches verb. We have 2 choices. I'll pick the second one and replace verb with like. We still have object. Object is a non-terminal, so we have to keep replacing it until we're done. We have 1 rule for object. We can replace object with noun. Now we have 3 rules for noun. I'm going to pick the second rule and replace noun with Python. What I've done here is what's called a derivation. A derivation just means starting from some non-terminal, follow the rules to derive a sequence of terminals. We're done when we have only terminals left and we can derive a sentence in the grammar. In this case we produced the sentence I like python, but there are lots of other sentences we could have produced starting from the same non-terminal if we pick different rules to follow. So now it's time for a quiz to see if you understand how replacement grammars work and can follow the BNF grammar we have here. So the question is, which of these sentences can be produced from the grammar here, starting from the non-terminal sentence? So check all of the sentence that are in the grammar. The choices are Python eat cookies, Python eat Python, and I like eat. The answer is the first two can be produced. The third one cannot. And the way to see that is to follow the rules. So if you start from sentence, well, we only have one rule from sentence, so we're always going to end up with subject verb object. We also only have one rule from subject and one room, rule from object. So we're always going to end up with noun verb, followed by object, which also is replaced with noun. From here, we have lots of choices, so we can replace the noun with Python. We can replace the verb with eat, and we can replace the second noun with cookies. That will derive the first sentence. We could replace the second noun with Python, using instead the second choice, that would derive the second sentence. There is no way to produce the third one. We can get close. We can turn the noun into I, following this rule. We can turn the verb into like, following this rule. We can't turn the noun into eat. The noun can either by I, Python or cookies. So that's why we can't derive the third sentence. The important thing about replacement grammars is we can describe a large language. In fact, an infinitely large language with a small set of rules. This language itself is quite small. But we'll see how to describe much bigger languages, still using a small number of rules soon. And it is very precise; we can figure out exactly what sentences are in the language, just by following the rules here, doing replacements. So, the Python grammar is much stricter than the English grammar or most natural language grammars. In English, if we say something nongrammatical like me go to the store, another English speaker might laugh at us. But they can probably understand what we meant. In Python, the code must match the language grammar exactly. Here we saw when we tried to evaluate 2 plus without the extra operand, we got a syntax error, that means it's not grammatical. If we said 2 plus to someone in English well they might be able to figure out that that means the same thing as 2. In Python it needs to match the grammar exactly. So now we're going to look at the Python grammar for arithmetic expressions. We won't see the entire Python grammar here. But enough to get an idea of why the expressions we've seen were valid and why the 2 plus is not. So first of all, an expression is something that has a value. We're going to start our grammar with an non-terminal expression. And we can make an expression by combining two expressions with an operator. This is sort of like the sentence rule we have for English where we could make a sentence by combining a subject, a verb and an object. This is a lot more interesting though, because we have expressions both on the left side and the right side. This looks kind of circular. Because we have other rules, it's not completely circular. This is what's called a recursive definition. We'll talk a lot more about that in a later class, in unit six we will, but for now, we're going to just see how we can use that to make the Python grammar. And to make a good recursive definition, we need at least two rules. We need one where we can keep going, using the same thing on the right side as the left side. And we need one where we can stop. So, another thing that an expression can be is a number. And this is why we can make expressions like 1 plus 1. This expression will become a number which will become one. The operator will become plus, and the other expression will become one. So let's write a few more rules to see how that works. So we can replace the operator with plus. We can also replace operator with times. And there's several more operators in Python. Those are enough for now, we just need those two. We can also make numbers. And the complete rule for making numbers is sort of complicated, but let's assume we know what numbers are. We can make numbers any number of digits. There different rules to make all those numbers, but we know what they are. So, this looks like a very simple grammar. It's quite small, but it can express infinitely many things. And the reason for that is because we have expression on both sides here. That we can replace an expression with a derivative expression, and keep going. So here's an example derivation. We can start with expression. We can follow the rule, replacing that with expression operator expression. And then, we can follow the rules again. We can replace the first expression with a number and replace that number with the actual number one. And we notice the actual numbers are terminal. So, once we get to the number one, we're done. There's no more replacements to do. We can replace the operator with plus. Plus is also a terminal, and we can replace this expression with a number, and replace that number with the number one. So this is how we got the expression 1 plus 1 in the Python grammar and that's why that was valid. We can do a lot more than this though. Instead of replacing this expression with a number, we can replace this expression with another expression, operator expression. So we're going to use the first rule replacing the expression with expression, operator expression here. I'm going to start abbreviating so Expr is an abbreviation for expression. Op for operator and Expr but, we're just using this rule. And now we can do the same thing again, replacing this expression with a number and replacing that number, let's say with number two. We could replace this operator with the multiplication operator. And we can replace this expression with a number. Or you could replace it with an expression, operator, expression. Let's do that, and build increasingly complicated expressions this way. We can keep doing this. We are not done until everything is a terminal. So lets say, we skipped a few steps here, but this could be 3 plus 3. So this is how we can build up complicated expressions from very simple rules. So I am going to add one more rule to our python grammar, that will be enough to produce all the expressions that we have used so far. And that rule that we need is for parentheses. And this is actually quite a simple rule. It just says we can make an expression by taking any expression we have and putting parentheses around it. So, this is a pretty small grammar, but this is actually grammar that's powerful enough to produce all the Python expressions we've seen so far. As well as infinitely many different expressions. We're not going to cover the entire Python grammar this way, but this should give you an idea of the power of writing our grammar this way. So we're going to have a quiz to see that everyone understands the grammar. So the question is which of the following are valid Python expressions that can be produced starting from expression using the grammar rules. So here are the choices; there are five possibilities, check all the ones that are valid expressions that can be produced from this grammar starting from expression. You can try your answers in the Python interpreter if you want, but first see if you can figure it out for yourself, which ones are valid. So, the answer is the first one. This is just a number three. And we can get three from expression by following this rule. Starting from expression, replacing with number, and then replacing number with the number three. The second one is not valid. And the way to see that is if we start from expression, we only have three choices. We can replace it with expression operator expression. We can replace it with number, or we can replace it with a left paren, expression, right paren. Since the expression we're trying to match starts with a left paren, the only way to get it left paren is to eventually have this rule that replaces expression with left paren. When we use that rule, what we get is the left paren followed by expression. Now we have expression here. >From here, we've matched the far left paren and the far right paren. What we have left is this. We can replace this expression with paren expression, and we have paren that's replacing this expression using this rule. And then we still have the second right paren that we had before. This isn't going to match here because we need two right parens to match. And the essence of this rule is that every time we open a parenthesis we have to eventually close it. So we can't product expressions where the parenthesis aren't balanced. So this is not a valid Python expression. We can produce the third one, this has many nested expressions. We have three perens that are open, but we have balanced and closed perens. And the way we can derive this expression, we'll start with one expression that's our starting point. We use this rule to replace it paren expression, paren. Now, we have an expression that starts with a one, so we want to replace this expression with expression operator expression. We still have the outer parens that we had before. Now, we're working on this part. We want to to replace this expression with a number and then with the number one. We're going to replace the Op, the following operator goes to times rule. That's going to be replaced with times And now we've got to replace this expression. We're trying to produce this whole thing, so we're going to replace this with, using the parentheses rule. And we can keep going, we're going to replace this expression with expression operator expression. Eventually get the two times and then do that replacement with parens again, to get the three times four. And not going to fill in all the steps here because they won't fit on the screen. But I hope you get the basic idea that we can keep doing the replacements, making complex expressions like this one. So the fourth possibility is not a valid expression. There's no way that we can get An operator in front with this rule. There actually are rules in Python that allow us to have an expression go to operator expression. But we have two expressions here. There's a three space three. If it was just the number 33, this would actually be a valid Python expression. Not something that we can produce with this grammar though. And the first one is valid It's not sensible, or necessary, to have er, nested parentheses like this, but we could always keep using this rule, so we can derive that expression starting from expression using the last rule with the parens, and we're going to end up with paren, expression, paren, close paren. We can use that rule again, we're going to replace the middle expression with expression paren expression. Replacing this expression with the last rule. That'll give us expression surrounded by parens, and we still have the two outer parens on each side. So we can have as many necessary parens as we want. It's not necessary, it doesn't make a lot of sense. We would never actually want to write code that way. But it's still a valid Python expression. So recursive grammar rules like these are very powerful. We only need a few simple rules to describe a big language, and the whole Python language that we're going to learn in this course can be described this way. We're not going to describe the entire Python language this way, but what I hope is that you have a good sense for how grammars work, and you can see that, even as we introduce constructs somewhat more informally as we go on, that they could be broken down into these kinds of formal or placement rules. So before we go on to the next major computer science topic we're going to introduce. I want to give you one more quiz, to see if you can write a python expression that's going to give you some idea how fast a computer executes. So your goal for this quiz is to write some python code that will print out how far light travels in one nanosecond. Let me give you some information that will help with this. So, the speed of light is 299,792,458 meters per second. So, almost 300 million. One meter is 100 centimeters. One nanosecond is one billionth of a second. Which is 1 divided by 1000 000 000. So, your goal is to compute how far light travels in one nanosecond, and to get that answer in centimeters. And I don't want this to be an algebra quiz. So, all you need to do is multiply these three values together, and you'll get the answer we want. So here's the Python expression to compute that. We're multiplying the speed of light times 100 cm in a meter, times 1 divided by 1 billion. One nanosecond is one billionth of a second. You'll note that I can't have space in the numbers. It's convenient when I write out the numbers to put spaces in them, so we can see how big they are. Python doesn't allow that, that looks like separate numbers if we have spaces there that wouldn't be valid in the Python grammar. So we can't have the spaces there, so when we run this we get the result 29. That says it's about 29 centimeters that light travels in one nanosecond. This is a little surprising that is an exact number, and it's an integer, and the reason it's an integer is because of the way Python does arithmetic. If all the numbers here are integers, Python will truncate down to that integer. If we want a more accurate result we should turn one of these numbers into a decimal number. So now we've changed the one to 1.0, now we run it we get 29.979. Two, four, five, eight, so almost 30 centimeters, which is a better answer than 29 was. So why do we care about how far light can travel in one nanosecond? If you know what kind of processor you have, and if you have a Mac, you can find this by selecting from the Apple menu, About this Mac. They'll be instructions on the website how you can do this for other operating systems. But you'll see a window like this appear that will tell you what kind of processor you have. And if you zoom that a little bit you can see that we have a 2.7 GHZ Intel Core processor. What GHZ stands for is gigahertz. Which means that we can do 2.7 billion cycles in each second. So that means the time we have for one cycle. Is actually less than a nanosecond, and you can think of a cycle as the time that computer has to do one step. So it does one step 2.7 billion times in a second, that means the time for each cycle is 1 divided by 2.7 nanoseconds. So that means in the time that computer has for one cycle, light travels 11.1 centimeters. So how far is that? So, let's have a little scale here. If we have a dollar bill, that's actually quite a bit longer than 11.1 centimeters. 11.1 centimeters is about three quarters of the way across the bill. So within the time light can travel that distance, the computer's gotta finish processing one cycle, finish at least part of an instruction. This should give you some idea of how fast the computer is operating, and this is part of the reason the processor has to be so small. If the processor was bigger than 11 centimeters, we couldn't even send light across the processor in the time for one cycle. One of the pioneers in computing was Admiral Grace Hopper. She was famous for walking around with nanosticks, which were pieces of wire that were the length light would travel in a nanosecond-- 30 cm long. Grace Hopper wrote one of the first languages, and the language COBOL, which she is seen holding here next to UNIVAC, was for a long time the most widely-used computer language. She was one of the first people to think about writing languages this way, ["Nobody believed that I had a running compiler and nobody would touch it. They told me computers could only do arithmetic." Grace Hopper] and you have this quote when she talked about writing compiler, and a compiler is a program that produces other programs, like Python. The difference between a compiler and an interpreter like Python is the compiler does all the work at once and then runs the new program whereas with an interpreter like Python you're doing this work at the same time. But she had this great quote talking about no one believing that she could do such a thing, and they told her that computers could only do arithmetic. So far we've only seen computers do arithmetic. We're going to see lots more interesting things in our Python program soon. There's a link on the website to a video of Grace Hopper's appearance on the David Letterman Show where she gives him a nanostick. I hope you'll enjoy watching that. So our answer to the last quiz would've been a lot easier to read and a lot more useful if we used names to keep track of values, instead of writing out those big numbers, especially numbers as big as the speed of light. Python provides a way to do it. It's called the Variable. We can use the variable to create a name and use that name to refer to a variable. So the way to introduce a variable is using an assignment statement. And an assignment statement looks like this. We have a name, followed by an equal symbol, followed by an expression. After the assignment statement, the name that was on the left side refers to the value that the expression has. The name can be any sequence of letters and numbers, as well as underscores, as long as it starts with a letter or an underscore. So here's an example, we could create the name, speed_of_light, and we can assign to it the value of the speed of light in meters per second. So after that assignment, the name speed_of_light refers to that value. One way to think of that is to have an arrow, so we can have the name speed_of_light, and that's a name which refers to a value. And the value it refers to is this long value, which is the speed of light in meters per second. So once we've done the assignment, we can use the name and the value of the name is the value that it refers to. In this case it's the speed of light in meters per second. So let's try that in the Python interpreter. So here we've introduced the variable speed of light and we've assigned to it the value 299,792,458, the speed of light in meters per second. And now we've got that, assign it a variable. Instead of having to type out that whole number, we can use it directly. When we print out the speed of light, it will be the value that that name refers to. So we'll see, instead of seeing speed of light, we'll see the 299 million value here. We can use in expressions as well. So if we want to convert it into centimeters instead of meters, we can multiply by 100 and now we see the result is the speed of light in centimeters per second. So let's define another variable. This one will define billionth, which means 1 divided by 1,000,000,000. That's hard enough to remember how many zeros to type, so it's nice to have that in a variable. And now we can define nanostick, which is the length of Grace Hopper's nanostick, as the speed of light times a billionth. That would be the length of the nanostick in meters. If we want it in centimeters, we can multiply by 100. And so now we've defined a variable, nanostick, which is the length light travels in a nanosecond, in centimeters, and we can print that out. So, variables are really useful. They're going to make our programs a lot easier to understand. They also mean that we can use the same expression, changing the values of the variables to compute different things. So, now it's time for a quiz to see if you understand variables. So for this quiz, the question is, given the variables that are defined here, and you'll see the variables already defined in the code in your web browser. Your goal is to write Python code that prints out the distance, in meters, that light travels in one processor cycle. Do the first variable as speed of light, and we've assigned to the variable speed_of_light the number of meters that light travels in a second. It might be hard to remember that. So we also have a comment there. We haven't used comments yet but they're a very useful thing to add to our programs. We can write a comment by starting with a hash symbol, that's usually the Shift+3 on most keyboards. Everything from the hash to the end of the line is a comment. That means it's ignored by the Python interpreter, but it's useful for the programmer to be able to see it. So we'll have a comment here that says that's meters per second. We can put anything we want in our comments. They are not interpreted by the Python interpreter. But it's a good idea to have comments that are helpful for us to remember what we did if we need to go back to the code a few months from now and understand it. It's also a good idea if someone else is reading the code, the comments will help them understand it. So the second variable, we'll call cycles_per_second, and we'll give that the value 2 billion 700 million. And I'm going to give it a decimal point so when Python does division, we'll get exact results. And we'll also give a comment for this one to indicate that this is the 2.7 Gigahertz speed that the processor in my computer has. So now, given those two variable definitions, your goal is to write some Python code that prints out the distance, in meters, that light travels in one processor cycle. And we can compute that by dividing the speed of light by the number of cycles per second. So, here's one way to answer this question. We have our two variable definitions. We can print out the distance light travels in one cycle by dividing speed of light by cycles per second using the variables, and when we run that we see the result is 0.11. So, that's 0.11 meters, or 11 centimeters. Another way to solve this that might be better would be to introduce another variable. So, instead of just printing the result, we can store it in a variable. We'll call it cycle_distance. Now, when we run it, there's no result. We haven't printed that out yet. But we've stored it in a variable. And now, we can print out the result of cycle_distance. Which gives us the 11, 0.11 meters. If we want the result in centimeters, well since we've already stored the result in meters in a variable, we can compute that by just multiplying that by 100. And now we get the result in centimeters. So the speed of light is a constant. But the important thing about variables in Python is that they can vary. That's why they're called variables. Once we define the variable, we can change the value. And then when we use that name again it refers to the new value. So let's see that in an interpreter. We could change the value of cycles_per_second. Suppose we have a faster processor. Now we've upgraded, we've got a 2.8 Ghz processor. Now, that doesn't affect the value of cycle distance. This was already computed with the old cycles_per_second. We still get the result, 0.111. We'll compute it again. This time the value of cycles per second is the new value since we changed what cycles per second refers to. And now when we print cycle_distance we see that the values changed. So we have a faster processor the second time we print cycle_distance now we only have 0.107 meters, less than 0.11 centimeters per cycle. So what happens now that we have assignment, the same expression can have different meanings at different times we evaluate it. The value of the speed of light divided by cycles per second depends on what the current value of cycles per second is. When we evaluate the first one, the value was 2 billion 700 million, so we got a different result, which was the 0.111 result we got the first time. When we evaluate the same expression the second time, the result's different, because the value that cycles_per_second refers to is different. And that's why we get the smaller cycle_distance the second time. So, let's see what's going on there and make sure we understand assignment. So, suppose we have a variable, days. And we'll initialize it to the value 7 times 7. So what that does is introduce a name days. And it refers to a value, which is the result of that expression. So it refers to the value 49, and that means when we look at the name days, we see what it refers to and we get the result, 49. If we do another assignment. Let's say we have one less day. And in this case we'll assign 48 to days. Well, that's a new assignment. We already have a name days. It used to refer to 49. But after the new assignment, it's going to refer to this new value. Now it's going to refer to the value 48. The number 49 still exists, but days no longer refers to it. Now days refers to 48. Where things get more interesting is we can use variables in their own assignment statements. So here we have an assignment statement where we have the value days minus 1 and we assign that to days. So what happens with that assignment? Well, we evaluate the right side first. We look for the value of days and we see that it refers to 48. We compute days minus 1 and we get the value 47. Then we do the assignment that will assign to the variable days. So now the value days refers to the value 47, no longer refers to 48. So we could keep doing that, if we did another statement, same exact one, that's going to change the value again. This time, the first time, the value days is 47, we'll subtract 1, we'll get the value 46. And then we do the assignment, that'll change the value, so now days refers to the value 46. So the important thing to notice, this is not an equal symbol. This looks like an equal symbol. If you studied algebra you would think an equation like this looks like an equality, and there is no way to solve an equation like that. In Python and in most programming language, equal does not mean equal. What equal means is assignment. You should really think of it as an arrow. It's an arrow saying put whatever value of the right side evaluates to, into the name on the left side. We don't write it as an arrow in most programming languages. There's some that do, just because an arrow is harder to type, and lots of programs have lots of assignments. But you should think of the equal sign as not meaning equal, it means assignment. So now, we're ready for a quiz to see that you understand the meaning of assignment. So the question is, what is the value that the variable hours refers to after running this code? And the code is below. First, we have an assignment statement assigning the value 9 to the variable hours. Then, we have another assignment statement where the right side is hours plus 1 and the left side is hours. And then we have another assignment statement where the left side is hours, and the right side is hours times 2. So the possible answers, the value of hours is 9, the value of hours is 10, the value of hours is 18, the value of hours is 20, the value of hours is 22, or it's an error. So try to figure out the answer yourself without evaluating this code in the interpreter. If you want to evaluate code in the interpreter, though, it's certainly a good idea to try that. So the answer's 20. And here's why. So initially, we've created the name hours, and assigned it the value 9. So, I was, will refer to the number, 9. That's what we have after the first assignment statement. For the second assignment statement, first we evaluate the right side. And that says hours plus 1. That will produce, 10, heading 1 to 9. And now we assign that new value to hours. So that'll change what the name hours refers to. Now ours will ref, refer to the, number 10. Then we do a multiplication. The third assignment statement, has hours on the right-side, hours times 2. So that will evaluate to, the value hours refers to which is 10, times 2, so we get 20. And then we get assignment, that will change the value of hours to now refer to 20. So, at the end of these statements, the value of hours is 20. So we'll have another quiz about variables. This one's a little tricky. So the question is, what is the value of seconds after running this code? The code has two assignment statements. The first one assigns to minutes, the value of minutes plus 1. The second one assigns to seconds, the value of minutes times 60. Possible answers, 0, 60, 120 or error? Like the previous one, see if you can guess what the answer is yourself. You can always try running the code in the Python interpreter. So the answer is, it's an error. And the reason why is this first assignment has minutes on the right side, but we didn't define minutes previously. So, if we use a variable that's not defined, there's no meaningful value for this. The Python interpreter will give us an error. Let's see that in the Python interpreter. So here, we have just the first assignment. When we run this, we get the error that says the name minutes is not defined. Minutes is not defined because we didn't introduce that variable yet. It looks like we're defining it. We've gotten in on the left side, but the right side needs to execute first. So without knowing the value of minutes, there is no sensible value this code can produce, so running the code produces an error. If we have a statement before this that gives minutes a value, then the code will be fine. We can run this, there's no error. And we can do the assignment that we had in the quiz, assigning to seconds minutes times 60, and print the value of seconds. This works now, but only because we added this definition. We need to always introduce a variable before we use it. So we're going to have one more quiz about variables. Variables are a really important concept. We're going to use them all the time in the programs that we write. So this quiz is going to test if you can define a variable.yourself, and use that to do a computation. So your goal for this quiz is to write Python code that defines the variable age, gives it the value of your age in years, and then prints out the number of days you've been alive. You don't have to use your real age. If you don't want to include your real age, you can make up whatever age you are or you can use your age in spirit. The important thing is that you can define that in a variable and then do the computation. So there are lots of different ways to answer this, especially, depending on your age. Here's one way. So, I'm going to define the variable, age, and I'm going to use my age in spirit, which is 7. And then, we'll multiply that by the number of days in a year. But let's also define a variable for the number of days in a year. And we could use 365. If we want to account for leap years, it would be more accurate to use 365 and a quarter, since one quarter of the years are leap years. And to compute the number of days that I've been alive, we can multiply those two values and print out the result. So let's try that in the Python interpreter. So here, we've defined our two variables. We have age is 7, not my real age, in case you're wondering. And days_in_year is 365 and a quarter. So we'll multiply those two to print out the result, which is 2556 and 3 quarter days. Quest to do this more accurately, we'd need to use a real age. And our actual age is probably not an exact number of years, unless it's your birthday today, in which case, happy birthday. But otherwise, you'd need to add the number of days since your birthday to get a more accurate number. I'll change my age to my real age. And I will add the number of days since my birthday. Which is 268, if you're watching this on the day it's released. And then we got my age, in days, is 14,878. Which seems pretty old. So, so far all the computation we've done is operated only on numbers, and in the early days of computing, people thought of computers as super powerful calculators, for doing computations like simulating nuclear weapons, computing ballistic tables, or breaking encryptions, which was a little more than just arithmetic. But still was mostly about counting and doing simple arithmetic. We saw this quote from Grace Hopper earlier talking about computers could only do arithmetic, and this is what people thought about computers in the 1940s and 1950s. But there's no reason to limit computers to that. They can operate on any kind of data we want, and it gets much more interesting when we operate on data besides just numbers. If we're going to build a search engine, most of the data that we want to deal with is not numbers. It's the letters that are contained in webpages, and in Python, that's what we call a string. A string is just a sequence of characters surrounded by quotes. So here's an example of a string in Python, it starts with a single quote, has a sequence of characters and anything that we can type on the keyboard can be in a string, and ends with another single quote. The string is the sequence of characters between the single quotes. If we want, we can use double quotes instead. If we use double quote, then the double quote starts the string. We can have a sequence of characters and a double quote that ends the string. The only requirement is that if we start the string with a single quote, it has to end with a single quote. If we start the string with a double quote, it has to end with a double quote. And that's actually a handy property. Because that means we can have the other kind of quote within our string. This string starts with a double quote. It contains a single quote inside it. But because we started with a double quote, that single quote doesn't end the string. That single quote is just like another character in the string. The string continues. Until the closing double quote. So let's try some things in the Python interpreter. So, we can print a string, just like we can print a number. So here I'm printing the string hello. And when we run this, we see the output hello. It's printing hello. We don't see the single quotes as it prints, but we know that it's a string that was printed. We can print a string with double quotes, and one thing to notice when you enter strings through the interpreter, the color is black now, since it's an open string, it hasn't been finished, once I type the final quote, that closes the string, the color changes to blue. So now when we run this, we have two prints, both that print hello, it looks the same both times. It doesn't matter if we use single quotes or double quotes around our string. Just to check everyone's paying attention, I'm going to try one more thing. And now I am printing hello without the quotes. You can guess what that will do. We won't make a quiz of this, but try to guess before I run it. Now that I run this, we see the result. We get a name error. The name Hello is not defined. Without the quotes, this looks just like a variable. It's a name, but it's a variable that we didn't define. So when I try to use it, I get an error that the variable name Hello is not defined. If I wanted to I could define a variable named hello. Let's make hello refer to the string howdy and now when I print hello, it works. I see the first two prints that printed hello, now when I print the variable hello, well that refers to the string howdy and I see howdy as the result. We usually don't want our variables to start with capital letters. That's just a convention, so I'm going to change this back to a lower case hello because it makes me feel uncomfortable to have a variable with a capital letter. There's no rule against that in Python. It's just a convention that we like to follow. So now we're ready for our first quiz about strings. So the question is, which of the following are valid strings in Python? So here are the choices. Check all of the choices that are valid strings. So the answer, the first one is a valid string; it has a double quote followed by another double quote, and a sequence of characters between the double quotes. The second one is not a valid string, and the reason it's not is because it starts with a single quote, but ends with a double quote. A valid string must start with the same kind of quote it ends with. The third one is also not a valid string, and the reason for that is it starts with a double quote but there's no double quote that closes the string. The fourth one is a name, this is a variable, it's possible it could be defined to be a valid string, but without defining Ada as some string, it's not a valid string by itself. The surprising one, might be the last one. This is a valid string, it starts with a single quote, it ends with a single quote and it's perfectly okay to have a double quote in the middle. If you're wondering who "Ada" is in all of those strings, Ada is Augusta Ada King, who is arguably the world's first computer programmer. Back in the 1840's, in England, she started to think about how to program mechanical computers-- Charles Babbage was proposing to build such machines-- and Ada was the first person to really think about how to program them. Grace Hopper wasn't the first person to think about doing things other than arithmetic with computers. Back in the 1840's, Ada was already thinking about that. You can see this quote here from her: "It might act upon other things, besides number, were objects found whose mutual fundamental relations could be expressed by those of the [abstract] science of operations..." The "it" that she's talking about is the analytical engine that Babbage was proposing to build. He never succeeded in building it-- in the 1840's, the technology for building it was not quite good enough to make a machine that precise. But he had a design for it, and Ada was thinking about programming it to do more interesting things. The quote goes on to talk about actually using it to compose music. ["...and which should also be susceptible of adaptations to the action of the operating notation and mechanism of the engine..."] People do use computers to compose music today. It's debatable whether or not you actually want to listen to that music, but certainly it's something computers can do. So, now we're going to have a quiz to see if you can actually use strings. Your goal is to define a variable, the name, name and assign to it a string that is your name. So, assigning a string to a variable is just like assigning a number to a variable. We can do that with an assignment statement. My name is Dave. So, I'll assign the string Dave, to the name, to the variable name. The nice thing about using a variable like this, is now we could have code. Say print Hello plus name. Here hello is a string. Name is a variable. If you assigned name to mean some other string, this will print Hello whatever the value of name is. I've introduced a new operator here. We're using the plus operator. We already saw plus on numbers. Now, we're using plus on strings. It means something different. What plus means with strings is concatenation. So we can put strings together by using the plus operator. The value of the string plus another string is the concatenation. That's a new string that's a result of pasting those two strings together. So let's try that in the Python interpreter. So here I've initialized the variable name to be the string Dave, and I'm going to print out hello plus name. You'll see I won't get quite what I want from this? Here's what happens, it concatenated the two strings together, it doesn't add spaces or anything automatically. So now we've got, the output is hello Dave, without any space in it. We need to add a space here. Now we'll have hello space Dave, which looks more like we want. We can keep doing this just like we could use the plus operator with numbers more than once, we can use it with strings more than once. Adding another string to the end, now we've got the exclamation point I need. Maybe one is not enough. We can keep adding more exclamation points. Now I have a more pleasant reading. So, it seems we can use plus with numbers and we can use plus with strings. What if someone tries to use plus with a string and a number at the same time? So, suppose my name is actually the number 9. Well, when we try and run this, what we get is an error. Here's the error we get. This is a little different from the syntax errors we've seen before. This is still in the Python grammar. But it's something that doesn't make sense. What we tried to do was concatenate a string, which is the string My name is, and the number, which is the integer 9, and it doesn't make sense to paste those together. At least Python doesn't know what it means. So this produces an error, we can't add numbers and strings together. We can multiply strings though, this is a little strange. And so, here I'm doing the exclamation point string times 12, and what I get is 12 exclamation points. This is better than having to type them all out. So I can change, instead of doing Hello name, exclamation point plus exclamation point, I could do exclamation point times 3 here. And this would be the Hello Dave with 3. So if I'm very excited to say hello to myself, I could do exclamation point times 38. And then I'll get Hello Dave, followed by 38 exclamation points. So one of the things we can do with strings that we can't do with numbers, is we can extract subsequences from the strings. So remember what a string is, is a sequence of characters. If we have a string, we can use the square brackets to extract parts of that string. So if we have the string udacity, and we use the square bracket, with the value 0, that would select the zeroth character from the string. The characters of the string are indexed starting from 0, so the result of index 0, is the string with just the letter u. The expression inside the square brackets can be anything that evaluates to a number. So we could have, 1 plus 1 in here. 1 plus 1 evaluates to the number 2. And at position 2, we find the letter a, so the value of this would be the string containing the single letter a. This looks a little strange and we wouldn't normally use indexing with the string literal like this, but it does work. It looks a lot more normal when we're doing it with a variable. We've initialized the variable name to the string Dave. Then when we do name index 0, whatever the variable name is, that will give us the first letter of that string, in this case it's the uppercase D. Let's try that in the Python interpreter. So here, I've defined the variable name, with the value, the string Dave. And I'm printing name index 0. I get the first letter. If I try instead, to print name index 3, that will give us the fourth letter, the e. Suppose I tried to do name index 4. Well, there's no character at position 4, remember that the indexes start at 0, so this is 0, 1, 2, 3. When I run this, what I get is an error. I get an error because I've asked for position 4 of the string; that's out of range, so the error I get says that that string index is out of range. What I can do is use negative numbers. When I use negative numbers in my index it starts counting from the back of the string. So name index negative 1 will go as the last character in the string. If I do name index negative 2, that will give us the next to last character which is the v. So the question is, given any variable, we're going to introduce the variable S, and we're going to assign it any string. Which of the pairs below are two things where both elements of the pair are the same exact value? So here are the choices. Check all the choices where the first thing and the second thing have exactly the same value. So the first thing is S index 3, S index 1 plus 1 plus 1. So, for any string that we choose for S, those two always have exactly the same value, then you should check this box. Second, we have S index 0 paired with S plus S, index 0. For the third choice, we have S index 0 plus S index 1 paired with S index 0 plus 1. For the fourth choice, we have S index 1 paired with S plus the string ity index 1. And for the fifth and final choice, we have S index negative 1, and remember, the negative indexes go from the back of the string, paired with S plus S index negative 1. So for this question, you should check all the boxes where the two items in the pair have exactly the same value, no matter what value S has, as long as S is a valid string. So here's the answer. The first one is true. S index 3 is exactly the same thing as S index 1 plus 1 plus 1 because 1 plus 1, plus 1 evaluates to 3. These two have the same value. If S is a string with at least 4 characters in it, this will get the fourth character from S. If s has fewer than 4 characters, both of these will produce an error. The second choice, both of these actually also have the same value. S index 0 will get us the first character of S as long as S has at least one character; otherwise it will produce an error. S plus Swill produce the string, concatenating S with itself but its first character is still the same as the first character of S, so these two are equivalent. The third option is not equivalent. So here we're taking the first character of S, concatenating that with the second character of S. Here we're taking from S, the 0 plus 1th character, which is, evaluates to 1 so that's the second character of S. This is just going to be one character, this is two characters. They're never equivalent. The fourth option is sometimes equivalent. If S is a string with at least two characters then S index 1 is the second character from S. S plus ity index 1 is the second character for S. The problem is that if S has less than two characters. So suppose our value of S was just a one letter string. S index 1 will be an error. There is no second character from S. S plus ity index 1 would be the second character of the string that resolves from that concatenation which would actually be the I. So these are not always equivalent. They are equivalent in the case where S has at least two characters. The final option, we have S negative 1, so that means the last character of S. And we have S plus S, which produces the string which concatenates S with itself in X negative 1. That's going to be the last character of concatenating S with itself, which is the same as the last character of S. So there are lots more things we can do with strings. The next one I am going to talk about, is selecting sub-sequences from strings. So what we have seen so far, we have used indexing, where we have a string, where we have our square bracket. We have some expression that produces one number, and we have our closed square bracket, and that gives us a one-character string. And whatever position the number refers to in the string here. The other thing we can do with square brackets is select a sub-sequence of the string. Instead of just having one expression here, what we can have is an expression. This is also something that should evaluate to a number, followed by a colon, followed by another expression. Both of these expressions are numbers. And this will evaluate to a string, this is a subsequence of a characters in, the input string. So I called the string s, the value of this number will call start, and the value of this number will call stop. And what the result is, is a string that's a subsequence of all the characters in s, and the string that we had here. Starting from position start, so the number to the left of the colon, and ending with position stop, but not including that character. So it's going to really include the characters from position start, up through stop minus 1. So this construct allows us to select from any string A subsequence of continuous characters in that string. So, let's try an example in the Python interpreter. I'm going to initialize the variable word to be the string assume. And using the single index operator we saw initially, we can select a character from word. So, if I select word index 3. That will give us the fourth character, zero, one, two, three, which is u, and when we run that, we see the result is u. With the new operation, that's the same as selecting word 3:4, that's going to select starting from position three, going to just before position four. So that will end up being just the one letter u. Just to make this clear, if I selected 3:3, there's no string there, that's just a single empty string which prints out in a way we can't see it. There's no characters between 3 and character 3. We'll go back to just selecting index 3. I could select from position 4 through position 6. That would give us a string which is a subsequence of letters at position 4 and position 5. So when we run this now we see the first one prints out to u. The second one prints out me which is position 4 and position 5. The last two characters in the word. I'll show you one other thing we can do. Which is, leave one of the sides of the colon empty. So it we did 4: to the end, that will select from position 4 to the end. We don't need to actually count the characters to know where the end is. So that will produce the same thing as we did before. We can also leave nothing in front of the colon. That will select from the beginning. So if we do :2, that will select from position 0 up to position 2, giving us the first two letters of the word, as. And we could leave both sides blank, selecting word, [:], with nothing on either side, well, it starts from the beginning, goes to the end. That's going to give us the whole word. There's no good reason to ever want to do this, but it's consistent with the syntax where we can leave one side of the colon empty and that means selecting from either the beginning or the end. So now we'll have a couple quizzes to see that you understand how to index subsequences from strings. So your goal for this quiz is to write Python code that will print out Udacity with an upper case U, given that we've already defined the variable S to have the value, the string audacity. And we want you to do this in a way that uses the string indexing operators up. It wouldn't be a good way to solve this by just printing out Udacity with an upper case U as a string. But see if you can find a way to write Python code that uses s and has as little extra code as possible but prints out the string Udacity starting from s. So the answer is, we want to select the part of the word that we can still use in our solution. So we can't keep the a, and we can't keep the lower case u, so those are positions 0 and 1. From position 2 to the end is good, so we can produce that using the index selection. We're going to select from s, starting from position 2. If we wanted, we could count all the letters and select from s to the final position. We can also just use a closed bracket. We don't need to count the letters that's going to select from position 2 to the end of the string. Now, we want to get the uppercase U in front. So, we're going to have an uppercase U added to that. And finally, we need the print to print that out. So, here that is in the Python interpreter. We have the definition of s that was provided. And what we're going to do is print out capital U plus S, two colon to the end. And as expected, we get our result: Udacity. So selecting sub-sequences from strings is a very useful thing, we're going to use it lots of times in many of the programs we write, so we're going to have one more quiz about this. This one's going to be a little more abstract, so for this one, you're given any string S, so S is a variable. It holds a value of any string, and the question is, which of these are always equivalent to the string S, no matter what S was at the beginning? So here are the choices. We have S index colon. We have S concatenated with S index 0 colon negative 1 plus 1. We have S index 0 colon. We have S index colon negative 1. And we have S index colon 3 plus S 3 colon. So your goal is to check all of the expressions here that have the same exact value as S, no matter what string S is initially. Feel free to try evaluating things in the Python Interpreter. Try to think about it without doing that first. But you're welcome to do experiments running code in the Python Interpreter to try and answer this. For remember, for your answer to be correct, it has to work for any string S, not just the one that you try. So here's the answer. The first one is always equivalent to the string s, remember what it means to use the colon when there's nothing on the left side means, start from the beginning, and when there's nothing on the right side, means go all the way to the end. So if there's nothing on on either side, that's selecting the entire string. So the second one's a little trickier, but this also always has the same value as the string s. And the reason is, we have the original string s, and we're concatenating to it the string s index 0, colon negative 1 plus 1. Well, negative 1 plus 1 has the value 0. When we index from 0 colon 0, that's an empty string. And the reason that's an empty string is because we're starting from 0. And we're stopping just before 0, there are no character between 0 and 0 so that's an empty string. Adding the empty string to itself, leaves the string empty. And the interesting thing about this is, this works even when s is an empty string. If s was an empty string, s index 0. That would produce an error. It's trying to select the first character from s, and there is no first character since s was an empty string. But s index 12 colon 12, even though there is no 12th character of, of s, since there is no characters between there, it's okay that s doesn't have them. That's going to valuate to the empty string. So, the third one is also always equivalent to s. It's selecting from the beginning of the string, position 0, all the way to the end. Again, as we saw here, even if s has no characters, this is still okay. It will give us the empty string, if s has any characters, it will give us all the characters in s. This first one is not equivalent, and this might be a little surprising. It sounds like, well, it's selecting all the characters from the beginning to the end, because negative 1 is the index of the last character in s. But remember that the selection stops before the last character. So what this do, will do will give us every character besides the last one. So let's see that in the Python interpreter. Were going to print s index, colon, negative one, and this will give us all the characters except for the last one. So the final one is the most surprising. That this actually is always equivalent to s. It's equivalent even if s has fewer than 3 characters. So the first part of selecting all the characters from the beginning up to position three, not including position three, and then we're concatenating that with all the characters of s from position 3 to the end. If s has less than 3 characters, well this is going to be empty. There are no characters from position 3 to the end. But that's okay, we're going to add the empty string to the characters before position 3. So here's how that works in the python interpreter. We'll do s from position beginning to index 3 and add that s to index 3 to the end. That produces the same string. And if we do this with a shorter string. Let's initialize t to be the string, Hi. We can print from t to position 3 plus from t to position 3 to the end. We don't get an error. We get the string Hi out. So, this indexing subsequences is very resilient. It works even when we index positions that don't exist in the string. This is different from when we were doing indexing of particular positions by themselves. If we did index t, index 3, that will give us an error. Because there's no character at position 3. So I want to introduce one more operation on strings, which we'll find very useful, which is the Find operation. It gives us the way in a big string to find some sub-string that we're looking for. The way we use Find is a little different from the way we've used other operators so far. Because Find is actually a method, and what that means is it's a built in procedure provided by Python. We'll be able to define our own procedures soon, we'll get to that in unit two. Find is a procedure that operates on strings, so we use it by having a string followed by .find, followed by a parentheses, then we pass in another string. Which is the string that we want to find in the first string. And the output of Find is the position in the string where that sub-string is found, the first occurrence of the string. So, if that string happens to occur in more places than one in the input string, the result of find is always going to give us the position. That's the number where the first occurrence of the sub-string occurs. So the output of using Find will be the first position in the search string, which is this blue string right here, where the target string, which is the purple string, occurs. So that will be a number. If the target string is not a found anywhere in the search string, then the output would be negative 1. So let's try a few examples to understand how that works and we'll do this in the Python interpreter. Here I've initialized the variable Pythagoras to hold the string here that's been attributed to Pythagoras. We don't know if he really said it. But it says there's a geometry in the humming of strings, there is music in the spacing of spheres. So now, we have that variable initialized, so I'm going to invoke Find, using Pythagoras as the string that we're searching in, and that's the value that we initialized it to with a string, passing in as the search string the string string. When we run this, we see that we get 40 as the result. If we counted, this is position 0, we would see string starting at position 40. Since I don't want to count that far, we can use our indexing to see if that's right. So let's print Pythagoras starting from index 40, we could print all the way to the end using a colon. And, when we run that, we see that it starts with string which is what we found with the Find. We can search for other positions if we search for Pythagoras the single letter T. Well that matches the beginning, so we should find the resulted position 0 which is what we get and we can look for sphere. [BLANK_AUDIO] That will match sphere at the end. We get position 86. Let's print the quote from position 86. And we see the end of the quote starting from sphere. [SOUND] If we search for a string that's not in the string that we're using as the search string, so let's look for say, algebra, which was not in the quote from Pythagoras, we get the output negative one. That means the string was not found. So the question for this quiz is, which of the following will evaluate to negative 1. So here we have the string test invoking find, passing in the string lowercase t. Here we have the string test in double quotes, using find to search for the string st. Here we have the string test in double quotes with a capital T. Searching for the string using find lowercase te. And here we have the string west, finding the string, test. The answer is that find will return negative one. When the target string is not found in the search string. Of the four examples here there are two where that's the case. For both of these, it is found, so in the first example we're looking for t within the string test. It occurs in two places. But it'll find the first one, so the result of this find will be zero. For this one we're looking for the string st. Strings are the same whether they have single or double quotes. It doesn't matter what we use, as long as we're consistent with the first and the end quote. And in this case we find the string st at position two, so that would return two. For this one we used an upper case t, a lower case here. The find has to match exactly, it has to be the same character and case matters. So this would return negative one, and would be correct that this is one of the examples that returns negative one. And for the final one, we're searching for the string test, within the string west. They don't match exactly; so this would also return negative one. So here's a more challenging quiz about find. This one will require you to think pretty carefully about how find is defined. For any string, so we're going to have a variable s that we've initialized to any string. Your goal is to determine which of these will always have the value zero. So the first choice, s.find (s). Notice there are no quotes around s. The second one is s.find('s'). The third one is 's'.find('s'). The fourth one is s.find(''). And the final one is s.find Passing in s concatenated with the string. Three exclamation points, one of my favorites plus one. So check all of the answers where the expression here evaluates to zero, no matter what value the string s starts with. So try to answer this, just based on thinking, understanding the description of find. You can always also try things in the Python interpreter after that. And see if your interpretation is correct. But remember our goal is to answer the question where no matter what the string S is, the resultive expression is always zero. So here's the answer. The result of the first expression is always 0. No matter what string s is, we always find s at the beginning of itself. So, if we think of s as any string. If we search for the string hello, in hello, well, we're going to find hello at the beginning of hello, and that's position 0, that's what fun will return, no matter what string s is, the result of s.find s will always be 0. The result of s.find passing in the string s, will only be 0, if s started with the letter s. So this is not always true. The third example always is true, so here we have the string s, that's a string with one character s, and what we're trying to find in it is the string s. Well, we find that at position 0. So that's the result find we'll produce. The fourth one gets a little more tricky. So here we're looking in the string s. We're looking for the empty string. Remember the definition of find says it will give us the first occurrence where that string appears. Well the empty string appears in s. We don't actually see it, but it's there. We found the empty string. There's no string there no matter what s is. We can find the empty string in it, because we don't need any string to find the empty string. So the result of s.find passing an empty string, will always be 0, no matter what the string s is. So the final one is also always 0. And the reason for this, is when we search in s for the string s plus ! ! , well, no matter what s is. So even if it was a string that already included ! ! . So let's suppose that's the value of s. What we're trying to find is now s plus ! ! . So that's going to be what we had before, plus three more exclamation points. Searching for that within the string s will never be found. And we know it can't be found because this string is actually longer than the string s that we started with. So the result of this expression is always going to be -1. That means the string was never found. We add 1 to that, we get 0. That's why this expression will always evaluate to 0, no matter what the value of s is. So, there's one other interesting thing we can do with find. And going back to the original description of find, we said, well, find returns the first position, there might other occurrences. And we might want to find those other occurrences. The way to find those other occurrences is, we can actually pass in an extra parameter. So, instead of just passing in one string, we can pass in the second parameter, which is going to be a number. Then when we pass in a number what find will output is the number of the position in the search string, where the target string appears, the first occurrence after that position. So, it'll give the first occurrence where the target string appears in the search string, but starting from whatever position we pass in this number. So, if we pass in zero, well, it would start from the beginning, that would mean the same thing as the original find. If we pass in the position here, it would start from there and would still output the same value we found before. If we start from here, well then, it wouldn't find this occurrence, because this occurrence starts after that position, it would find this one. So, here's an example. We'll use this quote attributed to George Danton during the French Revolution. Translated loosely, it means audacity, more audacity, always audacity. I should mention that Danton was actually executed, so whether you want to follow this advice or not depends on how you think things worked out for him. But if we do a find with danton, passing in audace with no extra parameter, we'll get position five which is the position where audace starts. The first occurrence of audace is found. [NOISE] If we pass in a number as well, well if we pass in zero, we'll also get five. That's because starting from position zero, we find audace at position five. If we pass in the number five, we'll still get five as the result, starting from position five, we find audace at position five. If we pass in a number higher than five, let's pass in six, well now find is looking for an occurrence starting from position six, which is here. Instead of finding the first occurrence of audace, it'll find the first one that occurs after position six, which is the one here at position 25. Let's just print out the string from position six to confirm that. So, printing from position six to the end, we see that the quote is udace, encore. And so on. I'll spare you from my poor French pronunciation, and that's why it found audace at this location, which is position 25. The result always counts from the beginning of the original string. Position 25 of the original string, which is where it found the second occurrence of audace. So if we pass in 25. We'll get 25 as the output, finding the position where this occurrence occurs. If we pass in 26, now it will start searching at position 26 which is the u here. We'll find at position 47. The final occurrence of audace. So, seeing the string from position 47 to the end, starting from here, we see that. Now, we're starting from position 48, which is this u. We'll get as our output, negative one. And that's because, although the string occurs many times in the string danton, it doesn't occur at all starting from position 48. And so, the output of find, when the target string is not found in the search string, is negative one and that's true if we start from position 48, we don't find the target string at all in the search string. So now we're ready for a quiz to see if you understand the find command with the number as the second parameter, as well as indexing and selecting sub-sequences of strings. And the question is given any string variables, so we're going to initialize the variable s to hold any string. T to hold any string, and i to hold any number, which of the expressions below is equivalent to s.find passing in t as the target string ni as the number? So here are the choices, s index i colon, find t. S.find t index colon i. S i colon.find t Plus i or s, i colon, find t, i colon. So check all the ones that are always the same as s dot find t, i no matter what s, t, and i are. And for this quiz, this is pretty tricky. Try to think of the answer yourself before trying to run anything into the Python interpreter. But feel free to also run things in the Python interpreter to try to confirm your answer and to see if things behave the way you expect. So this was a really tough question, and I'll admit I got it wrong twice myself in trying to answer it. But I'm pretty sure I know the correct answer now. Which is that none of these are actually equivalent to s.find t,i. If you didn't get that, that's okay. Two of em are pretty close, and the two that are pretty close are the first and the third. But none of them are exactly correct and let's go through an example to understand why. So let's suppose we started with s as udacity. Let's make t city and make i three. So if we do s.find t,i, what we're going to get starting from position i which is n, s looking for city, we're going to find it right there. The output of s.find t,i with these variables is going to be three. So it, search is starting from position three, but it's still going to give us the output where that's position three. It gives us output in terms of the positions in the original string, s. So the first one, si:, where i is three, is going to be this string. So when we do the find where that's the string, we find city at position zero, and the result of this is zero. That's not the same as the result we expect which is three. The second one doesn't actually make any sense. So here s.find evaluates to a number, and then we're trying to index from a number, that doesn't make any sense. We can only index from a string, select a sub-sequence of characters, there's no way to select a sub-sequence of characters from a number. So this is invalid, definitely doesn't produce the same output as s.find t,i. The third one's the trickiest one. This is one that I originally thought would be equal and for this particular case it is. In this case when we do s 3 colon.find t well that's going to produce the result zero we that we saw before. And then when we add i to it; we're going to get the value three. So in cases where we find the string t, in s starting from position i; this will be equivalent. If we made t something else, so let's suppose we made t dog, well then what's going to happen is the result of s.find, t,i when t is dog, that result would be negative one. Find always returns negative one, when the string we're searching for is not found. In this case, we'd have negative one as the result for this, add i to it. That would give us the number two. That's not the same as negative one because this also is not equivalent. In cases where t is found, it is equivalent, but in cases where t is not found, it's not equivalent. The fourth one is also not equivalent. For the fourth one we're starting from selecting the sub-sequence of s, starting from position i. And we're looking for the string t where we sub-sequence from t starting from position i, this won't give us the same result as s.find t,i. So this was kind of a tricky question. You are not upset if you didn't get it right but the answer is none of these are actually equivalent to s.find t,i. Great, so you've passed the last quiz on strings. And Dave, I think you've explained strings better than I've ever seen it. I mean, I've always wondered what string theory's all about. And, and physicists work really hard on it, and it looks so easy. So do you know what, what [CROSSTALK]. I have no idea what the physicists are doing. They must have very long and complicated strings to deal with. I, I hear you can get a PhD in string theory, and now you know all about strings. Well, I think we know enough about strings now to move on to the part where we're building the web crawler by extracting links from the page. So now you know enough about Python to be able to solve the problem that we started with at the beginning of this unit, which the problem of extracting a link from its page. Before we get to the code, I want to describe a little more carefully what's going on in a webpage. So we've talked about strings in Python and all a web page really is, is a long string. When you see a web page in your browser, it doesn't look like that. So here's an example web page, one of my favorite XKCD comics. And hopefully, you're starting to learn enough about Python to appreciate the power of Python to make you fly. Probably the rest of the comic, if you haven't done anything other than using Python, is a little hard to relate for now. But it's making fun of other languages where there's an awful lot of work to do something simple, like we've seen here, just being able to print out a string. But with Python, we can fly quickly, and you're going to learn to fly very quickly in this class. This doesn't lok like just a string. We've seen just a string is a sequence of characters. When we look at a webpage like this, well we see images. We see buttons. We see some text. We see things that are links and you can see the underlines these are all links. And the browser renders the webpage in a way that looks attractive. What actually was there though, started just as a stream of text. If you right-click on the webpage, one of the options you see is View Page Source. When you click on that, you'll see the actual source code. This is what came into the browser. So, your browser sent a request, the URL is what's shown in the address bar. So, it's sent a request to xkcd.com/355. It sent that request and this is what came back. What came back is just a stream of text. We can look at that text and some of it is fairly hard to understand. So what's important is the links. Here's an example of a link. So, the link starts with a tag like this. The language HTML uses these angle brackets. And the angle bracket a href equals is how we start a link. That's followed by a string which is surrounded by double quotes, similarly to a string in Python. So, we have a double quote. Between the double quotes is a URL. The URL is the way of locating content on the web so here we have the URL http colon, that means it's a web request. We'll talk more in a later class about what http means and the protocols used to request web pages. What's important now is, that's a location If we open that in a web browser, that will give us another page. What I'm looking at here is the link that is underneath the text for News/Blag. If we click on that link, that will take us to the page blag.skcd.com. That was the page that we saw in the link here it said vlad.skcd.com. When we click on the link, that's where we went. So to build our crawler, what we want to do for each webpage, we want to find these links in the page. We're going to keep track of those links and we're going to follow them to find more content on the web. This is similar to what someone would do if their browsing. If they're clicking on every link of a page, following all the links they find, looking at all that content. That's a really good way to waste a horrendous amount of time if you do that yourself. We're going to build a web crawler that can do that automatically. So our goal is to take the text that came back from a web request, find a link in that text, which is going to be a tag that starts with a href equals and then extract from that tag the URL of the webpage that it links to. Those are the URLs that we're going to use in our crawler to make progress. So by using what we've learned about strings, and what you've learned about variables, you know enough to be able to do that. What we want to do is find the beginning of a tag. And what the beginning of a tag is this text right we're looking for something that matches exactly the a href equals part. That's what the tags were here they all start with a href equals. Not all webpages have the same structure. There are lots of other ways to make a tag. The A could be a capital letter for example. There could be more spaces between the a and the href. The double quote doesn't actually need to be there. For what we do now, we're going to assume that all our webpages follow the same structure that we're seeing here. That each link starts with an a h ref without any funny spaces or anything else. Has an equal, has a double quote, has the URL following that, and then another double quote. So that means we're looking for strings like this, we're looking to find the a href; that's followed by a double quote. After the double quote is the URL. This is what we actually care about; we want to find the URLs on the Web page. That's followed by a closing double quote and then, there's more that closes the tag. And there's lots of other stuff on both sides of this. But this is what we want to do. We want to find the tags that are links and then, within the tags that are links, we want to find the URLs. So we're going to assume that we start with the page contents in a variable. We'll call that page, and we're not going to worry today about how we got those page contents. We're going to provide a function that does that. For the code that you have today, let's going to assume the page is already initialized. That it contains the content of some web page stored as a string and our goal is to find the URL of the first link in the page. That's going to involve a couple steps. SO what we want to do is find the start of the link. We want to find where we have the a href equals. We can't just look for the first string we find, because there's lots of other strings on the page that aren't URLs. So I think you know enough to do that, so we'll make it a quiz. So your goal for this quiz is to write some Python code that will initialize the variable start link to be the value of the position where the first a href equals. So the first tag that starts a link occurs in page, so you should assume that page starts with the content of some web page, and what we're doing is looking for the place where the first a href equals occurs, and that's the first link on the page. So here's the answer. We can do this using the find method. What we want to do is find in the search string page the target string a href. So we can do that with code like this. We're going to have start link as the variable that we're initializing. That's going to be the left side of the assignment. And we're going to set its value to the result of calling find where page is the search string and the target string is a href equals. And that will give start link the value of a number, which is the position where the first link tag is found on the page. Now what we want to do is extract the url. So we found this position, that's going to be the value of start_link. Now our goal is to extract this url. And the url starts from the first double quote that we find after start link, and it ends with the second double quote. So for the last quiz of this unit, your goal is to write all the code we need to end up finding that url. So this is going to be the hardest quiz that we've had so far. It's going to involve you thinking about variables, thinking how to use find in different ways. And write several lines of code yourself. Think carefully about how to do this. But I think if you understand what we've covered so far, you'll be able to do this yourself. [BLANK_AUDIO] So to be specific, here's the quiz, your goal is to write Python code that assigns to the variable url. These are all lowercase letters, a string that is the value of the first URL found on the page, in a link tag. So you should assume that we have the variable page that's already initialized to the contents of the page. And in your browser this will be initialized to the contents of an example page. From the previous quiz we also have the value of start-link already worked out. It said start-link is the result of calling find on page, passing in the string, a href equals. And your goal is to finish this code, so at the end of this code, the value of url is the first link on the page. And if you print the value of url, and you've done all the code correctly for the example that we provided, you should get the result http://udacity.com, which is the url that finds the Udacity webpage. So this is pretty tough quiz. There's a lot of steps. Think about it carefully. So it uses almost everything that you've seen in the unit today. You'll have to think about how to use the find method, possibly passing in numbers as well as strings, as well as variables to keep track of things. To find the result, you'll also need to think about how to use the string indexing operators to select a sub-sequence of a string. So here's the answer. What we have to do is find these two double quotes. So we know that we want to start looking from start_link, we can't start from the beginning of page. So we want to use find on page, passing in the double quote, which is what we're looking for, starting from the start_link position. So here's how we need to do that, we're going to initialize the variable, start_quote, which is where that double quote that starts the url is. And what we want to do is use page.find, to find in page. The string that we want to find is that double quote. To make a double quote as a string, we need to use a single quote, followed by a double quote, followed by a single quote. We also need to pass in a second parameter. We don't want to find the first double quote in the page, because that might not be part of a link tag. So we also need to pass in the variable start_link. So that makes find start from the position of start_link look for the double quote, and it will return the location where that start quote appears. We also need to find the end quote. We'll call that end_quote. To find the end_quote we don't want to start from the start_link. If we started looking from the start_link we'd find the start_quote again. To find the end_quote we need to look starting from after the start_quote. So we're going to use page.find again. Again looking for a double quote, so passing in the double quote as the string we're searching for. We need to start from the position of start_quote. We can't start from just the position of start_quote. If we started from start_quote, we'd find just the start_quote itself. We knew to start one after that position, so we need to add 1 to start_quote. And if we start looking from there, we'll find the first quote after that. That's the quote that ends the string. So the final thing we want to do, is set the variable url. So we'll initialize url, to the string that we find between the start quote and the end quote. And so we can do that using the string selection. We're selecting from the string page. We have to think carefully about where we start. We don't want to start with a start_quote because that would include the double quote in the url. We just want the url not including the double quote, so we're going to start with the start_quote plus 1. And we're going to go from there until the end_quote. We don't want to include the closing double-quote. We don't include that one in the string. So we don't need to subtract 1 from the end_quote. And that will get us the url, extracted from the first link on the web page. So congratulations, you've made it to the end of unit one. You're learned a lot of computer science already, you know what a program is, you've learned about variables, you've learned about expressions and grammars, you've learned about strings in Python. So now it's time for you to work on homework one on your own. And that will check that you understood everything from this class and prepare you to get started on unit two. And we're well on our way towards learning a lot of computer science, as well as building our web crawler and then building our search engine. [Dave] So welcome to Homework 1. Homework is going to be a little different from quizzes, so unlike the quizzes where you get instant feedback for each question, in the homework you'll submit your answers, and you won't see feedback on them until you submit your answers, and after the deadline for the homework, we'll be posting answers and having discussion about the questions. So for Question 1, we want to see that you understand how web pages are constructed and what a web crawler will do. The goal for Question 1 is for you to find all the target links in the sample web page that we've provided. So for each potential answer here, check the box if that corresponds to a URL that's a target link in the sample page. [Peter] So on this web page, there are 3 clickable hyperlinks. The first URL links to higher education. The second URL links to Sebastian's Wikipedia page. And the last one is the Digital Life Design Conference Wikipedia page. To go to the answers, here is the HTML page that you were given. The first option is this URL right here. Although it is a URL, it's not a clickable link. It's not encapsulated in this prefix that was described before. The "a" means that this is an anchor tag, and the href means that it's a hyperlink reference specified by the URL. So this is not the correct choice because it is not a link that you can click on. The second choice is a URL to the Wikipedia page on higher education. It highlights this text as a clickable link. The third option is Sebastian Thrun's Wikipedia page. Again, for the same reason as before, it's a link that you can click on. The fourth option is this quote. Although it's encapsulated in quotes like the other URLs, it's not in a tag at all. It's just plain text as displayed on the screen. The last option is a URL to the Wikipedia page on the Digital Life Design Conference. Like the other 2 URLs, it is a link that you can click on. [Male] The next 2 questions ask about Python programming. For question 2, your goal is to write some Python code that prints out the number of hours in 7 weeks. And you should do this by using Python to actually compute that value and print out the result. [Peter] Since we want our Python code to print something, we're going to start with the print statement. And the answer would be 7 x 7 x 24. There are other ways to get at this, but I feel this is the most intuitive. The 7 corresponds to the number of weeks. The second 7 corresponds to the number of days we're calculating in each week, and the 24 is the number of hours in each day. So let's run this in the Python interpreter to see what the result is. If we enter in the Python expression that we generated and click Run, we get 1176, which is the correct answer. [Dave] So for question 3, the question is which of the following sequences of statements leaves the value the variable x refers to the same as it was before running the statements? You should assume that before the code runs, both a and x refer to integer values. We don't know what they are. They could be any integer. And the question is after the code runs, does x have the same value it had before that code ran? So here are the choices. There are 5 different sequences of statements, and you should check the box for each sequence where x has the same value after executing those statements as it did at the beginning, no matter what value x had at the beginning as long as it was some number. [Peter] This one was a little tricky, but you should get it if you understand assignment. The answers are all of them except this one, and we'll go over each one one by one. I've initialized their values to represent colors, but they can be any integer as described in the question. The first line of code states that a refers to what x refers to, so let's change that. The second says that a now refers to what a refers to plus 1, so now a refers to a new number, which is the red triangle plus 1. At the end of these 2 statements, x still equals what it was originally, and that is the red triangle. A and x as described refer to initial values. The first line of code says that a refers to what x refers to, so as we did in the last problem, we result in that a and x both refer to the red triangle. Now x refers to what a refers to. Well, as you can see, a also refers to the red triangle, so the result of this is that x still refers to the red triangle, and since that's what it was initially, the value of x has not yet changed. In this choice, the value of x changes. Let's show you why. The first line of code says that x now refers to what it used to refer to plus 1, so we're going to create a new value that is the red triangle plus 1 and change what x points to. The second line says x should now refer to what x refers to. Well, it doesn't change what it's referring to now, which is the red triangle plus 1. The end result is that x does not refer to the red triangle any longer, which is why it's not the correct choice. The first choice may be a little bit of Python that you haven't seen before. What this says is a should equal x, and x should equal a. The end result is that x and a swap. Let's see what that looks like, and I'll draw this all the way around here. X and a have swapped values. X now refers to the green triangle, and a the red triangle. The second line of code is exactly the same as the first. It's going to swap them again, and if you swap 2 things twice, you get what you had before, so since x refers to the red triangle still, it's a correct choice. In the last choice, we have a third variable x, a z. We initialize z to the value of x, which is the red triangle. We then assign a to what z refers to, which is also the red triangle. And lastly, we set x to the value of a. A refers to the red triangle, so x also refers to the red triangle. The end result is the value of x hasn't changed. [Dave] So for question 4, we want to see that you understand how to use and make assignments to variables. The question is "Write Python code that stores the distance in meters that light travels in one nanosecond in the variable nanodistance." The variables below are predefined for you. We're storing the speed of light in the variable speed_of_light. And that's 299,800,000. And I have the dot at the end of this to make sure that when you do arithmetic we'll get decimal variables instead of just doing integer arithmetic on the speed of light. The second variable is nano_per_second, and there are 1 billion nanoseconds in 1 second. And your goal is to write code that assigns to the variable nanodistance the distance in meters that light travels in 1 nanosecond. And if you've done that correctly, after you run your code, when you print the value of nanodistance, it should output 0.2998, indicating that light travels almost 30 centimeters in 1 nanosecond. [Peter] So given the speed of light in meters per second and a variable, nano_per_second, representing the number of nanoseconds in a single second, let's create our nanodistance. To initialize a variable, you simply write out the name. And in order to get the nanodistance, we're going to divide the speed of light by nano per second. To check our code, let's print it out. And when we run it, we get 0.2998. [Male] The next group of questions test how well you understand strings in Python. The question is given any string s, so the variable s holds the value of any string, which of the following always have the same exact value as s? And as a reminder, you should be careful to remember that s could be the empty string. Here are the choices. Check the box corresponding to each expression that always has the same value as s no matter what string s refers to. [Peter] The correct answer for this is all of them but the second choice. Let's see why. Let's pick an example, string s. Let's say s is duck. In the first example, we concatenate a with s, so taking one onwards is going to give us back duck, which is our original string s. This works. For the second choice, let's just plug in duck. The first character, the zeroth character in duck is going to be d, and we're going to concatenate that with the rest of the string, giving us back our original string duck. So this seems like it works, but we have to remember that s can be the empty string. If we try taking the character at position 0, we would get an error because there is no character at position 0 because there are no characters in s. Moving on, if we try adding an empty string onto s, we get exactly what we had before because we're not adding anything. For the last choice, it doesn't seem completely obvious that it works for the empty string. It seems unintuitive that taking every character from position 0 onward would not result in an error because there are no characters. Well, we have to remember that for the subsequence operator, this does not cause an error. Why is that the case? Because. [Male] Question 6. Given the variables s and t defined as udacity is assigned to s, bodacious is assigned to t, your goal is to write some Python code that will print out "udacious" without using any quote characters in your code. So you should be able to print "udacious" extracting from what you have in the variables s and t without needing to use any new quote characters. [Peter] Given 2 strings, s and t, we want to print out udacious without using any quotes, and we're going to do that by using the subsequence operator, the colon. Let's say we want to get the first 5 characters from s and the last 3 from t. Since we want to print our result out, we need the print statement, and let's print our s part first. We want to go from the beginning, so we're just going to put the colon there, and we want to go 0, 1, 2, 3, 4. Since we want to include the fourth character, we're going to go end it at 5. Now we want the rest to come from t, which are the last 3 characters. So we're not going to want to start at the beginning. We want to start at 0, 1, 2, 3, 4, 5, 6th character. And we want to go to the end. This will print out udacious without using any quotes, as you can see. But there's another solution if you're a true Python guru. Let's go to the interpreter to try that out. We have our 2 strings, s and t. Let's say you're like me, and you don't like counting above the number 4. And we still want to solve this problem without using any quotes. So we're going to have our print, and we're going to use everything but the last 2 characters and s, as we did before. And since we know all we want is everything but the last 2 characters, we can just type in -2. This gives us--the first part, we had an s, but without having to count 1 character at a time until the end. Let's do this same thing with t. Here we have a little different problem. We want to start with the last 3 characters. We're going to use the same negative notation and go all the way to the end. This gives us our 2 parts, so all we have to do is combine them. And we get this result without having to count really at all. [Dave] Question 7, test if you understand how to use the find method. Assume that the variable text holds a string. Your goal is to write some Python code that prints out the position of the first occurrence of hoo, H-O-O, in the value of text or -1 if the string hoo does not occur at all in text. [Peter] Essentially, the problem is asking for the functionality that find gives you. If you remember from lecture, doing text.find, passing in 'hoo' will give us the location of the first occurrence of hoo, which is what we want. And if hoo doesn't occur in here, we'll return -1. But remember, the code wants us to print it out, so always remember to print it. [Dave] So question 8 also tests how well you understand the find method as well as using variables. The question is assume that text is a variable that holds any string value. Your goal is to write Python code that prints out the position of the second occurrence of the string "zip" in text or prints out -1 if the string "zip" does not occur at least twice in text. So there are 2 examples. If text is "zip files are zipped," the output should be 14, which is where the second zip appears. If the text value is "zip files are compressed," the output should be -1 since zip only appears once. And this is a pretty tough question, so I'm going to give this one a single gold star. [Peter] So the simplest way to solve this problem is going to be by introducing a variable. Let's call it "first_zip." To find the first_zip, it's going to be pretty straightforward, and it's going to give us the location of the first zip. Now we want to print out the second one, so let's write "print." We're going to do text.find again, searching for zip, but this time we're going to start from the first_zip +1. If we didn't start from +1, we would get the result of first_zip again, and that wouldn't tell us anything about a location of a second zip. This is one way to solve the problem using a second variable. Another way to do this without introducing a new variable is to simply put text.find right where we had first_zip before. [Male] For the last question in Homework 1, you're going to solve the problem of how to round numbers, and this is going to require using a new Python function we haven't introduced yet in lecture, but you'll be able to figure it out as part of this homework problem. But it's a pretty tough question, so that's why it has 2 gold stars. The new function that you'll use is the str function. The str function takes as input any number, and it turns that number into a string, so the output of str applied to a number is a string that represents the number that was passed in, so if we evaluated str on the number 89, what that evaluates to is the string containing the characters 8 and 9. So it's a string that looks like the number that was passed in, but instead of being a number, now it's a string. If you understand str, you'll be able to solve this question. Your goal for this question is given a variable x, so at the beginning of your code, x has been initialized to store the value of any decimal number. What your code should do is print out the nearest whole number to x. So here's a few examples. If the value of x is 3.14159, what your code should print out is 3. If the value of x is 27.63, your code should print out 28. And to keep this a little simpler, you can assume that the value of x is not negative. This is going to require you to combine several things that you've seen in Unit 1. The only new thing that you need to solve this is the str function that we've just explained. Everything else that you need to solve this is something that you already know from Unit 1. [Peter] This was a pretty tough problem. It wasn't only a single gold star problem. It was a 2 gold star problem. It involves combining a lot of things that you already knew, including something new, completely new. But that's part of being a programmer is combining things that you know and don't know together to solve new problems. This is a difficult problem. You may not know how to do every step, but we can start by working backwards from our output. Sometimes it's easier to solve hard problems this way by breaking them down and even starting from the result. We know what our result should be. As described before, 3.14 and so on should result in printing 3. And 27.63 should result in printing 28. To get this, we printed everything before the decimal point. We did this by printing everything out from a string-- let's say we found it and called it s-- before the location of the decimal point. Let's say that location is specified by an integer, point. So here s needed to be 3. something. We don't really know what it is right now. In the second example with 27 as the initial starting point, s = 28 and so on. And remember, these had to be strings. That was what s should have been. Now we need point. Point represents the location of the decimal point in each string. We can see that from looking at our string. Given s, we know how to find point. It's using the find command. In order to get s, we probably had it as some form of number, and we turned it into a string using str. Now the question is, what did num equal? To figure out what we want num to be, all we have to do is look at s, since s is just the string form of num. Here s is the string 3 with some change. Num is going to be the same thing, but as a number instead of a string. And in our second example, we have the same situation, except num is going to be 28 with some decimal remainder. The question is, how did we turn our initial value x into num? We want this method to work for any number x, not just the two we have listed here. So if the tenth place is .5 or greater, we want to increase the entire number x to the next nearest whole number. One way to do this is by simply adding .5, and we're done. Our third question, student Redmars asks, "Why did we choose Python?" So, there are lots of languages we could have chosen-- The real reason for choosing Python is-- it is a very simple language, but it is also a language that is widely used, and can very quickly get you on the path to building interesting programs. There are many, many programming languages. It is definitely important, and a great thing as you develop as a computer scientist that you learn more and more languages. But, to start with a language that will be easy to learn, and still powerful-- Python is a great choice for that. There are certainly some other choices, but I happen to think Python is a good one for this class. Stormborn has a question. "Before enrolling here, my only experience with a programming language was a bit of JavaScript. In JavaScript there are a lot of brackets and semicolons to mark the end of statements, but there seems to be none of that in Python. I was just wondering how Python knows that you are done defining your procedure and that it should carry on with the rest of the program. Is it all about the indentation?" Thanks for the question, Stormborn. We notice in Python that the white space actually matters. This is different from many languages. Those of you who have programmed in other languages like Java or JavaScript or C know that you have to have lots of syntax to tell the compiler where statements end and where blocks end and begin-- where you have semicolons and you have squiggly brackets and you have other things in your code that are really there just to help the compiler know where things begin and end. In Python, white space is used for that. The new lines matter. The indenting matters. The Python interpreter knows when a block ends based on where the indenting is. That's really nice in the sense that it makes it easy to read your code. You don't have to worry about adding brackets and things. If you look at someone else's code or you look at your own code, the structure of the code tells you what the code means, because it has to have the same indenting structure as the blocks that are interpreted by the Python interpreter. This sometimes causes problems, and this is why many languages don't pay any attention to white space. If you copy code between different editors or you change things that change the white space, in Python that changes the meaning of your code. You have to be careful that you don't change the indenting or don't change where the new line breaks are and things like that, because in Python that can actually change the meaning of your code. It is a handy way of making it clear to the interpreter as well as to a human reading the code--the structure of the code-- and it saves having to need any extra syntax like squiggly braces or semicolons to do that. [Sarah] This question comes from Crazy Puff. "Can you give some examples of how BackusÃ¢Â€Â“Naur Form is used in practice? For example, being a formal way to describe a language, it seems that BNF might find some use in creating compilers or interpreters or other tasks involving teaching a computer to understand text. Also, BNF lets you go from the abstract form to the concrete form, but it seems like in practice you'd more often want to go in the opposite direction. For example, given a concrete example of a Python statement, you'd want to know how the interpreter parses it. So, Dave, how would you do this?" [Dave] Thanks for the question, Tracy. That's a great question. We're using BNF in this class to understand languages to see how we can construct the expressions in Python. But grammars are also used by the interpreter to break the strings that we put in into their parts. When you write a Python program and you run that in the interpreter, the interpreter has to figure out what the things are. It has to figure out is this an assignment expression? Is it a variable? Are these parts of a number? Is it a string? All the things that we've seen in unit 1 and in later units are constructs in Python, and we need the grammar that's built into the interpreter to break that string into its parts. That is part of what's implemented, and when people implement interpreters or compilers, they usually do it by starting by writing a grammar. Then there's a tool that takes that grammar and turns it into a program that will break the string down into its pieces. If you take the follow-on course to this--if you take CS262 programming languages course-- that talks a lot more about how interpreters actually do that. There are lots of other uses of grammars besides just breaking down programming languages into pieces. Some are in the generative sense where you start from the grammar and produce strings. An interesting example of that is guessing passwords. There was a group at Florida State that looked at how to create passwords. First you learn a grammar from a set of passwords you might have. Then you can create more passwords, and you can use this as a way of guessing passwords or if you want to measure how strong a password is to estimate how hard it would be to produce that password from this grammar. There are lots of interesting uses of grammars to produce strings. The more common use in programming languages is where we use the grammar to break an input which is all one long string of text, that's your Python program, to turn that into the components of that program using a grammar. Student Trupp asks, "What are some of the ethics and responsibilities involved with knowing how to program-- and empowering yourself the knowledge of computer science?" So, this is a great question and it is something that is very important to think about. I don't know if it was Batman or Spiderman who said this, "With great power, comes great responsibility." Spiderman. Was it Spiderman? Okay. I'm a little rusty. It wasn't him, Alright... Anyway, it's true, that as you gain more power, and as you learn more about computing, there's a lot of responsibility that goes along with that. And, one concrete example of that I'll give you from building a web crawler-- The web crawler we're building is focused on simplicity. If you build a web crawler and you run it on the Internet, there's a lot of things that you need to do to be ethical and responsible. One is, every time you encounter a new site the web crawler should look for this file called robots.txt which says whether or not the site wants to be crawled. If you are an ethical web crawler, you don't index a site that says--- in the roblox.text "don't crawl this site." Those things make the web crawler more complicated. Our goal is to understand computer science, and make the web crawler code as simple as possible, so we're not going to do that in our web crawler, and when you run them on our server-- we're not going to allow your web crawler to make arbitrary requests to other sites on the Internet. But certainly, if you run it yourself, these are things that you should worry about, and make sure to behave responsibly. We're definitely going to talk about this more towards the end of the class. This will be one of the things that we get in to in unit 7. Student Rodith asks, "How do we go about finding a good seed page?" This is a really good question, we haven't solved that question in this course, and we won't. We're going to give you a seed page and have exercises and-- sets of pages to crawl set up so that seed page will work well. For a real web crawler, this is a big challenge. And they don't start with just one seed page; they start with a set of many seed pages that are selected in different ways. Some may be found by hand, by people identifying them as good seed pages, some may be the results of previous crawls, so once you start crawling the web, you don't just stop-- you keep crawling the web and you build a new collection of pages, which you can start using start using as seed pages. But this is a hard problem--to get a good collection of seed pages-- to cover as much content as you can find on the web. In our last question, student OmniBeef asks, "This might be a strange question, but I will ask it anyway. What do you guys expect from us? I love the idea of Udacity, and I am sure I am not the only one. How can we help Udacity grow and be successful?" Wow, that's not a strange question at all. We love the question. We love that students are helping out, making the course grow. The things that I have been seeing a lot of-- and I hope people will continue to do-- definitely try and encourage your friends to take a class. We still have time to enroll more students in the class-- it's great to have as many students as possible. There's also a lot that you are contributing by posting in the forums, by either answering questions or asking questions. That will enhance the quality of the class for everyone. Also, if you can produce creative, extra materials. We've seen some examples of that already. That's something that will definitely enhance the class for everyone and we'll certainly appreciate any efforts to do that. Hello. Welcome to the lesson on How to Solve Problems. Solving problems is one of the most important skills you can learn. And calling it skill is really an understatement. Nearly everything you can do can be viewed as solving problems. And improving as a problem solver is a lifelong challenge. One short lesson is not going to be enough to make anyone an expert problem solver. But for this lesson, we're going to, to look at some aspects of how to approach more complicated programming problems. And hopefully, that will help you in solving any problem that you're faced with from now on. But it doesn't really make sense to talk about solving problems without thinking about particular problems. So, we're going to look at a specific practice problem and talk about how I would go about solving that. And our goal by looking at a particular problem is not just to solve that particular problem, but to draw some general lessons about how we can get better as problem solvers in general. The problem that we'll use for this lesson was one that was suggested by one of our students for the make practice for unit two. And this is the one that we'll use and it was a problem that was suggested by Matias Wexen from Sweden, as a practice problem for unit two. And here's how he stated the problem. This is days old number two and it says given your birthday and the current dates, calculate you age in days. You have to beware about leap days. Dates are complicated things. And you can assume that the inputs are correct dates. And then, there's an example here to say that, well, if you were born on January 1, 2012, and the date today is January 2, 2012, you're 1 day old. So, this is a great practice problem. Thanks, Matias for suggesting it. And it's generated lots of discussion on the forums. So, I wanted to step through how I would solve this problem. If you have not tried it yourself, I would strongly encourage you to do so. There's a link to the problem in the additional homework to try it yourself. And I'd suggest keeping notes on how you solve it. Whether you're able to solve it or not, I hope you'll come back and watch the rest of this lesson. If you got stuck, this lesson will give you some ideas of how to get unstuck. And then, when you get unstuck, go back to trying to solve it on your own before continuing with the lesson. If you were able to solve it yourself, that's great. This is quite a challenging problem. But I hope you'll still come back to see how I solve it. I think you'll, perhaps, learn some things from the way I would approach it and probably I can learn some things from the way you approached it. So, I hope you'll post on the forum about how you approached it that was different. The hardest thing about solving problems is often just figuring out how to get started. So let's start with a quiz. What's the first thing we should do when confronted with a problem like this one? The choices are, start writing code. Make sure that we understand the problem. Search Google, or Duck, Duck Go, if you prefer, for the answer. Work out an algorithm that solves it. Check the one that you think is best. So I think the best answer is the second choice, that we should make really sure that we understand the problem before we progress on trying to solve it. I'll talk next on what it means to understand a problem and how to do that, but let me go through the other answers before. It's often tempting to start writing code too early. Writing code is fun and that's what we like to do as programmers and computer scientists. The problem with starting to write code before we understand a problem, is we might write the wrong code. We might get very frustrated trying to write code before we really understand the problem or how to solve it. Or we might end up writing a lot of code that doesn't actually solve the problem we wanted to solve. The third choice is actually a very good answer, if this weren't a practice problem. If it's a practice problem, you're going to learn a lot more by trying to solve it yourself than finding an existing answer. And then maybe understanding the answer, you'll still learn something. You'll learn a lot more by trying to solve things yourself. If it weren't a practice problem and you just wanted to solve this, and move onto the next thing, searching to see if someone has already solved the problem. And for a problem like this, probably there are good solutions out there already, is a better use of your time than writing your own solution. Unless your goal is to learn something by writing your own solution. The fourth place to start working on an algorithm also depends on understanding the problem. Until we understand the problem well, we don't know what algorithm we need to create. So, what does it mean to understand a problem? And I should emphasize, we're talking about computational problems here. And what all computational problems have in common is that they have inputs and they have desired outputs. So, problem is defined by the set of possible inputs. This is usually an infinite set for most interesting problems and the relationships between those inputs and the desired outputs. So, that means a solution to a problem is a procedure that can take any input in that set and produces output, a desired output that satisfies the relationship that we want. In this case, the relationship we want is that the output is the number days between the birthday and the current date. So, the first step to understanding a problem is to make sure that we understand what the possible inputs are. So the first rule in our Pythonista's Guide to solving all problems in the known computational galaxy is to always ask, what are the inputs? Now, there is one rule before the first rule, that's the zeroth rule. And the zeroth rule is don't panic. If you panic, you're never going to solve the problem. But the first substantial rule is to figure out what the inputs are. So the first question we need to answer for any problem is; What are the inputs? For this problem their fairly clearly stated says, given your birthday and the current date. Well, that's the input to the problem. What's the set of inputs we really want this to work for? Should it really just work for my birthday? And today's current date? If that's all we wanted it to work for then we can figure this out once. We don't actually have to write a procedure. So I think what is intended by this is something much more general. So the inputs are really two dates, and that gives us the type of the input, that gives us a set of all possible inputs. We need to think a little more carefully to know if they're all valid. Well, the statement of the question give us a good clue here. It said, assume that the birthday and the current data are correct dates and no time travel. This probably is a valid assumption if we're talking about birthdays and current dates. If we're comparing any two dates, well this says that the second date needs to be after the first one. Assumptions like this make life easier for programmers. That means it's easier to write our code since it has to work for fewer possible inputs. I like the way Mattias stated this is no time travel. For a program specification, we probably want to be a little more precise, and just state simply the second date must be, not be before the first date. And if we're being good defensive programmers, we should check if this is true. It's an assumption, it's up to the user of our code to satisfy this, because we've said, well that's a requirement. To use our solution you have to make sure the second date is not before the first date, but if we're going to be smart we're going to program in a more defensive way, because sometimes other people might make mistakes or we might make mistakes. And we're actually going to check this in our code. The other assumption we might want is something about the range of dates. Calendars are very complicated and they've changed over history. We're going to require that the dates are valid dates in the Gregorian calendar, which started In October 1582. Our code will probably work for dates outside this range, but it might not get exactly the right answer, since when the calendar changed the meaning of dates changed. For most real world problems, it's up to you to figure out how to encode the inputs and this is one of the most important decisions that you can make in solving a problem. For the problems that we've used in CS 101, because they need to be automatically graded and we want to run your code on test but we need to specify carefully what the inputs are and how they're encoded. In this case, the template for the problem, indicates how the inputs are represented, that there's six parameters to the days between dates procedure, year one, month one, day one, and year two, month two, day two, and that means we're going to be passing in six different values to represent those two dates. Those of you who've got a little further in the class will rise that there's better ways we might have used to package the year, month and day into one object, but based on what we've seen only through unit two, passing them in as separate values makes sense. So our solution needs to use inputs represented this way. So, the next thing we need to understand about the problem is what are the outputs? The statement of the question gives some idea of what the outputs should be, and then, calculate your age in days part. But it doesn't specify really explicitly what we want the output to be. So, let's make that a quiz. See if there's enough information here for you to decide how we should specify the output. The choices are, print a number, giving the number of days between the first date and the second date. The second choice is return a number, giving the number of days between the first date and the second date. And the third choice is output 3 values, giving the number of years, months and days between the two input dates. Select the one you think is best. I would argue that the second answer is best. The difference between the first and the second is whether we print out a number or we return the number. Returning a number is much more useful. If we return the number, then we can do more computation with it. If we print it out, well, then it gets printed out and it's hard to use for anything else. So, I'm going to assume that what we want to do is the second choice. The third choice doesn't really match what was stated. Maybe, we want the age in days, the third choice says, we'll give the age and years, months, and days. Note that this answer depends on the assumption we have about no time travel. We haven't described what that should be if the first date is after the second date and we don't need to because we're going to assume that could never happen. That the first date must always be the same or before the second date. So now we have the second step in our universal guide to solving all problems, which is understanding what the outputs are. All we have left to do is the third step, and this is kind of the hard one. This is to solve the problem. So now, we're going to talk a lot more about how we actually do this. But, I want to emphasize that if you don't do the first part, you're going to have a really hard time solving the problem. So, you always want to start by thinking about the inputs and outputs, and then go on to the hard part of figuring out how do you map inputs to the correct outputs. So now, we have our problem state. We know what the inputs are, and we know what the outputs are. What we want to do is make sure that we understand the relationship between the two by working out some examples. So, what should we do next? We could start coding, we could panic, or we could work out some examples. And, I hope no one packed. You could start coding if you're real confident. What I think you really should do at this point is work out some examples. Just to understand the Inputs and Outputs is not enough. We need to understand the relationship between the two and the best way to do that is to work out some examples. And, these are also going to give us some test cases to use to know if our program is correct. So, that's what we'll do next. So, to see that we understand the problem well, let's work out some examples. For each of the examples, give the expected output or write undefined if there's no defined output. Meaning, the inputs given were not valid. There are five examples, the first is December 7th, the December 7th, 2012. The second id from December 7th, 2012 to December 8th, 2012. The third is from December 8th, 2012 to December 7th, 2012. The fourth is from June 29, 2012 to June 29, 2013. And the final one is from June 29, 2012 to June 31st, 2013. The answers are, for the first one, the dates are the same. We said that was okay. The requirement is that the second date cannot be before the first date. It's fine if they're the same. And then the answer should be 0, there are no dates, between those two. The second one, the second input is one day after the first input, so the output should be 1. For the third one, the second date is before the first date. The way we specify the problem. That's an invalid input. That means the output is undefined. And, our procedure could actually be correct, no matter what it does for this input. It'd be more useful if it gives a clear error message or maybe even more useful if it gives negative 1. But the way we specify the problem, we don't have to worry about what the output is there, because we're saying that these inputs are invalid. For the fourth one, the dates are a year apart, June 29 in 2013 is one year after June 29 in 2012. And so, there are 365 days in a non-leap year. And it's non-leap year because the February that's included is the February in 2013. For the final one, we're going from June 29, 2012 to June 31st, 2013. If you know your calendar well, you know there's actually no June 31st. The way we specified the problem, we said that both input dates have to be valid dates in the Gregorian calendar. That means that the output here is undefined. We'd like to get some kind of error output, but there's no requirement for our procedure. So now, we've done 3 main steps towards solving the problem. We understand the inputs, we understand the outputs and we understand the relationship between the two based on some examples. At this point, you might be ready to start coding. But if the problem is a challenging one, you're probably not. What I'll suggest in the next step is that you should really think about how to solve the problem as a human. If you don't understand how to solve the problem yourself in a systematic way, you're probably not ready to start writing the code. So, let's think more carefully about how we actually compute this. So, what I would suggest to do next is to try working through a few cases in a very systematic way as a human. And we're going to try a difficult case that covers many of the things that we would need to think about in an algorithm. So let's try an example. Suppose we wanted to find the days between dates. 2013 Janurary 24, and 2013 June 29th. If we were going to do this as a human we might look at a calendar. I happen to have a calendar handy and thanks to my auntie in Belfast for sending me the calendar and we could count the days using the calendar so let's look at the calendar. We have our starting day is January 24 and we might count the days between January 24. How many do we have left in January. So there would be 1,2, 3, 4, 5, 6, 7 days left in January. So there'd be seven days in January. Then we have, have all of February, all of February is 28 days. Then we have all of March, 31 days. All of April, 30 days. All of May, 31 days. And then we have June. We don't want to count all of June because we are stopping on June 29th, so we are going to add 29 days. From June, and if we sum all those up we should get our answer. And as a human we know how to compute sums by entering sums into Google, and we get 156. So that gives us some idea how to solve it systematically. If we thought about a harder problem, let's say we increased the year, well then we would need to add the days in the years, and some of those years will have 365 days. Some of those years will be leap years, and we'll have 366. So you see this is a fairly complicated problem. Maybe based on this we have enough of an idea to write down as an algorithm what we did as a human. So that's what I'm going to try to do next. Let's try to write down an algorithm that systematizes how we solve it. And we're going to write this as pseudocode. That means we're not worrying about the details of how to write exactly correct Python. We're trying to get the idea down and see if it makes sense. So let's think about how we solve the problem as a human again. Here's how we start it. We looked at our start date, which was January 24. And we counted the number of days remaining in January. We do that by just counting up. If we started earlier we might not want to have counted every day. So we can subtract the total number of days in January from the day we started. So that will be our starting point. And we're going to keep the results in a variable called days and we'll start by initializing days into the number of days in the card line minus the day that we're starting on. So, for the example, that was 31, for the number of days in January, minus 24, which, I believe is 7. And once we've done that, well, we finished month1, so we should increase the value of month1 by 1. So now we were at February and now we started going through the months, until we got to the month we are on. So we went through each month until we got up to the month we were looking for, which was June. So that's sort of like a while loop. We're doing something over and over again until we get to the stopping condition. So we can write that as pseudocode. We're going to keep going while the current month is less than the target month. We're going to add the number of days in the current month. And we're going to increase the current month by 1. Now, we're not quite done we still need to account for the day in the month that we arrived at. And there we just add that day so if it was day one of June then we would add one. If we didn't actually get in to June. Now, we're going to add 29 since the 29th was our target day. We haven't yet accounted for years, for this example it was okay. But, for other cases, we're going to need to account for years, so let's think about how to do that. We can do it similarly to how we accounted for month. Well, we're not up to the same year. We're going to add the number of days in that year. So here's a pseudo co-description of an algorithm that follows what we did as humans. Now let's think about this a little more carefully. So the questions is; Should we go ahead and implement this algorithm? Are we close enough to start writing the actual python code? There are four choices. First is that yes, we should go ahead and implement this, and we'll end up with the correct solution. The second is that; We should start implementing this. It doesn't address all cases, but this is a good start and we'll figure out the details as we go. The third choice is no, that we should figure out how to address all the cases first and make sure that we have correct pseudo code before we try writing any actual python code. And finally no, we should give up on this direction and try to find a simpler way to solve this problem. I'm going to argue, that the best answer to this is no. This code is already fairly complex. It's got two loops in it, lots of statement and it doesn't handle lots of cases. So let's think about the cases that it doesn't handle. It doesn't handle the case where the, initial days are in the same month. And it doesn't handle that, because we're adding all the days in month one, to the days and if day two was also in month one, we're going to add that we're going to get the wrong answer. We could handle this. Maybe we subtract the difference between the days. We have a special case for that. Maybe we need to do something different with this loop to account for when the months are the same. But that's painful. We're going to need a new special case. Adding one special case is okay. There are other cases it doesn't handle. It doesn't handle the case where month 2 is before month 1. And this could happen if the years are different, it would still be the case that the second date is after the first date even though the second month is before the first month. And this won't handle that correctly. The other thing it doesn't handle quite correctly is counting days in leap years. This loop where we add the days in year one we have to be careful depending on whether February is included, based on what month we're in. Whether we should pay attention to the days in year 1 or the days in year 2. There's a lot of things it doesn't handle. We could definitely fix this code to handle.those. And, if you answered the second answer, I'd encourage you to try and do that. To try and turn this into a correct working program. And you should be able to do that, but our goal as programmers should be to try and find a simple solution first. Something this complicated is very difficult to get correct. Once you start handling lot's of special cases, and I've seen lots of discussions on the forum of people who try to handle all these special cases. It's really hard to get them all right and it makes the code very complicated. So let's start by thinking of a simpler way. Often the way humans solve a problem is not the simplest way, because humans are lazy. We want to find shortcuts, instead of doing things in a real, simple, mechanical way. On the other hand, computers are not lazy. Doing things in a simple, mechanical way is great for computers. It makes the program easier to write, makes it more likely to be correct. So let's think of a really simple way we might solve this problem. And what I'm going to suggest is a little like how we started. We're going to start on the day of the first date, and we're going to just count the days, we're going to go one day at a time. We're not going to do anything special when we go through months, we're just going to keep counting days, keep adding as we go. And we're going to keep doing this until we get to our target date, and I got 156. So here's our pseudo code for, a really simple, brain dead way of doing it. We initialize dates to 0. We have a loop that keeps going as long as date 1 is before date 2 and each step we advance, date 1 to the next day, and we add 1 to the number of days. So, this seems really brain dead. And before we go further on this, we should do a sanity check of whether this is actually practical. For a human, it certainly wouldn't be. If the dates are a few years apart, you wouldn't want to count every day. But what about a computer. So the question is roughly how long do you think it would take, using this brain dead approach, to count the number of days in a hundred years between December 12, 1912. And December 12, 2012. So here are the choices. A few nano seconds, that's a billionth of a second, a few milliseconds, that's a thousandth of a second, a few seconds, a few minutes, a few hours, or way, way too long. This requires a little bit of guessing or thought but I think you should know enough to be able to get the correct answer. And the answer is a few milliseconds. So here's why. We have a 100 years. A year is roughly 365. If it is a leap year, it's one more, but we're going to have somewhere around 36,000 days. A modern processor can do about a billion instructions per second, so that's means 1 nano second per instruction. And now, these aren't instructions like statements in a Python program. Each statement in Python program probably involves several instructions for the processor. So we're going to estimate that for each time through this loop, we're going to need about a 1,000 instructions. And that's the hardest part of this to guess and that's a very rough number. That's going to depend on a lot of specifics about how we write the Python code. But it's going to be somewhere between a few 100 and say 10,000 instructions if we do it in a sensible way. So we'll estimate a 1,000 instructions. So that means we need a 1,000 instructions times 36,000 days, so we need about 36 and a half million instructions total. If we were executing this as a human, we'd certainly would not want to do this. But for a processor, they can do a billion instructions in a second, doing 36 million instructions is no big deal. So that's going to be about 36 million nanoseconds, which is 36 milliseconds, which is 0.036 seconds. So, this seems like a really brain dead way of doing things a bit. Maybe that's good enough. We need to look at how we are actually using this procedure. If we're going to use it for a human to tell how many days old they are, in an interactive way, the fact that we have to wait 300th of a second for the answer doesn't matter, that's plenty fast enough. Getting that down to less than a 100th of a second is not worth extra effort. If we are using it in a service, that's doing this computation lots and lots of times for lots and lots of different dates, well then, maybe its not fast enough and its worth putting time and effort to doing something better. But we shouldn't put that time and effort until we know that we need it to be faster. This point is important enough that I want to put it in our guide to solving our problems. So, we have our first steps, don't panic, make sure we understand the inputs and the outputs, works through some examples by hand to think about how we would solve the problem systematically. And then, try to develop a simple mechanical solution. And the key here is simplicity, the simpler it is, the more likely we're going to be able to program it correctly. Eventually, we might need to worry about making it faster, but let's not worry about that until we have to. So now, we've got a simple mechanical solution and we've written out a pseudo code. So now, we're ready to start coding but we should think carefully about how to do that. So now, the question is what should we do first? The choices are, we should write the days between dates procedure that solves the whole problem. We should write a next day procedure that takes a current date given as a year, month, and a day, and returns the next day. But only deal with simple cases. Let's assume all months have the same number of days. We should write an isLeapYyear procedure that takes a year and returns true or false, determining if that year is a leap year. Or we should write a daysInMonth procedure that takes a month and returns the number of days in that month. This is quite a subjective question. You could certainly make an argument for at least two of these answers. But I want you to try and figure out which one is the best answer. And the one that I think is best is the next day procedure. This is sort of the most important thing to make the solution work. If we can't do this, then we would need to think of a different approach. And the reason that I think this is best is that, we can solve this in a simple way for the simple case, which is what we'll do next, not worrying about the complexity of how many days are in different months. And get a good feeling that we're able to get close to the right answer for some cases. The other answer that I think would be okay is doing is leap year. This is something we know we're going to need at some point. We need to determine whether the years are leap years to know how many days there are in the month of February but it's kind of a grungy, painful thing to write. It's something we know we're going to be able to do. And it's something that's not too interesting, so we're going to leave that until later. You could certainly make a case for doing that first. The other two are really not good answers. Trying to do the whole problem at this point is a little early. We still want to break it down into simpler parts and make progress and know that we're making progress. That other one is closer to something very small. The problem is this is probably not really the procedure that we want and until we write these other procedures and think more about how we're going to do this, we might not know enough to implement this correctly. And the reason that I'm going to suggest that this is not what we want is the number of days in a month actually depends on the year, if the month is February. So let's start by writing the next day procedure, and to keep things simple we'll assume that all months have 30 days. So for the quiz, your goal is to define a next day procedure that takes as input a valid data in the Gregorian calendar, which is encoded as three numbers, the year, the month and the day and then returns the next day as a threetuple of the year, the month and the day. And to keep this simple, you should assume that all months have 30 days. This of course will not be correct in some cases, but will be a good start towards solving the problem. So, here's my solution to implementing nextDay and you'll note that I start with a docstring. This is treated as a special common by most Python systems and I put in this warning to make people realize this [unknown] is not actually correct. So, it shouldn't be used to schedule, say, the apocalypse, but it's good for our testing for now. And the logic is quite simple, if the day is less than 30, since we're assuming all months have 30 days, we increase the day by 1, and I'm returning a three tuple of the year, the month, and the day. Otherwise, we need to increase the month, so we're going to advance to the next month and reset the day to 1. If we're in December, then we need to increase the year by 1 and reset the date to January 1st. As with the larger problem, you should start this by thinking about some test cases. And see that those behave as expected. We provided some in the example. One nice thing you'll notice here using the Python shell provided by [unknown] is that, when I try to use nextDay, I see the docstring right here. And normally, we want docstrings that are descriptive here. The warning is very useful. And I give a sample month, day, and year, and I see that I get the right result. I should note that for some cases, say, January 30th, the day following January 30th should be January 31st. I'm going to get February 2nd because of this assumption about all months having 30 days, and we should try a more difficult case, such as the end of the year. And here, I'll use December 31st, it would advance the year whether it's December 31st or December 30th because of that assumption, and we get January 1st, 2013. So, now I want to make a key point here and we should have a smiley face. We haven't solved our problem but we're making progress. And making progress is really good. We should be happy that we're making progress. And the way to make progress is not to write lots of code. It's to write small bits of code to test them and to know what they do. We haven't solved the problem yet. We've got lots of simplifications and we've only solved one part of it. But because of our solution, well, once we implement next day correctly, we are a good part of the way there. So, let's keep that in mind and think about what we should do next. So now what should we do next? The choices are, we can refine nextDay to work correctly for real months. We could go ahead and start defining your daysBetweenDates procedure to give approximate answers using the nextDay procedure we have, or we're really close enough or happy with just nextDays and 30-day months, let's go to the beach and celebrate. And I'd prefer number 2. Any of these could be correct, especially depending on how close you live to a beach and how nice the weather is today, but I'm going to suggest that we do number 2. And the reason that we do number 2, rather than, refining next day, is I like to procrastinate. The grungy work of dealing with all the complexity of real months. Let's put that off till later. The advantage of doing 2 first is we'll have a lot of confidence we're on the right track if this works. We'll be very close. We'll be getting approximate answers. We'll see that we're on the right track. And then, we can figure out those details but we won't need to change this code later. So, let's go ahead and see if we can write days between dates using the next day procedure. We won't get exact answers that are correct here because our next day procedure is not quite correct. So now, it's time to see if you can define a daysBetweenDates procedure that will produce the approximately correct results using the current nextDay procedure. If we add a correct nextDay procedure, your days between dates should produce exactly correct results. And I'm going to suggest one thing is a hint. Doing days between dates by itself is still going to be more complicated than we want one procedure to be. So, I'm going to encourage you to start by defining a helper procedure. And if you're following the problem solving strategy we've set out so far, you should test the helper procedure independently before you try to build the complete daysBetweenDates procedure. But I'm going to leave it up to you to figure out what would be a useful helper procedure and how to do this. So to answer this lets think about the pseudocode we ad before, we have this y loop where we need to know as the stopping condition if date one is before date two and then we have the body that keeps incrementing the date. Well we've got our procedure now to do this part we implemented the next day. That we're ready to turn in to code if we're going to write a helper procedure. We should write something that makes it easier to do this date comparison, and that's going to be a lot better to do as a helper procedure than to try to do that inside the days between dates code. Knowing whether a date's before another date is something that is possibly useful, in other context we'll actually see another use for it in writing this. The other advantage of writing that as a separate helper procedure is we can test that separately. So instead of starting by writing days between dates right away it would make a lot more sense to start by writing helper procedure that determines the stopping condition. So, let's do that. We're going to write a procedure dateIsBefore that takes as inputs, two dates, still encoded as three values. And it's going to return true or false telling us whether year1, month1 and day1 is before year2, month2, and day2. If you weren't able to write the code for days between dates on your own, now that you've heard this hint, please try again, again. See if you can do it writing dateIsBefore first. And testing that that's correct before you go on to writing the days between dates procedure. I'll show you my code next. So here's my code for the "date is before" helper procedure. If year 1 is before year 2 then we can return true right away. We don't care about the months and the days if the years are different. If the years are equal then we need to look at the months. If month 1 is before month 2, we return true. If the month's were the same, then we look at the days. And note that we don't have elses here. But if we don't hit the returns we're going to fall through to this last statement and return False. And that could happen if either year 1 is greater than year 2, or the years are equal and month 1 is greater than month 2, or the months are equal and day 1 is greater than day 2. In all of those cases, the first date is not in before the second date and we should return false. Now that we've got the helper procedure, defining date between dates is pretty simple. We have our while loop condition, checking of date 1 is before date 2. And then, we update the year1, month1, and day1 values with the next day. And we add 1 to the number of days. So, let's try a few examples. And this was the one we worked out by hand earlier. We get 155. That's not exactly correct, but that's pretty close. We got 156 when we tried this by hand, and given that our next day assumes all months have 30 days, it's not surprising, we don't get exactly the right answer. Let's try another example. This will be a good sanity check that our solution's still fast enough. We've got 100 years here, and we got 36000 days, it seems correct, right with our 12 months of 30 days are year is 360 days long, instead of the correct length of the year. Let's try one more example, try to guess what will happen here before I run it. I get the answer 0. It's not really correct, right, those aren't the same day. Its a valid answer in the sense that the statement of what days between dates should do we could assume the first date is not after the second date. In this case the first date is after the second date, but it's not a very satisfactory answer. We really don't want to get the answer 0. We could change the specification to say that if the first date is after the second date, then, the result is 0. But that's sort of a strange way of looking things. But would make more sense would be either to give a negative result for this, that's going to make our code more complicated. We'll leave that as an exercise for you to do after this lesson. What I'm going to advocate instead is to program defensively. If the assumptions that the function depends on are not satisfied by the inputs, it's lot more helpful to have raise an assertion to give a failure, rather than to continue and give a mysterious result or behave in some other unexpected way. So, I'm going to ask you to do that yourself in a quiz. So what I want you to do is add an assertion to the code that will give a failure when inputs are invalid in this way. And the syntax for assertions or you can do assert followed by any python expression if the value of the expression is false the assertion fails execution will stop with an exception. So this question's a little trickier than it seems, because we need to make it so if the two dates are the same, we should really get the result 0, not the exception. So the solution is to use a not and switch the order of the dates, so we're going to assert that the second date is not before the first date. Which is exactly what the requirement is here. So, now we've added the assertion. When we run this, instead of getting the value 0, we get an assertion error like this. Not a really friendly error message, for a regular user, but for a programmer this should help us a lot. It points us to the line in the code where the assertion failed and can look at that and understand what went wrong. Now, we should be pretty happy, we've got the guts of our program working. We've tested it, we've got some confidence this is going to work correctly. But we've got a problem, we're not getting the right answers. And we're not getting the right answers, because not all months have 30 days. We've tried to put off this grungy detail of dealing with the reality of the real world and most computational problems in the real world eventually run into issues like this that aren't that interesting, but are very complex. So now, we've gotta deal with the complexity of how many days there actually are in a month, that's the only thing we have left to deal with. One of the good ways about solving the problem this way is we got close to an answer without dealing with all that complexity, but we've gotta deal with it at some point, and now is the time that we have to deal with it. So for this quiz, I want you to think carefully about a strategy that will be the most effective way to finish the problem. We've got a lot of different things we might do next. We don't necessarily need to do all of these, and the order in which we do them will make a big difference in how efficiently and correctly we solve the problem. So, I want you to think about this and give an answer that lists the steps you would do in order. And an example to show you the format for the answer is just to put the letters in order. This is not a correct answer, but note that you can include some of the steps more than once, and you don't need to include all of the steps. This is pretty tricky, and I don't expect you to match exactly what I think the best answer is. But there's several different ways to answer this that would be accepted, and you should be able to come up with one of those. So, see if you can order these steps. So here's what I'll suggest is my favorite ordering, is we're going to first write a stub, daysInMonth, that will take a year and a month and return always 30, which certainly not correct. Then we'll modify our nextDay routine to use that stub, and then, right away, we'll test it. At this point, we won't have done anything that will actually change the outputs from what we were getting before if things are correct, but we're now, restructure the code in a way that all we have to do is improve daysInMonth. And then we've got the correct answer. The next thing we'll do is modify DaysInMonth to be correct, except for leap years. I'm putting off leap years as long as I can because I think leap years are really annoying. But there are also a complexity that only comes up occasionally. And we can have really close to a correct answer and know that we've got all the structure of the code and everything in good place, putting that off. So, I'll do that. Then I think it's a good idea to test again. So we're going to do the testing again in step five, and it would have been perfectly okay to do the testing using daysInMonth. I think it's easier to do it using nextDay, since I can just keep rerunning the same tests that I did for step three. Now, I've got to the point where I really can't put off leap years any longer, so I'm going to do the leap years next, and I'll write a helper procedure is leap year. That's step 6. And I'm going to test that separately. That's another step that you could argue, well, I could test that using daysInMonth or using nextDay. In this case is leap year, they're enough special cases that it makes more sense to test that separately. Okay, and after I've done that I should have a fully correct solution. I could test it separately, but I'm pretty confident in the rest of my code at this point. I'm going to jump right ahead to step K and run all the test cases. So this is order I'd recommend, but there's plenty of other orders that make sense. One thing that would certainly make sense would be to move the leap year stuff to the beginning. If you like leap years, and don't want to put that off, easy to do that separately first. The other thing that could happen is instead of using the nextDay test, use the daysInMonth test. That would be perfectly reasonable as well. So there are lots of correct answers to this question. The property that they should all have, all the correct answers, is that you're writing small bits of code that you can test independently as you go. You don't want to be writing a lot of code and not being able to test it. That's one of the most important things to learn as a developer is to think of ways to structure a code, to organize the way you build code, so you're able to do meaningful tests as you go and see the code incrementally get closer to the solution that you need for that. As you get more confident as a programmer, you might skip some of these steps. But part of my motivation in asking this question is, when I tried to solve this problem myself, I had a bug in my solution, because I didn't do these steps carefully enough. And I've tried running all the test cases and they all failed. And, debugging it took a lot longer than if I'd followed this pattern. What I'm going to encourage you to do as you develop your solution, is to write code to run all these tests as part of your solution. And, what I hope will happen, if you do these steps, testing as you go. When you finally get to step K, and run it on all the test cases, it will magically all work correctly the first time. Except, it won't be magic. It'll be the result of building things in a systematic and careful way. Now, I hope everyone feels confident that they can finish days Between Dates on their own. And so, that's the final quiz for this lesson. So, for the answer, we're going to show you how I actually solve this. I'm going to step through how I would solve this and maybe I'll make some mistakes. Hopefully, I will. That will make it a little more interesting. We'll keep those in the edited answer. If you get stuck trying to solve it yourself, go ahead and start watching part of the answer. But then, go back to try to solve it yourself after you see how I solve the first part. So I'm starting with the code we had before that works correctly, except for, with this assumption that all months have 30 days. So the first step is going to be to define the stub procedure daysInMonth that gives the number of days in a month. But, for our stub procedure, we're just going to always return 30. And I'm going to modify nextDay to call daysInMonth. That's pretty simple, but I should start testing, and I'm going to write some code to do testing. We don't want to have to keep typing the same test cases in the shell. We want to write some code for testing. For the problem that's provided, there were some provided test cases. I'm going to write my own starting now. And I'm going to make sure that these test cases, we don't expect the correct results yet because I'm testing with 30-day months. So, I'm going to test two dates that are the same. It's a boundary case, it's a useful one to test. I'm going to test from one day to the next, that should give us one day. And these are test cases for days between dates. I should really be writing some test cases for next day. The reason for that is that, if they fail, well, it's going to be more easy to understand what went wrong, rather than just writing all of my test cases for days between days. So let's try some nextDay test cases. Got one where the day advances. Let's get one where the month advances. And I will use a month that has 30 days. So it will be correct in 30 months, but will still be correct once we fix this. And I'll use advancing the year. A few test cases, probably we should have more. But let's try that. We should save, and let's run this, and we'll run our test. And, something failed. Not too surprising, this happens. Let's see what failed. And the failure is type error that I'm calling daysInMonth Not passing in the right number of parameters. In fact, I passed in 0. I should have passed in both the year and the month. So this is one of the reasons for writing things in stubs, we can find these kinds of errors quickly. So let's try again, and now we're test passed, and our test case is using restrictions. I'm going to be a little more careful and print something out when the test finishes, because it's a little bit dangerous to have nothing to tell when the test finished. Maybe we didn't get any output for some other reason. So now, I've written my stub. And I'm going to modify days and month to be correct for all months except for February in leap years. So, to do that, we've got to know how many days there are in a month, and I need Wikipedia for this. You may already know. Here we go. Here's the number of days in months. We have 31 days in January, March, and May, July, August, October, and December, so let's write our code. And I'm writing this using only things we've seen through unit 2. If I was writing this for real, I would do something a little bit easier to type. And those are the 31 day months. An easier way to write this would be to just list them all like this. That would mean the same thing but using a topple. We'll keep things only using things we've seen through unit 2. So, if the month is one of those, we return 31. If the month is February, we're going to return 28. And this is the case we're going to have to do something more complicated if it's a leap year, and otherwise we're going to return 30. So, at this point, we should be able to add some tests, that should be correct now, if we are not in a leap year, the day after February 28th is going to be March 1st. And a month that has 30 days, let's pick one, is September, it'll be October 1st. I think that's enough. The other test case, I think it would be good. That at this point, is something that looks at a whole year. If it's a non-leap year, we should correctly have 365 days. Okay, so now I've got some more test cases, and they should be correct, even for months that don't have 30 days, so let's try. See if I made any mistakes. And all the tests finished, so it sounds like they're correct. Okay, so now I've left the most annoying thing for last. I've gotta deal with leap years. And my campaign to eliminate leap years has not been successful, so we've gotta figure out a way to figure out if it's a leap year. And the rules for leap years are pretty complicated. Let's see, what Wikipedia has to tell us about that. This is quite interesting. You can see how accurate the solstice is over time as the leap days go. But the great thing here is that it actually has code. And it's not Python code but it's pretty close. But this is a very clear way to describe the algorithm for determining whether a year is a leap year or not. If it's divisible by 400 then it's a leap year, if it's divisible by 100 then it's not, if it was not divisible by 400, if it's divisible by four then it's a leap year, otherwise it's not a leap year. So, let's turn that into code. I'm going to cut and paste that, so I can see. If i was doing this with a smaller font size or a larger screen, I could see that at the same time so I wouldn't have to cut and paste it. But it's a good thing to have as a comment anyway. So all we've got to do now is turn that into Python. And I could do it in a straightforward way. I'm going to be a little bit lazier and save some typing by doing it in one line. Let me reconsider. I'm going to try to get this right the first time. We'll use a few more lines of code and I will follow what Wikipedia says more carefully. So if the year mod 400 is equal to 0, we're going to return True. It is a leap year. If the year mod 100 is equal to 0, we're going to return False. It's not a leap year. If the year mod 4 is equal to 0, we're going to return True. And if not, but we don't actually need the else, because we've been returning, we're going to return False. So let's test that. And if I wasn't thinking this was simple, I would probably write some special test cases, to test leap years. I'm going to just do it by hand with a few test cases now, because I think there aren't too many difficult ones. So 2000 is divisible by 400, so it should be a leap year. 2100 is not divisible by 400, so should not be a leap year and 2012 should be a leap year, and 2013 should not be a leap year. So I think I'm fairly confident that I got that right. So now, we're going to try to put that into days and months. We need to change the case for days in month when the month is February. Now we need to check the year, and if it's a leap year, we return 29, otherwise ret, return 28. And I don't need the else here, I'm going to put the else in just to make it look more balanced. Okay, so now lets run our current tests, make sure we didn't break something. They'll finished, that's a good sign. Let's add some tests that depend on leap years. So were going to, to test the next day, a February 28th, if it is a leap year. And we should do some long year tests, the number of days in a leap year should be 366. So I've got those two, let's also add the tests that we did by hand, and let's see, and the test all passed. And now we should try running it on the test that were provided. So, here they are. These are the tests from the provided question. And that was called test, as well, so I'm going to rename my test mytest, and let's see now if we pass all the tests. And we do, so I'm fairly confident my code is correct, now. If we wanted it to be faster, there's lots of things we could do better than this really simple, stupid approach of just going day by day. But in terms of getting correct code The simple approach had a lot of advantages. So I'll encourage you if you want to extend this as another programming exercise to try to make it faster. But in this case we're pretty happy with this. The other thing I'll mention if this were not a programming exercise. Python has built in types for managing dates. And that would make your life a lot easier to use those. There are lots and lots of different ways to solve this problem. Some of you may have come up with better ways than the one that I did. Certainly most of you probably came up with more efficient ways. If you have an interesting way of solving I would encourage you to post that for discussion on the class forum. So that concludes this lesson on problem solving, but developing better problem solving skills is reallhy a lifetime of effort. I hope some of the guidelines I've given you today will be useful for solving many problems you'll encounter in the futrue. Our first step is alwasy to not panic. Then to think about the inputs and the outputs and make sure we understand the problem by working through some examples by hand. Then to try and come up with simple mechanical solution that will be able to turn into code. And then the final step I'll mention, which is what we've been doing the last part, is to develop our solution incrementally in small steps that we can test as we go. Thank you for sticking with the lesson, and I hope you'll solve lots of hard problems in future. [Dave] Welcome back for Unit 2! I hope everyone is getting confidence in the things you learned in unit 1. We're going to continue to build on those in this unit as well as in rest of the course. Our main goal for this unit is to make the web crawler, instead of just finding one link in the page, to find all the links on a page, so that we can follow these links and collect more and more pages on the web. To do that we need two big new concepts in computer science. The first is procedures. Procedures are a way to package code so that we can reuse it more easily. The second is control. We need a way to be able to make decisions, and to do repetition, to find all those links on a page. What we saw at the end of Unit 1 was a way to extract the first URL from a web page-- that's great--we could find the first target. But if we want to build a good crawler, we don't just care about the first one, we care about all of the links on the page. We need to extract all of those links-- figure out where all of those links point to-- so we'll find many more pages to crawl than just the first one. So, that's the goal for this class as far as building a web browser. To do that, we're going to learn two really big ideas in computer science. The first is about procedures, and that's a way to package up code so we can use it in a much more useful way than we could before. The second is about control. Control structures will give us a way to keep going to find all the links on a page. So, let's remember the code we had at the end of Unit 1. We solved this problem of extracting the first URL from the page-- we assumed the page was initialized to the contents of some web page. We initialized the variable "start_link" to the result of invoking "find" on "page," passing in the start of the link tag. Then, we initialized the variable "start_quote" to the result of finding, in the page, the first quote following that link tag. Then, we initialized the variable "end_quote" to the result of invoking "find" on "page," to find the first quote following the start quote. And, then, we assigned to the variable "url"-- extracting from the page-- from the character after the "start_quote," to the character just before the "end_quote," we could print out that URL. This worked to find the first URL on the page. If we wanted to find the second one, we could do it all again. We could say, now we want to advance so we're only looking at the rest of the page. We could do that by updating the variable "page," assigning to it the result of the rest of the page, starting from "end_quote"-- and, remember, when there's a blank after the colon that means select from this position, to the very end-- and then we can do all the same stuff. We'll do "start_link" again; ... we'll do "start_quote" again; ... Now we've got code that's going to print out the first URL-- keep going, updating the variable "page"-- and then doing the exact same thing-- printing out the second URL. If we wanted to print out the first three, we could do it again... So now, we've got code to print out the first three URL's on the page-- let's scroll all the way up--so you've got-- print out the first one--keep going-- print out the second one--keep going-- so this can go on forever. The reason we have computers is to save humans from doing lots of tedious work. We don't want to make humans do lots of tedious work-- certainly, typing this out, over and over again, would be really tedious, and it wouldn't really even work that well. We have pages with hundreds of links, but there are other pages with only one or two links. So, it wouldn't make sense to copy this hundreds of times. There's always going to be some web page that has more links than we have copies of it-- and any page that has fewer copies, we're going to run into problems because we're not going to be finding any of those links. So, our goal today is to solve all of those problems. The first thing we want to do, is what's called "procedural abstraction." This is a really powerful idea-- this is--one of the ways we avoid having to do things over and over again by hand, is that we can write the code-- write it once, and use it many times-- changing the inputs to get different behaviors. If you look at each segment of code here, these lines were copied exactly the same way. We did the same thing, over and over again-- the same five lines of code-- to find the start of a link in "page," to find the start and end quote and then to extract the URL, and then to print the URL. The only thing that was different was the value of "page." We kept updating the value of "page"-- we did that as we went through the code-- we updated the value of "page" with this assignment and, before this one, we updated the value of "page" with this assignment. So, the idea behind procedural abstraction, is that anything that we're doing over and over again we want to abstract-- we want to make it a procedure-- and we want to make the things that change, inputs. That means, instead of having to type in this code over and over again, we want to make "page" an input-- "page" is the input; that's something that changes-- and we want to make the URL-- that's the result we want-- an output. That's our goal, to turn this into a procedure, where "page" is the input-- we can do the same code, over and over again, and every time we do it, we want to get this URL value as the output. The way to do that is what we call a "procedure." A procedure is something that takes inputs in-- there can be more than one-- does some work on those inputs; and produces outputs as results. The idea of a procedure is a very powerful idea. This allows us to use a small amount of code to do many different things. We can have the same code operate on different inputs. Whatever we pass in as inputs to the procedure will be what that code operates on-- and it can do different things depending on those inputs-- and it produces outputs that tell us the result, based on the inputs that we passed in. You've seen things very similar to procedures in the previous unit. You saw the built-in operators-- operators like "+." "+" took two numbers as its inputs, and, as its output, it produced the sum of those two numbers. Because it's a built-in operator, it's a little different from a procedure-- the syntax that we use for it is different because it's a built-in operator-- but, in terms of being something that abstractly operates on different inputs and produces the corresponding output, it's very much the same idea. What we're going to learn in this unit, is how to make our own procedures. Python provides a construct for doing that, and the grammar is to have the keyword "def"-- that's short for "define"-- followed by a name. And the name of a procedure is just like the name of a variable. It can be any string that starts with a letter, can be followed by letters and numbers and underscores. Anything that we could use as a variable, we can use as the name of a procedure. Then there's a left paren "(" the left paren is very important-- that's what makes it a procedure-- and after the left paren we have a list of parameters. "Parameters" is just a fancy name for the inputs to the procedure. After that, there's a colon ":" This is what says we're making a procedure-- it has this name; it takes these inputs. Then what we have to do is actually define the code. So, what follows that is a "block"-- and a "block" is just a sequence of statements, the code that we want to run, as the body of the procedure. What the inputs are is just a list of names, separated by commas. We can have as many inputs as we want. There could be no inputs. In that case, what the parameters would look like is just two parens with nothing between them - "()" There could be one input. In that case, we'd have a paren, followed by a name, followed by a closed paren. Or there could be many inputs; in which case, we'd have a paren, followed by the name of the first input, followed by the name of the second input, followed by the name of the third, followed by as many inputs as we want. So, we could have five inputs, give them the names "a," "b," "c," "d," "e." This is not a good idea, usually, to give our parameters meaningless names; that makes it hard to remember what they are when we use them in the code that we write as the "block." We're much better off having parameters with names like "page" that remind us what they mean. The body of the procedure is the "block." This is the code that runs to execute the procedure. The "block" is indented inside the definition. Usually we like to use four spaces-- that's just the convention in Python, and that makes it easy for people to see and read the code-- but all the lines in the "block" have to be indented the same amount. That's how the interpreter knows that we've got to the end of the procedure, when we get to some code that's not indented anymore. So, let's go back to the code we have for extracting the first URL in a page and see how we can turn that into a procedure. And remember, we made many copies of the same code if we wanted to extract many links from the page. What we want to do now is take the part that we kept having to copy and figure out how to turn that into a procedure. What we want to do is take this code-- we're going to take all the code here-- I'm leaving this part out of the procedure, because that's what we want to do with the results-- what we want to do is take all this code and turn it into a procedure. That means, instead of having to do all this work each time, what we want is a procedure that will start from what we have here-- we have the "page." What we want to do is from the "page," do a bunch of work; get the URL. Then, we want to do some stuff with the URL, want to do some stuff with the page, and then we're going to do it all over again. Our goal is to figure out how to turn this part of the code into a procedure, so we could keep reusing that, each time, instead of writing the same code. We need a little more room, so let's shrink the code we had. Now the question is, how are we going to make that procedure? Let's start with a quiz: When we think about making a procedure, the first thing we always want to do is make sure that we understand this: we need to know what the inputs are to that procedure; we need to know what the outputs are. If we don't understand the inputs and outputs, then there's no hope of writing the procedure correctly since the main purpose of the procedure is to map the inputs into the outputs. Let's see if you can figure out what the inputs should be for the procedure that we want to make to replace this code. I'm going to give the procedure a name. The goal of the procedure is to find the URL that's the next link target in this page, so we'll call the procedure, "get_next_target"-- it's important to give good names to procedures; that's how we remember what they're supposed to do-- and we'll use the name "get_next_target." So, our question now is, in defining this procedure, what should its inputs be? I'll give you some choices: its input could be a number giving the position of the start of the next link; its input could be a number giving the position of the start of the next quote; its input could be a string giving the contents of the rest of the web page; and, for the final choice, we could have two inputs-- the first, a number giving the position of the start of the next link, and the second, a string giving the contents of the page. The answer is that the input should be a string giving the contents of the rest of the web page. That's how "get-next-target" works. It finds the first target from the current page. One way to see that, is to look at the code we're trying to replace. This code defines lots of variables. It gives them values. The only one it uses on the right side, before giving it a value, is "page" When it uses "start_link" on the right side here, well the code defines "start_link" on the line above, so, it didn't care about the value of "start_link" going into this code. The only variable whose value we care about going into this code is the value of "page," and what "page" is, is a string giving the contents of the rest of the web page. So, that's the input. Now, let's think about the output. Again, we're looking at the same segment of code that we're trying to replace with a procedure. What do we think the output should be? This is going to be trickier. We need to think about what we need to know after the code runs. We don't have access to these variables if we're making this a procedure. We need to get--as outputs-- everything that we want to use after the procedure. So, the question is, what should be the outputs of "get-next-target," the procedure that we're going to define to replace this code. The first choice is the output should be a string giving the value of the next target URL found in the page. And that's what the variable "url" holds here. The second choice is we should output both the URL and the page. The third choice is that we should output both the URL and the value of "end_quote," the position where the end of the quote is. And the fourth choice is to output the value of "url," as well as the value of "start_link." That's the position where we find the beginning of the link. So this is a little bit trickier. To answer this one we have to look at the code after the procedure, and remember we said the procedure is replacing these four lines. After the procedure what we do is print the value of "url." So that means we definitely need at least "url" as our output and all of the choices here included "url." But that's not all we do, so we have to look at the second line as well. This uses both "page" and "end_quote." The value of "page" here is the same value of "page" before the procedure So we don't actually need to return the value of "page." It doesn't need to be an output from the procedure. We already know that. We knew that before we called the procedure. The procedure doesn't change the value of "page." No sense making it an output. So this answer doesn't make sense. We don't need "page." It does make sense to make "end_quote" one of the outputs. The reason we want "end_quote" as an output is we need to know where the end of the quote was to advance the page, so the next time we look for the next target, we don't find the same one that we just found. So we actually need this, so this is the best answer to the question, is that we need two outputs, we need both the url, and the value of "end_quote." The fourth possibility could work. If we return both the url and the value of "start_link," We could figure out a way to advance the page to not find the same quote, but we'd basically have to redo all this code. We need to look for the next quote, starting from "start_link." We need to look for the closing quote for that. Basically we'd need to compute the value of "end_quote" again. So it's a lot more useful to return the value of "end_quote," than to return the value of "start_link." That's why the third choice is the best choice. So now that we know the inputs and the outputs, the procedure almost writes itself. Especially since we already know the code that we wanted to execute before we defined the procedure. So I'm going to write the procedure, by modifying the code here. So first what we're going to do is make a little space. Erasing the code that's not part of the 4 lines that we want to turn in the procedure. So now I've, I haven't modified the code at all. What I have is, almost exactly what I need for the body of the procedure. This is what we want to do. What we need to do is modify that to get in the inputs, and turn it into a procedure. So, to make it a procedure, we need to use the def name syntax. So we're going to define the procedure. Get next target. So now we need our parameters, the parameters are the inputs for the procedures and we decided what the input should be. Is the web contents that's the string giving the contents to the webpage and that's what we had in the variable page. So we can call that page again here, that's what we are passing in as our input and now we have the body of the procedure. The code is exactly the same as the code we had before. But this time, instead of page being whatever it was here, page is whatever we pass in as the input to the procedure. And we can change the name of the page. It sort of makes sense to change that name. This code works no matter what we pass in. It doesn't have to be a webpage. Any string that we pass in, this code will find it. So it makes more sense to give it a slightly more generic name. We'll change the name to S. If we change the name of the parameter, well everywhere that we use page, now we don't have the value of page. What we have is the value of S, which is the name of the parameter. So we'll change all of those to S's as well. So we're almost done. There is one big thing we have left to do and that's how do we get the outputs. Right we said what we wanted the outputs to be is the URL and the value of end-quote. We need some way of getting those back and the way that you do that is to use return. Return's a special construct in python. So we have the keyword return, followed by a list of all the things that we want to return from the procedure. So what we return is a list of any number of expressions, seperated by commas. We can have zero return expressions, that would mean there's no output. And it actually is useful to have procedures with no output sometimes. That's not true if we just think of procedures as things that map inputs to outputs, but procedures can also do other things. They can do what we call side-effects, and what side-effects are, are things that we can see, but that aren't the outputs. And an example of a side-effect would be, well, if we printed something out, we would see that result happen. We'd see everything that happens when the code and procedure runs. But we wouldn't get it as an output. So, in this case, we do want to have outputs from get next target. We want to return results, so we know how to continue. And we decided what the output should be, are the value of the URL. So we want to find the string that's the next target. And the value of the end quote, so we know the position where it was found. So let's see if you can figure out how to finish the return statement. And your goal is to figure out the code that we need after the return, to finish this procedure. The answer is we need to return two things. We want the outputs to be the value of "url" and the value of "end_quote" so we know both the "string" that was foundÃ¢Â€Â”that's the target of the linkÃ¢Â€Â”as well as the value of "end_quote." We can do that by just returning those two values. We're going to have returning "url," followed by a comma, followed by "end_quote." That means that the two outputs from our procedure are the two values of "url" and the value of "end_quote." [Drawing smiley face.] Congratulations! You've defined your first procedure. This deserves a big smiley face. Procedures are really important ideas in computer science. We're going to find lots more proceduresÃ¢Â€Â”both today and through the rest of the course. Almost everything we do "in terms of building programs" is about building procedures. Those are the main things that we use to break down problems into things that we can solve. We're going to have some more quizzes about procedures soon, but first I want to give you an idea of how rich inputs and outputs can be when we do computations. We'll do that by looking at what happens when you build a self-driving car. So, I'm here with Sebastian, and Junior, one of Sebastian's self driving cars. Sebastian is going to give an idea of how rich inputs and outputs can be by talking about the kinds of inputs and outputs that he has on the self-driving car. [Sebastian] So, taking data in is essential to making self-driving cars work. This machine has a lot of sensors that take data in at enormous rates. There is a laser range finder on the roof that rotates. And it takes scans 10 times a second of the entire surroundings or range scans. It has a security camera, very much like Google Street who's able to see in all directions. In fact, this camera played an important role in Google Street's history and then it has stereo camera system, and also has a GPS system that we use to localize the car course [inaudible] based on satellite navigation. So, all this data, which are millions and millions of data points per second, get fed into the computer system that sits in the robot's trunk. So, this is the data. This is the laser data, but a million points per second. And you can see in his 3-dimensional depiction, the robot is parked in the garage, it sees the back wall, and it can see all kinds of other things around it. It uses that exact same data to avoid collisions with other cars, bicycles, pedestrians, and so on. And finally, the data gets funneled back to the car. These are the outputs of the computer system. And they go into the car: four little switches over here. They actuate the steering wheel; they use the brake, the gas. You can't really see it? It looks like a regular car; and it is. But if I hit this one button over here, it turns into a self-driving car. Unfortunately, we're not quite ready to be all smiley. Sebastian tells me it's going to be a few years before I can get my own self-driving car, but the bigger problem is we haven't yet talked about how to actually use the procedure. All we've done is make them; until we can actually use them we don't have a good reason to be really happy yet. We're going to learn how to use them next, then we'll be back to being smiley. Now we are going to learn how to use a procedure. The way to use a procedureÃ¢Â€Â”we need the name of the procedure, followed by a left paren, followed by a list of inputs. There could be any number of inputs, but it has to match the number of inputs the procedure expects. These inputs are sometimes called "operands." They are sometimes called "arguments." We're not going to argue about that. We're just going to call them inputs. You have actually already done something quite similar to this. Back in Unit 1, you learned about using "find" on "strings." With "find" you would pass in one or two inputs. The first input was a "string." That was the string you are looking forÃ¢Â€Â”that's the first inputÃ¢Â€Â” and the second input could be a numberÃ¢Â€Â”the position where you start looking for that string. We use "find" in many ways in Unit 1, as well as you used it yourself in the homework for Unit 1. "Find" is a little different from the procedures that you define yourself. First of all, it's built in. The other thing that was different is that, instead of just having "find," we had another input that was really over here. We have the string that we were doing the "find" inÃ¢Â€Â”let's say it was in the variable pageÃ¢Â€Â”that's really another input to find. We'll talk in a later class about why that's done differently, but it's very similar to calling a procedure where one of the inputs is over hereÃ¢Â€Â” the other two are here. It's a little different from that and we won't get into that in this course but in a later course you'll learn more about what this really means. For all the procedures that you define yourself, we won't have any object to invoke them on. We'll just have the procedure to call and the arguments or operands or inputsÃ¢Â€Â” as you like to call themÃ¢Â€Â”to pass in. Let's see how that works with a simple procedure. I am going to define the procedure "rest_of_string," and we'll give it the parameter "s," so that means it takes one input and we are going to use the name "s" to refer to the value of that input. We'll make it "return to string" from the first character to the end. We will use the "string" indexing operator "return s [1:]." This will evaluate to the "string," with the first letter removed, so all "strings" from position 1 until the end of the "string." That's what we return. So, the output of "rest_of_string" is that new string that starts from the second letter in the input "string." Here's an example of how to use this procedure. We could call it directly. We could say "print rest_of_string." That's our procedure. Now we are going to have our paren and we are going to pass in an input. There's one parameter to "rest_of_string," so we need one input to pass in and it should be a "string." We'll pass in the string 'audacity'. What happens when we call a procedure like this, execution will jump into the body of the procedure. We can think of what the interpreter is doing now. Instead of running the code here, the interpreter will move. When we call a procedure, it will jump to run the code inside the procedure. It will assign to the parameters the values passed in as the inputs. We can think of this as there being an assignment that says now the value of "s" is the value of this input that was passed in. Now we are going to evaluate the body of the procedure. In this case there's only one statementÃ¢Â€Â”it's this return statement. We are going to find this value, so s [1:]. The result of that is going to be the string 'udacity'. Then we got to the return. What return means is we're going to jump back. We're jumping back to where we called the procedure, but now we actually have a result. When we jump back, the value that this evaluates to is whatever value we returned. In this case, it's the string 'udacity.' So we don't have our self driving car, but now you can define and use procedures. This is a really powerful concept Anything that we are going to do in the rest of the course and anything almost anyone does in programming computers is all about defining procedures and using procedures. Now we should have a big smile. We can think of our procedures in terms of mapping inputs to outputs. We can think of our humans as also mapping inputs to outputs. We have inputs coming in through the eyes, through the mouthÃ¢Â€Â”maybe we even have a nose. I won't try to draw any of the outputs of our human procedure, but since procedures are such an important concept, we are going to have several quizzes now to check that you understand them well. So, for our first question about procedures, The question is, "What does the 'inc' procedure defined below do?" And here's the code for defining 'inc.' We're going to define the procedure that takes one input; we'll call that input "n," and we are going to have our return statement where the expression following the return is "n+1." So what does this procedure do? The choices are: Nothing. It takes a number as its input, and outputs that number plus one. It takes a number as input, and outputs the same number. Or--the final choice--it takes two numbers as inputs, and outputs the sum of those two numbers. So the answer is the second choice. The reason--for this we can see that it takes one input-- there's one parameter between the parentheses-- and it calls that input "n," and then what it outputs is--after the return, it outputs the result of "n+1." So whatever was the value of "n," which is the input, the result of "inc" is the value, plus one. So let's try another quiz. This one's going to be quite a bit trickier. Here the question is, "What does the 'sum' procedure do?" And here's the definition of 'sum,' so here we're defining the procedure of sum. It takes two inputs, "a" and "b," and its body assigns to "a" the value of "a" plus "b." So the choices are: Nothing; that it takes two numbers as its inputs, and outputs the sum of the two numbers; that it takes two strings as its inputs, and outputs the concatenation of those two strings. So the final choice is that it takes two numbers as its inputs, and changes the value of the first input to be the sum of the two numbers. This is a quite tricky question. I would encourage you to try some experiments in the Python interpreter to see if you can determine for sure what the sum procedure does. So the answer is, it really does nothing. It'll make the computer do some work when we call sum, but there's no good reason to ever call this procedure. It doesn't have a return, so it doesn't produce any output, and it doesn't actually modify the value of the first input in any way that's visible to the caller. It does modify the value of a inside sum, but the caller can't actually see that. Let's see that in the Python interpreter so we make sure we understand what's going on here. We'll define sum to take those 2 inputs and have the body that assigns to a, the value a + b, and we can try printing the result of calling sum. Let's see if it can add 1 + 1. When we run this, what we'll see is the result is actually None. The reason the result is None is, while the sum procedure doesn't actually return anything, so there's no value here. Python uses the special value "None" to mean there's no value. So that's not very useful. We could pass in bigger numbers. Whatever we pass in, will still get the result None because sum never returns anything. To make sure it's clear what's going on here, we're going to add some print statements to sum. Printing things out is actually a perfectly good and perfectly useful way to test your code to make sure that you understand what's going on. It's always a good idea to add print statements. Sometimes we call this debugging. if the code has problems, adding print statements to see more what's going on is a good way to figure that out. Here I'm going to print that I've entered sum, and I'll print the value of a, and I'll do the same thing again. Now when we run it, we see that we "enter sum!" When we enter sum, the value of a is 2. That was the value passed in as the first parameter. The value of b is 123. That was what we passed in at the second input. When we print out the first print, a is 2. We see a is 2. We do the arithmetic. That changes the value of a. So now running the same print, it prints out the value of a as 125. Then we return, we have the result. The result is None. There's no output from sum, and that's what gets printed out. So if we add a return statement to sum, now we have the original code that we had. I've removed the print statements. So we don't need to see those again. We have this, and now we've added a return statement. Now when we run this, we do get the value 125 because the output of sum is what's returned here, which is the result of a at this point, which is 2 + 123. The other thing I want to make clear without the return is that if we passed in variables for this, it still does not change their value. Let's say we had a variable--I'll even use a. So I'm going to use the variable a. We'll initialize it to 2. We'll have the variable b. We'll initialize that to 123. We'll call sum. We still don't have the return, so it will return no value. Let's see if the value of a has changed at the end, and it hasn't, and the reason it hasn't is what gets passed in here-- even when we have a complex expression, even when we use a name, or we have some calculation that produces the value-- what gets passed in is the value that that evaluates to. So the fact that it was a name doesn't matter. When we call sum, what's getting passed in as the value of a is the value that a refers to, which is the number 2. We don't actually modify what the variable is. That's a totally separate variable. Let me draw what that looks like to make it clear what's going on. Here we have our code. So that introduced a name "a," and it refers to the value 2, and it introduced a name "b," and that refers to the value 123. Both of those are numbers. And we have our procedure that we defined like this. It takes the 2 inputs. It changes the the value of the input named a. We're going to call sum, passing in a and b. What happens when we call sum--we have these names here. The names are our parameters. We're going to have a name inside sum that's a. That is going to refer to whatever value is passed in here. So to know what the value is, we evaluate the name a. We get the value 2. This a will refer to the value 2. b will refer to the value passed in as b. It's going to be the number 123. And then when we run sum, we do the assignment. That's going to produce the new number adding 2 + 123. We get the value 125, and then we do the assignment. The assignment changes what a refers to. Now instead of referring to the number 2, the a that corresponds to the parameter to the procedure sum, now refers to the number 125. Note that the original value of a, the one that we named here, still refers to 2. When we come back from the procedure, so once we get to here, we return. We're back to running the code here. All of the parameters that were visible inside the body of sum, those are no longer visible. They were there for that execution, but they're done. We can't use those names anymore. They were only visible during that execution of the procedure. Now at this point, a refers to the number 2, just like it did before. For the sum procedure to be useful and not do nothing, we need to change it. We need to add a return statement so we actually get an output. So add the return statement, return a, and now we'll re-ask the same quiz. I'm going to erase the previous answer because the answer is no longer nothing. I guess I've hinted at that. You can cross this one out from your consideration, but see which of the others are correct, and I should note it's still a tricky question. More than one of these is correct. Now the answer is that it actually does do something. It produces an output. If it takes numbers as inputs then it produces their sum. But it works also if we pass in strings. It would produce the concatenation of the 2 strings, because the "+" operator works on both strings and numbers. Given the name sum, it makes more sense to use it to add numbers, but it will work perfectly well using strings as well. And let me just show you that in the Python interpreter. So now, I changed sum to return the value of a. I have 2 variables that are strings. We've introduced s to 'Hello ' with a space at the end and t to 'Dave!' Now I'm calling sum, passing in s and t, and what I get as a result is Hello Dave! Note that it does not change the value of s. s is passed into the first input. Even though we change the value of a here, that does not change the value of s. Now we're ready for a quiz where you're going to define a procedure yourself. Your goal is to define a procedure named square that takes 1 number as its input and outputs the square of that number. What I mean by square is the result of multiplying the input number by itself. See if you can define a procedure that does that. If it's correct, you should get results like this. So if you do print the result of square(5), the output that's printed should be 25. Here's the answer. We're going to define a procedure, so we use the def followed by the name. We'll use the name square, followed by the left parenthesis, and now we need to decide what the parameters are. And remember when we define procedures, we should always be thinking about what the inputs are and what the outputs are. In this case, the input is one number. We see in our example, it was the number 5. We can give that any name we want. N is usually a good name for a number. So we'll use (n) and then we have the colon, and now we're ready to define the body of square. What we want square to compute is the square of the number, so we want to multiply n by n, and that's the output. We can do everything with 1 statement. It's going to be a return statement where the expression that we're returning is n times n. We want to get the value of n squared, and that's what we return. Here's how that looks in the interpreter. We're defining square. Our body returned n * n, and we're going to print the result of square (5). We get 25. We can use a variable. Let's say, x has the value 37. We can print the result of square (x). We get a bigger number that's 37 x 37, and we could also do this. Let's say we assign y the result of square (x), and then let's print the result of squaring y. That will give us 37 squared, and then we're going to square it again. That gets quite a large number--1.8 million or so. We could do those compositions without variables. We could do this directly. We could print the square of the square of (x), so we're calling square twice here. The first time we're passing in 37, then we're getting the output of that, and then we're passing it in to square again. This is called procedure composition. This is the way most programs are written, that we're going to write little procedures. Each procedure is going to take some inputs and produce some output, But then we're going to use the outputs that we get the first time we use a procedure as the inputs to the next procedure. In this case, we only have 1 procedure defined, so I've used square twice. When we run this, we see the value of 37 squared, which is quite a big number. We'll see lots more examples of how we can compose procedures using the outputs of 1 procedure as the inputs to the next procedure to get lots more interesting things done, and you'll write some procedures that do that yourself pretty soon. For our second quiz where you have to define your own procedure, we'll make things a little more complicated. Now you're going to define a procedure. We'll call it sum3, and the reason I'm calling it sum3 is because it takes 3 inputs. This is to distinguish it from the example, sum procedure, that we saw earlier that only takes 2 inputs. What sum3 should do is output the sum of those 3 inputs. So as an example, if you define sum3 correctly, if we print out the result of sum3, passing in 1, 2, and 3 as the inputs, the output should be the result of 1 + 2 + 3 Last I checked, that was 6. Here's the answer. We can define sum3. We're going to use the procedure definition syntax. So we have the def, followed by the name sum3, and now we need to find our parameters. Since there are 3 inputs, we need 3 names. We can make up the names whatever we want. I'm just going to use a, b, and c. Using letters like a, b, and c for inputs is usually not a good idea. They don't tell us a lot about what they're supposed to mean. In this case, since the inputs are just 3 numbers, and they don't mean anything special, we don't have any different meaning for the 3 numbers. Using a, b, and c is sort of sensible. But for most procedures, we want to use names that gives us a good idea of what the inputs are supposed to mean. Now we have our 3 inputs. We can produce the output right away just by adding those 3 numbers. For this quiz, your goal is to define a procedure. We'll call it abbaize. This is very useful if you need to come up with names, and what it does is take 2 strings as its inputs and outputs a string that is the first input, followed by 2 repetitions of the second input, followed by the first input. As an example, if we called abbaize, passing in the string 'a' and the string 'b'-- single character strings-- what we should get as a result is the string 'abba'. If we called abbaize, passing in the string 'dog' and the string 'cat', what we should get is the string 'dogcatcatdog', and there aren't any spaces between the strings. They're just all pasted together. Here's one way to define it. We'll call the inputs a and b, and all we need to do is produce a string concatenating them all. We can do that with one return statement. We're going to put a + b + b + a as the result. Now let's check that it works, passing in a and b. We run, and we get the result 'abba'. We can try the other example, passing in 'dog' and 'cat'. and now we get 'dogcatcatdog'. So far all of the procedures we've defined have been pretty simple. They've only required 1 line, maybe 2 lines of code. For the final quiz of this section, we're going to ask a much more challenging question. So far all of the procedures you've written have been quite simple, only needed a line or maybe two of code to finish them. Now we're going to try a quiz which is going to be much more challenging, and I'm going to give it a gold star to show that this is an especially challenging quiz. If you can get this one on your own, you're really understanding things very well. If you get stuck on this one, that's okay. They'll be some hints to make it a little easier, and then hopefully you'll understand the answer after you see it, and you'll have a lot more chances especially on the homework to try some harder questions on your own. So here's the question. Your goal is to define a procedure, and we'll call this one find_second. It takes 2 strings as its inputs, so the first input is the search string. The second input is the target string. And your goal is to print out the position of the second occurrence of the target string in the search string. It should output a number that is the position of the second occurrence of the target string in the search string. I'll show you an example in the Python interpreter of what find_second should do, then you should try and solve this on your own. For an example, here's the quote we had in unit 1 from George Danton, and if we evaluate find_second, passing in danton as the first input and 'audace' as the second, what we should get is the position of the second occurrence of 'audace' in the input string danton. When we run this, we see that we get 25, which is that position. Here's a way to define find_second. So we're defining a procedure, giving it the name find_second. It has 2 inputs. One name for the input would be search and target. The names could be anything you want, but it makes sense to give them names that tell us what we're doing. And then the first thing we need to do is find the first occurrence. So we're going to use search.find, passing in target to find the first occurrence. And now we're going to store them in a variable. To find the position of the second occurrence we have to do search again, so we're going to call search.find. This time we need to have the second input, which is first + 1 to say find the first occurrence after this position. We'll store that in the variable second, and we'll return second, and so that was the implementation that was used in the test. We could make this a little simpler. One way to make this simpler--we don't need to actually have the variable second. We could return second right away, and so now we only have 2 lines, and we'll run the same test just to show that it still works. We could even make it simpler than this. We don't even really need the variable first. We could replace first here with the search to find the first occurrence. Then we don't need the variable first. We only need 1 line. It's a good question, which of these is the best? I think probably the one before this was actually better than this. This is a complicated enough expression that it's hard to read. We're separating it into the variable first, and then using first here has exactly the same meaning, produces the same result. This is a little bit easier to understand what's going on, so I think I prefer this version of the procedure. But either one certainly is okay, and either one works well. Everything we've done so far has been pretty limited, that we had to do the same thing on all data. We couldn't do anything that really depended on what the data was. What we're going to do next is figure out a way to make code behave differently based on decisions. The first thing we're going to do is figure out some ways to make comparisons, so we have a way to test and decide what we should do. Python provides lots of different operators for doing comparisons. There are things similar to what we've used in math. We have a less than sign that compares 2 numbers. We have the greater than. We have a less than or equal to. Things like this... All of these operate on numbers, so we can have a number followed by a comparison operator, followed by another number. This is very similar to the grammar we saw earlier for arithmetic expressions, but now instead of having a plus or times here, we can have something that does a comparison. The output of a comparison though is not a number. It's a Boolean value, and a Boolean value is 1 of 2 things. It's either the value True or the value False. Let's see some examples in the Python interpreter. First, we'll use the less than to compare 2 and 3. So 2 is less than 3, so we expect the result to be true. When we run this, we see that the result is true. If we compare a number greater than 3, let's say 21 < 3. The result will be false. We can have any expression we want with a comparison, so we can do 7 * 3 < 21. When we run that, we also get false because 7 x 3 = 21, which is not less than 21. Another comparison operator we can use is not equal to. So != means not equal to. So 7 * 3 != 21 is false because 7 x 3 is equal to 21. If we want to do equality comparison, we don't use the equal sign, we use 2 equal signs. We call that the double equal. So now we have 7 * 3 == 21, and the result there is true. Now we're going to have a quiz to see if you can figure out why we need to use the == here instead of just the single =. The question is, why is the equality comparison done using ==, having 2 equals, instead of just a single = sign? The possible answers: Because = means approximately equal, and we want to do exact equality comparisons. Because we needed to use 2 characters for the not equal comparison, and we wanted the equal to be the same length. Because Guido, the designer of Python, really likes = signs. Because the single = sign means assignment, or it doesn't really matter. We can use either == or =. The answer is the 4th choice. We've already used the single = to mean something else. Single = means assignment. We can't use it to mean equality as well because that would be confusing. There are places where we couldn't tell what the code meant if single = meant both equality and assignment. Here's an example. The assignment i = 21 assigns the value of 21 to the variable i. The expression i == 21 is a comparison. It evaluates to either true or false depending on whether the value of i is 21. So now we know some ways to make comparisons. We want to use them to make decisions-- to make our code do something different, depending on the result of a comparison. The way to do that is to use an "if " statement. The structure of an "if" statement is: we have the keyword, "if", followed by a comparison, we'll call that the test expression, followed by a colon. And then, inside the "if", we have the block, and the block is the code that will run when the test expression is True. If the test expression doesn't evaluate to True, then the block doesn't execute. And, as was in the procedure definitions, we know the end of the "if" because of the indentation. All the statements inside the block are executed only when the test expression is True. The next statement that's not indented is going to be executed, whether or not the test expression is True. So here's an example of a procedure that uses "if": We can define a procedure, "absolute". It takes 1 input, which is a number. Inside the body of "absolute" we're going to use an "if" statement. We'll use an "if" test, where we're testing if the value of "x" is less than zero. So that's the test expression: we have the "if" followed by the test expression, "X < 0". In the Block, we're going to have one statement which changes the value of "x" to be "-x". The next statement, which will happen after the "if", whether the test was True or False, will return "x". So what this does is gives us the absolute value of the number that's passed in. If the number that's passed in is negative, we take its opposite and we use its negation, and then we return. If the number is positive, this test will be False so we don't execute the block that changes the value of "x" to its negation. We'll go right to the statement that returns "x". So now it's time for a quiz to see if you understand how to use "if" and can use it to define a procedure. Your goal for this quiz is to define a procedure called "bigger" that takes in 2 numbers as its inputs and it outputs the greater of the 2 inputs. So here are a few examples: If the inputs are "2" and "7", the greater input is "7" and the output should be "7". If the inputs are "3" and "2", the greater input is "3" and so the output should be "3". If the two inputs are the same, say "3" and "3", the output should be "3". So there are lots of different ways we could define "bigger." Here's one possibility: We're going to make a procedure; we'll give it the name, "bigger". It takes 2 inputs. We can give them any name we want. Since there's no real meaning to the inputs, we'll just use "a" and "b". And now we want to use a test to figure out which one is bigger. We're going to use a comparison, so we're going to see if "a" is greater than "b". Then we want the result to be the value of "a"--that's the bigger one. So we'll return "a". If that's not the case--well, if it was the case, we returned "a"; if it's not the case, then we're going to get here, and we can return "b". So this way of defining "bigger" is a little bit asymmetrical. Given what you've seen so far, this is probably the best way to do it. There's another way to do that, that uses an extra construct that allows us to have 2 directions that we can use the "if" in. So instead of just having what we had before, where we have an "if" and we have a test expression, and we have a block that executes when the test expression is True, what we want to do is have something that executes when the test expression is False. And we can do that by using an "else". We can have--after the "if", instead of the next statement, we can have an "else" that's part of the "if". This means if the test expression was True, we're going to execute this block. If it's not True, we're going to execute the other block, which is inside the "else". As before, the indentation tells us when we're done with the block, so after the "else", whatever code is here will execute whether the test expression is True or False. The test expression determines whether we execute the block inside the "if" or the block inside the "else". So let's see how to rewrite "bigger" using "else". We'll use "a" and "b" as the names of our parameters, as before, and we'll start the same--we're going to have our "if" and our test is still "a > b", and if that's the case, then we return "a". Instead of having the next statement return "b", we're going to think about having an "else" clause that says: well, if "a" was not greater than "b", what shall we do? If "a" is not greater than "b", then "b" is either the same size or bigger, and what we want to do is return "b". So this means the same thing. In this case, neither one is particularly better. I think this one is a little more symmetrical. There are lots of cases where it makes things work a lot better by using "else". And I'll show you one way that this could be different. If we didn't want to have two returns-- maybe we'll want to do something else with the result, instead of just return it-- well, with the "if, else" we can do that. So we can have--inside the first "if", we'll assign to the variable "r" the result "a". That's going to be the one that's bigger. Inside the "else", we'll assign to the variable "r" the result "b". That's the one that's bigger when the "if" test fails. And now the next statement here could return "r". Usually, we like our programs to be shorter rather than bigger. In this case, when we're defining "bigger", maybe the "bigger" version is better because that's a little easier to understand and follow. Your goal for this quiz is to define a procedure, is_friend, that takes a string as its input, and outputs a Boolean value indicating if the input string is the name of a friend. This would be very hard to do, in general, but we're going to assume that I have a very strict policy on friends. I'm friends with everyone whose name begins with the letter "D"--and no one else. So if the input name begins with the letter "D", your procedure should output True; otherwise, it should output False. So, for example, if we did: print is_friend('Diane'), the output should be True and if we did: print is_friend('Fred'), you should see the output False. So here's one way to solve the question: we're going to define a procedure, so we'll define a procedure, is_friend. It takes a single string as input. We'll call that the name--that's the name of the person. We're going to do a test using an "if" statement. We'll test if the first character of name is equal to an upper case "D". If it is, that means the person's a friend, so we can return True. If it's not--they're not a friend-- we don't need the "else", right--we could just have our return False. I'm going to keep things more symmetric by using an "else" and if the name does not start with a "D", we can return False. So let's try that. With our example, ('Diane'), we get is_friend is True, and when we try with ('Fred'), we get the output, False. So this looks like what we want. This is actually a lot more code than we need. There's no reason we have to actually have the "if" expression. Since the test itself evaluates to a Boolean we could just return right away. We could return the result of the comparison. We're doing the equality test, if name, index zero--the first character of name--is equal to "D". So this has the same meaning, much simpler thing. Sometimes people think it's unnatural to write expressions like this, that when you have test conditions, you feel like you need an "if" statement--but it's not required. It's much simpler, in this case, to just have the one line where we return the result of the equality test, directly. So for the next quiz, I'm going to make this a little more interesting and assume I'm not quite so picky about who my friends are. I'm going to be friends with people whose name starts with either "D" or the letter "N". So now the question is: we're still going to define the procedure, is_friend but I've changed my definition of a friend, so now we assume that I'm friends with everyone whose name starts with either the letter "D' or the letter "N", but no one else. So this result would still be correct--that would be correct. If we asked: is_friend a name that starts with the letter "N," let's say "Ned," then we should also get the result, True So see if you can figure out how to define "is_friend" for this new definition. So there are lots of different ways we could solve this. Here's one: so we're going to define the procedure, is_friend. First, we need to check if the name starts with a "D". If it does, then our result is True, and we can return True right away. If it's not, we're not done yet. We need to check if the name starts with the letter, "N". If it does, we return True. If we got to here, it didn't start with either a "D" or an "N", so that means we should return False. Let's see how that works. So we have 3 tests. The first one starts with a "D", so it should be True. The second one starts with an "N", should be True, and the third one starts with an "F", so it should be False. So there are lots of different ways we could have solved this. We could have used an "else" here--so we could have had an "else", and inside the "else" have the "if". And if it's not, then we could have an "else" here and the return, False. That will work, just the same-- a bit more code, but it also shows the structure perhaps a little better than the first one. The other thing we could do is return the result right away. To do that, we need to introduce a new Python operator that we haven't used yet, and that's the "or" operator. So we could do just this. This would be the equivalent of the long procedure we had before, where checking if the name at position zero is equal to "D" or the result of name at position zero is equal to "N". That produces the same result. And we've introduced the new construct, "or", which gives us the logical "or" of the 2 operands on its left and right. This will be the equivalent of the long procedure we had before We are checking if the name at position "zero" is equal to D or the result of name at position zero is equal to N That produces the same result and we've introduced the new construct "or" which gives us the logic "or" of the two operands on its left and right so just to see how "or" works we can use "or" like this So if we have "True" or "False", the value of "True" or "False" is "True" If we have "False" or "True", that also has the value "True" "True" or "True" is also "True", but "False" or "False" is "False" And I'm showing these boolean literals This could be any expression we want, like we use the name at position zero here The one important thing that "or" does is different from other operators It only evaluates what it needs to So here's an important example So we could say "True" or "this_is_an_error" That will also evaluate to "True" even though if I just look at "this_is_an_error" by itself that's an undefinable variable We didn't define the variable "this_is_an_error" but when we evaluate the "or" expression because we already found that the first part was "True", we don't get an error If we try to evaluate instead of "True" or "this_is_an_error" if we evaluate "False" or "this_is_an_error" it's necessary to look at the second operand and then we will get an error So let's try that, we are doing "False" or" this_is_an_error" we get an error because since the first operand was "False" to know whether the "or" is "True" or "False", we need to look at the second operand and that's not defined This behavior of "or" will turn out to be very useful We'll see other places where we rely on the second operand not getting evaluated if the first one is "True" So to summarize, here's what the "or" construct looks like So if the first expression evaluates to "True" then the value of the "or" construct is "True" and there's no need to evaluate the second expression and in fact the Python interpreter does not evaluate it If the value of the first expression is "False" then the value of the "or" construct is the value of the second expression Okay, so we're going to have a last quiz for this section, and it's going to be a fairly challenging one. So we'll give it a gold star. Your goal here is to define a procedure, "biggest", that takes 3 inputs that are all numbers and it outputs the greatest of the 3 numbers. So here's a few examples: So if the 3 inputs are "6", "2", and "3" the output of "biggest" should be "6". If the 3 inputs are "6", "2", and "7", then the output of "biggest" should be "7". And if the 3 inputs are "6", "9", and "3", the output should be "9". So whichever of the 3 inputs is the greatest number, is the output that your procedure should produce, and it should return that. So I've shown the outputs. We wouldn't actually see them, unless we printed them out. So this is a pretty tough question--I hope you were able to solve it. There are lots of different ways to solve this. I'll start by working out one way on the sketchpad, and then we'll see a few different ways to solve it in the Python Interpreter. So I'm going to call the 3 inputs "a", "b", and "c". We can call them anything we want, and since they're not meaningful numbers, might as well just use the first 3 letters. So one way to solve it is to have a big, complicated, nested "if" statement. So we're going to have several comparisons. First, we want to check if "a" is greater than "b". If "a" is greater than "b"--well "a" might be the biggest, but we don't know yet; we still have to check if "a" is greater than "c". So we need 2 "ifs" and the important thing to notice about the 2 "ifs"-- the comparison, "a greater than c" is indented inside the "if a is greater than b". So this will only happen when "a" is greater than "b". That means if "a" is greater than "b" and "a" is greater than "c", "a" is the biggest, so we can return "a". If it's not--well, now we've got the case where "a" was greater than "b". "a" is not greater than "c", so that means "c" is greater than or equal to "a". So now we know that "c" is the biggest since "c" is bigger or as big as "a" and "a" is bigger than "b". So now we can return "c". So when this is not True, we know that "c" is greater than or equal to "a", and we know that "a" is greater than "b" because this test evaluated it to True. So we know it's correct to return "c". Now, we want an "else" that corresponds to this condition, so here if "a" is greater than "b", we evaluated this code. If "a" is not greater than "b", well that means we have: "b" is greater than or equal to "a". And in this case, we want to check whether "b" is greater than "c" so we need another "if"--I'm going to use "if b is greater than c". Now we know that "b" is greater than "c". "b" was greater than or equal to "a" because we went to the "else" here. So that means we can return "b". If not--well then, we know "b" is greater than or equal to "a", and "c" is greater than or equal to "b", which is greater than or equal to "a". So that means "c" is the biggest. We should return "c". So here we have a definition of "biggest". It's pretty complicated. We have 3 different "if" statements. The main one that starts by comparing "a" and "b", and then within that, we compare "a" and "c". Then we have the "else," and within the else, we compare "b" and "c." Whenever we have lots of nested "if" expressions-- and certainly, we can have more than this amount, but this is already getting to be enough to be confusing. We should try to think if there's a clearer way to do this, a way to make the code smaller and simpler, easier to understand--and if it's easier to understand, that means it's also easier to write it correctly. So the easier way to write this would be to use the "bigger" procedure that we defined earlier in this unit. And if we remember what that was, we defined "bigger" like this: "bigger" took 2 inputs, it compares them: if "a" is greater than "b", it returns "a". If not, well then "b" is bigger--or at least equally big-- so we can return "b". So if we have "bigger" defined, which we already did, then we can define "biggest" in a much simpler way. We don't need all these "ifs". All we need to do is use "bigger" twice. So if we remember that we have the "biggest" procedure, well then we can think about "biggest" this way. So we've got 3 inputs coming into "biggest", and it should produce 1 output--the biggest of those 3. Well, we've got the "bigger" procedure so we could use "bigger" to compare two. If we put "a" and "b" into "bigger" the output here is going to be the bigger of "a" and "b". To know the biggest of the 3--well now we need to compare that one with "c", so the inputs to this ""bigger" procedure will be the result of "bigger" of "a" and "b" and the input, "c". And the output of that will be the biggest of the three. So this is composing 2 calls to "bigger". We want the inputs to the first call to be "a" and "b". We want the output of that call to be one of the inputs to the next call. So here's how we can do that, in code. We can return the result directly, and the result will be the result of "bigger"-- and this is the last "bigger". When we do composition, we need to think about the function that we actually do last coming first because that one needs the inputs of the other ones. So the input to this call to "bigger", it has 2 inputs. It has the result of this one, which took "a" and "b" as its inputs. So that's what's here, taking in "a" and "b", producing this output. That's one of the inputs, and then the second input to "bigger" is "c". So that's a much shorter way to write "biggest". It takes advantage of the fact that we already defined a procedure that does this for 2 inputs. And now we want to do the "biggest" for 3 inputs. There's actually an even easier way to do it, and that's using a built-in operator. There's a built-in operator, "max", and we could use "max" directly to implement "bigger", just returning the "max" of a, b, and c. If we actually knew about the built-in operator, "max"-- well then, we wouldn't need to find "biggest" at all. We could just use the built-in "max". But the important thing to see here is that we can define procedures ourselves. And, in fact, we've seen enough at this point that every built-in procedure in Python, you could actually define yourself. And it's even better than that, that you actually know enough at this point, that you could write every possible computer program, using just the things that we've seen. And this is a pretty astounding result, and I mean this in a very strong sense, that everything that could be computed mechanically by any machine can be described using a program that only used the things that we've seen so far. All you need is procedures, simple arithmetic with the comparisons, and "if" statements. And this is a pretty amazing thing. This was shown by Alan Turing, back in the 1930s. Alan Turing is probably the most important computer scientist. In the 1930s, he developed an abstract model of the computer which we now know as the "Turing Machine". And he proved that that machine, with a very few simple operations, could simulate any other machine. I should point out that Alan Turing was doing this back in the 1930s, when there weren't computers like we think of today. In the 1930s, what someone thought a computer was was a human who did calculations, and they did calculations in a mechanical way, following steps such as what you might have learned in grade school to do long division or long arithmetic. Alan Turing showed that a very simple model was enough to capture everything that a mechanical computer could do, whether it was a human computer or a modern computer that operates electronically, like we think of today. Following World War II, he worked at Bletchley Park. This was the headquarters where all the British efforts to break the Nazi encryptions were done. Alan Turing lead the effort there to break the Enigma Code. Enigma was the most widely used cypher code by the Nazis. And Alan Turing built machines that could be used to break the Enigma Code. These were sort of like computers. They would do lots and lots of calculations. The big difference between these machines and what we think of as computers is these machines weren't programmable. They were built for one very specific task, for doing a calculation that was useful for breaking Enigma encrypted messages. And it was tremendously useful that they could do that. This had a huge impact on WWII. But they weren't computers because they couldn't be programmed to do anything else. We're not going to get into the theory of Turing Machines in this course, but I hope you'll take one of the later courses that we'll do. The important point to make now is that, with a very few simple operations, you can simulate any other operation you want. And you've seen arithmetic, you've seen comparisons, you've seen how to define and call procedures, and you've seen how to use "if" to make decisions. This is enough to simulate anything else a computer can do. So with just that, you could write every possible computer program. We could end the course here and you could, from just the things that you know now, build any computation you want. We're not going to end the course here though. And the reason for that is, although you could, in theory, build every computation using just these very simple things that we have so far, that's not going to be the best way to build computations, that there are more powerful constructs that we can use that mean, with a smaller amount of code, or in a more elegant way, that we can write the computations we want. We also have a lot to learn to get practice using these to define more interesting programs. But in theory, everything that you need to know to write any possible computation, you already know, from just these constructs that we've seen so far. I said we didn't need any new constructs, but we are gonna introduce one and that's gonna make writing the code we need for a search engine much more convenient It's also gonna be very useful for lots and lots of procedures that we wanna write and the construct we are gonna introduce is called a loop It's a way to do things over and over again The kind of loop that we are gonna introduce first is called the while loop The syntax for the while loop is this We have the key word "while", followed by a test expression followed by a colon, and then inside we have a "block" and the "block" is a sequence of instructions This is very similar to the "if" statement So as a reminder, here's what the "if" statement look like we had an "if" followed by a test expression, followed by a colon and then an indented "block", which is a list of statements that executes whenever the test expression evaluates to a "True" value With "if", the block executes either zero or one times, depending on whether the test expression is "True" With "while", the block can execute any number of times It keeps going as long as the test expression is "True" So with the "if " statement, if the test expression is "True" we go to the block, run the block and then continue if the test expression was "False", we go right to the next expression With a "while", we also start by checking the test expression if it's "True", we go to the block But now, instead of going to the next statement, after the block, we go back we try the test expression again, if it's "True", we go back to the block we always go back to the test expression if it's "True", we do the block again, we go back to the test expression If it's "True" again, we do the block again, we go back to the test expression and we can keep going around as many times as we need as long as the test expression is "True" we'll keep executing the block and keep trying the test expression again At some point, maybe the test expression is "False" Once the test expression is "False", we go to the next instruction So this means a while loop can execute the block either zero times if the test expression was "False" at the beginning one time if it was "True" the first time, but "False" after that two times, three times...any number of times, it could keep going forever There's no requirement that guarantees the test expression eventually becomes "False" So here's an example of while loop. We start by initializing variable i, and we'll give it a value, zero then we have the "while", the test expression says i is less than ten So that means as long as this evaluates to "True", we'll evaluate the block and what the block does is print i and then add one to i So here's what happens when this executes So initially, the value of i is zero, i is less than ten So that means we'll enter the loop So that means the test expression is "True", so we'll enter the block, we'll print i So we'll see the value zero printed and then we'll do the assignment, so that will change the value of i We add one to i, so that's gonna be making the value of i now refers to one So if it was an "if", we would be done now, but because it's a "while", we keep going We go back, test again, if i is less than ten Now the value of i is one, which also is less than ten so we continue, go to the block again we are gonna print i, this time we'll see the value one Then we go to the next statement, increase the value of i by one that's gonna make the value of i two Now i refers to the number two Because it's a "while", we keep going, we go back to the test expression i is less than ten, still less than ten, now it's two, we are gonna print the two we are gonna add one that it will make the value of i three and we are gonna keep going Test again, and i is still less than ten, so we are gonna print i again we will print the value nine, then we add one, so that's gonna have one to nine, we'll get ten So that's the new value of i and we go back again and now we do i is less than ten, and now i has the value ten Ten is not less than ten, so that will be "False" and we are done with the while loop We'll continue with whatever statements here, in this case, there is none So then the loopÃ¢Â€Â”Ã¢Â€Â”what we've done, we've gone through it ten times we've printed the numbers from zero to nine The new value of i will be ten, if we do anything here that uses the value of i we'll see that the value of i is ten So to see that you understand while loops, we'll have a quiz So the question is what does this program do Here's the program We start by assigning zero to i We have a while loop, where the test is not equal to ten So the test is i is not equal to ten Then we have i equals i plus one, so we are assigning to i the value of i plus one and then we are printing i So this is similar to the example, but different in a couple of ways So it's up to you to see if you can figure out what the program does Try to figure out yourself You can certainly also try running this in the Python interpreter The choices are produce an error print out the numbers from zero to nine print out the numbers from one to nine print out the numbers from one to ten or the final choice is it runs forever or at least until our machine runs out of power So see if you can figure out what it does You can definitely try running it but try to figure out on your own before running it in the Python interpreter So the answer is: it prints out the numbers, from 1 to 10. And if we follow through the code, we can see why. So initially, the value of "i" is zero. The test says, well "i" is not equal to 10, so zero is not equal to 10-- so we go through the Block, and the Block adds 1 to "i". So that will change the value of "i". Now "i" refers to "1". And then the next statement prints the value of "i". The value of "i" now is 1, so it will print, "1". And then, because it's a while, we go back. We do the test again--I'm not going to step through every time, so we keep doing this. As "i" gets bigger, we're going to keep going. Eventually--let's say "i" is 9, and by the time "i" is 9--well, after "i" was 9--we print "9". So we've printed the numbers from 1 through 9. At this point, "i" is still not equal to 10, so we still go through the loop body. Now we add 1 to "i"--that will make the value of "i" 10. Then we do the print, so that will print out, "10". Then we go back to the "while" test. Now the value of "i" is 10, so: "i" not equal to 10--"10" not equal to 10-- is False, because 10 does equal 10. That means we're done with the "while" loop and we're going to continue, but there's nothing to continue with, so we're done. So the net result of the code is printing the numbers from 1 to 10 and that's all that happens. So now the test is False. We don't execute the Block anymore, we would continue with the next statement. There isn't one, so we're done and what the code did was print out the numbers from 1 to 10. So we're going to have another quiz about "while" loops. This one's going to be a little trickier. The same idea, your goal is to guess what this program will do and, like the last one, try to figure out the answer yourself rather than by running the code. We're going to assign 1 to the variable "i". We'll have a "while" loop where the test condition is: "i" is not equal to 10. And, in the Block, we'll have a statement that says: "i" is assigned the value of "i" plus 2-- so adding 2 to "i", then we'll print "i". So the choices are: produce an error, print out the numbers: 2, 4, 6, 8; print out: 1, 3, 5, 7, and 9; print out: 3, 5, 7, and 9--or run forever. So the answer is: this loop will essentially run forever. It won't run till the end of the universe, because we'll probably have something else happen to our computer before that. But there's no stopping condition for the "while" loop. The "while" test will never become False. We start with "i" equals 1. We keep increasing by 2, so the values that I will have will be 1, 3, 5, 7, 9, 11, and so forth. The loop test checks if "i" is equal to 10. If "i" is not equal to 10, we keep going. So if "i" is not equal to 10, we're going to keep going through the loop. "i" will never become 10--we skip 10. The loop test is never True--that means the "while" loop just keeps going forever and ever, never finishing. I'll show you what happens when we run that. And I'm going to show this running in the Python shell instead of running through the Web browser ID that you've been using so far in the class. And the reason for that is we can see more output. We can run longer things that--the way you run the programs for class, there's a limit to how long they can run and how big the output can be. With the shell, there's no limit like that, so I can show you a longer execution. There are instructions on the Web site, if you want to run programs yourself in the Python shell. There are lots of different ways to do that, and instructions for how to do that on different platforms. It is not necessary to continue with the class, but it will make it easier to see what's going on here. So here's the code. I'm going to enter the code that we had, so we have "i" is assigned 1, and then the loop, "while i is not equal to 10". We're going to increase "i" by 2, and then we're going to print "i". So now when I type return one more time, this "while" loop will start running, and we'll see it print out the numbers and it will keep going as long as we let it keep going. So here we go. We see 3, 5, 7, notes keeping going, really fast. So at the top, you can see the first 5 numbers: it started at 3, 5, 7, 9, 11. Since it skipped 10, the loop didn't stop. This condition was never False. And it keeps going--and it will keep going for as long as we let it print or until our computer runs out of memory or power. So a loop that never stops like this is what we call an infinite loop. That means it keeps going forever, and if you run programs on computers, you've probably encountered them a lot-- not just in the program that you just wrote, that we just used for this quiz, but oftentimes, when your software hangs and gets stuck doing something--that's what's going on, that there's some mistake that a programmer made. We call that a bug--there's a bug in the program, and it's stuck in an infinite loop; it's never going to make any progress. It's got stuck in something where the test condition will never be True and it's going to keep going forever. So now we're ready for a quiz where you're going to write your own "while" loop and you're going to do that in a procedure. So your goal is to define a Python procedure-- and we'll call it "print_numbers", with an underscore. And it takes, as input, a positive number, and it prints out all the numbers from 1 to the input number. So, for example, if we ran "print_numbers", passing in 3, what should happen is it should print out the numbers: 1, 2, and 3. So this one's going to require some thought, but you know enough to be able to do it. You're going to have to define a procedure, you're going to have to use a "while" loop, and you'll probably need to introduce a new variable. So see if you can figure out how to define "print_numbers". Here's one way to define "print_numbers": so we're going to make a procedure using "def". It takes 1 input. We'll use the name "n" for our input. That's the number that we go up to. Now, to do the loop, we need to have a new variable that keeps track of the loop iterations. We'll use "i" for that, and we start with 1--that's the first number to print out. We need the loop now, so we have the "while" and the test that we want is we want to keep going, up to and including the number, "n". So we want to print the numbers, all the way from 1 up to and including "n". So our test will now be a less than or equal to test. We want to keep going as long as "i" is less than or equal to "n". Once "i" gets bigger than "n", that's when we should stop. What we do in the loop body is print the value of "i" and add 1 to "i". We don't need to return anything; the only point of the procedure, as we were asked to write it, was to print out the numbers. So now let's do a test: we'll print the numbers up to 3, and there we get the output, printing the numbers 1, 2, 3. There are lots of other ways we could have written this. Another approach would be to start with "i" equals zero, make the test condition "i" is less than "n". So now we're stopping as soon as "i" is equal to "n". For this to print out the correct numbers, though, now we need to move the print. We want the print to be after we added 1 to "i", so the first number we print is supposed to be a 1, which will be the case here. And the final number we print should be "n", which is the case here. Once the value of "i" is "n", this test will be False and we don't go through the loop anymore--so when we run this, we get the same result, printing 1, 2, 3. So as another test, let's see what happens when we pass in zero. And when we run this, it doesn't print anything. That's because when "i" is zero, "i" less than "n" evaluates to False. Zero is not less than zero, so we don't go through the loop at all and don't print anything--which seems like a pretty sensible thing. Since we said print the numbers between 1 and the target number, if the target number is zero, not printing anything sort of makes sense. For the next quiz, you are going to define a procedure that can help solve the problem of figuring out how many different ways there are to order objects. Here is the problem we want to solve. Suppose we have four blocks. We have a red block. We have a blue block. We have a purple block and we have a green block. We have a baby who wants to play with the blocks, and we want to know how long can the baby play with the blocks without getting bored. What the baby wants to do is try all the different ways of arranging the blocks. The baby will stack the blocks in a tower. The baby might pick the red block firstÃ¢Â€Â”put that on the ground. Then put the blue block on top. Then put the the purple block on top of that, and then put the green block on top. When she's made one tower, she is going to knock it down and make another one. She's going to keep doing this as long as she can make different color combinations. If she has to make the same tower twiceÃ¢Â€Â”well, that's pretty boring. Maybe the next one she'll pick the purple block first, then she'll pick the red block, then she'll pick the blue block, and then she'll pick the green block. These two are different. The question we want to answer is, how many different towers can she build? Given that she has four blocks, we want to know how many different towers could you build with four blocks, but maybe she gets some more blocks. What we really want to know isÃ¢Â€Â”given that she has "n" blocksÃ¢Â€Â”whatever number "n" isÃ¢Â€Â”how many different towers could you build where the color combinations are all different? The way to solve that is to think about combinatorics. The way to pick the first blockÃ¢Â€Â”well, it could be any one of these four. We have four choices. Let's sayÃ¢Â€Â”for our exampleÃ¢Â€Â”she chooses the red block first. Now it's time to choose the second block. Well, she can't use the red block again. She has already used it, so she can either use the purple, the blue, or the green block. She has three choices now. She can use the purple block, the blue block, or the green block. Let's say she chooses the green block, so she is going to have the red block and then the green block. She had three choices. She could have chosen any of the other two, but now that she has chosen the red and the green, she only has two choices left for the third block. She can either use the purple one or she could use the blue oneÃ¢Â€Â”those are the only two that are left. Let's say she uses the purple one. Now for the final blockÃ¢Â€Â”well, she's used the red one, she's used the green one, and she's used the purple one. The only one that's left is the blue one, so she has no choice but to use the blue block. That means for the fourth block, there was only one choice. So, for each of these choices, she could choose any of the four for the first one, any of the three remaining ones for the second oneÃ¢Â€Â”regardless of what she picked for the first one. If she picked red, she could pick either purple, blue, or green, but if she'd pickedÃ¢Â€Â”sayÃ¢Â€Â”blue for the first one, then what she'd have left is purple, red, and green. She always has three choices for the second one. After that, there's only two choices leftÃ¢Â€Â”there's only two blocks left and she can choose either one. The pattern here is every time she chooses a block there's one less because she's used the block in the previous choice. For the total number of choices, what we want to do is multiply all these numbers. To figure out the total number of choices, what we need to do is multiply the number of choices for the first block, and then we multiply that by the number of choices for the second and we keep going for however many choices there areÃ¢Â€Â”in this case there are only fourÃ¢Â€Â”until we get down to one. Each time we make a choice, we have one fewer items left to use for the next choice. So the function that we are computing here is mathematically called factorial, and it's sometimes written with an exclamation point. A way to define factorial isÃ¢Â€Â”for any value n, we can compute the factorial, which is the number of ways of arranging "n" items. We can compute that by multiplying "n"Ã¢Â€Â”which is the number of choices for the first itemÃ¢Â€Â”times "n" minus oneÃ¢Â€Â”that's the number of choices we have left for the second itemÃ¢Â€Â”times "n" minus twoÃ¢Â€Â”that's the number of choices for the third item and so fourth, all the way until we get down to one. So, your goal for this quiz is to define a procedure named "factorial" that takes one number as its inputÃ¢Â€Â”that's the number "n" hereÃ¢Â€Â”and outputs the factorial of that number, which we can compute by multiplying "n" times "n" minus one all the way down to one. Here's one way to define factorial. There are lots and lots of ways to solve this, so we're going to define a procedure and its input is the number "n." What we want to do is compute this functionÃ¢Â€Â”we're going to compute "n" times "n" minus one times "n" minus two. We are going to need a variable to keep track of the results as we go, as well as a variable to keep track of how many times we go. We're going to define a procedure that computes the factorial of "n." What we need to do is multiply all these numbers, so we're going to have a variable that keeps track of the results so far. We'll start by initializing that to one, so we'll call that "result" and we'll set its initial value to one. We're going to keep multiplying by "n" until we get to the end. We're going to have our "while" loop where the test condition is as long as "n" is greater than equal to one. We're going to start with "n" as the value that was passed in. We're going to subtract one each time we go through the loop until we get down to one, and keep updating the result. The result keeps updating, so we want the result to be the previous result times "n." We also have to change the value of "n" to keep reducing "n" as we go. We subtract one from "n" every time through the loop. The result is multiplied by the current value of "n"Ã¢Â€Â”"n" is decreased by one. We keep going until we get to "n" is equal to one. We're not quite done yet. We want to return a "result," and the value that we want is stored in this variable "result," so we "return results" here. Let's try that in the Python interpreter. Now we'll see what happens when we have the input 4Ã¢Â€Â”our child playing with the blocks. We see the results as 24. They're 24 different ways to arrange the four blocks. Factorials increase pretty quickly, so we could also use the factorial procedure to figure out the number of different ways to arrange a deck of playing cards. If we have a deck with 50 cards, there are 52 ways to pick the first card, 51 ways to pick the second, and so forth. When we run this, we see that the factorial of 52 is this really big number. That's why you can have so many different card games. Every time you play, the arrangement of the cards is going to be different. [Break Time!] So now you have finished the hard quiz about factorial. You might think you deserve a breakÃ¢Â€Â”and you almost do, but we have one more thing to learn about "while" loops, and that's the "break" statement. "Break" gives us a way to stop the loop even while the test condition is true. Here's the typical structure of a loop with a "break," so we have the "while"Ã¢Â€Â”as we did beforeÃ¢Â€Â”and we have the test expression and we had a colon. Our general "while" structure is we had a block here. Now we want to look inside this block a little bit to see the kinds of things that could be here. This is just an example of what might be in the blockÃ¢Â€Â”we have some code, we have some Python statements, and then we have an "if" statement. That's going to have another test expressionÃ¢Â€Â”we'll call that the "break test." That's a text expression that's checking whether it's time to take a break. When the "break test" is true, what we have is "break" whichÃ¢Â€Â”by itselfÃ¢Â€Â” is all we need. What "break" means is stop executing the "while" loopÃ¢Â€Â”jump out of the "while" loop and continue with the code after that. Whatever we had here, this is more code that was in the "while" block. That will get skipped and we'll jump to this point which is the code after the while. So what happens when we execute a loop with a "break," it executes like a normal loop. If the test expression is true, we go to the code. If the "break test" is false, we don't execute the break. We would continue with the "more" code. We would go back to the loop test and check the test expression again. If it's true, we go run this "code." If the "break" is true, then we execute the "break." What "break" does is jump out of the loop, so we don't execute the "more" code, we don't execute the test expression again. If the "break" happens, what happens is we jump to the code after the "while." This gives us a way to break out of the middle of the loop. Here's an example of how we might use that. Before, we defined the procedure "print_numbers" without using break. We defined it like this. This is the code we had before. We could rewrite that using "break." Now, instead of having the "while test" stop the loop, we'll make the "while test" true. True will never become falseÃ¢Â€Â”that means, if we didn't have a break, the loop would keep going forever, but we're going to add a "break." We're going to have an "if test" that says the stopping condition now is we're going to stop once "i" is greater than "n." The way to stop is to use "break." If "i" is not greater than "n", then we're going to keep going. We'll do the same thing we did beforeÃ¢Â€Â”we'll print "i" and we'll add one to "i". This loop has exactly the same meaning as the one we had before. The previous one's better in every way. This is more complex. There's more code. This illustrates how we can use break. We wouldn't want to do it this wayÃ¢Â€Â”this is much worse than what we had before. We want to keep our code simple and easy to understand. We'll see once we get to the code for extracting all the links on the page that there are cases where it's easier to write the code using "break" than it is without that. Now we are going to have a quiz to see that you understand "while" loops, as well as "break." This is going to be a pretty tough quiz that you have to think carefully about how "while" loops are defined and what "break" means. The question is which of the following are always equivalent to "while," any test expression "T", and a blockÃ¢Â€Â”which is any statement "S." "T" and "S" could be anything, and your question is to understand which of these are equivalent to that. Here are the four choices. The first one is a "while" loop with a nested "if." The second one is a "while" loop with the statement and a "break." The third choice is a "while" loop with a nested "if." The fourth choice is a "while" loop with a nested "if", an "else," and a "break." Your goal is to check all the ones that are equivalent to the "while T", "S"Ã¢Â€Â”where "T" and "S" can be any test expression in any statement. Here's the answer. The first one is equivalent. The reason for that is we have our code here that has "if False." "False" will never be true, so we'll never actually run the "break"Ã¢Â€Â” we'll never reach that code. We'll just run the statement again and we'll have the same thing that we started with. Every time the test is true, we execute the statement. The second one is not equivalent, and the reason for that is the "break" will stop the loop. If the loop would execute more than once in this version, and if we go through the loop twice, in this case we can only ever go through the statement once, since after we go through the statement once, we reach the "break" and then we're done. The third one is not equivalent, so here we're having a "while true" that will run forever except for we have the "break" and that would stop it. The problem is the test condition for the break is the same as the test condition for the "while," but it should really be the opposite. In the "while" we keep going as long as the test condition is true. The way I have written in the code here, if the test condition is true, we stop. For this to be equivalent, what we should have written instead would've taken the opposite of the test condition, so if we had "if" not"Ã¢Â€Â” which changes true to false and false to true, then the test condition, then the breakÃ¢Â€Â”this would be equivalent to the original loop. What we have is not. The final one is the most complicated. This one is actually always equivalent to the original loop. The reason for that is if we think through the execution, so in the original loop, if the test condition is true, we ask to give the statement "S," and then we keep going. If the test condition is true the second time, we execute "S" again and we keep going. If we look at what happens hereÃ¢Â€Â”well, if the test condition is true, we execute "S." Then if the test condition is true again, we execute S and we keep going. That has the same behavior. We should trace it through the case where the test condition is not true. HereÃ¢Â€Â”if the test condition was true, we execute "S." If it's not true the second time, then we're done with the loop and we continue. In this case if the test condition is true the first time, we'll execute "S." If it's not true the second time, then we would go to the "else." So if it's not true, we go to the "else" and then we go to the "break" and the "break" gets out of the loop. We have the same exact behavior where we executed "T" once, then we executed "S," and then we executed "T." We didn't execute "S" again, and we broke out of the loop to continue. So these two are equivalent and the other two are different. So, breaktime is over; now, you know about "Break." You know about "while" loops; you know about "if" to make decisions; you know everything you need to finish the goal of today's unit, which is to write the code for extracting all of the URLs from a web page. First, let's remember what we were doing before: we had the code that kept repeating to get one link after another. So, we had code like this: we had finding the "start_link"-- and we assumed, before entering this code, that "page" has the contents of some web page. We would search for the start of a link; then we would find the "start_quote," again using "find," but this time passing in the start of the tag and searching for the double quote. Then, we would find the "end_quote." And then we would extract the URL using the string selection-- selecting from "page," from the "start_quote" to the "end_quote." Then, we would print out the URL, and this was what we needed to do for one URL. We would continue by advancing the "page" to go from where we found the "end_quote" to the end; and then we would do all the same thing again to find the next URL. And we'd keep doing this code, over and over again, finding as many URLs as there were on the page. So, here's the code, shrunken down so we have some more space. What we want to do is extract into a procedure, this part [indicating the first four lines after "page" is defined]; and then we want to make it so we can keep going. We've seen "while" loops give us a way to keep going; so, we'll end up writing a "while" loop that keeps looking for links till we reach the end of the page. So, the first thing we're going to talk about is how we extracted this procedure, and we're going to need to make a few changes to it, to make it work well in our "while" loop. We defined a procedure, "get_next_target"-- that takes the page as an input-- and essentially had exactly the code we have here-- except for, at the end, it would return both the URL and the value of "end_quote." And we had a quiz earlier where you determined that what "get_next_target" should do is return both the URL and the "end_quote"-- that is the position where the end of the quote was found. So, we needed this procedure to return two values because we need to know both the URL, as a string, and where to continue looking for the next target. We haven't yet used a procedure that reutrns two things, but it's actually quite convenient and simple to do this. We can do this by just having two values on the left side of an assignment statement This works in general; so we can do-- instead of our simple assignment rule, where we had a name, followed by an equal, followed by an expression, and that would assign the value of the expression to "name"-- we can have multiple names on the left side, and multiple expressions on the right side. So, we can do multiple assignment, where we have any number of names, separated by commas, an equal sign, and then any number of expressions, also separated by commas. As long as the number of names and the number of expressions match, what happens is the value of the first expression is assigned to the first name-- so this name [indicating ] will now refer to whatever this value was-- [indicating ] the value of the second expression is assigned to the second name. As an example, if we had "a, b = 1, 2", this would assign to "a" the value "1," and to "b" the value "2." In order to get the two values returned by this procedure, what we need is to have two variables on the left side and the procedure call on the right. The syntax we'll use is just the URL [url]-- we'll use that as the variable to hold the URL; and "endpos"-- we'll use that as the variable to hold the end position; and, then, on the right side, we have "get_next_target" passing in "page." Since this returns two values, it's like listing two expressions: the first value returned will be assigned to "url," the second value returned will be assigned to "endpos." Being able to have multiple variables on the left side of an assignment is very useful. Let's have a quiz to see an example of "why." This quiz is going to require a little bit of guess work, for how a multiple assignment works. I think you'll be able to bet the right answer. You can also try experiments in the Python interpreter. The question is for any variable--so let's assume s and t are names, and they've been assigned some value, and now we execute the statement s, t assign t, s. What does that do? The choices are nothing--after the assignment s and t both have the same value as they did before. That it makes both s and t refer to what the original value of t was before this statement. That it swaps the values of s and t so after the statement, s now has the previous value of t and t has the previous value of s. Or it's an error. [ Quiz: What does s, t = t, s do? ] So, the answer is, it actually swaps the value of "s" and "t." This is quite convenient, and the important reason for that is both the values on the right side get evaluated first-- to get turned into their values-- before we do any of the assignments. So, what's going on: "s" refers to some value-- let's call that "alpha"-- and "t" refers to some value-- we'll call that "beta." This is before the assignments. To evaluate the multiple assignment expression, we find the value of "t" here [indicating the second "t" in the expression]-- that has the value of "beta"-- and we find the value of "s"-- and "s" has the value of "alpha." We've evaluated both of these, and we've turned them into the values the names refer to; and, now we do the assignments. So, "s" will be changed to refer to the first value-- which is "beta" Ã¢Â€Â“ and "t" will be changed to refer to the second value. This has very different behavior than if we did two assignments like this; so, if we tried, instead, doing "assign t to s," and then "assign s to t," that wouldn't swap the values, because, by the time we do the second assignment, the value of "s" has changed-- now it refers to whatever the value of "t" was. If we had done these two statements {indicating "s = t" and "t = s"], both of them would end up having the value "beta." [Dave] Now we have our get_next_target procedure, and we know how to use it by using multiple assignment to get the 2 results. There's 1 serious problem with the get_next_target procedure that we have to fix before we go on to the problem of outputting all of the links in the page. The problem is we didn't really think very carefully about what should happen if the input does not have another link. Let's try and see what actually happens the way we've defined it. Here's the code we have for get_next_target, and we're going to try an example. First we'll try an example where there is a link, so what we should get as the next target when this is the page that's passed in is the link that's included, which is between the double quotes inside the a href tag. When we run that, we get our 2 outputs. We got the string that's the link, and we got 37, which is the position of the end quote. And we can see it's printing out the 2 outputs as a tuple, meaning the first one, the second one surrounded by parentheses, and we could get those in an assignment like this. Instead of just printing it, we'll use our double assignment, getting those outputs, and we'll print the value of just the URL. And we get the string http://udacity.com. That worked well. Now what happens if instead of passing in a page that actually has a link, we pass in something that doesn't. Let's say our page is just the text "good." Now, there's no link to find, but the code is going to run anyway, and what we see as the result is we actually got the result "goo." Probably not what we wanted, and the reason we got the result "goo" is you remember the find command, if it does not find what it's looking for, it returns -1. And when we use -1 as an index, that means the last character of the string. So what we end up with is getting all the characters except for the last character. If we pass in something else that does have a double quote in it, so now we'll pass in 'Not "good" at all!' we see what we get back for the URL is Not. This is not very useful. This is pretty confusing behavior. It's going to be very hard to tell when we've gotten to the last target because maybe Not could be a valid URL, and we don't know that. What we want to do is make get_next_target return something more useful in the case where the input does not contain any link, and the way we're going to do that we'll leave partly up to you. But I'll give you a hint to get started. We're going to want to change the code, and you're going to want to put something into the code here. If we found a link, well, we've got a value for start_link that's the position of the start link. If we didn't find a link, what we got back from find was -1, and I want you to change what the get_next_target procedure does, so when there's no link to find, what we should return is the value None. This is the special value that means there isn't anything. And we'll return 0 as the endpos. Let me write that out more precisely, but the hint is you're going to have to change the code after you've found the start_link to figure out whether there is a link to find. Your goal for this quiz is to modify the get_next_target procedure that we've defined so that if there is a link, it behaves exactly as it does now, still returns the URL of the link target, as well as the number of that position where the end quote is. But if there's no link in the input string, it should output None as the first output and 0 as the second output, and None is a special value that means it's not actually returning anything. So here's the solution So we want to add an "if" statement because we want to make a decision We want a test If the start_link is equal to -1 So that means that we did not find what we were looking for find returns to -1, so the value of start link is -1 Well, then we don't want to do the rest, we don't have an URL to look for What we want to do is return the special value "None" and zero So that's the change Now when we run this with this string that does not have a link what we get as the output for the url is "None" We can't tell that's not a string, the way it prints out, but it's different from a string and one thing that we can do with "None" is sort of like "False" So if the value of the test expression in an "if" is "None" that's treated the same way as "False" So if url returned here is "None", then we'll print "Not here!" I guess that means we are here, but we are not "Here!" So here's what we get, we see that we got "Not here!" when we passed in a string that did not contain a link tag if we go back to the string that has a link tag and now we run the code, we'll see that the url was some string that's treated as "True" and we get the print "Here!" So the test condition for a boolean doesn't necessarily have to be just "True" or "False" Python will interpret different values as "True" and "False" and the important thing here is that any string value other than empty string is treated as "True" and we'll go through this part of the "if" The value "None" is treated as "False" and we will go to the else So now we've modified our get_next_target procedure, and it will return None as the first output if there's no next target. Otherwise it will return the URL and the end_quote. And now all we have to do is figure out how to keep going. Let's look at what we were doing before. We turned these 4 lines into our procedure so now we can--instead of having all this code, we're going to call the get_next_target and assign the results. Now we've got the value of URL, which we do on a print out, so we're still going to print that out as before. And we still want to update the value of page, but we don't want to use end_quote now. What we want to use is the value that was returned here, which we assigned to the variable endpos. And then, well, we're doing it all again. So, all of the code here is just another call to get_next_target, and similarly, this would be endpos instead of end_quote. And we want to keep going until we get to the end, so how do we decide when we've gotten to the end? Well, we got to the end when the URL that's returned is None. And when the call to get_next_target returns None for the URL, we know we're done. We've seen a way to keep going. That's a while loop. We've seen a way to do a test. We want to test the URL. And we have everything we need now to print all the links on the page. I'm going to give you a start for how to write this procedure, and then you're going to finish it. What we're going to do is define a procedure that will print all the links on the page, and it takes the page as input, and so we want to use a while loop to keep going, and I am going to leave blank the test condition for the while loop. We'll leave that as something for you to figure out. In the body of the while loop, what we're going to call get_next_target, assigning URL and endpos to the result. This is just like what we were doing in the example code. Now what we need to do is check whether we got a valid URL, so what we were doing here, we assumed that we always got a valid URL, and we printed it out, and we kept going, but we need to do something to test whether the URL that we got back is None. That's what we'll do. We have if URL, and if that's true, that means we found a valid URL. We didn't get the value None as the result from get_next_target. And so we want to print that out as we were doing before. We'll print the URL, and we'll advance the page to the next position. If we didn't get a valid URL, that means that get_next_target did not find a link. There were no more links on the page, and we need to do something else, and I will leave blank what we need to do here. So, this is all we need for the code to print_all_links. There are 2 parts left for you to do as the quiz here. See if you can figure out what should go as the test condition for the while and in the block for the else. And if that's correct, you'll be able to print all the links on the page. So here's the code that we need to finish. We need a test condition for the while, and in this case we really want to keep on going forever until we're done. So, we're going to use while True and then use break to stop the loop. The test condition is true, and the way we know when we're done is when the value returned as the URL was none. That means we got to the else, so to finish, we need to finish the else block by using break. Now let's test our code. We'll call print_all_links with our test string that has test 1, test 2, and test 3 as the 3 links. And when we run this, what we see is it prints out the 3 links, test 1, test 2, and test 3. We'll try a more interesting test. For a more interesting example, let's go back to the web page we looked at earlier. This was the page with the flying Python comic. And it has many links in it, and we saw when we did view source we can see what those links look like, so the first link that we see on the page. So if we use Command-F [or Ctrl-F], we can search for the first link on the page. We see that we have these links. The first one is the link to Archive, and that corresponds to what we see here at the top of the page. Here's the link to Archive, the link to Blag, the link to the Store and About and Forums. And so there's a lot of links on this page. If we go back to our print_all_links code, we can try to print them all. First, let's look at what we actually see when we do get_page passing in the URL of xkcd.com/353, which is the page we were looking at. And when we run this, we see a lot of text printed out, and that's exactly what we saw from view source, but now that's what we're getting as the result from get_page. That's the text of the web page. Not very easy to look at. Instead of using get_page, we'll print all the links on the page instead of just printing the whole page out. Now we're using our print_all_links procedure to print all the links in the xkcd page. And when we run this, we indeed see all the links on the page. At least we see most of them. There are a few that we missed, and we'll talk about that in a later unit, but we're seeing many of the links on the page, including the first ones that we saw with the Archive and the Blag and the Store link, and we're seeing lots of other links. And you can see that we go all the way to the Buttercup Festival link and the license link. Those are the 2 at the bottom of the page. This is the link to license, which was the last one that we printed out. So, congratulations are in order. You've made it to the end of Unit 2, and I hope you understand the main concepts that we've seen so far. In Unit 1 we saw variables. We learned about programs. We saw how to do arithmetic. In Unit 2 we learned about making procedures, and we learned how to use if to make decisions, and we saw that those by themselves were enough to do every possible computer program as Alan Turing showed in the 1930s. We also learned about while loops, a way to make it more convenient to do things over again. And now we've actually got a really good start on our search engine. We can print all the links on the page. We still don't have our web crawler. We need to actually collect those links and do something with them. That's what we're going to do in Unit 3, and then in Unit 4, 5, and 6, we'll see how to use the corpus that we've built to do useful web searches, but we've come a long way, and I hope we'll see you back soon for Unit 3. For the first question, we're going to see that you understand procedures. Your goal is to define a procedure--called "udacify"--that takes as input a string and outputs a string that is an uppercase "U" followed by the input string. Here's an example. If you print the result of calling the udacify procedure that you defined, passing in "dacians" as a string, the output should be the string "Udacians" with a capital "U." See if you can define the procedure "udacify." As the problem states, we need to define this procedure. In Python it's really simple. We just use "def." Then the name of procedure, which is supposed to be called "udacify," and the parameters that it takes in. We'll take in 1 parameter, and we'll call it "s." Don't forget the colon. Now we want to return the result, which is the concatenation of the uppercase U plus the string that's passed into it. If we give it "dacians," it'll be called "s" when we're executing this. We'll add "U" to the front, and we'll return "Udacians." Question 2 tests that you understand procedures as well as the if construct. The question is "Which of the following have exactly the same behavior as the procedure below?" For two procedures to have exactly the same behavior, that means that no matter what the inputs are, the caller couldn't tell the difference between the two procedures, so it produces the same output. They both have the same side effects. In this case, we've defined a procedure here. It uses the procedure "test"--we haven't shown you how test is defined. You should assume that test is a procedure that takes a number as its input and outputs a Boolean. But you shouldn't assume anything else about test. Your goal is no matter what the procedure test does to figure out if the choice has exactly the same behavior as the procedure showing here. Here are the choices--check all the choices that have that have the same behavior as the procedure defined here. In order to solve this problem, you need to have a good understanding of what the original function, proc, does. So let's take the two cases that really embody the output of this function. There are 2 inputs, but the output only depends on the value of A. Specifically, the value of the function test on a. If test(a) is true, then we return the second parameter b. If test(a) is false, we return the first parameter a. That's what we need to check in each of these functions. Let's start looking at them. In proc1, if test(x), which is the first parameter is true we return y. This matches with the original function. If test of the fist parameter is true, we return the second, as we do in proc1. If test of the first parameter is false, we return that parameter x. Test x is false, which is equivalent to test a is false, and in both cases we return a and x, which are just different names for the same variable in this function. This is equivalent. Let's look at this second function--proc2. Notice here that this condition is based on the value of b. We know this can't possibly be equivalent to proc, our original function, because the output here is not dependent on the value of b. We can tell right away that this is false. This is not equivalent to our original function. Let's look at proc3. The structure here is a little different, but let's work our way through it both examples. In the event that test(a) is true, we set result to b and re-return result. As our original function did, if test(a) is true, we return b. If test(a) is false, we simply return result, which was set at the beginning to a. So the overall functionality is that if test(a) is true, we return a. This matches with our original function definition. So this is equivalent to proc. Now we have the last function--proc4. It might throw you off that you see 'udacity' in quotes here, which is not present in any other function, but it's important we work our way through the problem. If test(a) is true, then not test(a) is false. We return b. If test(a) is true, we return b. That matches with the original definition. If test(a) is false, not test(a) is true, so we set b to 'udacity,' but then we return a. If test(a) is false, we change the value of b, but we don't do anything with it--we just return a. The result is the same as our original function proc. For question 3, your goal is to define a procedure called median, that takes three numbers as its inputs, and outputs the median, which is the middle value, of those three numbers. Here are a few examples-- If the three inputs are 1, 2, and 3-- your procedure should output 2-- if the three inputs are 9, 3, and 6-- your output should be 6, since 3 is lower than 6-- but 6 is lower than 9-- and if the three inputs are 7, 8, and 7-- well, then the median is 7. This is a pretty tough question, so I am going to give it 1 gold star. One way to solve this problem, is to look at the possibilities. We know that there is a bigger number, the median, and a smaller number. And that we have 3 inputs-- Let's call them "a," "b," and "c." Let's say, for the sake of example-- that we figure out that "b" is the bigger number. We could solve this using the bigger function that you defined in lecture. >From here, we only need to figure out what is the median and the smaller number. We know "b" can't be the median, because we just decided that it was the bigger number. >From here, all we have to do is compare "a" and "c." There are two cases at this point. One is where "a" is greater than "c." If "a" is greater than "c," we know "c" is the smaller number-- and "a" is the median. If "c" is greater than "a," we know that "a" is the smaller number-- and "c" is the median. We can use this strategy to solve every possible case when defining our function. So let's take a crack at it by going right to the interpreter. So, first let's define our function. As specified in the problem, it's called median--and we take in 3 parameters. As I did before, we are going to call them "a," "b," and "c." As I described earlier, we want to find the biggest number first, let's call it "big." Here's the perfect time to use the function that we defined in class, "biggest." "Biggest" will give us the biggest number, as the name describes-- by simply passing in those 3 parameters. >From here, we enumerate the possible cases. As I described earlier, if "a" is the biggest number, you want to return the bigger number of "b" and "c." If "b" is the biggest number, we want to return the bigger number of "a" and "c." And lastly, if "c" is the biggest number, which is satisfied by the else here, we want to return the bigger number of "a" and "b." This question tests that you understand loops. Your goal is to define a procedure called countdown, that takes a positive whole number as its input, and it prints out a countdown from that number down to 1, followed by "Blastoff!" Here is an example-- If we call countdown passing in 3-- your procedure should output 3--2--1--Blastoff! In this problem, we are told to define a function called countdown. Countdown takes one parameter--the number that it countdowns from-- let's call it "n." Don't forget the colon. The goal here is to countdown from "n" all the way down to blastoff. This sounds like something that is going to need a while loop. Let's get started. Let's leave the condition blank for now-- because we already know what we need to do inside the while loop, and that is, print the number. We also know at the end, that we want to blastoff. So we have two things to fill in. One, how long we countdown for? Lastly, what do we do after every count? If we look at the sample, the last time that we count is when n=1. So, one way to do that is saying while "n" is greater than zero. Every time we countdown, we subtract 1 from "n"--so let's do that-- and all together, this will produce the outcome as expected. Question 5 is a trickier question about loops. For each of the loops shown below, your goal is to determine whether or not the loop always finishes no matter what positive value is initially assigned to "n." So, for each of the 3 loops, and you can see the loop code shown below, your goal is to determine that no matter what value is initially assigned to "n" -- whether the loop always finishes-- that would mean for any possible value "n" is initialized as-- as long as it is a positive integer-- the loop will eventually finish. The second option is that the loop sometimes runs forever, that there's some value that could be assigned to "n" that makes the loop run forever--that it never finishes. And the third choice, is that it is unknown--and that doesn't mean that it is unknown to you-- that means that it is unknown to anyone in the known universe. Whether that loop will always finish for all initial values of "n." Here's our first loop. Let's think about what we know-- "n" is any positive integer and "i" is zero. What we do know, that "i" is less than "n" because zero is less than any positive integer. This loop runs while "i" is less than equal to "n." In every iteration, "i" increases by 1. We know intuitively that eventually "i" will become greater than "n" because "n" is fixed. So, we can say definitively, that this loop always finishes. Like the previous loop, let's look at what we have. We have a positive integer-- "n"-- "i"--which starts at 1-- and here a while true loop. It will continue forever until we trigger the break. So, let's look at the inside-- "i" at every iteration, doubles-- and "n" at every iteration increases by 1. The point at which we break is when "i" becomes greater than "n." One way to think about "i" is that it is an exponential function. At every iteration it doubles in size-- "n" is linear--every iteration increases by 1. We know "i" starts at 1, but every time it doubles-- "n," however, can start at any positive integer. It can be anywhere on here. But we do know, that it increases very slowly. In fact, it's guaranteed that eventually "i" will surpass "n." I will leave the mathematical proof to you, but you can take my word for it for now. Considering that eventually "i" is going to be greater than "n," we know that we will eventually break. Which proves that loop 2 always finishes. So, let's look at this last loop. It's pretty simple code. We're given an integer "n," which is any positive integer. While that integer is not equal to 1-- if it's even-- we divide by 2, otherwise we multiply by 3 and add 1. This is pretty simple, however, in order to figure out whether this loop terminates, you have to solve an open mathematical problem. You have to determine whether or not the Collatz conjecture is true. The Collatz conjecture states that given any positive integer "n"-- this code will terminate. It's an open mathematical problem. And no one has solved it. This is just an example of why a really simple loop like this is really hard to determine whether or not it terminates. As mentioned in the lecture, it's actually impossible for a computer to solve this problem in general. The correct answer, this is unknown to anyone in the known universe. So for this question, your goal is to define a procedure, named "find_last," that takes as input 2 strings. The first string is a search string; the second string is the target string. And it outputs the last position in the search string where the target string appears, as long as it appears at least once. If it doesn't appear at all, then the output should be -1. This problem asks you to define a function called "find_last" that takes in 2 parameters: one string that we're searching in, another string that we're finding. The whole point of this function is to find the position of the last occurrence of "t". So let's use a variable called "last_pos". The overall plan here is while we keep finding occurrences of "t", we're going to keep running the "find" function and updating our offset. So let's do that: "while True:"-- and since we don't know when we want to terminate yet, we're going to update a position using the "find" function, where we're searching for "t", but we're starting at the last position, plus 1. The "+1" is important so that we don't keep finding the same string over and over again. If this returns "-1", that means we didn't find another occurrence of "t". So we want to return the previous refound occurrence, which we stored in "last_pos". Otherwise, we want to update "last_pos" with the position that we just found. So the one thing left is: what do we initialize "last_pos" to? If we never find any occurrence of "t" in "s", the goal is to return "-1". So if "position" equals negative 1 in the first iteration, we're just going to return "last_pos". So it makes sense to initialize it to "-1". Welcome to office hours for Unit 2. We'll get started right away with questions. Let's start with Catherine from New Hampshire. She says, "I believe there were at least one or two instances where I gave up in frustration and viewed a solution before getting a correct answer in a unit quiz." She wants to know, what do the unit quizzes mean? Should she be concerned if she gets it right? Should she be frustrated if she's getting them wrong? I hope people aren't frustrated on the unit quizzes. The quizzes in the units are really there to help keep you engaged-- to help you learn. If you can't get the answer, that's okay that we do have answers recorded after them. You're not being graded on the quizzes. They are really there to help you learn. Some of the quizzes are harder than others. One of the things that we do on the quizzes is rate them with gold stars. Don't be surprised if you're not necessarily able to handle those with gold stars. Those are questions that will require a lot of thought. Those are going to be really hard, especially for beginning students. Those are questions that--I hope by thinking about them--you'll be able to solve yourself. If you're not able to solve it yourself, don't get frustrated. You can watch the answer--hopefully you'll understand the answer-- and then maybe you'll be able to try it on your own again after you've seen the answer. The quizzes don't count towards your grade. You shouldn't be frustrated or stressed about that. They are really there to help you learn. Our next question from student, MTRTMK, from Pakistan. This student asks, "What are some good programming practices, and how important is it to follow programming practices used by professionals--things related to like naming variables, commenting the code, being consistent with the structure--things like that?" So this is a great question. There are definitely many things that people learn as they get more experienced in programming. We're focused, in this class, on learning the basic concepts-- on getting you able to write and understand short programs. I'm trying to use good practices in most of the programs and, hopefully, those will come across. But people have different opinions about the right way to code things. Some opinions are better than others. I think, in most cases, the opinions that I have are reasonably good ones. Most cases--not always. Most of the time--we hope. And you'll develop your own style. You'll develop your own experience as you get more experience as a programmer--how you like to do things-- but there are conventions that it's useful to follow, and part of the reason it's useful to follow conventions is you want it so other programmers can understand your code. And things like using lower case names-- using lower cased letters at the start of a variable name are just conventions, and that's used to distinguish variable names from other things you might see in a program. There's no really good reason for that, but that's a convention that most programmers follow, and it's good for you to follow it too so if other people need to read your code they'll be able to the code as well. Anesh, from India, asks: What are some of the aspects that go into building a practical Real World search engine and how should you use existing tools, such as preexisting libraries, to help build your search engine? So one example he gives in his post, which has a lot of great deal in there--and I encourage people to look at it-- is Beautiful Soup, which is a Python library to parse really complicated HTML. So in our web crawler, we just parse very strict, kind of string match, and it doesn't always follow that rule so Beautiful Soup can help with that. Should we be aware of these libraries, and how should we include them? Yeah--so there's a lot of things that are more complicated if you want to build a robust search engine that's going to work on all the pages out there on the Web. And Anesh has a good list of some of the things that you need to think about, and for the advanced students that are wanting to go beyond what we're doing in class, it's great to start thinking about those things. And it is also the case that you don't want to build everything yourself. In this class, we're building things ourselves because we want to learn what's going on underneath and build as much and understand as much about computing as we can. If you're building Real software, you want to try to start from libraries that other people have already written that are available for you to use and Beautiful Soup is a very useful library for parsing HTML-- for doing the kinds of things that get real complicated, if you want to find links in Real HTML code that can be much more complex than what we're focusing on so far. It's still using the same kinds of ideas that we do in the class, but someone else has put a lot of effort into writing that code and making it work, and it's definitely a good idea to reuse libraries that are available. You have to check, carefully, what the license is on those libraries-- whether you can use them or not. But it's definitely--when you start building more complex programs, rather than starting from scratch and writing everything yourself, trying to find a library that will help you get what you need done more quickly is a great idea. Vasco, from Portugal, asks: In a world where we already have Google and other search engines, what are the advantages of building another search engine? So certainly, you don't want to try to duplicate something that behaves exactly like Google does, because Google works pretty well at what it does. But there are lots of things you can do that would be different from what Google does. One of the best examples of that is the search engine called DuckDuckGo, and we had a visit from Gabriel Weinberg a few weeks ago. There's a video, with a few clips from that visit, where he talks about what motivated him to build DuckDuckGo. There''ll be a few more clips of that later in this course where you'll get some idea of the kinds of things that he thought were interesting to make a new search engine, and why he was motivated to build one. But there are lots of things that you can think about that would be new features that are different from what Google does-- or specializing your search engine for a particular kind of corpus that you're searching for. Probably, you don't want to try to build a generic Web search engine, like Google, unless you've got some ideas how to go beyond that or to do things differently, that would be more interesting. Welcome back for Unit 3. This unit introduces the next big idea we need for a web crawler, which is structured data. And by the end of this unit you will have finished building a working web crawler. The closest thing we've seen so far to structured data is the string data type introduced in Unit 1 and used in many of the procedures in Unit 2. A string is a kind of structured data, and that's because we can break it down into its characters. The string has a sequence of characters, and we can operate on sub sequences of the string. What we could do with strings was somewhat limited, though, because the only thing we can put in a string is a character. Today, we're going to introduce the list data type, and lists are much more powerful than strings, so whereas for a string, all of the elements had to be characters, in a list, the elements can be anything we want. They could be characters. They could be strings. They could be numbers. They could also be other lists. Let's look at an example. When we created a string, we just put a sequence of characters surrounded by either single or double quotes. Here's an example of a string, and we could store that string in a variable by using an assignment. With a list, instead of using quotes to identify the list we use square brackets, and the elements are separated by commas. And just like with a string, we can assign the list that we created to a variable, so we'll store that list in the variable "p." With a string, we could use the square brackets to select elements, and when we index element 0, we'll get the first element of the string, a sequence of that character, which is the character "y." With lists, we can also use square brackets to access elements, so if we do p[0], that will evaluate to the first element of p, which is the string containing the single letter y. With strings, we saw that we could use the colon inside the square brackets to select a sub string of more than 1 character. Here we're selecting from position 2 through position 4. That will give us the third and fourth characters of the string, which is the sub sequence, the string "bb." We can do the same thing with lists. We can select from position 2 to position 4, but instead of returning a string, it will return a list containing those elements. It will give us a list of the third and fourth element of the variable p, which is the list that we have here. The general grammar for constructing a list is to have a square bracket followed by a list of any number of expressions where the expressions are separated by commas. We could create a list using just 2 brackets, a left bracket and a right bracket, and this would create a list containing 0 elements, also known as the empty list. We could create a list containing 1 element. That would be the square brackets with 1 element between them. Here we've created a list containing just 1 element, which is the number 3. Or we could create a list with many elements, as we did in the first example, where we have all of the strings separated by commas. So now it's time for a quiz to see how well you understand lists. Your goal is to define a variable with the name "stooges" whose value is a list of the names of the Three Stooges. If you're rusty on who the Three Stooges were, the names of the Three Stooges were Moe, Larry, and Curly. And remember that a list is ordered, so it's important that those values are in the list in the correct order, which is Moe first, Larry second, and Curly third. So to answer this, we need to create a list, and to create a list, we use the square bracket and put the elements that we want in the list between the brackets, separated by commas. In this case, we have the elements the string Moe, the string Larry, and the string Curly. To store that in a variable, we need an assignment statement. Now I know some of you are worried that in some of the Three Stooges movies, Shemp replaced Curly, and we'll see that we can actually do that with lists, but we'll get to that a little bit later. Let's try this in the Python interpreter. And we can click "Run" to see the value of stooges as we've defined it. It is a list containing those 3 strings. For this quiz, the goal is to see that you understand lists and can define a procedure that uses them. You'll be given a variable, daysinmonth, which is initialized to a list containing 12 entries where each entry is the number of days in the corresponding month, so January has 31 days, so that's why we have 31 here. February--at least in a non-leap year--has 28 days. March has 31, and so on up to December that has 31 days. Your goal is to define a procedure called howmanydays-- with underscores between the words-- that takes as input a number representing a month and outputs the number of days in that month, and we should use the conventional way of numbering the months, so here's a few examples. If we call howmanydays, passing in 1, meaning the month January, the output should be 31 since there are 31 days in January, and that corresponds to the entry in the zeroth position of daysinmonth. If we call howmanydays, passing in 9, that's September. We should get 30. So here's one way to define how many days. We have our initial definition of daysinmonth. We're going to define a procedure, howmanydays. And it takes one number's input. We'll call that the month. And what we want to do is return the number of days in that month. We can find that by indexing into the daysinmonth list, and we want the element that corresponds to the month that was passed in. That isn't the element of the month directly because elements in the list start from 0, months start from 1. We need to subtract 1 from month to get the correct element. Let's try that. We'll print the number of days in month 1, which is January. And we run, and we get 31. Let's try month 9, which is September, and we run and get 3. What happens if we pass in, say, a number that's not a valid month? Let's say we pass in 13. Now we run this, and what we get is an error, and you can see what the error is. It's complaining that the list index is out of range. That means we've tried to find an element in a list that doesn't exist, and we did it exactly at this point where we're returning daysinmonth of month - 1, and the value of month was 13. There's no element at position 12 because daysinmonth only has 12 elements. So all the examples we've seen so far, all of the elements in the list had the same type. We had a list where all the elements were strings. We had a list where all the elements were numbers. There's no restriction on lists, though. We can make all of the elements any type we want. We can mix and match different things in 1 list, so here's an example. We've put some strings and some numbers together in 1 list. That's perfectly okay. Where it gets even more interesting is we can have a list inside a list. Now one of the elements of "mixed up" is itself a list, and we can have another list inside that. Here we've defined a new variable, mixed up. It contains a string, a number, a string, a number, and then a list. The fifth element is itself a list that contains a number, a number, and contains another list. This example shows the versatility of lists, that we can put anything we want in them. It doesn't seem particularly useful because there's no structure to the things we've put in the list. So let's try another example that may give a better idea of why it's so useful to be able to have lists inside lists. Before we defined the variable "beatles" as a list of 4 strings, just the names of the Beatles. Now we've defined the variable beatles as a list of lists where each element of the list is a list of the name of the person as well as the date when he was born. We have the first element in our list as John, who was born in 1940. Let's see how that works in the Python interpreter. When we start to have long lists, especially lists of lists like this, they might not all fit on 1 line. It's okay to divide things into 2 lines, but we have to be a little careful where we do the division to make it clear to the Python interpreter that it's all part of 1 list. The place where you want to do the separation is after a comma, and if you indent things in a way that makes that clear, then you can see the structure, that these 2 lines are still part of the same list, and it's the closed bracket here that closes the list. Now let's try printing that out, and we see the list containing 4 elements. Each element itself is a list containing 2 elements. We can print just 1 of the elements. We'll print the element at position 3, which is actually the fourth element of the list. We see that element itself is a pair. That's a list. So if we want to get just the name from that, well, then we need to use index again, so we can use index again to get the 0 position element of that list, and that will give us just the name. If we used index 1 here, that will give us the year. So now we're ready for a quiz to see if you understand nested lists. For this quiz, you're given a variable named "countries," and it's defined with a list of information about some of my favorite countries. And for each country, there's a list containing 3 things: the name of the country, the capital, and its population in millions. I should point out, of course, for those of you in Romania or in smaller countries, that when it comes to countries, bigger is not always better. First, try to write code that will print out the capital of India. We can find India as the second country in our countries list. And the capital is the second element of that list. You obviously could solve this by just printing out "Delhi." I don't want you to solve it that way. I want you to solve it by finding an expression that uses the countries variable to find the right value. So the answer is we need to find the second element of countries, so that's this element. Remember that lists are indexed starting from 0, so to find the entry corresponding to India, we need to find the entry at position 1. The result of countries[1] will be the element of countries at that position, which is the list containing 3 elements, the string India, the string Delhi, and the value 1210, which is the population of 1.2 billion people. To select the capital, that's the second element of that list, so we use index 1 again to get that element, and the value of countries[1][1] will be Delhi. And then we can just use print to print that out. Let's try that in the interpreter. So, running countries[1] will give us the element of countries that corresponds to India. And then to get the capital, we select element 1 from that. So for the second part of this quiz, the question is what multiple of Romania's population is the population of China? To solve this, you need to divide the population of China, which you can extract from the countries variable, by the population of Romania, which you can also extract from the countries variable. To get the entry for China, we need to select the first element of countries that's indexed at position 0. To get the population, well, that's the third element of that list, so that's the entry at position 2. To compute the multiple, we need to divide that by the same value for the entry for Romania, and when we run this, we see that the population of China is approximately 64 times the population of Romania, and I should point out that this is integer division, so this is not the exact result. If we looked at actually multiplying 21 by 64, the result that we get is 1344, so 1 billion 344 million. But the population that we get for China was 1 billion 350 million. If we wanted a more exact answer, we need to use floating point division. We could do that by changing the values in our list to make one a floating point number. Adding a decimal point would be enough. Now when we run it, we get a more precise answer. Of course, these populations are just estimates, so the answer of 64 would probably be a better answer to the actual question. So I said there were 2 main differences between strings and lists. The first we've seen already is that a list can hold anything we want, whereas a string, the elements could only be characters. The second big difference between lists and strings is that lists support mutation. Mutation sounds a little bit scary, and in some ways it is scary. It makes it much harder to understand what our programs mean, but it's also very powerful. What mutation means is we can change the value of a list after we've created it. To explain what that means and to see why it's so different from the behavior we can get with strings, let's recap what happens with strings. We can create a string. We can store it in a variable. We can change the value of the variable by creating a new string. So what's going on there, it's changing the value of s, but it's not changing the value of the string. When we did the first statement, this one, it created a string with the value "Hello," and it introduced a variable, s, which referred to that string. When we execute the second statement, that creates a new string with the value "Yello," and it changes s to refer to that new string. It hasn't changed the string that we created with the value Hello. We just don't have a way to refer to that any more. With strings, we can also use the + operator to concatenate 2 strings. It looks like this is changing the value of the string. You might think that the result of this is, well, now the string that was previously Yello spelled wrong is now Yellow spelled with the w added at the end. But that's not actually what happens. We don't actually modify the string we had. What happens when we use the + operator, it creates a completely new string where the value of the new string is the result of concatenating the 2 input strings. When we execute the third statement, first a new string with the value w is created. Then when we do the concatenation, it doesn't modify the previous string that we've created. It creates a whole new string which will have the value "Yellow" spelled with a w. And then the assignment changes what s refers to to refer to the new string. Now let's see what we can do with lists. We've created a list using the square brackets that contains 5 strings. Each one is a 1-letter string spelling out the word "Hello." And we've stored that in the variable p. We could do the same thing we did with strings. We could reassign p to a new value. And if we did that, that would create a new list containing the letters Y-E-L-L-O and assign that to the variable p. What we're going to do instead is mutate the list that we already created, and we can do that by modifying the value of its elements. Here we have an assignment where on the left side of the assignment we have p[0]. This means select from the list that p refers to. Find position 0. Instead of getting the value at that position, though, since it's on the left side of an assignment now, we're going to replace that value with what's on the right side of the assignment, in this case, the string containing the single letter y. Let's see what that looks like. When we created the list initially, we had a list like this, and I'm going to draw the list showing boxes. This is a list. Each box is 1 element of the list, and after the initial assignment, the value p refers to is this list. Now when we do the assignment where p[0] is on the left side, well, p[0] will find this position. The assignment will replace what's there. So, replace the H with the Y. Note that we did not create a new list. P still refers to the same list. We didn't have to change the arrow. But we've changed the value of that list. Let's try this in the Python interpreter. I've created a list with the elements being 5 strings spelling out the word "Hello." And I can see that that's the value of p. Now I'm going to use the assignment expression to replace the value in the first element and print p again. Now when we run, we see that for the first print the value of p is Hello. For the second print, the value of p is Yellow. We can change other values the same way, so now we've changed the value in position 4 to an exclamation point, and we can see the third line printed out. We have "Yell!" So now it's time for the first quiz about mutation. In a previous quiz, we defined the variable stooges to hold 3 strings, strings Moe, Larry and Curly. But in some of the Stooges films, Curly was replaced by Shemp, so your goal for this quiz is to write 1 line of code that changes the value of stooges to be the list containing 3 strings, Moe, Larry, and Shemp, but doesn't create any new list object. The answer is we can do this using mutation. We just need one assignment that replaces the value in position 2 of stooges with the string "Shemp." So far I've told you that mutation modifies the existing object. But you can't really see the difference from what we've done with strings. Where we'll really see the difference is when we introduce a new variable. Let's go back to the example we had before, and now we're going to add an extra assignment statement, and we'll introduce a new variable. Suppose we introduce the variable "q." And we assign p to q, and that means the value of p, which is the object that's this list, is now what q will refer to. The important thing here is after the assignment, p and q refer to the same list. Suppose we did an assignment statement to modify the value of one of the elements of q. Well, that will change element 4 of q, so this is element 4 of q. It will change that value to the new exclamation point. It also changed the value of p. Even though the assignment statement didn't include p, the fact that p and q refer to the same object means that it changed the value of p. To show you that things are different with strings, let's try that with a string. See if you can guess what happens when we try to use assignment to replace the first letter in the string. Let's run it to see what happens. And what we get is an error, and we get an error because the string is not mutable. There's no way to change the value of the string, and the error says there's no way to do assignment in a string, that that type of object, because it's immutable, does not support assignment. A key difference between mutable objects and immutable objects is once an object is mutable, then we have to worry about other variables that might refer to the same object. We can change the value of that object, and it affects not just the variable that we think we changed, it affects the value of other variables as well. Let's see an example of that. I've initialized p to the list containing the strings "Hello." Now I have an assignment that introduces the new variable q and assigns p to that variable. And we'll print out the values of p and q, and we'll see that both p and q contain the string Hello. But now let's change the value at position 0. Now we have an assignment that stores in the value at position 0 of p the letter y. This changes the value of p. What may be more surprising is this also changes the value of q. Even though we didn't use q in the assignment, it changed the value of q because q refers to the same object as p. When we have 2 different ways to refer to the same object, that's called aliasing. Aliasing in programs is similar to the way we think about aliasing in Spycraft. You might not be able to tell from my drawing, but this is James Bond. And we can refer to James Bond either by his name, James Bond, or by his spy name, 007. Both of those are ways to refer to the same person. If something happens that changes the state of James Bond, so instead of pleasantly enjoying a martini, like he is now, the bad guys are after him, and he grabs his gun and is no longer so happy, well, that affects the state of both James Bond and 007. Both names refer to the same person, so whatever state that person has is true for both names. Aliasing for variable names has the same property, so if we have 2 variable names that refer to the same object, any change we make to the object p refers to also affects the value that q refers to. If we did an assignment using p to change the value in the second position on p, that also changes the value the name q refers to. If we do an assignment like this where instead of changing the value of one of the cells that's part of the p object, we assign p to a new value, well, this assignment we create a new object, a list containing 3 elements, the numbers 007. And it will change what the variable p refers to to point to that new object. The value of q is the same as it was before. It still points to the same object, which we haven't modified. [Narrator] So, now we're ready for a quiz about aliasing. The question is what is the value of agent index 2 after the following code runs? And we have 3 assignment statements. The first assignment statement creates the list 0, 0, 7, and assigns that to the variable named spy. The second assignment assigns spy to the variable named agent, and then the third assignment assigns agent index 2 +1 to the position at spy index 2. So what's the value of agent 2 after all of this code? [Narrator] The answer is 8. Let's try this in the Python interpreter to see why. These are the first 2 assignments, and after these assignments we can see that agent has the same value as spy. Both spy and agent have the value a list containing 3 elements. The element values are 0, 0, 7, and they're actually the same list object because both agent and spy refer to that same list that we created in the first assignment. This means the value in agent position 2 is the number 7. When we do the third assignment we're assigning into position 2 of spy the value at position 2 of agent plus 1. The value at position 2 of agent is 7, add 1 to that we get 8, and we put that in position 2 of spy. Since agent and spy refer to the same object that changes the value of both spy and agent, and we can see that both agent and spy now contain the value 8, and position 2. [Narrator] For this quiz your goal is to define a procedure named replace_spy that takes as its input a list of 3 numbers and modifies the value of the third element in input list to be 1 more than its previous value. To solve this quiz you're going to have to experiment and understand how values are past procedures in Python. Something we haven't talked about yet, but if you solve this quiz you'll have a good understanding of how things might work. The behavior that we want is shown in an example, so if the value of spy is the list 0, 0, 7, we call the procedure replace spy, passing in spy. Note that we're not using the result. We're not assigning this back into a variable spy. We're just calling replace spy, but after the call the value that spy refers to has changed. Now it has the value 0, 0, 8. So, I haven't yet told you what it means to pass a mutable object like a list to a procedure, but try to define replace spy and see if you can figure out what happens. [Narrator] Here's the answer: we can define a procedure named replace spy. It takes 1 parameter as its input. I'll call the parameter P. We could call it spy and that might be a more natural name for it here, but to avoid confusion with the variable spy, we're using in the example, I'll call it P. For the body of replace spy what we want to do is change the value in position 2 of the value past it. So, we can do that within an assignment statement. On the left side we're selecting the cell, and we're replacing it with a value that we get from the old value in that position plus 1. This has the behavior that we want, and to have a better understanding why let's see what happens when we pass a value to our procedure. Here's what we had before the call. We've initialized the variable spy to hold the list containing 3 elements that are numbers 0, 0, 7. Then we make the call to replace spy, passing in spy. What happens when we call a procedure the name of the variable in the procedure now refers to the object that's passed in. So, now the value of P of the parameter here refers to that object. Then we do the assignment. We replace the value in position 2 of P with it's previous value plus 1, so that changes this value to 8. The parameter P and the variable spy both refer to the same object, so that also changes the value of spy. Not that there's no return statement here. We don't need to return a new value. We've modified the value of the list that was passed in, and I want to emphasize that this is different from what's happened in other procedures. If you remember in an earlier exercise you defined the procedure INC. It takes 1 input, we'll call it N, and it adds 1 to that. If we remove the return statement from INC, it doesn't change the value that's passed in. It does nothing, and here's why: suppose we had code like this, we'll introduce a variable A, give it the value 3; we'll call INC on A. What happens here--well, the variable A that name refers to the value 3. When we passed that to INC--well, the same thing happens as happened when we passed the mutable list as parameter P to replace by. The name N now refers to the same value as A referred to, but we can't mutate that value. What happens inside INC is an assignment statement. We assign to N the value N +1, so that the changes the value N refers to. Now N refers to a value 4, but that doesn't change the value A refers to. A still has the value 3. So, we can see with numbers we can't mutate the value of a number. If we could everywhere the value 3 existed before--well, now it would mean 4. That would be pretty confusing. [Narrator] I hope you're getting a sense that lists are very powerful. That by using mutation, by having lists that could contain other lists or any other kind of data we want, we can build very complex data structures, and we can do lots of interesting things. I'm going to introduce 1 more list operation, which will allow us to add a new element at the end of the list. We've seen that we can use lists to store complex data, that elements of the list can be any type we want including other lists, and we've seen that we can use mutation to change the value of a list, and that mutation is visible through any reference to the same list object. Now I'm going to introduce some other list operations. The first one is append, and append is like a procedure but it's a method, so we use it similar to the way we use to find on strings. We'll have a list first, then a dot followed by append, and what we pass in is the element we want to append to the list. Append will add a new element to the end of a list, and the important thing about append is that it's mutating the list that its invoked on. It's not creating a new list; it's mutating the old list. As an example of the use of append let's assume that instead of replacing curly in the 3 stooges, we want to end up with 4 stooges. We'll add Shemp and add the other 3 as they are. So what we want to do is to append Shemp at the end of the list we have. We would do that by invoking append on the stooges, passing in the string Shemp as the input. Here's what happens after the first assignment, the name stooges refers to the list containing the 3 elements, Moe, Larry, and Curly. When we invoke append it modifies that object, adding a new element to it. After the append, the list that stooges refers to now has 4 elements. We have not created a new list. Note that there's no assignment from the result of append. What we've done is modify the value that stooges refers to by adding a new element to it. [Narrator] That's what append does. We're going to introduce 2 other list operations. The next one is plus. Plus behaves very similar to the concatenation operation for strings. If we have the list 0, 1 + the list 2, 3 the result is the list 0, 1, 2, 3. What plus does like concatenation for strings is it produces a new list. It doesn't mutate either of the input lists. I want to introduce 1 other operator that works on lists, and that's the len operator. Len is short for length, and we use len like this: it looks like a procedure call. We pass into len the object that we want to know the length of that can be a list. Len actually works for many things other than lists. It also works for strings. It works for any object that's a collection of things, and the output from len is the number of elements in the input. For example, the result of len applied to the list 0, 1 is 2, since there are 2 elements in the list. The result of applying len to this list is also 2. It looks like there are many more elements here, but len is only counting the outer elements. If 1 of the elements of a list is a list, it doesn't matter how many elements that list contains. It only contributes 1 to the length of the original list, so the result of this call would also be 2. We can also use len on a string, and the output will be the number of characters in the string. In this case the string Udacity has 7 characters, so the output is 7. Now we are ready for some quizzes to see how well you understand the 3 list operations we've introduced. The append operation which is invoked on a list and takes an element as a parameter and adds that element to the end of the list. The plus operator which operates on 2 lists as its operands and produces a new list that consists of all the elements in the 2 lists put together. And finally the len operator that takes a list as its input and produces an output number that is the length of the list. The number of elements in the input list. [Narrator] Now we're ready for our first quiz about append, plus, and len. The question is to answer what is the value of len of P-- --the length of P after running the following code? These are the 3 statements: the first one creates a list 1, 2 and assigns that to the variable P. Then we use append, passing in 3 as the value to append, invoking append on the variable P, and then we have an assignment that assigns the P the result of P + the list 4, 5. The question is after running those 3 statements, what is the value of len of P? [Narrator] The answer is 5. Let's step through each statement to see why. The first statement creates a new list. It's elements are 1 and 2, and makes the variable P refer to that list. The next statement evokes append on P, passing in the value 3. Append adds an element to the end of the list, so after this the value that P refers to will include 1 extra element with the value 3. The next statement uses the plus operator. The operands to the plus are P, which we already have, and the new list containing the elements 4 and 5, and remember what happens with plus; it doesn't mutate any of the inputs. It creates a new list that consists of all the elements concatenated together. That will be this 5-element list. We assign that to the variable P, so now P will no longer refer to the list 1, 2, 3. It will refer to this new list that has 5 elements, and at the end of this, the len of P is 5, since there are 5 elements in P. [Narrator] For this quiz we're asking for the value of the length of P after running these 3 statements. This is a little trickier than the previous quiz. Try to see if you can think about the answer and find it yourself. Of course it's okay if you want to run the code in the Python interpreter as well, but see if you can figure out the answer without doing that. [Narrator] The answer for this one may be a little surprising. The answer is 3, here's why: the first statement creates the list with the elements 1, 2, and P refers to that list. The second statement creates the list with the elements 3, 4 and assigns that to the variable Q: The third statement appends a new element on the list P. That element is the list with 2 elements, but what actually happens is not adding 2 elements to P. What happens with append is we're just appending 1 new element. That element happens to be a list. The way this looks is we have a new element in P. The value of that element is actually the list object that Q refers to. That's why the length of P is 3. Let's try this in the Python interpreter. Here we see the list that's created. We can see that the length of that list is 3. What do you think will happen if we try an assignment like this? We're replacing the element at position 1 of Q with the value 5. Does that change the value of P? It does, and if you remember the picture we drew, it's not surprising that it does. Remember that the object we had created, the third element of P, is actually a reference to this object containing the elements 3, 4, which is the same list object that Q references. When we change the value in position 1 of Q that also changes the value of P. [Narrator] Now you understand a little about how to use a complex data structure like a list. I'm going to talk some about how computers actually store data. To use a list you don't really need to understand this, but it will certainly give you a better appreciation of what's going on inside the computer. In order to store data you need 2 things: you need something that preserves state and can be in more than 1 state, 2 states is enough, and you need something that can read the state of that thing. One way to think about that is to think about a light switch. Here we have a switch; we have our light bulb, presumably it's also connected to some power source, and when we flip the switch that turns the light bulb on. It changes its state. The light bulb has 2 different states. It can be off or on, so that means it can store 1 bit of data. In the next lecture I'll talk more about what a bit means, but something that can have 2 distinct states can store 1 bit, and if we had enough light bulbs well we could store many, many bits, which would be enough to keep track of any amount of data that we wanted. We don't need just something that can change state though. We need something that can also sense the state. With a light button, well, that could be someone's eye. You can see if the light bulb is on or off, and then you know its state. You could have a light sensor that would do that if you wanted to make that automatic. The way computers store data is sort of like this, except for it's using much less energy and much less space than a light bulb to store the state of data, and it's not using a human eye. It's using sensing electrons or sensing magnetism to sense the state of something. That's 1 way to store data is like a switch, and the fastest memory in your computer works that way. The data that's stored directly in the processor, which is called the register, is stored like a switch that makes it very fast to change its state, to record what the state is, but it's also like a light bulb. It means that when we turn the power off we lose the state, so it's not persistent, and it's a lot more expensive than other ways of storing data. The other way computers store data is more like a bucket. We could represent having a 1 by having a bucket that's full. We could represent having a 0 by having a bucket that's empty. Then to check the state of the bucket, we could weigh the bucket or look at the bucket to figure out whether it's full or empty, and the difference between buckets and light bulbs is-- --well, buckets leak a little bit. Water is falling out of the bucket and they also evaporate. If we want to store data using a bucket it won't last forever. Eventually the bucket will evaporate, and we can't tell the difference between a 0 and a 1, and I should also point out that the amount of water in the bucket--well, we're going to have to decide some threshold where if it's above that threshold we think that it represents a 1. If it's below that threshold we think it represents a 0. We could certainly imagine having many more levels than just 2 in the bucket. For computing it's almost always the case that we want to use a digital abstraction where everything only represents 1 of 2 things. That makes it less likely that we get it wrong. As the water evaporates we know it's still a 1 until it gets really near the bottom, but when it gets near the bottom there's going to be some left, and we want to know when it becomes a 0. When we're doing this with electrons we don't call it a bucket. We call it a capacitor. The memory in your computer that works this way is called DRAM. [Narrator] I want to give you a better idea what these actually look like, and my wife was kind enough to let me take some parts out of her computer. Actually, she took them out of the computer so I could show you what they look like. This is DRAM; this is 2 GB of DRAM, and what a gigabyte means is approximately a billion bytes. What it actually means I'll show you in the Python interpreter. In Python we can do exponentiation by using a star star. This is what we would write mathematically as 2 to the power 10. So 2 to the power 10 is 1024. This is called the kilobyte; we use the prefixes like the thousand prefixes, but the actual values in computing are usually powers of 2 instead. They're a little bit different than 1000. It's actually 1024 when we talk about a kilobyte, and a megabyte is 1024 KB. That's equivalent to 2 to the power 20. A megabyte is just over a million bytes. A gigabyte is 2 to the power of 30, which is just over a billion bytes, and a terabyte is 2 to the power of 40, which is just over a trillion bytes. These are the main units we're going to talk about when we think about memory. Here we have 2 GB of memory, so that means we have 2 to the 30 that would be 1 GB. We have 2 to the 30 times 2, which is 2 GB times 8, which is the number of bits in a byte, and 1 bit is the equivalent to a light switch. It can be in 1 of 2 states, so with 1 byte we have the equivalent of 8 light switches. This is comparable to having 17 billion light switches. The kind of memory that we have here is actually DRAM, so it's really more like having 17 billion buckets, and that means when you turn your computer off everything that's stored in the DRAM is lost. To keep the memory here, it's like a bucket, but instead of storing water it's storing electrons. It's a capacitor and when the power goes off that memory is lost. There are many different types of memory inside your computer. I mentioned registers briefly, that's the fastest memory that is built right into the processor. The main things that matter that distinguish the memory that you have is the latency which is the time it takes to get a response. So the latency you can think of as the time to retrieve a value from memory. We'll talk about latency more next class in terms of what that means in networks, which is really the same thing. For this DRAM the latency is about 12 nanoseconds, and as a reminder, a nanosecond is 1 billionth of a second. The other thing that really distinguishes memory, and the reason we have so many different types of it, is the cost. The cost varies depending on mostly the latency and the amount of memory you can store. The cost for this memory, if you bought it today, is about $10 for 2 GB. That's 10 US dollars, about 7 Euros. [Evans] Units like nanoseconds are fairly hard to understand, so what I want to do to give a better understanding of what the different types of memory in a computer are is turn those into different units and compare them. If we think about the light bulb switch, which certainly would not be a reasonable way to store memory in a computer today, the cost per bit is probably about 50 cents. So we can buy light bulbs for about 50 cents. Let's assume the sensing is free. It's already going to be ridiculously expensive. I'll call it US dollars, 50 cents per bit for using a light bulb and a light sensor. The latency is about 1 second. And what we're going to do in the quiz is convert latencies in terms of time in terms of the equivalent for the distance light travels in that amount of time. The other type of memory I mentioned-- and we didn't see this because it's sort of hard to extract from the computer-- is the CPU register. The registers are part of the processor, so it's hard to measure their actual cost. It's probably close to a 10th of a cent, though, if we look at the total cost of the processor and how that depends on the number of registers you have. The amount of memory that you have in registers is close to a kilobyte or 2 in a typical processor. Only a few thousand bytes in the registers. The latency is the shortest of any of these. It's less than a nanosecond. And the time to get memory from a register has to be short enough that you can do it within a single cycle. So we saw our cycle speed for the processor was 2.7 gigahertz. That means we need to do 2.7 billion cycles in a second. The time of a cycle is less than 0.4 nanoseconds. Within a given cycle, we at least need to be able to get memory out of a register. So that's an approximation of the time there. We'll measure the latency distance in terms of meters for light. So the third type of memory we've talked about so far is the DRAM. The cost per bit for the DRAM--well, our DRAM costs about $10 and it stores 2 gigabytes. So in order to write down the cost per bit, we really need a new unit. If we try to write it in terms of dollars and cents, it's going to be far too hard to see. So to fit DRAM into this, DRAM costs $10 US dollars for 2 gigabytes. If we want to write that in terms of a meaningful cost per bit, we need a new kind of currency. We're going to need far too many zeroes before we get to the value using regular dollars and cents. So we're going to use a new kind of currency. To measure the cost of DRAM in a meaningful way, we need a new kind of currency, which we'll call a nanodollar. A nanodollar is one-billionth of a dollar. So if we have a billion nanodollars, that would make 1 dollar. I don't have one of these on paper. It's money that's really not worth the paper that it's printed on, but it's a useful unit for measuring the cost per bit. Now we have a more useful currency for measuring the cost per bit of DRAM. The cost of DRAM turns out to be, in terms of nanodollars, 0.58 nanodollars per bit. And we saw that the latency for DRAM was 12 nanoseconds. So now for the quiz I want you to figure out the latency distance for each of these different types of memory. Note that the units are different here. We used dollars and nanodollars. For the distances we're going to use kilometers, meters, and meters. You've got all the information you have here. As a reminder, the speed of light is about 300,000 kilometers per second. [Evans] We can compute these using the Python interpreter. You didn't need to submit your code for this. You needed to compute the answers. And the answers that you should have gotten is that a light bulb, the latency distance is approximately 300,000 kilometers; for a CPU register, where the latency is less than 0.4 nanoseconds, the equivalent latency distance is 0.12 meters, about 120 centimeters; for the DRAM, DRAM is much cheaper. The latency is much higher than a CPU register. That corresponds to 3.6 meters of latency distance. [Evans] There's one last type of memory in your computer that I want to talk about, which is the hard drive. This is what a hard drive looks like. You can see that this hard drive has 1 terabyte of data. If you turn it upside down, you can maybe get a little better sense of what's going on here. It's a little hard to see. My wife drew the line at opening the hard drive, so I'm sorry I can't show you inside it. But inside here there's a bunch of disks that are spinning, and the disks are storing data in a magnetic way, and there's a read head that can read data from the disk as well as write new data from the disk. So this is a very slow way of storing data compared to what we have in the DRAM, but it can store a lot more data with a lot less cost. There are 2 important properties that the hard drive has. The hard drive is a lot bigger than the DRAM. It stores a lot more memory. This was 2 gigabytes. This is 1 terabyte, so that's 500 times as much memory. And a terabyte is close to a trillion bytes, so that's 8 * 2 to the 40 bits, which is equivalent to 8.8 trillion bits. This is enough memory to store about a quarter million songs. The latency for a hard drive is much worse than the latency for the DRAM memory. And the reason for that, if you think about what you have to do to get data out of the hard drive, you've got these disks that are spinning in a physical thing, so you've got to wait until it spins to the point in the read head where you can read it. If it's not in the right place, the read head also has to move across this. You're moving real physical things, so that takes time. The latency for a hard drive is about 7 milliseconds, and a millisecond is 1/1000th of a second. And that's the average time. The time varies depending on where the data is. So if you have to wait for it to spin all the way around and move to the head, that can take a lot longer. If you're lucky, the data is in the right place and it doesn't take that long. The cost of this hard drive is about $100 US dollars. So let's add the hard drive to our data table. For the quiz it's up to you to figure out the values for the hard drive in the data table. As a reminder, we said it was $100 US for a 1.0 terabyte hard drive. Your goal is to figure out the number of bits. I've told you the latency is 7 milliseconds. That's a milli, not a nano. You should be able to compute the latency distance. The units to use for this are kilometers. [Evans] The answer is the cost per bit for a hard drive is approximately 0.01 nanodollars per bit. Remember a nanodollar is a billionth of a dollar, so this is a cent of a billionth of a dollar per bit. The latency distance, though, is quite high. It's 2098 kilometers. So that means accessing data from the hard drive is like traveling between Munich and Moscow. This is a pretty big difference between accessing data from the DRAM memory, which is only about 3 meters away, about what you can reach with your arms, which is again very different from accessing data from the CPU, which is the distance between your thumb and your finger. So when people write programs and they care about performance, you really have to think about memory quite a bit. You have to make sure that the data that you access frequently is stored in these close, fast-to-reach places, not in the hard drive, which is like traveling between Munich and Moscow to get to your data. And no one is storing data in light bulbs. [Evans] The final major concept we're going to introduce in this unit is how to loop through a list. Since loops are collections of things, it's very useful to be able to go through a list and do something with every element of the list. With the things we know so far, we already know enough to do this if we put them together in the right way. You should remember the while loop from the previous unit. And as a reminder, this is the way the while loop works. We have a while followed by a test expression, which is something that evaluates to true or false. And when it evaluates to a true value, that means to execute the block, which can be a block of any number of statements we want. And then at the end of the block we continue, go back to the while loop, try the test again, and we keep executing the block as long as the test evaluates to true. So for this quiz we're going to see if you can figure out how to use while to go through the elements of a list. We're going to provide most of the code for you. Our goal is to define a procedure called printallelements that takes as input a list. We'll use the name p for the list. Our goal is for that procedure to print out every element in the list. I've written most of the code for this for you, but I've left out the test expression for the while. So the code that's written introduces a variable named i, initializes this value to 0, and we're going to use i to index through the elements of the list. For each element we print out that value, and then we increase i + 1. So can you figure out the test expression we need for the while to make printallelements work, and what printallelements should do is print out every element in the input list p. [Evans] Here's the answer. When the procedure starts, p refers to some list that was passed in. We want the procedure to work on any list, so we shouldn't assume anything about the list that was passed in. It could be any length. And i has the value of 0. That means the value of p index i is this first element of the list p. In the loop body we print out that element, and then we go on to the next element by increasing i by 1. i will now have the value 1. We go to the next element of p. We're going to keep on going until we get through the elements. What we need for the test condition of the while is to figure out when to stop. We learned about the len operator. The len of a list tells us the number of elements in the list. The highest index in the list is not the value of len because the list starts from 0. The highest index is the value of len(p) - 1. So we want the test condition of the loop to make sure that i has not exceeded that last index. We could write that condition many different ways. One way would be to use i < = len(p) - 1 since we know i is an integer since we created i, initialized it to the value 0, and the only thing we do with i is add 1 to it. This is equivalent to a simpler expression: i < len(p). Either of these would work as the test condition for our loop. We'll use the shorter one since it's simpler. [Evans] So we could write all the code we need to loop through elements of a list just using while. We'd be able to do anything we want. It would just be a little more complicated than we want. Python provides a simpler way to loop through elements of the list, and that's called a for-loop. The structure of a for-loop is like this. We have the keyword for followed by a name, and this is a new name for a variable that we can introduce, then the keyword in followed by a list, and this is any expression which evaluates to a list followed by a colon. So this is quite similar to what we've seen for the structure of a while loop and an if statement with a block inside the for. What a for-loop like this means is that for each element in the list we're going to assign that element to the name and evaluate the block. And we'll do that in order going through the list. So using for, we can define the procedure printallelements using much less code than we needed using while. We have a for statement where we'll introduce the name e as the variable name. We're going through the list p. For each element what we want to do is just print that element. So let's step through what happens when we use the for-loop calling printallelements, passing in the list we've defined and stored in the variable mylist. This is a list with 3 elements. The first 2 are numbers, 1 and 2, and the third is the list 3, 4. So when we created mylist, that created a list object that looks like this. It has the 3 elements, numbers in the first 2 and the list 3, 4 in the third one. When we pass that to printallelements, the variable p will refer to that object. When we execute the loop, what happens is the variable e is assigned to the first element of p. So initially, e will refer to this value. We execute the body of the loop with that as the value of e, so that will print out the value 1. Then we continue. The next time through the loop, e will refer to the second element of p. We evaluate the body of the loop, printing out that value, which is 2. Then we continue in the loop. The next time, e will refer to the third element of p, which is the list 3, 4. This will print out the list 3, 4. At this point we've gone through all the elements of p and the for-loop is done. Execution would continue here. In this case there's no statement there, so we're done executing the procedure and we return. [Evans] For this quiz your goal is to define a procedure, named sum_list, that takes as its input a list of numbers and produces as its output the sum of all the elements in the input list. So here's an example. If we pass in the list containing the three numbers 1, 7, and 4, the result of the call to sum_list should be 1 + 7 + 4, which is 12. See if you can define sum_list using the for-loop that we've just introduced. [Evans] Here's one way to define sum_list. It's a procedure that takes in 1 input, and we'll name the input p as the name for our parameter. I tend to use p as the name for a list. There's no really good reason for that. I don't want to use the letter l because l looks too much like a 1. I don't want to use m, n, or o because m and n are used usually to represent numbers and o looks too much like a 0. So the first good letter to use after l is p. Of course you could use any name you want for your parameter name. To define sum_list we're going to introduce a variable to keep track of the sum so far. Let's call that result. Initially, the value of the result of 0. Next we'll use a for-loop to go through the elements. We're going to go through the elements of p. Each time we execute the block of the for-loop the value of e will be the current element of p, and we'll go through the loop once for each element of p in order. So what we want to do is add that value to result. When we then get to the for-loop, that means we've gone through all the elements and we should return the result. Let's try this in the Python interpreter. We've defined sum_list. Let's try running it. We do get the value 12. What do you think would happen if we run sum_list like this, passing in the empty list? The answer is that we get the value 0, which is what we expect, right? The sum of no elements is 0. And if we look at the code, that's exactly what happens. Initially, we set the result to 0. The for-loop goes through all the elements of p, but if there are no elements of p, it doesn't execute at all. And so we go to the next statement, which returns the result, which has the value 0. [Evans] For this quiz, which is an especially udacious one, your goal is to define a procedure, named measure_udacity, that takes as its input a list of strings and outputs a number that is a count of the number of elements in the input list that start with the letter U, where U has to be upper case since lower case Us are not quite udacious enough for us. For example, if we evaluated measure_udacity passing in as input the list containing the strings Dave, Sebastian, and Katy, the result would unfortunately be a 0 since none of those strings start with an upper case U. If we instead passed in the list containing the strings Umika and Umberto, the result would be 2 since we have 2 strings that both start with the capital letter U. See if you can define the procedure measure_udacity. I can't claim that this will be a really useful procedure, but it will be a good test of whether you understand how to use a for-loop to go through the elements of a list. [Evans] Let's define our procedure in the Python interpreter. We'll give it the name measure_udacity, and we'll give the parameter the name p. Actually, we should probably give the parameter the name U, and we'll use an upper case U. Not the most standard name for a parameter but appropriate in this case. We'll introduce the variable count. We'll set its initial value to 0. We're going to use count to keep track of the number of strings that we found that satisfy the udacity property. And we'll use the for-loop to go through all of the elements in U. Now we need to decide whether or not to count this element. We can use an if statement to do this. We're going to need to use a comparison to check if the first character of the string is an upper case U. If it is, we want to add 1 to the value of count. If it's not, we do nothing. So we use the equality test to check if the value at position 0 in e, the current element of the list, is an upper case U. If it is, we add 1 to count. If not, we don't need to do anything, so we don't need an else clause. And now we just need to return the value of count. Let's test our procedure. Our first example, the input strings were Dave, Sebastian, and Katy. We see the result is 0, as expected. We'll try the second example where we have 2 strings that start with the letter U and see that we get the result 2 as the second value printed out. We should also test a string that has a mix of Us and non-Us. Now we're passing in 4 strings. They all start with a U, but only 2 of them start with an upper case U. So the result for the third number printed out should also be a 2. And we see that we get the expected result. [Evans] I hope you're starting to feel fairly confident that you understand lists, you understand the operations we can do on lists, and you understand how to use for and while to loop through elements of a list. For this quiz we're going to try something a fair bit tougher than what you've seen so far. Your goal is to define a procedure, named find_element, that takes 2 inputs. The first input is a list. It can be a list of any type of element, and the second input is a value which can be of any type, and it outputs the index of the first element in the input list that matches the value that's passed in as the second input. One of the things you should think about when you define a procedure is whether there are any special cases that it's not clear what you should do. In this case the question as I've stated it so far doesn't explain what to do if the input list doesn't contain any element that matches the value that's passed in as the second input. We'll change it to make that more clear, and we'll make it behave like the find method that we saw in strings. So if the element doesn't exist, we'll return -1. Here's a few examples. If you call find_element, passing in as the list the list 1, 2, 3 and passing in as the value to match the number 3, we find the match here, which is position 2, so the output should be 2. If we pass in as the list the list containing the strings alpha and beta and we pass in as the element to find the string gamma, there's no such element in the list, so the output should be -1. There are many different ways you could define find_element using the things that we've seen so far. See if you can find a way to define it that has this behavior. [Evans] There are many different ways we could solve this problem. First we'll look at a way of solving it using a while loop. We'll define our find_element procedure. We'll use p as the name of the list and t as the name of the target, the element that we want to match. We'll define the loop to go through the elements of p, similarly to the previous while loops we've seen that go through lists. We have our while loop. We've introduced the variable i. We'll use that as the index to go through the loop. The stopping condition for the while loop is when i reaches the len(p), so we want our test for the while loop to be i < len(p). In the block of the while loop we want to check if the current element matches t, so we get the current element using p[i] and then we use == to test if it's equal to t. If we find a match, meaning the 2 values are equal, then we want to return the index that we found. So the result should be the value of i, which is the index where we found the matching element. The risky thing about using while loops instead of for-loops is it's really easy to forget that you need to increase the index variable. If we just left the loop like this, it would run forever because the value of i would never change unless the first element matched, in which case we would return 0. The loop would just keep going on forever, again checking the first element. So we need to increase the value of i, and that's the end of the while block. The way we described what the find_element procedure should do, if the element was not found, it should return -1. If we get to the end of the while loop without returning, that means we've gone through the while loop for all values of i up to len(p) - 1. We didn't find any element that matches, so we should return -1. So that's one way to define find_element. I'll also show you a way to define it using a for-loop. The reason it's more natural to start thinking of defining find_element with a while loop than a for-loop is because the value that we want to return from find_element is the index itself. When we use a for-loop with the standard syntax of going through the elements of the loop, we don't keep track of the index. We just see each element in order. So we need to add something else to keep track of the index because that's the value we want to return. So we still need to use a variable to keep track of the index. We'll use i as that variable just like we did in the while loop version. Now instead of a while loop we'll have a for-loop. We don't need to think of the stopping condition here because it will just go through all the elements. Similarly to the body of the while loop, we check if the current element is equal to t. In the for-loop we can get the current element using the variable e. That's what gets assigned each time we go through the loop body to the value of the current element. So our test is using == to compare e and t. If they match, just like we did in the while version, we should return the result. The result we want to return is the index where we found the match. In the while version that was clear. It made sense because we were looking at element p, index i. In the version with the for-loop we have to be more careful to know where that index is. We're using the variable i to keep track of that index, so we'll return i. i starts at 0. Each time through the loop we need to increase i so we keep track of the current index as we go through the elements. As with the previous definition, when we had the while loop, if we got to the end without finding it, that meant that the element did not exist in p and we should return -1. We'll do the same thing here. [Evans] There are many other ways to define find_element. I'm going to show you 1 way that takes advantage of another built-in list operation that we haven't introduced yet but that makes it much easier to write find_element. The operation is called index. The index method is invoked on a list. You pass in a value, and the output in index is the position that that value exists in the list. So the built-in index almost solves find_element exactly the way we want. The difference is when we invoke index on a list that doesn't contain the value we pass in. Index doesn't return -1. What it does is gives us an error. So let's look at what happens in the Python interpreter. I'll define a variable p and give it the value of the list 0, 1, 2. If we invoke index on p, passing in 2, we get as the result 2, which is the position in p where the value 2 occurs. For the second example we'll add more 2s in the list, and we see that it always gives us the first one. So the result returned by p index is the first place in the list where that occurs. Now we'll try an element that doesn't exist in the list. What we see is instead of getting -1 as a result we get an error that the target element that we looked for doesn't appear in the list. So if we want find_element to have the behavior that's described, we can't quite do it using index directly. There are some other list operations that might be very helpful, though. So to summarize the behavior of the index method, if the value passed in is in the list, it returns the first position where the value is found. This is exactly what we wanted for find_element. The problem is if the value is not found in the list, it produces an error. There's another list operation that will be useful to allow us to use index to find_element, and it's useful for many other things, and that's the in word. We've already seen in being used in the for-loop. Here we use the same word in, but in this context it means something different. The syntax is to have a value to the left of the in word followed by the list. The syntax is a bit strange compared to the other things we've seen in Python. It doesn't look like a procedure call, but it's very natural in terms of how it corresponds to how we would say this in English. If we say something like, "Is 3 in the list?" we would write that in Python as 3 in p. So let's see how that works in the interpreter. Now I'm printing the result of 3 in p. 3 is not in the list, so it prints out False. If I change this to print the result of 2 in p, we get the value True. So to summarize the behavior of the in operator, if the value is in the list, the output is true. Otherwise the output is false. Similarly, we can use not in. Not in has the opposite meaning of in. If the value is not in the list, the result of value not in list is true. If the value is in the list, then the result of value not in list is false. The value not in list is exactly equivalent to saying not value in list. The only reason to have the not in is it's more natural to read it this way in English than having the not between the value and the in. So now to check that you understand index and in and not in operations, I want you to try to define the find_element procedure again. It should have the same exact behavior as the ones we've defined before. It should give us the position of the element we're searching for if it exists, and it should give us -1 if it doesn't exist. But this time instead of using a while loop or a for-loop to define it see if you can define it using index. [Evans] Here's 1 way to define find_element using index. In the case where the element does exist in p, index gives us exactly the result we want. So we can use an if statement, check that t is in p using t in p, and then if it is, the block for the if returns that value. It returns p.index(t). For the else clause the element did not exist in p, so we return -1. Here's another way we might define find_element using index. Instead of checking if t is in p this time, we'll check if t is not in p. If t is not in p, then we know the result is -1. We can return -1 right away. If we reach the next statement, then we know that t is in p and we can return the result of p.index, passing in t. So we've seen 4 different ways to define the find_element method. They all have the same behavior, but we've defined it once with a while loop, once with a for-loop, and 2 different ways using the index method. When we use index, we need to use an if statement as well to make sure that we produce the right result for the case where the element is not in p. This is a long unit, and I know things are definitely getting tougher. If you are having trouble I hope you will take advantage of the course forum, there is lots of great discussions there with other students in the class, as well as the course staff. I want to make sure everyone sticks with the class, so we asked Sergey Brin to explain why you should do that. [Sergey Brin - Co-founder, Google] [S. Thrun speaking] So will you entice students to stick with the class and computers? [both chuckle] I certainly recommend that you continue with the class and go all the way through it to completion to really make sure that you get a deep first cut at computer science and at programming. [Evans] We'll have 1 more quiz about using lists. It will combine many of the things that we've learned. After this quiz we'll be ready to build our web crawler. For this quiz your goal is to define a procedure, named union, that takes 2 lists as its input. It should modify the value of the first input list so when union returns its value is now the union of the 2 input lists. When we compute a set union, we want to add all the elements in the second list to the first list, except if they already exist. We shouldn't be creating any duplicate elements by adding elements that already exist. So here are a few examples. If you start with the variable a, referring to the list 1, 2, 3, and the variable b, referring to the list 2, 4, 6, then we call union, passing in a and b. After the call, the value of a should be the list 1, 2, 3, 4, 6. We've added the elements of b to a, except we skipped the first element, the value 2, since 2 already exists in a. I should mention that union should not modify the value of b. After the call to union (a, b), the value that b refers to should still be the list 2, 4, 6. So see if you can define the union procedure as described here. [Evans] Let's think about how to define union. We need to make a procedure that takes 2 lists as its inputs. We'll call the lists p and q. To define union we want to modify p by adding elements from q. We should remember that append operation does that. It adds a new element to a list. So we're going to use append to add elements from q to p. To define union we need to go through all the elements in q. Check for each element whether it already exists in p. If it does, we do nothing. If it doesn't, then we add it to p. So we'll use a for-loop. We need to make sure that we loop through the elements of q. Those are the ones that we want to add to p. For each element we need to test whether or not it's already in p, so we check to make sure the element is not already in p. If this is true, that means e is not in p, and we want to add it. To add e to p, we use append. We're going to introduce one more list operation that will be very useful in building our web crawler and that's the Pop operation. Pop works like this. We have a list. We have .pop. This is similar to the way we use the find method. There are no inputs to pop, but we still need the parenthesis to show that we're calling a procedure and what it outputs is an element of the list. What pop does is it mutates the list. It removes the final element of the list. It also returns the value of that element. So, here's an example. If we started by initializing the variable a to be the list one, two, three. And then, we'll make b an alias for a, so here's what we have after those two statements. We have created a new list with elements one, two, three and a refers to that list, after the assign a to b statement, b also refers to that list, then we do x assign a pop to x. So the value of x will be three, that's what the last element was. That's what we get returned by pop. But it also mutates the value of the list. It removes that element. So now a refers to the list one, two. Since b was an a list for a, it also changed the value of b. b is now the list one, two. Now it's time for our pop quiz to make sure everyone understands pop. For this quiz, assume that the name p refers to a list with at least two elements. Your goal is to determine which of the code fragments does not change the final value of p. And so that means no matter what value p starts with, as long as it has at least two elements after executing the code. And I'll show you the choices for the code next. The value of the p is the same as what it started with. So here are the choices. Check the box for each code fragment where the value of p at the end of the code fragment is the same as the value of p beforehand, assuming that initially p has at least two elements. So the answer is all of the code fragments except for the third one, except for this one, leave the value P unchanged. So let's work through why that is. We're not going to assume anything about P. It's, list with atleast two elements. So I'll draw P. We can't make any assumptions about what the elements are. We'll call them Alpha, Beta and Gamma. Actually, it looks like alpha, beta, and alpha. That's okay. So let's look at the first option. Here's what happens. We append a 3 to P. That adds a new element at the end of P. And then we pop. That removes it. We don't do anything with the result returned by pop, but that's okay. The value of p is unchanged. For this choice, we start by popping. That will remove an element from p, so now x will refer to whatever this element was. So x refers to alpha in this case, and p is mutated by mod, removing that element. So at this stage, the value of p has changed, but we're not done. We still have the append to do. The append appends to p, adding onto the end of p the value that x refers to, which is the alpha value that was in that position to begin with. So at the end of these two steps, the value of p is also unchanged. Let's look at the third option and see why that does affect the value of p. So the first statement, we assign to x the result of p.pop(). That will remove the last element from p and make x refer to it's value. So now whatever value was at ten of p the name x refers to. Then we do another pop. So now after this pop, y will refer to the value here, which is beta. We remove that value from p. So at this state p has lost two elements, but we've stored them in the variable x and y. Then we do the append, and we're doing the appends in the same order we did the pops. So we're appending x first. The value of x is alpha, so this will Add the alpha to p. Note that that's not what we started with. We started with the beta there. Then we do the next append. That will add the value of y, which is beta to p. If we pop elements of p, and we add them in the same order that we pop them, this will actually reverse the order of the elements, since each time we append, we add to the end of the list. So for the final choice, we're again popping two elements. This time we're appending in the opposite order, that means when we do their appends so the value when we popped x, that got the value alpha. When we popped y, y was the value beta. P lost these two elements as the result of the two pops. Now we're here. We do the appends. And this time, we're appending y first. Well, that's the beta, that's the last one we popped, the first one we append. This gets the elements in the order they were before. And finally, we append x, which is the alpha. This restores the value of p to what we started with. So now we're ready to get back to the problem of extracting a list that contains all the links in a webpage. This is the first step towards our crawler, which will crawl a set of webpages, finding all of the links that can be found from a seed page. We're going to start with a webpage. We have the url of some seed page. We use the get_page procedure to get a string which is the text of that page. That's got lots of stuff in it that we don't care about, but it also includes some hyperlinks, and inside the hyperlinks are the url's to that page links too. Our goal is to define a procedure--we'll call it getalllinks-- that takes as input, a string representing the text on a webpage, and produces as output, a list containing all of the url's that are linked to by that page. So let's recap the code we have at the end of unit two. So we defined a procedure, get_next_target, that would take a page, search for the first linked target on that page, return that as the value of URL. That would be the first output, and also return the position where the end of the quote is so we know how to continue. And then we define the procedure print all_links that keeps going as long as we can. As long as there are more URLs on the page. It will find the next target. Store these in the variables URL and endpos to keep track of the location end of string. If there is a URL, what we did was just print it out and then we update with the page to keep going. What we want to do to change this is instead of just printing out each URL as we find it, we want to collect the URLs. We want to have a way to use the URLs so we can use them to keep crawling to find new pages. The structure we've been learning about this unit is the way to do that. What we want to do is keep all the URLs in a list. At the end of this procedure, instead of printing the links as we go, we want to have a list of all the links that we found. So this is what the current print_all_links procedure does. It takes the page as its input and its output is nothing. It doesn't return anything. All it does is do some work, prints out all these links. But we can't actually use them at the end, because it doesn't return anything. So what we want to do is change this. Instead of print_all_links, what we want is to get_all_links. We want to actually have the links in a way that we can use them. So what we want, instead of printing all links is to actually get the links. So we'll change the name of our procedure to get_all_links. And instead of outputting none, what we want to do is output a list of links. And that should be the list that corresponds to the things that we were printing before, but now instead of just printing them, we want to output them as a list. So to show you an example of what that looks like, we've created a test page that's in udacity.com cs101 index.html and when we run get all links we'll see all the links on that page. Let me show you what the page is first. This is our test page for learning to crawl. So that's the URL that we're using to get page and get all links from that page. Now you see that this page has three links on it. The first one goes to crawling.html, the second one goes to walking.html, and the third one goes to flying.html. We'll look soon at the structure of these pages when we do our web crawler. You can try that on your own in the web browser. For now, what we are interested in is finding these three links. So when we assign links for the result to get all links. We can print the value of links that we get back. And when we run that, we see a list containing the three links on the page. And because that is a list, well, we can do useful things with it. We could extract the value at position zero, and get just the first link on the page. So think on your own, if you could define get all links. If you're ambitious, you'll try to define this all by yourself. We're going to step through how to do this with a few quizzes because I think it's quite a challenging thing to do all by yourself. But think about that by yourself first, and then we'll step through it with a series of quizzes. So here's the code, that we had at the end of unit two. Our goal now is to modify that code, instead of printing all links, to get all links. The good news is, the get_next_target we don't have to change at all. We still want to find the next URL in the page. We're going to need to make a few changes to print all links to make get all links. But not too many. The first change we need to make is we need to introduce a variable to keep track of the results. So I'll call that variable links. I'll leave it as a quiz for you to figure out what the initial value of links should be. Remember, our goal for get_all_links is that at the end of get_all_links, it will return a list containing all of the links that we found on this page. So the answer is we want links to start out as the empty list. And we get the empty list with the two square brackets. The next change we want to make is we don't want to print the URL. We want to do something else with it. For your next quiz, your goal is to figure out the code that we need here. And remember, what we want to do is to maintain in the variable links, a list of all the URLs that were found on the input page. So the answer is we want to append the URL to links. So we can do that by using links.append, passing it as the input, the URL that we found as the next target. So this will add that value to the list that links refers to, keeping track of all the URLs that we found on the page. The last thing we need to finish to get all links is to produce the output. So I'll leave it up to as a quiz to figure out what we need here to do that. The answer is we need a return statement. And we notice it's indented at the outer level. And what we want to do is return the value of links, which is the list of all the links that were found on the page. So now we're ready to finish the Web Crawler. And remember what we want the Web Crawler to do. So, we have a seed page, and we're assuming we know some seed page to start with. And the seed page has some links on it. We want to be able to find those links, and we know how to do that now. We're going to get them to list, and then we're going to follow those links. So we'll follow the links. To new pages, and those new pages might also have links, and we want to follow those links. So in order to do this, we need to think about two things. We need to keep track of all the pages that we're waiting to crawl, and we'll introduce a variable, tocrawl, to do that. And what tocrawl will be is a list of pages left to crawl. So, initially it'll just be the seed page. Once we collect the links on the seed page well it will include those links as well. Once we finish crawling a page, we don't want to keep it in tocrawl anymore. And as we find new pages to crawl, they'll be added to the tocrawl list. The other variable we want is to keep track of all the pages that we've crawled. At the end of our crawl, this is the result. We want to know all the pages that we found. That will be stored in the variable we'll call crawled. So let's walk through an example of how this should work on the sample site. So I'll make the seed page, www.udacity.com/cs101x/index.html, that's this page here. That means when we start to crawl, we want tocrawl to be this index page. And I'm going to stop writing out the full URLs, just writing out the final part. because all the pages we crawl will be on our test site. So tocrawl will be the list containing just one element. The index.html page. We haven't crawled anything yet, we're just getting started, so crawled will start out as the empty list. The next thing we're going to do is crawl this page, so we'll get all the links on this page. That means we've crawled the index page, so that will now be added to crawled. But when we looked at the links on the index page, we found three new links on that page. We found a link here, which goes to crawling.html. We found the link here, which goes to walking.html. And we found the link here that goes to flying.html. So the new value of tocrawl, after crawling this page, will have those three links in it. The next thing we want to do is take one of those links and crawl it. The order actually matters a lot in terms of getting a good crawl. Let's assume for now that we'll do just do the last one first. So, we'll do the link fly. That links to the flying page. Here is the page there. So, we are going to crawl the page flying.html. This page doesn't have any links. If you're not sure why squeamish ossifrage is the magic words, I would encourage you to DuckDuckGo or Google that. And now we've finished crawling flying, so that's going to be added to the crawled list, which already had index.html, we don't lose that. We're going to add the new one, which is flying, to that list. And we finished crawling it so we don't want to crawl it again. Let's remove it from the tocrawl list. Now, after we're crawled flying, we have two more links left in our tocrawl list. We have two links that we've crawled. So let's try another link. Let's suppose we follow the crawling.html link. And we follow crawling. We get to this page. So, to follow crawling, we're going to follow the same algorithm we did with flying. Alright, so that removes this link from the tocrawl list, adds it to the crawl list. So, we're done crawling, crawling. And now we want to add to our tocrawl lists all the links that we find on this page. Well, we found the link, kicking, which goes to the page, kicking.html So we're going to add that to our list of pages to crawl, and now we keep going. And we're going to keep going. We'll follow kicking. We find that kicking does not have any links. So that would add kicking to the crawled list and remove it from the to crawl lists. And we're going to keep going until we have no more pages to crawl. So let me describe that process a little more formally and then I'll ask you a question about it. So I'm going to describe that process, and I'm going to write it out in a, fairly precise way, but not as actual python code. Because it will end up being your job to finish the python code to do this. But I want to describe it precisely enough so we can ask some questions about it. So we're going to start with some seed page and to crawl will just be that page. The list containing just the seed page, and crawled will be empty. And we're going to keep going as long as there are more pages to crawl. And for each step we're going to pick one of the pages, we'll add that page to crawled to keep track of the fact that we've crawled it. Then we'll find all the link targets on this page, and add those to tocrawl, and we'll keep going as long as there are more pages in tocrawl. And then when we're done we'll return crawled. So that's the basic process that I've walked through. So for this quiz. I want to see that you understand the process that we're using to crawl the web, well enough to understand what will happen if we do this starting from the seed page on the example test site. And you can try exploring that site yourself. So the choices are, it will return a list of all the URL's that can be reached starting from the seed page. The second choice it will return a list of some of the URL's but not all of them that are reachable from the seed page. And the third choice, it will never return. So the answer, is that it will never return. And the reason for this is the stopping test for the while loop is when there are any more pages to crawl, so we're going to keep doing this as long as there are pages in tocrawl. So in order to finish, we need to know that the value of tocrawl eventually becomes empty and if we look at the test site. If you follow the walking link, which the crawler will do, you get to this page that has a link to crawling that goes back to the index. That will keep going, and you're going to follow the walking link again, follow the crawling link again, following the walk, walking link, following the crawling link back to the index. And this will continue forever. The crawler will never finish because it will always find a link to crawl. And the real web is full of circular links like this. There are lots of pages that link to each other. There are also pages that link back to themself. So to avoid this, we need to do something smarter. We need to make sure that we don't crawl pages that we've already done. So we're going to have to be a little more careful about this step. We need to add a test to see if we already crawled this page. If we did, we don't do anything. If we didn't already crawl it, well, then, we need to add it to crawl, add all the links in that page to tocrawl and keep going. Now we're ready to write the code for crawling the web. So our goal is to define a procedure, we'll call it crawl_web, that takes as input a seed page url. So, that's the url that identifies our seed page, and outputs a list of all the urls that can be reached by following links starting from the seed page. So, if you're really ambitious you should try to do this yourself without anymore help. That's going to be a pretty tough challenge. So we're also going to step through one way to do this as a series of quizzes. But you should feel free at any point, when you feel confident that you can do it yourself, to try to finish for yourself, rather than following the step by step quizzes that I'll show you. So we will start defining our procedure crawl web, and we are going to introduce two variables. The two crawl variable that keeps track of the pages that we need to crawl, and the crawl variable that is a list of pages that we have already crawled. For the first step, your goal is to figure out, how to initialize these variables. Which of the first value, to crawl and crawled be? So the answer is we should start to crawl with a list containing just the seed page. And we should start crawled as the empty list. We have not yet crawled any pages. The next step is to write the loop that's going to do the crawling. And we said the process we want to follow is to keep going as long as there are more pages to crawl. We can do that with a while loop, and we can use tocrawl like this in our test condition. If a list is empty that's interpreted as false. If the list is not empty, that would be interpreted as true. So this means the same thing as testing if the length of the list is zero, it's a cleaner way to write this by just doing while tocrawl. Inside the loop, well, we want to pick a page to crawl. We'll store that in the variable page. And I'll leave it as a quiz for you to figure out a way to pick the page to crawl. There's certainly lots of different ways to do this. If you're clever and can think about using all the things that we learned about, you'll be able to have one line that both initializes page to the next page we want to crawl, and removes that page from the tocrawl list. So the best way to answer this is to use pop. Pop's the only thing we've seen that actually removes elements from a list and it also has the property that it returns that element. If we do tocrawl.pop() that'll get us the last element in the tocrawl list. Remove that element from the list tocrawl. And assign that to the variable page. One important point to note is because we're getting the last element first. What we are implementing is what's called a depth-first search and that means that as we crawl webpages, If we had three links on the first page. Well, what's going to happen is we are going to follow that last link. We're going to add the links that we find there to the page. Before getting to these links, well, we're going to follow this link, right? That's going to be the last link that we added. We're going to follow that, we're going to get to that page, and we're going to follow the last link on that page. So, this is why it's a depth-first search. We don't get to look at the second link on the first page until we've followed all the links that we can reach from the last link on the first page. If our goal was to get a good corpus of the web quickly, doing a depth-first search would probably not be the best way to do it. And some of the questions at the end of your homework, ask you to figure out ways to change the search order, that will give us a better way of capturing content on the Web. For now, we're going to be happy, and with the test site, it's enough to do a depth-first search. If we can complete our search, no matter what order we follow, we'll always find the same set of pages. If we aren't able to complete the search, and with a real web crawler, there's far too many pages to wait until we find them all to return a result, then the order that we do the pages matters a lot. So for the next step, we knew to think about this problem rent into web cycles. We don't want to crawl pages that we have already crawled. So what we need is someway of testing whether the page was crawled. If it was crawled, we don't want to crawl it again. If it hasn't been crawled, then we want to do something. So the way to make a decision like that is to use if. So we need a test condition for the if so that will only do the stuff that we do to crawl a page if we have not already crawled that page. So see if you can figure out what the test condition for the if should be. So the answer, is we only should crawl the page if we have not crawled it already. And the crawled variable keeps track of the page that we've crawled already. So what we want to do is test whether the page is not in crawled. If page is not in crawled, then we should crawl it. If it isn't crawled, well, we just keep going. We're going to do nothing else. For this iteration through the while loop, we're going to keep going through the while loop and check the next page. We're not done right away, if this one was already crawled, but we don't want to crawl it. So now, we're ready to finish the heart of our crawler. Let me put the last statement in, so you know there's nothing else missing and you'll be able to test this. And the last thing we want to do is return the result in crawled. When we finished the while loop, we're ready to return crawled, which is the list of pages we found. What we have left to do is to figure out what we do to crawl each page. This is going to be a pretty tough quiz, I think you'll need at least two lines of code. If you think about using all the procedures that you've learned about and the ones that you've defined in earlier quizzes, you shouldn't need more than two lines. And the two things that you need to do are update the value of to crawl to reflect all the new links that are found on page And update the value of crawled, to keep track of the pages that have been crawled. See if you can figure out how to finish the crawl web procedure. So the first thing we'll do, is add all the links that we find on the page that we're crawling, that's the value of page, to to crawl. The best way to do that is to use the union procedure, that we defined in an earlier quiz this unit, that will avoid having duplication in to crawl. If you didn't use union, you could still get the stork. It's okay if there's duplication because we're doing this test to not crawl the same page twice. So I'll do it using union. We're going to union into to crawl. The results of finding all the links on the page that we found, and we need to use get page passing in page to get the actual contents of that page. And the get all links procedure that we defined earlier returns a list of all the links on that page. The next thing we need to do, is to keep track of the pages that we've crawled, we can do that by using append. So that adds this page to the list of pages we've crawled, and now we're done. We've got a working web crawler, for any seed page, it will find all the pages that can be reached from that page, and return them in a list. So, congratulations. You've built a web crawler. You've learned to crawl. We're not quite at flying yet, but this is a lot that you've learned in just three units. And by learning about lists, we can build any other structure we want starting from lists. And we'll see lots of other things that we do in the next unit, as well as the units that follow that. That use lists. We haven't quite finished building a search engine. We have a way of getting a great start towards our purpose, finding all these pages to crawl. What we need in Unit Four is the way to get the content from those pages, by starting from our seed page, and following the crawl web procedure that you wrote. And then we'll use that to build an index, so we can respond to queries when someone's doing a search for a particular term. The other thing we'll do in Unit Four is, we'll learn more about how the Internet and the web work. I'm here with Anna Patterson who's built a bunch of search engines, including building the world's largest index of the web. And now works for Google. And we've just finished building a very simple web crawler. I want Anna to tell us something about how things are different if you want to build a web crawler that works with the scale that Google has to deal with. So there's three main issues with scaling up a web crawler. One is the normal politeness that you need on the Web. The second one is how you get a bunch of machines involved in crawling, not just one. And the last issue is how to consume a lot of bandwidth so that you keep the expensive resource busy. While still being polite. So, on politeness, there's a line in the robots.txt that each domain tells you how often you can crawl that domain. There's a number of problems with that, which is that multiple domains can be hosted with a hosted service, and they can be hosted even on one machine. So even though you're being polite to one domain, you're really actually really hurting a hosting service, or you're hurting a machine. So you have to make plans in order to not hit one machine or one domain too hard. The next thing is, that if you crawl on just one machine. It, the state is very good, and it's really easy to keep the state of the crawl on the one machine. But then it's hard to make a very big search engine, because you get as much as one machine will crawl. So of course in practice, you crawl on thousands of machines. Now, if you're going to obey politeness, that means that each of your thousand machines, needs to tell the other ones, what it has crawled and what it's about to crawl and what it, going to crawl in 20 minutes, right? All of this communication overhead can actually slow down the crawler, which actually hurts your aim of having a big search engine. The last part is that you want to max out your bandwidth. So one thing that people do instead of trying to lessen the communication, is they pre-process the corpus that they already have. So when you've crawled a set of pages you can process them and extract out all the links that they point to. You can then normalize those links so that Yahoo.com and dubdubdub.yahoo.com wind up being the same string, and now you can farm those strings out to your thousand machines, and now they don't have to communicate because they know they're not going to hit the same domain. However, they could accidentally hit the same hosting service and the same machine, but you can take care of that ahead of time as well. Thanks a lot Anna. I hope those of you who think about unleashing your web crawler on the world, pay careful attention to what she said about politeness. Thank you for having me, and students, good luck on your search engines. So I hope we'll see you back soon. You'll have a homework for Unit three that's going to be quite challenging, and I look forward to seeing all of your answers to it. Here we're given some code, and we have to fill in the blanks such that if we execute this code and print the list "p" we get the output [1, 2, 3]. We have to find the initial values of p, and then we update each entry in p once and only once. Although this says p[0] and this says p[0] and this says p[0], this p[0] is actually a different value than these 3. It'll help to think through it if we actually label. We'll say this is the first one, the second, first, second, and we know based on the final values that this equation equals 1, this one equals 2, and this one equals 3. Let's do a little algebra. I'm going to re-write these on the side to make it easier to read. With just this equation, there's nothing we can do. All we know is that the the initial values of p[0] and p[1] have to add to 1. We can't get anymore specific than that. Unlike the first equation, we can actually simplify this a little more. Remember that we know the final values of each entry. We can actually simplify this to just say 1 plus p[2] equals 2. With a little algebra we know that p[2] equals 1. In our last equation, we can just quickly glance at it and see that the final value of p[0] plus the final value of p[1] equals 3. Well, we're given that the final values are 1 and 2, so all we're saying is 1 plus 2 equals 3, which doesn't help us very much. What did we learn? We know the last value has to be 1, and we know the first and the second values have to add up to 1. We can't do anything from here. This is all the information we have. As long as we satisfy those 2 constraints--this entry plus this entry equals 1-- then we'll get the correct answer. Two sample solutions would be [1, 0, 1], and an equally valid one is [-99, 100, 1]. In this problem, we have to determine that if we have some code that does some stuff, and we have a list, and we compute some solution, that if I insert this call to the function "proc" 1, 2, 3, or 4 as we'll go through them that this code behaves exactly the same no matter what else it does. So let's get to it. In this first procedure, there's only one line. We set the first value of p to equal its second value. This is going to change the elements in p. I mean, if we had in a list [1, 2] executing proc1 would then change it to [1, 2]. Obviously, that can very well effect how this could execute, so this isn't right. This one can be a little tricky, so let's work through it. We know that p is a pointer to a list--let's say it's 1, 2, and 3. Now we're reassigning what p points to to the original value of p, which is this, concatenated with the list 1. This is going to create a new list, because that's what the plus operator does with lists. We want to create a new list. Now p points to this. We don't do anything with p. But most importantly the original list has been left unchanged. The end result is that this is good. We can go through this problem like we did the previous one. We start with a variable p that points to a list. We then create a new variable "q," which points to the same thing as p. On p we append 3, and then on q, which is the same list, we pop 3. The end result is the same list we had before. Here we create a new list called "q," which is an empty list. There's nothing there. While p is not empty, we append onto q what we pop from p. If we remember, the pop is going to take the last entry in p and return it. It's going to pop off 32, and then we're going to append that on the q. This is going to continue until we have the reverse of the previous list here and p is empty, which I'll just symbolize with that. Then we're going to reverse the process here. If I undo what I just did, the end result is we have the original list, and we have the empty list. Although, this doesn't matter. The main point is that we still have our original list. This one is good. For this problem, we've taken a list p, and we want to return each value in the list multiplied by each other. The multiplicative identity is 1. Let's start total as 1. The reason we do this is because it works for any value of p[0] against which we multiply. We're then going to go through the list and multiply our incrementing total by each value. At the end we're going to return total. That's it. In this problem, we take in a list p, and we want to return the greatest value in p. We're given that the list is positive integers. We're going to choose 0 to start out greatest value, because 0 is smaller than any positive integer. Additionally, if we're given an empty list, we're told in the instructions to return 0. This will be useful later. This is similar to the previous question where we want to go through the list one entry at a time. If we find an entry in our list that's greater than our current running biggest, then we want to update biggest. At the end we're going to return our max value. The problem specifically asks for you to deal with the empty list case, and if you noticed, if p is empty we don't execute any of this. So the end result is that this is equivalent to just returning 0, which satisfies the problem constraints. In this problem, we're given a new data structure that is a list of universities where each entry is another list that contains the name of the university, the number of students that attend that university, and the tuition costs. What we want to calculate are the total number of students enrolled at all universities in this list and the amount of money that all of them are paying. What we're going to do is sum the number of students, so we're going to keep track of all the students and keep adding for each university the second value on the list. Then we're also going to keep a second counter that is the amount of tuition that they're paying, and so what we're going to do for each entry is we're going to multiply these two values and add those. We're going to have 50 times 2, which is 100, and 100 times 1, which is also 100. The end result would be the tuition is 200, and the number of students enrolled in 150. This is what we'll return--both those values. Let's write the function that does that. I've declared the function. It takes in a list, and I've started my 2 sums-- the number of students enrolled and the total tuition all the students are paying. I've added a little trick here to make the code a little shorter. This is a Python thing that you probably didn't know, but feel free to use it in the future. What I'm saying is that for each value in the list, I have the name, which is going to correspond to the first entry in the sublist, the students correspond to the second entry in the sublist, and price corresponds to the third entry in the sublist. If I had the other version where I just say for i in p and then assign the variables names, that's all we're doing here. It's just a little short cut to save you this time of writing the 3 lines to write this out. Here for each school I update the number of students by simply adding the number of students to the total count. I update the total tuition by simply adding the amount the students are paying at this particular university to the total tuition. Then in the end I return both values, which you can do by simply adding the comma. Here I've built a fake internet It's a little smaller than the real internet, but it'll be a good example for showing how we want to modify the crawler to solve the max pages problem. The problem asks us to stop the crawler from crawling the internet after we've reached a certain number of pages. If this were the real internet, there'd be a lot more links. We'd have links going basically practically forever. There are billions of pages on the internet, and if we took the code that we had at the end of this unit, then the crawler would go on for a very, very long time. I leave it up to you to estimate how long it would take, but longer than this course has time available. What we want to do for all practical reasons is have the crawler stop after reaching a certain number of pages. That's pretty easy to do if we just count the number of pages that we've seen as we go through our sample internet and simply check it against the max pages passed into the function. If we say max pages is equal to 3, what our crawler is going to do is start with A. >From A, we're going to crawl A, then get B and C. Then we're going to crawl C, and get D and E, but we now have crawl 3 pages, so we want to stop the process. Let's look at the code that we had at the end of the unit and modify it to do exactly this. Here we have the crawl web function. We take in a parameter--max pages-- and we want to stop crawling once we've hit that number of pages crawled. An easy way to check is to simply look at the length of the crawled list, and we get that but using the len operator. We don't only want to crawl a page if it hasn't been crawled, but we also only want to crawl it if the length of the crawled list is less than max_pages. In this question, you were asked to limit the depth the crawler searches to. In order to understand this question and what we need to do, I'm going to draw a graph of the links, so I'm going to start off with a seed page A, and from A I have links to another page B and another page C. Now B links to D, and C links to E. Now, just to make things a little tricky, E is going to link to D. Finally, D links to F. What do we actually need to do? Well, we need to keep track of what pages we have left to crawl, just like before. We need to keep track of the pages we've already crawled, because once we've crawled them we don't really want to have to crawl them again. I'm going to introduce a new list where we keep track of the pages at the next depth. I'm just going to call that next_depth. We start off at tocrawl, and we have just the seed page. Now, we haven't crawled anything yet, and we don't know what there is to come either. We start off with just tocrawl with the seed page in it. Now, from there we look at A, and we see that there are two pages that A links to. We're at A, and the next depth--the next pages at depth 1--are B and C. We're actually going to move A from tocrawl to crawled, because we've actually looked at it now. We've seen that the next pages are C and B. Those are going to be the ones that we crawl next. I'm going to put those into tocrawl. We'll look at those next. If we look at B, B has a neighbor D, and then C has a neighbor E. We do this in a couple of steps, but just to get the idea how the code is going to work. I'm just going to go through it looking at what's at each depth. B and C we've now crawled, so those two both go in to crawled. Now the ones at the next depth are D and E, so those are the ones we want to look at. We're going to move D and E over here, and then we're going to look at the next pages of D and E. D has neighbor F, and E has a neighbor D. Those are at depth 3. Now, we might not want to add D in here, because actually we've already look at D, but we'll see when we get to the actual code how we're going to handle that. Now we take D and E and put them into crawled. Then we've got F and D over here, and we can carry on, depending on what depth we want to go to. That's the idea behind how the code is going to work. We're going to start off with a page. We're going to crawl it and everything else at the same depth, and then add those pages to next depth and switch the lists around, which hopefully you'll be able to see more clearly in the code. This is the supplied code for crawl_web, and we're going to make a few changes to this to take account of the depth. So what do we do first? Well, we're going to need another list next depth, which will keep track of the next level of links. When we start we have a depth of 0. We're going to carry on through the while loop while there's something in tocrawl, because if there's nothing to crawl, then we can't carry on. Also while our depth is at most the maximum depth that's supplied as an input to the function. Just as before, we're going to pop from tocrawl, and we're not going to make any changes to this line either, but instead of adding to tocrawl--because we don't want to muddle up the pages we're searching through now and the pages at the next level-- we're going to actually add the new links to next depth instead. Then just as before, we're going to add our page that we've crawled to the crawled list so that we know we've already looked through it, and we're not going to look through it again. Now, the last bit of code that we need to add-- when we've finished going through all the lists at a given level, just like I showed you in the example, we're then going to change our tocrawl list and our depth list over. So tocrawl is now empty. Next depth contains all the new links, and I'm going to use a multiple assignment where I swap tocrawl and next_depth. Tocrawl becomes equal to next_depth and next_depth is going to be empty again, so that we can start the while loop again with a clean list. Then depth we're going to increase by 1. Then we're going to return crawled. Just to quickly recap--we carry on through the while loop as long as we've got some page to crawl and our depth is less than or equal to max_depth. We take page, and if we haven't crawled the page before, we add all the links from the page to the next_depth. Then we take our page, and we put it in the crawled list. We keep doing this. If we haven't got any pages left to crawl, then we switch them around. But if we have got pages left to crawl, we just carry on with the while loop until tocrawl is empty. Once tocrawl is empty, that means that that level is finished, that depth is finished, and we want to go on to start the next depth, and that's it. In this problem, we've been asked to build a simplified Sudoko checker. In this version, we're given an n x n matrix. In this case n equals 3. We're going to insure that every number appears once in every column, and once in every row. In this example, the 1 appears once in this column, once in this column, once in this column, once in this row, once in this row, and once in this row. We can repeat that check for every digit in the grid. Here's our plan of action for solving this problem. We're going to go through each digit, 1 through n. In this case, 1 through 3. We're going to start with 1, and we're going to go through each row and column at the same time, checking to see that that digit occurs once and only once in each row and column. Here we see 1 appears once in the first row and the first column, so we increment our counts by 1. Then we check the second entry in the row and the column and then the third entry. At the end of checking each entry in the row and the column we check our count and make sure that it equals 1 for both. If either one is not equal to 1, then this grid is not correct. Otherwise, if we go through each digit and see that every digit appears once and only once in every row and column, then this grid satisfies our modified Sudoku property, and we return True. Let's code this up. Here's the finished code for this problem. First we extract the size of the grid by looking simply at the length of the list p. Then we start with the first digit and go through each digit, checking each row and column at the same time. For each entry in the row and the column, we see if that entry equals our digit. If it does, we increment our counts. Otherwise, we just move onto the next entry. Once we go through that row and the column, we ensure that the row count and the column count both are exactly 1. If they aren't then we return False and stop, because the grid has already violated our Sudoku property. Otherwise, we keep going to the next row and the column until we've gone through each row and column for that digit. After we are done with that digit, we move onto the next digit. We go through every digit, ensuring the Sudoku property for each digit. We return True, because there was nothing wrong with the grid, so therefore it passes the test. An important part of being a software engineer is designing good data structures. This question asks us, how do we modify our index so that we can track the number of times users click a link for a given keyword? This allows us to sort the results in our search engine based on how popular the links are. Let's go through the choices one by one and come up with some examples to see the effects those choices can have on an implemented search engine. Given this is an answer choice, it may be a little hard to reason about what it would look like if you actually used it in your search engine, so let's come up with an example. The keyword "andy" is associated with 2 URLs: "udacity.com" and "searchwithpeter.info" and the keyword "irvin" is associated with "udacity.com". And then I have the counts, 5 and 8. Ideally, for this to be useful we want to count the number of times a user clicks the URL given a certain keyword. That way we can sort these 2 URLs based on the counts in order to serve our users better search results. At this stands now, there's only 1 count for each keyword. This might be useful to count the number of times people search things, but it doesn't help us solve our problem, so this is no good. Here I've numerated the second choice. What's useful about this is that we have a count for each URL and each keyword. This allows us to sort these 2 URLs. We can add "searchwithpeter.info" above "udacity.com" when we display our results on the web page because users more often click that link than the other. This seems like a pretty good choice, and it turns out to be the best one so it gets a check. This data structure doesn't really make that much sense. Why do we have multiple counts corresponding to a single URL? You could imagine a use for it, maybe that each count corresponds to a certain period of time, but given what we have here, it's probably not the best data structure for exactly what we want to do and that is just sort the queries results based strictly on the number of clicks. For this one I don't need to even go into an example. This is the same as the first choice, except keyword was moved over a position and count was also moved over. For the same reason as before, namely that we only have 1 count for the keyword instead of for each URL, this isn't the right solution. This question asks us to see whether new code that modifies our web crawler changes the way it behaves, and if so, how does it affect the run time? First let's figure out if the new code acts the same way or produces the same results as the old code. Looking just at addtoindex, we can see that it changes the structure of the index. In the end we're going to get an index that looks like this. This means that we might have the same keyword appear multiple times, but each time it'll appear it'll be with perhaps a different URL. Looking at the lookup procedure, it'll go through the entire index and every time it finds a keyword that matches the one it's looking for, it'll pin the URL to a result list. In the end, you'll get a list of all the URLs. In fact, it'll be the same list you would if you used the original addtoindex and lookup procedures. But now we must ask ourselves, how does this new code affect the run time, the speed at which addtoindex and lookup run? Before, addtoindex had to go through perhaps the entire index looking for the entry that corresponded to the keyword. But in this code all it has to do is append the new keyword and URL to the end. This is faster than searching through the index. Before, lookup would just go through the index until it found the keyword corresponding to this lookup. In the previous case, the lookup would stop as soon as it found the keyword. But now lookup has to go through the entire index no matter what because it doesn't know how many times the keyword appears, whereas before, all it had to do was find the one occurrence of the keyword. So in the end, all things considered, the behavior is the same, but add to index runs faster and lookup will run slower. In this problem, here at Udacity we're trying to upload our videos to YouTube, but we're having a hard time because it's taking a really long time to upload these multi-gigabyte files. What do we need to do to fix this problem? First let's consider latency. Latency is the time it takes something to go from Udacity to YouTube. Well, if we consider the fact that the video is being broken up into smaller chunks, the amount of time it takes to send 1 chunk over is probably going to be on the order of something like 100 milliseconds. Even if we reduce this to 1 millisecond, sending only 1 chunk at a time, considering there are 3 gigabytes worth of data, is going to go almost just as slow. We might save 99 milliseconds. In the grand scheme of things, this isn't really going to fix the problem. Next let's consider bandwidth. If instead we increase the bandwidth of our connection, which allows us to send larger chunks over from our source to our destination, we really solve the problem. Here the latency isn't a big issue compared to the size of the files we're sending, and it's much more important to send larger chunks over than measuring the time it takes a single chunk to go from Udacity to YouTube. So the answer is we want to increase the bandwidth. The last 2 options were based on the content of the video: the number of colors we have and how much bad hair we have in the video itself. While these may affect the file size a bit, it doesn't make that much of a difference. And really, the best way to fix this problem is by increasing our bandwidth. In this problem, we want to be able to split a string by more than just spaces and white space but instead punctuation. This allows us to better index a web page so that we aren't fooled by punctuated text following a word, such as a comma, and instead we are able to search for that word itself instead of the word and the comma. The first thing I do is initialize the output list. This will contain the words separated by the splitlist. With this variable I'm going to keep track of whether or not I am at a point that's a split. This one might make more sense later, so let's keep going. Using the for loop construct like this iterates through the string source 1 character at a time. If the current character is one we're supposed to split on, such as a comma, then we're going to set atsplit to True. If we're at a character that isn't in the splitlist and we're at a split point, we're going to create a new entry in the list. So if we're looking at this example up top, if we just had a space and then we have a T where space is something that we want to split on and T is not, then we want to create a new entry that will contain what becomes the word 'the' instead of appending it on to the previous one after. If we're not at a split point but rather building up a word, such as in the middle of 'After', we simply add the current character to the end of that word, output [-1] finds the last entry in the output list, and we simply append the character using the + operator. Once we've gone through every character in our source string, we return the output list. In this problem, we want to modify addtoindex such that a particular URL appears only once for a given keyword. As the code stands here, if a keyword appears twice in a URL, the URL will be in the index twice for that keyword, if you could follow along. The solution to this is actually really simple and only a single line of code. First let's go over addtoindex really briefly. If we want to add this URL to this keyword in the index, we're going to go through everything in the index, and when we hit the right entry for that keyword, as it stands now, we simply append the URL to the URL list. But we're going to add 1 line of code that says only append to the URL list if the URL doesn't already appear in that list. We also need to fix our tabbing--very important--and that's it. For this question you're asked to record the number of clicks for a URL for a given keyword. So when the URL is chosen for that keyword and the user clicks on it. Now this is so that we have a measure of the popularity for the URL, and so the search results can be ordered on that. In order to do this we're going to have to change the stucture of our index so that we have the count associated with each URL and in order to do that we're going to replace the URL with a list which is url, count. That means that everytime we have the url we have to replace it with a list [url,0] because the count initally will be 0. That changes the structure. What we haven't yet done is taken into consideration the duplicate elements. We're going to do something similar to the previous question where you were asked to remove duplicates. from the index but this time it's going to be slightly different because of this structure of url, count. We're going to check we have the keyword as before then when we have the keyword, we're going to loop through this list here and we're going to check whether each element in the list here, whether the first position in that is our URL. If it is, then we're done - we don't want to add it again to the index. If it isn't there, after we've looped through all of the URLs then we'll add it to the index as before. That takes care of duplicates and the change in the structure of the index what we now need to do is to sort out the clicks. To do this, we're going to look up in the index to find our keyword and that's going to give us all the associated urls. If we've got some urls - well if we haven't got any urls, then there is nothing to do we're not going to be able to click on anything. If we have got some urls if the first position is our url that we're looking for - remember than lookup now return this whole list of url, count pairs so we're just going to have to look at the url, the first entry to see if it matches to see if it matches rather than the whole list and so if it does match then we're going to increment the count, which is the second position by one and that's it. For this question, I'd like you to calculate the time the data spends at routers on its trip between two points. The trace route we're going to take is between me here in Birmingham, England, and Mid Sweden University. Now, because I'm using Windows my tracer route is "tracert" instead of the whole word "traceroute," which was what Dave used on the Mac and also on Linux. This trace route doesn't go directly to Sweden. It actually goes via The Netherlands and Denmark. There we have NL Netherlands, DK Denmark, SE Sweden. Finally it's at Mid Sweden University, and it takes about 75 milliseconds, and we're going to use that value. Traceroute--and remember that that's the round trip time from Birmingham, England, to Sundsvall in Sweden-takes 75 millisends. Now, in order to do this calculation, we're going to need to know the distance. So the one way distance from Birmingham to Sundsvall--now this isn't a direct distance. It's the distance via The Netherlands and Denmark just like the traceroute took. It's about 2,500 km. What you're also going to need to know is the speed of light. That's what we take the speed the data travels at in optical fiber. That's about two-thirds the speed of light, which is 200,000 km/sec. That's the speed that you're going to need for the data between the routers. What I would like to know is what is the total time spent at the routers. If you'd like to enter your answer in the box here. One more thing you might need to know is that there are 1,000 milliseconds in 1 second, and please make sure that you're answer is given in milliseconds. You can give it to the nearest whole number or any number of decimal places that you like. In order to calculate the answer to this question, instead of doing it by hand, I'm going to let Python do the work. What I've done is I've collected together the data from the question, the total time of the round trip for the data, which was 75 milliseconds, the one-way distance, which was 2,500 kilometers, the speed of light in an optic fiber, which is 200,000 km/sec. Note that this is kilometers per second, but the total time is in milliseconds, which means I'm going to need a conversion between milliseconds and seconds. Let's think. What do I need to calculate? Well, what I want to know is the totaltimeat_routers. Working backwards from what I want to know, let's see what I need to calculate. Well, the total time spent at the routers is equal to the total_time minus the timeonthe_wires. How am I going to calculate the timeonthe_wires? That's while it's in the fiber optics rather than actually at the routers. The time on the wires--that's equal to--well, how do we calculate time when we've got distances and speed? Well, it's simply distance divided by speed. Now, what distance are we using? Well, the total timeatthe_routers is equal to total_time. That's actually the time for the round trip, so we need to know how long the data was on the fiber optics for the round trip, which means we need to go twice the distance. That's the one-way distance. We're going to divide by the speed that the data is traveling in the wires, which is the optical speed. Now at the moment, we've got--what have we got here? We've got kilometers divided by km/sec, which is going to give us an answer in seconds. But our times are measured in milliseconds, so that's seconds at the moment, and we want to convert it into milliseconds. We have to multiply it by the number of milliseconds per second. That's our conversion factor, which is milliseconds per second. Let's see what happens--75. That's a bit weird, isn't it? Because the total time was 75. What's gone wrong? Let me just print out here the timeonthe_wires--0. Well, that doesn't make sense, does it? Because it's been somewhere, and it's come back--it can't have taken 0 time. What's the problem here? Well, the problem is this division. What we have in Python--at least before version 3--is that division is integer division. So if the number is less than 1, which it will be here, because onewaydistance is only 2,500, and we're dividing by 200,000. Python just rounds it down to the nearest integer, which is 0. In order to deal with that, I'm just going to make it into a float, which means that it does division normally and gives an answer which is a decimal. You can convert all of these into floats, but really we just need to do one of them. If I run it now, I find that the first value here--25--is the amount of time on the wires, and the totaltimeat_routers is 50 milliseconds. You need to be a little bit careful to make sure that you're doing float division. Float is just decimal division instead of integer division. Welcome to unit 4! Unit 4 will be a little different from previous units. We are gonna start in right away by finishing the code for the search engine. What we have built so far is a web crawler. It can follow content on web pages, following links to find other pages, but it doesn't actually respond to queries. What we are going to build in this unit is a search engine, where we can pass in a keyword and get a list of the pages that contain that keyword. We are also going to learn how the Internet works and the World Wide Web. The main new computer science idea in this unit is the idea of how to use and build complex data structures. In order to respond to queries quickly, we want to be able to have a data structure where we can look up a keyword and quickly find the pages that match that keyword, without needing to scan all pages every time. To do this we are going to build a structure called an inverted index, or often just - an index, that allows us to have a mapping between keywords and pages that contain these keywords. Our index is really the same idea as an index in a book. I happen to have a book handy. That is one of my favorites. I might be a little biased, since I wrote it. But let's take a look and see if there is anything in the book that would help us understand index searching. We could try to read the whole book, see if there is anything about index search in here, or we could go to the index, and if we are lucky, the index will have what we have, it's got "index search". As each keyword in the index it has the page number, so we would go to the page number where that is found, and instead of needing to read the whole book to try to find what we are looking for, if we can find the right page, we will find the section on index search right away. So that's the goal of an index. For our search engine what we want is an index that provides a mapping from keywords to list of webpages where that keyword appears. So now we're ready to think about how we should represent the index for our web content corpus. And we're going to have a quiz to see if you can think of a good way to represent our index. So I'm going to give you several options. And try to decide which one you think would be the best way to represent our index. And I should note that several of these could work. We could build a search index using different data structures, and if we tried hard enough, we could make many of these possibilities work. But I want you to think hard about what's going to be the best one to use. So the first option is we could have a single list where we have a keyword followed by the URLs where that keyword appears followed by another keyword followed by the URLs where that keyword appears. The second option would be we would have a list containing as its elements lists. And each element would be a list of the keyword followed by the URLs where that keyword appears. The third option, we could have a list where each element of the list is a list where the first element is the URL, and the second element is a list of all the keywords that are found on that page. The fourth choice is a list where each element is a list and each element list is a keyword followed by a list of all the URLs that contain that keyword. So see if you can decide which one of these four representations will be the best one to use to represent the index for our web content corpus. So the answer that I think is best is choice four. Choice two is pretty good. But I think choice four is a little bit better. Choice one and choice three would be really difficult. So let's look at how these look to see why choice four is the best choice. So I need to shrink the choices to have a little more room for drawing. So here's what option one would look like. We have a single list and the elements of the list are keywords. Each keyword is a string and the keyword is followed by the URLs where that keyword appears. So for option one, we have a list, and it's a single list containing strings. Each string is either a keyword or a URL. And we have the keyword followed by the URLs where that keyword appears. This seems nice and simple. There's only one list. There are two real big problems with it. The first problem is it's hard to tell the keywords apart from the URLs. Maybe in this case we would say "well, anything that starts with HTTP is a URL" -- that's a well-formed web link-- and anything that doesn't is a keyword. But we could have keywords that start with HTTP as well. and then we couldn't tell which was which. The other really big problem with this representation is it's very hard to loop over the keywords. To find the next keyword, if we start from keyword one, we don't know which position to look at. There are different numbers of links that each keyword might have. And we'd have to search through every element to try to decide whether the next thing is a URL or the next keyword. So this is not going to work very well. So option one is definitely a bad idea. So next let's look at option three, which was the other one that I said really would be very difficult. So with option three we have a list where each element of the list is itself a list. And the element lists are lists where the first element in the list is a URL. The second element in the list is a list of keywords. So that would be a list of the keywords that appear at that URL. So this has more structure than the first choice. We can tell apart where the URLs are-- all the URLs are the first elements of these lists-- and where the keywords are, which are all contained in the second element of the contained list. The problem with this approach is it's not going to make it easy to look up the pages where a keyword appears. This almost like having to scan all the pages over again. To look for a particular keyword, we've got to look at each entry, look in the second part of that entry, scan it to see if that keyword appears. If it does, well then we want this URL in our result. If it doesn't, then that URL is not in the result. But to find particular keywords, we've got to look through each entry and look through all of the keywords in that entry. So this option is not going to work very well. Our goal in making the index was to be able to make look-ups fast so we don't have to look through all the content of the pages, and this representation doesn't solve that problem. So we have two choices left, and I said both of these choices could work okay. But I think the fourth option is the best one. So let's look at why. So this is option B. We have a list where each element of the list is a list. And the element lists are themselves lists which contain the keyword followed by URLs where that keyword appears. This has a big advantage over the first two options. It means it's easier to tell the keywords from the URLs. The keyword is always the first element of the list. And unlike the previous option, it's also easy to go through the keywords. For each list contained, we just need to look at the first element to see if that's the keyword we're looking for. If not, we go onto the next one. We don't need to look through all the content in all the web pages. We just need to look at the first element in these lists to find the keyword we're looking for. So that's okay. The reason that I think option D is better, is that it makes a better separation between the keywords and the URLs. So the difference between this and option D is in option D instead of the inner lists being flat lists that are the keyword followed by the URLs, the inner list has just two elements. It has the keyword followed by a list of URLs. So that will be another list, and now we have a list of URLs. So this is option D. Each element of the main list is a list. And it's a list that just contains two elements. It contains the keyword--here the keyword "udacity"-- followed by a list containing all the URLs where that keyword appears. The reason I like this better than the second option is that it really makes a clear separation between the keyword and the list of URLs. It means if we decide we want to keep track of something else --say we want to keep track of the number of times someone searches for each keyword-- we could easily do that. We could have an extra element here that keeps track of the number of times someone searches for something. With option B, it wouldn't be that clear how to do that. Maybe we could add an extra value in here--we could add a number in here. We would need to change a lot of code that we already wrote. Instead of looking for URLs starting from position one, we'd have to start from position two now. Maybe we should put the number at the end to avoid that problem. Well then we have the problem of we've got to find where the number is. There are easy ways to find the last element of a list. But it's going to make things much more complicated. And if we start adding more and more things, we're going to have a hard time keeping track of everything. Option D gives us a lot more structure. By keeping all the URLs in a list, we can treat that as a list and do things with it much more easily than if it's combined with a keyword. And we can also do things like add extra elements if we want to keep track of the number of times someone searches for that keyword or any other information we think of later that would be useful to add to our structure. So that's why I think option D is the best option. And deciding on data structures is one of the most important things we do when we build software. If you pick the right data structure, oftentimes the rest of the code is fairly easy to write. If you start with the wrong data structure-- say we started with the structure that was choice A or choice C, well then it's going to be very very difficult, sometimes it's going to be impossible, to write the code in a way that performs well. So thinking about data structures is one of the most important things we do in computer science. We'll see that some more in this course. We'll also have following courses that really focus on this question of how to design and use data structures well. Now that we've decided on our data structure, hopefully it will be easy to write the code for building our index. I think you actually know enough to be able to write the procedure that adds new entry to the index. Your goal for this quiz is to-- Define a procedure--we'll call it add to index-- and it takes 3 inputs. The 1st input is the index that we want to add the new keyword and URL to. Remember that we decided in the previous question-- that the way to represent index is as a list where each element of the list is itself a list and each of the element list is a keyword followed by a list of the URLs where that keyword appears. The 2nd input, is a keyword--that's just a string-- that's the word that we want to add to the index-- and the 3rd input is the URL-- which is a string that encodes the URL where that keyword appears. So, what add to index should do, depends on whether or not the keyword that's passed in is already in the index. If the keyword is already in the index, we don't want to create a new entry in the index for the keyword. We only want to have that keyword appear once-- what we want to do instead is add the URL to the list of URLs already associated with that keyword. So, if the keyword is not in the index, what we need to do is add a new entry to the index, and that new entry will be a list with the keyword, that's the new keyword, and the list the list of URLs where that keyword appears. This is the first one, since it wasn't already in an index, so, it will be a list containing just one URL. That's the list that we want to add to the index to represent that we found this keyword at this one URL so far. Let's work through an example-- Suppose we start by initializing an index to the empty list-- we have no entries in our index yet-- Then we'll call add to index, adding a new keyword, passing an index as the 1st input, for the 2nd input we need a keyword let's use the keyword udacity-- and for the 3rd input we need the URL where that keyword appears. So, here's what we should have-- 1st we create index, we're initializing it as an empty list, we don't have any elements yet-- then after we call that index, we're going to add an element to the index list--- we've mutated index--now it contains element-- that element is a list containing the string udacity as the keyword-- the 2nd element of that list is itself a list containing one element-- which is the string "http://udacity.com" That's the new value of index. If we call out to index again, this time we're passing an index again-- it's the value that index refers to which is the structure-- now the keyword is computing, and we're passing in as the URL "http://acm.org" That's going to mutate index again. We're going to follow the rule here, the keyword is not in the index, so we should add a new entry. That means we are going to append a new entry to index. That new entry is going to have the keyword computing. As the second element we have a list, and this list will contain the URL we passed in, which is acm.org. I am going to show you one more example. In this case, we're going to pass in a keyword that is already in the index. We're calling out to index again--passing in the keyword udacity-- which is already in the index here-- and passing in a new URL, which is not in the index. What should happen this time-- we're going to mutate index, but instead of creating a new element-- we're going to mutate the element we already have-- we're going to look for the entry that matches udacity-- it's already in the index, so don't want to add a new one. What we're doing is following the 1st rule here-- that says if the first word is already in the index-- what we want to do is add new URL to the list of URLs associated with that keyword-- but we don't want to add any new entries to the index itself. Here's what that will look like-- we're adding to the list of URLs a new entry-- that's the new value of the URL. I hope it's clear now what add to index should do. I think you know enough to be able to define it yourself. That's the goal for this quiz, for you to define the procedure-- add to index that has this behavior- it takes the 3 inputs and adds a new keyword to the index. There are different ways that we can define add to index, here's one way that works. We're going to create a procedure, we'll call it add to index-- and it takes our 3 inputs--the index, the keyword, and the URL-- What we need to do in add to index is first find if the keyword already appears. To do that, we need to look through all of the entries in index. The natural way to do that is to use a 4-loop. We're going to define the procedure add to index-- and it takes our 3 inputs, index, keyword and URL-- to help keep track of what we are doing, I am going to draw a reminder of what the data structure of index is. Remember that it is a list of entries, and each entry is itself a list, where the 1st part is a keyword, and the 2nd part is a list of URLs. That's our data structure, that's going to help us figure out what to do to define add to index. The first thing we need to do is to check whether the keyword already exists in the index. If we can find it, well, then we want to modify that entry, rather than creating a new one. The natural way to do that is to use a 4-loop. We are going to loop through the elements of index. We will give each one the name entry to use in the block. This is what entry will be. The first time through the loop, the value of entry will be a reference to the list here-- which is the first element of the index list. Now we need to find the keyword. The keyword is right here--that's the element at position zero of entry. We're going to test the value at position zero on entry identical to the keyword that's passed in we'll use the double-equal comparison to test that-- If it is equal, then we found a match-- this means we want to append the URL to the list of URLs associated with that entry. To get that list of URLs we want to find entry 1--that's the value at position 1 of entry-- and we want to append that the new URL. Here we've found an entry that matches the keyword we were looking for-- this means the keyword is already in the index-- we've added the new URL to the URLs associated with that keyword-- so we're done, we have nothing else to do. What we want to make sure, is that we don't continue and and do anything else. One approach would be to use break---that would end the loop-- what we want to do instead is really end the whole procedure. If we did break, well, then we'd still have the problem of how do we deal with the case where the keyword wasn't found? Here we're just going to return-- we're all done with add to index, we've added the URL it belongs. Now we need to think about what to do in the case where the keyword does not already exist in the index. If that's the case, then we get to the end of the loop without ever finding that entry. If we've got to the end of the loop, that means we did not find any entry in the index that matches the keyword, then what we want to do is add a new entry--- and that new entry is going to have, as its value, a list containing 2 elements, it will be the keyword-- and as the 2nd element we'll have a list containing the URLs that we found that have that keyword. So far we only have 1--the URL that was passed in to add to index. How do we do that? To add a new element to add to index we use append. We need something to pass in to append--that is the structure we want to add. This whole thing is what we want to add-- so, that's a list containing the value keyword as its 1st element. As the 2nd element, its a list containing just the single URL. That's what we want to append. in the case where we didn't already find the keyword in the index. So now that we can build an index, we'll want to use it. We'll want to use it to respond to queries. If you understood how the add to index code works, I think you'll be able to write the query code yourself. So the lookup procedure takes 2 inputs. The first is an index, and that's the data structure we've been working with. It's a list where each element of the list is a list containing a keyword and a list as its second element, and that list is a list of URLs where that keyword appears. The second input is the keyword to lookup. That's what we're searching for. So the output of lookup should be a list of all the URLs associated with the input keyword. So as an example, we constructed the index here where we've added 2 URLs with the keyword udacity. The result from doing a lookup on the keyword udacity should be a list containing those 2 URLs. We should be concerned what happens if the keyword does not exists. If the keyword doesn't exists, well there are no URLs associated with that keyword. So we would just return an empty list. So see if you can define the lookup procedure. So here's a way we could define the lookup procedure. It takes 2 inputs, the index and a keyword. And as a reminder, I have drawn the structure of the index here. It's a list, each element in the list in an entry. Each entry is a list itself. Where the first part of the list is a keyword. The second part is a list of URLs. So what we want to do to the fine lookup is very similar to what we did for add to index. We want to go through the entries in the index to try to find one that matches the keyword. So letÃ¢Â€Â™s write that again. That's going to be a for loop, and it's going to be exactly the same code as we had before. So we are going to look through the elements in the index each time we go through their loop. The variable entry will refer to 1 of those elements. We're going to check if the value in position zero, which is the keyword of that entry, matches the keyword we're looking for. When we we're defining add to index, what we did when we found a match was to pin the URL to the list of URLs associated with that keyword. What we want to do for lookup is different. All we need to do for lookup now is return the list of URLs. And we can find that by looking in position 1 of entry. If we get to the end of the list without finding that keyword. Well then we still need to return something and the way we describe lookup, what it should return is the empty list. That means there are no URLs that we've found so far that contain that keyword. So now we're ready to build the Web index. We're going to use the split operation to do this. So we can certainly build a way to separate all the words in a Web page ourselves using the operation we've already seen. We can use indexing to go through the letters in the string We can identify characters that we think of as separating words such as a space or a comma. And we can collect those all as separate strings. The good news is Python provides a built-in operation that does exactly what we need. It's called split. We invoke split on a string and what it outputs is a list of the words in the string. For now we're not going to worry too much about the details of how split decides how to separate a string into words, but let's look at a few examples to see that it does something pretty close to what we want for building our Web index. So we've defined quote as a string which is this quote from Robert Reich. "In Washington it's dog eat dog. In academia, it's exactly the opposite." And now we'll use split to divide the quote into its words. And you can see the result. We have a list where the elements of the list are the words from the quote. And split does a pretty good job of dividing the string into the words that we want for our Web index. It's not perfect. We can see that Washington, which was followed by a comma in the quote, ends up as the string Washington including the comma. That's a different value than the keyword Washington. So if we search for Washington and we built our index this way, we're not going to actually find this occurance. So this isn't perfect, but it's going to be good enough for what we use for now. Later on we can think about ways to divide the Web page into its component words in a way that will be more accurate. Figuring out exactly how to decide when something's a new word is a fairly tough problem, though. As a second example to get a feel for how split works, let's try another quote. Here we have a quote from David Letterman. "There's no business like show business, but there are several businesses like accounting." I've introduced a new Python constrict. We're using the triple quote here. The nice thing about triple quotes is that we can divide them over multiple lines. When we tried to enter the previous quote using just the double quotes, it fell off the edge of the screen. Using triple quotes, we can define one string spread over multiple lines. And now when we print out the result of splitting the quote, we see it's divided into words. It's fine that there are new lines. It still separating it into the words we have. We still have some issues, like the parentheses is included as part of David. So this quote wouldn't show up for the keyword David. I'll leave it for you to decide at the end of the class whether computing is a business more like show business or business more like accounting. I'm going with show business, though. So now let's see if you can write the code to build an index using the URLs collected from our Web problem. For this quiz, your goal is to define the procedure add page to index that takes 3 inputs. The 1st is the index, and I've drawn a picture of index to remind you of its structure-- and it's a list where each entry in the list is a list containing a key, and the list of the URLs where that keyword is found. The 2nd input is the URL-- so that's the location of the page, where the content came from-- And the 3rd input is the content. That's the entire text of the page at that location where URL is. The results should be updating the index to include all word occurrences found in the page content by adding the URL to the words associated URL list. I'll show you a few examples so it is clear what add to index should do, and then you'll have a chance to define it yourself. We're going to start with an empty index-- and we'll call add page to index-- and let's print out what index looks like after this-- it's a little hard to see like that, so let's see what index position zero is. We can see that the keyword this appears at the URL "fake test" if we print index at position 1 we'll see the same thing, but this time for the keyword is. We have an entry, we have an index, we have 4 words in our index this is a and test and for each word, the list of URLs where each word appears is fake.test which is what we passed in as the URL here. Let's try adding some other things to our index. This time, we'll add a page called real.test. and have the content of the page be this is not a test. Now, when we run this, we see this index if we look at a particular element--let's look at the element at position 2-- it has 2 entries in its URL list-- since both of the pages we passed in contain is-- and if you look at index position 4-- we see that for the word not--that only appears on the real.test page-- so there's only 1 entry in it's URL list. We already defined the procedure for respond to new query. So, that should work on this index. Let's try. Look up takes the index and the keyword and returns the list of URLs at that keyword. Delete the previous tests, and see what happens when we look up is, we see that it occurs on both pages-- if we look up udacity--it doesn't occur anywhere so far. I hope it's clear now what add to index page should do-- see if you can write the code to define add page to index. Here's one way to define add page to index. We're defining a procedure that takes in 3 inputs-- the index, the URL and the content at that location-- We use the split method to divide the content into its component words. We store that into the words variable. Then what we want to do is go through all of the words, adding each word into the index. We can do that using a 4-loop. We're going through all of the words, we'll use word as our variable. For each word, we call add to index, pass in to index the word and the URL. Note that if a word occurs more than once on the same page, we're going to keep adding it to the index each time. There might be more than one occurrence of the same URL in the list of URLs associated with a word. Depending on what we want our search engine to do, and how we are going to decide on how to respond to queries, this might be a good thing or a bad thing. We'll talk more about that in a later class. Let's try this in the Python interpreter. Let's recap the code we already wrote-- we have the add to index procedure-- that takes in the index, the keyword and the URL. It goes through the entries in the index, and it appends the URLs to the entries that matches the keyword. If it's not found, it adds a new entry to the index, that's the list of the keyword, and the single URL. We defined the lookup procedure that takes the index and the keyword, finds the entry in the index that corresponds to that keyword, and returns the URLs associated with that keyword. So, now we're going to define the add page to index procedure. So, here it is, we're splitting the content into it's component words, we're looping through the words, and we're adding each word to the index-- note that we don't need to return anything-- the point of this procedure is to modify the index. Let's try add page to index with a few simple examples. Here we have the test we tried before-- we see that we get the expected result-- if we're adding the first quote to the index, we see that there is the 4 words in the quote each has the list of pages associated with it--the list of URLs contains fake.test. Then we added the 2nd page, the 2nd print we see, now for most of the words we have both fake.test and not.test except for not, which only has not.test. So, to be really convinced that this works, let's try a few more interesting examples. Now we're going to add page to index that might be on the dilbert.com page-- this quote from Scott Adams about time management-- "Another strategy is to ignore the fact that you're slowly killing yourself by not sleeping and exercising enough that frees up several hours a day, the only down side is that you get fat and die." Hopefully that is not happening to anyone in this class. I know that it's a lot of work, but you need to manage your time so that you're still getting enough sleep and exercise. The second quote we'll add to the page index and we'll give the URL randy.pousch for that. And it's a quote that says "Good judgement comes from experience, experience comes from bad judgement. If things aren't going well, it probably means you are learning a lot and things will go better later." So, hopefully things are going well in this class, but if they're not, that means you're learning a lot and hopefully things will go better later. Let's see what the index looks like after adding these 2 pages. You see that it is pretty big, there are a lot of words in those 2 quotes. We can see that some of them only appear at dilbert.com and from the quote from Scott Adams on time management-- others appear on both pages-- We'll see more if we try a query. Let's try a query. We'll look up in our index to see where the word you appears. And when we run that, we see it appears in both documents. It was there in the dilbert quote twice, it was listed 2 times at the URL dilbert.com and once and the Randy Pousch URL. Just to confirm, the 2 occurrences in this quote, there is one here--and there's one here. And there's one in the second quote right here. If we look up another word, we see good did not occur in any of the quotes, but bad appeared in the 2nd one. So, it looks like all the code that we have seems to be working. We can look up words that are indexed and get the list of URLs where they were found. We can add pages to our index. And we can record all of the words in that page at the location they occur. We're really close to having a search engine. The one thing that we have left to do is to connect the code we already wrote for crawling the web to the code that we have for indexing documents and looking up the keywords. It's been awhile since we looked at the code for crawling the web. Let's look at that again and see if we can think how to connect the two. So let's remember the code we had at the end of unit 2 for crawling the web. So we used 2 variables. We initialized "tocrawl" to the seed, a list containing just the seed, and we're going to use "tocrawl" to keep track of the pages to crawl. We initialized "crawled" to the empty list, and we're keeping track of the pages we found using "crawled." Then we had a loop that would continue as long as there were pages left to crawl. We'd pop the last page off the "tocrawl" list. If it's not already crawled, then we'll union into "tocrawl" all the links that we can find on that page, and then we'll add that page to the list of pages we've already crawled. So now we want to figure out how to change this so instead of just finding all the URLs, we're building up our index. We're looking at the actual content of the pages, and we're adding it to our index. So the first change to make, we're updating the index, and we're going to change the return result. So instead of returning "crawled" what we want to return at the end is the index. `If we wanted to keep track of all the URLs crawled, we could still return "crawled" and return both "crawled" and "index," but let's keep things simple and just return "index." That's what we really want for being able to respond to search queries. So now we have one other change to make, and this is the important one. We need to find a way to update the index to reflect all the words that are found on the page that we've just crawled. I'm going to make one change before we do that. Since both "getalllinks" and what we need to do to add the words to the index depend on the page, let's introduce a new variable and store the content of the page in that variable. This will save us from having to call "get_page" twice. "Get_page" is fairly expensive. It requires a web request to get the content of the page. It makes a lot more sense to store that in a new variable, and that will simplify this code. So now we just need to pass in content. So we have one missing statement, and I'll leave it to you to see if you can figure out statement we need there to finish the web crawler. When it's done, the result of "crawl-web," what we return as "index" should be an index of all the content we find starting from the seed. So the answer is we should use the "addpageto_index" procedure we just defined, and we should pass in the index. We should pass in the page, that's the URL that identifies the location, and we should pass in the content. And that's all we need. So we're done with our web crawler. >From a seed, we can find a set of pages. Following that seed, following all the links that we find on the pages that we find starting from that seed, for each page, we're going to add the content that we find on that page to an index, and we're going to return that index. And we've already written a code that given the index, can do a lookup. So for any word we want to look up, we'll find the list of URLs for the pages that contain that word. Congratulations, you've now got a working search engine. You can crawl the Web, finding content from pages, building an index, and then respond to search queries with the pages that contain that content. This is really exciting. I think I'm ready to start my search company. Cool. And so I was looking at the competitors out there, and the key is that you've got to have a catchy name. So Google, Duck Duck Go. I've got to come up with something. This is the really hard part. Yeah. I'm ready to announce -- I'm ready to share with you my idea. I've been putting a lot of thought into this. How about Search With Peter dot Info? Oooh. Yeah. So there's a lot of work to do. I've got to buy servers. I've got to get employees. Investors. I've got to -- Oh, man -- I should probably start now. Okay. Well, good luck to Peter. There are some more things that we want to learn in this class. And there's some things we need to do to really improve the search engine to make it useful. In Unit 5 we'll work on making the search engine faster. And in Unit 6 we'll work on making it find the best page for a given query, not just all the pages. So for the rest of this unit we're going to look at understanding more how the Internet works and what happens when we request a page on the World Wide Web. So now that we've got our basic search engine working, for the rest of the unit, we're going to learn more about how we actually get web pages on the internet. So far we've been using the magic get_page function. And we provided this function that takes as its input a URL, which is a resource locator on the web, and it produces as output the contents of that page. I can show you the Python code that we use for get_page. It won't really help very much in terms of understanding what's going on, on the internet. But I don't want you to think there's anything hidden here. So the main thing that we're doing in get_page is we're returning the result of calling URL open, passing in the URL. So that opens the web page that was requested. And then reading that page. And that returns the output of that page as a string. This is provided by the Python library urllib, so we needed to import that library. And so that's what's going on. The rest of this is an exception handler. So we call this a try block. That we are going to try these things. They might not always work. And this is where we use try. There might an error. Maybe the URL is bad. Maybe we don't actually get a page back. Maybe the internet request times out, doesn't always work even if its in the URL. So that's why you put this inside a try block. And if something fails, execution will jump to the except block. This is called the exception handler, and in this case we just return an empty string. So that means if we request a URL that can't be loaded instead of getting an error it will just return an empty string, and for the use in our web crawler this is a good thing. If we didn't do this then the WebCrawler would have to deal with a case where the page doesn't exist. In our case we just get an empty string, so there's no content on that page. So looking at the actual code for get_page doesn't really help us understand much about what's going on when we request a webpage. All the actual work is hidden in this Python library function. So in order to understand more about what's going on, we need to understand more about how the internet works. First Im going to talk about networks in gerneral. The internet is just a special kind of network. There are lots of different ways to define a network. We are going to use quite a precise definition. So we are going to define a network as a group of entities. And entities could be people, they could be computers, they could be organizations, they could be governments, that can communicate, even though they're not all directly connected. So here's an example to show what that definition means. So we have Alice. And we have Bob. And Alice and Bob know each other, and can talk to each other. The way they talk, we can call the channel. That could be just talking in person. That could be talking over a telephone. We're going to say that just this is not enough to be a network. This is just two people having a conversation. If we had the second scenario, we'll say we have Alice, Bob and Charlie. And Alice can communicate with Bob. Bob can communicate with Charlie. And Charlie can communicate with Alice. But they can do all this directly. They're all directly connected. If Alice wants to talk to Charlie, well, she has a direct link to Charlie. She doesn't need to use Bob. There's no way to communicate other than across these direct links. So even in this case where there are three people who can all communicate we're still going to say that's not a network. Many people would call both of these networks. We're going to use a somewhat more precise definition where neither of these will be considered a network. What will be considered a network is this third example and in the third example we have three nodes. We have Alice, Bob, and Charlie let's say. They're the three people but now Alice is not directly connected to Charlie. But there's a way that Alice can send a message to Charlie. And she can send the message, because Bob will forward the message for her. Once the message goes through two hops, to make it so two people are not directly connected, can communicate. And maybe Charlie can also send messages back to Alice. Then we call it a network. So that's going to be our definition. There has to be at least three entities and there has to be a way that entities that are not directly connected can still communicate. So to see that you understand that definition of a network and maybe also know a little bit of world history we're going to have a quiz. So here are the possible answers. Ten years old, 30 years old, 100 years old, 1000 years old, or over 3000 years old. So the answer is over 3,000 years old. Humans have been using networks like this since at least as long as we can record. They might have just been networks where people talk to each other, but even networks where they were using technology to communicate, in this way, go back at least 3,000 years. So to give you an idea of how sophisticated networks could be over 3,000 years ago, here's a quote from Homer's The Iliad, where he's talking about the network the ancient Greeks had. And they had a line of beacons spread over the Greek islands. They could use that to send messages, to warn the neighboring islands when there was an enemy attacking, and that would tell them to bring in their ships, that trouble's about to occur. And Homer was writing this around 800 BC. But what he was describing are wars that happened over 3,000 years ago. And Homer wasn't just making this up. The Greeks actually had such a network. They had a network where soldiers could light a fire on one island and soldiers on another island would see that fire. Light their own fire that would send a signal to the next island. The next island would see that and light its own fire. And they could send messages over great distances this way. They could send a message over 600 kilometers across the Greek islands. So what do you need to make a network like this? So now I really went to art school. I thank Amy for the Greece drawing. So what does it take to make a network like this work? So let's suppose we wanted to send a message from Rhodes to Sparta, and we have many points along the way where we can send smoke signals. So we'd start by sending a smoke signal from Rhodes. This would be visible from a few other points. And to reach Sparta, the one at Noxos would need to resend it, would need to also submit it as smoke signal that would be visible at some other points. The one at Melos would need to see it and resend it. And maybe that's already visible at Sparta. So we need several different things in order to make a network like this work. The first thing we need is a way to encode messages. We need to be able to convert the message that we want to send, say it's a message that says the Trojans are arriving. We needed to be able to send that message and encode that in a smoke signal. We need a way to do routing. We need to figure out where the message should go. If we want to send it to Sparta, we need to know that it should be forwarded by these nodes. The node that sees it from Miletus does not need to resend it. Probably the way the ancient Greek network worked, all the nodes resent every message. They didn't have a way to do routing selectively. But that's very wasteful. What we'd like is a way to only send the message to the destination it goes to. For the kinds of messages the ancient Greeks were sending that says things like the enemy's arriving, well, it was okay. You wanted to send it everywhere, that's called flooding the net. But if we want to send messages just between two points, we've got to know which nodes should resend the message or which direction to send it in. And the final thing we need to worry about is, we need to decide who gets to use the network. So it might be that there are more than one enemy arriving at once or maybe, the enemy is arriving, it might be at the same time. Achilles, say Achilles is in Mellitus, and he wants to send a message back to Medea in Delphi. So maybe Achilles wants to send a message that would go like this at the same time as the army needing to send this important message that's saying the Trojans are arriving. So we need to figure out who gets to use the network and what they get to send. So, these are all things the ancient Greek network would have had to deal with if it was sophisticated enough to worry about them. If it was just sending the message that says the troops are arriving, well, that's one smoke signal and it didn't necessarily need that. All of these are the same things that we need to worry about if we want to send messages on the internet. So these are the things that we need to make any network. We need some way to take the messages that we want to send and encode them in a way that they can be transmitted, and interpret them when they get to that other end. For the Greeks, the message was something like, Agamemnon is arriving, get the ships to a safe place. And they needed to encode that in a smoke signal. We need a way to route messages. We need a way for the receiver of this smoke signal to know the next place to send it. And for the Ancient Greek network, since smoke signals are not directional, they just go up in the air, there wasn't much to do here. Everyone could see the message and they wanted to send the message everywhere. If we want to send messages just between two points, this becomes a much tougher problem. We need rules for deciding who gets to use resources. If there are two messages that want to go through the same place, well, only one of those can be sent at a time. We need some way to decide when. For the Greeks, well, I don't know what their rules were, but let's assume their rule was, if you're a general, your message has priority. We needed all these same things for the Internet. Before we talk about how they are done on the Internet, I am going to introduce the two main ways that we measure networks. I want to talk about the two main ways to measure a network. Those are called Latency and Bandwidth. What they mean is very different. They're often confused. Often people say bandwidth when they mean latency, or say latency when they mean bandwidth. They're quite different things. So let me explain what they are. So latency is the time that it takes for a message to get from the source to the destination. And that's for the start of the message. So, we can measure latency by timing when you start sending to the time that the receiver starts receiving. So this is the unit of time. It will be measured in something like seconds. For a fast network today, it's more often measured in milliseconds and there are 1000 milliseconds in one second. So now, you understand about latency. And when I go back to the Greek signaling network. So, suppose now that Zeus, who is all powerful, wanted to send a message from Rhodes to Sparta. And he thought that the latency of the smoke signal network as it was currently set up was too high, that it takes too long for the message that he sends starting from Rhodes to reach Sparta. So the question is, how could Zeus, and remember that in ancient Greece, Zeus was all powerful, reduce the latency between Rhodes and Sparta. So here are the choices. It makes the signalling nodes further apart. So instead of going from Rhodes to Naxos to Millios to Sparta, maybe it would have to go one hop. There would be a new island in the middle here, and it could go from Rhodes to the new island and then to Sparta. He could threaten the soldiers at all the signalling points and scare them into working harder, so they start the fires more quickly, when they need to send a message. He could find a way to make it so instead of just sending one color smoke, you could send different colors smoke. That would mean that with the same amount of smoke, you could send more different messages. Or he could increase the speed of light. That would mean that the the soldiers at each signaling point would see the previous smoke signal more quickly than they do now. So three of these would reduce latency. The first one is correct. That would reduce latency because every time you go through a hop, well there's some time delay there. That you need the time for the troops at the hop to see the message that came in and then to start their fire to send the same message on to the next hop. So if you have fewer hops its going to take less time for the message to get across. You could reduce the time it takes to go through each hop. So, if you can make the soldiers at each node work faster, it would take less time from the time that they see the message to the time that they send it on, which is the time when the next person will see it. So, the total time to get across the network would also be reduced. The third choice does not reduce latency. So adding colors would allow you to send more messages, but it doesn't reduce the time it takes for a message to get across. And we'll see next that what adding colors would do would actually increase the bandwidth of the network. But it doesn't improve the latency at all. And finally, because Zeus can do things that most people can't, other than possibly physicists in Switzerland. If you could increase the speed of light, well that would make the network faster. Not a very realistic option and it wouldn't make it much faster because of the transit time even with the regular speed of light, the time it takes for the light to travel between the points is infinitesimally small compared to the time for all the other things like starting fires. But all three of these would in theory reduce the latency. The adding colors would not reduce the latency, but it would increase the amount of information that Zeus could send between those points in the same amount of time. And that's what we call bandwidth. So adding colors wouldn't increase the latency, but it would increase the bandwidth. What bandwidth means, is the amount of information that can be transmitted per unit time. And it doesn't matter if there's a start-up time. Right, the start-up time is the latency. That's how long it takes to start sending a message across. That's how long it takes for the start of the message to be received. The bandwidth is, once you've got some part of the message across, what's the rate that you can send information? So, this is going to be measured in terms of units of information divided by units of time. So bandwidth could be measured in terms of bits per second. On the Internet this is often measured In Mbps, which is megabits per second or million bits per second. I haven't yet explained what a bit is, and in order to understand information, it's important to understand what a bit is. So, what's a bit? And a bit is the smallest unit of information. So suppose I tell you that there are two boxes. There's a green box and a blue box, and in one of those two boxes, there's a gold star. And it's equally likely to be in either the green box or the blue box. One bit is the answer to one yes or no question. So if you ask one yes or no question, you ask, is the gold star in the green box, then you get one bit back as the response. You get an answer that's either yes or no. And when you learn which one it is, that's one bit of information that allows you to go from having two choices down to one choice and then you know, well, if the answer was yes, the gold star's in the green box, that's the one you should open. So when we think about bits in computing, we don't usually call them yes or no. We call them 0 and 1. 0 more readily maps to no, and 1 to yes. So I switched blue and green here. But we could pick any two things. We could use green and blue. We could use yes or no. If we have two things And we can choose one of them. Knowing which one to choose is one bit of information. So that's what one bit can do. It allows us to decide between two things. For the ancient Greeks network, maybe that's all it could transmit. There was either the no bit, which said there weren't any enemies arriving. Or if there was a smoke signal, that was one bit saying, yes there is an enemy arriving. So it's possible if it was only able to transmit that 1 message, that it only conveyed 1 bit of information. If all we can do is send bits, we can send either a 0 or a 1, or a yes or a no. But let's think of it as 0 and 1s now. Can we send anything more interesting? Can we just send one thing? And it turns out that we can actually send everything that we want, just using bits. So instead of just picking between two boxes, now let's suppose there are four boxes. So let's say, there's, a purple box, and there's a dark red box. So now there're four boxes. There's still only one gold star. So can we figure out which box the gold star is in with just yes, no questions? Well one way to do that would be to ask for a question, right? We could say is it in the green box? We could ask is it in the purple box? We could ask is it in the blue box and as long as we there is at least one gold star. We don't really need to ask if it's in the dark red box, because if we got news for all three of these well then we know the answer to that next question, if we asked if it was in the red box, would be yes. So here we needed up to three questions, to figure out which box the gold star was in. Can we do better? So the question is, how many bits do we need to find the gold star? And remember each bit is the answer to one, yes or no question. And we have four possible boxes and the gold star could be any anyone of those four. So we saw that if we ask these three questions. Well we needed three questions to be sure that we will find the gold star, by opening box, but we don't need three questions. If we are little smarter about our questions, we only need 2. And the way to do it in 2 questions is to ask for questions that gives us more information. So the problem with asking is that is it in the green box question first? Is that three 3 4 of the time? The answer is no. And if we're trying to use yes, no questions. Or we're trying to use bits to get as much information as possible, what we want to do is ask questions where the answer is equally likely to be yes as it is to be no. We want a question where half the time the answer is yes and half the time the answer is no. If the question isn't like that, so if it's a question where it's no more often than it's yes, well then we could guess the answer is no and be right more than half the time. So we're not getting a full bit of information in the result, because we had a good chance of being right without getting that answer. So we want to figure out questions where the answer is equally likely to be yes. As it is to be no. So we could ask that as our first question. So we're going to ask, is the gold star in either the green or the purple box? So the answer is yes if it's in one of those two boxes. The answer is no if it's in either the blue or the red box. So, there are four boxes. For two of the boxes the answer is going to be yes, so half the time the answer is yes. So that means, we're gaining one full bit of information. If the answer is yes, we've learned that it's in either the green or the pop-, purple box. If the answer is no, we've learned that it's in either the blue or the red box. And so if the answer is yes, well now we need to ask one more question. To figure out which box it's in. And that could be, is it in the green box? And so, if we ask that question, if the answer is yes, well then we know it's in the green box. If the answer is no, then we know it's in the purple box. We only needed two questions to get to the right box. And that's the same, if the answer was no to this. Well then we can ask is it in the blue box? That's a yes no question. If the answer is yes, well then we know it's in the blue box. If the answer is no, then we know that it's in the red box. So now, we can cover all four possible boxes. We didn't need three questions like we did when we asked, is it in the green box, is it in the purple box, is it in the blue box? We might have needed three questions to determine the box, here we only needed two. So now you've seen that you can encode four things in bits. You can encode any number, we just need more bits. So if we have more bits, we can encode more different things. So, here I've got four bits. That means I have four yes, no choices. And I can encode sixteen different numbers. And the reason for that is because 2 to the 4 is 16. Every time I add one more bit, I double the number of things. Because I have one more yes, no question. So for just this part of the graph, I had eight things, I had three bits. I could distinguish between the numbers zero through seven. Adding one more bit, doubles the number of things I can distinguish. So that's a way to measure information. And once we can distinguish any number of things. Well, we can send any kind of data we want. Anything that's discreet, we can turn into a number. So we could turn letters into numbers. If we have a long string, we could have a sequence of numbers, which we can turn into one really big number. So, once we can send bits, we can send anything we want. So that's what bandwidth is. It's a measure of the amount of information that we can send, and we're measuring the number of bits. Each bit is one yes or no decision. In computing, we usually think of that as either a 0 or 1. So that long stream of 0's and 1's is the information we're sending. And it could be encoding a string of text like a dozen of web page. It could be encoding an image, it could be encoding a number. And to measure our bandwidth, we need to know how many bits can we send per second. So there are lots of different ways you can try to measure the bandwidth that you're getting over your Internet connection. I'm going to show you one that's provided by CNET. This is not necessarily that accurate and it'll depend where you are. But you can go to the CNET site, Internet Speed Test with hyphens between Internet, speed, and test. Pick your location. I'll deal with work, and it will try sending some messages to figure out what your bandwidth is. And, you can see that I'm getting 44,000 kilobits per second, it says kbps here. So that's 44 megabits per second. We can try again, see if we get the same result. And we try it a second time, we get 31 megabits per second, or 31.7. We can try again and we get 62. So we can see that it is varying each time we try it. And bandwidth does vary. You're sharing connections on the network with other people, they may be doing different things. There are lots of reasons why the bandwidth that you measure varies, but if you try this test you'll see what you get. And we're going to have a quiz. This is more of a survey than a quiz. But, we're curious to see what bandwidth you're getting. So, try a bandwidth test and see what the result is, and the quiz will ask you to report that to us. So, this isn't really a quiz. It's more of a survey. But the question is, what is your bandwidth? And you can use one of the tools we provided links to, to figure out what your bandwidth is. And the boxes give you a choice of ranges. And if you can get greater then 200 megabits per second were you live, I'm very jealous. So there's no correct answer to this quiz, of course. What I'm getting here, is usually between 40 and 60, sometimes it was between 60 and 100, never much above 60. So, this is the answer that I'm getting. I know some of you are, unfortunately, having much less bandwidth from that, and I hope you're still able to get the videos okay. If you have less than one kilobit per second, unfortunately, you're probably having a really hard time. And some of you probably live in countries that have much better bandwidth than the United States, and are fortunate enough to have over 200 megabits per second. [Narrator] We can also learn a lot about the internet by measuring our latency to different destinations, and in fact we can also see the hops along the way. I showed you on the map of Greece the hops along the way. We can see the same thing for destinations on the internet, and we can do that using an application called traceroute. If you're using a Mac you can just create a shell and run traceroute directly. If you're using some other operating system you might need to do something a little different, and we'll have directions for that on the site, but you can do traceroute and after traceroute you pick where you want the destination to be. First we'll try tracing the route to Udacity.com, and what traceroute is doing is sending packets over the internet, looking at all the intermediate hops to figure out the route it takes to get a packet from where I am now to the Udacity.com site, and when we run that we see the route. You can see each hop, so from where I am now to reach Udacity.com took 15 steps. The total time was about 39 milliseconds. You can see there are several different times in doing multiple tests and the time might vary each test, but the time is about 39 milliseconds, and you can also see the steps. The first thing you see is that our site is actually being served on a server run by Google. That's what the Udacity.com site resolves to, and you can see all the hops along the way. The 192.168.1.1 that's a special internet address that means your local machine, you always start there, and then you can see all the other hops that we go through, and the time it took to get there. There are different hops that took different amounts of time. You can see the time does vary. We can see that the time to get to the Comcast site here in Santa Clara varied from 11 to 37 milliseconds and you can see all the other hops along the way. That each hop took a millisecond or 2 between that hop. To get 15 hops took us about 40 milliseconds. If we try to go somewhere further away, let's try tracing the route to MIT.edu. Well that server is running from Boston. I'm here in California. To get to Udacity.com we didn't have to go very far geographically. To get to MIT we've got to go across the country, now we're going to Boston. We started where we are now, we went through Santa Clara, went through San Jose. Sometimes from the host names you can guess where they are, sometimes you can't, but here it's pretty clear we're going from San Jose, and then we're going across the country to New York, and you can see that the big time difference was when we went from San Jose to New York. There's no hops, so unlike the Greeks where the distance between hops was very limited, in the internet the distance between hops can be thousands of miles. There's some fiber optic cable probably between those 2 points, and there's no need for any routing directions. Once you got to this point in San Jose you end up in New York without going through any other decision points, and then we get to Boston, and it takes about 100 milliseconds before we get to MIT, and you can see we're not actually getting the final destination. We're getting some stars; we're not getting a response from the web server at MIT. We could do that if we tried a few more traceroutes and set the time outs differently, but to get across the country it took about 100 milliseconds, and we can go somewhere further away. About the furthest away you can get from where I am now is Madagascar. I'm going to try tracing a route to a server in Madagascar. If there are any students in Madagascar please contact me, and we try that traceroute, and we can see that it starts again going through San Jose, goes through Dallas, and now it's going through a lot of servers run by the same country, and that's getting across the ocean, getting towards Madagascar, and you can see it's starting to take quite a long time. It took 100 milliseconds to get to MIT. Here we have taking 195 milliseconds already, and we haven't yet reached Madagascar. The time it takes to do the traceroute is much longer than the time it takes to get a request from these pages because it's sending many requests trying to find all the points along the way, but this is a good way you can see what's going on in the internet and get a better understanding of how packets are getting from where you are to where you're making a request. So we observed that the latency between where I am now, which is Palo Alto, California, and Cambridge, Massachusetts is 100 milliseconds, and that's what we measured using traceroute. And the distance between those two locations is 4,300 kilometers. So the question is, at what fraction of the speed of light which is 300,000 kilometres per second, did my data travel between Palo Alto and Cambridge. So the answer is 1 seventh, which is pretty good. There aren't many things that we deal with where we can think of them in terms of fractions of the speed of light and fractions above 10%. So our data was traveling between California and Massachusetts at a speed of about 43,000 kilometers per second. And most of that time is not the time on the wire. While the data's traveling on the wires, it's traveling pretty close to the speed of light. The speed of light through Optical FireWire is about 50% slower than light travels in a vacuum. But what's taking up most of the time is all the routers that it had to go through. And we saw that, from the traceroute, that it went through about 20 routers. So each of those routers had to take a packet in, figure out where to send it, and do all that in the time that it had to travel across the country, which was a 100 milliseconds total, so the average speed going across the country was one seventh the speed of light, I can show you the Python code to compute that. So we have the distance which is 4300, that's the number of kilometers between Palo Alto and Cambridge. We have the speed of light, which is approximately 300,000 kilometers per second. And we have the time it took, which, since we're using seconds as our unit for the speed of light, we should put in seconds. And so it as 100 milliseconds, which is 0.1 seconds. And so I can compute the time it took light to travel that distance. By dividing the distance by the speed of light and let's see what that is. So if it was travelling at the speed of light it would take 0.014 seconds to get across the country, which is 14 milliseconds. What it actually took was a 100 milliseconds. And if we divide the time it actually took by the time it would take light to travel, we get 6.97. So, it's taking almost seven times as long as it would take if it was just light traveling in a vacuum for that distance. If you had a vacuum between Palo Alto and Cambridge and no routers and nothing else along the way, well then you could get your packets across about seven times faster than the internet actually does. Not many people can afford setting up a dedicated vacuum between the two points they want to communicate. So now let's go back to the things that we need to operate a network. So we need a way to encode and interpret messages. So we saw that we can encode any message that we want in bits. And then we can encode the bits on the wire. How that encoding actually works is pretty complicated, it's not something that we're going to talk about in this class, but there are lots of different ways to do it. But we're figuring out ways for each zero and one to encode that as something that we send along a wire, or it could be wireless. What we haven't talked about, which we're, we are going to talk about soon, is what these high level messages are. Right? We need ways to send messages that can be interpreted and understood at the other side. And so, what we'll talk about next is how that works on the internet. As far as the way to route messages. For the internet, all of the routers along that path. Well, a message comes in. It has a desination. The routers have to figure out the next destination to go to. And that's also quite a challenging problem. It's something we're not going to get into more detail in this class. But you can imagine different ways you might do this. A router might have a table that says, well, if you're in California and you want to send a message to Boston, you should first send it to Nevada, because that's going in the right direction. That's not quite the way things work, because we saw that there was actually just one message. That really, what you want to do is send it to San Jose, we've got a big strong pipe that goes all the way to Boston. Finally you need ways to decide who gets resources. And on our Greek network we assume that the general could decide. The internet is much more of a wild west in that in the internet there aren't any real rules for who gets resources. Everywhere along the network gets to decide on it's own how to do that. And what we really get on the Internet is just what we call best effort service. If your message needs to go over the same link as some other message, the router can only send one message at a time. It's up to the router to decide what to do. There are different policies that different routers follow. There's no general rule that is enforced on the whole internet. And this means that sometimes your packet might just get dropped. There's no guarantee, when you send a message on the internet, that it actually gets to where you want it to. So we're not going to talk more about these two in this class. I'll encourage you to take a future networking class that will get into those details. We are going to talk a little bit about how the messages work for the web. And what we need to make a network work is a Protocol. And what a protocol is, a set of rules that people agree to, that tell you how two entities can talk to each other. So, for the web, the protocol gives rules about how a client and a server talk to each other. The client is the web browser and the server, is the web server. So that might be udacity dot com. The web browser is what you're running at home. And what the protocol says is, if you want to get the server to do something, the client has to send a message in a particular way. The protocol that we use on the web, is called hypertext transfer proto, protocol. Which is abbreviated as HTTP. When you look in your browser, almost all the URLs that you use start with HTTP. That indicates that the protocol, that you should use to talk to the sever, that you're requesting a document from, is this protocol, called hyper text transfer protocol. An it's a very simple protocol. There aren't, too many messages. There's actually only two main messages and there is only one, we'll talk about. That's the message called GET. The client can send a message to the server, where the message says get, and then the name of that object that you want to get. So that's all the client does. It sense the message like this, and if you remember the python code for get page. Well, lets call in some library function that actually does this. That's sending the get message to the server. The server will get that message. It will do some, run some code on it. It will find a file that was requested. It might run some more code to get the result. Take the web application course to understand more about what the server does, but what matters to the client, and what matters to us in using this, is what happens after that. The server sends back a response, which is the contents of the requested object. So that's the whole protocol, that's what's going on whether you send a web request using your browser, by clicking on a link. Well then the browsers doing a lot of things to figure out what you requested and then its sending a get message to the right web server. That was the server specified by the URL, to know which server it is, and then its getting a response and its doing processing on that response to render it. If you want to understand more about what the web browser is doing, take the programming languages class that focuses on how to build a web browser. So we've reach the end of unit four. I hope you feel like you understand at a high level what's going on in a web browser, what's going on when you request a page over the internet. There's certainly lots of details, we're not going to cover them all in this class. But I think you should have a pretty clear picture of everything that's going on. There's nothing that's magic here, everything can be understood. Everything's done by sending messages across the internet and getting responses back and the responses are just text that are processed either by your web browser or now by your very own web crawler that you've written, and now you've got a search engine that can respond to queries. So, congratulations for making it to the end of Unit Four. There'll be a homework to do now, and in Unit Five we're going to look at the problem of how to actually make our search engine scale. The search engine that we've built in unit four works, it gives us responses to queries, it doesn't do that in a very fast or smart way. That's what we're going to improve in unit five. We're going to make it so that we can respond to queries much faster than we can with the code that we've written so far. And then in unit six we're going to look at the very interesting question of how do you find the best response for a given query. We don't usually want to get all the pages that contain the search word we're looking for. What we want to do is get the best page. And that's what we'll look at in unit six. At the end of Unit 4, we built a search index that could respond to queries and would do this by going through each entry one at a time, checking if the keyword matched the word we were looking for, and then responding with a result for that. I wanted to ask Gabriel Wienberg, the creater of DuckDuckGo, how well that approach will work if we have a large index with lots of queries. You'll find that with a large index with lots of queries, it will be too slow. A typical search engine should respond in under a second and often times much faster. But with that algorithm, having to go through each link like that one after the other, you could be on the order of seconds or even longer. So what we're going to learn this unit is how to make this much faster. So welcome to Unit Five. The main topic for this unit is trying to understand the cost of running programs. So far, we haven't really worried about this. We've been very happy to write code. If we get the correct result, that's a great thing. But once we start making programs bigger, worrying about programs that do more things, running on larger inputs, we have to start thinking about the cost of running our programs. And this question of what it costs to evaluate an execution is a very important problem in computer science. In some sense, it's one of the most fundamental problems. Many people spend their whole careers working on this. And it's a problem called Algorithm Analysis. I haven't yet explained what an algorithm is. But you've actually written many of them already. So an algorithm is a procedure that always finishes. A procedure is just a well-define sequence of steps. It has to be defined precisely enough that it could be executed mechanically. So to be a procedure, it has to be something that can be executed without any thought. And we're mostly interested in procedures that can be executed by computers. But the important part of what makes it a procedure is that the steps are very precisely defined and don't require any thought to execute. To be an algorithm, it has to always finish, and we've pointed out already that this is a very tough problem to figure out whether a program will finish. In general, it's not possible to answer that question, but for many specific programs it is, and in order for a program to be an algorithm, we have to know that it always finishes, and it always produces a correct result. So once we have an algorithm, well, we know we have a well-defined sequence of steps, so we can reason about what will happen on any input, and we know that we will always finish and always produce the correct result. So then we can think about what the cost is of executing that algorithm on some input. So how should we think about cost? And the way computer scientists think about cost is quite different from how most people think about cost. So if you're normally thinking about cost, well, if you've got a specific object, let's say, you've got a cool car. This is supposed to be a cool car. It doesn't quite look like a cool car, and it's got a cost associated with it. Let's say, that's a $25,000 car, and you have some other car. So you have one car, it's got a particular cost, that's what it costs you get that car. You could another car that would be smaller and green, and let's say that car costs $10,000. And when we think about the cost of things normally, we have very specific things, and they have specific costs. And we know that the red car costs $25,000; the green car costs $10,000; the red car costs more than the green car. We just need to compare those costs. So when we think about the cost of algorithms, we don't have a specific execution in mind usually. What we want to understand is how the cost depends on input. So we might have two different algorithms. Let's say this is algorithm one, and we have a second algorithm that solves the same problem. And both of these are algorithms that take inputs and produce output. And if we want to decide which algorithm is better, well, we don't have a specific cost for the algorithm the way we do for the cars. And we can say the red car costs more than the green car. The cost depends on the actual input that we run the algorithm on, so it might be the case for some inputs algorithm one is faster, and for other inputs, algorithm two is faster, and I should label this algorithm two. So what we need to understand is how the cost of executing the algorithm depends on the input. We don't want to do that for every specific input, right, if we had to do that for every input, well, we might as well just run it on the input and see what it costs. What we want to do is be able to predict this without actually having to run on on every input. Normally, there isn't that much that matters about this specific input. The main thing that's going to matter about the input is the size of the input. That's not always the case, and we'll see examples where other properties of the input matter, but the primary way that we talk about cost in computer Science is based on the size of the input. As the size of inc, input increases, how does the cost to evaluate the procedure increase? So cost ultimately always comes down to money. And when it comes down to money, well, what are the things that cost money when we execute algorithms? And the main things that costs money are the time it takes to finish. If we get an answer more quickly, well, we've spent less time on it, and we can also rent computers by the time to execute. There are lots of cloud computing services now that will give you a processor of a certain power for a certain amount of time, for a certain number of cents per hour. So time really is money. So we don't need to turn our cost estimates into money because we don't necessarily know how much our computing cost will be. But if we can understand the time it takes to execute, that will give us a good sense of the cost. The other main cost is often memory. So, if we know that we need a certain amount of memory to be able to execute our algorithms, well, that tells us something about the size of computer we need and how expensive that's going to be. So, we don't usually talk about cost in terms of dollars when we analyze a logarithms, we're talking about cost in terms of time and memory. But those things in real implementations end up being cost in terms of dollars. So we're mostly going to focus on measuring time, and time is usually the most important cost of running an algorithm. Memory is often another consideration. So for this quiz, I want you to think about why we're so focused on how time scales with the size of the input, rather than the absolute time it takes for a particular execution to run. Check all the answers that are correct. So the first choice is, we want to predict how long it will take for a program to execute before we actually run the program. The second choice is, we want to know how the time will change as computers get faster. And through the entire history of computing it's been the case that the computer that you can buy for the same amount of money a year from now is faster than the computer that you can get for that price today. So the third choice, we want to understand fundamental properties of our algorithms, not things that are specific to a particular input or machine. And the fourth choice is, we want abstract answers to make sure they can never be wrong. So the answer is the first three are all good reasons to focus on how time scales with input size, rather than absolute time. So the first reason is if we have an understanding of how the time depends on input size, well then, we can predict how long it will take before we actually execute a program. If we have to run the program to figure out how long it takes, well that's not going to be very useful because we have actually finished it. We have got the result we want. If we only learn how long it takes on that particular input, we haven't learned anything useful to figure out, what it will cost to run it on some other input. So we want to be able to make predictions, by understanding how the running time depends on the actual size of the input. The second reason is also true. By understanding how time scales with input size, we get a better idea of how the cost will change over time. Computers keep getting cheaper and faster. This was observed by Gordon Moore in 1965. And turned into the notion that we sometimes call Moore's Law today. It's not a law in the sense of a physical law, but it's a law in the sense that the history of computing has followed this trend, where the amount of computing power you get for the same cost, approximately doubles every 18 months. So what you can get for $1,000 today if half what you'll be able to get for $1,000 a year and a half from now. That's a pretty nice property to have, but it means that understanding the cost of something today doesn't tell us very much. What we really want to understand is the cost in a more fundamental way. The third reason is also true. That by understanding how time scales with input size, we get a much better fundamental understanding of our algorithms, than if we just had some absolute time measurements for a few different inputs. The fourth answer is not correct. Abstract answers can be just as wrong as concrete answers. But having good abstract answers will allow us to understand things much more deeply, than a few specific concrete answers will. So we're going to try a few things in the Python interpreter to get a sense of how long things take and I've written in a procedure here that times the execution of a piece of code. Right, we could just do the timing with a stopwatch and then we'd have to run really long things to be able to get a, a reasonably accurate time but Python has a built in procedure we can use to measure time, and that's the time clock procedure. So we could try just using a stop watch and if we ran programs that took long enough to run, this would give us a reasonable idea of how long they took. It's going to be a lot more accurate to use this built in procedure, which is provided by the time library that evaluates to the number of seconds. So the value of time.clock will give us the current processor time in seconds. This starting point is fairly arbitrary there but the important thing is if we call it twice, and we start the time here, and we stop the time at the second call, we store those in the variables, start and stop, that's going to give us the amount of time it took to execute this code. So I've rendered a procedure that starts by initializing the variable start to the current clock time then run some code, and I'll talk more about what it's doing there in a second, and then it computes the time between the current time and the start time, and gives us the run time, and it returns both the results of the code and the time it took to run. What's happening here is actually quite exciting. So we're using Eval. Eval allows us to evaluate any string as if it were a python expression, so we're passing in a string here but when we're passing the string in to eval, it's running it as code. So we can pass at any python expression. We're going to start and end the timer and in between, we're going to evaluate the code and get the result of evaluating that code. So I've defined this procedure time execution that will give us the time it takes to evaluate any Python expression. And now we're going to run some tests and instead of running them through the web browser ID like you've been using so far, I'm going to run them directly in the Python shell, running on my desktop computer, and the reason for that is we'll get more accurate timing measurements. You can try running timing through the Web browser interface that we provide. The problem is there are limits to how long we let your programs execute and the timings won't be very accurate so instead, I'm going to run these in the Python shell, If you have Python installed, you can try this yourself, and we have some directions on the website how you can do that, but it's not necessary to do that to continue in the class. I just wanted to demonstrate how time execution works. So let's try a simple example. We're going to time the execution of the expression 1 plus 1. So that's doing a simple addition. We're adding two numbers. Well see how long that takes and when we run time execution, we get back two results. We get back the result which is one plus one is two. That's good. And as the second result, we get the time it took. A little hard to read so it looks like 8.3 and then E to the negative 05. So what that means That's using the scientific notation. The negative 05 is where the decimal point is so what that is really looks like this. There are four zeros followed by the 83 dot dot dot and that's a value in the number of seconds. For the number of seconds it took to run is .00008 seconds. If we try the same thing again we'll try timing the exact same thing. We don't get exactly the same result like the timing's inaccurate. It depends on other things going on on the machine. We won't get exactly the same answer. But it's still a very small number. And if we try it a few times, we'll keep seeing this small number. If we try, a more complicated addition, it's still going to give us a very small number, and it's a small number of microseconds. The actual processor time for something that simple is actually probably lower than that but there are some other things happening because we needed to stop and start the clock and other things to do the timing. We'll see more if we try running longer things. So this won't tell us much evaluating very simple, very fast evaluations. So, to get a better sense of how timing works, I've defined a procedure spin loop. Spin loop starts by initializing the variable i to zero and then it goes through a loop n times, each time through the loop is just adds one to i. So that'll run for longer, we can, by picking the value of n, make it go through the loop any number of times. So, let's try that. So I'll try running the loop 1,000 times and now we get no result, and the time it took is 0.0001 seconds. So, about a tenth of a millisecond. Let's try it with a larger number of executions, so now I am going to increase the number of iterations by ten, so the value of n's multiplied by ten. And if we see that now, the time is, is higher, the time is increased to about six tenths of a millisecond and we can keep increasing the time, so let's try looping 100,000 times. And we see if the time increases. And the time increased by about a factor of ten. Between looping 10,000 times and looping 100,000 times. And we'll try one more time. Let's go for a million. If we go for a million times, now we're up to 0.05. So, five hundredths of a second, or 55 milliseconds. To loop a million times. Still pretty fast, right? We're going through that loop a million times. It's still much less than a second. What's important is, we can see that well, the time changes depending on the input. As we increase the input to spin loop, the time increases accordingly. This quiz will see if you understand execution time well enough to make some predictions. So, here's the code we had before that times the execution of evaluating a Python expression that we pass in as code. And we've defined spin loop as a y loop that goes through a loop that just adds one the number of times of the variable passed in. So let's try that in the Python interpreter. We're going to time an execution where what we're evaluating is calling spin loop, passing in some numbers. So we'll try 1,000 first. And what time execution does is return two values. The result and the run time. We only want the second one, so we'll index to get the second value out of the return result, and see that result. So that's what we get, so it took 0.0001 seconds to do spin loop a thousand. If I increase this to 10,000, I see that it takes 0.0006. Lets try 100,000, adding one more zero and I see now it takes 0.005. I'm going to write this a little differently, so we can see it more easily. So now, instead of writing out a 100,000, I'll do ten star, star, five, which is the same value as writing out a one followed by five zeros. And for good measure, we'll do ten star, star, six, which is a million times through the loop, and we see that, that takes 0.05 seconds. So here's the examples of timing loops. For your quiz, your goal is to estimate the expected execution time for a value running spin loop where the input of the loop is ten star star nine, that's one billion. And you should give your answer in the number of seconds. Of course it's not possible to get the exact answer, but you should be able to get a guess within about 20% of our answer to be correct. So here's the answer. We'll try it and see what we get. And while it's running, let's think about what we should get. So we can look at the examples that we did so far and try to make some predictions. So we saw when the value passed in was 10 to the 5, that the time it took to execute was 0.005. When the time passed in was 10 to the 6, so 1 million. We saw that the time to execute was 0.05, and now we're trying to predict 10 to the nine. If we look at the pattern here, every time we increase n by a factor of 10, the time also multiplies by a factor of 10. And, that's not surprising because the loop is going around ten more times. The times, number of times we go through the loop, scales as a factor of the input value n, so if we increase n by a factor of 10, the time will also increase by a factor of 10. And we see we have got our result now, so if we increase by another factor of 10, we would expect that this would also increase, that it would take about half a second to do 10 million. If we increased by another factor of 10 we would expect the running time would also multiple by 10, so we'd be up to about 5 seconds. And if we increased by another factor of 10 which is the billion that we tried, we'd expect it to also increase by another factor of 10. Getting to be something around 50 seconds. So it's not exactly a 1,000 times what we had when we did spin loop passing in a million, but it's pretty close to that. Now it's taking almost a minute, 1,000 times this would be 54 seconds, so it's a little bit off from that. But very close, and if we tried it a few more times, we might get a slightly different result. Let's try is one more time. So we tried it again and this time we got 55.89 seconds, pretty close to what we got the previous time. The important point here is that the running time depends on the value of the input to spin loop and it depends on in a linear way. As we increase the magnitude of n, the higher number of times through the loop, the running time scales linearly with that value. So we seen a few examples measuring the time of execution of toy programs, of a loop that does nothing. What we care about though is the time of execution of our index encode, so what I'm going to do next is write a program to be able to test the time of execution of indexing code. To get a good test we need to make a big index, we need to fill up an index with lots and lots of words, and we can do that by hand; that would take a lot of time and effort. So what I'm going to do instead, is to find a procedure that makes a big index. So what it does is take in, a size, and then it's going to, fill up an index with that number of words. To fill up the index with that number of keywords, we need to generate different words. So what I've done is created a variable called letters, that is initially is all A's. And as we go through the loop, we go through the loop size number of times. We keep making a new string. We add that string to the next, I'll explain what make_string does later. We add that string to the index, then we change the letters. And we're going to keep increasing the letter once we get to z, we wrap around. For now it's not too important to understand everything in this code, but I do want to walk through the code a little bit. So what this loop is doing is going through all the positions and the letters are A and we filled this up with eight different elements and we're going to go through those elements starting from the last one going backwards, so this range loop goes from the length minus 1 to 0, stepping by negative 1. We are going to check each letter. If the letter is less than z, that means we can increase and we are going to increase it using this code here and I'll talk soon about the code that turns letters into numbers, but what this expression does is get the next letter. So if the letter was an a the result after this will be a b, and we're going to replace the letter at that position in the letters list, with the next letter. If the letter is a z, we don't want to go beyond the alphabet, so instead, we're going to set that letter to a, and we're going to go back through the loop to find the next letter. Once we found one less than z, we break, we only need to change one letter. What the make_string procedure does, that we call here. Is just turn that array into one string. So it's going through the elements of P which is this list of letters that keeps changing. And concatenating all those letters into one string. So the whole point of this is to allow us to easily make big indexes so we can run tests on different size indexes. So let's try this in the Python shell. First I'll show you what the result is when we use make big index. We'll start with a fairly small one, so I'm passing three is the size. What make big index gives us is an index with three keywords: aaaaaaaa, aaaaaaab, aaaaaaac and for each of them there's one url which is the name fake. If we passing in a bigger value, this will have an index with a hundred keywords, so we're going to passing a hundred is the size, we get this big index, and you can see it's starting to change the second from the last letter. To make sure that each word is a different word than the next. So, what we want to do now is look at how the time of executions take for different size indexes. So, let's make a really big index. So what we're going to do, we'll make an index of size 10,000. And remember, our concern is the time for lookups. It's the operation that's going to happen most frequently. So we're not timing the time to make the big index. Let's see what the time is to do a lookup, and so I'll time the execution of looking up in index 10,000 the keyword, and the word makes a difference. So, first let's try looking up the word judacity. Which, sadly, is not in our index. We'd need a much bigger index to get up to udacity. And the time of execution is shown here. So, it's 0.0008 seconds. So, still getting close to a millisecond, but still quite fast. Let's make a bigger index. This time we have a 100,000 keywords. going to take a little longer to make it, but we're not worrying about the time to make it now. What we care is the time to do a look up. So that took a long time. Let's see how, many entries there are, so we can look at the very last element in our index. And we can see got to aaaafryd, which I don't know to pronounce. Another way to see that, which we didn't talk about yet, we can actually index from the back using negative numbers, so if you use negative 1 as the index, that will give us the last entry in the list. So, now we'll try doing a timed execution. We're going to look up in the 10,000 size index. And we'll see the time's pretty similar to what it was before, that time might vary a little bit, let's try it once more, and again, it's just under a millisecond. So now, we'll try, instead of the 10,000 index, looking up in the 100,000 length index, the same look-up, and we see that the time is now 10 times that, so it's now about 8.6 milliseconds whereas before it was 0.9 milliseconds. And let's, for consistency, try that again. We'll note that these timings vary a little bit, each time we do it. And there's lots of reasons why the timing varies. We're running lots of other things on the computer at the same time. So it's not the case that we have total control over the processor and are running exactly the same thing every time. Because all of the other programs might be doing other things. The other reason the time can vary is where things are in memory. Sometime it's very quick to look up a value in memory, sometimes it takes longer. And we're not going to talk about the details of that. What matters is that, that the time's roughly the same, each time we execute it. And it really depends on the size of the input, in this case it's the size of the input table. So when we increase the size of the table to have 100,000 entires, it's about 10 times as slow as when we had 10,000 entries. So now let's have a few quizzes to see if you can guess how these timings work. So the question is what is the largest sized index where we can do a lookup in about one second? So if you look at the executions we have, we've seen the time it takes with an index with 10,000 is .0009 seconds. The time with an index of 100,000 is .0085 seconds. And your goal is to predict what the largest index that can support lookups that finish within about one second is. And your choices are 200,000 keywords, 1,000,000 keywords, 10,000,000 keywords, 100,000,000 keywords, or 1,000,000,000 keywords. So this required some guesswork, since we hadn't actually run any examples this large. But if you understood the examples we saw with the smaller inputs, you should have been able to guess that it would take about a second to do a look up for a table with ten million keywords. And the reason for this, if we look at the previous executions, we saw, based on the keywords in the index, the time increased linearly. So, when we had 10,000 keywords we measured the time as 0.0009 seconds. When we had 100,000, we measured the time as 0.009 seconds. We didn't measure any times beyond that. The suggestion from looking at this is, well when, when we increased the number of keywords by ten, the time also increased by a factor of ten. So maybe if we could guess, that if we had a million keywords, it would probably take about 0.09 seconds, to do a look up. If we had ten million, the time would take 0.9 seconds, which is close to one second. If we had a 100 million, then the time would take about nine seconds. So, for this question, your goal is to guess the expected time to execute the query. Lookup index10M where the string is eight a's. Where index10m, 10m, is the index created by make_big_index passing in 10 million at this size. And I should warn you this is a bit of a trick question. So, think careful about what make_big_index does and what lookup does. And here are the possible answers. So, it could be 0.0 seconds. It could be 0.1 seconds. It could be 1.0 seconds, or it could be 10 seconds. So the answer is actually zero seconds that this will take very little time. It will be exactly no time but very close to zero seconds. And the very reason for this is because of both the way make_big_index works. Which creates an index where the words start with four A's, and we keep increasing the letters as we go. So that means the index created by make_big_index passing in any number. The first entry in that index will always be aaaaaaaa, and so when we do the lookup, the way lookup works, it goes through the entries in order, and it's going to find the first entry right away. So the point I want to make with this quiz is that the execution time depends on both the size of the input, and sometimes it depends on the actual input. So here the size of the index is very big, because we looked up a word that's at the very beginning of the index, the lookup is very fast. What we usually care about when we analyze programs is what's called the worst-case execution time. And that's the case where the input for a given size takes the longest possible time to run. So for our lookup, the worst case will be either the very last entry in the table, or a keyword that doesn't exist in the table at all. Let's look at the code for lookup to understand more why the time scales the way it does, and think about what the worst case execution time and what the average case will be. So, to get a better understanding of the results we've seen, let's look at the codes that we wrote for the index. This is the code that we finished in the last unit. And we have the code for lookup. So, what lookup is doing, it's going through a loop. Each of the entries in the index. And remember that index is a list, so it's going through that list for each element, it's checking, does it match the keyword. So this is our index structure, right? It's a list of elements. If we had 10 million of them, it's a very long list with lots of elements. But each element is a list itself, where we have keyword followed by the list of URLS where it appears. And what lookup is doing is going through those entries. The number of times we go through this loop depends on the size of the index. The size of the index is the maximum number of times through that loop. And it also depends on, well, if we find the keyword early, then we're done. The other code that you see here, that's relevant to this, is the code for add_to_index. And the reason that's relevant is, we want to know what the structure with index is after we make our big index. And what add_to_index does is also loop through all the entries to find if one already exists, then it adds that URL. If one doesn't exists, it adds the new entry at the end. So this means that the first entry we add will always be at the beginning. That's why the aaaa, with eight a's is first. And the last one that we add will be at the end. So now, we'll have a quiz to see if you understand what it means to be the worst case input and how the code for lookup works. The question is, which of these inputs will have the worst case running time? So the choices are, doing lookup, passing in the index and the first word that was added to the index. The second choice is doing lookup, passing in the index, and a word that is not in the index. And the third choice is calling lookup, passing in the index, and is the second input passing in the last word that was added to the index. So, for the quiz, you should check all the answers that have the worst case running time. So their answer is both of the last two. Both of these will need to go through the loop here, the number of elements in index times. In the case where it's a word that's not in a index, the test will always be false, and will get to the end of the loop and return none. In the case where the last word is added, we'll still go through the loop, the number of elements times, but the very last time we'll find a match, and return that element. One of the assumptions in all of this analysis is that the time it takes to go through the loop doesn't depend on the actual keyword that's passed in. And that's assuming that this equal comparison takes the same amount of time depending on what the entry and the keyword is. That it doesn't matter what the keyword is the time to do this comparison is the same. And it turns out that for strings and Python that's the case. That we can do these string comparisons very quickly, because strings are immutable. That means that we don't need to look at all the characters in the string to compare two strings. That double equal for strings can be done in such a way that it doesn't need to look at the whole string. It knows that the strings were created as different strings. That means they're different strings. Or if they were created as the same string, they're the same string. So that's the reason why we say that all of the other operations in the loop have constant time. That they don't depend on the size of inputs at all. These are all very fast operations. What matters in terms of understanding the time is the number of times we go through that index. If you take the follow on course, which I hope you will, we'll understand how to analyze algorithms in a more formal way. For now our goal is to develop an intuition, and for that intuition the important thing to understand is the running time depends on the number of times we go through this loop. Everything that we do inside the loop is constant time. It's not affected by the size of the elements. So now I hope you understand the running time of look up well enough to be able to answer this question. This is definitely a fairly subjective question. And the question is, is our look up fast enough? So the possible answers are yes, that it is fast enough, that it depends on how many key words there are in the index, that it depends on how many url's there are, meaning the number of different pages that we crawled in our web crawl. That it depends on how many look-ups we expect to need to do. Or no; that it's not fast enough. So the best answers for this question are that it does depend on the number of keywords. If we have very few keywords, well then, our lookup's fast enough. We're probably going to to have more keywords than that, so we want our lookup to be faster. The third possibility is not actually true. So, it doesn't depend on how many URLs there are. And the reason for that is we're doing a lookup based on the keywords. The number of times we go through the loop and look up depends only on the number of elements in index Which is the number of keywords, and then the size of the URL list for each keyword doesn't impact the time it takes to do a lookup. So it doesn't depend on the number of URLs. Certainly, if we have more pages, we're likely to have more keywords, so that would increase the size of the index, but just the number of pages itself doesn't affect the time for lookup. It does depend on how many lookups we want to do. So if we only want to do one lookup and that lookup takes a few seconds, well that's okay. It's probably not worth spending a lot of time to make that one lookup faster, but chances are we're going to want to do lots of lookups. Certainly if we wanted to have a real search engine, we'd want to be able to surf millions of lookups every day or in the case we will, many billions of lookups everyday, every hour. So, if we want to do lots of look up, we want look up to be faster. So, I think we have good reasons to want to make our look up faster and we're also going to learn some interesting computer science concepts, by trying to do that. So what do we need to do to make lookup faster? Well let's think about why it was so slow, right? The reason it was so slow is that we were doing this for loop, we were going through all the elements in order, and we're checking if they match the keyword, right? And we had to do this for the entire index, for an entry, for a keyword that's not in the index, To determine that it's not there, we had to go through the whole index. This is not how we use indexes in real life, right? If you're looking for a word in the index of a book, you don't have to look through every single entry to see if that word exists. You can jump around, and the reason that you can jump around is because the entries in the index, are sorted, they're sorted in alphabetical order, so you know where that entry would belong. You just need to find the right place and see if it's there. So we can do that with our index instead of having our index kept in arbitrary order. If we kept our index in assorted order, then we could find the place where that entry belongs and look for it. Sorting is a very interesting problem. It's something we're not actually going to talk about more in this class. We're going to do a different way of doing that. What we're going to do is find a way to find where the entry should be that doesn't require actually keeping all the entries sorted. What we want is something that will allow us, given a keyword, we're going to have some function that tells us where it belongs. We're going to call that a hash function. That tells us where in the entry to look. And so instead of having to look through the whole index, the hash function will tell us where that entry belongs. So what we need for this is some function that's going to take a key word, map it to a number And that number is the position in the index where that number belongs. We could do this lots of different ways. One simple thing would be to think, well we know alphabet. This is more like the way an index for a book would work, and we're going to have for each entry and index, we'll have based on the first letter, we'll put all the entries that start with tha tfirst letter in the same place. So, if we're looking for a key word that starts with u, that prefer hash would tell us to look in the place where all the words that start with u are. And then we'd only have to look through the words that start with u. So this would allow us to do a look up much more quickly than looking through the whole index. This isn't quite the best way to do things. If we made our places based on the letter, well, then we have a problem if we have two words with the same first letter. You generally expect to have more than one word that starts with the same letter. So instead of having just an element here for each position, we're going to have a list of elements that would be all the words that start with u So when we look up the word udacity, we look in the entry for u, and if the word that's there doesn't match then we know udacity isn't in the index. There are lots of problems with this. The first problem is well, there might be more than one word that starts with u. So we can't just have one entry here. What we need to have is a list of entries We often call this a bucket. So we need a bucket of all the entries that start with u that would be in this position. So, instead of just having one entry like the old structure of our index, now we're going to have a list of entries, and each element of the index will now be a bucket, which is a list of entries that are in the right position. This is going to be our bucket of our, all the entries that start with u, and that would have all the different entries that start with the letter u in that bucket. So this is getting better. Now, for each look up, instead of having to look through all of the words in index, we just need to find the position that starts with the right letter. That's got a bucket of all the words that start with that letter, and then we just need to look through that bucket. This works okay, but this doesn't really scale very well. At best, if we have you know, ten million words well now instead of having ten million entries to go through, we need to go through ten million divided by say 26, if we have 26 letters. It's not making things much faster. It's making things maybe at best, 26 times letter. That assumes that all of the buckets are the same size. Certainly if we make the buckets based on the first letter, that's not going to be the same size. If the words are a typical English words. We're going to have many more words that start with s or t, say than start with u. So, we want to fix those two problems. We want to be able to have more buckets. So we're not going to just use the first letter, we're going to use some function on the whole word that tells us where it belongs. And we're going to try to make that function distribute the words fairly well. So the structure that I've described is what's called a hash table. This is a very useful data structure. It's so useful that it's built into Python. There's the Python type called a dictionary. Which provides this functionality. At the end of today's unit, I'll explain how the Python dictionary works, and how to use it, and we'll modify the search engine code to use dictionary instead of the lookup table that we built, but before we do that, we are going to implement it ourselves. We are going to make sure that we understand how the hash table works by writing all the code to do it ourselves and then we'll switch to using the built-in Python [INAUDIBLE] So now we're ready for a quiz to see if you understand the goal of the hash table. So the question is if we have b buckets in our hash table, and we have k keywords, and we should assume that k is much greater than b, that there are more keywords than we have buckets. The question is which the properties should the hash function have? And remember what the hash function is, is it's a function that takes in a keyword, produces a number, and what that number does is gives us the position in the hash table which is the bucket where that keyword would appear. The first choice is output a unique number between 0 and k minus 1, so each keyword maps to its own output number. The second choice is output a number between 0 and b minus 1. The number of buckets that we have. The third choice is that it should map approximately k divided by b, of the keywords to bucket 0. That means for that number of keywords, the output of the hash should be 0. And it should map to the first bucket. So the fourth choice is map approximately k divided b of the keywords. To bucket b minus 1. That's the last bucket. And the final choice is it should map more of the key words to bucket 0, than it maps to bucket 1. So check all of the properties that we would like the hash function to have. So, the answer is many of the properties are desirable. The second property is desirable. So, the first property is not desirable. That if the hash function outputs a unique number for every keyword, well then, the range for the hash function would be very large. We'd need a huge amount of memory to store the hash table. And the number of buckets would be the same as the number of keyboards. That's not going to work very well. What we want is the number of buckets to be b, so that means that the output of the hash function should be in the range between 0 and b minus 1. That will find the element of the list that corresponds to that bucket. So, we do want the second property. The third and the fourth properties say that we want the number of keywords in each bucket to be approximately the same. So, if there are k keywords and we're fitting them into b buckets, if we want the buckets to be approximately the same size, then each bucket should have approximately k divided by b keywords. So, both the third and the fourth property are true. The final property says that we should have more keywords in bucket zero than in bucket one. There's no reason that we would prefer that, so you, you might think it would be better to have more keywords at the beginning than later on, that's not the case with a hash table. Remember, what our hash function does is, it tells us right away which bucket to go through. We don't have to look through the earlier buckets. This is different from the list index that we started with. Where the first one is the fastest one to find. And the last one requires going through all the elements. For the hash table, that's not the case. There's no reason to prefer having more entries in bucket zero to bucket one. What we really want is to try to have all the buckets have approximately the same number of keywords. So let's try to define a hash function that has these properties. And what we want the hash function to do is to take a string as its input, we'll call the hash function hash_string, and it'll produce as output a number between 0 and b. So, we also need another input to our hash string, which is going to be the size of the hash table. So that'll be the second input is the size of the hash table, the number of buckets. What we haven't seen yet, that we're going to need for this function, is a way to turn a string into a number. Python provides an operation to do that. It's called ord as an ordinal, and what ord takes as it's input is a one letter string and produces as it's output a number. And actual mapping between strings and numbers is not so important. We just want something that is going to map different string to different numbers. There's another operator that goes in the opposite direction that takes in a number, and outputs the one-letter string that corresponds to that number. And the property these functions have is their inverses. That if we take the character corresponding to the ordinal corresponding to any one-letter string. We'll call that alpha. What we get as a result is the same alpha that we passed in. So let's try a few examples in the python interpreter to see how ord and chr work. So we'll print ord of a, and when we run that we see we get the number 97. If we try print ord of capital A. That's different. We get 65. And if we print ord of B, we get 66. So, the numbers are sort of sensible. B is higher than A. The lower case letters have different ordinals than the upper case. So, if we try a lower case b, we should expect to get 98. And that is indeed what we get. And these are the numbers based on the ASCII enchar, character encoding, what the actual numbers are, are not very important for us, other than that we get different number for different letters. So we'll be able to use the results of ord to make different strings hash to different values. And just to show that there are inter, inverses. If we do ord of u, and then chart of that, what we get back is the single letter string u that we started with. The limit of ord is it only works on one-letter strings. If it provided a mapping from any string to a number that would be useful for a hash table. Well, then we'd be done. But it doesn't do that. If we try running it on a multi-letter string, we get an error. It says that ord expects a single character, but it got a string of length 7. So we're going to need to use ord only on single letter strings. So with ord, we have a way of converting strings to numbers. Converting single character strengths to numbers. The other property we need our hash function to have, is that our output number is always between 0 and B minus 1. We need it to be in that range, because we're going to use that to index the list, to find the bucket where that string belongs. So to get our outputs in the correct range, we're going to use the Modulus Operator. And this is written with a percent sign. It's usually the Shift 5 on most keyboards. What modulus does is takes a number and maps it to the range based on the remainder when you divide that number. So the way modulo arithmetic works, is like a clock. So if we think of having a clock with 12 hours, and then arithmetic on the clock is modulo 12. So if we were to evaluate 14 modulo 12, what that would mean is, well, if we start from 0, and we make 14 steps, we're going to 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14. Where we end up is 2. That's the same as the remainder we would get by dividing 14 by 12. And that's the result of 14 modulo 12, is 2. So now we're going to have a few quizzes, to make sure you that understand the Modulus Operator, as well as the org and char operators we introduced. So for this quiz, your goal is to predict the value of each expression. Try to figure out the answer yourself. You can definitely try evaluating in the Python interpreter to check that it's correct. So, the first expression is 12 modulo 3, the second expression is ord, the character a, modulo ord the character a. And you should see if you can solve this, without actually figuring out what the value of ord a is. And the third question is ord of z plus 3 modulo ord of z. Here are the answers. So, for the first question, we had 12 modulo three and 12 is equal to three times four. So, that means, if we divide 12 by three we get four with no remainder. So, that means, the result of 12 modulo three is zero. For the second question, we could solve this by figuring out what ord of a is. But we don't actually need to. We know that the value of ord for 'a' is always going to be the same every time we do it. So this is saying, the same value modular the same value, the result is always going to be zero. Because anything is divisible by itself with no remainder. So that answer's also zero. For part C, well now we've added three. In order to know what the result is here, we've got to know whether ord of 'z' is greater than or less than three. As long as ord of z is greater than three, well that would mean ord of z plus three modulo ord of z must be three, because the remainder will be what we added to ord of z, since ord of z by itself is always divisible by ord of z. And we do know that ord of z is greater than threeSo that means the result will be 3, so let's try that last one in the Python interpreter. We're going to print the value of ord of z, plus three, modulo ord of z, and when we run that, we see the result is three, and I want to point out that the parentheses here are actually important, if we didn't have them We tried the order Z, plus three order Z, then we get the result 125. And the reason for that is, the grouping here is going to group three mod or Z and add that towards, so it's a different value, and the reason we get 125 is the value of ord Z by it's self. Is 122. So it's 122, which is ord of z, plus three mod ord of z, which is three mod 122, which is three, which is why we got 125 when we evaluated this without the parentheses. So we're going to find lots of good ways to use both modulus and or Intera operators. So lets do one more quiz that's going to be a little trickier. What I want you to answer is which of the expressions below are always equivalent to X. So I have exactly the same value of X where X can be any integer between zero and ten. So the answer is, only the second and the third are equivalent. This is a little surprising. This was kind of a tricky question. So the reason the first one is not, if x is seven or greater, well, then seven mod seven has the value zero. That's not the same as the x that we started with. And that's the case also if we have eight. Eight module seven has the value one. Which is different from what we started with. When the modulo is greater than the possible value of x, and we said, x could be only between zero and 10, well, then, the result is always the same as x. The third question, when we map x to its character value, and then we take the order of that, we'll char an order inverses, so that's equivalent. You would think that would in the other direction and the reason it doesn't is because the input to ord must be a one letter string. If the input's not a single character, then ord produces an error. So let's see that in the Python interpreter, if we print the result of ord where the input is a number and we said x was a number between zero and three. Well, that gives us an error. And it gives an error, because ord expects a string of length one, but the input was an integer. There is a function that allows us to turn numbers into strings. And that's the str function that takes a number and gives us a string corresponding to that number. So let's see what str of three gives us, that will give us the string three, we can't see in output here that it is actually a string, but it is a string, and we can actually use order on the result there. When we run this, what we get is 51, not the three that we passed in and that's because the ord of the character three is 51. So now that we know about ord and we know about modulo, we're ready to define a hash function. So let's remember what our hash function should do. So the hash function takes two inputs. It takes the keyword, and it takes the number of buckets. And it's outputting a number between 0 and buckets minus 1, that gives us the position where that string belongs. And we've seen the function ord that takes a one letter string and maps that to a number. And we've seen the modulus operator that takes a number and a modulus and produces, as a result, the remainder that we'd get when we divide that number by the modulus. So now, we can use those to define a hash function. I'm going to start by giving you a really bad hash function. So let's define a procedure, and we'll call it bad_hash_string to make sure we remember that it's really bad. And it takes as inputs the keyword and the number of buckets. And we're going to output the bucket based on the first letter in the keyword. So we'll use ord on the first letter, and we'll use modulo the number of buckets. And that's our simple hash function. For the quiz, I want you to answer all the reasons why that's bad. And remember what bad_hash_string does is take the first letter in the keyword, turn it into a number using ord, and then find that value modulo the number of buckets. Here are the possible reasons, check all the reasons that apply. The first is it takes too long to compute. The second is there's at least one input cured for which bad_hash_string will produce an error. The third is, if the keywords are distributed like words in English, then some of the buckets will get too many words; others will get too few. And the fourth choice, if the number of buckets is large then there's some buckets that will never get any keywords. The answer is, all choices are true except for the first one. The reason the first one's not true, is this really doesn't take long to compute. We only need to look at one letter and do a simple modular computation, that's very efficient. But the other three reasons are true and we'll go through each of these showing what happens looking at how things evaluate in the Python Interpreter. So the first correct reason is that it produces an error for one input keyword. When we write code we should think about whether it works for all possible inputs. And the one that's usually the trickiest to think about is the boundary case. For a string, that's often the empty string. So, if we pass in a string with no characters in it, which is a perfectly valid string, we'll then, when we try to index element zero, that would be an error. So let's see what happens when we try that in the Python Shell. So we'll try to evaluate bad_hash_string, passing in the keyword the empty string, which is a perfectly valid string. And lets see there are 100 buckets. And we do get an error, we get the error that the string index is out of range because we tried to access the character at position zero, but there is no character at position zero in the empty string. So to understand the other two reasons, I have defined a procedure called test hash function. It takes three inputs. The first input is a function, so we can pass functions around, just like any other value, so what we're going to pass in for this, is the bad_hash_string function that we've defined, but we can also use it to test other hash functions, which we'll see later. We're going to pass in a list of keys, those are the keywords for the hash table, and we're going to pass in the size, this is the number of buckets. What we do in test hash function, is we're going to keep results as a list of the number of times each bucket is used. So initially, they're all zeroes. And we initialize it with zero times the size. We're going to use keys used as a list of the keys that have already been used. We don't want to count a duplicate key more than once. So now we're going to loop through the keys. We're going to check if a key was used already, and if the key was not used, then we're going to figure out by calling the hash function where that key would hash to. So, if we passed in that hash string, that would be the function here. And we're calling that passing in the keyword, and the number of buckets. We're storing the result in the variable hv. And then we're increasing the value of the element at results position hv, by what? And this is a short-hand syntax, means the same thing as doing a new assignment where we're assigning two results hv, the value currently end results hv plus one, and then we're adding the word that we just used to the list of keys used, so we don't use it again. This is similar to what we did in the web crawler, to avoid crawling the same page more than once. And if end will return the results. So what we'll have as the result of test_hash_function, is a list where the values in that list are numbers, giving the number of times a key hashes to that bucket. So let's try this with an example using the bad_hash_string function. So to test our hash function, we need some content. We need content that represents the kind of words that we think we're going to be using the hash table on. I've picked this one, which, perhaps is represented, perhaps not. And what's there at that link, is Gutenberg's text of The Adventures of Sherlock Holmes. And you can see from the scroll bar, it's quite long. So this is all the text there is. And so on. So, we're going to get all the words on this page using getpage. We're going to split them into words like we were doing in the crawler, and we'll store that in the [INAUDIBLE] words. And the length of that is over 100,000 words. Now they're not all unique, so the number of entries in our hash table will be smaller then that. But let's see how the distribution is for those words. So we'll use the test_hash_function that we defined, passing in bad_hash_string, the words that we got from Sherlock Holmes, and we'll pick, for now we'll use size 12, definitely too small, but that'll give us a good sense of how the distribution goes for a small number of buckets. So now we have the result. Let's look at what the counts are. And you can see, we've got 12 entries, which corresponds to the number of buckets. And they vary quite a bit. The smallest one has only 754 elements. The largest one has over 2000. So the gap between the smallest and largest is nearly a factor of three. If our hash function was good, we will want these to be about the same size. Here's what that looks like graphically. We have our twelve buckets. The ones that are red, are too full. The ones that are blue, are not full enough. We would like this to be a fairly flat graph, distributing all of the words evenly between the buckets. So we've seen the basic looking at just the first letter does not work very well, doesn't use enough buckets. And it doesn't distribute the keys well. So now we're going to think about how to make a better hash function. So we want the same property we had before in the sense that it's one function that takes two inputs and that two inputs are the keyword which is a string. And the number of buckets, which is a number. Those are the two inputs and the output is the hash value and it's in the range from zero to number of buckets minus one. And our goal is for these numbers to well distributed, so we can have any number of buckets we want. The keywords will be spread evenly among the buckets, and every time we hash the same keyword we'll get the same bucket. So, we'll know quickly where to find it. So in order to do better than we were doing before, we're going to need to look at more than just one letter of the keyword. If we look at just the first letter, we're not going to do better than having a limited number of buckets in a bad distribution. So, what we want to do is something that's going to look at all the letters of the keyword, not just the first letter. And based on all the letters, we'll decide their appropriate bucket. We saw that with lists, if we had a list of items, we could use the for loop construct to go through the elements in the list, like this. And this will go through each element in p, assigning it to the variable e and executing is whatever is in the block for each element of p. We can do something similar with strings, so if we have a string s, we can use the same construct to go through the characters in s. So each time we go through the loop, the value assigned to variable c will be a one letter string corresponding to each character in the string in order. So first it will have the value a, and then value b, and then value c, and then value d. So this gives us a way to go through all the elements in the string. And if you remember how we turned single letter strings into numbers and modular arithmetic, then I think you know enough to define a much better hash function. So for this quiz, your goal is to define a function hash_string that behaves like this. It takes a keyword, a number of buckets, and it gives it number, identifying the bucket where that keyword will belong. But instead of just using the first letter in the keyword, it's going to use all the letters. And produces as output, a single number that represents the bucket where that keyword belongs. And your goal is to do this in a way that depends on all the characters in the string, not just the first character. There are lots of ways to do this, so we're going to specify exactly what you should do. So what we want to do is make the output of hash string a function of all the characters. And we can think of that with modular arithmetic, that if we have a circle which is the size of the number of buckets, so this is going to go from 0 to the buckets minus 1. But what we want to do for each character, we are going to start at 0 and for each character in the string, we are going to go around ord of that character, distance around the circle, and we are going to keep going. So each character we are going to go some distance around the circle, the circle can be any size depending on the number of buckets and we're going to keep going around the circle using modular arithmetic for each letter. And as we keep going, we can go lots and lots of times if it's a big word. Wherever we end up is going to be the bucket that we use. And let's say that's position 27, who knows where it is. So that's the idea and I'll give you a couple of examples so you know if you're implementing it the right way. Let's suppose we have as our string the single letter a, and we have 12 buckets. Well in that case we're going to have 12 buckets, so we wouldn't have 27 here. This is going to be, 11 is the last bucket, the ord value of a is 97. So for a, what we would do is go around the circle eight times, because 97 is 12 times 8, and one more, because 97 is 12 times 8 plus 1. You don't actually have to go around the circle if you use the modulo that's what it will give you. And so the hash value for a should end up in bucket one. As another example, if we tried hash string where the string is the single letter b, also with 12 buckets, well that's going to also go around the circle eight times because the ord of b is 98. But it's going to end up in bucket two, since that's 96 plus 2, which will end up in bucket two. If we change the number of buckets, the results will be different, so let's say, instead of having 12 buckets we have 13, and we tried hash_string on the single letter string a, with 13 buckets. The result there should end up being 6, and the reason it's 6 is because 97 is equal to 13 times 7 plus 6, so the size of the hash table matters, as well as the string. We don't want it to just work on single letter strings. With single letter strings, we are really getting the same thing we defined before, where it gets interesting is where we have multi letter strings. So lets look at a few examples like that. So where we can see the difference between what you are going to find at hash string and the bad hash string we had before is once we have longer strings. So suppose we tried the string au, the ord of a was 97, and that, when we went around the circle, ended up at location 1. The ord of u, I can tell you, is 117. When we add those two, we get 214. And modulo the number of buckets, which is 12 here, we should get 10. So that string with two symbols doesn't end up in position one where the a would end up. It ends up in bucket ten, and as another example, we won't work through the details on this one, but you'll be able to test if your result is correct. If you try the string udacity, it should end up in the bucket sorry I forgot the input size, this is very important. We need two inputs to hash string, both the string and the number of buckets matter. So here, we're also assuming 12 buckets, here we'll use 12 buckets again, the result should be 11. So see if you can define a function hash-string that does this. And we want it to take these two inputs and produce a number that tells us what bucket that keyword should be in. So, this is a pretty tough question. If you weren't able to get it yourself, that's okay. What I'd encourage you to do is stop in the middle of the explanation, once the part where you got stuck on makes sense, and see if you can finish it yourself. So, what we need to do is define a function, so we're going to define a function hash-string, and it takes two inputs, the keyword and number of buckets. And we're going to keep track of where we are in the circle. We need to introduce a new variable to do that, and we should start at position zero. So, we'll initialize that variable. We'll use h to represent the hash, and we'll initialize that to zero. Now, we want to go through the characters in the key word. So, we'll have a for loop that goes through each character in keyword. And for each character, we want to add to the hash. So, we're going to add to the hash, the value of that character. We could do the modulo here, so we could, at this point, use modulo buckets. We have to be careful to have the parentheses here. If we just have the modulo buckets here, we wouldn't get the right result. because it would do ord c modulo buckets, but what we really need to do is modulo buckets, the sum that we get from h and ord c. And then at the end, we're going to return the hash value. We could, instead of doing the modulo each time here, we could do the modulo just once at the end. That would be computing a big number if we have a really big string, and then, at the end, compute our modulo buckets. Either way should work. This way's a little better, in the sense that if our string is very long, we would have to compute a really, really big number, which gets to be more expensive. And we might even run out if it's a super long keyword. So, it's better to do the modulo here. We get the same result either way though. Let's try this in the Python interpreter. So, here's the code that we wrote out on the sketchpad. We have our variable, h, which is going to keep track of the hash value. We're going to go through all the characters in the keyword, adding each one into the hash value, modulo the number of buckets. So let's try the examples. So a, with 12 buckets, hashes the bucket one as we expect, and if we look at b. And hash just the bucket two, also as we expect. So, one other thing we should try, if you remember, when we had the really bad hash string function. One of the many problems it had was it didn't work on all strings, in particular, did not work on empty strings. Do you think our hash string function here will work on the empty string? Try to guess what the result should be before I run it. And then I will run it. And you see the result is zero. So, no error. And it makes sense that the result is zero. We start with h is zero. When there are no characters in the string, we don't go through this loop at all. So, h is still zero when we return. And let's also try the longer example. When we hash the string udacity with 12 buckets, we get bucket 11. We should be able to increase the number of buckets. So, let's increase the number of buckets. Let's suppose we had 1,000 buckets, and we get bucket 755. This isn't enough to convince us that our hash string function is distributing all strings well between all buckets. But at least we're getting a, a fairly large number that says we might be using all the buckets. So let's test our new hash function. See if it does better than the bad string hash function we defined earlier. We're going to use the same test hash function we defined before, that takes the function as input. So we can pass in either the original bad string hash function, or the new hash string function that we hope will work better. A list of keys, and the size, computing the hash size value for each key. And, records how many end up in each position. So let's try that again, we'll use the same example we had before using the words from Sherlock Holmes. And so we'll initialize words, as all with words in the page that is the Adventures of Sherlock Holmes, that we load from the Web. So, first we'll try this again with the old hash function, bad string hash, and obtain the counts, and let's print those out, remember what those look like. So it's a pretty bad distribution, as we saw before, ranging from 725 all the way up to over 2,000, in one bucket. Now, let's try it with the new hash function, instead of bad_hash_string. We'll path in plain hash string. We're using the same words, the same number of buckets. And we'll see the distribution now. It looks a lot better, right. There's no values under a thousand now, there's now values over the highest one would be 1,363 in the first bucket. So, lets look at that graphically. Here's what we had before. With a bad hash string function we can see the size of the buckets varies a great deal. And we have the red and blue bars showing some that are too popular, some that are not popular enough. With the new hash function we have much less variance. Still not perfect. We'd like to have all the bars really be as close to the same as possible, but it's really close. So this is working pretty well. The other thing we can try is having more buckets. So lets try this one, we are doing the same thing but this time with a 100 buckets instead of 12 buckets. And we can print that out, and so we see the results when we have 100 buckets, are pretty good, but certainly not perfect. We have buckets as small as this one, that has a 104, and as larger, this one that has a 197. So almost twice the size of the smallest bucket. It's certainly a hard problem to build a better hash function. People put a lot of effort into building good hash functions. As your tables get larger, it's very important to both have the hash function be efficient. Our hash string function is not that great, because it does take a long time to execute. If the string gets longer we have to go through that loop once for each character. And so there are better hash functions available. We're not going to look at those in more detail now. But there'll be some links on the website to documents about more interesting hash functions. This is going to work well enough for us though. So before we go on to actually implementing in a hash table. We're going to have one quiz to make sure that you understand, why this is so much better than the original index. So, lets assume for now that we have a perfect hash function. That it distributes keys evenly across all the buckets. And then the question is which of the following will leave the expected look up time for a given keyword essentially unchanged. For the first choice is we can double the number of keywords, without changing the number of buckets. The second choice is we can keep the number of keywords the same. But double the number of buckets. The third choice is, we can double the number of keywords and double the number of buckets. The fourth choice is we can halve the number of keywords, keeping the number of buckets the same. And the final choice is we can have half as many keywords, and half as many buckets. And the question is, which of these five, and there could be more than one that's correct, Will essentially leave the time it takes to look up a keyword unchanged. So there are two correct answers, the third one, and the fifth one. And this is why a hash table is such a great advance over the linear index, is that we can double the number of keywords, and double the number of buckets, and the look up time stays the same. With the linear index, if we double the number of keywords for each look up, we need to go through the loop once for each keyword. If the keyword was near the end or one that wasn't in the table, the time to look up the keyword would double as we double the number of keywords. With a hash table if we also double the number of buckets when we double the number of keywords, well then the number of keywords in each bucket stays the same. We're dividing the keywords evenly between buckets. So this is the number, the number of keywords per bucket is the number of keywords divided by the number of buckets. Of we double both, that number stays approximately the same. The time to look up only depends on the number of keywords per bucket. The time to find the bucket is very fast, right? We just need to run the hash function, find that element of the list. Both of those don't depend on the size of the list, how long it takes to do that. And then we have to look through the bucket, the size of the bucket, we have to look though each element in the bucket one at a time. So if we keep the number of key words per bucket the same, the look up time stays essentially the same. So that's the great property that hash tables have. If we double the number of buckets, as we double the number of keywords, the expected look up time doesn't change. For the other possibilities, well if we double the number of keywords and keep the same number of buckets, that's going to get slower because the number of keywords per bucket will approximately double. So it's going to take about twice as long for each look up. If we keep the same number of keywords, but double the number of buckets, well then it's going to actually get faster. We'll have the same number of keywords, double the number of buckets. So, this value will be approximately half of what it was before. The expected lookup time will be about half of what is before we doubled the number of buckets. If we have the number of keywords keeping the same number of buckets, well that has essentially the same affect. The average number of keywords per bucket will be half of what it was before, so the expected lookup time will be about half of what it was. And finally if we have both, well that's going to keep the ratio the same so the expected look up time will be about the same. So that's why these two are the correct answers, that those are expected to leave the lookup time essentially unchanged. So I hope everyone understands the main idea behind the hash table now. Our goal is to map a keyword and a number of buckets. Using our hash-string function to a particular bucket and that bucket will contain all of the keywords that map to that location. So now what we're going to do is try to actually write the code to do this. We're going to start from our index that we wrote for the previous unit, but try to figure out how to implement that with a hash table instead. So the first question is, how is this going to change our data structure? So this was what we had before, if you remember we had our index was a list of keywords, we had a list of entries, and each entry was a pair, which was a keyword. And the second element of the pair was the list of the URLs where that word appears, and we would have each word in the index as its own entry with its own list of URLs. So this was the data structure that we used last class. Now we want to change things to implement a hash table. So, I want you to think about what data structure we'll use and we'll make that a quiz to decide a good data structure to use to implement the hash table. So the question is which of these data structures would make most sense to implement the hash table index? The first choice is a list. Where the elements in the list are. A list where the first element is a word and the second element is a list of URLs where that word appears. The second choice is a list where each element in a list is the list itself where the first element is a word and the second element is a list of lists where each element in that list is a list of URLs. So, the third choice is a list. Where each element is a list. Where the element lists themselves contain lists. Where the element lists of the element list are a list of the word, all by a list of all the URLs for that word. So, we have three nested lists for the first three. For choice four, we have a list where each element in the list is a list. Where within the element list, there is another list, which is a list of words, followed by a list of URLs. And for the final choice, we also have three nest of lists, where each element is a list, where the elements of that list are a list, that are word followed by a list. Where each element in that list is a list of urls. So which one of these would be the best structure to implement a hash table? So the answer is the third choice. These data structures are getting complicated enough that they're fairly hard to read. We need to think about what components we need to represent the hashtable. And the main component we need is a way of representing a bucket. So, here's our picture of four hash table. What we want is a list, this is going to be the list where each element in the list is a bucket. And what a bucket is, is a list itself where each element in that list is a key and a value. In our case, the key is the word, the value is a list of URLs. So the structure that corresponds to that most closely is this one where we have a list. Each inner list here, so this corresponds to a bucket. And then within the bucket, a word and a list of URLs is one entry. This corresponds to what the entries were in our previous index but now because we want to make it a hash table, we're going to collect them in buckets. So list of those entries and each element in the outer list corresponds to one bucket. So the first thing we're going to do to implement our hash table index, is we have to figure out how to create an empty hash table. With a simple index, this is really easy. To make an empty index, we just have an empty list, there are no elements. So we can initialize the index by just initializing it to an empty list. And as we added elements to the list, we would just add them to the empty list. For the hash table that's not going to work. We need to do something more complicated to start with an empty hash table. And the reason for that is we need to start with all the buckets. So our initial value, for the plain index, was just an empty list. Our initial value for a hash table needs to be a set of empty buckets. And the reason for that is, we want to be able to do lookups right away, and we want to be able to add elements to our hash table. If we just started with an empty list, well then, the first time we look up a keyword, it would say, that keyword belongs in bucket 27. We don't have a bucket for that. We would need to figure out how to create that bucket. It makes a lot more sense to start by making our empty hashtable be a, list of buckets. Where, initially, all the buckets are empty, they're ready, waiting for keywords to be placed in them. So what we need is code to create that empty hash table. So, I think you know enough to define make_hashtable yourself, so we'll make that a quiz. So your goal is to define a procedure, we'll call it make_hashtable, that takes as input a number, giving the number of buckets in the hash table. And it outputs an empty hash table that has that number of empty buckets. So here's one way to define make_hashtable. We're going to start by initializing a variable i = 0. So we're going to start by creating an empty table and what we want to do is add n buckets, number of buckets to the table. So we're going to use a while loop and we're going to loop while i is less than number of buckets. So each time that I want to go through the loop what we want to do is add on empty bucket to our hash table. So we can do that using Append. That adds a new empty bucket and we need to remember to increase I to make sure that we don't keep looping forever. So we're going to go through this loop nbuckets number of times each time adding an empty bucket to the table and then we need to return the table at the end. So let's try that in the Python interpreter. So here's the code just like we read out and we'll print out the result of making a hash table. We'll keep the number of buckets small for printing. For a real use were going to want to have many more than three buckets. And let's run that. And we see what we got is a list with three empty lists as it's elements. So this works okay. It seems like a lot more code than we need. And it is more code than we need. There's a better way to write this, which is to use a four loop. So, the general structure we've seen for four loops. Alright. We've seen a loop that has, has a structure like this, where the collection could be a list. It could be a string. [SOUND] To have a four loop, we need some set of objects that we're looping through. In this case, what we want to do is loop through the numbers from 0 to n buckets minus 1. So we want to create a list that contains those values. So we, what we would like in order to be able to define a procedure like make hash table, is to have a list, which is the numbers from 0 to n buckets minus 1. Python provides an easy way to do that, its called range. So range takes two numbers, as inputs. The start and the stop number. And what it outputs is a list of all the numbers from start up to stop minus 1. So this is what ranges outputs, a list of numbers, starting from start. Increasing by 1, until we get to stop minus 1. We'll note that it doesn't include the value passed in is the second parameter in the list. This turns out to be useful because oftentimes when we look through elements, we don't want to include the last element. So that means if we evaluated something like range 0,10, the result would be the list 0,1,2, up to 9. So now that we know about range. We could change our loop here. Instead of having this while loop, we could do the for loop. And we prefer this for two reasons. The first is it's going to make our code shorter. Anytime we can make code shorter, that's usually a good thing. The second is, it saves us from the danger of forgetting to increment the variable. This is a common mistake, and when we forget to increment the variable, the loop's just going to run forever. So if we can write our while loops at for loops, that's usually a good idea. So a better way to define the catch table is to use the for loop. We're no longer going to need the variable i. We still need table and now instead of using a y loop we're going to use a for loop. We're going to leave the variable name blank for a second, we'll figure out what to put there later, and what we're looping through. Is from the range from 0 up to nbuckets. So we want to look through the elements of the list range to nbuckets. That's going to be the list of numbers from zero to nbuckets, minus 1. And for each one of those we want to append, one new bucket to the table, just like we did before. We don't need to increment i, there's not i variable now. And at the end of the loop, we return the table just as before. For this loop, we didn't actually need a variable here, right? We never used the variable inside. For this index of the four loop, well, we still need something here, so I'm just going to call the variable unused. To make it clear that we have a name there. We don't actually use it in the body of the formula. So this makes the code a lot smaller. It will work the same way as what we had before. So here's the new code. Several lines shorter than what we had before. Does exactly the same thing. If you were really clever, you might have thought of an even shorter way. To define make hash table, that unfortunately doesn't quite work. So the shorter way would be to guess, that the times operator works on list, the same way it worked on strings. So we could do this by creating empty list, times nbuckets. This seems great, it's only one line, really clear and easy to understand, and it looks like it almost works. So let's try that in the Python interpreter. And it looks like it worked, we've got a hash table, a list with three empty buckets. There's one big problem with this approach, and I'll show you a hint why it is, and then we'll have a quiz to see if you can figure out why. So now instead of just printing out the result. We're going to assign it to a variable called table, and now we're going to mimic what would happen when we add something to the hashtable. That means we're going to add something to one of the buckets. Let's pick bucket one, and let's assume we're going to add the entry for udacity with one url. And now we can print out what's in that bucket. Looks like everything is okay. What about what's in bucket zero? Now we get the same result. So, think about what went wrong. I'm going to ask a quiz to see if you can understand why this simpler definition of make hash table doesn't actually work correctly. So the question is, why does this not work? Why does multiplying empty list times n buckets not produce what we need for the empty hash table? And the possible answers are, because it's too easy, and we like doing things the hard way. Because each element in the output refers to the same empty list, or because the store operator means something different for lists than it does for strings. So the correct answer is the second one. So hopefully, no one picked the first answer. We usually do try to do things the easy way. There is sort of an exception to that in this whole unit. That we're learning ourselves how to define a hash table. Even though Python provides a dictionary type, which I'll talk about at the very end of the unit. That makes things much easier than what we're doing ourselves, but we really want to understand a lot of computer science by building our own hash table, and then we won't actually need to use it because there's a built-in text that works much better. But the answer is the second answer, and here's the reason why. So what happens when we evaluate this list multiplication, well, we have this empty list, let's draw it like this. And we create a new list, which is three copies of that list. But it's not copies, it's three references to it. So here's the new list. It has three elements. Each one of those elements refers to the same empty list. Then when we did table index 1 append, well, what happened is we follow this reference to whatever table index 1 is, this object we appended to it, added a new element. But because the references at position zero, one, and two, all refer to the same object, that changed all of those values, not just the value of table index 1. And we can see that if we print out the whole table, that the table contains three elements. But they're all the same. And they all refer to the same object. So any change we make to one changes all of them. So now that we've created our empty hash table, the next steps are to figure out how to do lookups as well as adds. Both lookups and adds depend on the same first step. We need to find the right bucket, so that's what we'll do next. So remember the idea for a hash table, so we have a list of buckets, each bucket is a list of entries, and each entry is a key, and the list of values. So regardless of whether we want to do lookups and added, and find the value associated with the word, or if we want to do add and add a new value associated with a word. The first thing we always have to do is find the right bucket. So if you find the right bucket if we're doing a lookup, the next thing we're going to do is need to look through all the entries in that bucket to find if there's one that matches the key word. If we're doing add, we also need to start by finding the right bucket. Then we're going to look through and see if that word already exists. If it doesn't exist, we can add a new word and we'll have a new entry, with that word and that value. So both of those depend on first being able to find the right bucket, so we'll do that once and be able to reuse that code in both lookup and add. So our goal is to define a procedure, and we'll call it hashtable_get_bucket, and it'll take two inputs. So it'll take a hashtable, and a keyword, and it will output the bucket where that keyword could occur. We don't know yet whether that keyword's actually in the table. It might be somewhere in that bucket. It might not. But the important thing that hashtable_get_bucket should do, is find the bucket. One function that will be useful for doing that is the hash_string procedure that you defined earlier. And hash_string takes two inputs. It takes a string, which is the keyword, and it took a size, the number of buckets, and it outputs the number which is the index of that bucket. There's a bit of a mismatch here that you'll have to think about to define hashtable_get_bucket. That hash_string, the input is the size, the number of buckets, it's a number. The two inputs to hashtable_get_bucket are just the hashtable and a keyword. So you need to also figure out how to get the size of the hashtable to pass into hash_string. And if you remember the structure of the hashtable, you should be able to figure out how to do that. Remember our hashtable is a list of buckets, so the value that we want to pass in to the hash_string is the size of that hashtable, the number of elements in the list of buckets, that is the hash table. So see if you can define hashtable_get_bucket, and as a hint, you can do the whole definition with a very small amount of code. It should only take one line to do this. Here's the answer; we can define hashtable_get_bucket, and it takes two inputs, the hash table, we'll call that htable, and the key, which is the word we're looking for. And to find the bucket, well, we're going to use hash_string. We're going to pass in the same word, the keyword, that's the input key. The number of buckets is the length of this table, so we're going to call hash_string, passing in the key. And as the second input, we need the length of the table, that's the number of buckets. So that will get us a number which is the index of the bucket we want. To get that bucket, we need to use that as the index to select that element from htable, and then we want to return the results. So that's all we need to find the bucket. Let's look at that in the Python interpreter. So here's the code we have so far. We have the hash string procedure we defined that maps the key word and a number of buckets to the position where that should occur in the hash table. We have the make_hashtable procedure that creates an empty table with that number of buckets. And now we have the hashtable_get_bucket procedure that takes a hash table and a key. And give this the element of the hash table which is where that key would belong using that hash string function to find the right position. So now we know how to find the right bucket. Let's look at how to define the add procedure. So we are going to first define add, we'll make hashtable add, that takes a hashtable, a word and a value. And first we'll define a simple version of that, that says we are going to add the new entry to the bucket even if it already exists. So we'll find the right bucket. And we'll add the new entry at the end. So your goal is to define a procedure, we'll call it hash table_add. Takes three inputs: a hash table, a key, which is the word, and a value, and it adds that key to the hashtable, making sure to put it in the correct bucket with the associated value that was passed in as the third input. So here's one way we can define hashtable_add. We're going to define the procedure hashtable_add. So the first thing we want to do is find the right bucket. We'll use hashtable_get_bucket we just defined to do that, passing in the table and the key. We'll store that in the variable bucket. The next thing we would need to do is add the new key value pair. And we can do that using append. Append will add a new element to the list. And what we want the list to be, is a new list with two elements, the key and the value. So let's try this in the Python interpreter, and I've done essentially the same thing that we did before, except for we don't really need the variable bucket. We can do the append right away. So i'm getting the bucket and then append the new entry to it. So we'll start, we'll make a hash table. We'll keep the size of the hash table very low. We would never really want a hash table with only three buckets. But to make it easy to look at the results, we'll keep the hash table very small, and let's add to our table a key and value. And for our actual web index the values will be a list of urls. For our test, they could be anything, so lets just use a number, and now we can look at table, and lets run that. And we see we have the table. We have three buckets, and one of the buckets contains an elements. If we look at the bucket that we get from hashtable_get_bucket for the key udacity, we should get the bucket, that contains the word udacity. Lets try that. That works and we can add some more words to our hash table, more key value pairs to our hash table. So now we've, we have got three entries on our hash table, they all happen to end up in different buckets. That's just lucky in this case. Lets add one more, so we have a bucket that contains more than one entry. And we should print our table after adding one more. And now we have one bucket with one word, one bucket with two entries and one bucket with just one. Now, there is one big problem, with the way we did hashtable_add. Suppose we add the same word again, and let's say now the value of udacity is 27. So now we are making a hashtable that has three buckets. We're adding a bunch of entries to it, we've added the entry udacity twice, now when we get the bucket for udacity. What we see is we have a bucket that has the same keyword twice. If we want our hash table to be a mapping between keys and values, this is going to be a problem. If we have the same keyword twice, when we look up udacity, well, we don't know which answer we should get. Is the value 23 or is the value 27? So, what we want is something a little different from add. What we want is to make sure that every time we add a new keyword to the hash table. If it already exists, instead of having two entries with the same keyword. What we'll do is change the value associated that is associated with that keyword. So we have a problem if we have two entries with the same keyword. We're going to fix that later. Before we fix that, let's define look up. And it will turn out that lookup will actually be helpful in defining a better version of add. So, let's think about what we want lookup to do. It's going to take a hash table and a word, its output is going to be the value associated with that keyword. What we want lookup to do is, like add, first thing it has to do is find the right bucket, and we've defined this procedure hashtable_get_bucket to make it easy to do that. Once we've found the bucket, what we want to do for lookup is go through all the entries in that bucket. See if there's one where the key of that entry matches the word that we're passing in. So, your goals to define a procedure, we call it hashtable_lookup. It takes two inputs, a hashtable, and a key, which is the string, and it outputs the value associated with that key. Whenever you're asked to define a procedure, you should think carefully whether the description is clear enough. In this case it's not. There's a situation that this description doesn't cover. We need to think about the case where the key is not actually in the table. What should we do then? There's a lot of different things we could do. We could produce an error. The problem with producing an error is then we've got to deal with it when we call it. We'd like to, instead, produce the value that we can use to represent the case where there's no entry associated with that key. And we'll use the None value for that. So, if the key is not in the table, the result of lookup should be None, which means there's no value associated with that key. So here's one way to define hashtable_lookup. So we're going to take the table and the key. And the first step is to find the bucket, so we'll use the hashtable_get_bucket that we defined earlier for that, and store it in a variable called bucket. So we'll use hashtable_get_bucket to look up in the hashtable where that key would occur, and we'll store that in the bucket. But now to do the lookup we need to go through all the entries in that bucket, find one that matches the key. To do the lookup, we need to go through all the entries in the bucket. So we'll use a for loop for that, going through the entries. For each entry, we need to check whether the key part of that entry, matches the key, and remember the bucket was a list of entries. And each entry in the bucket was a keyword in the value. In the case for our web crawler, the value was a list of URLs. So if the entry matches the key, so the first part of the entry is the keyword, if that matches the key we're looking for, then what we want to do is return the value. So that's the result of entry position one. If it doesn't match, well then we want to keep going, keep trying the next, we're going to keep going through this for loop, checking all the entries in the bucket. When we get to the end, we didn't find it, and what we said in the question was if it's not in the table, what we should do is output none, so now we'll return, the value none. So let's try that in the Python interpreter. So here's the code, we're defining a hashtable_lookup, we find the bucket, we loop through all the entries in the bucket, if we find one where the key matches, we return the value associated with that key, otherwise we return none. When we got to the end of the bucket without finding the entry, we know it couldn't exist anywhere else in the hash table because the only place that keyword could appear is in this bucket. We still have all the same code from before, that makes the hashtable, that gets the bucket and then adds to the table. And, we'll test it using some of the code we wrote before. We're going to add several words to our hashtable, and let's try looking up a keyword. We'll look up udacity. And we get the value 23, which is what we expect, that's the value that we associated with udacity. So this is looking pretty good. We've got our hashtable almost working. The one problem is the one we mentioned before, if we try to change the value associated with udacity, and we're going to need to do this for our web index, right? When we add all of the urls to the table, we need to keep adding UR, URLs. We don't want to lose the one we have, but we want to change the value associated with, with that keyword. Now, we do the look up again, and we get the same result. And the reason we got the same result, if we look at the bucket in the hashtable that's associated with the keyword udacity, well what we see is it's a list of two elements. And because of the way we implemeneted add, the newer one is later in that list, because of the way we define lookup, it's always going to find the first one it matches. It's going through the entries in order. The first one that matches it returns that value. So thats why we get the value 23. So we're really almost done, but we have to make one other change. We want to change add to be more like update. So instead of adding a new entry, we want to update the value that's associated with that entry. So for the last step in implementing our hash table. Your goal is to define a procedure, we'll call it hashtable_update. It takes three inputs the hash table, the key, and the value. And what it should do is update the value associated with that key. So if the key is already in the table, then instead of creating a new entry like were doing before with add. What we want to do is change the value associated with that key, to be the new value that's passed in. If it's not already in the table, then what we want to do is add a new entry, that has that key associated with this value. This is going to be a pretty complicated procedure. I think it's the most complex procedure you've been asked to define so far. But if you think about it carefully and put together all the things we've seen so far, and understand how the hash-table works, I think you'll be able to define it yourself. So updates going to be pretty similar to look up. So let's start by copying that code and seeing how we need to change it. So we have lookup. We're going to change it to be update. Now instead of taking a key as its input, it's going to take a key and a value. But it's not going to return anything, so we're going to get rid of the returns. Right. remember all update is doing is modifying the value of entry. So now we still have what we had for lookup, we're still getting the bucket and we want to do that. We want to make sure that we update the value in the right bucket. We still need to look through the entries in the bucket, to find if one matches. If we find one that matches, well what we did in lookup, was just return it. And update, what we want to do is change the value associated with that key. So we are going to have an assignment that replaces whatever value is there before with a new value. And now instead of returning the value, we want to stop going through the loop, and we actually are done with update, so we can return here. We found the entry, we updated the value. We also need to deal with a case where we didn't find the entry. So now we've gone through the loop enough times. When it was a look-up we just returned none. When it's an update what we want to do when the key is not already in the table, is add it. So now we're going to use, append, to add a new entry to bucket, that has the key and the value. So that's how we defined update. There's certainly lots of other ways to do it, and one thing you should be thinking about is, well this is actually very similar to look at, right. We duplicated a lot of code. Maybe there's a way to define update and lookup so we don't have to have two copies of the code, that scans through the bucket to find the right entry. We'll leave that as a homework question for this unit. For now we're going to be happy that we've got correct implementations of both lookup and update. And, let's test them. So, what we did before, we're going to replace the adds with updates, and now, the second time, what happened with the add was we added an entry, but we could never reach that entry because it had the same keyword. Now we're used update, the second time we should be updating that value, and we'll see that the lookup now produces the value 27, for the second lookup. That's good, right, the first time the value was 23. We did the update, we got 27, and we can see that the bucket only contains one entry. So this is great, we finished our implementation of the hash table. We can do updates that will either add new values to the hash table, if they don't already exist, or change the value of ones that exist. And we can do lookups and lookup will know where to look, which bucket to look in to find that key, if it exists. So this has the great property that as the number of keys increase. As long as we increase the numbers of buckets accordingly, the time to do both an update and a lookup is constant. This means the time doesn't increase even as the number of keywords increases, as long as we increase the number of buckets. So, this size of each bucket stays the same size, because the expensive cost of this is going through the elements in the bucket looking for the key that matches. So now that we've built it ourselves, I'm going to show you the easy way to do it, which is to use the built in Python type called a dictionary. And what a dictionary is is really an implementation of a hash table. It's built into Python. So it's much easier to use than defining our own hash table. So far, we've seen two complex types in Python. We've seen the string type and we've seen the list type. Now we're going to introduce the dictionary type. So there are many things that are common between these three. There are other things that are different. So to create a string we could have a sequence of characters inside quotes. To create a list, we use the square bracket. And we could have a sequence of elements inside the square bracket, and the elements could be any type, unlike a string where they had to be characters. So, our string was a sequence of characters. Our list was a list of any kind of value. So, a list of elements of any value. The dictionary type we're going to create using the curly bracket. And the entries inside the dictionary are key value pairs. So here I've created a dictionary with two elements. And each element, the key is a string. Here is the string hydrogen and the value associated with that element is a number. The keys in a dictionary can be any immutable value, so they don't need to be strings, they could be numbers. They could be other things. The values can be any value. So what a dictionary is, is a set of key value pairs and the property that a dictionary will give us is like the hash table, that we can look up a key and get a value associated with that key. So one important property of all types is whether they're immutable or mutable. We saw that the string was immutable. That means once we create a string, we can't modify that string. It has the same value it always has. A list was mutable, we could change the values of elements in the list after we create the list. We could append to the list, adding new elements to it. A dictionary is also mutable. So after we create a dictionary, we could add new key value pairs to it. We could change the value of values associated with keys. We saw with strings, if s is a string, then we can do s index i. That will give us the ith letter in the string. With lists, we can do something very similar. If p is a list, we can do p index i to get the ith element of the list. With dictionaries, it's a little bit different. The syntax is the same. We can do d index k. With both strings and lists, these were numbers. Here the k is whatever the key value is. So this is a key in the dictionary. What d index k will give us the value associated with that key in the dictionary. We'll see some examples soon. We can also use our indexing and assignments. We saw, with the list, we could do this. That would replace the value of the ith element of p with whatever we have here. With the string, we can't do that. That produces an error. And the reason we can't do it is because strings are immutable. So there's no way to modify characters in a string. With the dictionary we can. And what the meaning of this, is very similar to the meaning of update in our hash table. So that's equivalent to update the value. The value associated with k to be v. So let's try a few examples. So I'll create a dictionary. We're using the squiggly brackets. And some keyboards that's the shift on the square bracket key. It may be somewhere else on your keyboard. And we're going to use the squiggly bracket, list our elements in the dictionary. So each element of the dictionary is a key value pair. And the entries in the dictionary will be the elements and their atomic numbers, so we have the string hydrogen with its atomic number 1. And we have carbon with number 6. So we've created the dictionary, and what we see when we print it out is the elements of the dictionary. Now one thing you might notice is, they're not in the same order that we put them there. If you think about what we did with hash tables, this isn't so surprising. When we put elements in hash tables, well where they end in the hash table depends on the key and the hash function. It's not necessarily in the order that we put them in. And with the dictionary, because it's implemented like a hash table, we see the same thing. Unlike a list, where the elements are ordered, with a dictionary there's no order to elements. So when we print it out, they might appear in a different order from the order that we put them in. We can use the indexing to lookup one of the elements. So now when we lookup the value associated with hydrogen, we get one. And if we lookup the value associated with carbon, we get six. What do you think's going to happen if we look up a value that's not in the dictionary? So now we're looking up the value associated with lithium. And what we get is an error. It's called the KeyError. KeyError, it says that element is not in the dictionary. This is different from how we define lookup for our hash table, right? We defined our lookup to return none, when the element is not there. The way the built in dictionary type works, is it gives us an error when it's not there. If we don't want to get errors like that, we can use the in, to see if an element's in the dictionary. So the in, behaves similarly to in did for lists. We can say lithium in elements. That will evaluate to true, if the key is in the dictionary, false otherwise. So now, hit a value it's to false. So I said that dictionaries were mutable, so we can add new elements. And the way to add an element, is just to use an assignment. So we'll add lithium, giving it value 3. Note that it was an error, when we used an element like this as a lookup. When it's on the left side of an assignment, well that's an update. So that corresponds to the hash table update. Where lithium is the key and 3 is the value. We can add another element. Let's add another element. We'll add nitrogen. And now when we look up nitrogen, we get the value that we assigned to nitrogen, which is 8. Turns out that 8 is not actually the correct value. That the atomic number for nitrogen should be seven. So we can modify that value, using another assignment. That's again the same as our hash table update. It won't create a new key value because the key nitrogen is already there. But it will update the value, so now the value associated with nitrogen will be 7. So we can see the first print, the value is 8. The second print, the value is now 7. For this quiz, the goal is to see that you understand how to define a dictionary. You should define a dictionary and assign it to the variable population, and it should provide information on the world's largest cities. The key values in your dictionary should be names, the name of each city. And the associated value is the city's population in millions. So that's a number. To get you started, here are the four cities that your dictionary should include. Shanghai's population of 17.8 million, Istanbul with 13.3 million, Karachi, 13.0, and Mumbai with 12.5. If you don't happen to live in one of those four cities, you might want to also include your hometown and any other cities that you're interested in. If you define your dictionary correctly, you should be able to use it like this. Print the population, indexing, looking up the value associated with the key Mumbai, and you should get as output 12.5. So here's one way to solve the quiz; we're going to create a dictionary called Population, and then we'll add some cities to it. We'll add Shanghai, has population 17.8 million. Istanbul has population 13.3 million. Karachi has population 13 million, and Mumbai has population 12.5. I'm also going to add my home town, which is Charlottesville, and the population of Charlottesville is pretty small compared to Shanghai. It is 0.043 million people. Only 43,000. So now we've created our dictionary. We've populated it with some entries. We can print those out. So if we look at the value of population of Shanghai, that will get that entry in the dictionary, and we can see that we get the result 17.8; we can also print out the population of Charlottesville, and we get the result 0.043 So here, I've been using just numbers as the values, but the values can actually be anything we want. They can even be other dictionaries. So if you wanted to make more interesting version of elements. So we'll start with an empty dictionary, and we can add a new element. This time we'll use the atomic symbol as the key, and we'll make the value of the element a dictionary that provides some information about it. So we've added an element to our dictionary. The key is the single letter H, and it has as its value a dictionary, that has three entries with the key name number and weight. And values associated with each of those that could be different types. Name is a string, which gives the full name of the element. We'll add another element to our dictionary, and so for helium, we have the same name, number and weight keys, and, so for helium we have an extra entry that says it's a noble gas, and the value of noble gas is true. So now we can look up the element H, we'll see it's entry. Again note that it's a dictionary, so the order is not the same as the order that we used here. But we can do another lookup. So now we're looking up element H, that gets us the dictionary here. And then we're looking up in that dictionary the value name, and that will give us the name of the element, whose symbol is H. We can change this to look up some other property. Let's look at the weight. And we can change element to look up the value for helium instead of for hydrogen. And now we get the 4.002, which was the weight of helium. If we look up the noble gas property, we get true for helium. What's going to happen if we look it up for hydrogen? So here we get an error, and we get the same error that we got before when we tried to look lithium up in the elements that didn't include lithium as a key. We are looking for the key noble gas, but it doesn't exist. So now I hope you understand how to use dictionaries. And so the next step, we're going to go back to the search engine code from the previous unit, and modify it to use dictionaries instead of the nexus. And this will have the big advantage that now we can do our lookups in constant time as long as we increase the number of buckets with the number of keywords. So to start thinking about this, the question is which of the procedures that we've defined for our search engine will we need to change to make use of the dictionary instead of using the list? So, here's the choices, all the procedures that we've defined so far. So we had a procedure get_all_links, and get_all_links would scan a web page, return a list of all the links in that web page. We had the procedure crawl_web; we have crawl_web, which started with a seed page, and then followed all the links that could be found in that page collecting pages, and for each page, collecting the keywords on that page and adding them to the search index. We have add_page_to_index that would take a page; it was called by crawl_web when it, a new page was found and would add that page to the index by finding all the words on that page, adding them to the index. We had add_to_index, which would take the index, a keyword and the URL where it was found and add that location to the index. And we had lookup, which would take a keyword and give us a list of all the URLs where that keyword would appear. So to answer this, you may need to look at the code, and you'll find it on the website. Think about which ones of these procedures we'll need to change to replace the list index with the dictionary index. So the answers is, we need to change the three of these procedures. We need to change crawl web, we need to change add to index, and we need to change lookup. We don't need to change get all links at all, that we can keep exactly the same as it was. It just returns the list of links, it doesn't depend on the index. We don't need to change add page to index. This is a little more surprising since it depends on index, but because of the way we wrote add page to index, it calls add to index. So it doesn't depend how we actually represent the index. It's going to go through all the words add them to index by calling add to index. So we don't actually have to change that code. We do need to change the other two, so let's start with crawl web and figure out what we need to do to change this, to use a dictionary. And the change is actually going to be really small, right? The index is here, in the old version we initialize index to a list, to the empty list And all we do with index is pass it in to add page to index. So to change that to use a dictionary, all we need to do is change the square brackets to be curly brackets. So now, instead of starting with an empty list, we're going to start with an empty dictionary. So that's the only change we need to make to crawl_web. The change to add index is going to be a little more complicated. And we can see from the code to crawl_web, what happens with each page was that we call add to index, passing in index, which is now a dictionary. Let's look at add_page_to_index. I claimed that we didn't need to change that. Here's the code to add_page_to_index. And it takes the index. It goes through the words. It adds each word to the index. We can do this just the same whether index was a list or a dictionary. We don't need to change add page to index, we are going to need to change add to index. So we are going to need to change the code to add to index and lets try to figure out how. So before we had add to index, that takes an index, a keyword and a URL. We'll still take the same parameters but what we had to do when it was a list was go through all the entries in the index, check for each one, if it matches the keyword we're looking for. If we find that it does, then we add the URL. If we get to the end without finding it, then we append a new entry, which is the keyword with a list of URLs containing just the first URL. So let's figure out how to change this to work with the hash table index. So, the great thing about the hash table is we don't need to loop through anything now. We know exactly where it is from the hash table. With the dictionary, the built in in-operation gives us that. So instead of looping, now we can check right away if the keyword is in the index. So what's going to happen if we found the keyword in the index, that means that we can look it up. This will look up in the dictionary the entry that corresponds to the index. That's going to be the list of URLs that we have. And so all we need to do now is append to that entry the new URL. If it's not in the index already, well we need to do something different. What we did before was we added a new element to the index list using append. We don't want to do that now. We want to add a new key value paired to the dictionary. So we're going to do that by using the assignment. And the entry that we're adding is the list containing just this URL. So you can delete everything else here. Add the new entry to the keyword. So this is a lot simpler. We have less code. And it's going to run a lot faster. We don't have to loop through anything. Because of the hash table, we can right away look up whether the keyword is in the index, we can find if it is, what the value is, by using the dictionary lookup, and we can append the newer URL to the list of the URLs associated with that keyword. If it's not found, we can create a new entry, using the dictionary syntax, like this, that contains just that URL. So, now we've got a much simpler way to add to index. I hope you understand this. If you do, you should be able to define lookup yourself. For the final quiz for this unit, your goal is to change the look up procedure to now work with dictionaries. Before we had look up working where index was a list of entries, and we did the look up by looping through the index, that required a lot of work we had to go through each entry, check if the keyword matched, and then return the one that matched, if we got to the end without finding it, we returned none. Your goal for the quiz, is to modify this code to now work where the index is going to be the dictionary, and we should be able to find the entry much more quickly. We don't need to loop through anything. we can use the property of the dictionary to look up the entry right away. If you understand the add to index code that we just did, I think you can define look up on your own. The one thing to be careful about, is that you need make sure that when the index does not contain the keyword, when it's not in the dictionary, instead of producing an error, that it returns the value none. Here's one way to define look up. Instead of needing the loop, we're just going to need to check to if the keyword is in the index, if it is, we can return the value associated with that keyword using the dictionary look up like this. If it isn't, we return the value none. Congratulations, you have completed unit 5. You have a search engine that can respond to queries quickly, no matter how large the index gets. This problem of analyzing the cost of algorithms and designing data structures that are more efficient, is one of the core ideas in all of computer science. It's something we go into a lot more depth on in later courses that I hope you will take after finishing CS101, including the Algorithms and Theory of Computation course. The main thing we have left to do for our search engine, is to find a way to get the best page for a given query, instead of all pages. This is the main thing that made Google so successful - figuring out a better way to identify the pages searchers really care about. Thats what we are going to look at in unit 6. Hope to see you back soon! In the first homework question, we have to determine which of the given functions scale linearly with the input list p. Let's go through the functions 1 by 1. This should look familiar. All sum_list does is take an input list p and calculate the sum of the numbers in p. In this case the worst and the best case are really the same, because no matter what, you traverse this for loop for the length of p. And accordingly, if you double the number of items in p, you also double the run time because you have to go through twice as many items in this for loop. And so the run time of sum_list scales linearly with the number of items in the list p. This procedure determines whether or not a given list p has duplicate elements. Let's go through a quick example. Here's a small list with the elements 0, 1, and 1. Going through the code here, we have i and we have j. In the first iteration of the loops, i and j are both going to be 0. That means we're looking at whether the first element is equivalent to the first element. We have this case right here that says not to compare the same element with itself. So j increments and now we're comparing the first element with the second element and they're not the same. We do that again, the first element with the third element. They're not the same. We then increment i and reset j. 0 and 1 are not the same, 1 and 1 are not the same, and lastly, we have 1 and then 2, and in this case the second element and the third element are the same, so we're going to return True. That's how this works. Now, in order to examine the run time, the key part here are these 2 for loops. For this for loop we're going to go roughly the length of p, and for every element in p we're also going to go roughly the length of p. This creates a quadratic run time in relation to the number of elements in p, namely if we double the number of elements in p, we're going to increase the run time of the entire procedure by a factor of 4. Here we have our mystery function. You've never seen this before, but the general structure should be familiar. Here we have a while loop, and we set i to 0 and we're going to continue this while loop until i is greater than or equal to the length of p. And looking down here, we're basically going to be iterating through p, but we're going to do it a little different than normal. If the element in p at index i is even, we're going to increment i by 2. Otherwise we're going to increment it by 1. So the worst case for this function in terms of run time is if every element in p is odd, meaning we only increment i by 1 for each iteration. So we're going to go at half the speed that we would if every element in p was even. Simplifying the worst case, all we have is a while loop through every element in the list p, so this is clearly linear in the worst case. I'll also note that in the best case the run time of the mystery function is also linear. That may be a little confusing at first because it goes twice as fast, but we're really concentrating on the growth of the run time so that even if it is going twice as fast as the worst case, if we double the number of elements in the list p, the run time is also going to double. In the question hash string, we have to determine which of the following statements are true. Let's go through the statements 1 by 1. The first statement says the number of string comparisons done to look up a keyword that is not a key in the hash table may be less than the number needed to look up a keyword that is a key in the hash table. As this turns out, this is actually a true statement. In order to show it, we need an example, so let me give you an example dictionary with 3 buckets and 3 keywords in here. I'm not showing the values because they don't really matter for this example. It could be the case that if we search for "Batman" our hash function takes us to bucket 0 and then we have to compare between "Andy," "is," and finally "Batman." So that would be 3 string comparisons. Let's say we search for "Irvin" and that brings us to bucket 2. There's nothing in bucket 2, so there's no comparisons to be made. This is an example where it actually takes more comparisons to look up something in the hash table than it does to look up something not in the hash table. Statement 2 says we should expect the time to look up most keywords in the hash table will decrease as we increase the number of buckets. And with a good hash function this is true. Let's say we have a hash table with only 2 buckets. If we have a good hash function, the number of keywords in each bucket is the same. And so the average number of comparisons is going to be half the size of a bucket in order to look up a keyword in the hash table. If we double the number of buckets, the average lookup time is decreasing significantly. And with a good hash function the time is going to decrease even more. Statement 3 says it is always better to have more buckets in a hash table. This is a pretty strong statement, as indicated by the use of the word always, and it's really because of that word that the statement is false. There's really 2 good reasons. The first reason is because changing the number of buckets, be it more or less, changes where keywords hash to. It could be the case that with 2 buckets I have a good distribution. But if I add a third bucket, the hash function is such that everything lands in that new bucket. We choose hash functions carefully so that this is less likely, but depending on the keywords you're using, this is still possible. And the second reason is memory. I could have an arbitrarily long hash table, but they can use a lot of space, especially if there are a few keywords that go into it. Real-world implementations of hash tables try to shoot for a ratio between the number of buckets they have and the number of keywords, increasing the number of buckets accordingly as the number of keywords in the hash table decrease and increase. Statement 4 says the time to look up a keyword in the hash table is always less than the time it would take in a linear time list (as used in Unit 4). So the question is, is the lookup time always less than the lists that we've been using previously? And as you might suspect, this statement is false. We're going to show that by giving an example hash table. If I have a hash table where 3 keywords all go in bucket 1, if I want to look up the keyword "Batman," I'm going to go to bucket 1 and iterate through each item in this bucket until I find "Batman." That's essentially the same as a normal list where we just start from the beginning without doing any kind of hash function and just go through each item 1 by 1 searching for "Batman." For the next few questions we're given this data structure of courses. Let's take a couple seconds to go through what it looks like. It's a dictionary where each key in the dictionary is a hexamester of courses that Udacity offers. In each hexamester we have another dictionary that's where the keys are the name of the course, and within that there's another dictionary with name value pairs. This is a common way to store data in an unstructured form where we just have an attribute like name, teacher, assistant, whatever-- prereq down here--and then a value for that attribute: Building a Search Engine, the name of the TA, etc, etc. This question asks us to write a function that determines whether a course is offered during a given hexamester, and we're going to do that pretty simply. Before we get started, let's look at the data structure. What we want to do is, given a hexamester and the name of a course, we want to determine if that course is a key in the dictionary to which that hexamester is associated with. And this is just 1 line of code, actually. What this line of code does is determine whether or not the course is a key in the dictionary that we get with the keyword hexamester in our course's data structure. In this next question, we want to find all the hexamesters a given course is offered. So if we go back to our data structure, what we're going to do is go through each hexamester, each key in the highest level dictionary, search through all the keys of that dictionary. If they equal the course we're looking for, we're going to append it to a list of our results. The first thing I do is create the result list, and we're going to go through every key in courses to get each hexamester. If that course is in the dictionary for that hexamester, then we're going to append it to our offered list. And once we're finished, we're just going to return the list. In the last question involving this data structure, we want to create a dictionary that contains the hexamesters as the keys and the values as a list of each course a given person is involved with. So let's look at Dave. For April 2012 he's involved in 2 courses: cs101, his intro course, and cs387, the Applied Cryptography course. And the dictionary continues on, but the structure stays the same, where the key is the hexamester and the value is a list of courses for which that person is involved. So 1 question you may be asking yourself, what does it mean to be involved? And if we go back to our data structure, what we're going to do is look at the name value pairs associated with the course. So if we're looking for Steve, Steve is associated with his class, cs253, the Web Engineering - Building a Blog. And so that's what we're going to do. We're going to go through each course, looking at the value in the name value pairs, and if the value is what we're looking for, then we're going to add that course to our dictionary associated with the key of that hexamester. It sounds a little convoluted, and the answer is a little long, but it's really a simple idea. The first thing I'm doing is creating the output dictionary. We're going to go through each hexamester. We're going to go through each course in each hexamester. We're going to go through each key in the name value pairs. If the value associated with all this is the person we're looking for, then we're going to update our output dictionary. If we've already added this hexamester as a key to the output dictionary, then we're just going to append this course at the end of the list associated with that hexamester. Otherwise we're going to create a new list for which the course is the sole value, and once we're done with all these for loops, we're going to return our output dictionary. In lecture, Dave pointed out that these 2 functions, hashtable_update and hashtable_lookup, use some similar functionality that instead we could place in a separate procedure. Looking at the hashtable_update and lookup procedures here, we see code that's identical between them, namely these 2 lines. In both functions, these 2 lines of code go through a given bucket searching for an entry whose first value is the key. And so what we're going to do is we're going to take this code and move it into a separate helper function. This is known as refactoring. Refactoring is a common software engineering practice where we change the code without changing the functionality. There's a number of reasons to do so. For example, here we're doing it to minimize duplicated code. This is desirable, because if we want to change how these 2 lines of code work-- perhaps we change the structure of the bucket-- we don't want to look through every hash table function searching for how this works and updating them. Rather, we just want to update it in 1 place. This minimizes bugs and saves time. So let's give it a try. Here I've created a new function called bucket_find. You should see that it's very similar to the code that we have in update and lookup in that we're going to go through the bucket searching for the entry whose first value is the key and then returning the entire entry so that we can use it accordingly in both update and lookup. So now that we have the helper function, let's change our hash table functions to use it. The resulting code is going to be both simpler and shorter. I've changed hashtable_update. We find the bucket in the first line, then within the bucket we're searching for the key, and if we find that entry we're going to update the value. Otherwise we're going to append the key and the value to the end of the bucket. It looks quite a bit simpler than the original function. Let's do the same thing to lookup. In the new hashtable_lookup, we first find the bucket and then within the bucket we search for the entry. If the entry is not None, we return the second value. Otherwise we return None. Ã¯Â»Â¿This question asks you to implement a cache and to show you why we might need a cache; I am going to run the code without one but for 40 instead of 100. So letÃ¢Â€Â™s see how long it takes. So while thatÃ¢Â€Â™s running, weÃ¢Â€Â™ll look at the code to execute the cache. What the format of the cache will be, which is a dictionary is as its key values it will have the inputs and the value associated with that key will be the output. So it will be an input output pair, we donÃ¢Â€Â™t want to evaluate the code more than once for any given input, so what weÃ¢Â€Â™re going to do is check whether the input is in the cache or not. If it isnÃ¢Â€Â™t in the cache, weÃ¢Â€Â™ll add it to the cache. So weÃ¢Â€Â™re now ready to return it. So for the input, we return the value of the cache. If itÃ¢Â€Â™s not in there, we add it; if it is in there, we just return it, and letÃ¢Â€Â™s see if that runs. And it does fairly quickly. So now letÃ¢Â€Â™s go back to the un-cached version and see how that runs for just an input value of 40. And now we have a solution. The answer to the 40th Fibonacci number and thatÃ¢Â€Â™s what it calculates, cache fibo is actually Fibonacci numbers and youÃ¢Â€Â™ll learn more about those in unit six. First number is the answer and the second number is the amount of time it took in seconds to calculate that number. So thatÃ¢Â€Â™s without the cache. Now letÃ¢Â€Â™s have a look at the cache, at the same version with the cache and IÃ¢Â€Â™ll run that and you can see that itÃ¢Â€Â™s done in about point one milliseconds. So there is a huge difference there, two minutes or point one milliseconds. So we had a lot of great questions about hash tables on the forums and one example is Student Baracha asks "How does Python decide how many buckets a dictionary has as it grows?" So this is an important question, and there are lots and lots of interesting things about hash tables that we did not get into in Unit 5. If memory was free and cheap, and equally fast no matter how much you needed, then you'd want the hash table to be as big as possible, right? You'd want billions of buckets in your hash tables so they'd never have to have more than one entry in a bucket. But as we saw in Unit 3, memory can be expensive. And the faster and the closer to the processor the memory is, the more expensive it is. So you have a very limited amount of that, there's a reason to try to keep the hash tables small as well. So this is a tough trade-off. Good hash table implementations try to make this trade-off in a way that gives you the right balance of performance and memory use. They do this by looking at the load factor. We actually used this in Unit 4. This is just the number of entries divided by the number of buckets. We had that question in Unit 5. The question where it was "N divided by B" where you're looking at the impact of the change of the number of buckets and the number of entries. One thing you have to worry about when you do that is if you're just looking at the number of keywords and the number of buckets, that's the average size. What matters in many applications is more the worst size. Even if the average size is fairly small, the worst size could be much larger than that, and if the lookup for the worst case entry starts to get very bad, then you want a larger number of buckets or to change your hash function in some way. So, for a typical hash table implementation, the goal is to keep the load factor actually below 1 usually. For Python's dictionary implementation, if the number of keywords exceeds about 2/3, and I think it's actually exactly 2/3 of the size of the table, that's the point where the table is resized. So the table would then be doubled, and that changes the bucket each word would appear in, because we saw that the result of the hash function depends on the number of buckets you have. So you'd have to copy things into the new hash table that has more space, but that's going to make the look-ups faster. So this means that if you had about a million entries in your hash table, you would expect to have about a million and a half buckets. But as you increase above that 2/3 threshold, then you'd double the size of the buckets. So you'd end up with 3 million buckets, if you added one more entry beyond that. So if you compare this to what we did in Unit 5, you might be surprised that it's so low. We were doing example hash tables, where the number of buckets was very small, and each bucket had many entries in it. This is partly to be easier to see what's going on, because if you saw a hash table with thousands of empty buckets, that would be kind of hard to print out. But the other reason for that is the way we implemented the hash table in Unit 5 was each bucket was a list. And with a list, that's a fairly expensive data structure. You've got to create all those empty lists to create your hash table. The way the Python dictionary is implemented, there's just one flat list. That means there's one space for each hash value, that if you hashed to a given bucket there's only one space there. That means if two things hash to the same bucket, you've got to do something else. And what happens with the Python dictionary implementation is you look for another free place to put it and you have a way for deciding where you look for the next one if the first one is full. This makes look-ups and adding to the table more complicated, so that's why we didn't do it. But it means you're using less memory, because you don't have all those empty lists for all the empty buckets. There's a great chapter in a book called "Beautiful Code" that's all about the Python dictionary implementation. So if you're interested in how that's actually done, I encourage you to look at that chapter. Our next question is from Student Kirk Charles, and he has quite a story here. Okay, "So we know Peter is very excited about launching his new search engine business." This is true. SearchWithPeter.info is actually launched. It's a really cool site Yeah I put a lot of work into it Web 2.0 and all that. "Let us suppose he is targeting the underserved market of Klingon language web searches. Let us suppose also that he is writing some custom hashing procedure. After 8 months of explosive growth in business," I hope so, "Peter finds that he needs to double the number of buckets in his hash table. He also finds that the hash buckets are not utilized evenly, since he did not understand the hashing of Klingon very well." Sounds like a hard problem. So, his question is "How can we re-hash the index without service interruptions? This is made more difficult by the fact that his user base may get violent, if he delays search results. Additionally the long latency of intergalactic networks means he also needs to carefully roll out a new hash." Which strategy should he, I guess I, take? Wow, well this is quite a question from Captain Kirk. I'm glad he is hoping for the success of SearchWithPeter.info. And thinking about the future is an important thing to do I think one thing I understand is Klingon name servers don't support the ".info" domain. So I think you're probably safe from the Klingon attack for now, but it's a good question to think about when you have to re-hash a table. So we've been talking about the standard way a hash table works. Once the buckets get too full, or the load factor is too high, you want to create a new table with more buckets, and you've got to copy all your entries to it. If you're running a big service like SearchWithPeter.info, you don't want to shut down your service while you do that. That would get people pretty annoyed. If they're Klingons, you don't want to get them annoyed. So what you could do instead and there are lots of different things, and I don't know what Google does, I'm sure there are lots of solutions that are possible, and they've figured out something that works well. One thing to do would be start a new copy, so you keep the search engine going, still responding to queries using the old hash table but you start a separate process of running on a separate computer, something that's making a new copy of the hash table with a larger number of buckets. Then when you're done with that, you switch them over and you have the larger table with new buckets going. Other than the switch over, there's no interruption in service when you do that. There's some things that make this hard. You've gotta worry about "Well what if a new entry is added to the hash table while you're in the middle of copying it." You could lock it, make it so you can't add add any new entries during that time. That might be a bad thing if it takes a long time to copy. You could maybe add the entry to both hash tables. Every time a new entry is added, you add it to both the original one and the copy as you're developing it. You could save the updates and apply them all later after you finish the copy. So there are lots of tough problems to solve to make this work without interruptions, but it's definitely an important question to think about if you're building SearchWithPeter.info, and you have a lot of angry Klingons. I probably should have been taking notes. Depending on the service. Well, we'll see. Hopefully the Klingons don't know where you live. We've recently reached 50 users on SearchWithPeter.info. We had a cake, and threw a party, it was pretty cool. Cool, congratulations Thank you. Student Kevin Troy asks, weÃ¢Â€Â™ve seen in this unit the use of import time to get access to time the clock. Can you talk about the basics of libraries, what they are and how they work et cetera? Okay, this is good because I donÃ¢Â€Â™t think I explained really whatÃ¢Â€Â™s going on when I use that. What import does is just bring a library into your execution environment, so you can have a library that defines different variables, defines functions, defines anything that you would define in your own Python code and then when you import it you get access to all of that but itÃ¢Â€Â™s not in your own file. And having libraries is really useful. It limits the size of the file that you have to deal with, it protects the name space, so if everything that was defined as part of the standard library was always available and you didnÃ¢Â€Â™t have to import it, there would be name, more names that you have to worry about using because they already have some other predefined meaning. So libraries are really useful. You can make your own libraries, weÃ¢Â€Â™re not going to cover that and IÃ¢Â€Â™ll see as one-on-one but as you start to build bigger programs itÃ¢Â€Â™s really important to think about how do you structure your program, so you donÃ¢Â€Â™t end up with one huge file with lots of code that no one can figure out whatÃ¢Â€Â™s going on. So libraries are very useful way to do that. So student Lisa asks, what would be different in world where almost everyone was programming literate. So this is the core question and obviously I feel that it would be great to have such a world thatÃ¢Â€Â™s why we are trying to encourage as many people as possible to take this class and hope youÃ¢Â€Â™ll encourage any non programming literate people that you know to take the next version in this class starting in April. There are lots of things that understanding programming even at just a basic level and I think many of you are beyond the basic level now if youÃ¢Â€Â™ve made it this far in CS101, but in terms of the things that you interact with and the things that you see in the world, almost all of them are controlled by programs these days and people who understand programming can relate to those things and have better way than people who donÃ¢Â€Â™t. And some of this can be sort of fairly obvious things when you interact with a website and you can tell, well theyÃ¢Â€Â™ve got some bugging it because the programmer didnÃ¢Â€Â™t think of that both branches of the NIFT test and if you are a programmer or you at least understand about programming that you maybe have a better sense of what is going on but you also can get a lot more familiar by it because you know well this is something any programmer who knows what they are doing should have test before and understand whatÃ¢Â€Â™s going on and itÃ¢Â€Â™s really annoying that you have to deal with their mistake. Other things you probably have a better understanding of how complicated it is and how hard it is to get things right that you might be a little more forgiving when things break and have better ideas about well this is probably why itÃ¢Â€Â™s breaking, letÃ¢Â€Â™s try to use this tool or use this product in some slightly different way. So thatÃ¢Â€Â™s one of the reasons. The other reason I think is there are lots of things that people encounter every day that if you know a little bit about programming instead of doing a lot of tedious work as a human you can find a way to automate that and save yourself a lot ofÃ¢Â€Â¦ There is a good example of this right here in our office. So when recording these video we generate hundreds every week to get the classes out for all these courses and they are all named kind of default things by the video camera and video X, X, X, 1, 2, 4 and whatever but what we need to do that is that organize them like date and time and course and what not. And so whenever video editors wrote script, weÃ¢Â€Â™d just kind of the programming that you got from here and a little bit previously to do this automatically. Whenever we record videos we just give it to her and she sorts it automatically and saves the video editors hours of time. Okay, thatÃ¢Â€Â™s great and I think people once you get a little experience with programming youÃ¢Â€Â™ll see things like that every day that youÃ¢Â€Â™re seeing people could be yourself but itÃ¢Â€Â™ll less often be yourself spending their time doing tedious things that are not fun for humans. That you could write a few lines of python code to solve and so I hope, at the end of this class and I think by this point in the class many of you really should be at a level where youÃ¢Â€Â™re instead of just solving the problems that weÃ¢Â€Â™re giving you in the homeworks, youÃ¢Â€Â™re finding real problems in your life and in your friends lives that you can solve by writing a little bit of code. So, I hope everyone will be doing that and spreading the value of programming literacy beyond that, beyond just yourself. Welcome to Unit 6. The big idea in Unit 6 is recursive definitions and we'll see how to use a recursive definition of popularity to make the search engine respond with the best page for a given query instead of just giving us all the pages. This is really a key advance that made Google so successful. The real goal of this unit is to give you infinite power. I know what you're thinking, I have infinite power already, and you're right. You've had infinite power since Unit 2 when you learned about procedures and if. And that was enough to write every possible computer program. But we went on to introduce while, to use a while loop to find all the links in a page. And that really should not have been necessary. If you already had infinite power, you wouldn't have needed anything new to do that. What we're going to see in this unit is that you could do that without while, that all you really need is procedures, and by thinking about things recursively, you can solve lots of problems in interesting ways. So, we'll start with a quiz. It's kind of a trick quiz. The question is, what's the longest word in the English language? If you're not a native English speaker, don't worry. This quiz is just as hard for the native English speakers as it is for you. And, here are the choices: honorificabilitudinitatibus, antidisestablishmentarianism, hippotomonstrosesqvipedaliophobia, pneumonoultramicroscopicsilicovolcanoconiosis, or none of the above. So the answer is none of the above and we'll see why in a minute. First I want to mention that all of these are sort of real words. It's not that well defined what it means for something to be a word. The first one is the longest word used by Shakespeare. This is 27 letters long and it means roughly, with honor. The second one is one letter longer. It means the movement against the division of church and state. The third one, which is 35 letters long, means fear of long words. You can see it's made up of phobia, which is fear and a really big sort of made up root about things being big and words. So it's fear of long words. The fourth one is the longest word in most large dictionaries. It's a kind of lung disease that you get from having contact with volcanic particles. So, the reason the answer is none of the above is that I'm very confident whatever you claim is the longest word, I can alwauys make a bigger one. There is no such thing as the longest word in the English language. So a word is just something that has meaning that speakers of a language will understand. We could define words as just what's in the dictionary, and then there would be a clear answer for that. But certainly there are lots of things that are words that aren't in the dictionary. And the important thing about words is that we have rules for making new words. For example we have a rule that says if we have a word, we can make a new word by adding counter in front of the old word. I'm using the same notation that we used back in unit one. This is a BNF replacement grammar. If you need a refresher on this, please go back to the video that introduced that in unit one. But the basic property is that we can replace what's on the left side with what's on the right side. So, anytime we have a word, we can replace it with counter-word. And the meaning of the new word is something that goes against the original word. So, if we started with the word, intelligence, and I mean this in the sense of spy craft. Not in terms of smarts. Well then, we can use the rule. We can make the word, counter-intelligence. Intelligence was a word. We added counter in front of it to make counter-intelligence. And that means trying to thwart intelligence from the enemy. We can use the rule again, so now this is a word, and we can replace this word with counter in front of that word, and we get counter-counter-intelligence. And that would be trying to thwart the enemy's counter intelligence, that's preventing you from getting intelligence. And we could keep doing that. We could have counter-counter-counter-intelligence. And so forth, and these are words that, once we get up to at least three counters, it's not something that's used before. But it's still something that has a sensible meaning, and we could do this for other words. So we saw that one of the very long words was this hippopotomonstrosesquippedaliophobia. And if you knew that this word meant fear of long words. Even if you've never seen the words counter in front of that before. So now we can make the new word counter-hippopotomonstrosesquippedaliophobia. Quite a mouthful. But even though you've never seen that word before. And I expect most of you have never seen that word before. Well, you could guess that this is something that goes against the fear of long words. Maybe, there's some new medication that cures people of this phobia. And you could also figure out, well, if there was a counter-counter-hippo and so forth phobia. Well that would be something that counteracts the counter-hippo, and that might be something where this new drug doesn't work if you have too much coffee. Then coffee would be a counter-counter-hippo so forth phobia. So the point is, because English has this rule that allows us to make new words from old words. There's no such thing as the longest word, we can always make a longer word, starting from any word that we have. If you remember how BNF grammars work, then you should be able to answer the next quiz. So the question is, if the only rule that we have for making words is this one, the one I should you before, where we have the non-terminal word, and that can be replaced by counter followed by another word, then the question is, how many words can we make starting from the non-terminal word? And the possible answers are none, one, two, or infinitely many. So the answer is none, that we can't actually make any words with just this rule. And the reason for that is this is a circular definition, and it's a circular definition because we, we can never stop. If you remember the rules for BNF grammars, that we can start from a starting on terminal, and we keep doing replacements. We can only stop once we have all terminals. We are never going to get there if this is our only rule. We can keep adding more counters, but we can never replace the non-terminal word. Because every time we end up with the non-terminal word again, on the right side. So with just this rule, we can't actually make any words. All we can do is start from word. Now our only choice is to replace word, with counter-word well, we only have one rule, so our only choice is to replace the word here with counter-word. So now we end up with counter-counter-word, but since word is a a nonterminal, we're never done. So we can never make any word this way. So let's try adding one more rule. So now we'll ask the quiz again. But this time our grammar has two rules. So now we have two rules. We have the rule we had before, which allows us to replace word with counter-word. And we're going to add one more rule. It says we already know one word. We know the word hippopotomonstrosesquipedaliophobia. So now the question is, how many words can we make? The possibilities are none, one, two, or infinitely many. So now, the answer is infinitely many. All we needed was these two rules and we can make infinitely many words. This is the power that recursive definitions give us. And unlike the previous definition which was circular, what we have now is what we call a recursive definition. That means, we have defined word in terms of itself but that's not the only way we've defined word. We also have this other rule that allows us to have a starting point. That there's one word that we have that's defined not in terms of itself. So here's how we can make infinitely many words using these rules. So we can start with a non-terminal word and let's say we choose to use the first rule. We can replace word directly with our [UNKNOWN] and we're done, but we have another option. We could have replaced word using the second rule, with counter word and if we replace this word, using the second rule, we'll end with that word counter hippo [UNKNOWN] phobia. But that's not the only choice, right, we could've chosen to use the first rule again, and then we were to replace this word with counter-word and so now we have counter, counter, word. Again we have the choice of what to do with this word. We could use the second rule, replace it with the terminal. And then we'll have counter, counter hippo. Or we could replace it using the first rule. And then we'll have counter, counter, counter followed by word. So this can keep going as long as we want. We can produce all of these words with any number of counter, either zero, repetitions of counter one, two, three, four. As many as we want. That means we can produce infinitely many words. Some of them are going to be pretty hard to pronounce. Actually, they're all pretty hard to pronounce. But, there's no limit to the number of words that we can produce this way. So this is what's called the recursive definition and the important thing that it has is two parts. It has a base case which is here. That's the stopping condition. That's something that says we have at least one word that we can define already. That we don't need to define in terms of word. And it has the recursive case that says we can define a word in terms of another word. And if we combine those two, well now we have a definition that can make infinitely many words. So this works for things other than words. The place where you've seen it the most so far has been in language, but we're also going to to see how to use it to make procedures. And you'll also see how to use it in later classes, how to define data structures. There are lots and lots of different things in computing that are defined recursively. And a recursive definition has two parts. It has the base case. In our example with the word, that was the second rule. And the base case we can think of as a starting point. And the important thing about the base case, is it's not defined in terms of itself. It has to be something where we already know how to define it. So for programs, it's usually going to be the smallest input, or one of the simplest inputs. Something where we already know the answer. We don't have to do any computation to figure it out. The second part is the recursive case. And that is defined in terms of itself. [BLANK_AUDIO] But it shouldn't be defined in terms of itself exactly. It should be defined in terms of some sort of smaller version of itself. We need to make progress to eventually get to the base case. We'll see what that means in programs soon. First, we're going to try one other example not in terms of a program, just to get a better sense for how things can be defined recursively. The question we want to think about is how you could define who your ancestors are. The way to think about ancestors. Well, here's you. Hopefully, you're smiling, because you're enjoying learning about recursive definitions. And you had some parents. Let's assume you had two. And we won't assume whether of not your parents are smiling, but let's hope at least one of them is. And your parents were your ancestors, but they're not all of your ancestors. Your parents had parents, as well. These are your grandparents. Grandparents are always happy. So, they're all smiling. And your grandparents, well, they also had parents. Those would be your great-grandparents, and so forth. And all of these, except yourself, are your ancestors. So our goal now is to define that precisely. Can we come up with a definition that describes exactly this same relationship, all the ancestors that you have? So the question is, which of these is the best definition of ancestors? And there are three choices, the first has one rule, ancestor is replaced by parent of ancestor. The second has two rules, ancestor is replaced by parent, and ancestor is replaced by parent of the ancestor. The third has three rules. Ancestor is replaced by parent. Ancestor is replaced by parent of parent. And ancestor's replaced by parent of parent of ancestor. So the best answer is the second choice. The first rule by itself is not sufficient. And the reason the first rule doesn't work is that there's no base case. We can keep producing parents of ancestor and parent of parent of parent of ancestor. But we can never stop because there's no rule that defines ancestor in terms of something other than itself. The second rule is a recursive definition that works; it says our parent is our ancestor. And the parent of an ancestor is also an ancestor. And so, this will give us exactly the set of ancestors that we showed before, that it will be the parent, the parent of the parent, the parent of the parent of the parent, the parents of the parents of the parents of the parents and so forth, covering all of our ancestors. The third choice will also produce that same set, but it has an unnecessary rule that we only need these two rules. Here we've said, parent, parent of parent, parent of parent of ancestor. We can still combine these rules to produce any word that is parent of parent of parent of any number of times ending in parent, but it's less elegant than the second answer, which only needs two rules to produce exactly the same set of ancestors. So we've seen how to use recursive definitions to make words, and to define concepts like ancestors. Now we're going to see how to use recursive definitions to define a procedure. And we're going to start with the procedure that we already defined in unit two. We defined the factorial procedure. And we defined factorial as the number of ways that we can order n items, and the input is the number n. And that could be calculated by multiplying n times n minus 1 times n minus 2, and so on until we get down to the 1. So that definition is not very precise mathematically, and the problem with this as a mathematical definition. Is, it's got this, dot dot dot in it, and humans sort of understand that correctly, what that dot dot dot means, but it's not a very precise mathematical definition. If we use a recursive definition, we can define factorial in a much more precise way. And we need to do that by giving a base case, so for the base case we want to think about the simplest input, something where we already know that answer. And for factorial, and for many procedures that involved numbers, the simplest input is the number 0. So if we try factorial 0, the number of ways to arrange 0 things is defined as 1. So we know that result. That's going to be our base case. Now all we need to do is define the recursive case, where we want to define what the meaning of factorial for any number n is. Where n is any integer greater than 0, and we can define that in terms of the factorial of the smaller numbers. So if you look at this definition with the dot dot dot, well we see that the factorial of n is n times n minus 1 and so forth. Well, this what we have here, is actually the factorial of n minus 1. So that means that we can define the factorial then as n times the factorial of n minus 1. And that's our recursive case, and this definition matches our intuition well, if we think about factorial meaning the number of ways to arrange n objects. This corresponds exactly the way we think about this, that we have n ways to pick the first item. And once we've picked the first item, well, we have n items left, and factorial of n minus 1, gives us the number of ways to arrange the remaining n minus 1 items. So that's a way to define this mathematically. So now, I'll leave it to you as a quiz, to figure out how to define a procedure, that computes factorial without using a y loop. So your goal for this quiz, is to define a procedure, named factorial, that takes a number, which is a positive whole number as its input, and outputs the number of ways to arrange the input number of items. So, that's the mathematical definition of factorial. And, for your procedure, we've already seen how to do this using a Y-loop. Your goal here is to define that procedure without using a Y-loop, to define it as a recursive definition. So here's how we could define factorial. And, we should go back to our mathematical definition. That's what we want to turn into code. We had our base case where factorial is 0. The result should be 1. And we had our recursive case, where there is input is greater than 0. We want to have the result be n times factorial of n minus 1. So we can turn that fairly straightforwardly into code, so here's the code. We're going to define a procedure. Just like the previous definition, we have one input, it's a number. We'll call it n. Now we need to have the code, so we need to first check if we've reached the base case, so we'll use an if for that. And we're going to check if if n is equal to 0, remember we need the double equals for the comparison. That means we've reached the base case. And we defined that value factorial as 0, is defined as 1. So that means when n equals 0, what we should do is return the value of 1. When it is not equal to 0, we'll use else for the case where n is not equal to 0. Well then we have the recursive case. And that was given by the definition, that the factorial of n, for numbers greater than 0, is equal to n times factorial of n minus 1. So that's exactly what we want to do in the Python kid. We'll turn the new result, which is n times the result we get, calling factorial passing in n minus 1. And this may seem strange that we're defining factorial using factorial. It seems like that's kind of circular, but the reason that it's not circular, is because we have this base case. That we have a case, where we do stop, we stop once we reach the case where n is equal to 0, and because every time we call factorial, instead of passing in the same value of n that we started with, we're passing in n minus 1. It's getting smaller. Eventually we're going to get to 0, assuming that we started with n as some positive whole number. So we eventually stop, return one. And on the way there, we're going to be multiplying in all these values. So let's step through what happens when we run this code. So let's look at an example. Suppose we called factorial passing and three. So that means we're going to enter the procedure here. The value that n refers to is going to be 3 inside the body of factorial. We're going to try the comparison. It is not equal to 0, so we don't return 1. So we're going to go to the else. And that means we're going to return the value of n times factorial of n minus 1. So that means we're computing the value of n times factorial then and n minus 1, well, n was 3, so n minus 1 is 2. That's what happened as a result in the first call. But we're not done, right. We still need to evaluate this, so now we're evaluating factorial of 2. That means we're entering factorial again. This time the value of n will refer to 2. We do the comparison, n is not equal to 0 so we go to the else clause. Now, we're going to return the result of n times factorial n minus 1. In this case, the value of n is 2. So the value of factorial of 2 will be 2 times the result we get by calling factorial, passing in the value of n minus 1, so calling factorial passing in 1. And remember that was part of the return, where we had 3 times factorial 2. So we still have the 3 times. But now we're getting the result of factorial 2. It's 2 times something. We're calling factorial again. We still don't know what factorial of 1 is. So that means we're going to reenter factorial. We finished here. We're doing the call. We're going to re-enter factorial, but this time the value of n now refers to 1. And now again this test is false. So we go to the else clause. And now we're going to return n which is 1 times the result of factorial 0. So now, we're calling factorial 0. We're going back into the procedure. Now, the value of n refers to is 0. And, now, this test is actually true, n equals 0. So, we'll go to the return here. We return 1, that means the result of factorial 0 is 1, so to get the result of factorial 1, we had 1 times factorial 0, that's 1 times 1, which is 1, and now to get the result back from factorial 2, we had 2 times factorial 1, which we now know is 1. So we're going to have, the result here as 2. And to get the result for factorial 3, we have 3 times factorial 2, which we know has the value 2, will get the result, as 6. And note the way we've defined it, well if we tried instead, factorial 4, if we started with factorial 4, what would have happened is the first time we go through, we get 4 times factorial 3. So factorial 4 would be 4 times factorial 3. Well we had factorial 3 as 6, 4 times 6 would give us 24, which is the result of factorial 4. So, we can do another example of defining a recursive procedure. And the goal this time is to take in a string, and determine whether or not it's a palindrome. What a palindrome is, is a string that reads the same way, forwards and backwards. So, an example of a palindrome would be level. If we read level forwards, we get level If we read it backwards, we get exactly the same thing. Another example of a palindrome would be the word, the single letter a. If we read a forwards, we get a. If we read a backwards, we also get a. In fact, any single letter must be a palindrome. The empty string is also a palindrome. If we read the empty string forward, we have the empty string, if we read the string backward, we also have empty string. So, our goal is to define a procedure that will take any string as input and output true if that string is a palindrome. I am going to view, give you a few hints how to do this, but start thinking on your own, if you can think of a way to define a procedure that tests whether or not a string is a palindrome. So, this is a pretty tough question. See how far you can get on your own, but I'm going to provide some hints before we make the quiz. So, the first hint is, we want to think of what it means to be a palindrome. To try to formalize that definition, if we knew easy ways to produce the reverse of the string, and check if it's equal. Well that would be an easy way to solve this, and in fact there are ways to do that in Python. But we haven't seen them yet. And I want to have you think about ways to do this palindrome that don't depend on that. So, that means we need to think about a way of defining a palindrome in terms of simpler things. So, the first thing to notice is, there's one simple case where we know right away whether a string's a palindrome. So, we should think that that might be our base case. When we do procedures on numbers our base case is often something that deals with a number like zero or one, a small number. When we do recursive procedures on strings, it's more likely that our base case is going to be the simpler string, which is the empty string. So, we know that if the input is an empty string, the result of this palindrome is true. The empty string is a palindrome. What if the input's not an empty string. Well then, one way to solve that would be to look at the first letter of the string, and look at the last letter of the string. If those two are equal. Well, then it might be a palindrome. It's a palindrome if all the ones left over in the middle are also a palindrome. So, this is how we could break the question of testing whether a string's a palindrome into smaller steps, that our recursive case is going to test the first and the last character of the string, see if those are equal, so if our recursive case. We're going to test the first and the last characters of the string. If those don't match, we know it's not a palindrome. That means we know the result is false. If they do match, we're not done. We need to check the rest of the string. And that means, we need to check the middle of the string, if that's a palindrome. And because we're able to define this recursively, remember that we're defining the procedure is_palindrome, but we can do this test assuming that we've already defined it. In order to check whether the middle of the string is a palindrome we can use the procedure that we're defining. This is like we were able to use factorial to define factorial in terms of a smaller number. In this case, we're defining a palindrome in terms of the smaller string. So, I hope this is enough for you to get started, so see if you can define the code for is_palindrome, keeping in mind that we can break it down into these two cases where if it's empty, we know it's a palindrome right away, if it's not empty, well, we need to look at that first and last characters. If they do match, we also need to look at the middle of the string. So here's a way to define is_palindrome. So we're taking a single string as an output, I will call it s, and we're first going to test the base case. So the base case was to see if the string is empty, we should return true right away. So we can do that with an if. We are going to check if s is equal to the empty string, and if it is, we return true, that's our base case. For the else, we have the reverse of case so now we need to do the test of the first and the last characters to see if they match. And we can do that using the string indexing operators, as 0 gets us the first character, s negative 1 gets us the last character. If they match, then we need to check the rest of the string. If they didn't match and let's finish the didn't match case first. So if they didn't match then we know it is a palindrome, because we found a place where the first and the last character did not match, so it should return false right away. If they did match, well then we have the harder problem. We need to do the recursive call to check all the other letters in the strings still form a palindrome. So this was our starting string. It had all these characters in it. We checked that this one matches this one, so now what we need to do is take the rest of the string and check if this is a palindrome. So that'll be a recursive call, so we're going to return the result, of calling is_palindrome. But instead of passing in s, what we want to do is pass in the string starting from position 1 of s, so removing the first character, and ending at position negative 1, removing the last character. And remember with our indexing, the last value here is not included. So by having the last index as negative 1, that removes the final letter of the string. So the first thing to test is the base case. So we'll pass in the empty string. And the empty string is a palindrome, so it should give us the result true, which it does. Let's try the single letter string, a, that's also a palindrome. It's the same backwards and forwards. And so we also get the value true, if we try say string ab, which is not a palindrome. We get false. As a longer test, if we try a level, we should get true. Which we do. And, let's try one of the most famous palindromes, amanaplanacanalpanama. And we should get True which we do. [BLANK_AUDIO] So any procedure that we could write recursively. We're going to also write without using a recursive definition. And I want to show you another way that we might have defined is palindrome. So here we're doing this with the for loop, and we're looping using the variable i and the range from 0 to the length of s divided by 2. So that's going through halfway of s. And inside the loop we have an if-test that checks if they character at position i is different at the position negative i plus 1. So that's going to be counting from the back of the string, i's positions away. If those are different, then we've found a mismatch and we return false. If they're not different, we're going to keep going through the loop. Once we get to the end of the loop without finding any differences, we know it's a palindrome and we return true. So this is also another way we could define is palindrome. I think this is more complicated to understand, and harder to get right. It took me three tries before this code worked correctly, whereas the recursive definition, I could get right the first time. If we wanted to test very long palindromes, this would be much more efficient, than the code that we had with the recursive definition. And there are a couple of reasons for that. One is that the recursive definition keeps making new strings, every time we do the recursive call, we have to create a new string, and that's pretty expensive. Another reason is that the recursive calls themselves are fairly expensive, and there are languages that make recursive calls fairly cheap. Python is not one of them. In Python, it's fairly expensive to do a recursive call. So for most procedures, the recursive way is often the most elegant, and the easiest way to get correct. If we're really worried about performance, and we need procedures to work on really large inputs. We're often better off trying to find a non recursive way of defining that procedure. So before we get to the problem of ranking web search results, I want to talk about one more interesting workers definition, the fibonacci series. And fibonacci numbers are one of the most interesting things in mathematics. Once you know about them, you'll see them all over the place, both in nature and in human designs. The name co mes from Leonardo da Pisa who was also know as fibonacci. And back in 1202 he published a book called Liber Abaci. The root Abaci is the same as the one for abacus the calculating machine. And this translates loosely as book of calculus. This was the book that introduced Indian mathematics to the west. In particular it introduced what we now know as Arabic numerals. This replace the Roman numeral system that was then widely used. And part of what fibonacci did in the book was show, how much easier it is to do calculations, using numbers in the decimal systems where the place, where the number is indicates its value. And as part of the book introduce these problems, and showed how to solve them using calculation. The problem that became known as the fibonacci numbers was one of the problems in the book. And he posed a problem like this. So at the beginning, we have one pair of rabbits, and it takes one month for a rabbit to produce offspring, and every month a mature rabbit will produce a new pair of rabbits, so at month one, we had one pair of rabbits. At month two, well, we have the one pair we started with. And now we have a new pair. We have two pairs of rabbits. And now at month three the baby rabbits aren't yet ready to produce offspring. It takes a month for the rabbits to reach maturity. But these to will produce new offspring each month. So we have one new pair of baby rabbits and the rabbits that were born in month two, well they've had a month to get bigger. So now, they're mature rabbits. So we had three pairs at the end of month three. So month four we still have the three pairs of rabbits we had, rabbits never die in this model, and the two pairs that are mature, both of those will now produce new rabbits. So we have two new pairs of baby rabbits. The baby rabbits that were born in month three, well now those are mature. So now we have three pairs of mature rabbits, and two pairs of baby rabbits, so we have five pairs of rabbits total. And this keeps going, so the model assumed that rabbits never die, that every month each pair of mature rabbits produces a new pair of rabbit babies. And it takes one month for a pair of rabbits that spawn, to become mature. So in month five, the three mature pairs of rabbits, will all produce new offspring. New offspring, new offspring, three new offspring. And the two that are a month old, that were born in month four, now become mature. So this isn't a very accurate model of how rabbits reproduce. It's good for us, if it was an accurate model, it would only take a few years for rabbits to control the entire planet. But it's an interesting mathematical model. And the model that this poses, we can write in a more formal way. So, the number of rabbits is the number of rabbits we had in the previous month, since those rabbits don't want to die. So in month five, we have the five pairs that we had in the previous month, plus all of the rabbits that were mature, meaning, all of the rabbits that we had, two months ago, which was three if we're on month five while those reproduce. So we have three new pairs of rabbits, plus the five that we have in the previous month. And this keeps going. So we could in month six, we're going to have the eight rabbits that we had at the end of month five, plus the five mature pairs, one, two, three, four, five, will each reproduce. So we'll have five new pairs, and that will give us 13 pairs of rabbits. So this was the model fibonacci developed. And the question is, can you figure out, at the end of month n, given any number n, how many rabbits will there be? So the way we define this mathematically is a little different from the way, fibonacci posed the question. And that's because in modern mathematics, we usually like our series to start with a zero. If we are thinking of modeling rabbits, well that doesn't quite make sense to start with zero rabbits. But if we're thinking of it as a more general series, it does. So the way it's defined mathematically is that we say that the fibonacci number zero, is defined as zero. Fibonacci number one is defined as one, and those are our two base cases. So this is different from the other recursive definitions we've seen in that the two base cases. Previously, all of our definitions just had one base case. And then we can define every other fibonacci number, but first we'll be starting from these base cases. And so, the fibonacci number n, where n is some whole number greater than one, is, well we have all the rabbits in the previous month. So, that's fibonacci of n minus 1, plus, all the new babies. And the number of new babies is the number of rabbits we had two months ago, those are all the mature rabbits. That gets added to the number of rabbits we had the previous month. So that's how we define fibonacci numbers. This defines every fibonacci number in terms of the two base cases, and in the one recursive case. So, your goal is to define a procedure called fibonacci. That takes a natural number as input. So, numbers starting from 0, any whole number 0 or higher, and outputs the value of that fibonacci number, defined using this recursive definition. So here's one way to solve this, we're going to define a procedure Fibonacci and we'll call the input n. And now we need to write the code, and if we remember our definitions; so we said Fibonacci of 0 is defined as 0, Fibonacci of 1 is defined as 1. And Fibonacci of any higher number is defined as Fibonacci of n minus 1 plus Fibonacci of n minus 2. So if you remember the definition, we have two base cases we need to consider. If the input value is 0, or the input value is 1, we need to do something special. So we could write those as separate if statements. So if n is equal to 0, what we want to do is return 0. If n is equal to 1, what we want to do is return 1. Otherwise what we want to do is the recursive part of the definition. So we want to return the result of Fibonacci n minus 1, and we want to add that to Fibonacci n minus 2. So we could simplify this a little bit. Let's try this in the Python interpreter. We're going to define Fibonacci, so here's our definition, and let's try this out, so we'll print the result of fibonacci 0, first, we should get 0, which we do. We'll try fibonacci 1, we get 1, so we've seen our two base cases. Now, when we do fibonacci 2, what we should get is the result of. Fibonacci 1, which is 1, plus Fibonacci 2, minus 2, which is Fibonacci 0, which is 0. So we should get 1 again, which we do. And now let's try printing Fibonacci 3, we get 2. And if we print Fibonacci 4 we should get 1 plus 2; which is 3. Which we get and if we try 5, we should get 2 plus 3, which is 5. And let's try something a little bigger, let's try Fibonacci 10. We get 55. We'll try Fibonacci 25, so we'll try Fibonacci 24. So for counting months that would be the number of rabbits in two years, and we get 46,000. And let's try, in 3 years. Our program times out. So I'm going to try the soon in the Python interpreter, well see we can do slightly bigger ones. But, the time it takes to solve Fibonacci, this way, is very long. And, the reason for that is because we're doing lots and lots of redundant calculation. So, if we look at what our code is doing. Every time, we call Fibonacci n, what's happening is we're calling Fibonacci n minus 1 and we're calling Fibonacci n minus 2. So we're starting, we're calling Fibonacci 36, that was the example, where the interpreter didn't finish. And, what we'll get is that's going to be broken down into calling. Fibonacci 35, plus the result that we get from calling fibonacci 34. Each of those, is another call to fibonacci, so the call to fibonacci 35, well that will be broken into, calling fibonacci 34, and adding that result to what we get from calling fibonacci 33. And when we do fibonacci 34 here. Well, that's going to be turned into, calling Fibonacci 33, and adding the result to Fibonacci 32. We're going to do lots, and lots, of calculations here. And we haven't got close to getting down, to fibo 1, or fibo 0, which are the only places that we stop. If we look at the number of times we have to evaluate, fibo 32, let's pick that one, so Fibonacci 32,. So we need to evaluate, Fibonacci 32, 1, 2, 3, 4, 5, times. The number of times we had to evaluate, Fibonacci 33, was 1, 2, 3, times The number of times we had to evaluate Fibonacci 34. Was 2 times, and the number of times we had to evaluate fibonacci 35, was 1 time, and the number of times we had to evaluate fibonacci 36 was 1 time. So, maybe you can see a pattern here. How many times do you think we're going to need to evaluate, fibonacci 31? So, maybe you can see a pattern here. For the quiz, I'm going to see if you can figure out how many times we'll need to evaluate Fibonacci 30. Evaluate fibo 30 when we're evaluating fibo 36. See if you can figure this out without drawing out the whole thing and counting it, that's going to be a lot of work. But if you think about what we've seen so far, maybe you see a pattern here, and you can figure out the result for how many calls there would be to fibo 30 without doing all that work. So see if you can figure out the answer without working out every step. [BLANK_AUDIO] So the answer is 13. And the reason for this is quite interesting. If you look at the answers we were getting so far, this is the number of calls for each number. So when we had fibo 36, the number of calls was 1. When the input was 35, the number of calls was also 1. When the input was 34, the number of calls was 2. When the input was 33, the number of calls was 3. When the input was 32, the number of calls was 5. We should start to notice a pattern. This is exactly the Fibonacci series that we're computing here. Every time we decrease n by 1, so to get the number of calls for 32, we added the number of calls for 1 before. And the number of calls for 2 before, and if you look at the structure of this, it follows from the same rule that we had; thinking about the number of rabbits. Reproducing. That everyone that we have on the previous level, leads to two more. And that means as we do this addition, we have all the previous calls. So we had, 1 call the 34 at the previous level. We're going to produce two new calls but the inputs are different. But, if we look at the way the inputs are distributed, we have 2 plus 1 here. We have 1 plus 1 for 34. We have 2 plus 1 for 33. For 32 we have 2 plus 3. We have 5. For 31, we're going to have eight calls, and for 30, we're going to have 5 plus 8, which is 13. And this will keep going. These numbers will get. Quite big very fast, and the number of calls we need, every time we evaluate fibo 36. So the evaluate the number of calls, when we started with 36 that's going to be the result of fibo 36 minus n minus 1, so the number of calls we'll need to fibo 2. And evaluating fibo 36 will be fibo 33 calls, and we don't know what that number is yet, because when we tried to evaluate fibonacci 36, using our recursive definition, our evaluator timed out, so we're in big trouble. If we want to figure out how many calls there are, we need a more efficient way of computing Fibonacci numbers. So let's see if we can do that. And the reason this was so inefficient was because we're doing all this redundant work, right? We saw that to compute fibonacci 36, well we had to compute fibonacci 35, and we had to compute fibonacci 34, all of this work computing fibonacci 34. We did the same exact thing over here, right? This is producing the same output. There's tons and tons of redundant computation going on. So if we're going to compute this more efficiently, we don't want to duplicate all that work. We need to do it in a way, where we don't need to keep recomputing the same thing. So the solution to this, is instead of using a recursive procedure to compute Fibonacci. We're going to compute fibonacci using a while loop. Anything that we can define recursively, we can also define without using a recursive definition. It's often much easier and cleaner to think about things, with a recursive definition, but it's often not the fastest way to calculate things, and certainly, in this case. Because of all the redundant computation, it's a very, very inefficient way to calculate fibonacci. So let's try to do this with a y loop instead and we'll make that a quiz. So the goal is to define a faster Fibonacci procedure, fast enough to enable us to compute Fibonacci 36. To estimate, at least according to Fibonacci's model, how many rabbits there will be in three months. And I'm going to give you a little hint for how to do this. So we're going to want a while loop, and the loop. It's going to go up to n. But within the loop you are going to need to keep track of two things. You are going to need to keep track of the two previous fibonacci numbers. And instead of going backwards the recursive definition did. We started with our base cases, we started with our base cases with zero and one and then we defined every previous case by adding the previous two. So to compute this with the y loop. If we keep track of the previous two, invariables then you can compute the next one by adding those. And then what you gotta figure out is how to keep up to date the variables, to know what the previous two are each time you go through the loop. So see if you can figure out how to define fibonacci yourself. Test it on some of the smaller numbers before trying it on fibonacci 36. But if you define it this way, you should be able to compute Fibonacci numbers for much higher inputs than we could with our recursive definition. So here's a way to define Fibonacci iteratively. [BLANK_AUDIO] We're going to avoid all the redundant computation by keeping track as we go. And we're going to have two variables. And I'm going to do this in a slightly strange way, and the reason for this will become clear soon. I want to make it so we can get the right answer when n is 0 and when n is 1, without having special cases. So instead of keeping track of the previous two, I'm going to keep track of the current one and the imaginary one that's going to be after that. And we know that the first two Fibonacci numbers are 0 and 1, so [UNKNOWN] current is 0, and the next one, we'll call after is 1. So that's the one after the one that we're currently doing, and now we have a loop, so we're going to go from i in the range from 0 to n. So we're looking for Fibonacci number n, that means we want to start at 0. The current value is the value for Fibonacci 0 and after is the value for Fibonacci 1, and as we go through the loop, we'll keep updating those. And we want to update them by following the recursive rule and so that means that the new value of current, is the current value of after. And the new value of after, is the sum of those two lists; current plus after. We can do that with a multiple assignment, that'll save us from needing a temporary variable. We can assign current and after, to their new values. The new value of current, is the current value of after, and the new value of after is current plus after. So, this is the place where a multiple assignment comes in handy. If we didn't use a multiple assignment, we'd have to use a temporary value to keep track of one of these while we do the assignments. But with multiple assignment, we get both of these values first, and then we assign them to the two variables on the left side. So, that's all we need. And then after the loop, we should return the value of current, which is the current Fibonacci number if we're looking for Fibonacci N. So let's try that. So we should be able to see Fibonacci 0, and the result should be 0. And that's what we get, and, because that's the value of current, when the range is from 0 to 0, we don't go through the loop at all. So we get the value 1. Let's check Fibonacci 1, and we run this, we get the value 1, which is also what we expect. And we got that because we went through the loop once, assigning the value of after, which started as 1 to current and that's what we return as the value of current. And we can keep going, we'll try Fibonacci 2. And that's also 1, as we expect and Fibonacci 3 should be 1 plus 1, gets us 2 and so forth. [BLANK_AUDIO]. Okay, so this looks like it's working. We've tried a few simple ones. Let's try Fibonacci 33. So we estimated in the earlier quiz, in order to compute fibonacci 36, we would need Fibonacci 33 calls, using the previous recursive definition. So, why did it take so long for that code to run? So what's the value of Fibonacci 33? And that's what it is, it's 3 and a half million calls. And so even with a processor that's doing a billion instructions a second, doing 3 and a half million recursive calls takes quite a while. Each time through the call, is many more than just one instruction it's many thousands of instructions. So this starts to take enough time that we didn't see the result. And, it wasn't only those Fibonacci 33 calls to Fibonacci 2, we had all the other things that we had to do to get Fibonacci 36. But let's see that now we have our faster, internet definition of Fibonacci that isn't doing all that duplicate work, that we can compute Fibonacci 36. And so that gives us this value, so indicating that there would be about 15 million rabbits after 3 years using Fibonacci's model. Let's try what we'd have after 5 years, passing in 60 months, and we get this starting to be quite a huge number. To try to relate to this, let's look at how long it would take for the mass of all the rabbits that are born to exceed the mass of the Earth. So the mass of the Earth is 5.9722 times 10 to the 24, and that's in kilograms, and I'm using the times time notation. This gives us a power, so this is 10 to the power 24. So that's one way to write 5.9 times 10 to the 24 kilograms, just to demonstrate the power notation, this is 2 to the power 10, so we'll see the result is 1,024. That's what we get by multiplying 2 times 2 times 2 times 2 10 times. Here we're multiplying 10 by itself 24 times and that's a good estimate for the mass of the earth. So now to find out how many months it takes before the mass of the rabbits exceeds the mass of the earth, we're going to have a for loop. We're going to loop from Fibonacci numbers, until we get to a number that exceeds the mass of the Earth. We also need to decide what a mass of a rabbit is, and I'm going to assume that a rabbit weighs about 2 kilograms. And, that's a pretty good guess for how heavy a rabbit is. That's assuming of course, a well fed rabbit like we have today, not if the rabbits spread as fast as Fibonacci's model would suggest that they do. So, we'll write a loop to see when the mass of the rabbits exceeds the mass of the earth. We'll start with n equals 1, and we're going to keep going until Fibonacci n exceeds the mass of the earth. So, we'll go while Fibonacci n times the mass of the rabbit. So Fibonacci n gives us the numbers of the rabbits in month end, times the mass of the rabbit and as long as that is less than the mass of the Earth, the Earth is still safe for humanity, or at least there's some space left for humans. And every time through the loop, we'll increase n by 1. And at the end of the loop, we'll print out the value of n, we'll see where we got, and let's also print out the value of Fibonacci n, to see how big the Fibonacci number of that n is. So we'll keep going through the loop, as long as the Fibonacci of n times the mass of the rabbit is less than the mass of the Earth. And once we stop the loop that means we've exceeded the mass of the Earth and we'll see what the results is. So let's try running that, and, we get this result. The value of n is 119, so it'll only take 119 months, or just less than 10 years, until the mass of the rabbits exceeds the mass of the Earth. And this is the number of rabbits we would have then. A pretty big number, you should be very afraid of all these rabbits. The good news is that Fibonacci's model, is not actually correct. That this was a mathematical abstraction for rabbit reproduction. Real rabbits actually die off after some point, and if there're too many rabbits, they don't have enough food, so they don't keep growing like the Fibonacci numbers and take over the entire planet. So we should be very afraid if Fibonacci's model is correct. It would only take 10 years for the rabbits to take over the entire planet, and weigh more than the earth does itself. The good news is, it's not a very accurate model of how rabbits reproduce, that they don't live forever, and once there're too many rabbits, they start to run out of food. So they stop reproducing, and stop surviving. So now that you've survived the bunny uprising, we're ready to get to the main goal of this class, as far as building the search engine. Our goal is to improve the results by finding the web page instead of just returning a list of all the web pages that match a query. As the web has grown, it's become more and more important for search engines to do this ranking well. That what really distinguished Google from previous search engines was they had a much smarter way of ranking pages that produced more useful results, where the first one or two results in response to a search query were often the very thing that the user was searching for. So now we're ready to start thinking about the problem of how to rank web pages. Let's start by recapping how our search engine works. So we started by building a crawler. And what the crawler did, and this is what we did in units one, two, and three, what the crawler did was follow all the links in the web pages. Following those links, building up an index. And the end result of the crawler, after units four and five was we had an index. By the end of unit five, it was a, a table where we could look up a key word, and we would find the entry where that key word might appear. And we'd follow, and we could look through each of those entries to find the one that matched, and that would match the key word that we were looking for. And as it's value, it would have a list of all the urls where that keyword appears. And the order of those urls in that list was determined just by how we added them to the crawl. Every time we encountered new page, we indexed that page, and we added a url for that keyword. So the one that's first in this list is just the one that we happen to find first. So say it's the c page. The one that's second would be the one that we find next. And it's this page. So, this doesn't tell us anything about which page is best. So the order of the URLs in the list and what we were getting as our output just depends on the order that things happen to go in the crawl. When the web was really small, which was quite a while ago now, this was sort of okay. That there were only a few pages that might match a given keyword, and you could look through them all and decide which one you wanted. With the web today, this doesn't work at all. There are thousands of pages that match any interesting keyword. Maybe millions. Certainly many more than you want to look through by hand. So the most important thing that a good search engine does is to figure out how to rank these pages so the one that's at the front of the list is the one the user wants. So that's our goal for the rest of this unit, to figure out how to rank pages. Before we do this for web pages, we're going to do something very similar, but perhaps easier to relate to. We're going to talk about how we decide who's popular. So here's a typical group of friends in middle school. And some of the people are popular, some of them might not be. The first step to deciding who's popular, is looking at who has a lot of friends. So let's draw in some links, that show who's a friend. And friendship links are one directional. Just because Alice's friends with Bob, doesn't mean that Bob is friend with Alice. So we'll draw our links as arrows, so this means this person, we'll call him Bob, is friends with Alice. And let's say, Alice has many friends. And let's say Bob is also friends with this person, they're friends with each other. We have lots of friendship links. Some of them are bi-directional but not all of them. So, we have lots of friendships. So, is this enough to decide who's popular. So, if you went to a school like I did, it's not. Just having a lot of friends is not enough to make you popular, you have to have the right friends. You have to be friends with the popular people. So, it's not enough to have lots of geeky friends say in high school, you've gotta have lots of friends that are popular. So that means the definition of popular, isn't just about having lots of friends, it's about having lots of friends, who also have lots of friends. That's what make some one popular, so we can define popularity of a person is the number of people who are friends with p. This means the number of links from someone else to that person is their popularity score. So here is Charlie, so there are one, two, three links into Charlie, so Charlie's popularity score would be three. Alice also has three links, so her popularity score would also be three. Bob only has one arrow going to Bob, so his popularity score would be one. So, this isn't a bad way to define popularity, but it's not quite right. So, the definition of popularity doesn't just depend on the number of friends you have, it depends on, both, the number, and the popularity of your friends. So, we can change the definition. Let's instead define the popularity score of a person p. Now it's going to be the sum of the popularities of all of their friends. So we can write that in a mathematical way, so using the sigma means to sum up. We're going to take each friend, that is in the friends of p. And we're going to sum up the popularity score of the friends. If the mathematical notation is unfamiliar to you, we could also write this as pseudo Python code. We're thinking of the popularity of a person p. Let's assume we have a function that gives us the friends. So we're going to start with a score of zero. We're going to loop through the friends. And for each friend, we're going to add to p score, the popularity score of the friend. And we'll return the score as the result. So now, you've seen a mathematical definition of popularity, you've seen the same thing as code. I'm going to ask you a very important quiz question next. Its an easy one to get right if you try it twice because there's only two answers, but think about it carefully. See if you can get it right the first time. The question is, is this a good recursive definition? The answers are yes, or no. And for something to be a good definition, well it has to provide a meaningful answer, for all possible inputs. So the answer is no. That it does not and the key reason why it does not is there's no base case. Without a base case, it's not a recursive definition. What it is, is a circular definition. And that means that it actually doesn't give us any answers. Because we'll never finish here right. The only way that we've defined popularity whether you look at that mathematical expression or the python code. Always involves calling popularity again. And we are never going to get to a point where we can stop. That we are going to keep calling popularity for different people. If we think of doing this for our friend graph, well here's what would happen. If we wanted to know the popularity of Charlie. Well, we have to look at all the people who are friends with Charlie. So, that means that the popularity of Diana, the popularity of Edgar, and the popularity of Fred. But, for each of those, we need to compute their popularities to the popularity of Diana. That's going to be equal to the popularity of Alice. So, now we're here, but we need keep going. And, the popularity of Alice is the popularity of Edgar, and the popularity of Bob. But we need to giv, keep going. We still need the popularity of Edgar well, that's the popularity of Fred. And we need the popularity of Bob, which is the popularity of Fred. And we need the popularity of Fred, which is the popularity of Charlie, plus. The popularity of Bob. So, this is not okay, right? The problem is, we started trying to figure out the popularity of Charlie, we did all this work following these links backward. And now, to solve it, we need to know the popularity of Charlie. But that's not what we were trying to solve. So this is not a recursive definition. To be a good recursive definition, we have to end up with a simpler version of the problem. And never go back to the one that we started with. The way we've defined it, we get back to the one that we started with. We haven't made any progress. We're never going to get an answer. Charlie will be very unhappy because we'll never know how popular he is. So how can we fix this problem? Well, the first thing we should think about is, well, can we give a base case. All right. All of the recursive definitions we had. We had a way of stopping. So, we had a base case. Right. With, factorial, we said, we are going to pre-define, that we know the value of factorial when the input is 0. We know that the value is 1. We are not going to define it, in terms of factorial. We are going to note it's value. We did this for palindrome we said, palindrome, we have a base case, when the input string is an empty string, it's predefined as a palindrome We don't have to do anything else. And we did this for fibonacci, where we had two bases cases? But for all these definitions, we had some starting point, that was not defined in terms of thing we are defining. And that's why it was good recursive definition, because we had the base case. We don't have one here. So let's try to invent one. Let's suppose that we made our base case. So if we're going to fix this, what we need to do is invent a base case. Maybe that will solve our problem. So let's try and add a base case. So. Suppose we assume we know the popularity of Alice and sadly Alice is not very popular. Her popularity score is a 1. So that looks like a base case, right we define the base case for factorial for 0 for palindrome for space. Let's pick Alice as our base case now. And. That works like this for the mathematical definition. For the python code, what we would need to do is add the base case, as in a statement. So we would insert a line here that says that if p is Alice, return Alice's popularity score which is our base case which is 1. So this looks more like the recursive definitions we've seen. Now we have a question. See if this actually works. So the question is, would this definition work? The possible answers are, only if everyone is friends with Alice, only if no one is friends with Alice, only if, from every person in the network,. There's some way that you can follow links that eventually reaches Alice. Only if there are no cycles in the graph. So there's no way to start from one person and end up at the same person by following friendship's, by following friendship links. And the final choice is no, that there's really no situation where this works well. So the answer is no, that even with any of these restrictions, we still don't have a good definition. So, let's consider all the restrictions. So, the first one was, if everyone is friends with Alice. So that would only work if they don't have any other friends. Let's say this is Alice. We've got Bob and Charlie. They're both friends with Alice. But Bob is also friends with Charlie and Charlie is friends with Bob. That means that to figure out the popularity of Bob we need to know the popularity of Charlie. To figure out the popularity of Charlie we need to know the popularity of Alice as well as the popularity of Bob. So we're never going to get to a solution. We are going to keep bouncing back and forth between Bob and Charlie doing this. The second choice only if no one is friends with Alice. Well, if no one was friends with Alice, that would remove these links. It doesn't solve our problem. We're still not going to be able to give a popularity score for Bob and Charlie. The third choice only if there is a friendship path from everyone in the graph that eventually reaches Alice. So adding this link would provide that property, but it still doesn't solve our problem. It doesn't give us a way to figure out the popularity of Charlie, because to know that, we need to know the popularity of Bob, which we need to know the popularity of Charlie for. We still end up in this cycle. The final choice seems, possibly more promising. It says there are no cycles in the graph, so if we want to remove this cycle. We could do this. In this case, we'd be okay, right? We could figure out the popularity of Bob, by figuring out the popularity of Charlie, which depends on the popularity of Alice. Where we're not okay, is if Bob has another friend. Let's say Bob is friends with Diana. Well then, to figure out the popularity of Diana, we need to know the popularity of Bob. Where it breaks down is, suppose we also have Diana and Edgar, and Diana's friends with Edgar. To figure out the popularity score of Diana, we need to know the popularity score of Edgar. We don't have a cycle, but we don't have an answer either. To figure out the popularity of Edgar,. We are going to go through Edgar's friends, and the way the Python code is written. This could actually work, right? Because if we define popularity when you have no friends. Well, if the friends of p is empty, when we go through this loop, the score is going to be 0. So, if you answered there are no cycles. That's at least worth credit for this, that could be correct. In terms of the mathematical definition, it doesn't make very good sense. We still needed a way to know the popularity of Edgar. We've sort of defined things in this case to say, if you have no friends, your popularity score is zero. And the Python code will work for that. But it's not a good way to define popularity. So its very arbitrary to say we're going to make Alice the one whose popularity score is predefined as one. There is nothing Alice could do to make herself more popular. That's not very fair to Alice and it doesn't give us meaningful scores. So we need to figure out something different. There's no sensible base case that gives us a good recursive definition. What we're do, going to do instead is what's called a relaxation algorithm. And the basic idea is pretty simple. We're going to start with a guess and then we're going to have some loop where we keep going. We'll just say, while we're not done, we'll figure out how to decide when we're done. We're going to do something that makes a guess better. So, that's the basic idea. That we don't have a good stopping point and we don't have a clear starting point of saying Alice's popularity is one, and we're going to define everything in that. What we're going to do instead is we're going to start with a guess, and our guess could be, well, let's assume everyone's initial popularity is one. And then we're going to keep refining the guess. We're going to have some process that updates the guess based on what we've learned. And each time we do this, we're going to get better and better. And at some point we're going to stop and we're going to say well that's the result we want. So let's think about how to do that for popularity scores. So, instead of just having one input to popularity now, there's going to be two. It's going to take the time step, that's the number of times we've tried to guess. And it's going to take the person, and it's still going to output a score. And now we can define this in a way that we do have a starting point, which is the equivalent to having a stopping point in a recursive definition. We'll define what the value is at step zero. For any person, we'll say that the score is 1. And it didn't work to have a base case, in terms of the person, because there's no clear ordering of the people. We had a graph, we had lots of different friendship connections, there was no clear starting point. We're going to add an extra parameter which is our, our time step, and that's going to be our base case. And if we think of our time step as our base case, it's easy to say that time step zero is our base case. And at step zero, we're going to say everyone's popularity score is one. And now we can have our update rule, which says, we can figure out the popularity at any time step t, where t is greater than 0 for any person, and we're going to define that as the sum over all their friends. So we're going to pick a friend in their set of friends. So we're going to go through each friend summing up the popularity score of the friend. But instead of at time t, we're going to use time t minus 1. So that means we're looking for the popularity of the friend in the previous step and we're using that to compute the popularity of the person they're friends with in this step. So let me write out that more in pseudocode. If we think of this as the Python procedure, it's going to be something where we're taking in two imports now, the time and the person. And now we have the base case, if the time is 0, we're going to return the score is always 1. If the time is not 0, well, we can compute the score similar to how we did before. We're going to have the score at 0, we're going to sum over the friends. We're summing over the friends, updating the score, by adding the friends' popularity score at the previous step. And when we're done, the value of score is the result. So now we have our new definition. We have it written in mathematical notation at the top, and in the Python code here. So the question is, is this a good recursive definition? And I don't mean to ask whether it's a good definition of popularity, let's hope it's not. What I mean to ask is, for all possible inputs, so all values we can pass in as t and p, does the way we've defined popularity give us a result? So here the possible choices. So, yes, it's only good if people can't be friends with themself. It's good only if everyone has at least one friend. Hopefully, everyone does. But it's only a good definition if that's the case. Or only if everyone is more popular than Alice. So the answer, is yes, we have a good recursive definition, no matter what we pass in for t and p, we'll eventually get a result, and the reason for that is because every time we do a recursive craw, the value that's passed in for t, is one less than the previous value, and eventually, if we start with an integer. And we keep reducing it, eventually we're going to get to the case where t is equal to 0, and then we have a base case. We can return the value one, without using the popularity function again. So this is a good recursive definition. It will always produce a result. It might not produce a meaningful measure of popularity, but if this is how we define popularity, this code will always produce a result. So, that idea for how to rank webpages is the same idea as how we measure popularity of people. But instead of thinking about friendships as the way to measure popularity, what we're measuring is links on the web. When one page has a link to another page, well that indicates it's more likely that this other page is popular, just like when someone is a friend, it indicates that the person they are friends with is more likely to be popular. So, the goal in ranking web pages is to get a measure of how popular are pages, based on the other pages that link to it but we have the same issue with popularity then not all links are the same. That a link from a page that's really important counts for a lot more than a link from a page that is not important. So, if the New York Times has a link to your page, that counts for a lot more than if your mom sets up a web page and puts a link to your page in it. Unless your mom is Lady Gaga, in which case her link probably counts for more. So, another way of thinking about this is what we're trying to model is a random web surfer. So, our random web surfer has some set of pages that they know about. And those pages have links to other pages. Some pages might have a lot of links. Some pages might just have one link. Some pages might have no links. So, one way to think about this is that we're trying to model a random web surfer. The web surfer starts knowing about some pages. And she picks one page at random, let's say she picks this page. And then, when she's on that page, she picks a random link and follows that links. Whoops, this was a bad starting page. It actually has no out links. So, then, she picks another random page. Let's say she picks this one. She follows the link from that page, and now she got to the page with no links again. Let's say she picked a better starting point. Let's say she randomly picked this one. Now she's got two links to follow. She randomly picks one of those. She follows it. She gets to a new page. She randomly picks a link from that page, in this case, it only had one, and in this case, it seems we have a bit of a problem, because all of the starting pages eventually lead into this one, which has no outgoing links. So, we'll think about how to solve that problem later, but we can think of what our random web surfer is doing, is picking random pages, following links, and what we want to measure is the popularity of a page. And that's the probability that she reaches that given page, starting from these random pages. So, if you did this over and over again, and you counted the number of times you reached each page, that would give you a measure of that page's popularity. So, this is very similar to the popularity function. We're going to define a function that we'll call the rank of the page. And, like the way we defined the popularity function, it's going to have two inputs. It's going to have a time stamp, and it's going to have the page which we'll use a URL for. And the output of rank will be some number. Except for we'll define for time step zero. This is our base case, and we're going to find all the ranks have value one. We'll actually change that shortly, but we'll start out think of it, all the ranks having value one, like we did with the popularity scores. And then we'll define the value of the rank at time step t for any given URL. Just like we defined the popularity score. It's going to be the sum of all the pages that are friends with this page, and what it means for our webpage to be friends with another page is that it has a link to it. So, this is going to be for all the pages that exist that have some link to that URL, or its friends. And so, we're going to go through each of those pages. We'll call them inlinks instead of friends. We're going to go through those and we're going to sum up the ranks that we got for those pages at time t minus one. So, this is our first model of popularity on, of webpages. This is exactly the same as the model we had of popularity for people. It's not going to work that well yet and one of the reasons it's not going to work that well is some pages might have lots of links. And if a page has lots of links, the value of each one of it's links should be diminished. It shouldn't have the same value as the page that only has one link that links to this URL. Maybe that should be the same case for a friend's popularity, if someone has lots of friends, each friend is less valuable. Whereas someone who only has a small number of friends has lots of time for each friend. S,o this is the way we're going to model web popularity. We don't want to just give the same score to each link. We're going to change this by dividing by the number of outlinks. So, if a page has many outgoing links, the value to the pages that it links to is less for each page. So, a page that's just a long list of lots of links won't have that much influence on the rankings. If a page only has a few outgoing links, well then, they are worth more. So, what are going to do, is divide this by the number of out links from p. So, each of the p pages, right? These will be the values of p, as they go through the inlinks of URL. We are going to sum up the rank that we got on the previous time step and divide that by the number of out links. So the final change we're going to make, is thinking about our random surfer model. If this was our model, if a page has no incoming links, well, it's popularity ranking would be 0. We don't want to have that be the case. If we think of our random web surfer, well if she randomly starts at a page, she could randomly start at a page that has no links. If we made all the page scores 0, for pages with no links, well, then it would be very hard for a new page to get started. So, we don't want those to be 0, so we're going to have some random probability that you reach a page even when it has no links. So that means we're going to add something to this sum so it's not zero when there are no incoming links. And the other thing we're going to do is we're going to scale this summation a little bit. And we're going to scale that with what is called the damping function. And that just means, if we think of our random web surfer again, even if she's following a path. That does have more links. At some point, she might decide to get tired and give up and start again with a new random page. So, the dampening function determines how frequently, we think our random web surfer will pick a random link, versus starting over again on a new random page. So that's call the dampening value and we are just going to use the dampening value to scale this number. So, we'll call that d, that's the dampening constant. A typical value for that is something less than one, and a good value is something like 0.8. So now we're going to change our rank function to take into account that. We're going to have some initial value and if we want to keep the values in a reasonable range, instead of starting from one, we're going to divide the values by a total number of pages. And the reason for that is just to keep the ranks in some meaningful range. This will keep the ranks so the total of the ranks when we start the sum of the ranks is 1, that gives them a little more meaning then if the sum of the ranks was the number of pages. So n is going to be the number of pages, the total number in our corpus and d is the damping constant, and so now we're going to change our initial values to divide them by n. This means, the sum of the paid ranks at the beginning will be 1, and, we're going to change the way we compute the rank by adding to it, a value that correspo... That gives us the sense of starting over. So, the value that we're going to use for this is 1 minus d, divided by n and, that gives the notion that. That times when we don't decide to do a new page. So, 0.8 of the time. We decide to follow a new page. So we're going to multiply this by D. The times when we don't follow a new page, that's one minus D. We're going to start over, and we're going to divide that by N, because N is the number of pages that the probability that this is the page that would be picked when we start over. So now we've got our recursive definition of page rank. We start by initializing the rank n times at 0 to one minus, divided by N, and then for as many times up, as we want, we're going to keep improving our results. By using this formula. For each link that links to us, we're going to take it's popularity on the last step, divide that by the number of out links so it's dividing it by the number of other pages it links to. Multiply that by our damping constant and that gives the probability that this page was selected by the Random Web Server, and then we're going to add the term that takes into account the Random Web Server might have started over from scratch and picked a new random page. So, before we try to change our Web search engine to actually program this, it's time for a little quiz. And the quiz is, What is AltaVista? And if you don't know this, feel free to use Google, or DuckDuckGo, to find out. These are the choices so, it's the view from the Udacity headquarters in Palo Alto. It's the most popular web search engine in 1998. It is Spanish for, You're Terminated Baby and, it's a small town in Virginia. And feel free to Google the answer if you don't know. And answer is the second choice. It is also true that there's a small town in Virginia named Alta Vista. But the relevant answer is the second choice. Back in 1998, the most popular search engine was probably the search engine called AltaVista. They certainly had the biggest web index at the time. And they also had great technology for responding to queries quickly. 1998 is the year that Google was founded, and most people probably have not heard of AltaVista today, and, might have had a hard time answering this quiz. And the reason for that is Google figured out a better way to do page ranking. And because of this, search engines that didn't have good ways of ranking pages, like AltaVista, quickly become irrelevant. And the algorithm that I've described, is the algorithm that launched Google. It's called PageRank. And you may think the Page stands for webpage. The Page actually stands for Larry Page, who was the co-founder with Sergey Brin, of Google. So, that's the algorithm that we've described. And that's what allowed Google to produce so much better search results, than other search engines at the time. I hope you remember Anna Patterson from Unit Three, and are still following her advice to be polite on the web. One of the reasons AltaVista started to work so badly, was because websites were not polite. They tried to find ways to game the rankings. Certainly this is still something websites still do today. And the way AltaVista ranks pages, it was very easy to game them, so the site that would be ranked was not the best site about something, but a site that was best at gaming the rankings. So I asked Anna to explain why Google's page ranking algorithm was so important to the success of Google. So a page rank on the web, was a huge step forward. I'm old enough to actually remember the time that Google launched and you know, it's advance over AltaVista. Was AltaVista was very, very prone to keyword stuffing spam. So if you said restaurant 32 times, well you were better than a page that said restaurant twice. So, PageRank came out and actually gave a measure of popularity or traffic, and therefore, the things that said restaurant twice, but were awesome. They wound up going to the top. Certainly things have got more complicated since then, and there's more things that go into the ranking algorithm, than just what we've shown you. But that's the basic idea, and the next thing we're going to do, is change our search engine to implement this algorithm. So the goal for the rest of this unit is to modify our search engine code to implement the PageRank algorithm. We have one little problem. PageRank is a registered trademark of Google. So we're not going to call our algorithm PageRank, even though it will do the same thing. We'll call it URank. The first thing we need to be able to do, to implement this ranking algorithm, is keep track of the link graph. So our popularity of pages depends on the link structure. So that means, we need to keep track of, what pages link to what pages. So, for each link, there is a connection between pages and we can think of that, as a graph. Abstractly, a graph is just a set of nodes, we'll draw those as circles, with edges between the nodes. And because our edges go one way, just like links in a page, we call this a directed graph. So, in order to represent our web link structure we need to build the directed graph. The pages in the graph are the nodes. For each page, we need to keep track of the edges that connect that node to other nodes. And so the way that we're going to do this is to keep a dictionary. So we're going to have a dictionary where the entries in the dictionary are the node, which is the URL, that's the page. And for each URL, we'll have a list of all the pages that it links to. So if this was say node a, and these were nodes b, c, and d, our entry for node a would contain the list b, c, d. And our entry for node b, well, there are no edges out of b, so it would be an empty list. And finishing the example, C has an out link to one node, and D has no out links. So that's our goal. We want to build a structure like this that shows the structure of the webpages that we crawl, and we see that structure because we're following the links in our crawler. So our goal is to modify the crawl web procedure that we defined at the end of Unit Five. And to modify it so that instead of just producing an index, it also produces a graph. So we're going to modify crawl web. It's going to still take a seed page as its start. But what it's going to produce now is both an index and a graph. And the graph is a structure that gives a mapping from each node to the pages that it links to. So let's look at the code that we had at the end of Unit Five and see how we need to change that. So here's the code, that we had at the end of unit five, for crawling the web. And as a reminder, we're keeping track of the pages left to crawl in the list tocrawl starting with the seed page, and we're building up the index as a dictionary. And as long as there are pages left to crawl, we go through the y loop, which finds a page to crawl, popping the list of pages to crawl. As long as this one, we haven't crawled before, it gets the content from that page. It adds it to the index. It finds all the links, using get_all_links, passing in the content on the page and unions those with tocrawl to update the tocrawl list and then it appends this page to the list of pages, that have already been crawled. So to change this to build a graph, we're going to keep most of the code the same. In addition to producing just index, we're going to produce a graph. And the graph is also going to be a dictionary. And the reason the graph is a dictionary is that the mapping from nodes, which are urls, to the list of edges that go out from that node. So we'll create the graph as an empty dictionary. And as we find new pages, we're going to add them to the graph. And we're going to also change the return to return both the index and the graph. I'm going to make one more change before we give you a quiz. And the change I'm going to make is, instead of calling get_ all_links here, Since both the graph building and the tocrawl list depend on knowing all the links, we're going to create a new variable. And we'll assign the result of get_all_links(content) to that variable. That means we can use those links as the input to content. But we can also use them to build the graph. And I'm going to leave the line that we need to build a graph for you to complete. So we'll make that a quiz, to finish this code. Write the line that we need to update the graph. So your goal for this quiz, is to finish modifying the crawl_web procedure, so that instead of returning just the index, it returns both an index and a graph. And the graph gives the link structure. The graph should be a dictionary, where the entries in the graph are a URL, which is the target page, and a list. Which is the pages that link to that target. So to test your graph making code, we've provided a sample site at this URL. So if that's the link that you pass in as the seed for the crawl_web. It's going to crawl in the site we set up. And there's an index page that looks like this, it's got five links on it. And, those links go to different web pages. So the first one goes to my favorite hummus recipe. So, there's a link from index.html. And it goes to the page hummus.html. And if we follow that link, we get to a page that has no links on it. This second link. Goes to page arsenic.html. And that page includes a link the Nickel Chef page. And the Nickel Chef page includes a link to kathleen.html. And that page has no links on it. And the third link on the index page, also goes to the kathleen.html page. And there's two more links on the start page. The first one goes to the Nickel Chef page, which we've already seen. And the last link, goes to the Zinc Chef. And from the Zinc Chef page, we have two more links, we have one to the Nickel page. And we have one to the Arsenic Chef's famous hummus recipe page. So this is a pretty complicated link structure, although it's very simple compared to the things that we actually find on the web. But your goal is to be able to produce this graph, by modifying the code that we have for crawl_web. And then once we have the page ranks, we'll be able to use PageRank to find the best page. To find a hummus recipe. So for this site, the graph that your crawl_web should produce, should have entries that show these connections, so there should be an entry where the URL is the urank/index.html, I'm leaving out the beginning of the URL. And the entries should be a list of all the pages that, that links to there. So they're going to be five pages. All five of these should be in the list here. There should be the Hummus page, there should be the Arsenic page, and the other three pages. The order that. Links appear in this list doesn't matter, it's correct as long as you have all five of the links that you can reach from the index.html page. The kathleen.html page, doesn't have any outgoing links, so the entry for kathleen.html should be an empty list. So see if you can figure out how to change the code for crawl_web, to produce as its second output, a graph that shows the structure of the web pages that we crawled. So the answer is, we only need to add one line. We need to add the line at line 13. And the line that we need, is to update the graph. So we're going to have a new entry in the graph, that is the page that we're crawling. So that's going to be the key for the entry that we want to associate with that page, a list of the links. That you can reach from that page, all the outgoing links. Well that's exactly what we stored in the variable outlinks. So that's the only line of code that we need to add, to produce the graph. We needed to initialize the graph as an empty dictionary, we needed to change the return it. But the only substantive change, was adding this line. And, we'll run that, we'll call crawl_web. Passing in the test URL. And this time we have two variables on the left side. So we're going to assign the index to index. And we'll assign the graph to graph. And let's check that the graph has what it should. So we'll print out to get graph entry for the index page. And, what we get, we see a list of five URLs. Hummus, arsenic, kathleen. Nickel and zinc. And this corresponds to the picture here. We had five outgoing links from the index page to those five other pages. Let's look at another one. We can print the graph for the Kathleen page, and that had no outgoing links, so what we see here is the empty list. And, we can see the whole graph, we have each URL. With a list of all the pages that, that page links to. So both the Hummus and the Kathleen page don't link to anything. The Zinc page links to the Nickel page, and the Arsenic page, and so on. So now we have our graph. The next step is to figure out how to use that graph, to do the page ranks. So our goal is to write code now, that computes the formula that we worked out earlier. Then we want to compute the rank, for each page. The thing that we're going to do, instead of using this recursive definition. We're going to write a loop, that goes through the time steps, and we're going to figure out how many time steps we want. The more time steps, the more accurate rankings we'll have, but the longer it will take. So we'll just pick a value for the maximum number of time steps, and we'll make our loops go through those steps, computing these equations. So let's work out the code to do that. So now that we've got the graph. All that's left to do is figure out how to use it, to compute the page ranks. So to do that, we'll make a procedure called compute_ranks. It takes as input, a graph that gives the link structure. So, as an example we have our graph that has the URL's, and each URL, followed by the link of pages that it links to. And this is the graph that was produced by our crawler, and crawLweb produced as outputs, a graph as well as an index. We're going to use the graph as the input to compute_ranks. So the output from compute_ranks, will be a dictionary, giving for each URL, Q rank, the ranking. That we compute using our formula. And, the higher the rank, the better. And, what we're going to do once we have those ranks, and this last part is going to be left as a homework assignment for you, we're going to instead of having just look up, we're going to have lookup_best. And lookup_best will take three inputs. It will take the keyword we're looking for. It will also take the index that came from the crawl, and it will also take the ranks, and from those three inputs, the index will give us all the pages that contain the keyword, and then what lookup_best will do is, use the ranks to find the highest ranked page. And give that as the output. So once we've done that, you'll have a complete search engine. You'll have a crawler that starts from a seed, finds pages, produces an index, produces a graph. That graph is the input to compute_ranks, compute_ranks uses our page ranking algorithm to figure out the pages that are most popular, and then lookup_best takes the graph as input. The index as input, and the keyword, finds the pages that contain that keyword, and identifies the one that's best, using the ranks. So that's what you'll have after the homework of this unit. We're going to finish compute_ranks now, and leave it up to you to define lookup_best as a homework question. So, let's remember how we defined our ranking function. So, we said we're going to have a time step. We're going to keep going through steps to get more accurate rankings. But initially, we're going to give every rank 1 divided by the number of pages. Before I called that capital N. I'm going to use npages as a more Pythonic variable name for that. And we updated the rank at time step t by adding the probability that the random surfer starts over and randomly picks that page. So, that's 1 minus d, is the probability of starting over, divided by npages, how many pages there are. And remember than d is our damping constant, and we'll decide that d is 0.8. That's the damping constant. We add to that the sum that we get of all the ranks, all the pages that link to this URL. We add up d times the previous iterations. So, it's going to be d times rank on step t minus 1 of that page. But we want to divide that by the number of out links from p. So, it's starting to look more like Python code. We want to simplify it a little bit before we get to Python code. And the first thing we're going to do to simplify it, is observe that well, we have this t parameter. But we only ever use the very previous one. So, we don't really need to keep track of the rank value for all of the different t values. We just need to keep track of the previous one. When we did Fibonacci, we kept track of current and next in variables. And that allowed us to keep track of the previous and the previous previous Fibonacci numbers. What we want to do with ranks is something similar. So, we're going to use the variable ranks to keep track of the current ranks. And as we compute the new ranks, we're going to use the variable newranks. So, we'll use ranks. This corresponds to the ranks at time t minus 1. The ranks of the previous iteration, and we'll have a variable newranks, which is the ranks at time t. And the reason we need both of those. As we update the rank from each page. So we're going to go through the pages. Recomputing its rank. We can't lose the previous one. We still need to get rank at the previous step for that page. If we use the one that we got this time, that would distort the results. It would mean that the order that we update the ranks for changes the results. So, we don't want the results to depend on the order that we go through the pages. That's why we need to keep track of both the previous values, which will be used for ranks, t minus 1 and the newranks. Once we have done that, we don't need the t parameter anymore. What we are going to do is change this rank, the rank at time t is going to be the value of newrank and the value of rank at time t minus 1. That's the value of ranks. The other change I slipped into this. Before we had parenths here and I've changed them to square brackets. And square, square brackets should give you the idea that well, this might be a data structure that we're indexing. And that's correct. We want to index the data structure. And we want to index it by the URL that we're looking for. And the Python dictionary provides a great way to do that. At the end of this will be a Python dictionary. And that's exactly what we want. So, I think we're ready to start looking at the code. We've written this formula. It's still a mix of math and Python. But we're going to turn this into the code for computing the page ranks. So, I'm going to provide a start on this code and now we'll leave the crucial part of it for you to do as a quiz. You should feel free at any point to stop and try to figure out more of the code on your own. There are lots of different ways to do this and we'll show you one. And you'll finish that as a quiz. So, the first thing we're going to do is define two constants. So, we're going to use d as the damping factor. And I'll use 0.8 as my damping factor. That's the probability, thinking about our random web surfer, that she selects the link on the current page, rather than starting over with a new random page. The other constant I'm going to define here we'll call numloops. That's the number of times we're going to go through the relaxation. What we're computing is the value of rank at some time step. The number of times we go through that is going to determine the accuracy of our ranks. We'll use ten as the number of loops. You can experiment with changing that, and one of the questions in the homework assignment will ask you to think about what happens when you change that. So, now we need to start, we said initially the rank of each url is 1 divided by the number of pages and so the dictionary ranks, we want to initialize with those values. So, we are going to create an empty dictionary. We'll call it ranks. The number of pages, the number of pages, we can get from the graph. The graph is a dictionary of nodes and len of graph will tell us the number of entries in that dictionary. So, that's the number of nodes in the graph which is the number of pages that we've crawled. And now we want to go through the pages initializing each page with the value one divided by npage, and I'm remembering to use 1.0 here to make sure the division is done as floating point division and we get an accurate number rather than inner shirt division. So, now, we've initialized the ranks. We have a dictionary that maps each page to its current rank, which is one divided by the number of pages. So, now, we get to the interesting part. We need a loop that's going to go through the number of times of numloops. Each time through this loop, what we want to do is update the new ranks based on this formula, using the old ranks and then, at the end of the loop, we are going to make the variable ranks hold what was previous new ranks and that way, we can keep going, each time we are going to get a new value from newranks. At the end of doing all updates, we are going to update ranks to refer to whatever newranks is. So, that means each time through this loop we are going to create a new dictionary called newranks that starts as empty, and we're going to add all the pages to newranks as we update their rank. So, to do that we need to go through the pages in the graph and for each page what we want to do is compute the new rank for that page. And the first thing we'll do is this part. The new rank is 1 minus d divided by npages plus this summation. So, the first thing we will do is introduce a new variable, we will call it newrank and we will assign it to this value. Then we are going to update it as we go through the pages that link into this page. So, we'll start by initializing newrank as 1 minus d divided by the number of pages. So, then what we need to do is update for this summation. And I'm going to leave this blank. And I'm going to skip that for now. This is going to be left as a quiz. We'll finish the rest of the code. And then your quiz will be to finish this part of the code, which is really the most interesting part of computing the page ranks. Once we've done that, so we've used newrank as a variable to keep track of the rank for this page. Well, we want to update our dictionary, so we're going to add an entry, newranks. We're still within the for loop, you're going to put your code that sums up all the links here. Once we've done that, we've got the value of newrank that reflects both the probability of starting from that page, and the popularity from all the inlinks. And so, we'll update this to be newrank. We've added that to our dictionary, so once we've finished looping through all the pages in the graph, well now, we're ready for the next step. So, that means, we want to make the var, variable ranks refer to the newranks, so we've changed the time step to the next time step, and now we're going to go back through this loop, and we go through this loop, number of loops times, each time we're updating the ranks, and when we're done, what we want to return is ranks. That's the dictionary that maps each page to its rank. الان تركت لكم الجزء المهم كتحدي وهو جزء من هوا جزء من الاختبار , وهوا كيف لحساب أساس ترتيب القيم من قيم حلقة التكرار , التي تاتي من ترتيب المتغيرات ونريد ان نصل الى ان نرتب جميع الصفحات بهذي الروابط معها , و الان اذا تفكر عن تركيبات Graph وكيف تدخل داخل nodes graph, اعتقد يمكنك تخيول كيف يمكنك عمل هذا So here's what we want to do, we want to go through all the pages in the graph. So, we'll call them nodes this time, we can't use page again, because we already used page up here. So we're going to go through each page in the graph, giving it the name node, and for each node, now what we need to do, is check whether that page links to this one. So we're going to look in graph index node, that's going to get us the list of all the pages. That node links to. If page is in that list, well that means that node links to page. So that means that we should add to newrank, based on the rank of this node. So that's what we're going to do. We're going to add to newrank, and the new value is going to be the old value. We summing into the value of newrank. We're going to multiply by d, that's our damping factor. And, the value that we're going to use here, is the page rank of the node. Remember, it's the node that links to this node that we care about, so we're getting the rank on the page. What we want to do, is divide that by the number of out links from that page, and that's important, that means that each, a page with many links, the value of each link is less. We need to divide that by the length. Of that list, which is what we get by looking at graph index node. So, that's all we need. We are going to update the newrank. We are going through all the nodes in the graph. We are finding all the nodes that link to this one, and we are updating our rank using the formula to get that, and at the end, we're returning the ranks. So let's try that in the Python Interpreter. We have the code that we just wrote for compute_ranks. We're going to use crawl_web passing in the example site. Assigning the outputs to the variable index, which is the index and graph. And then we're passing in graph to compute_ranks, storing the result in the variable ranks. And we can print out the result in ranks, to see the page ranks. So, here's what we get. So we get a dictionary, for each URL that we crawled. We have an entry where we have the URL, followed by each page rank as the value. So let's see if the ranks that we get make sense. So, going back to our example site, we have the page Kathleen that has two links going into it. We have the page Nickel. That has three li, links going into it. If we just did simple link counting, well then, Nickel should be more popular than Kathleen. If we look at the page ranks, well the page rank for Nickel is 0.97. The page rank for Kathleen, is 0.11. So the page rank is actually higher, for the page that only has two incoming links. And the reason for that is, well, even though it only has two incoming links, the links that are coming into the page, are from popular pages. It's coming in from the index page, and it's coming in from the very popular Nickel page. So that's why the page rank of Kathleen is actually higher than the page rank of Nickel. So congratulations--you've now built a search engine. You've got all of the components that you need for a search engine. You've got a way to collect a corpus, using a Web crawler that you built in the first 3 Units. In Units 4 and 5, you figured out-- and hopefully understood--how to build the index and then how to make it faster in Unit 5. And in Unit 6--what we've just finished-- you figured out how to rank the results. There's one little bit left: we haven't used those ranks, so one of the questions on your homework will be using the ranks to get the best result. If we want to get the best result, just having the dictionary ranks is not enough--we need to use that to find the result that matches the query that has the best rank. And that's one of the questions that you'll do on the homework for this Unit. There are a lot of other hard problems. So you have a few problems left to solve before you can build a search engine that will compete with Google. Probably the hardest one: you've got to come up with a name. This is really hard. You could try "Yoogle", You could try "DuckDuck Find". None of those really work--you'll have to come up with a better name, and this is a pretty tough problem. Make sure to also talk to your Trademark lawyers. Another thing you'd like to be able to do is actually get your search engine on the Web so other people can send queries to it. That's not something we're going to cover in this class, but if you take the Web Applications course that will start shortly after this class finishes, you'll learn a lot about how to build Web applications and be able to do that. So congratulations--you've reached the end of Unit 6. And this is actually the last technical content that will be in this course. Unit 7 will get you ready for the final exam and will give you some interesting examples of using Computing in Context. So congratulations. You've now finished building a search engine and it actually does Page Ranking better than any search engine that existed before 1998. That's quite amazing. I first want to also congratulate David for getting you to this point. I think that's quite amazing and, honestly, he's put a lot of sleepless nights into thisl. But also, i want to tell you: you guys are my heroes. You got to a point where you reached something, I think, really significant in this class--you actually learned how to-- And you programmed your own search engine. Now, I have to say--I'm a little bit jealous. When I was a student at college, there was no search engines, and there wasn't even and ability for me to learn all this stuff. As for you, you've been afforded the ability to learn all this stuff. But then you really got an amazing speed here. That's something really, really significant. I hope--I mean, if you keep up that speed and keep improving yourself with that same speed and learn new things-- maybe in 3 or 4 years you are the next Google. That would be really amazing. Well, I think you're definitely on track to doing that, and I hope you'll take some of the courses that we'll start offering, as 200 available courses and more advanced courses later. This is the end of Unit 6--we're not going to have any more technical content to the course. Unit 7 is going to be all field trips and interviews, giving you some idea of how the things that you've learned in class fit into Context--and that should be a lot of fun. The other thing that you'll have, as part of Unit 7, is the final exam. And I hope everyone enjoys Homework 6 and will be ready for the final next week. And I hope you enjoy the final exam. For this question, we need to determine if the given grammar generates infinitely many strings starting from the nonterminal word. So we can start from either substitution rule. If we start from the first one, then we end up with 1 possible word. If we start from the second word, then we get the letter a, and then we can insert another word. This can be udacity, so then we end up with audacity. We can do the same thing but twice. So we have a, then instead of going to udacity, we do a again, and then we do udacity. The way this is breaking down kind of looks like this. It should be pretty clear that we can continue this forever and eventually end with udacity. So we can have an arbitrary number of a's, followed by udacity. This inidicates that this grammar generates an infinite number of possible words. In this grammar, we can see that every word begins with a root and then a tail. So what we're going to do to see how many strings this generates is, go through every possible root there can be and then every tail there can be. So root can be uda and also boda. Tail can go directly to cious and city. But we should also look at this substitution rule that has root going directly to tail. So you could have a word that's really the same as tail tail, which adds 2 more possible combinations to what root can be. This gives us 4 possibilites for root and 2 possibilities for tail, which means 8 possibilities all together. This grammar can generate 8 different words. We know that 8 < infinity, so this grammar does not generate an infinite number of words. So here we have a grammar that looks a lot like our first one. However, let's still work it out to see if there's an infinite number of words. So according to problem, we start with word. And there's only 1 substitution rule for word. >From pre udacious, we have 2 options. We could go to super udacious, which gives us one complete word, or we can do pre super udacious. You might have already noticed that we can keep substituting the pre with pre super, and we can keep doing this forever, and stopping at any point and ending with some number of supers followed by udacious. This grammar generates an infinite number of strings. In lecture, we said the number of rabbits in a given month was = to the number of rabbits the previous month + the number of rabbits 2 months ago. In the new model, we have the same number of growth of rabbits, but instead we're going to subtract the number of rabbits that are 5 months old to account for them dying. Astute readers will know that this doesn't actually model death correctly of rabbits, but it's a good example for coding a recursive function. So with this in mind, let's get to the programming. So the first thing I've done is at our base case, which was defined in the problem statement. And if it's not the base case, we're just going to plug in the formula that we got from the problem statement. So this may look like it's finished, but there's one issue, and that is, what we'd do and say n = 3, when 3 - 5 is a negative number, and we don't have anything to account for that. We're just going to continue forever, basically, because we're never going to hit the base case of 1 or 2. So we need to actually add a second base case. And our second base case, basically, says if we had a number that's not 1 or 2, or below a 1 or 2, then we're going to return 0 and not effect the count of the number of rabbits alive for that month. So in this problem, we start out with n number of people with big heads and happy smiles. And after every hexamester, each one of our happy udacians goes out and asks spread number of their friends to also take the course. This process continues as long as the number of udacians is less than the target. With a little bit of math, you can solve this pretty straightforward, and you might have done it in middle school or high school, but we're going to use recursion to solve this problem very easily. Remember what we're looking for is the number of hexamesters this process goes through until we reach the target. I saw on the forms a couple of people were trying to use global variables that counted recursive calls, but really that kind of defeats the purpose in the power that we can use in the recursion. I'm going to show you how to do that right now. So our base case says that if we've met our target, then we don't need any time to spread in order to reach the target because we're already there. Now here I have a + 1 because we're going to say that we're doing 1 iteration of the udacian spreading process. Now for the recursive call. The first thing we need is n. Well, n is going to be the same thing as last time + how many new people we've gotten, which is spread x n. A more succinct way of writing this would be simply (n x (1 + spread). The spreading rate doesn't change, so we're going to leave that alone. Our target doesn't change. And that's it. We're done. In this problem, given a list that possibly contains lists, we want to count all of the elements in all of the lists. So to go through an example, the black list has 2 elements. This blue list has 3 elements, and the pink list has 2 more elements, leaving us with the total of 7 elements. So this is what we want to compute, and we can take a second to think about how we're going to do that. We're basically going to start with the length of this list, and then we're going to iterate through each element and repeat the process for every sublist. Let me show you how that works. We're going to start with our sum at 0, and then we're going to iterate through each element. For every element we see, we increase the sum by 1, and if it's a sublist, we're going to do deep_count on the sublist. Once we've gone through every list, we're going to return the sum. [Mouth sound mimicing explosion] I've got to get like a catch word, like pow! In the lucky search problem, we have 3 inputs. The index, which is a hash table of all the keywords in the pages in which they appear. We have the ranks, which rank each page based on the URank algorithm that we discussed in lecture. And then we have the keyword we are searching for. The output is going to be the highest ranking page with that keyword. The steps to solve this can briefly be summarized as follows. We're going to go through every page that contains the keyword, and we're just going to find the page with the maximum rank. So we're going to find a maximum. It sounds pretty simple, but it's actually a few lines of code. So let's go right to the ID. So the first thing we're going to do is get the pages from the index with that keyword. If there aren't any pages, then we're going to return none, and if there's at least 1 page, we're going to say for now the best_page is the first one. And we're going to iterate through each page in the pages list, updating our best_page accordingly. So if the rank of the candidate page, the page that we're iterating through, is greater than the rank of our best_page, we're going to update our best_page. Once we're done, we're going to return the best_page. Ã¯Â»Â¿Student Chainsaw Riot asks what does it mean to be pythonic? Wow, Chainsaw Riot. Okay. So, pythonic is a word that sort of describes the way you would do things in python, if you were an expert python programmer and we have mostly not tried to do things in the most pythonic way in this class because I want to keep the subset of python we use as small as possible. So many of things weÃ¢Â€Â™ve done, there are very clever ways to do them in python, which would take advantage of features we donÃ¢Â€Â™t see. One that comes to mind was a student posted a solution to the Sudoko problem. That was a fantastic one line solution that used a few things we hadnÃ¢Â€Â™t covered in the class but if you want to see the pythonic way to solve problems, I would encourage you definitely to take Peter NorvigÃ¢Â€Â™s class, which is CS262. He is really a master at using python in a very clever way and finding a way that solves problems that you would think would require hundreds of lines of code and then both by mostly clever thinking and clever ways of solving it but also using features of python in the best possible way finds a way to solve it in two or three lines and so if youÃ¢Â€Â™re getting more experienced as a programmer, you are going to be finding these very elegant short solutions that take advantage of more features in the language than we have used in CS101. Ã¯Â»Â¿Student Brian Yee asks, weÃ¢Â€Â™re using python two in this class but python three exists, are we Ã¢Â€Â“ is what weÃ¢Â€Â™re learning outdated? Does it not help us in the real world? Okay, so fair enough question. There is a newer version of python and almost everything that weÃ¢Â€Â™ve learned in this class, it doesnÃ¢Â€Â™t matter whether youÃ¢Â€Â™re using python or a Java Script or scheme or C or Java, any program or language, the basic concepts that weÃ¢Â€Â™ve learned really apply to all of those languages in the same way. Now, developing skills as a programmer is useful to learn different languages and different languages have slightly different ways of doing things and we talked in the previous question about the pythonic way being the best way to do something in python to really take advantage of the design and the style that python programmers expect. Python three is different from python two and in some ways itÃ¢Â€Â™s not that different. So almost everything that youÃ¢Â€Â™ve written in this class would work in python three and would be the same way to write it in python three, some things wouldnÃ¢Â€Â™t. And most code today, python two is still used more widely than python three. There is some incompatibilities in python three that mean itÃ¢Â€Â™s very hard to move libraries that were written for python two to work in python three and the infrastructure that weÃ¢Â€Â™re using is all working in python two, not in python three. So thatÃ¢Â€Â™s the real reason that we use python two for this class instead of python three. But essentially everything that youÃ¢Â€Â™ve learned would be the same and would be very easy to transfer if you start writing python three code. Some things will be a little different and probably the most notable thing that would be different is print would work differently. So the code that youÃ¢Â€Â™ve written that uses print would not work in python three, youÃ¢Â€Â™d have to add extra parentheses for that. But otherwise everything would really be the same, there is no concepts that would be different, itÃ¢Â€Â™s just a matter of different things defined slightly differently in different languages. Ã¯Â»Â¿Student W.Q. Feng asked when do you use a recursive definition versus a 'while' loop? So this is a good question and in terms of being able to solve a problem, anything you can do with recursion you can also do with a 'while' loop. Anything you can do with a 'while' loop you could also do with recursion. So any problem you can solve either way. Usually solving it with a 'while' loop would be more efficient because you donÃ¢Â€Â™t have the overhead of all the extra procedure calls. Often solving it with recursion is a simpler and more elegant solution. So depending on whatÃ¢Â€Â™s more important, oftentimes the tradeoff is much better where the simpler elegant solution that performance difference you probably couldnÃ¢Â€Â™t even measure unless you were timing really carefully for really large inputs, you wouldnÃ¢Â€Â™t notice the difference. So itÃ¢Â€Â™s more important to get the solution correct and have it in code thatÃ¢Â€Â™s easier for you to write and easier for other people to understand, in many problems the recursive solution really lends itself to that. ItÃ¢Â€Â™s much shorter than the iterative solution would be and itÃ¢Â€Â™s easier to understand and follow. In places where performance matters and we saw this with the Fibonacci example that if you end up blowing up the number of calls in a way that makes it too slow to do recursively, you might prefer a more complicated solution that involves a 'while' loop and avoids the recursive calls. Manuel had a question. "I always though recursive calls were more efficient that iterative functions. Professor Evans said that recursive definition isn't very efficient in Python. So I want to ask if other programming languages like C or Java improve the recursive calls in order to always be more efficient that the iterative method." Thanks for the question, Manuel. The problem with recursion in terms of performance is that when you execute a procedure that does a recursive call you've got to keep track of the state of that call. That's called a stack frame. You're keeping track of the function you called. You're keeping track of where to return when you're done, and you're making a new space to store the parameters that you passed in to that procedure. If you have a recursive call, each time you're doing the recursive call you need a new stack frame to keep track of that. When you finally get to the base case, then you're got a result, and you've got to unwind all that. You're going back through all those stack frames, passing back the results, reclaiming that space. That take a lot of space. If there are a lot of recursive calls like some of the examples you've seen in 101, you're going to run out of space when you do that on a high input. For some languages there's an optimization that the interpreter or the compiler does to know that if the only thing that you do with the results of the recursive call is pass it back to the next level, you don't really need to keep track of all those stacks. You can keep reusing the one you had, just replacing the parameters, and know that when you're done that's the actual result. Or maybe you do a more complex optimization where there's something you need to do on the result, but you don't need to keep track of all those stack frames. This is what most languages that are designed to use recursion frequently do. Languages like Lisp and Scheme are designed this way-- to make it very efficient to do recursive calls. It's still more expensive than iteration, because you still need to do the call. You need to do the mechanics of calling a procedure and getting a result, but with this tail recursion optimization, you don't need to keep track of all those stack frames. It's much more efficient than it is in Python. There have been a lot of questions about why am I covering recursive procedures if they're so inefficient in Python. The reason for doing that is really it's a very useful way of thinking, even if you need to eventually turn the procedure into an iterative version of it. By writing the recursive version and understanding how they recursive definition works and understanding things that way, you're thinking in a new and powerful way. Recursive procedures are often easier to reason about than iterative ones. And if you use a language that does provide tail recursion elimination, then the recursive definition is often the one that you want to use. In Python that's usually not the case. It's better to write a procedure not to have a recursive call, because you're going to run out of stack space if you ever call it on a large input. Ã¯Â»Â¿Student Hu asks about the complexities that are involved in the PageRank algorithm that you went over in unit six is how similar is this to what Google does or other search engines when they are ranking pages. So this is a good question. So the PageRank algorithm that we described in unit six is exactly what Google started with and this was the research paper that Larry Page and colleagues wrote about how they would improve search ranking and thatÃ¢Â€Â™s exactly the algorithm that we implemented in unit six and that was what Google was doing in its early days. Things are a lot more complicated today and a lot of the reason for that is well, sites adapt. And youÃ¢Â€Â™d remember Anna Patterson was taking about how sites adapted to the way AltaVista was ranking by putting lots of copies of the same word on the page to try to show up top in the rankings and this started to make the results less useful. Sites have also adapted to PageRank by trying to find ways to get links to the page, have their own pages linked to their own other pages that look different to Google, making it so there are lots of in links and trying to make it so you get a high rank in the page and there is entire consultants whose business is try to find ways to get your page higher ranked in Google. So that means that for PageRank to continue to work, well they have to take into account more things, so they look at things like how things appear on the page, they look at other context, they look at other information, not just the link structure. But thatÃ¢Â€Â™s still the basis for a lot of Ã¢Â€Â“ the ranking of the pages is the link structure. And you can see evidence of PageRank on kind of what the search results you get when you are using Google, itÃ¢Â€Â™s very, very common that Wikipedia is one of the top three results on almost anything you search for and thatÃ¢Â€Â™s because a lot of people link to Wikipedia because it has got authority but also that Wikipedia links to itself a lot. That kind of a structure helps. Yeah, hundreds of pages link to other higher pages. And itÃ¢Â€Â™s also that content of the pages is also high quality and there is things that Google is trying to do to measure the quality of pages as well. Yes. Ã¯Â»Â¿Student Sanjayman asks what are the major problems search engines are trying to solve today. So I hope weÃ¢Â€Â™ll see some creative solutions of new things that you can do with search engines as part of the contest and we will be releasing the full details on that soon. The kinds of things that are probably the biggest things that commercial search engines are working on today, one is always getting better results, right. Finding better ways to find the best page, finding ways to respond queries that are more complex and have more than just one keyword, doing things that will get people what they are searching for. The other thing that I think is probably a big effort and is an increasing arms race is dealing with efforts to get pages ranked highly that arenÃ¢Â€Â™t active, so people are trying to do things, they call it link spam sometimes trying to make pages that will rank highly but donÃ¢Â€Â™t have good content and this is sort of a never ending battle between the search engine companies and the people who want to create content that ranks highly. Every time Google tweaks their algorithm, lots of people get upset because their PageRanks go down. That could be unfair. It could be because they have good content and that new algorithm is unfair to them. It could be because the algorithm has been tweaked to try to remove things from high ranks that donÃ¢Â€Â™t have the content that users are actually looking for. So thatÃ¢Â€Â™s really a never ending battle to try to get the best results. And there is also a lot of effort to kind of instead of just returning a query - returning results for a given search query but to answer questions. Yeah. And so you can go into whatever search engine you use and ask like, when is new year, what day is new year or the Chinese new year and itÃ¢Â€Â™ll give you the date instead of just Ã¢Â€Â“ in addition to the results and will start answering questions and this is kind of the first step into kind of organizing search engines around what we want to know. And in some search engines like Google and DuckDuckGo are pretty good with questions like that. To actually understand natural language well enough to be able to answer a complex question that doesnÃ¢Â€Â™t fit some known structure is a really hard problem but is definitely something that is in the future of search engines to do that well. Raymond has a question to do with the use of non-US alphabet characters. When he first wrote programs with text in Spanish and ran them using Python, he got an error--syntax error "non-ASCII character." He did not get that error when running the same code in IDLE. It worked as it should. He solved this by changing the encoding. So as we're building a search engine that will scan pages in different languages and perhaps use different language interfaces, how should we change our code so that it does not run into problems with encoding? What should our default character set be? Thanks for the question, Raymond. This is a really good point to bring up. As you take inputs that include more languages than just English the character sets are different. If you look at a webpage, there's a header in the webpage that identifies what characters set it's using. This is part of the HTTP protocol to have a header that describes the content type, which includes the character set. The character set can be selected from a few different ones. The most common one is called UTF-8. That's using a way of encoding characters that makes the simple characters that can be encoded in just 7 bits. This is the character set that is known as ASCII. These are characters that are common in English. It doesn't cover all the characters that are used in all other languages, but those 7-bit characters can be encoded using a small amount of space. The standard we've been using in Python with standard strings is that they're all ASCII. Each character is 1 byte. There's only 255 possible characters that can be encoded in 1 byte though. If you're wanting to deal with more languages, you need to use different characters. The way to do that is called Unicode. Unicode is a character set that can support large numbers of characters. It's actually a way of encoding characters that doesn't have a limit on how many characters you can support. A way of encoding those that makes it efficient when the characters are small but allows you to still encode a large number of characters is called UTF-8, which is what most web browsers use. To deal with this in Python, what you'd have to deal with instead of standard strings is Unicode strings. There is a built-in type for Unicode characters. You can convert a string to Unicode by using Unicode. Then there are ways of encoding Unicode in other character sets. If you wanted to build a web search engine that can deal with text that's not using the standard English character set, you definitely need to worry about handling Unicode and all these different character encodings. Welcome to unit 7. This unit will start with a brief summary of the course, recapping the major themes we've seen. Then the rest of the unit will be all fun field trips and interviews. We'll start by looking at the past of computing by visiting the computer history museum. Then we'll look at the present and how you can contribute by visiting SLAC National Accelerator Laboratory, and talking to the folks at Mozilla and Benetech. Finally we'll get a glimpse into the future of computer by visiting UC Berkley and looking at what people there are doing research on. We'll start by summarizing the course, and I want to highlight the three main themes that I think are most important in computing. [Evans] I think there are 3 main themes that really pervade the course that we've seen over and over again, but I haven't mentioned them explicitly until now. These are themes that aren't just pervasive throughout this course but are pervasive throughout all computer science. The first one is abstraction. Abstraction is all about hiding details. The point of abstraction is to make it so you can have 1 thing that is used in many different ways, and you can use it without necessarily understanding all the details behind it. We've seen lots and lots of examples of abstraction in this class. The most important one is procedural abstraction. We can write 1 procedure, use it to do lots of different things depending on what the inputs are, and when we use that procedure we don't need to know exactly what sequence of instructions will execute. What we know is what the procedure does. The second main theme is universality. We talked about this early in the class about how computers are universal machines. I want to show you how much better I've gotten at drawing. If you thought my drawing of a toaster in Unit 1 was not recognizable, I hope you can see how much better I can do now. This is a toaster, and a toaster is very different from a computer. A computer is a universal machine. We've seen lots of examples of how a computer is universal-- that we only need a few simple constructs to be able to define every possible program. We saw that if we had a way to make decisions-- and we saw we have that with if in Python; we saw that if we have a way to keep track of things-- and in Python we can do that using variables and data; and if we have a way to keep going-- and we first saw that using while--with a while loop we can make something keep going as long as we want. But in fact, we don't even need while. We could do that with procedures, and that's what we saw with recursive definitions in Unit 6. Once we have those 3 things, we can write any computer program. So we have much more power with a computer than we do with a toaster. The final major theme I want to summarize as our third main theme is one we've already mentioned here. It's recursive definitions. We introduced those explicitly in Unit 6, but you saw them many times before that. The first time you saw them was actually in Unit 1. We saw these rules that said we can make an expression by taking another expression, using the plus operator, and combining it with another expression. That was not enough by itself for a recursive definition. We also needed a base case. We saw a base case, like we can have an expression that's a number. So the big idea here is that with very simple rules we can define infinitely many things and very complex things by using rules to define things in terms of simpler versions of themselves. [Evans] These are our 3 big themes in the class: abstraction, universality, and recursive definitions. What I want to do now is look at various things that we've covered throughout the course and see how they fit in to these 3 main themes. In Unit 1 we introduced the concept of variables. We can use a name to refer to some value. So that's definitely a type of abstraction. It allowed us to use the name x to refer to different things. It's helpful for universality, but by itself it doesn't really provide us that. And it's not really a recursive definition, although we can define variables in terms of other variables. In Unit 2 we introduced procedures. A procedure is definitely a kind of abstraction. By making the parameter to a procedure, we can have code that we write once that does many different things, and we can hide all those details when we use the procedure. Procedures also give us a form of universality. We can use the same procedure to do many different things, and we can define procedures to do everything, as we've seen. We didn't really understand that yet in Unit 2, though, but it is enough to define every possible computer program. We certainly use procedures to make recursive definitions, and we've certainly defined recursive procedures--not until Unit 6, though. And this gives us a way to define a procedure to break a problem down by seeing it in terms of a smaller version of itself. The main new thing in Unit 3 was lists. This is a kind of data abstraction. You can use a list without knowing the details of how Python implements a list. It also can be a recursive definition. We can have lists that have elements that are other lists, so it certainly is useful for recursive definitions. And it's universal in the sense that we can put any element we want in a list. So in Unit 4 the main things we did were finish the search index by providing a way to produce an index of data. This certainly involved a lot of abstraction. We found a way to represent the data from the web pages in an index and respond to queries. The other thing we talked about in Unit 4 was how networks work. Networks are all about abstraction. We want to find ways to make requests where we're thinking about what we're requesting as a web page. All the details of how we actually do that are hidden, and unless we need to worry about that, it's much better to think about that abstractly as this is sending a request for a web page. In Unit 5 the main new idea we introduced was how to measure cost. That's a kind of abstraction. We want to measure cost in terms of understanding how the cost scales with the size of the input rather than the details of the cost. It's also related to universality. Understanding the cost of a procedure depends on having a fairly universal model of computing. We want to understand how much a given algorithm costs without depending on the details of how our particular computer works. And then we introduced the hash table. This was a kind of data abstraction. It was universal in the sense that it could contain any kind of element as its values. We didn't define it recursively. We could certainly have hash tables containing other hash tables, and we have dictionaries of dictionaries, so this also certainly has aspects of recursive definitions in place. And finally, in Unit 6 the main big idea was recursive procedures. Obviously, that fits in to our theme of recursive definitions. It also relates to universality. We showed how to make code that runs forever or keeps on going as long as it needs to without using a while loop, so that gives some support for the idea that all we really need are procedures, if, and a way to keep track of things to be able to define every computer program. We saw that any program that we could write as a recursive procedure we could also write as a while loop. So if you've followed everything that we've done in this class, you've really learned an amazing amount. And as you learn more and more about computing, you'll see these 3 themes of abstraction, universality, and recursive definitions all over the place. But you've already seen them many, many times just in the units of this course. [Evans] We're only going to have 1 quiz in this unit, and the quiz is something that should sound like a fairly simple question, although it's actually quite difficult to answer. The question is, what kind of thing is computer science? Your choices are engineering, science, and liberal art. Check as many as you want. [Evans] This is definitely a subjective question, and it's kind of strange that a discipline like computer science is so poorly defined that if you ask many computer scientists what it is you'll get very different answers. But my answer to this is it is engineering, it is a science, and it's also a liberal art, that all 3 are true, and I'll explain why next. This is the way I tend to think about engineering is it's building big, complex structures that solve physical problems like getting cars across a bay of water. With that narrow view of building physical things, most of what we do in computing is not about building physical things, it's about building virtual things, it's about solving problems. A broader view of engineering views it as design under constraint. When you're building a bridge, the constraints are the laws of physics. You need the bridge to stand up, but you want to limit the cost of the bridge, the amount of material that you use, you want it to not sway too much in the wind. These are all the kinds of constraints that you have to think about in designing a bridge. When we build computer programs, we don't usually have to worry too much about the laws of physics. We've seen that they do affect us--that the speed it takes for light to travel affects how fast our programs will run-- but for the most part when we're designing programs, this is not the main thing that we're thinking about. The main constraint that we have to worry about is the limitations of human minds. What we can do is limited by our creativity, but it's also limited by how much we can keep in mind at one time. The main tool that we have to solve this is abstraction. The point of abstraction is to allow us to limit what we have to keep in our mind to be able to solve problems by hiding those details and thinking about things at the right level and designing programs in a way that we can have a procedure that solves the problem that we want, and then we can forget about the details while we move on to the next part. That's all about using abstraction to overcome the limits of human minds in terms of how much we can keep in mind and understand at one time. So from that perspective, computer science is definitely about engineering. We certainly want to build things. We're not building things like bridges, and we're doing that under constraints, but the main constraints are not from the laws of physics-- because we're not building physical things--but from the limits of our own minds. We tend to think about science as understanding nature through observation, and our favorite example of this is Sir Isaac Newton. If you can't recognize this, this is obviously Newton because he's sitting under an apple tree and the probably untrue story of him understanding gravity because of an apple falling on his head. In computer science we're mostly not focused on understanding nature, at least not in a very direct way. We're thinking about abstract things. We're writing programs to solve problems, but they're dealing with abstract representations of those problems. Certainly computing is used all over the place to build better models of the universe and to test those models, but that's a little different from saying that computer science itself is a science. But there is a lot of computing in nature. Certainly physical processes involve computation. The other big example today is really in biology. If you think about DNA as programming organisms, it's a very complex way of programming, but it's also very computational. And if you think about biology, biology is really all about computation today. So certainly if we want to understand nature better, both how human minds work--that's largely about computation-- and how DNA produces biological organisms and how DNA evolves over time, that's really about understanding computation in nature. We didn't get to this too much in this class, but this question about universality, questions about what can be computed and how fast it can be computed are really fundamental questions about science. They are questions about our universe. They are abstract questions in the sense that we can form them as mathematical, precise questions, but they are also really questions about what are the limits and what are the possibilities in our universe. The final correct answer was liberal art. In some sense this is arguably the easiest one to defend, but it's probably the one that was most surprising to many of you. Understanding why computer science is a liberal art depends on actually understanding what the liberal arts are. Here's a picture of the medieval view of the liberal arts. There's grammar, rhetoric, dialect, which we think of as logic today. Those are the 3 that have to do with language, and then there are 4 that have to do with number. The 4 that have to do with number are arithmetic, geometry, music, which is number in time, and astronomy, which is number in time and space. So how do each of those relate to computing? We've certainly seen a lot with grammars. We've seen rules like this. Rhetoric is about using language to communicate between people, especially to persuade people. We've actually seen rhetoric a little bit. This is a little less clear, but we've seen it in terms of network protocols. What protocols are are ways of computers communicating with each other and making sure that they can understand each other. So arguably, that's a form of rhetoric. Logic is the art of thinking in the medieval view. We've certainly used logic all over the place in this class. All of our decision constructs are logical constructs, so we've certainly used a lot of logic. So those are the 3 traditional liberal arts, known as the trivium, focused on language. And then we have the quadrivium, which are the 4 focused on numbers. Arithmetic. We've certainly seen lots of arithmetic in this class, and we can do lots of arithmetic in Python. Geometry. We haven't used too much directly in this class. There certainly is lots of use of geometry in computing. The 2 that I'll mention most-- In computer graphics that's all about understanding the geometry of light well enough to be able to simulate images and to be able to draw things on the screen. The other place where geometry comes up a lot is in networking, and we saw that a little bit in Unit 4. If we want to design a network, we care about the topology of the network-- how things are connected--and that depends on understanding geometry. But we didn't get to either of those things too much in this class. Music, which is about number in time. We haven't really seen how computing relates to music very much in this class, but certainly recursion occurs all over the place in music. If you don't believe me, I would encourage you to read this book by Douglas Hofstadter called Godel, Escher, Bach. It's all about how the logic of computing relates to things in both the art of Escher and the music of Bach. And the final traditional liberal art was astronomy. We haven't seen that directly in this class either, but certainly almost all astronomy today depends on computing. So we've seen science, engineering, and five of the seven traditional liberal arts. That's pretty good. Wee should go on some field trips to celebrate. Let's start by visiting the Computer History Museum in Mountain View. Hi, I'm Alex Bochannek, curator at the Computer History Museum in California. Welcome to Revolution: The First 2,000 Years of Computing, an exhibition that covers the history of computing from the abacus to the smart phone and everything in between.. The Computer History Museum was started in the 1970s in Boston, has been in California since the '90s, and since 2011 this new permanent exhibition has been open to the public with 23,000 square feet, 19 galleries, and over 1100 artifacts. Folks, you're looking at the Babbage engine. It does what Charles Babbage envisioned it would do-- produce mathematical tables without any human intervention all the way over to the print shop. It produces a stereotype try, which then goes to a printer to print a book of logarithmic tables for example. This was envisioned by Charles Babbage 1849 but never built in Charles Babbage's lifetime. My name is Dave Bennent. I'm a member of the team that restored this machine--the world's first hard disk drive. It was announced in 1956 it was the first product of IBM's laboratory in San Jose, California. This is a big machine with a very small capacity. However, in 1956 it was very important. This machine had 50 disks 24 inches in diameter. It stores a total of 5 million 6-bit characters, 3.75 megabytes in today's world. Any disk drive that doesn't have at least gigabytes in it is obsolete by modern standards. It was actually designed to run a request from the Air Force for storage capacity for their 50,000 spare parts inventory. It was designed to hold 50,000 character records with access to any records in less than a second. How did we search before we had computers? [Mark Weber:] People with clay tablets, which have writing on them, would sometimes have cross-references to other clay tablets. That's kind of the origin of Bing. Telegraphy--you could send in a query, like to a search engine, as a telegram and get it back by post. There were a lot of people that were thinking about how to use technology to search. The search engine is basically where you're looking through every word in every document that might be up on the web that's accessible to find a match. It's really just the same as if you went into a library ad you spent, in this case, it would take days to sit there and go through every page of book, looking for all the occurrences of--I don't know--the word "aardvark." Obviously, that's something that's really painful to do in the real world, but powerful computers can make that so fast that it actually becomes a reasonable way to search for information. Our students have all the knowledge they need to build a search engine, but what are they missing? Well, a few thousand of these. We're standing in front of the Google server rack. This is a web server, but it's using Ethernet to connect these different boards, which are actually separate computers that they've put together in a rack. These are just generic PCs, because you can run a search engine at home on one computer, but it's not going to have a very big index. How many are we talking about--10s? Many, many, many thousand. Google was not a particularly well-known one it its early years. Most of these search engines--today we think of them as being incredibly wealthy companies. At the time they were mostly losing money. They had venture capitalists put money in but they basically didn't make enough money from selling ads to pay their bills. Search engines actually go back before the web. On the Internet there were several search engines. The closest to what we have today might be WAIS, done in the late '80s, and that let you search different servers over the Internet. Then we have, for instance, the CERN Virtual Library, which was done by Tim Berners-Lee, the man who invented the Web, but that wasn't really like a modern search engine. It was more like a library cart catalog where you have categories. Early Yahoo was like that as well. The one that got the most recognition was Alta Vista, and this was kind of like the Google of its day in the late '90s. One that was a little bit different was Ask Jeeves, which was a search engine, but it was also meant to be a natural language query. You could say, "What's the capital of Spain," and it would give you the answer. Google borrowed an idea from a little search engine called GoTo.com, which was to not just have ads but to sell the search terms themselves. So like when you go to Google now, and you see the "sponsored results," those are actual terms related to what you're searching for, but they're also ads. That just took off. People really responded to that. That actually brought the entire search industry from on its way down to being one of the most profitable parts of web commerce. I hope everyone enjoyed the visit to the Computer History Museum. Maybe one day, there'll be something in the museum built by a CS101 student. If you're ever in the area, it's a really cool place to visit, and you can also drop by our offices in Palo Alto, only a short distance from there. What we're going to do next is learn about the present of computing. We're going to visit SLAC National Accelerator Laboratory, and see how they're using computing to advance science today. We're here at SLAC National Accelerator Lab, and we're going to see how they use computing to understand the mysteries of the universe. [Spencer Gessner:] We're standing in the klystron gallery, formerly the longest building in the world. [Richard Mount:] You're here at SLAC National Accelerator Laboratory. This is a 50-year-old laboratory, as all the flags on the lampposts around the lab are telling you. It was founded to build a 2-mile-long linear accelerator. SLAC is an accelerator laboratory still. Its main science is based on accelerating particles and creating new states of matter or exploring the nature of matter with the accelerated particles. This always has generated a lot of data, a lot of information. It's very data-intensive experimental science. >From the earliest days of SLAC computing to analyze data has been a major part of the activity here. You really can only study the cosmos by studying it in a computer. You get one chance to look at it, but to understand how it evolved into the state it is now, you have to do all this in the computer. There are massive computations going on for that sort of simulation, massive computations in catalysis and material science and massive data analysis going on here as well. The particular particle physics experiment that I am involved in right now has some 300 petabytes of disk space-- some 300,000 terabytes, some 300 million gigabytes of disk space around the world to do this analysis. Of course, we are far from understanding everything about the universe, but this is probably one of the most data-intensive activity in science today. The raw data rate coming out of the ATLAS detector that I'm involved in is about a petabyte a second. That's 1 million gigabytes a second. You can't store that with any budget known to man, so most of it is inspected on the fly and reduced to a much smaller, but still large, storable amount of data. Right now we are sifting through these many, many petabytes of data to look for signals of the Higgs boson, as no doubt people have heard in the news. There are tantalizing hints that I'm not holding my breath about at all right now, but this is the way we do it. You need to have those vast amounts of data just to pick out the things that will really revolutionize physics in there, and you need to understand all of it in detail, because what you're looking for is something slightly unusual compared with everything else. If you don't understand everything else perfectly then you don't understand anything. [Max Swiatlowski:] We're looking at one of the racks that contains the ATLAS proof buster at SLAC. ATLAS is an experimental Large Hadron Collider in Geneva, Switzerland, that collides protons, fundamental building blocks of nature, traveling at very, very, very close to the speed of light with trillions of times the energy that they have at room temperature. You get many and many of these collisions happening at once and this enormous machine that reads out trillions of data channels. At the end of the day, you have this enormous amount of data--petabytes of data-- that you have to analyse looking for very rare, very particular signatures inside of that. If I want to look for a rare signature--something that had a lot of energy and a lot of really strange particles at once-- there are trillions and trillions of these events stored on this machine. To look for them in any reasonable amount of time, I have to do many searches at once. I have to use all the cores on the computers-- the hundreds of cores on the machine all running at full-speed at the same time-- to have any hope of doing it in any reasonable amount of time. [Richard Mount:] This isn't the sort of thing that search engines currently do. They're looking for text strings and indexing all the text strings that they find in some way like this. What we have is very, very structured. We know the structure of these data. We know exactly how to go to anything that we want to get to in these data, because the way in which everything is linked together is very well understood. Things will go wrong all the time. You cannot assume you won't lose data from the disk. You send it by network from one computer center to another. You cannot assume it arrives undamaged. You cannot assume your computers don't die in the middle of calculations. Everything can go wrong, so the computing we do for the LHC has many layers of error correction and retry. Some of the basic failure rates are quite high, but by the time everything has been fairly automatically retried and errors have been corrected, we get high throughput and a high success rate. For our next stop, I'm really happy to be here at Mozilla where they make the Firefox web browser. One of the really critical things about Firefox is it is open-source. [Dave:] Can you tell us more about what does it mean for software to be opensource? [Asa Dotzler:] For software to be opensource it means a couple of things. First, it means that the actual underlying source code to the piece of software is freely available, that people can acquire that from a website or off of a DVD or in some other form and see the underlying source code that makes up that program. But that's actually insufficient, because opensource also requires that not only can people see it but they can do what they want with it. They can take that piece of software, make modifications to it, develop their own products based on top of that. There are different licenses that opensource software operates under that have different requirements and responsibilities for those who take that source code and make modifications to it. At Mozilla with the Firefox browser, our license is called the Mozilla Public License, and it says you're free to take the source code to Firefox and go build your own browser with it. You can do whatever you want to that source code and you can turn it into Walmart-Fox, if you're Walmart and wanted to. There's no requirement that you pay us for that, that you have any involvement with Mozilla. But if you make changes that improve the software that you got from Mozilla, you have to return those changes. If you take a feature and you make it faster or you add a new feature, making the browser more capable, you're free to ship that and under your own brand for whatever your own business model is, but you have to return those changes. This allows Mozilla to take the work that you've done, reincorporate it into Firefox and ship a new version that's as good as the version you shipped. Different licenses behave in different ways. Our license is pretty generous in that it says you can take our product and combine it with other products, and you don't have to disclose any of your proprietary information. You only have to return to the Mozilla Project the pieces of our code that you altered. [Dave:] I'm here with Dave Herman who works at Mozilla and directs research here. Tell us how you go involved in Mozilla and open-source projects. [David Herman:] I was actually a graduate at the time that I first got involved. I was interested in JavaScript, and I was doing research in programming languages. I was spending some time learning about JavaScript, and I wrote web pages about. Out of the blue, Brendan Ike, the CTO at Mozilla and inventor of JavaScript, found the web pages that I had written and sent me an email and said that he was interested in talking to me about some of the things that I had learned and was doing. That experience alone was incredibly eye-opening to me. It showed me that the assumptions that I had had about the boundaries between research and industry, the boundaries between academia and industry. The boundaries between just a person on the internet and the movers and shakers in industry were a lot more porous than I realized, and it showed that the web is this place that brings people together who might otherwise not have had any way of getting to know each other. That was very exciting, and I started talking with Brendan and talking with Mozilla and got involved with the ECMAScript Standards committee, which is the standards committee that standardizes the JavaScript programming language. I was doing that while I was in grad school, and when I finished grad school I came to Mozilla full time. [Dave:] A lot of the students in our class have only been programming for about 7 weeks. Can they still get involved in opensource projects or do they need a lot more experience than that? [Dave Herman:] There are all sorts of ways of getting involved in open source projects. You don't have to be a computer science wizard to contribute. One of our largest sources of community volunteer work is localization, which is basically translation. Firfox is developed in English and our official release is in English, but we actually have close to 100 localized versions of Firefox in countries all over the world. We have volunteers in communities that could be as large as many countries or could be as small as a small community in one country where anybody can simply provide translations of the menu items and the windows and dialogue boxes--all of the stuff where we have to present something to the user we do in English, and then you can translate it. Now you can have contributed to your native languages version of Firefox. Another project that we started is a project called universal subtitles where you can take YouTube videos that were recorded in one language, and you can provide translation and the software will automatically create subtitles based on the translation that you provided. There are all sorts of ways that people contribute to Mozilla software and to opensource software in general, and it doesn't always have to be technical. It can be code, and sometimes we end up hiring people who started out contributing code and ended up working on some of the most advanced parts of our projects. But it also can be as simple as editing documentation or providing translations. [Dave:] We have a real wide range of different types of people in our class. Can you tell us is it possible for anyone to get involved in opensource software? [Asa Dotzler:] One of the things that really appeals to me about opensource software is the opportunity for a whole variety of people with backgrounds and different experiences and different interests to get involved with the project. A good example of this is if you look back to the Mozilla Project in 2002 and 2003, we were sort of struggling along with this next general Netscape communicator browser suite. And one day a young 15-year-old high school student showed up in one of our IRC channels where we all get together as engineers and testers and the people working all across the project and talk about the work we're doing, and he came in and said, "I don't like the way this particular button behaves in Mozilla." "Can someone fix that?" I reached out to him, and I said, "That button is actually powered by some simple JavaScript." "You could look at the source code and maybe you could fix it yourself." He said, "Well, I've put together a couple of web pages. I know some simple JavaScript." And before you know it he was a dedicated member of the team. Only a few short months later, he was one of the founding members of the new Firefox project that would go on to reach 500 million users today. This is a 15-year-old high school student with no background in computer sciences. He got involved. He had mentors who helped him learn the pieces he didn't know. He went and read books, and before you knew it he was building one of the world's most successful software products. We also have a number of students who come here, either for weekend work as something to compliment their education. We have people who are in the industry and have been developing software for as far back as the Fortran and COBOL days who are looking for something that's fresh and exciting and want to renew their skillset and see participating in opensource software as a way to work with some of the younger people on some of the newer technologies and to refresh and get revitalized with their computer software skillset and interests. We have people who are part-time Mozilla contributors working on it because they're interested in a particular feature set. We have retirees and people who have part-time jobs trying to fill the rest of their day and who happen to know something about what we're doing somewhere on the Mozilla project. Sometimes that's writing client software code in C++, but other times that's manning our volunteer support desk and helping Firefox users fix problems with their browsing experience. So opensource really does, and many opensource projects really do, have multiple points where one can attach themselves to that project and find support and mentorship. Some of the places you attach yourself can be very simple. We'll often put some of our most valuable programming resources on very challenging projects and leave some of the easier or simpler features or smaller bug fixing unowned, as it were, by a full-time staff member with the idea that that staff member can instead mentor a volunteer or a student or a retiree to go finish off that piece of the work. This is a great learning experience and an opportunity to develop a set of skills that you can advance and go and become more deeply with the project over time. Ultimately, this young 15-year-old, Blake Ross who helped launch the Firefox project moved from fixing a couple of style issues using some JavaScript and CSS on toolbar buttons to being the authority on a bunch of the C++ code that made up Firefox. That was probably in a short time period, maybe less than 2 years that he was able to make that progression almost exclusively through opensource mentoring relationships on the Mozilla project. I hope everyone enjoyed the visit to Mozilla and is excited about the things you might be able to do to contribute to open-source software. It's really a great way to learn more about programming as well as to work with expert programmers and contribute to making software that millions of people will use. [Dave:] I'm here with Jim Fruchterman who is the director of Benetech. Tell us about what Benetech does. [Jim:] Benetech is Silicon Valley's non-profit technology company, and we exist to combat market failure. Basically, when something doesn't make enough money but does a lot of social good, we want to develop software that delivers solutions for that social problem. [Dave:] What kinds of things do you actually build? [Jim:] We write software in three different major areas. The first one is education, especially for kids with disabilities. Like we run the largest library for the print disabled, the blind, in the world online. We also write software for the human rights movement, whether you're a grassroots group or a truth commission or a war crimes tribunal. Our third area is the environment. We write project management software for environmentalists that are running campaigns or managing programs on the ground to actually have the same kind of tools you would have in a for-profit but because you're in the environment now you've got one. [Dave:] And heard you're starting a new project for coding for social good. [Jim:] Yeah, it's in a pilot phase right now. It's called "Social Coding for Good," and you can kind of think of it as an online matching site for geeks that want to do social good. You tell us your passion, your technical skill, and your time availability, and we'll hopefully match you up with a project like Wikimedia or the Guardian Project helping human rights groups or whatever other sort of project that matches up with your goals. It's just in the pilot phase, but we're hoping that in the next year it goes to scale so that geeks all over the world that want to do social good can get a chance to go to a place like GitHub, do some volunteering, and get some good cred for having done something socially good. [Dave:] How much experience would students need to have to be able to start doing this? [Jim:] Well, I think that people in different levels of the professional area of software development can actually help. I think our initial target audience is to work on people who are in the profession, people who are working for high-tech companies or software developers, but the human rights, the environment, and the education need people at all sorts of different levels. It could be characterizing a bug or writing some documentation, and our goal, of course, is people can increase and improve their skills by doing volunteering for social good, and then hopefully that leads to a job either doing social good or maybe a regular job. [Dave:] It sounds like you found ways to do lots of really beneficial things with technology. Can you tell us what are the social responsibilities that someone who gets power because they learned about technology should have? [Jim:] You know, I think that being educated in a profession like software development you have a responsibility to give back to society. Many people do that by actually getting a job and creating products that have value. The thing I want to talk to engineers is as you go out there and you see problems that are important to society and they can take advantage or your skills, don't ignore them just because they don't make a lot of money. I think that there are ways to make a living or volunteer to actual help these issues, and I think that that's really an area of terrific satisfaction as a toolmaker when you see the great things that people do with your tools. Solve bit social problems and actually find a way to change the world for the better, not just for more money. For our next stop, we're going to get a glimpse into the future of computing. I'm here at the University of California Berkeley, which has one of the top computer science departments in the world. Lots of exciting things are going on. Let's go inside and see what people are working on. [Dave:] This is Brian Gawalt who works on text analysis, which is a really important problem for search engines if we want to be able to do a better job of identifying the right documents. Tell us how that works. [Brian:] There are lots of different approaches, but the model that we tend to take transforms them into a really nice hashtable representation. Text is long and unwieldy and unstructured and prose flows and goes, but computers like things that are nice and structured and amenable in familiar things like lists, hashtables, etc. What we've got is a way to turn unstructured text into a data structure that computers are really happy with. One of those is the hashtable and the ???. We can start with a document that says, "Obama announces candidacy," and we can turn that into a representation of that document, and imperfect representation that just says let's keep track of every word and the number of times that word appeared in the document. We would just go through and say "Obama"--go to the hashtable and hash Obama and make sure the value associated with it is 1. Similarly, "announces" hashes to 1, and "candidacyO hashes to 1. If we were dealing with longer documents, these values would grow, and the number of elements in the hashtable would grow as well. Then we come across document 2, and we can represent that with a whole new hashtable. "Barak Obama elected"--Barak maps to 1, Obama maps to 1, and elected maps to 1. If it also said "President" down here, we'd add more and more keys and keep track of the value associated with each one. When it comes time to relate documents to each other, like we would do with our search engine, we can look and say, hey, there's an overlap between these two documents and the fact that they both used "Obama." If we've got enough documents and there are enough patterns between them, then we can start saying I'm seeing this pattern of "Barak" shows up in a lot of them or "candidacy" or "announcements" seem to come from him a lot. Now you've got a way of expanding this key word that maybe we're searching for "Obama" and the search engine can think when you say "Obama" you're really talking about this wide pantheon of topics that all of the do with the 44th presidency. [Dave:] How did you get started working on this? [Brian:] Well, I was an electrical engineer, and I went from circuits to signals to statistical signal processing, and it turns out I was working on how to tell if a cell phone is sending a 1 or a 0, and the math behind that wound up being broadly applicable to general problems, including how to tell if an email is spam or not. That's kind of the entrÃƒÂ©e to text processing in general from my background. [Dave:] I see. So what's the next step then? Well, a lot of the stuff that we work with all comes down to being able to compare two documents and then finding out how that comparison matches to whatever you're target is--detecting spam or not. All that works really well if the documents are next to each other, living close to each other within a single system, but that gives you a maximum of how many documents get analyzed. So distributing the solutions to these problems is, I think, where a lot of energy is being put forth. I'm here with Sara Alspaugh, who is a PhD student at Berkeley, in the lab where she works on energy-aware computing. So tell us about this here. I'm working on a project in which we try to create electric loads whose power consumption can be scheduled at a given point in time in order to make use of renewable supplies of energy like wind and solar which are only available when there's wind or sun and not available when we necessarily need them to be. And so on this project we tried to create a computing cluster in which we scheduled the work that the cluster did at times when there was wind energy available. So for instance, the types of work this cluster might be doing is you might have some set of these machines which act as web frontends and respond to search queries, and they would need to respond to the search queries as soon as the query came in, and you wouldn't be able to schedule this work any other time. But some of the other stuff that the computing cluster might be doing is building the index for the search engine, and that sort of work has some flexibility in when you actually can do it, so you can wait until there's wind energy available to schedule this work. And so these machines can do their work powered off of wind energy, and the rest of the time you can keep them in a low power state so they're not consuming energy. This is Adrienne Felt. Adrienne is a PhD student at Berkeley, and she's done a lot of interesting work on computer security. So what do our students need to understand about security? One of the first projects I looked at, which I actually worked here with Dr. Evans, was I use Facebook and I install and use Facebook applications. Many of you may be familiar with the Washington Post Social Reader. And at the time I was just curious. What are these doing with my data? How are they getting my data? How do these things work? And so I decided to learn more about how they work, and from there it led to basically what ended up becoming my thesis topic in a PhD program. I'm still interested in how do applications get data and how do they use the data. When developers are writing applications that access users' private information or resources like their location or their camera, they need to keep in mind that they need to a) respect users' privacy and only use the resources that they need to use, and b) they have to be careful to build their applications in such a way that they don't accidentally leak this data to other applications. So I primarily focus on Android development and security of Android applications. One thing that's really important for an Android application developer to know is about the privacy and security of their applications. So when a user installs an application from the Android Market, they're shown things called permissions, which are small warnings that tell the user about all of the resources that the application gets access to on their phone. For example, for this application I'm looking at, the application can get access to location, the Internet, the list of contacts, camera, etc. So the user is warned before the application installation is completed that the application can do all of these things. So as a developer, it's important to only ask for access to resources that your application really needs. Otherwise you might unnecessarily scare off users who might otherwise want to install your application. So one of the projects we built was a static analysis tool that analyzes the permission usage of Android applications so that it can warn developers if developers are requesting more permissions than they actually need for their applications to work. I'm here with Isabelle Stanton, who is a PhD student at Berkeley, and she works on theory of computation. So what are you working on? Lately I've been working in computational economics, which is this exciting thing that really Berkeley focuses on, so looking at problems that economists face and see whether or not we can develop algorithms and ways to solve this. So particularly the thing that I've been working on has been computational social choice. Social choice functions are ones that aggregate people's preferences. So think about this as a voting mechanism. Everybody gets to say, "I prefer Candidate A to Candidate B to Candidate C," and then we take everyone's votes and we output some kind of winner. And you'd really like this winner to be the one most people prefer or something. The problem that I've been specifically looking at is that back in the 1970s Gibbard and Satterthwaite showed that for any kind of reasonable voting mechanism it's going to be susceptible to manipulation. So is this like when someone doesn't vote for their preferred candidate because they think it's going to be better for them if they vote for sort of the more popular, less preferred candidate? Exactly. So if you knew that your favorite person was the underdog and there was no way, you might change your vote so that way your second favorite person would be the one that's elected. We've been specifically looking at Binary Cup voting protocols, which are familiar to people as single elimination tournaments. So how could someone manipulate a tournament like this? The tournament organizer is allowed to pick the seeding of the players, and that's the bracket, that's in each round who plays against who. For example, I can show you over here on the computer. Here on this slide we have actually the Women's World Cup. The seeding is this picking of Germany versus Japan, Sweden versus Australia. If I wanted something else to happen, maybe I could have picked a different initial seeding here, like maybe I have Sweden play England, and that would end up with a different result out of the tournament. Let's go over a simple example. Everyone is familiar with the game rock, paper, scissors. And in computer science we like things to be a power of 2, so let's add in hand grenade so that way we have 4 players. So we've got rock, paper, scissors, hand grenade. Now we can look at 2 different tournament brackets that have different winners. So if we have rock, hand grenade, paper, scissors, first rock wins this match-up and then scissors wins here and then rock wins the total bracket. If, on the other hand, we have rock face paper and scissors face hand grenade, then paper knocks out rock, hand grenade still wins, and hand grenade is the final winner. So the tournament manipulation problem is to figure out if there's a bracket so that your favorite player wins, like this, given information about the match outcomes. I'm not sure if this explains how the US lost the Women's World Cup, but we'll leave that as an open problem. I'm here with Brielin Brown, who works on quantum computing. So Brielin, what does quantum physics have to do with computing? Quantum physics actually has a lot to do with computing. If you think about the algorithms that you've been learning about in your course for searching the Web and doing things like this, everything that you program is built on a fundamental model of computing that manipulates a registry of 0s and 1s. Everything is transformed into machine instructions to manipulate these bits. But in quantum computing, you actually get to replace these bits with something called qubits, which give you a lot more power. What can you do with a qubit that you can't do with a regular bit? With regular bits they're either 0 or 1 and there's no middle ground, but with a quantum bit you can actually exist in a superposition of 0 and 1. So right now I have this coffee cup which the viewer doesn't know whether or not it has any coffee in it. So right now it exists in a superposition of being filled and unfilled until I measure, a.k.a. take a sip. And so you can see that there is coffee in this cup. The cool thing about quantum information is that it takes a lot more classical information to describe the same system. But at the end of a quantum algorithm, to get the access for this information you have to take a measurement which actually destroys the system. So if you're really clever with how you devise your algorithm, you can sort of access this exponential amount of information in a way that allows you to solve a problem faster by making a correct measurement at the end. And so this allows you to do things like factor integers faster or simulate quantum systems, which gives you a lot of progress in physics that we haven't been able to see recently. Wow. All this talk about physics is making me thirsty. I think it's time to go get a coffee. [laughs] Absolutely. Ah! That's good. Or is it empty? You can't really tell. I hope everyone has enjoyed our field trips as much as I have. It's really been a great time doing this, and it's been an amazing experience to teach this class. You're nearing the end of the class but I hope just the beginning of your journey in computing. There's a lot more exciting things to do after this, including taking the courses that we'll be offering starting in April, but I hope all of you will find more exciting things to do in computing after this class. It's really been an amazing and wonderful experience for me to teach it, and it's been a privilege to have so many students from so many different places in the class and to see how much you've all contributed to make the class great and the effort that you've put into it. So I hope everyone has had a great experience. Stay udacious, and I look forward to seeing you soon. In this problem, we're given a dictionary where the keys are children and the values are a list of parents, and given a person, we want to go through the dictionary, and calculate a list that contains all of that person's ancestors. So let's go over the plan. We're going to use recursion. We're going to find the person that we're searching for in the dictionary. We're going to add that person's parents, their direct relatives, to the output list, and then we're going to recurse on the parents to find the ancestors, adding the result of this recursive call to our output list. This should be enough to get started, so let's go right to the editor. If the person we're searching for is in the genealogy dictionary, we're going to do what we described previously. If they're not in the dictionary, we're going to return an empty list because we don't know any of their ancestors. So for each parent, we're going to add their ancestors to the result list, and once we're done, we're going to return the result list. And that's it. So in this problem, we're going to try to build up a given row of Pascal's triangle. So you could solve this problem recursively, and that's what I did my first time, but I feel that the iterative solution is a bit simpler and more intuitive to understand. This isn't always the case, but this is how I'm going to explain this problem. What we're going to do is, we're going to start with a list that's row 1, and then we're going to build the next list by adding the 2 numbers above it. More precisely, let's say we're doing the last row, and we have the previous row already made, we're going to start an invisible 0 here, and we're going to say, 1 is going to be the sum of the 0 number that I just made up and the 1 that's the first element of the previous row. We're going to update our pointers to move over by 1, and we get to the element 4 by adding 1 and 3. I'm going to repeat this process all the way through. 6 is 3 + 3. 4 is 3 + 1. 1 is 1 and 0. So that's pretty easy to explain, and that's basically how you would do it if you were building it out by hand, but putting it in a code may be a little bit more complicated and have alluded you. So let's see how it's done. So if I initialize the first row in the triangle to 1. We don't have anything for a result yet, so that's an empty list. I'm then going to iterate through the process of building each row 1 at a time, n times. That way we can get to the nth row. We're going to append the row that we just discovered onto the result list. The first time around it will just be the list of 1 because that's how the triangle starts. We're then going to find the next row, which I haven't defined yet, and then repeat this process appending the current row onto the result list. Once we're done, we're going to return the result. So this is a good outline of what we're doing, but we're missing the most important part, and that is the makenextrow. So a row is going to start as an empty list. As I had the 2 pointers before, we're going to have the previous one and then we're going to have one that I'm going to call e. So as I said in the description, we're going to start out with 0. That way when we add 1, we get 1, which is the sides of the triangle. We're going to calculate the new entry in the current row by adding e--that's our right pointer--with the previous one that we start at 0 so that we get 1. We're going to update the values in previous and then the next iteration, e will update to the next value in row. This last line basically includes the 1 on the right-hand side. Once we return result, triangle can use makenextrow accordingly, and we're done. Unlike the previous problem called Feeling Lucky, where we wanted to modify the search engine such that it returned the highest ranking result, we want to create a new function that orders the results according to the ranking. Now in order to do this, what we need to solve is sorting. We need to be able to sort the pages according to the ranking. This is a very well-studied problem. and a canonical example of algorithms. For the purposes of this course and a kind of reinforced recursion, we're going to use the quicksort algorithm. Quicksort is interesting because it's incredibly elegant. It's recursive, and it happens to be one of the fastest ways you can do sorting, and we're going to do it in just a few lines of code. Before we get started, I'll go quickly over how quicksort works. Let's say we have this list of 5 elements, and we're going through the quicksort algorithm. The first thing we need to do is to choose a pivot point. A lot of implementations use a random one, but it really doesn't matter if we assume that the data we're given is randomly distributed. So let's just choose the first element as our pivot point. That makes coding it simpler, and it's also a little simpler to go through. What we're going to do now is divide the rest of the elements according to things that are smaller than the pivot point and things that are greater than the pivot point. So let's do that. So we have our pivot point 2, and now we're going to go through the rest of the elements and decide whether or not they're greater than or less than 2. A pretty simple operation. So 1 is less than 2. We're going to add it to this list. 8 is greater than 2. 0 is less than 2. Notice how I didn't bother with the ordering of the sublist. We're going to take care of that by recurring quicksort onto the sublist of each side. 9 is greater than 2, and we're done. What we have is a partially-sorted list. Everything that is less than 2 is on the left side of this, and everything that's greater than 2 is on the right side. So what we're going to do is, we're going to redo the same thing to the left side, the same thing to the right side, and in the end, once we sorted everything, we combine them all together, and we have a sorted list. So let's go through that real quick. So here 1 is the pivot point. We get 1. 0 is less than 1. Here 8 is the pivot point. 9 is greater than 8. And we're done here. We're also done here. Now we're left with single element lists. We do quicksort on each of these, and a list of 1 element is sorted, so we're done sorting at the bottom. We now append on the way up. So the end result of all of these appendings will be our sorted list. And just to finish our list, let's just say we called it conquer. Hopefully this gives you an idea of what we're doing. So let's go to the code, and it might become a little clearer if you're confused. So our ordered_search takes in 3 parameters: the index, the ranking of the pages, and the keyword that we're searching for. I'm going to look up the pages that are associated with that keyword, and then I'm going to quicksort the pages according to the rankings that it was passed into ordered search. This is another function that we'll have to define. So I'm taking in 2 lists-- the url's and the rankings of those url's which is stored as a dictionary. So if I didn't get any pages passed in, or it was an empty list or whatnot, then I'm just going to not do anything and stop right here. This saves some cases that add a little bit of complexity later on if we take care of it now. So the first thing I'm going to do is find the pivot point, which is the ranking of the first page. That's, basically, how we did it in the example I went through. We initialized our 2 lists, the better list and the worst list. Now we're going to go through each page and put them in the correct list accordingly. One thing you might notice is that I didn't go through every page. I skipped the first page. That makes the code a little bit simpler because I've already included the page as the pivot point. Once we put the pages in the correct list, we're going to recur. In order to get the list concatenation to work appropriately, you need to put this pages into another list. This is the appending that I showed at the end, and this is the recurring that I showed earlier. This is all quicksort is. We got--what is it--14 lines of code,13 lines of code, and we can even save a little bit here and there if we wanted to, but we're just going to recur, and we're done. To go through it real quickly, if we have 1 page on our list or if there are no pages in our list, then it's considered sorted, and we return it right away. Otherwise, we find our pivot point, which we want to use as the first element, and for the rest of them, we're going to put them in the appropriate worse or better list, if they're better or worse ranked. We're then going to recur on each of our sublists, and once that's done, we're going to append them all together.