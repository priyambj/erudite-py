Hi everybody, I'm Cameron Pittman. Welcome to this short course on JavaScript promises. Every web developer needs to be able to handle asynchronous work with confidence and ease, and that's why you're here. You're here to take advantage of native JavaScript promises. There are many methods to handle asynchronous work already. However, as you'll be discovering in this course, promises are the recommended option, because they give you flexibility, intuitive syntax, and easy error handling. But before we start all that, I have an off topic question for you. [SOUND] You're looking at millions of stars in the disk of our Milky Way galaxy. Every dot is a star. Some are bigger and brighter than the sun, others smaller and dimmer. But what else is in this picture? Planets. Every single star in the Milky Way is the possible home for dozens of alien worlds. That means it's likely that there are hundreds of billions of planets in our galaxy alone. The Kepler Space Observatory has found more than 1,000 exoplanets like this one in the last few years. Combined with data from other telescopes, astronomers have confirmed sightings of almost 2,000 exoplanets. That's a lot of worlds. I had an idea when I was designing this class, and I call it the Exoplanet Explorer. It's a web app that helps people learn about real planets around other stars. Throughout this class, you'll be using promises to request real JSON data about exoplanets, and that data is coming from NASA and CalTech. You'll be using promises to turn that data into useful information in the app. Are you ready to get started? The Promise object is used for deferred and asynchronous computations. Okay, great. This statement is less than helpful if you're understanding of the word asynchronous is less than certain. So, the question is, what is asynchronous work? Asynchronous work happens at an unknown or unpredictable time. Normally code is synchronise. One statement executes, like this one, and there's a guarantee that the next statement executes immediately afterwards. Threading on processors doesn't necessarily guarantee that, however, the JavaScript threading model ensures that for all intents and purposes, JavaScript runs in a single timeline. Unlike synchronise code. Asynchronous code is not guaranteed to execute in a single unbroken timeline. In fact, you should assume that you have no idea when asynchronous operations will complete. In a situation like this, for example, you can't even assume that just because you sent out the first request first and the second request second, that the first request will overturn sooner than the second. Assume that either order is equally likely, as the fact that one or both requests just might fail altogether. Network requests aren't the only examples of asynchronous code. Any code that relies on processes like these, like events, like threads, or just some kind of unknowable finishing time are asynchronous. So, the big question is, what is the best way to handle asynchronous code? Okay, the answer is obviously promises. That's why you're here. Callbacks are the default JavaScript technique for asynchronous work. Pass the function to another function, and then call the callback function at some later time when some conditions have been met. This works well but there are some questions without obvious answers. For instance, how do you handle errors? It's best practice to assume that any operation could fail at any time. It's doubly important to assume so with network requests. If an error occurs here, should you still execute the call back? If so, what value should it receive? If not, then what should happen? What if it's a JavaScript error? Should that be handled any differently than a network error? There's no clear answer. Node basically makes error first callbacks mandatory but that doesn't really solve the problem. It's still basically your job to define, and implement an error handling strategy. Assume that everything happened just fine, no errors and then this callback runs when the unload handler gets called. Great. Now you've chained together two pieces of work, but what if this callback is also an asynchronous operation and you need something else to happen afterwards? Do you pass another function with another callback here? This is one scenario that leads to something called the Pyramid of Doom. A dreadful situation where there are nasty, nasty nested callbacks within call backs, within callbacks. This looks ugly and it's hard to write, but the real sin is that it is incredibly frustrating to debug. This is the same kind of code, but written with promises, and my, it looks nicer. You'll be learning all about the beauty of .then later in this course. For now, just read this and appreciate the fact that you can figure out what's happening here, despite the fact that you haven't even finished this course. That's pretty awesome. I broke this course into four stages that built on one another. You'll start in the wrapping stage where you'll be learning the syntax of constructing promises. A promise constructor in and of itself isn't super useful. So from there, you'll be learning how to react the resolution of the promise. If all goes well, you'll want to then off the promise, or if something breaks, you'll want to catch the air, these are the thening and the catching stages. You'll spend the whole second lesson in the chaining stage where you'll learn how to create long sequences of asynchronous work. It's also worth going over some promise vocabulary. I'm stealing these definitions from Jake Archibald who wrote a fantastic guide on promises that you can find in the instructor notes. There are four states a promise can have. You'll pick up these terms pretty quickly, but I recommend jotting them down on a piece of paper to help out as you're going through the course. Here they are. The first one is fulfilled, and that means that the action related to the promise succeeded, this state is also known as resolved. Then there is rejected, this means that the action related to the promise failed. The next one is pending, which means that the promise has not yet fulfilled or rejected. And then finally, there's settled, which means that the promise has either fulfilled or rejected. Okay, now that you've got the terms behind promises and you know where we're going in the course, it's time to examine how and when promises are executed. I want you to imagine a situation like this, where you're setting an Event listener after the event has already fired. What happens? Nothing, if this event doesn't fire again, then this Event listener never gets called. Now imagine you're using promises and you set an action to occur when a Promise resolves here which is after the promise has already resolved. Guess what? This will execute. Compare this to Event listener example where the Event listener would never get called if it's set after the event already fired. I want to quickly show you some code. This is a promise constructor, and you'll be learning more about this in the next video. This methods, resolve, settles the promise. A promise can only settle once. So in this scenario, the second resolve is doing nothing. Nothing's going to happen, it's going to go by unnoticed. Compare this to events. An event can fire many times, but a promise can only settle once. Promises execute in the main thread, which means that they are still potentially blocking. If the work that happens inside the promise takes a long time, there's still a chance it could block the work the browser needs to do to render the page. If so, the frame rate of your app is going to suffer, and you'll probably hear your users complain about jank. Promises are not a pass for safely executing long running operations. They're simply a technique for deciding what will happen when an a synchronous task settles. Think of them as try catch wrappers around a synchronous work. Okay, it's time for a quiz. In which of these situations should you consider using Promises? Should you consider using Promises when you're working with information from an Ajax request? Should you use them when you're executing long-running image manipulation in the main thread? Should you use them when you're creating a series of divs and appending them to the body in a specific order? Or should you use them when you're posting messages back and forth between the main thread and a web worker. If you're not familiar with web workers, it's an API that allows you to create independent threads to execute long running JavaScript off the main thread. There's more than one answer, so check all that apply. So, which of these scenarios are right to be promisified? I'll go ahead and start at the top, working with information from ajax requests. Most definitely, the would asynchronous is in the very definition of ajax, and you'll be working with these kinds of requests soon. Next up, executing long running image manipulation work in the main thread. No. Promises run in the main thread, so you don't gain anything from wrapping work in the main thread in a promise. The work will still happen synchronously and still probably lead to a gen key experience. Next up, creating a series of HTML elements. No. Creating and appending dom elements is synchronous, so there's no need to wrap them in promises. That being said, if these were, say image elements, or script elements with links to external resources, then loading the external resources themselves, are asynchronous operations. You could use promises to chain actions after the resources load. Likewise, if the data came from an asynchronous resource, then you could wrap this in a promise, but that's not what's happening here. Last up, posting messages back and forth between the main thread and a web worker. Yes. Web workers run on separate threads and post data to the main thread. They are certainly asynchronous and perfect for promises. All right, that's enough discussion about promises. It's time to start writing them. We are entering the wrapping stage. I want you to keep in mind that a promise is a tricatch wrapper around code that will finish at an unpredictable time. Here, let me show you an example. Promise is a constructor. You can either store a promise as a variable like I'm doing right here. Or you can simply work on it as soon as you create it. Either way works just fine. But you'll often see me simply work on the promise without storing it as a variable. You pass a function to the promise with two arguments. Resolve and reject. Resolve and reject are two callbacks that you use to specify when a promise has either fulfilled, because something worked, or rejected because something went wrong. Let me show you what this actually looks like. In this example, I'm wrapping an image tag loader in a promise because I want to do some work after the image loads on a page. I'm using the image tag's onload handler to specify success. Onload calls resolve, which queues up the function, passed to then to execute after this function finishes executing. Note, the JavaScript engine does not immediately stop executing this function upon calling resolve. In this case, that's the last piece of work so effectively it's the end of the function however, that's not always the case. Check the link in the instructor notes to see what I mean. Being able to called resolve and reject is important. This is what it gives you the flexibility to explicitly say what constitutes fulfillment and what constitutes rejection for the promise. When either resolve or reject has been called, the promise has been settled, and then at that point, the next part of the chain. Usually, a .then, or it could be a .catch is then executed. Back to the original example, any value passed to resolve or reject will be received as an argument by this subsequent .then or .catch. In the event that nothing is passed to resolve or reject as is the case here with the reject, then it's totally fine. The next link in the chain simply receives undefined. There's a third case and that is if the value that's passed is a promise. If so, then the promise will execute first and then whatever value it resolves to will be passed to the next link in the chain. Note that resolve and reject have the same syntax. Resolve leads to the next then in the chain, while reject leads to the next catch. Incidentally, if there is a JavaScript error somewhere in the body of the promise, .catch will also automatically get called. And by the way, there's a bit more to error handling and you'll be learning about it in the next lesson. In the meantime, it is time for you to write your first promise. For this quiz you'll be wrapping set.Timeout with a Promise. There won't be any error handling yet because I want to keep this first quiz simple. I'm giving you a sample page to work with, and inside of it you'll find a function called wait. Wait should simply wait a set number of milliseconds before resolving. That means that you'll need to call resolve when setTimeout executes its callback. While you're working on this function, I want you to console.log(this) inside the Promise. The reason is that I have a question for you about the scope of this inside Promises when you finish working on it. I also want you to return the Promise from wait. The reason is that, after you finish your work, you will be able to uncomment these two lines to test your code. If there are no errors, and this text changes, you'll know you've done it right. And like I said, when you're done, I have a question for you. What is the scope of this inside the Promise? Type your answer into this box. Don't forget, you can find a link to more quiz instructions in the instructor notes, and good luck. So here's the solution. To start off I'm creating a Promise by using new Promise. I'm going to pass a function into the Promise with the parameter (resolve). There is no reject in this case because I'm never going to need to reject so I just don't include it. Inside the Promise I'm logging (this) so I can check out its scope later. And I've got the setTimeout. You'll see that in the callback function to the setTimeout, I'm calling resolve to resolve the Promise. In this case the Promise will resolve after some number of milliseconds that's getting passed into wait. Also notice that I am returning the Promise. And you'll see why in a second. Then I've uncommented these two lines which say that after 2000 milliseconds the (finish) function should get called. All right, let's see how this looks. I will go ahead and refresh the page. You see that two seconds later it is complete. It looks like this logged out the window, or the global Object. Incidentally, this, the scope of this, could change depending on the context. For instance, if you use arrow functions with ES 2015, you will see a different this, so keep that in mind. So the correct answer is the global object. Okay, that first quiz was a little bit on the simple side. This one's going to be more useful. You'll be matching jQuery's.ready feature by wrapping a check for document.readyState in a Promise. You are now in the thening stage of the course. I want you to use then to perform an action after a promised result. Document.readystate has three possible states. Loading, interactive, and complete. Loading means the document is still loading. Interactive means the document has loaded and been parsed. But subresources like images and style sheets have yet to load. This is equivalent to the dom content loaded event. Lastly there's the complete state, and that means that all the subresources including images and style sheets have loaded. Every time the document's ready state changes a ready state change event fires. Creating a promise to run on interactive is really useful if you want to run some code as soon as all of the initial dom elements have been loaded. For this quiz I'm giving you an event handler for ready state change. I want you to wrap it in a promise so that it resolves when the dom is interactive. Or, in other words, I want it to resolve when the ready state is no longer loading. Like the last quiz, you don't need to worry about air handling because if the dom is never ready then the page won't display anyway. Make sure you test, too. Do so by using .then to chain the method wrapperResolved when the document is ready. Make sure you check out the Instructor Notes for help getting started, and good luck. To start off, I need to give credit to Jake Archibald, who came up with the idea for this quiz, and who also wrote this code. There are two parts to the ready method. It checks the ready state when the readystatechange event fires, and it also checks the ready state immediately. By checking it immediately, this ready method will still work if the ready state becomes interactive. Before creating this promise, so that's pretty useful. And if the readyState is still loading when the promise is created, it'll call checkState every time the readystatechange event fires. Once the readyState is no longer loading, it resolves. So here's how I'll test it. I simply call ready, and then chain, then wrapperResolved. Time to see how it looks. To test this quiz it's kind of hard to see but I'm using to 2G so that the image takes a little bit to load. Remember this text should say resolved before the image shows up. Now, it already say resolved but let see what happens when the page get refreshed. You can see that its resolved immediately before the image even finishes loading, that's pretty cool. Okay. Now it's time to try some air handling. I hope you're starting to get the hang of Promises. I've got another challenge for you. I want you to wrap an Ajax request in a Promise. You're now officially in the catching stage, and don't worry, it's pretty similar to the venting stage. In the instructions I'll be asking you to add .catch to your promise as a way to see if there are any errors, and then do something about it. Right now you won't be recovering. You'll simply be console.logging them. To take this quiz, you'll be doing your work here, inside the xoplanetexplorerapp.js file. Check the instructor notes for its path. I want you to wrap this XHR helper method with a Promise. Unlike the last two quizzes, a lot can go wrong with a XHR so you need to include error handling. Reject if there's an error, or if the request status is anything less than 200. Remember, any value that you pass to resolve or reject will get passed to the next then or catch. And of course, don't forget to return the promise from get. Test your Promise wrapped with this URL, which, by the way, it might change. Use whatever you see in the rebuild. The file that's requested contains a simulated search response for the exoplanet explorer app, and it contains the URLs for some JSON data of some Earth-like planets. Pass the response to add search header when it resolves, or if it fails to resolve, catch it by passing unknown to add search header on reject. You might try messing up this URL to make sure your .catch works correctly. While you're working, I recommend using gulp serve to watch for changes and automatically reload the page. This is definitely the fastest way to work. Anyway, make sure you check the instructor notes for help and some more instructions. Good luck. To start off I'm calling gulp serve, and I'm letting that run in the background. So here's my promise wrapper inside get. Notice that I'm returning the promise, and I'm resolving when the request status is 200. I'm passing the response to resolve so that then gets the response as well. I'm rejecting on any error whether that's not a status of 200 or something else, and the rest of it looks good. I didn't have to change anything else. Down here in the web components ready listener, I am actually doing something to the page. Once I get the data, I add the search header, and if something goes wrong, I add a search header of unknown and then console that log error. Okay, let's see what happens. So it looks like this query works because you can see earth-like planets on the page. But let me see what happens when I mess up that URL. I'll go ahead and just delete a character. Let's see what happens. Okay, that looks good. I see unknown as the query and I see an error here in the console. I can open it up and see that something went wrong with the XHR. Cool, I want to show you one more thing though. Inside the addSearchHeader there is this call to JSON.parse of the response. If you think about it, parsing a JSON really has nothing to do with adding a search header, so in the next quiz you'll be removing this all together and putting it inside a different method where it does belong. The course that you're taking is about native JavaScript promises. They started showing up in browsers around the end of 2014, but polyfills for promises have been around for much longer actually. JQuery, which is obviously a very popular library, implements its own version of promises, but they have some serious issues. So I definitely recommend reading up on them in the instructor notes if you want to use them. The first version of Angular uses Q style promises. These are mostly the same as native promises, but have some slight differences. Angular 2, however, will actually be taking advantage of native JavaScript promises. Once again, check the links in the instructor notes to learn more. As of this filming right now in December of 2015, native promises are safe to use with every major browser, except for Internet Explorer and Opera Mini. You'll need to make sure that you include a polyfill or some other kind of fall-back on your production sites. There are some new APIs that are also taking advantage of promises. For instance, they're the recommended strategy for interacting with the new service worker API. Service workers are a total game changer. They allow you to add a powerful layer of control between your app and the network, and that means that you can actually create apps that work offline. Seriously, it's amazing. And you should check the instructor notes to learn more. In the next quiz you'll be using another new API called the Fetch API. It uses native promises to simplify xml http requests. That's really hard to say. Substantially. So let's go ahead and do it. As you probably realized a few videos ago, or maybe even longer, XHRs are really annoying. Even the simplest use case is fairly verbose, and it only gets worse as you address edge cases and browser compatibility issues. Fetching resources really just shouldn't be this hard. Luckily there's a new API that simplifies XHRs, the fetch API. Currently it's natively supported by Chrome, Firefox, Opera and Android browsers. Its support is growing, and it's incredibly useful, also it's built on native promises. This is going to be a two step quiz. On the first part you're going to re-factor GET with the Fetch API and in the second part, you're going to be creating a new wrapper called getJSON. getJSON should return a Promise and it should return a promise, that's two steps. The first part should be getting the URL and use the get method for that. And the second part should be parsing the JSON response. I want you test getJSON by adding a search header in counsole.longing the parse of JSON. When you do so, you should see an object with search data appear on the console. If there is an error, catch it. Pass unknown as the search header and then counsel.log the error. As always see the instructor notes for more information and good luck. So this is how I did it. Inside get I am just using fetch, in fact, this whole object here with method get is totally optional. If there are no options fetch assumes that you're doing a get, so you can just get rid of it. Here in getJSON, I simply then'd off the get and then return response.json. This whole response.json is specific to the fetch API, but it's basically the same as json.pars. To test I'm getting the json and then if it's there, I'm adding the query to the SearchHeader, if it's not I'm adding unknown and console.log and the error. Don't let me forget to console.log, the response. Let's see if it works. So far so good, I'm seeing earth-like planets. And when I open up the console, I see the response logged out with the query and some more JSON files. That's pretty cool but I want to show you one more trick. I just switched out the .catch for another .then. I could have left the .catch there, actually but I just got out of it to keep this looking short. Anyway, so from the original .then, I am returning some results. In fact, this is the first URL in the search results. Then, in this then, I am taking the URL and console.logging it. The cool thing here is that I've got then and then another then, which means I'm chaining promises together. So what happens here? Now inside the console, after the whole search object, I'm seeing the URL of the first planet in the response. This whole idea of chaining is incredibly important, and that's what you'll be doing next in the course. So far you've created promises and chained the some work off them. You did so in the last quiz by creating a get function and then using .then to do something with the data that you retrieved. You also included catches to ensure that no error goes unhandled. With the promise API, .then also return promises. So if you can .then off of an initial promise, you can .then off of .thens because they are also promises. Developers commonly use the term thenable to describe promise in .thens. Any method or object that returns a .then is thenable. Anything thenable can become a part of a chain of asynchronous work. Promises are thenable as are .thens and .catches. In fact, other libraries include thenable objects. See the instructor notes for more information. When creating a chain of asynchronous work, each subsequent link in the chain receives either the fulfilled value of the previous promise or the return value of the previous .thens function. In this way, you can pass information collected from one asynchronous method to the next. Being able to chain thenables is an incredibly powerful technique for simplifying complex sequences of asynchronous work. You'll be practicing a few chaining strategies in the next lesson. So this is the end of the first lesson. You have already added a powerful new tool to your toolbox, and you are just getting started. At the beginning of the next lesson you'll be creating a chain of .thens to put thumbnails on the Exoplanet Explorer. See you then. Welcome back. In this lesson you'll be experimenting with different techniques for creating chains of asynchronous work. Asynchronous work is rarely isolated, and as such you may have many asynchronous actions that depend on one another. This is another strong suit of promises. Rather than creating a pyramid of doom, promises make it straightforward to chain together lots of asynchronous actions. And it even works when you're generating those actions programatically. To get started, you'll be manually creating a chain of work to load a planet thumbnail in the exoplanet explorer app. So here's how I did it. This first part should look pretty familiar, but there's one new line, this right here. I went ahead and return the response from the second getJSON. This getJSON is getting the URL of the first planet. By returning it, it will get past to the next .then which happens to be right here. When it receives the planetData, it then creates a thumbnail with it. Before we go on, I want to show you a slightly different syntax here. Instead of an anonymous function, I can actually just pass this function, createPlanetThumb, this function will receive the same argument. And as the argument that the anonymous function was receiving is the same one that createPlanetThumb was receiving, this works totally fine. I've also got two catches, here and here. I've got this first one here in case there is an error with the search results. And I've got the second in case anything else went wrong. Your error handling strategy may have looked slightly different and that's totally fine. So the real question is does this code work? Let's see. And it sure does. Very, very cool. Okay, but that's about as far as we can go just by manually chaining vents. It's time to make chains a little bit more interesting. So far, air handling has come in the form of .catches like this one. But there are actually other ways. These two chunks of code are actually equivalent. .catch is just shorthand for .then undefined and then a rejection function. Notice how, this then is actually is taking two arguments. The full function signature for then is actually this. In this form, if any previous promise is rejected, the reject function gets called. If they resolve, then the resolve function get's called. If there is no resolve function and the promise before this then resolves, then this then gets skipped over and the next then is called. In all cases, as soon as a promise rejects, then the JavaScript engine skips to the next reject function in the chain, whether that's in a .catch or a .then. So that means an error here in this promise or here in this promise, both get caught by this cache. Both methods .catch and .then with two callbacks work equally well. However, it's actually recommended that you use .catch when you can, because .catch is just easier to read and write than a second .then call back which can be hard to spot. In fact, you might not have even noticed it right here. That being said, there is a major difference in the execution order between .catch and a second call back. Notice that you cannot call both the resolve function and the reject function if they're part of the same .then. Only one or the other, or neither will get called. If something goes wrong with the resolve function, you'll need another .catch or another .then, farther down the line to catch it. But if you have .then and then a .catch. Each with their own resolve or reject function. Both of them can possibly get called. And finally, I want to make one more subtle point. It's also worth noting that it isn't necessarily true, that passing a value to resolve means that the promise succeeded. This is a subtle point. So go see Jake Archibald's blog post in the instructor notes for more information. In the next quiz, you'll be thinking through the flow of a chain of promises using different formats. There are some subtle differences to air handling strategies that can come back to bite you if you're not careful. So for this quiz, I want you to think through a few different scenarios with this long chain. Now, you normally wouldn't want to mix and match different syntaxes like I've done here, but I want you to think through some different situations. In this example, async returns a promise, as does recovery. The idea is that the recovery method gets the chain back on track and continuing to resolve if something goes wrong. My question for you is, for each of these four lines, what numbers will be logged if an error occurs there? Note that you can assume that no other errors occur. I'll go ahead and give you the first one. If an error occurs with async then the first reject function will get called, which is right here. So that logs A1. If the recovery works, which you can assume it does, then the next result function will get called, which is here. And that puts a 3 on the log. Okay, now it is your turn to finish up the rest. If an error occurs here in this line, then the next reject function will get called, which is here. So once again the first number is 1. Then the recovery function happens, and things get back on track. So, the next number is 3. After that, there's no more log in here so that's it. Next step. If there is an error with this recovery function, now this is an interesting one, because this is only going to get called if there is another error. So in this case nothing will show up in the log. And then for this one, if something goes wrong with the async function, then this next reject function will get called. In that case, the number 4 should end up on the screen. So, these can be kind of tricky, but just keep in mind that if something goes wrong, the next reject function will get called. When you need to perform asynchronous work, the work may not be isolated. You often need to perform multiple asynchronous actions. And so you are in the chaining stage of the course where you will be chaining promises together. There are two main strategies for performing multiple asynchronous actions. They are actions in series, and actions in parallel. Action in series occur one after another, like these three cats all waiting their turn for the rocket. While actions in parallel all occur simultaneously, like each of these cats getting its own rocket to ride. You could say that synchronous code is always in series. But asynchronous code can either be in series or it can also be in parallel. Neither option, series or parallel, is inherently better than the other, each has its own purposes. In the quiz where you fetched the list of planet jsons and then performed a request for an individual planet json You have to perform the two requests in series because one depended on the other. But if you need to request a lot of planet jsons, as you will soon be doing in a quiz, then you will need to programmatically send out the request. You'll also want to make the request in parallel because that will reduce the amount of time it takes to load all of the data. So with that in mind, here's a quiz for you. There's a problem with this code. It appears to be looping over the URLs from the planet search query, but something unexpected will happen. What is it? Is it that the requests are being sent in series but they will return in parallel, causing some kind of collision? Is it that the requests are blocking so that this code will never finish? Is it that the thumbnails will be created in a random order? Or is there just simply nothing wrong with this at all and I just gave you a trick question? I want you to pick one of these four answers. I'll start from the first one, no. The browser is really really really really good of keeping track of requests. You don't need to worry about a collision. In fact, I just made that up. So, no. For this one, no. Making lots of parallel requests is totally fine for the same reason as I just stated. Is it this one, that nothing is wrong? No. I don't like trick questions. So that must mean that the thumbnails will be created in a random order. Remember, you cannot predict the order in which requests will return. So you don't know when any of these getJSON promises will resolve, which means that they could resolve in a different order than they were created. In that case, the planet thumbnails will be created in a totally random order. Now, this isn't necessarily a problem or a bug, but it does lead to the question. Just how do you make the thumbnails appear in the right order? Keep watching. In the next three quizzes, I'm going to be challenging you to take advantage of array methods, to programatically create long chains of promises. Keep in mind that you want the thumbnails to appear on the page in the same order as they appear in the search results, but, and this is an important but, this does not mean that you need to perform the request in series. There are different strategies for controlling the order that promises resolve, which you'll be trying out soon. The keystone to all of these strategies is the idea of a sequence. You'll need to create a sequence of promises that are chained, one after another. Does this code look familiar? For this quiz you'll be refactoring it and making it actually work. To do so, you're going to need to create a chain or a sequence of promises. I want you to loop through the array of URLs that comes in the search results, create a promise for each one and then use that promise to create a thumbnail once it resolves. There are probably a few different ways to solve this challenge. You'll know you've done it correctly when the thumbnails show up in the same order on the page as they did in the original URL from the search results. Also, don't forget to handle errors. I'm going to let you decide what you want to do with them. When you're done I have a question for you. How are the requests executed? Are they executed in series or in parallel? Even if you think you know the answer, make sure you check the network panel because you may be surprised. I'm going to give you some hints to help out. But if you want a challenge, go ahead and skip to the quiz. Of course there's always help in the instructor notes. Are you still here? Okay. I want you to think about a loop that looks like this. For every iteration through the loop, x increases by 1 before the iteration, x is at 0. Then you add 1 to x and get 1. You add another 1 to x and get 2. And then so on, add another one. You get 3. And at some point you've chained so many ones together that you've got 10. I want you to treat the sequence similarly, but don't use addition here. For every iteration through the loop, add another then to the end of the sequence. Remember that for each planet you're going to need two actions. You'll need to get the JSON and create a planet thumbnail. In this way the sequence will grow by one request and one thumbnail for every iteration. Okay good luck. Okay so there are different answers to this question depending on how you solve the problem. Let me show you my solution first, and then I'll talk through how you may have come to a different conclusion. I'm iterating through the URLs and adding two .thens for each URL. The first gets the JSON data and then the second creates the planet thumbnail. As for each iterates through the array of planet data urls, the sequence gets longer by two thens each time. Each .then will need to wait for the promise before it to resolve before it can execute. There's some good news and some bad news. The good news is that the planet thumbnail show up in the right order. The bad news is that it's happening in series. You can pretty clearly see that each request depends on the one before it finishing, but you might have seen that all the thumbnails show up and found that it was in parallel, and if so, I bet your code looks something like this. Notice that this time I'm not actually adding to the sequence, rather, I'm simply adding two thens which quickly get overwritten by the next iteration through the loop. Luckily, these two thens stay attached to one another, and so they continue to execute. If your code looked like this, then you probably saw the request come in like so. They're in parallel and the problem is that there's no guarantee about the order. And to be honest for many applications this is completely fine. You can handle ordering in other ways with your front end. But if the order that promises resolve is important to your app, this kind of code could easily become a subtle source of bugs later. Browsers can request many resources simultaneously so it makes a lot of sense to run code like this in parallel. But if you want to do so, you probably should where it's really, really obvious that your requests are happening in parallel. In fact, you'll be doing that in the next quiz. .map is an array method that accepts a function, here represented by this box and a rocket ship, and it returns an array. The array that it returns is going to be the result of executing this function against every element in this array. Here, let me show you what I mean. It starts with the first element. It creates the array and passes this element into the function and executes it immediately. So at this point, this function is running. Then .map moves to the next element. Now it is in the array and executing as well. It goes to the next, and so on until it's created this new array. And for each element in the array, the function has already executed. In this case, the array you want to iterate against is the URLs, and you'll want to call getJSON and createPlanetThumb against each one. Okay, and I lied about sequences earlier. You don't actually need to create a sequence in order to use .map, however there is a bonus challenge at the very end of this course. Your solution to this quiz is going to be the starting point for it. You'll probably find that you'll need a sequence to solve it. Anyway, map the URLs against the methods you need to load the thumbnails. When you're done you should see the thumbnails appear on the screen, and you should see the request go out in parallel. So this is how I did it, by mapping an anonymous function against every URL in the results array. This function takes the URL and then gets the planet's data, once it has that then it creates the planet thumbnail. All right. Well, that's pretty simple. And like I said, there was no need for a sequence here. But remember, there is no guarantee to order when you're using .map. If order matters, you'll need some additional logic in your app to handle it. All right, it's time for the final promise method. Let's go to last quiz. There is one last promise method that you should learn to use, and that is .all. .All takes an array of promises, it executes them, and then it returns an array of values in the same order as the original promises. .All fails fast, in that it will reject as soon as the first promise rejects, without waiting for the rest of the promises to settle. This means that even if one of the promises rejects, the whole .all rejects. But once ever promise has resolved, then the next in the chain gets the array of values. For this quiz, I want you to refactor this code from the previous quiz, using .all. When you do it correctly, of course you should see the thumbnails show up and you should also see parallel network requests. Check the instructor notes for more information, and good luck. So this is how I did it. .map returns an array so I create an arrayofPromises by passing all of the URLs to getJSON. Now remember at this point, because they've been mapped, this function immediately runs against every URL. So in reality, I have an arrayOfPromises that are basically already executing, and then I simply pass them into .all. Once all of the promises settle, then the next link in the chain runs. In this case the .then receives an arrayOfPlanetData, which is in the same order as the array of promises and then for every planet, I create a planet thumbnail. Very cool. Looks like I left out a semi-colon. Incidentally, I could make this section a little bit more terse. Let me show you how. First off, I don't need this anonymous function. This is the same, because remember this function will receive the same argument as the anonymous function. And of course I don't actually need to create a variable, I can simply pass the array created by map straight to all. Anyway, lets see how this looks. All right, the planets are once again there in the correct order, and I'm seeing all of the requests happen in parallel. The cool thing is because all guarantees the order of the resulting array, I know that all the thumbnails ended up on the page in the correct order, so that's pretty nice. There is one more performance optimization that's possible with this code. Some people may or may not think it's a good idea, but it's definitely a good challenge. So after this course is over, at the very end of it, there's a bonus challenge for you to optimize this code even further. There are hundreds of billions of planets in the Milky Way, but they're really hard to spot. Humanity's search for other earths has only yield a small fraction of the possibilities. If you're interested in learning about exoplanets and the techniques astronomers use to spot them, keep watching after this video. Anyway, that was fun. I hoped you enjoyed learning a little astronomy alongside JavaScript. Of course you came here to learn about Promises, the easiest technique for handling asynchronous work with JavaScript. You learned how to wrap asynchronous work in Promises, you chained asynchronous actions together, and you practiced error handling. You experimented with sequences of Promises, and you tried different strategies to convert lots of asynchronous actions into long chains of manageable promises. It's been a lot of fun. I want you to go out there and use Promises to simplify your life, and you know what, don't forget to look up every once in awhile. [MUSIC]