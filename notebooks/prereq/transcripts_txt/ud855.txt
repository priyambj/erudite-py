Hey, Joanna, did you notice this? Well, talk back is pretty repetitive for this list. Can you call Dan? Yeah. Hey folks. What's up? Just wondering if you looked at talk back support? I think we did something. I remember something about content descriptions. Well, the content descriptions are pretty awkward. Not very helpful. This is basic accessibility stuff and. This is why we're here, right guys? To help make sure Sunshine is a great app for all of its users. Yeah, totally agreed and not at all intentional. This is something that should never be an Apple product- Hey, I'd be happy to take care of making Sunshine accessible, but, Dan, does that mean you forgot to do localization work as well? Got it. Okay, I'll take care of that as well. Sound good? Good, good. I'm going to go out and test sunshine outside, and try out these new improvements. They do seem like they will be really helpful. Nice work, Dan. Not all Android users interact with their devices in the same way. And that is why it is important to make sure your app is usable by anyone. This includes users who have visual, physical or age related limitations that prevent them from fully seeing or using a touch screen. And users with hearing loss who may not be able to perceive audible information and alerts. To make these considerations easy for developers, Android provides accessibility features that help users navigate their devices more easily including text-to-speech, haptic feedback, gesture navigation, trackball and directional navigation. Even better, our experts have created a nifty checklist to help developers know what to focus on when making their apps accessible. So, let's take a look. There are three basic checks that you should make before releasing any app that will cover the majority of accessibility scenarios. First, you need to provide content descriptions for user interface components that do not have visible text. This is most important for buttons, check boxes, and images because these components often influence the flow of the app. So use the android:contentDescription layout attribute or the setContentDescription() Java method to provide this information for accessibility services. Note however that decorative graphics are the exception to this rule, but be sure to indicate this by setting content description to NULL.Second, you should make sure that users can navigate your screen layouts by using the hardware based, or software directional controls. Many users will employ D-pads, trackballs, keyboards, and navigation gestures, and you should be confident that your Apple support these. Put an exceptional focus on ensuring that any UIElement that accepts input Is reachable. In some cases, this may require that UI components are focusable, or else you may need to adjust the focus order to be more logical. Finally, audio feedback must always have a secondary feedback mechanism, to support users who are deaf or hard of hearing. For example, a sound alert for the arrival of a message must be accompanied by a system notification, haptic feedback or some other visual queue. Now that you've put all this effort into making your app accessible, you'll want to be sure that you've done a good job. As with any other app development process, you need to test your app. The easiest way to do this is just to turn on the accessibility services on your device. I use Talkback, and then I just go through the app, trying every component and cleaning up the bad behavior. Nothing about TalkBack or an equivalent app, Ready to Go. You should play with Sunshine to see what you find, then fix the problems. As a reminder, you'll want to check the three basics, content descriptions, focus-based navigation and making sure you don't have any audio-only feedback. And then use the accessibility testing documentation for advice on what to look for. When you're done, go ahead and let us know by checking here. Great. If you'd like to compare your fix with what I found, check the GitHub commit linked in the instructor notes below. I covered the core of the checklist. But there are a couple of things I didn't walk you through. Custom view controls and custom accessibility services. For any custom views that you create for your app, you'll want to implement the accessibility interfaces to support the native features. Beyond that, developers may build their own accessibility services, which can provide enhanced usability features, such as audio prompting, physical feedback, and alternative navigation modes. Accessibility services can provide these enhancements for all applications, a set of applications, or just a single app. This means that custom services you build can be used by other apps, or that your app might be able to use someone else's custom accessibility feature. So be sure to cover all of your accessibility bases. But accessibility considerations won't be enough to reach all users, you also need to consider localization. To reach the most users, your application should handle text, audio files, numbers, currency and graphics in ways appropriate to the locales where your application will be used. This is actually pretty simple if you use the Android resource framework to separate the localized aspects of your application from the core Java functionality. You can put most of the contents of your apps UI into resource files, whereas the behavior of the UI is driven by your Java code. For example, if users input data that needs to formatted or sorted differently depending on locale. Then you would use Java to handle the data programmatically. But alternative strings or layouts can live in the XML. To begin, you'll want to identify the target languages and locales for your app. You can manage your app in three main dimensions, country, locale, and language. Language is the key consideration for localization, but locale is significant to format dates, times, currencies, and such. Users control what the language and locale used on their Android device is, and those affect how your app will be displayed. After you've identified your targets, you can focus your development, translation, testing, and marketing efforts to these markets. Once you know where you intend to distribute your app, you can design for localization. Planning early is key as you need to consider the space and locations for each language. You can reuse your default layout if you build a flexible UI. The key to this is to allow elements to expand horizontally and vertically. And also to leave about 30% more space than you need for your default language, so the translations will have plenty of room. If you need an alternative layout, though, you can tag it with the relevant qualifiers so that the resource framer can find it automatically. But, using the mini alternative layouts will be harder to maintain. So you'll need to determine what's best for your app. Android 4.2 introduced need of support for right to left layout mirroring. There are two simple changes that you will need to make. In the Android manifest file, add android:supportsRtl="true" To the application element. Then, in each of your app's layouts, change all of the left/right layout properties to the new start end equivalents. Note that if you're targeting SDK 17 or higher you can replace each left/right property with a start/end equivalent. But, if you're supporting an earlier SDK version you'll need to use both versions. For example, you'd use both android:paddingLeft, and android:paddingStart in each layout. There are also a few new attributes that let you have precise control over LTR and RTL layouts, such as text alignment and layout direction. So check the documentation for more information. Now it's your turn to play with RTL layouts. You'll want to implement RTL support for Sunshine. When modifying the layout properties, remember that Sunshine supports back to SDK version 10. It helps to have a test device or emulator running Lollipop, because Android introduced a new developer option to force RTL layout direction. This way you won't need to change the language of the device to see what you're working with. And when you're done, click here to let me know. Well done. Now that you know what to consider when designing your layouts, let's take a look at translation. In order for strings to be localized, it helps to move all strings into strings.xml. Any string that is hard coded cannot be translated without modifying the compiled code. In the strings.xml file, you will want to comment thoroughly in order to provide the context for the string. This will result in higher quality translations. You may want to include information such as, what is this string for, when is it presented to the user, where is this in the layout? For example, translations are less flexible for a button than a text box. You can also specify strings that should not be translated simply with a placeholder tag. Finally, there are a variety of system provided formats for dates, times, numbers, and currencies. So take advantage of our utils such as date format for dates, decimal format and string format for numbers and currency, and phone number utils for phone numbers to simplify formatting across your locals. If you provide strings in values/, values-en/, and values-fr/, and the users device language is set to French, which string set XML do you think that they'll see? Exactly. Using language codes lets the Android framework know that you support other language, and when French is the device language, then the values-fr resources should take precedence over the others. Finally, be sure to test your localized app. Keep in mind that devices vary across locales, so try to have test devices that closely match what is available in your target environment. Check all of your target locales for common issues, such as clipped text, or awkward line wrapping, or untranslated text and incorrect alphabetization. And then, check a locale you aren't supporting to be sure that your default resources are working as expected. Finally, have your app reviewed by native speakers, either within your company or through beta test programs. Now, hopefully, you've learned how to test some good edge cases. With that in mind, lets go back to our previous hypothetical. If you provide strings in values, values-en, and values-fr, and the users device language is set to Japanese, which strings on XML will they see? Good job. When the device's language is not called out explicitly, the app will use the default values, which are the ones in the unqualified resource directory. In this case, that would be the string select small file from the values folder. Localization is critical but does require extra planning and work. So after you go through all these steps, remember to support your international users after you launch. Check reviews regularly, and consider creating local specific user groups. Good luck. [LAUGH] Hey, and welcome back. How the field testing go? Quite well, in fact. Always nice to see an app that works well offline. How's Sunshine looking? Well, it certainly sounds much better. That's a relief. Now, as we add new features just make sure we keep it up. Don't worry. I'll keep you all honest. Angela, how many times do you actually launch Sunshine during the day? Probably about 100, I mean, we are working on it right now. No, no, I mean to check the weather. Oh, maybe three? Do you really feel like Sunshine's making you amazing? No. That's the problem, remember the Android creative vision, make me amazing? Right, that's why we added those notifications. Exactly. Notifications are a great way of bringing Sunshine to the users, making it just a normal part of their day. The students spend all that time building a content provider. We should show them how useful it is, and have them leverage it, to build a widget. Great idea Dan, I actually have a bunch of ideas on how to bring Sunshine to the users. So then, what are you waiting for? Dan mentioned the idea of using widgets to bring our Sunshine data directly to the user's home screen. What exactly is a widget? So far, we've only focused on activities, full screen experiences, and fragments, which are reusable portions of those activities. Widgets differ in that area provides just the view. That view is then passed to the home screen app, the launcher to display alongside other widgets and other app launcher icons. App widgets had a humble beginning. Fixed-size widgets that could respond to one action, tapping. It was great for control widgets or widgets with just a single piece of information to display. In Android 3, widgets got support for collections of data and vertical swiping. Now, you can display a stack, list, or grid of data right in your widget, making it easy to jump into exactly the piece of information you need. Android 3.1 opened up the possibility of resizing your widget either horizontally, vertically, or both. This gave users the ability to customize exactly how much space they want to give to your widget, and gave developers the tools needed to customize how they display their data depending on the size of the widget. So, can we use these capabilities for Sunshine? Let's focus on two common cases. Today's weather, where we'll build a horizontally resizable widget, showing information just about today. And the weather forecast, where we'll build a detail widget, which will display the same data we see in the main screen of Sunshine, to give users quick access to their forecast, right from the home screen. So let's get started. So what exactly do we need to know to get a widget working? How does the launcher even know we have a widget the user could choose to add to their home screens? There's two main pieces. An AppWidgetProvider XML file and an AppWidgetProvider class. The AppWidgetProvider XML file Is what describes your widget's attributes, such as its size, whether it can be resized, and a preview image, which helps users get a sense of what your widget will look like before adding it to their home screen. The AppWidgetProvider is what holds all the logic for creating the actual widget views, filling the views with the correct data and setting up the click listeners so our widgets respond to touch. One thing to keep in mind is that users aren't limited to just one instance of your widget. They could have a bunch of different sized widgets with potentially different data. That's one reasons why part of your AppWidgetProviderInfo can specify a configuration activity, a special one-time setup activity that appears when users select your widget. Well, we won't use this for Sunshine. You can imagine, if Sunshine supported multiple locations at once, we could use a configuration activity to select which location we wanted to display in each widget. So, let's start simple. We'll build the one by one version of our today widget with some static data, say sunny and 76 degrees Fahrenheit, a nice 24 Celsius. What would our app widget provider info look like? In fact, there's only a few required attributes. First here is initialLayout. This is the XML layout to be used by default. minHeight and minWidth are what determine how many cells in the launcher are used. Note that the number and size of cells can change based on the device or launcher being used. A good rule of thumb is this formula, which works well for all default launchers. In any case, you should build your widget such that it's flexible enough to support slight variations in the size available. The last attribute, you can see here, is the updatePeriodMillis. By default, the system will wake up your device at approximately this interval, and call your app widget provider update your widget, with a minimum update period of a half hour. However, if you have static data, you don't want to wake up the data if it's in deep sleep. Or, if you have another component already controlling the flow of new data into your app, such as Sunshine Sync Adapter, you can use 0 to disable this functionality and prevent unnecessary work. That's all we need to get started. While our minimum app widget provider info would be enough to get us started, a preview image is one of the best ways to improve the user experience. Giving users an idea of what the widget will provide, even before they add it to the home screen? What attribute do we add to the app widget provider info to set the preview image? Yep, you got it, the aptly named preview Image attribute is what you need to include if you want to preview image for your widget. Generally, during development, you'll be iterating on your widget, and creating a preview image isn't as useful. After you've finalized your widget, you can use the Widget Preview App, available on Android Emulators to get a perfect preview image of your widget. Then put the image in your drawable nodpi folder and reference it in your app widget provider info xml. All the meta data in the world doesn't help if we never actually build the Widget Provider. This is the class that has the logic for building the view for the widget, and passing it on to the launcher app. It does that through the use of a special class, Remote Views, because these views need to go across applications, and break their traditional sandbox provided for each app. Only a subset of the normal views are supported for widgets. No custom views are allowed. Thankfully, all of the common views you use in normal Android view layouts are available to your widgets. In fact, you'll build your widget layouts in XML, just the same as you would for any other layout in your app. One caveat with widgets has to do with margins. Prior to Android 4, Ice Cream Sandwich, widgets needed to beride their own margins so that widgets wouldn't appear huge next to the app icons already on the home screen. On Android 4.0 and higher, however, the margins are automatically applied for you, and your background should fill the entire space. To make our widget backward compatible, we can wrap our widget in a FrameLayout that includes the correct padding for each API level. So what does this mythical AppWidget Provider class we've talked about actually do? The core of it is in the onUpdate method. This is where we surprisingly update our widgets. We've got a list of appWidgetIds, unique identifiers for each widget the user has created. And it's your job, should you choose to accept it, to update all of those widgets. Thankfully, that's pretty easy for static widgets. Create your RemoteViews object, and pass it on to the AppWidgetManager you're given. But even that's not very useful. The setOnClickPendingIntent method allows you to control what happens when you tap on your widget. The only final piece we need to get our widget up and running is an entry in the Android Manifest. It ties our AppWidget provider To our AppWidget provider info. You'll note, the AppWidget update action here. That's what tells Android that this is a widget provider. And our meta data attribute, so it tells Android where to find the meta data it needs to display the widget in the widget selection screen.. With all those pieces in place, we should be able to get a basic widget showing up on the home screen. Okay, so we know all the basic parts of building a widget. So let's enter first widget to Sunshine. Rather than do everything at once, we'll iterate. For this first iteration, let's get our one by one widget with static data working first. Make sure you use set on-click pending intent so that tapping on the widget launches Sunshine. Awesome. Adding all the pieces into our app, we can see the widget on our selection list and place it on our home screen. Woohoo! Now that we have the baseline working, let's actually make this widget useful. Static data is not all that useful, I know. Luckily, you have this content provider that has the exact data we need. Let's put these things together. But wait, we took all this effort and sunshine to not run queries on the main thread. AsyncTasks, IntentServices, Loaders, and SyncAdapters were all used. What can we do here, or is there even a problem? Let's go back to when we added our app widget provider to the manifest. The app widget provider class is actually a thin wrapper around one of the basic types of components on Android, a broadcast receiver. Broadcast receiver is a short lived component that receives broadcasts from other components, or other apps, through its onReceive method. App widget provider harnesses the broadcast sent by the Android system provides us with a simpler to use onUpdate() method among other things. Turns out the onReceive() method and hence our onUpdate() method get called on the UI thread. Doing anything that might take a while, is probably not a good idea. A very common pattern, one you need to do more work in response to a broadcast, is the broadcast receiver starting an Intent Service, do to heavy lifting. Intent Services are great for this kind of work because the On Handle Intent, runs on a Background Thread. And the service is automatically stopped once done. No need to keep the service around when there's nothing to do. So we'll write an intense service that does everything our onUpdate method did and change our onUpdate to CallStartService. Now, we can use the same technique we used elsewhere to retrieve data from our content provider, query to retrieve our data, then extract the information we need. So now, we can see our app widget provider is calling our intent service. Our IntentService is then querying for the data and getting a response back. As our AppWidgetProvider is a broadcast receiver at its core, our SyncAdapter could send a data changed broadcast to our AppWidgetProvider to update the widgets exactly when we have new data. We'll add a new constant to our SyncAdapter. Then use that constant as the action for the broadcast we send out. Then we'll update our manifest entry for the app widget provider to receive the new action. Finally to actually handle our message, we override the onReceive method to look for our action and start the Intent Service to update the widgets. Time to get real data. We'll move the code from onUpdate into our separate IntentService. Call startservice from our onUpdate method. Send our broadcasts when the data's changed from the SyncAdaptor. Then receive that broadcast in our AppWidget+Provider. Finally, we'll update our IntentService to query for real data. Don't forget to add your IntentService to your Android manifest. Whoa, I think we might've made something actually useful. You should start seeing realistic weather in your widget now. Well, unless you put placeholder data in there that was the same as the weather, then you might have to wait for the weather to change just to make sure. As exciting as our little one by one widget is, there just isn't enough room to show everything you might want. The ability to resize widgets gives you the flexibility to share almost all of your code, yet give users the flexibility to choose how much space they want your widget to take up. Remember our design in the beginning? A two by one widget would give our icon the full height. And we'll use the same styling as listItems within sunshine for the high and low temperature. For wider widgets, we'll show the description of the weather as well. Since we'll be sharing as much code as we can, make sure common elements, like the image and high temperature text us the same IDs across all three layouts. So how do we know what layout to use? On Android 4.0 and lower devices, we know the size will always be our default size, but on Android 4.1 and higher devices, we'll take advantage of a new method added to AppWidget Manager, getAppWidgetOptions. This takes a widget ID, and returns it to bundle, which contains information, such as current size of that widget in dp. With that information, we can easily switch between layouts by comparing the widget's width to specific values, denoting the break points between our layouts. In fact, we can use two new attributes added to app widget provider info. minResizeHeight and minResizeWidth. These let you set a minimum size that's smaller than the default size. With this, we can make our default the two by one widget, and allow users to resize down to a one by one if they're crunched for space. This is great for ensuring that you put the best experience forward while maintaining flexibility. We'll also add one more method to our AppWidgetProvider, onAppWidgetOptionsChanged. This is called whenever the size of the widget is changed. In our case, similar to our onReceive and onUpdate method, we'll start the intent service to refresh our widget. Okay, so lets get our widgets resizing. Create the other two layouts, implement the onAppWidgetOptionsChanged method, and update the IntentService, to choose the right layout based on the current size. If you're anything like me, as soon as you got things working, you sat there and resized your widget for what seemed like a solid minute. Just me, then? Well, it's still cool and it gives users the flexibility to really make the widget part of their perfect home screen set up. So our current widget focuses on one thing, today's weather, and I'm kind of okay with that. However, there are certainly times when quick access to the entire forecast would be helpful. For that case, we can build a collection widget. These widgets control full list, grid, or stack of elements, perfect for showing off the upcoming forecast. Good starting point for this is a simple list view widget. The top banner can open Sunshine itself, while below the list offers direct access to the forecast of each upcoming day. Clicking on one of these will go directly to the detail page for that day. So, I'll layout style and header click behavior the same as our today widget. Filling in the data on our list here is a different story. For that, we'll use a remote view service. The remote view service is responsible for creating a RemoteViewsFactory. Think of it as the equivalent to a cursor adapter, that's specifically designed for returning remote views, suitable for widgets. Note the special permission, BIND_REMOTEVIEWS. This is what lets the system bind your service to create your remote views for each row. To tell our remote views to connect to our RemoteViewsFactory, you'll use the setRemoteViewsAdaptors method. This method kicks of the RemoteViewsFactory's life cycle, causing our data to reload and remote views created for each row. To update our widget based on new data, we can still use the same technique as our Today widget, in receiving the data updated broadcast. But instead of calling an Intent Service to update the whole widget, we can just call the NotifyAppWidgetViewDataChanged method to trigger the onDataSetChanged three queries for new data. So if that's all it takes to get data into our widget, and get out list populated, we're done right? In some cases, sure. But we're trying to make this production ready. What we really want is to be able to tap on a particular day and go directly to the details of that date. If your mind is already spinning on where to add the set on click pending intent method to get this working, you'll be happy to know that there's some tools which make this easier. The idea is that each element shares some common template for the click action. That means our app widget provider can also call setPendingIntentTemplate with the pending intent that has all the common attributes. Say, what activity to start. Our RemoteViewsFactory get you at method then handles the unique part for each element calling set on click fill in intent to fill in our template appropriately. Now of course, for Sunshine, we have to consider how about tablets, which have the master and detail view together and phones, which have them as separate activities, work. That complicates things a bit here. Let's just see how it all falls together. So here's everything we need to get the detail widget working. You'll see our DetailWidgetProvider and DetailWidgetRemoteViewsService do almost all of the hard work. But we still need the layouts, app widget provider info and manifest update. Thankfully, those parts should be very familiar to what we built for the today widget. Awesome. Look at how much sunshine I can have on my home screen now. Wonderful, wonderful sunshine. No, no. Not rain, no, no, no. Well, at least now I know. This widget is already paying off. Now, not every user is as sunshine obsessed as I am. The important part is now we've created an outlet for our biggest fans and made their life more amazing. It may be a single feature you build out that causes those users to rave about your app to all their friends and grow the next group of happy customers. So far, we've been talking about taking over part of the user's home screen with widgets. Meaning that they trade their precious home screen space for more information from Sunshine. A useful trade off for me, and maybe for many others but there's another element on the home screen we haven't looked at, the background of the home screen, called the wallpaper. Could we use the wallpaper as a passive way to bring weather information to the user? Yes, we can. Now, the type of information we can provide for wallpaper is somewhat different from a widget. Colored icons and text don't exactly scream most beautiful background ever to me but what we can do is make beautiful backgrounds into the weather. A sunny picture for a sunny day, a snowy picture for wintertime fun, and some ominous rain clouds for when an umbrella's a good idea. Sounds neat but how would you actually do it? What about pictures that are too bright, making the text or icons hard to read? How can we build something like this without becoming an expert on dynamically changing wallpapers? Sometimes, you do have to become an expert but just as many times, some good Google fu might reveal the perfect library or the perfect app that makes your job much, much easier. It just so happens, this is one of those cases. There's already a live wallpaper app out there called Muzei that provides an extensible system Sunshine can plug into to build our dynamic weather wallpapers. So how does that even work? So we've worked with notifications and more recently with widgets. Both are good examples of API's provided by the Android system that let your app extend beyond the full screen activity we started with. However, this isn't limited to just the system. Apps can also provide API's you can integrate into your app to further extend your app. A little research shows that this is exactly how Muzei does its magic. It extends the live wallpaper API provided by Android. Gives us an easy API where we only worry about sending Muzei new wallpapers. And it does all the work actually displaying them to the user, controlling things like how bright or blurred the picture should be, fixing those issues with readability, we mentioned before. And even mirroring the wallpaper over to Android Wear devices if the user wants. So how do we do it? First, we'll add a gradle dependency. Then a manifest entry for our MuzeiArtSource. MuzeiArtSource is an intent service, which Muzei will connect to get our wallpapers. The intent filter is how Muzei knows it can connect to our service. We'll also include a special icon, description and even a color to help make sunshine feel at home. So what happens when a user selects our app for their wallpapers. First, we get a call back in our Muzei Art Source of on Enabled. Then on Subscriber Added. Then comes the most important one, on Update. This is where we will publish our wallpaper making it available to Muzei. Similarly, upon selecting a different app, we'll get an on Subscriber Removed, and on Disabled callback. So what would our on Update look like? We'll do a simple query to get the current weather. Use a new Utility method getImageURLForWeatherCondition to get the appropriate wallpaper URL and then build up an Artwork object. In our case we'll include the imageUrl. We'll use a description of the weather as the title or main piece of content. And then we'll use the locationQuery as the byline. Our secondary line of text. Muzei offers the ability to open more details. Loading the main activity of sunshine seems like a good way of seeing more details to me. We'll pass that artwork through to publishArtwork. Like magic, we'll see Muzei handle all the image loading, live wallpaper code and other work to get our imagery on the user's wallpaper. Neat. While we have the option of using Muzei's scheduleUpdate method, we can use the same approach as our Widget, and use our data changed action to trigger an update. That way, whenever the data changes, we'll update the wallpaper as well. In this case, though, we're triggering a service. So we'll add a start service call, to our sync adapter. Then, our onHandleIntent, can include a special check for the data updated action. And if we're enabled, and the user who has selected us as their background source, we can call our own update method. So that's everything we need, seriously. Just the two methods in our MuzeiArtSource is all the code we'll need. So with just a little bit of effort we've suddenly got passive wave for users to just know the weather. Note taking of space on their home screen or remembering to launch Sunshine. Many ways of expanding your app can have a dramatic user experience impact with a much smaller effort than it took to get the core of your app built. We've talked about widgets and user wallpapers, but perhaps we're thinking too small. We're still limited to just a single device. However, Android gives us the tools to build a truly multi-device experience through AndroidWear, Android TV and more. AndroidWear gives us ability to really improve our notifications. High-resolution backgrounds, more information, and even the ability to add custom actions and layouts, to give users a great experience without pulling our their phone. Taking it even farther, you can build Android apps that run directly on the watch, letting users bring up your app on command, say, right before deciding on whether to pack that umbrella. Or build a watch face to make the weather information available all the time. Android TV opens up the other end of the spectrum with a 10-foot experience. This is where that great imagery and easy-to-read information can really be useful. That's not counting the great video or radar imagery opportunities that could really make the big screen experience amazing. If you'd like to learn more about all the ways to take your app even farther and explore the myriad of devices available to you, check out the ubiquitous computing course which goes into these topics and more. You know, Ian, I think I agree with you. There's something very useful about having sunshine right there. Otherwise,how would we have known it wasn't going to rain. Yeah, totally agree. Yeah, all sunshine today, huh? [LAUGH] Hey, Ian, so it's not a big deal, but you know how we want Sunshine to just be the best it can be and we've been working really hard to personalize it and polish it up? The thing is, it just doesn't really make me feel amazing. I don't know, when I get a weather notification from Sunshine, it really makes me feel like Sunshine's helping me see into the future. Right, but that's not really taking it far enough because think of it with like notifications. Sometimes, a daily notification isn't really enough, but then other times you've just have this same sunny, gorgeous weather every day. Yeah, good times. Right, so I was talking to Dan, and I have some changes that I want to make that I think will be really useful. Something that's a little more now, and a little less into the future. Okay, you do that. Dan wanted to show me this crazy redesign of Sunshine he's working on, so I'm going to go down there now, and then go enjoy the sun. [SOUND] Most Android apps won't live alone on the device. You'll probably want to talk to your app at some point. And to do that you'll need a server. Now, I'm not going to walk you through building a server. There are plenty of resources out there for that. Instead, I'm going to show you how to communicate with your server. So let's focus on how to get data from your server to your app. The easy way, which you're already familiar with, is known as polling the server. This is when your app calls up the server, just to see if anything has changed. With a repeating alarm, the app does this after a specified amount of time. But, with a sync adapter, it'll do it whenever the radio is turned on, after some time has already passed. Sorry, let me just, there. Sorry. So, by waiting for the radio to be activated by something else, we can spare a bit of battery life, but that requires a flexible timing schedule. So you need to determine what your priorities are when choosing a polling method. For example, in Sunshine, we poll the weather servers every three hours, give or take, to keep the weather data up to date. An alternative to polling would be pushing. With this method, the server is responsible for the messaging and will inform your app when new data is available. Your app doesn't need to regularly check in with the server. Just, okay. Where was I? Oh yeah, pushing. Oh, pushing. What a good idea. Okay. So pushing can happen in two ways. Either the server can send a small message called a tickle, which says something has changed and asks the app to sync at its earliest convenience. Or, the server can just send the updated data directly to the app and cut out the middleman. So, you might be wondering why anyone would ever choose pulling over pushing because there's no obvious advantage to pulling. So does that mean that you missed something? No, you didn't. Properly configured pushing will always be less expensive for the device on which your app is running. It will lead to fewer syncs, which will lead to fewer uses of the cellular radio, which will lead to longer battery life. It also makes things easier on your server, who won't have to deal with nagging devices all day everyday. Note, however, that I said properly configured. The cost here is extra engineering effort to set up the pushing server. And it isn't always a simple process. So that's why we introduced Google Cloud Messaging, to make it easy to communicate with your applications. Now Sunshine is dependent on the open weather map service for its weather data, and we don't have control over how we communicate with their servers. And I already said that I wasn't going to teach you about servers today. But I will teach you about GCM, and to do that, I'm going to fake a few severe weather alerts. In the United States, the National Weather Service issues severe weather alerts when a hurricane, tornado, tropical storm, blizzard or a similarly severe weather pattern is likely in an area. This weather does not happen daily in most places. I'm looking at you, tornado alley. But when it does happen, it's vital that your users be aware of the danger. And that means that these would be time-sensitive alerts and not nice-to-know facts tomorrow morning. So let's dive in. So normally we would have a shiny server that subscribes to weather alerts. So then when a new alert happens, the server will see it first. Then it can take that alert and use it to make a push notification. And then it can send that notification to each affected device. In this case, devices that are in the region that we're concerned about for the weather alert. But, of course, before we begin you need to take a trip to the Google API console. Some Google services are now available through a config file that you get from the developers console. This config file helps by doing such tasks as keeping track of your project number, which will later be the sender ID used to identify your messages as distinct from another app's. When you generate this file, also take note of the server API key because you will need this value later on. Once you have your config file, you need to make sure it leaves in the app or mobile directory of your project so that the Android framework can find it. And then you need to tell the Android framework that it is there by modifying the build.gradle files. And the top level build.gradle, you're going to add a dependency on Google Services. Then in your project level built.gradle, you'll introduce the plug in for Google Services. Now to use Google Play services specifically, you'll need to first install the library through the Android SDK manager. You'll find Google Play services under extras at the bottom. But you should also see Google Repository there. Go ahead and install both Google Repository and Google Play services. The repository is where all of the jars you will be referencing are so don't skip this one. While Google Play services will give you access to offline docs and code samples. Then you will need to reference the new library in your app. So go back to your project level build.gradle file and add the compile rule for Google Play services. The cool thing about this library is that you can reference the specific bundle that you care about. In our case, that is Google Cloud Messaging. And you can avoid compiling the entire library into your app. Also the version number will likely have changed from what you see here, so use the Android Studio recommendation or check the documentation for the latest version number. Finally, because it is hard to anticipate the state of a user's device, you must always check for compatible Google Play service APK before you access Google Play services features. There are two approaches to this and you should choose the one that best fits your app. You remember Radel's explanation of the Android activity life cycle right? So you could handle this flow while your app is active at the moment you wish to make the API call. Or you can check for the SDK when your app first start and then attempt to resolve error such as a need to install or update or enable Google Play services at the beginning of your apps execution. If you're checking early, you can do so in on creates that you can configure various aspects of your app based on the result. But you may prefer to make this check or an additional check in on resume. Because you never know how the user will use their device and you don't want to end up in a wonky state. If your features are dependent on the expectation that Google Play services is available you'll need to check here. For sunshine, we are only going to check at creation because we are going to design the messages separately from the rest of the app. If the APK is unavailable, we will never enable the GCM feature. And the user will not receive weather alerts. In this way the user should never even notice that something is missing from the app as the normal app flow is untouched. And that is what it is to fail gracefully. So, at the creation of the app, we will check for Google Play services with a call to is Google Play services available. Then, we will attempt to solve any errors that we can, such as prompting the user to update. This first step is fairly straightforward. Modify the build.gradle and the app build.gradle. Then add the CheckPlay Services helper method I just showed you to the bottom of main activity. And add a placeholder check in onCreate that will call this method. So that in later steps, we can control our app flow based on the result of this call. You'll also need a request code for Google Play Services. So to see these changes check out the GitHub commit linked in the instructor notes. You'll need to implement all of them in your app, and once your code is ready click here to let us know. Second, will need to add a few things to the Android Manifest. GCM requires several permissions. Sunshine is actually already requesting one of these which is Internet, which we obviously will use to communicate with Google and with our fake server. So, we can go and check this one off the list. The next permission is Wakelock, which is technically optional depending on whether you want to keep the processor from sleeping when you receive a message. We are going to include it however, because the receiver that we will use to get the downstream messages is the provided GCM receiver, which extends from WakefulBroadcastReceiver. Unless you intend to write your own receiver and to not use a WakefullBroadcastReceiver, this permission is not optional for you. The Receive permission is what allows our app to register to receive messages. So you obviously need this one. And finally, the message permission is a custom permission made using our package name so that no other Android app can register to receive messages intended for our app. Those sneaky little eavesdroppers. So first you'll need to actually declare the permission. And then you can register to use it. Beyond the permissions, we'll need to inform the app of four new classes that we will be using. The first is a declaration of GCM receiver which handles downstream messages sent via GCM to your app. Because the service wants to receive messages only from the GCM framework, add the send permission for Google Cloud Messaging to the receiver. Note that we aren't requesting a permission here but requiring one instead. Requiring this permission means that anything trying to send a message to this receiver must provide the send permission which ultimately protects our receiver from bugging and senders. If you want to support pre 4.4 KitKat devices, you'll need to add an additional action not just for receiving but now also for registration to the intent filter declaration for this receiver. But once you have all of this, you're good to go on this declaration. Then we have a declaration of a GcmListenerService which enable various aspects of handling messages such as detecting different downstream message types, determining upstream send status, and automatically displaying simple notifications on the app's behalf. And that is our second class down. Finally, we have to create a service that extends InstanceIDListenerService to handle the creation, rotation and updating of registration tokens. So this is a big one. These are all of the required classes that we need. However, I am also going to have you add one more declaration for a helper service, which we will discuss later. To review, we need four permissions, and four class declarations. Internet is already in the manifest. So, add the permissions for wakelock, receive, and message. Then, declare our for new classes, the GcmReceiver, the GcmListener, an InstanceID listener, and a registration intense service to help. To see what these changes should be, again, check out the GitHub commit linked in the instructor notes. You'll need to implement them in your app now. And once your manifest is ready, click here to move on. An Android application needs to register with GCM servers before it can receive messages. To help us with this, we are adding two new services. The first is MyInstanceIDListenerService which extends from GCM's InstanceIDListenerService. This service is what checks the validity of a registration token and requests a new one if a token is not present or is expired. Google Play services will automatically start the service and invoke on token refresh when it detects that a new token is needed. To get a new token, we have a registration intent service which will communicate with the GCM servers off of the main thread. Keeping the registration work in its own service instead of the InstanceIDListenerService means that it can be invoked only when needed, which may not always overlap with a token refresh such as the initial registration when the app starts. It also makes for cleaner code so that you can easily track buys and make future changes. But you could also have done all of this work in one service if you prefer, which is why I mentioned that this was our fourth class when we were talking about the Android Manifest. To perform the registration, we use the InstanceID class to call getToken. This class needs a SenderID which is pulled from our google-services.json config file. Then it also needs a scope for the permissions that will be granted by the token and any parameters required by that scope. In our case, there are none. Once we have our token, we store our Boolean in sharedPreferences to let us know we've got it. Normally, you would also want to send the token to your server. The server needs the token in order to send the message to this specific device in the future. However, because we don't have a server, you should log the token so that you can use it later in our website. But generally, a token should be kept secret and not just logged willy-nilly. All of this takes place in the background so as not to block the main thread. And since our GCM feature isn't a core piece of the app, we don't need to worry about letting a user know when they are registered. But if your feature is necessary to your app's behaviour, you may also want to let the users know their registration status somewhere in your UI. Finally, we'll need to modify our Google Play services check in on create inside of main activity to see if our app is already registered. We can do this by checking the boolean that we stored with the default value of false. This means that if we cannot find the boolean, assume we have not registered and if we haven't already, we will register the app by invoking our new registration service. If an app is not registered or if Google Play services is non available, this device will simply not receive any messages. This is convenient, because it also means we do not need to hide layouts, or features, as may be the case in your app. To review, you need to create new classes, the InstanceIDListener and the RegistrationIntentService. And then you need to do the initial registration in onCreate of MainActivity, if the app has not already been registered. To see the code we walked through, check out the GitHub commit linked in the instructor notes. You'll need to implement these changes in your app now. Once you're finished click here. To receive simple downstream messages, use a service that extends GCM listener service to handle messages captured by the GCM receiver. GCM receiver extends wakeful broadcast receiver. Guaranteeing that the CPU is awake so that your listener service can complete its task. Recall that this is why the way clock permission was not optional for us. We need it in order to use this receiver. By overwriting the method on message received, you can perform actions based on the received message. In our case, we want to trigger a system notification. So let's look at on message received where we'll need to process our message. There are many different types of messages so just look for the one you want in your app and ignore any others. In this case, we want a message from our SenderId, that means that we will know how to properly parse it. Parsing the message is going to be determined by you not by GCM.. The way that your server constructs its requested Google service is how it will be passed along. In this case, I used to JSON object to my fake server in order to send data with both a weather value and a location value. You can build up complex messages or use only simple ones, but just make sure that if you change something in your server, you update your logic in your app. Otherwise you might start to notice a bunch of null values and your app could go all wonky. Finally, we'll pass our alert message along to a helper function that builds out a notification. You recall how to build notifications. The things you want to note here are the content intent which directs back to main activity and the priority. Because this is an alert and potentially important for users, I'm going to increase the priority to one. Priorities can range from negative two to two and I want this one to be noticeable but not spammy. Choose priorities with care so that your users have a good experience and not so that you are always on top. Also, note how we build up the notification image. We set both the small icon and the large icon so that we can use a storm image to make the alert more on point, but also the sunshine sun image so that users can understand where the app came from. It is considered a best practice to use your app icon as the small icon and something relevant as the large icon. Also, note that large icons must be passed as bitmaps and not as a resource reference. So be sure you're constructing a bitmap. Then, just fire the notification off and our GCM implementation is done. Congrats, you. To review, you need to create the GcmListenerService and implement two methods, onMessageReceived() and sendNotification(). There's also a string that needs to be added to strings of .xml. All of these pieces as well as the expected message structure can be determined from the code in the GitHub comment link to the instructor notes. You'll need to implement these in your app now. And once you're finished click here. Now let's see if this works. Instead of building a server I've created a simple web page we can use to send the post request. You'll just need two things I mentioned along the way. Your server API key which you generated in the API console, this is your authorization key and it is how Google servers know that you are who you claim to be, and that it is okay to send a message to your app. And to the registration ID or token that you logged in registration intend service. Now, copy both of these values into the web page linked below, click Send, and see the magic. If you followed all instructions correctly you should receive a weather alert on your device at this point. Copy that alert message here to let us know you've succeeded. OK great! You're basically best friends with Google Cloud messaging now. Well done. So, to review everybody, we have a server that wants to communicate with a device. Now, you already know how to create an Android app. You're learning that now, obviously. And, we just covered downstream messaging, where the server sends messages to the device, so we're good there. But you probably want to look in to how to build a server at some point, because I didn't teach you that. You also might be wondering about when the device wants to send a message to the server. Although I didn't cover it, Google Cloud Messaging does support this and you can learn more from the documentation. So check out the links and the instruction notes everybody and good work. [SOUND] Golly. [SOUND] [SOUND] Oh, my goodness, Magnus, I'm so sorry. Hey, Joanna. Yeah. I heard you used GSM to build the better apps with Sunshine. Yeah. How did you hear that? There's lot's of more Google services. There's location, adds, maps, analytics, you name it. Yeah, we're building a udacity course with them all. Oh, wow. Perhaps you can help me promote it. I would love to help you. Oh, that is so Googly, thank you so much. Of course. Hah, hey you. Yes. Perhaps not to use the bike. Oh, yeah. [SOUND] Hey Dan, what's up? Just getting ready to fix a bunch of issues. I know you had some feedback from Sunshine, when you first looked at it. Yeah, I had an issue where I didn't have an internet connection, and I didn't know why I was always getting a blank screen. Okay, good. Well, not good. But it's on my list to fix. I'm on it. Thanks Dan. [SOUND] Sunshine was a relatively complex app in terms of integration points because a successful outcome relied on both user and server input. We did a great job dealing with certain aspects of that wide range. The first thing we did was using a SyncAdapter to load data from the server in the background, we never see partially loaded data because of this choice. It keeps our data relatively efficient, and it makes efficient use of battery. Even if we have not opened the app in a while, the data is being updated behind the scenes. The second thing we did well was caching our data locally. This is why being offline is only critical when first starting the application or changing the location. Caching keeps our data still accessible when the user's not connected to the Internet. Without this, our weather app would display a blank screen any time your device went through a patch without service. And that, would be terrible. Our first integration point is the user input, Sunshine uses this to determine the location we should get weather data for. Our second integration point is when Sunshine communicates with the weather server. The sync adaptor that performs this action stores the response in the database as a cache, notifying Sunshine when new data is ready. The result of either invalid input by the user or lack of connectivity to the weather servers results in an empty database, and that means an empty list. Since an empty list is hardly user friendly, let's handle that first. In order to assist our users, we should give them helpful information when the database is empty, and the screen would otherwise display nothing. We'll take advantage of the built in capacity for list view to display an alternate view when the list is empty, so our user doesn't see an empty screen. This functionality is actually part of the adapter view parent class. Typically, you place the list view into a frame layout that contains the list view and an Empty View, and then you call the set Empty View method on your list view. For now, add a No Weather Information Available message to your application when there is no data by using the set empty view function on your list view. All right, you're done. Let's take a look at my solution. We start by adding a string that we're going to display when the list is empty. For now, we're just going to make this a generic string, just to inform the user that we don't have weather data. Next, we'll create a layout to be displayed when the list is empty. The TextView can just be added to the FrameLayout that is currently in the main fragment layout. Since we will either be displaying it, or the list content. For consistency, we specify the padding using the dimensions we've already defined in Sunshine. Finally, we need to tell the list view that we have a layout for it to display when it is empty. We'll add it inside of onCreateView right before we set the adapter, and that's it. We've made our app slightly more friendly, but we can do more. Let's test this to make sure everything's working well. We'll do this by uninstalling Sunshine, putting the emulator in airplane mode, and then launching. So let's go to our emulator now. We'll test this by first uninstalling Sunshine. Then we'll put the emulator in airplane mode. Now we'll launch the app, and as you can see, we've an empty list. Now when we leave airplane mode our sync adaptor will run, and bam, we get our list content again. Getting out of schedule the way network becomes available is one reason sync adaptors are awesome. Our new empty list is better, but it's not telling the user any good information about why they aren't getting weather data. There's something easy for us to check. Let's look at improving the integration point between the sync adapter in our application and the server. This integration point can go wrong in one of two common ways. And, it's vital to make sure that we're dealing with both. The first case is when the user gives us bad input, either an empty response or a non-JSON response. This can happen when there is an error on the server side, or when the user is behind a captive web portal. The other case, which we'll be tackling first, is when we cannot connect to the network at all. This will result in outdated data and a bad user experience. And it's part of the reason our onboarding case goes so poorly. In oder to address this, we'll do two things. An onLoadFinished in the forecast fragment, if we see that we have an empty cursor, we will write a check to see if the device is connected to the internet. If the device is not connected to the internet, we will alter the message displayed in the empty list to reflect the lack of connectivity. Because Android uses a permission system to allow apps access to certain parts of the devices functionality, we'll need to have a specific permission, ACCESS_NETWORK_STATE in our Android manifest in order to check whether the device is connected to the internet. This is a separate permission from the internet permission we already have in our app. We use the connectivity manager to check for this state. I recommend creating a function in the utility class that can do this for us. We're going to update the empty view for no connectivity. First, we're going to add the ACCESS_NETWORK_STATE permission. Then, you're going to want to add an empty view the sibling to the list view. In onLoadFinished in the forecast fragment, as we just went over, check for an empty cursor. If the cursor is empty, check for the network state using the Connectivity Manager. If the network state is not connected, update the empty view message. Once again, we can test this by uninstalling the app, putting the device into airplane mode, and running the app. All right, you're done. Let's take a look at my solution. First, we add the permission for ACCESS_NETWORK_STATE to the manifest. Then we add a no_network string to the strings .xml file. As I suggested, in the utility class we add an isNetworkAvailable function. That uses that connectivity service to return the active network information. Then, I added a function to handle updating the empty view, which we'll call from on load finish. Finally, we call this function from on load finished. Let's test it. Remember how we do this. We go to our emulator. We uninstall the app. Then we set the emulator into airplane mode. At this point, let's launch and run the app. And now we get a far better message. No weather information available, the network is not available to fetch weather data. Once again, if we switch off of airplane mode, it'll automatically go and run our sync adapter. We've improved the initial experience feedback in the case of poor connectivity, but what happens if the weather server goes down or if from behind a captive portal? In that case, we could get either no data or some form of corrupted data and the user still will have no idea what is happening. Let's start by enumerating the states, we want to communicate with the user about. While Java supports enumerated types, they're somewhat expensive and inefficient by comparison to using static final integer constants. So at Android, we recommend avoiding them. That being said, it would be nice to have some type safety and that's where the annotations we've added to the Android Support Library can help. Well, first of all, what are annotations? In Java, annotations are specified beginning with an @ sign, such as the commonly used @override here. They contain information or metadata that gets associated with the code in our app, but do not directly change the functionality of the code. They may be used by development tools and depending on the way they are retained, may be read at runtime. To use the support annotations, we just go to Android Studio to the Project Structure dialog and add the support annotations dependency. Since the integer we are storing for our state can only have a few predefined values, it would be nice for our tools to be able to help us. Cache assigning unsupported value to our state, an auto complete the typing of variables of this type. The support annotations and library provides functionality that does just that using the IntDef annotation. Here's how this works. When we define our integer constants, we also create an interface annotation. As in this example from inside the app from PAD Library, we then annotate this new annotation with IntDef, containing the different integer constants that are supported. The retention policy of source tells the tool chain that we do not need to preserve this annotation in the class or at runtime. Making the annotation not have an impact on our runtime or distribution sides. The IDE will now flag cases where we try to return a value not in this set from getNavigationMode or pass an integer not from this set into this set, @NavigationModeMethod. So what location states do we need to think about? The first stage is that everything is okay. The second stage is that our server is down. The third stage is that our server is malfunctioning. The fourth stage is that we don't know if the server is up or down, because we haven't tried to contact it yet. We'll continue to add states here, as we work to make our app production ready. All right. You're done. Let's take a look at my solution. First of all, you all added the support annotations dependency, right? Then we just created the constants, added the location status interface and annotated that interface with the IntDef containing the constants. Finally, we said retain it only for our source code. Now that we've enumerated our first four states, let's use them for something. One of the challenges with sync adapters is that they don't return status to us when they complete. So we have to use another mechanism to do that. Since these states occur before we have a valid location. There's no proper way to store this information in our existing database, which requires all of the location fields to be filled out. The method we're going to use is to have the sync adapters store the current location status in a shared preference. This has some nice advantages. Namely, it persists after closing the application. And we can register a listener to be notified when the preference changes. Okay. time for another task. We're going to create a new shared preference to store the status of our location, which also means creating a new string and the resources to name the preference. Now I tested this by changing the forecast base URL to a few servers that produce the desired results. See the instructor notes for details. You can use breakpoints or logging to make sure your code is called. We'll be connecting it to the UI soon enough. We start by adding a string for our SharedPreference. In the Sunshine sync adapter, we add a function to set the location's status. Since setLocationStatus will be used on a background thread, I use commit. One would use apply if it were on a foreground thread. In onPerformSync, if the server returns an empty string, or I get an IOException. I set the status of server down. I set the status of server invalid if there is an exception parsing the Json. We also set LOCATION_STATUS_OK at the end of a successful sync. Let's put some breakpoints in to check to see if these are actually getting set correctly. For a URL that I know is going to produce an error not expected by our app, I'm going to use this one. Let's debug it and see what happens. As before, I've uninstalled the app first. And as you can see, we nicely get a location status of, server invalid. Which of course leads us to no weather information available. Which is what we do in the case of not knowing why something has happened as of yet. We'll fix this later. Let's try a URL that we expect to be empty. Once again, I'll uninstall the app first. Now let's debug it and see what happens. As you can see, we now get SERVER_DOWN rather than INVALID, as expected. This will help us a lot when we move to the next part of our implementation. Let's set everything back to normal to make sure we didn't break anything, and there we are. Everything's working just as we would expect. So, hopefully we now are setting all sorts of error states, but we aren't using them to help display anything to the user yet. Let's change that. First, we need to add a new utility method to get the current location status, and next, we'll update the function that changes the string displayed in the empty view to use both the location status and the network state, instead of the call we have now, that only looked at network status. As I mentioned before, one of the great advantages of using a shared preference to store the status of the location, is that we can listen for changes to shared preferences. We'll have forecast fragment implement an onSharedPreferenceChangeListener. We'll register this listener with default SharedPreferences in onResume, and unregister it in onPause. When the location status changes, our onSharedPreferenceChangeListener will get called, and we can update the string displayed in the empty view. Let's try updating the empty view in the location status changes. First, we'll add a function to utility to get the location status, and then we'll have forecast fragment implement on shared preference change listener. Registering and Deregister it in onResume and onPause. Finally, we'll make the empty view function update based upon the location status and the network state. I've given you two strings that you can use in the instructor notes. The string for the invalid server error case, recommends if user check for updates of Sunshine. This is designed to handle the case with a server, is outdated in a way that is no longer compatible with our app. All right. You're done. Let's take a look at my solution. First, we add a function to utility.java to get the location status. Note that we need to suppress warnings for our end def because we are reading integers your out of shared preferences. Which could be out of the range of our location status. Then we add the new strings we need. Now we can make update empty view, update the view based upon both the location state and the network state. And of course, we only update the empty view of the forecast adaptor is empty. Next, we'll have our forecast fragment implement our on shared preference change listener. We need to register that listener and on resume, and unregistered and on pause. And our listener will now call update empty view. Done. Let's get to handling our second integration point, between the application and the user. In particular, we allow for free form text entry of the location. That means there are multiple ways the user can get something wrong. The user can input text that doesn't actually resolve to a location or the user can input text that resolves to a different location than they are expecting. We're going to look at handling the first problem, the user inputting text that doesn't resolve to a location. The second problem is a bit trickier. Many users use ZIP codes to set their location, because we use that, by default, in our application. One of the fascinating parts about the world's postal system is the fact that postal codes tend to be unique within each country, rather than truly unique. As a result, sometimes a postal code in which was intended for location in the United States will return information for a location outside the United States, even if the postal code is properly written. In addition, there are often cities around the world that share the same name. Unless the user types in the entire name, including state, province, and country, we may get this wrong as well. Note that we currently have a function that maps the location. So, a determined user can find out where their weather search is geolocated. All right. How do Android apps make it easier to enter settings or queries in free-form text fields? Take a look at your favorite Android applications to see what they do. The common pattern is to support the ability to autocomplete what you were typing, hopefully taking what we know about your context into account to give a better result. It's not recommended that one do that against our weather server since they want to limit queries to no more than one every ten minutes per device. Look at using a Google Play service to do this later on in the course. Currently, the user has no way of knowing they've entered a location that our server can not handle. In fact, our source code is also blissfully unaware of this case. We'll fix that. We'll have to add a new location status. Location status invalid. But how do we know that that location is unknown to the server? It turns out that with each transaction, the Open Weather Map API returns a code in JSON similar to HTTP codes. For success it returns 200, if the location isn't found it returns a 404 error, location not found. So if we see a 404 error we know that the user has entered something that the server doesn't understand. Great, we can modify the code and get weather data from JSON to understand this code. Then we can set the location status to the invalid state, when this response is detected. All right, detect the state where the user has entered an invalid location. First, add a utility function to reset the current location status to UNKNOWN. Then call the reset functions in settings when we change the location. Add an INVALID location status, then detect the 404 error in getweatherDataFromJson and set the INVALID status. Create a new string to display in the empty list view. And add the INVALID location status to the updateEmptyView function in ForecastFragment. Lots of steps, but everything here should be pretty straightforward. Take a look at the instructor notes if you have any questions. All right, you're done. Let's take a look at my solution. First, we add a function to utility to reset the location status to unknown. Note that we use the shared preferences editor apply function rather than commit, since this will be called from the UI thread. Next, we call that function to reset the location status if the user changes the location within settings activity. Next, we add the location status invalid. Remember, we have to add the constant and then add it to the indef annotation. Next, in get weather data from Json, we add the message code Json definition. Now let's check to see if we have an error. If the message code is 200, which happens to be the same as HTTP_OK, we can continue. But if the message code equals HTTP not found, then we set the location status to invalid. If it is any other error, we assume a server failure of some kind and set the status to server down. And then we add a string to display, when this case happens. Finally, we add this new case to update empty view. Done. Let's test this. All right, let's first of all run this on our emulator. All right, let's put an invalid location. London. And then we get our new message. No weather information available. The location in settings is not recognized by the weather server. Awesome. So, we have a good set of user feedback in the empty list case. But it would be nice to have this also reflected in the settings part of the app. Since the material design specifications specifically says if the summary for the preference can be used the preference status, we're going to add some status here about the location. We'll show the status of the preference, followed by the value of the preference in parentheses. Just like in the forecast fragment. We can take advantage of an OnSharedPreferenceChangeListener to update the settings UI as the sync adapter changes the state. Add preference status to the summary of the location preference in SettingsActivity. First of all, add strings for the different statuses. Secondly, add code to onPreferenceChange to show the status. To make it a bit easier, I've included the strings I used in the instructor notes. Note that I only handle the invalid location, and the validating location statuses, because any other state should be transient. All right, you're done! Let's take a look at my solution. First, we had the strings for the two states that we're going to support extra information for. We have our SettingsActivity implement SharedPreferences.OnSharedPreferenceCha- ngeListener, which, of course, we register in onResume, and unregister in onPause. In setPreferenceSummary We then add code to set the preference summary based upon the location status. All right, let's try this out. So, now, you can see we get invalid location, Londan. Now, of course, we can change this to something else. We can take this a bit farther. Right now the location preference allows us to enter a string of arbitrary size. We'd like to make it so that the preference is at least three characters before accepting input. The default preference doesn't allow us to do that. We're going to create a custom preference view. A custom preference view is similar in construction to any other custom view in Android. So, consider this an introduction to creating custom views. A custom preference view can both change the way the preference is presented in the list, what happens when it is clicked, and in this case, the way the alert dialog behaves that is used to back the edit text preference. We're going to give our custom view a custom attribute for the minimum length of the location. Mostly because custom attributes are cool. So let's start there. We'll create a new values file called attrs.xml. We build custom attributes using the declare-styleable tag. Each attribute in declare-styleable has a name and a format. The next thing to do is to create our custom edit text preference by creating a new class that extends edit text preference. And that new class will create a constructor that uses a context and an attribute set. That attribute set is what we use to read the value of our custom attribute. We call context.gettheme.obtainStyledAttributes passing in this value. Create LocationEditTextPreference, which will use a custom attribute to set the minLength of the location field. Create our custom attribute using declare-styleable. Create a new class that extends EditTextPreference. Read the minimum length from the styled attribute during onCreate, and log this value for testing. Change pref-general.xml to refer to this new class instead of EditTextPreference, adding the custom minLength attribute. See the release notes for information that will help you with this task. All right. You're done. Let's take a look at my solution. First, we create the attr's .XML file. Then we add the declare styleable tag, with the name Location Edit Text Preference. We create an attribute inside of that, named minLength, that takes an integer value. Next, we created our LocationEditTextPreference class that extends EditTextPreference. To really make sure things are working correctly when we read our styled attribute, we'll set the default minimum length to 2. We'll then call the obtained styled attributes function from the current theme, asking for our LocationEditTextPreference style. We can then get the integer value of our attribute, passing in our default value. Then, we need to edit our preferences.xml file. At the top of the file, we need to add the name space of our custom attributes. Then, we replaced our edit text preference with com.example.android.sunshine.app.Locati- onEditTextPreference, and set our custom attribute from min link to the value we want, namely 3. Finally, we need to test this. Let's make sure our minLength is being set appropriately. And now we'll launch the application. As you can see, minLength is set to 3, being correctly read out of our custom attribute. But we're not using it yet. Now we need to change the behavior of our edit text preference appropriately. What we'd like to do is disable the okay, or positive button, until the user's typed enough text. The first part of this is easy. We'll override the show dialogue method which is called the show the dialogue. After the superclass is called, the dialog should be present, so we can safely fetch the edit text view by calling get EditText. We'll use a special callback of EditText called an EditTextListener. We'll add an EditTextListener which will get called when the user changes the text. We'll only utilize the after text change callback. Now there is a tricky part. We'd like to get the alert dialog that is used by our edit text preference. But, there's no supported way to get at it. We know it has to be there, because the dialogue preference provides an alert dialogue builder to customize the dialogue. Let's take a quick look at the Androids source that implements dialogue preference. First of all, let's grab a Chrome extension. This extension not only makes it easy to search the Android SDK, but it also adds an Android View Source link to developer.android.com. So now we can just type AD to search for edit text preference. And when we see DialogPreference we also get a link to its source. As you can see, there's an internal member called Mdialog. This is what is returned in Get Dialog. But where is it created? As we can see, it's created for our builder as we expected. So at least in current versions of Android. We can expect this to be an alert dialog. Great. But just in case this changes in the future, we'll protect the code. We'll use the instance of operator to verify that the dialog return using Get Dialog is an alert dialog as expected. If so, we can call dialog.get button AlertDialog.button_positive to get the button we need to enable and disable. All right. Use a text changed listener to disable and enable the positive button the associated AlertDialog as the user enters text. First, override showDialog, and get the editText after the superclass is called. Add an EditTextChangedListener to the editText. In this listener, implement hiding and showing of the positive dialog button after the text changes. See the release notes for information on how to get the alert dialogue from the editText preference. Inside of LocationEditTextPreference, override showDialog, getting the EditText after we call the super class. Add an EditTextChangedListener to the EditText. In the afterTextChanged method, we get the alert dialog. If the length of the string is less than the minimum length, we disable the positiveButton, otherwise we enable it. We've covered a few new topics in Android such as making custom preferences with custom attributes, using support library annotations, and using shared preference listeners. Most importantly we've now covered the primary air estates for the interaction points for our app. It's important to take a moment here to remember what we've done and to talk about how to generalize this process to work on whatever app you may be refining. First, we identified what interaction points existed in our app, each of which is a place where errors and bugs can creep in. Then we looked at what we already done well at each of these points and what air cases we had not covered already. This gives us a list of issues to cover to avoid bugs in our app. In a real app, we would also want to take user feedback into account when coming up with a list of changes to spend resources on. Finally, we went through each of the issues and designed a solution to the problem at hand. Some of these solutions were simple and straight forward. Some of them were more complex and required prioritization but by covering these issues, we've made our app far more comprehensible when errors inevitably occur. [SOUND] Hey. Wahoo. I'm done. Good job. You're awesome. So, about that lab coat? Yeah. Not yet. Let me get Ian and see what he's found after looking over sunshine. [SOUND] Dan! Thanks for coming! Yeah, I heard you wanted to talk about Sunshine, great app isn't it? Yeah, it's a great learning exercise, and with a little more polish it could be a great prototype. Prototype? I thought we were done with Sunshine. Wasn't that what the great party was all about? Well, you're half right. It was a great party. Look, Sunshine does function, but we've got a long way to go before it's production ready. Remember, it's that last 10% of polishing those unique features that make all the difference to real users. Get it ready for real users, and then you'll be ready for your own lab coat. Maybe. Well, sure, I had a couple things in mind that we didn't get to. Great. I thought you'd have some ideas. And I've brought in some extra help for you to get it done. You need to go talk to the fix-it team. So I guess I should be leaving now? Here's to more Sunshine. [MUSIC] So, I've got this app, and it's not production quality, and students are watching, and I need your help. Sure, we can take a look. [SOUND] Yeah. Mm. Oh my. Mm. Mm, well, this is certainly functional and we can work with you to help you make it production ready. Awesome, what do we need to do to get started? I think it would be good to hear from you on exactly where Sunshine is now. No time like the present. Let's go. Hi. I'm Ian. And I'm Johanna. Welcome to our fix it workshop. We're here to help Ben get Sunshine Production ready. Shall we? Yes, let's. Dan, you're up. I'm Dan. You should remember me for the last class, Developing Android Apps, Android Fundamentals. I'll be talking about larger design issues using Raytoe's underground bunker. Sunshine is a weather app, focusing on the current and upcoming weather for a selected location. Given that focus, it is no wonder that our main user interface is the weather for the next seven days. Tapping on a day brings us to the details page, which goes more into depth on the forecast for that day. On larger devices, such as tablets, we used a master detail view, so you could see the forecast and the detail side by side. In both cases, we also provide a settings screen where users can change the location they want weather for, and switch between imperial and metric units. Even when the user didn't specifically open the app, we use notifications to bring the latest weather information to them. All this was made possible by the key components, such as the content provider and sync adapter for stable and battery efficient data loading and retrieval. Now that we have a better idea of what makes up Sunshine, let's talk about the ideal state where a production-quality Android app should be. While it's easy to immediately dive into the minutiae, let's take a step back and look at the big picture. What are the goals of an amazing Android app? It actually starts with create a vision for all of Android. Create a vision for Android. And all Android apps have three main pillars. Enchant Me, Simplify My Life, and Make Me Amazing. Enchant Me revolves around the idea that your app should both look and act effortlessly, through well-placed animations and a feeling that the app was designed specifically for the user. Simplify My Life involves making the app easy to understand. Whether it's for a new user just trying to figure out what exactly your app does, or a returning user, where you're trying to make the experience as frictionless as possible. Make Me Amazing is about leveraging the strengths of Android to build apps that contribute to building a whole greater than the sum of its parts. Integrating into one another, and extending beyond a single entry point app, you need to remember to launch to get any benefit. Many of these concepts shouldn't be foreign to you. Making a great experience for users should always be in the forefront of your thoughts. Let's take a look at Sunshine to see exactly where we are with each of these. All right, let's see what we're dealing with. Now, I love the blue and the minimalist approach. Points for guessing my favorite color, but I feel like it could do a bit more. There aren't really any animations or magic moments or anything. Oh, but there's this notification. That'll be handy and really helps add to the experience. Although, I'd love to see a widget or something else to allow me to set up a permanent weather display that fits with my device. But this doesn't look like what the weather outside looks like. I wonder how to change that. Of course, it would be nice if I didn't need to do this manually. Remember that the initial experience is often the turning point between someone uninstalling an app and using it every day. Now let's see what the tablet version looks like. Mm-mm. There's nothing here. What's going on? Oh, I'm not on Wi-Fi. Sure would have been nice to know I needed an internet connection and not that the app was broken. Okay. Much better. And I like the landscape layout, with the weather details right next to the list. Really great use of the extra space here. Oh lord. Looks like there's a few edge cases they overlooked. It means, Wednesday comes around every week, after all. It really is important to keep in mind the huge variety of Android devices when designing your app. Well, I'll need to come up with a plan of attack. I'll check with Ian, and between the two of us, I'll bet we can settle on the core of what needs to improve. But I challenge you to take a look at Sunshine, and make a short list of what you think should be done before launching the app. Discuss your ideas in the student forum and take note of where your list intersects with ours as you move through the course. We've talked about potential places where your app can really shine and where it can really fail. Being on the development team of an app can lead to a certain type of blindness. You know the app so well that you naturally miss some of the pain points a new user might run into. This is where bringing in external feedback can be extremely helpful. As soon as you publish your app, or even beforehand, when showing it to testers, you get a flood of advice. This feedback can be a great source of new perspectives and give you insight into exactly how people are using your app, or even better, how they want to use your app. Having a large, diverse set of users can be one of the keys to building a successful app. Remember, that while feedback from others who have built Android apps can be helpful, it shouldn't be your only source of feedback. So, how does Google give feedback for new Google apps? Even before internal testing among employees, or dogfooding, each app goes to the Google User Experience review process. The goal of this process is to get the app in front of experienced Googlers to focus on various parts of the user experience, such as design, interaction patterns, accessibility, and more. As we looked into productionizing Sunshine, we wanted to get some expert help with the UI that would both leverage a broader set of implementations skills than we were able to present in the first course. And begin to illustrate a material design concepts. Of course we turned to Android UX legend Roman Nurik who has helped many Android developers improve the UX of their applications with direct feedback. Develop design tools to make constructing Android UX easier. And who has contributed DashClock and Muzei to the Android world. [SOUND] Roman, it's so great to have you here with us. Now, when you first looked at Sunshine from Android Fundamentals, what are the things that you felt worked really well in the design? So, let me take out my phone and just point them out. So, I think that the first thing that was done really well was just the use of hierarchy, or the overall hierarchy of the screen. Yeah you have your branding on top and then you have the most important piece of information, the current conditions and weather, at the top as well in this kind of nice, big display type. And then below that you have the secondary information, the forecast for tomorrow and the next day and so on. That was one. I think another that was done really well is the use of keylines. So keylines are essentially these invisible vertical rules that you can use to align streams of information. And it felt like specifically the use of that second keyline, the one where you have the brand name, the current temperature, the dates of the kind of later forecast, those are kind of left aligned to that second keyline. And I feel like that is really nice in helping visually process the information very, very quickly. So I feel like those are probably two of my favorite aspects of the existing design. Tell us a bit about what you designed in the new production version of Sunshine, and why. Well, I think I'll just talk about one, I think that there's one that's really important here, and it's an essential part of material design, and that's the use of surfaces. So the first is I felt that, well, with surfaces, I guess, in the existing app, you kind of, I guess the use of surfaces was all over the place. On portrait phone screens, on landscape tablet screens, it wasn't really consistent. It felt like information was being presented in different ways. And what's worse, on landscape tablets, you actually had this kind of massive sea of white space. And the information was kind of floating on top of that. And it felt like the use of surfaces can really help both manage that white space, and introduce consistency. And so in the new design, we use this single elevated white card to present the current conditions of, I guess the current temperature, right? And we use that consistently across phones and tablets. And so, that does three things. The first is that, again, it introduces consistency across screens. The second is it that actually makes it easier to do motion to, another big part of shell design is motion. It helps you do things like transition from list to detail. When you can kind of have a single object that appears in both and transition them, it's really nice and easy. And I guess the third is it really kind of helps you manage space. On that landscape tablet screen, the fact that you can have this kind of nice big card to present one major stream of information. And kind of have everything else fall, I guess, from outside of that. It makes a nice use of space, I guess. I mean just very bluntly, it's a really nice use of that massive screen real estate. And so it does those three things really well I think. And that's one of the things that we really focus on in this redesign for Sunshine. [SOUND] Wow, tons of great feedback. Like we expected, we have a really good start. But there are some rough edges to work through before we have a production ready user experience. So, how does that constructive feedback map to our production quality goals? Well, the design feedback we got around consistency, white space, and motion fall under [INAUDIBLE]. Those little details can really make Sunshine stand out. When you combine that with the suggestions Team FixIT has made, such as under Simplify My Life, having Sunshine display useful information, even when there's no network connectivity or poor user input. And under Make Me Amazing, having Sunshine open up new, extremely useful ways of getting weather information front and center. We had some pretty good ideas about how to start getting us closer to the production of Sunshine. Both user feedback and the UX review are examples of user research. A whole set of techniques used to understand what users are experiencing, and how we can use that information to help build the best app possible. In general, we can split user research into two styles, quantitative and qualitative. Quantitative user research produces data in the form of numbers. How many users signed in, or how long people spend in your app? In many cases, this data's captured indirectly via analytics tools that can aggregate data automatically across all your users. Qualitative research, on the hand, can't be reduced to a simple number. Instead, the data produced here is often via direct communication between users and the development team. In many cases, qualitative research takes the form of interviews that are either undirected, in the form of our UX Review, or directed with specific tasks or goals for the user to accomplish. For that reason, qualitative research tends to be better at answering why questions, such as why do users disable notifications or why do they like one interface over another. We've just touched on only a few of the things that make up the field of user research. There's a ton more out there which can help get your app production ready. For now, let's focus on Sunshine. So we've looked at Sunshine, and we've looked at the creative vision for Android as our ideal state. The early feedback we've gathered so far shows a few gaps. That's why we're here, to make Sunshine truly production ready and the, best app it can be. So how do we get there? It'll take some polish on the functionality we already have, as well as a few stand out features to really take Sunshine to the next level. Let's find the others and get started. So, the real issue, I think, is on Nexus 7, we didn't have enough width and that's-- Can you just hold this for a second? Thanks. Hey guys, talking about Sunshine? Yeah, we're brainstorming all the things we need to cover and what we need to do and it seems there's kind of a lot, so I was thinking we would each do one improvement per lesson. All right. So, where do we begin? Well, you were assigned all those arrow cases, right? So I think you should start with those. Yeah, a solid base is always a great idea. Right. Solid base, then improve from there. I like it. And I'll keep you apprised on my progress? We are just so excited to see what you do. So we've made a lot of progress on Sunshine. Yeah, I'm feeling a lot better about it. Right, but you have to admit it's pretty boring. Oh come on, like you haven't noticed that there's no way to personalize it. You know if it was my app there'd be some sort of Cheyenne, right? So I was just wondering, do you have any ideas? Actually yeah, I think there's a lot we can do on the personalization side. I'm not sure about Cheyenne though. Oh, come on. Obviously everybody needs a little Cheyenne. Yeah, I'll take your word on that. She is cute though. Remember when we talked about the creative vision for Android? One of the pillars was enchant me, that feeling that the app was made just for you. Joanna makes a good point. Right now, Sunshine is pretty basic in this regard. Setting your location isn't exactly customizing it just for you. It's just basic functionality. So what can we do? Ideally we'd want something visual, that impacts the whole application. In fact, our weather icons, which are used throughout the app, are perfect for this. What better way to customize than allow users to change the very way they see the weather. So let's add the ability to change icon packs. We'll keep our APK size small by downloading the images from the Internet using our current included icons only as a fallback. Oh, we actually haven't talked about downloading or displaying images from the Internet at all. Well, let's start there. So what actually goes into getting images from the Internet onto the screen in your app? Well, there's a networking part to actually download the images, can't do that on the main thread so we'll have to use a background thread. You probably want to cache the images locally to prevent unnecessary repeated downloading. Oh, and down sampling and decoding. It doesn't make sense to load giant images, just to display tiny icons. Well and we have icons on our list, so probably want some behavior to ensure that we can still scroll our list nice and smoothly. A whole bunch of images are loaded or cancel requests for images that are no longer visible due to life cycle changes such as our activity being paused. Then it add the image to the screen at least we have image view there. Oh, and we have our notification as well. There we probably do need to get the whole image as we build the notification so maybe a synchronous API for this case. Anyone else thinking this is a bit complicated? You can't just cut out any of these steps if we want to go to experience. But none of the logic here is unique to sunshine, right? Plenty of other ops have gone through the same flow and tackle these same steps. When you see these types of reusable pieces of code it's a great time to consider using a library. So libraries, what exactly do we mean by a library? I love books but that's not the kind of library we're talking about. Instead, a library is a packaged collection of reusable code which you include in your app rather than starting from scratch. We've already used a few libraries with Sunshine. We used AppCompat in Android Fundamentals One to build a consistent look and feel across all API levels. And the Support Library Annotations, just recently, to add a little bit more type safety to our code. We certainly could have done all that ourselves, or skipped it entirely, but libraries can often help you achieve the best user experience without you writing and maintaining a ton of extra code. Even better, Popular libraries often have a strong community following and a large number of people who can help you answer your questions. Not usually the case with your own code. Well, I'm sold. Libraries are great. There are certainly some downsides to be aware of. By definition, a library is reusable and generic. If it custom built for you app, it would be easier to call it your code. That means that libraries may include more than what you need and bloat what could be a lean app, or maybe not even cover the cases you need. And of course, libraries are built by developers and that means there may be bugs, architectures that don't work well with your existing app, or trade-offs such as quality versus memory consumption that you might not be able to control. In addition, not every library ages gracefully. They may not be taking advantages of the newest API's, hampering your ability to build the best user experience. Or they may have been abandoned entirely, leaving you stranded when faced with an issue or a bug. Goes to show picking the right library might be the most important step. So, how do you go about choosing a library? There's a few things to look at. Central to everything is functionality. So, the first step is to figure out what the library actually gives you. If the source code is available, that would be the ultimate source of truth, but it's probably not the best place to start. Instead, consider looking for an overview Readme or a Quick Start Guide. These should help you get the essence of the library and highlight the common use cases. The library really makes easy, ideally, these should match exactly what you need to do. This is also where Integration and Instructions should be found. Finding easy to understand gradal instructions, can make a huge difference in getting up and running. Lack of gradal instructions might mean extra pain and maintenance time. For UI libraries, you might also look for screen shots, videos, a demo app or real world apps that use the library. All can be powerful signals in determining if this is actually what you need. There are specific things you need that aren't readily visible, may be time to look through the documentation. Good documentation is a sign that the library developers care a lot about the developer usability of their library. Two other factors you might consider are recent activity and whether there is a community around the library. Both are good signs that if you come across an issue, or a bug, you won't be on your own. While none of these things except the core functionality are deal breakers, there is a strong correlation between these factors and well designed and useful libraries. As you might imagine, with an important area such as image loading, there are actually a large number of libraries providing this exact functionality, each a little bit different. Comparing similar libraries can be a laborious process, but can really give you a deep understanding of how the libraries work. For Sunshine, we'll use Glide, the image loading library that is flexible and has a number of optimizations to allow it to work efficiently within a scrolling list and work alongside the activity and fragment life cycles. It is used in a number of Google Apps, including Google Camera, Photos, Field Trip, and the Google I/O app. With an easy Getting Started guide, good documentation, and the full source code, there's a lot to like. Let's see how we can use Glide for Sunshine. Okay, now let's remember our goal, replacing our weather icons through Sunshine with images downloaded from the internet. Of course, before we can use Glide with anything, we'll need to add the library to our project. In fact, we use the same approach as we did with the support annotations library adding in the single dependency needed for Glide. With just that change, we can now use Glide throughout our project. So what does it take to replace our code for loading icons with a call to Glide? Let's take a look at the detail fragment, as an example. In this case, we're using a utility method to retrieve the correct resource id, based on the weather condition id. So, what does Glide look? Pretty similar, in fact, we'll create a Glide instance, passing in either a context, activity, or, in this case, a fragment, and use load, passing in the URL of the image to load conveniently provided by a different utility method. Then, we'll request that Glide load that image into our image view. Just like that we've written everything we need to download, cache, format, and display the loaded image in our app. Not bad for three lines of code. Of course we probably also want to ensure that the app works even if there isn't a network connection and we haven't cached anything. For that we can use the error method to fall back to our local image resources. Glide offers a number of convenience methods like this to allow placeholder images, cross fading, center cropping, and more but this will work great for what we need for sunshine. There is one caveat. When we use an image view with wrap content and we set the image view via set image resource, you're actually taking advantage of some built in functionality where the image view would automatically resize itself based on the image's dimensions. However, when loading images from the network, we'll need to set a specific flag, adjust view bounds. This ensures that after glide loads the image from the downloaded bitmap. Image view will adjust its view bounds to match. So what changes when we don't have an image view? Brought up at the beginning to gather images into our notifications, this is a slightly different problem. We somehow need to get a bitmap to add as our large icon. What does this mean for Glide? Most of this should seem familiar, create a glide instance, load from a URL, fall back to our local artResource if an error occurs. But there's a few new methods in here. AsBitmap is what tells Glide to load the image as a simple bitmap. Turns out that Glide can also load animated gifs, which, unfortunately, don't work for our notification large icon. Then instead of using into with an image view, we pass in a fixed width and height. This is what tells Glide to load it as a fixed size bitmap, rather than dynamically resizing it based on the size of the image view. But how do we know what size the large icon needs to be? On gingerbread and lower devices it was a fixed size, 48 DP. On newer devices we can use the provided dimensions, notification large icon with and notification large icon height to ensure that we always get the perfect size. Then we use get to request the glide, retrieve the bitmap synchronously or wait here until the images are treat as we build our notification in our sync adapter, which runs on a background thread, it's okay to block until we get a result. Definitely not something we want to do on the UI thread. Make sure to catch the interrupted exception and the execution exception from get. While we don't expect these things to happen, it's much better to fall back on our local art resources than crash. If everything goes according to plan, we'll have a perfectly sized bitmap we can pass on to our notification. We're not quite to getting icon packs into Sunshine but we are far enough along to replace our current icons with ones loaded with Glide. Copy in the new getArt URL for weather condition utility method, the new URL string, and our dimension for the default notification, large icon size. Then, update the DetailFragment and the ForecastAdapter used for the forecast fragment. Don't forget about the adjust view balance attribute for the XML files. But before we use gray scale icons for the future dates, let's update it so that all days use the colorized icons. Don't forget about our notification, we want pretty icons for everything. Great success. Now we're loading images from the network without writing any networking code or caching code or crazy views within a list view, optimizations or anything. Best libraries take a complex problem and give you a simple API to work against, letting you focus on the unique parts of your app. So how do we transform our code to something that actually allows us to load different icon packs? A lot less than you might think. In fact, because all of our logic for retrieving a URL from a weather condition ID is in our utility method, we actually don't need to touch any of our fragments or notification code. Kind of like we planned it that way, hm. We will have to update our setting screen, though, adding a new list preference to allow users to select which icon pack they want. If you remember back to our temperature units list, preference is driven by two arrays. One for the options the users sees, and the other for the values, what actually gets written in to the shared preferences. We'll use our URL templates for the values. Just need to replace our single URL string with our options and values string arrays, wire up the list preference, then do that last piece of magic. Update our utility method to read the URL template from shared preferences. Sounds easy enough? And that's it, no extra magic required. Now you might say to yourself, hard-coded URL templates right in the app? What are we doing? And you're right. Ideally, we'd have an external server or service that allows us to dynamically load the list of icon packs. But the logic behind there isn't necessarily user visible. We can still make a great experience with what we've got, and then iterate from there if and when we find icon packs are a huge hit. We started looking at a pretty simple feature, just replacing a few icons. After realizing getting those icons from the network was more complicated than at first glance, we were able to integrate a library, Glide, to get us back to being a pretty simple, manageable extension to Sunshine, that gives users the ability to really make Sunshine feel like their own. Look at Sunshine. Still think it looks boring? Well, yeah. It's a weather app. But- Oh wait, this is better. [LAUGH] That's the icon bag you chose? Wow. Hey! I like that one. Hey, did you get a chance to see Dan's view design? I did, I think he'll be happy to see what he came up with. Oh, there he is now, hey, Dan. [SOUND] All right, I think it's done, done, it is so done. Wow, Dan, you're really excited about this. And I'm going to let you finish, but let's see the redesign first. Right, right. We developed the original Sunshine app in parallel with the development of material design in Android. For that reason the design already incorporates some material concepts. We're going to take the design a bit farther in that direction with the help of a support library. While Sunshine functions on phones and tablets of all sizes it wouldn't come close to be considered a tablet optimized application. Material design could help us here. We can take advantage of patterns that add extra space into and around our layouts to make things feel more natural on these devices. The new support library makes it easy to bring some material design to our application. It implements toolbars and makes it generally easy to bring vibrant material colors to our application. Finally, we're going to add motion and dimension to our application. Some of this will only apply to newer Android releases, but we'll make sure that the experience is good on all of our devices. We're going to radically rethink the design of sunshine. Before we dive into this further, let me make it clear that there are many positive things about the sunshine design. Particularly the portrait phone model. The landscape version, however, is very clearly a stretched version of the portrait design. The giant blue splash for the today view is a nice idea, but it's a bit too much, especially in landscape. The use of roboto condensed, detracts from the appeal of these reviews. The detail views even on a phone start to fall down. It's a pretty simplistic presentation with uneven use of white space. The landscape version even, needs to scroll to show all content. For the portrait forecast view, we're going to moving toward better use of color and white space. Even though we're initially using up more space with the app bar. We're going to add some code to allow us to scroll it along with the forecast list. For the landscape view, we're doing something pretty radical in order to improve the use of white space. Namely we've eliminated most of the app bar. By taking the sides of the list in. We provide more balance to this layout. It's not ideal but it's more aesthetically pleasing. We'll also demonstrate some parallax scrolling here. For the detail view we're doing a more serious overhaul. We're using a toolbar that matches the coloring of the detail view. And only contains share functionality. The bottom includes a nice accent shade with a separate section of the app per data unique to the detail view. Overall, it's a far better use of whitespace. And a good teaching ground for some more advanced layout techniques. The landscape detail view is even more striking in comparison to the original application. It not only has a nice look. It actually fits more information on the screen. The landscape tablet version wouldn't make it on google play as a tablet optimized application with all that unused space. We'll give it a fresh look with the update. Our portrait tablet is even more striking in its comparative use of white space. If the challenge to display an app which has list like this and tablets. Without falling into confusing user scenarios such as changing the number of fragments on screen between portrait and landscape. We'll dive deeper into implementing this design throughout the lesson. One of the great things about reading the Material Design specification is that it is presented using Material Design. I was immediately struck by the vivid use of color. The spec says that color should be unexpected and vibrant with bold hues juxtaposed with muted environments, deep shadows, and bright highlights. To help designers, the developers of Material Design provide a sample palette of primary colors for app developers to choose from. Using these colors isn't some sort of requirement, especially Especially if your brand already has established colors, but it's a great starting point. Material uses the number 500 to represent the base color for the theme. 500 is in approximately the middle of the Material palette, as in these examples. You should pick a lighter version of your color from the same palette in the 100 range, and a darker color in the 700 to 800 range. I picked the 100 and 700 light blue for the update to Sunshine, which is similar to our original palette. Then you'll want the contrasting accent color. To make things easier, the Material palette definitions mark accent colors with letter A. You want to pick an accent color that contrasts with and harmonizes well with your primary colors. I chose a shade from the amber palette because it harmonizes nicely and matches our icon color. After all, blue skies and golden suns are not only friendly, they are evocative of our application name. So, this is the final short color palette for our application. Using the support library, we can easily alter our color palette to use these new colors. We're going to theme Sunshine with our updated material colors. We'll start by creating constants for primary_light, primary, primary_dark, and accent. And then we'll replace all occurrences of sunshine_blue, sunshine_light_blue, and sunshine_dark_blue appropriately. Remember that colorPrimaryLight is not actually part of the material theme. All right, you're done. Let me show you my solution. As you can see, I've modified the colors.xml file to match our selected material pallet. I've also gone and replaced these colors throughout the app. Most notably, in the main style.xml file. We know our app theme is using color primary, color primary dark, and color accent. But there are other places in the code that I had to do a search and replace on all three of these color values. And that's it. All right, as you can see, here's a new version of Sunshine, with our new and updated colors. Pretty cool stuff. The Android 5.0 introduced a new tool bar widget. This generalization of the action bar pattern, gives you much more control and flexibility. Tool bars of view and your hierarchy just like any other, making it easier to interweave with the rest of your hues, animate and react to scroll events. Many Androids apps now have two or more tool bars. As in this example. Toolbars are made particularly important, because of the design rule that we aren't supposed to split a toolbar with another piece of material. This means we often need multiple toolbars. Fortunately, we have a fully functional version that has been built as part of the Android support library. In order to make use of toolbar, we need to first change our application to use a theme that doesn't add an action bar on our behalf. I'm going to create a base toolbar style, that gives it a background color. Toolbars have transparent backgrounds by default. We'll also make sure that we're using the light pop up theme. This will be important when you set the toolbars to the dark theme in our layouts. That we can have a little more light colored text that will pop against our dark background. I can make all of my toolbars get this new style, by placing a toolbar style in the app theme. Then you just add the toolbar into our layout. Note that I'm setting the size to be the standard action bar size from the current theme, using the ?attr notation. And I'm setting the theme to be the overlay theme for dark. This will nicely style us with light text. Finally, I can make the toolbar behave like an action bar. By setting into the activity using setSupportActionBar. Once it's there, I can apply action bar styling to it using getSupportActionBar. I could use these functions to get the icon back, but I want to demonstrate one other cool thing about toolbar. It contains a view group that you can customize. This view group is like an even more simple frame layout. So we could add our logo back to the toolbar this way. This level of control, becomes useful as we continue to work towards our new design. We're going to convert sunshine from using action bars to using tool bars. We start off by changing the app's style. Then we add a tool bar style and reference it in the app theme. Remember we're just doing that to set some common parameters across our toolbars. Then we add support toolbars to activity main, and activity detail. We call set support action bar in each activity to register it, and then we call setDisplayHomeAsupEnabled with true and setDisplayShowTitleEnabled is false on our support action bar. Finally, we add our logo into the toolbar layout in activity_main. All right you're done. I'll show you what I did. As I said before, we're going to change our base app theme into a no action bar them. In styles.xml. Next we added a toolbar style. Again we're doing this just so we can set our background color consistently and also set this pop-up theme. We then reference this in our app theme. In activity_main we created a new linear layout for our new tool bar. So we could sit it next to the fragment that was already there. It was a little easier in our tablet version of our main activity. And again we added a linear layout here as well to add our toolbar in our activity detail. Finally, we had to register it as our action bar. So once we have set our ContentView, we find the Toolbar by id, and call setSupportActionBar on our AppCompatActivity. Then we can get the action bar with full action bar methods, and call setDisplayHomeAsUpEnabled equals true. For a detail activity. We do something similar in the main activity, except that we call setDisplayShowTitleEnabled equals false. And that's it. And there you are with our exciting new look. Well, as you can see it looks exactly as it did before, except now we're using toolbars. We'll take advantage of this later on. The view contains three sets of elements. The first element is the toolbar, now styled in white. The second set is a view reminiscent of the Today view. And the third set contains additional weather detail. Some quick measurement shows that the top set of Today elements is one and a half times the height of the bottom half of the detail elements. Sounds like a job for a LinearLayout with weights. Inside of the sets, we see some interesting Android layout techniques. Two spacer views are in place above and below that vertically center the content of the Today styled view. Following the rules of material design, we see 16dp spacers being used liberally in the vertical direction, along with 32dp spacers in the horizontal direction for the details. But we're still missing the core of these layouts. It would be pretty easy to build the top one with a nested LinearLayout, and slightly tricky with a RelativeLayout. But it turns out that both of these sections are built with only one layout each, a GridLayout. GridLayout was added to Android for the Ice Cream Sandwich release. Its goal is to address the limitations of Android's nested layouts, which fall into three basic categories. Firstly, the inability to control alignment along both axes simultaneously. Performance problems in hierarchies that are too deep, especially when you're using expensive features such as layout_weight. And unsuitability for design tools that support freeform editing. And yes, we are looking at you, RelativeLayout. As its name suggests, GridLayout uses rows and columns to layout views. You can see it adjust the grid automatically as controls in the righthand column get larger. Using GridLayout, you give constraints to each view, as well as specify what to do with the extra space in the cell, using the GridLayout's own version of layout_gravity. The GridLayout then attempts to preserve the constraints as it solves the problem of laying out the view. Android Lollipop added the ability to GridLayout to reapportion space among its child's views automatically using layout_weights. Fortunately, the support library lets us use this latest and greatest version of GridLayout. GridLayout is a separate support component. It requires a separate entry in your Gradle dependency list. Here are a bunch of layout elements in no particular layout. If we place the layouts into a default GridLayout, it behaves similar to LinearLayout, although it aligns text to the baseline by default. We didn't have to put the height or width of each into the layout XML because GridLayout assumes wrap content. Here is the underlying grid produced by this layout. Changing the orientation to vertical makes it perform very similar to a vertical LinearLayout. And here is the grid produced by that layout. Changing things back to the default orientation of horizontal, but giving the GridLayout a column count of two, causes GridLayout to automatically place the child views into columns. Here's the underlying grid produced by this layout. Explicitly setting the icon view to the second layout row, first layout column causes the GridLayout to move the cloud icon to the first column in the second row and continue laying out all other views from there. Here's the underlying grid produced by this layout. But even better, we can use layout_columnSpan to have the date span both of the columns. Here's the underlying grid produced by that layout. Now we can distribute the extra weight across all columns by adding a layout_columnWeight to all of the columns. Note that you need to add this to all layouts in the column in each row for it to have the desired effect. And here's the underlying grid produced by this layout. We can tell the GridLayout to center a view horizontally within its cell by adding layout_gravity equals center_horizontal. By adding this to each layout, we get this effect. Note that the two columns aren't exactly even, because we only distributed the extra weight between them. It looks close because they contain similar sized elements. You can really see that in the grid produced by this layout. Material Design defines these default styles. These sizes and styles were developed to balance content density and reading comfort under typical usage conditions. Consider using these styles whenever possible as it will help you make good design decisions. The support library provides the definitions for all of these font styles. Here's how you would reference the Display 4 112sp style in the textAppearance of a TextView. We're going to do our best to make sunshine use as many of these styles as we can while implementing the new design. Let's talk about how we use grid layout in Sunshine. Our key lines guide us in laying out the top today section. We begin with the grid layout declaration. Note that we are using the support library version, so you will have to prefix grid layout specific xml attributes with app, and include the res-auto schema. We use a column count of two. Adding a column count isn't strictly necessary, as you can just specify the row and column of each child, but it does simplify the declaration of each of the children. Our first child is this space widget. Space is a lightweight view subclass that is used to create gaps between components. It can be used anywhere, but it's actually part of the grid layout support library. We'll have this space widget span both columns with a column span of 2. We'll give it a column weight of 1, so it will take up all available width, and a row weight of 1, so it will participate in getting any extra row space when the layout is complete. First of all, the 16 DP spaces, using the padding horizontal material constant from the support library, above and below the text view, are generated from layout margin attributes. Remember that adding a layout margin actually changes the borders around your layout. We're using material styles here. In this case, we're using the title style and applying the standard sans serif font family with our secondary text color from the material theme, since the title text appearance uses a different font weight and color. Note the use of the tools.text feature here. This allows us to populate the view of text for the purposes of editing without impacting the production code. This view also spans both columns. Because we want column weight to be calculated for both columns, we must have it here and everywhere we declare a child. We're finally, actually using both columns. As before, we need to declare a column weight so the grid view will distribute the extra weight. We're finally actually using both columns. As before, we need to declare a column weight so the gridview will distribute the extra weight. A couple of notes about the imageView. I'm using maxHeight and maxWidth along with the adjustviewBounds to limit the size of our weather image. This allows more flexibility in layout. But still allows us to have a theme image that may be larger than our layout size. The image view also uses a source tag with a tools names based, to display an image in the editors tools. We set up the forecast text view and the low temperature text view in the same way as the columns in the previous row. Note that we were actually giving the low temperature text zero margin, which is applying across both columns. Finally, we add another space widget with a row weight to keep the rest of the content centered within the grid layout, and that's it. We had the top of our detail layout, which is included from detail today, grid.xml. The rest is up to you. Grab the starting code from the instructor notes. There are lots of changes, including things like adding the GridLayout to the project. The bottom half of the fragment detail layout has been implemented incorrectly using LinearLayout. Alter the layout using GridLayout to match the design. All right! Your done. Lets go over my solution. Before we actually go to lay out the bottom half of our details view lets strategize. We have two columns, one that contains these headers, and one that contains data. The headers column is pretty easy it's all left justified, 32 dp away from the edge. The other column is also justified right from the other edge but all three of those elements are aligned left. This would be very tricky to do with anything else other then a grid lay out. We're going to let these three elements actually take up the expanded space. Let's look at how we implemented that. All right, so let's take a look at our grid layout. As you can see, the padding in the bottom and top is 16DPR. Abc_action_bar_content_inset_material. Our padding in left and right, in start at end, for right to left languages, is forecase_detail_horizontal_padding. Or 32DP as we defined it in our dimensions. Let's take a look at our first row and column. As you can see, we're using columnWeight 1. Let the layout manager know that this text view is actually going to expand to take up any additional space. We use a rowWeight of 1 to also show this row is going to participate in any additional space that the layout manager may have. And here's our first column. And here's our second column. Notice that we're not using any weights here at all. Other than that this is pretty simple, all of our rows have a row weight of one, so they'll all participate in the extra space, so they'll all be spaced evenly. This gives the layout a nice even look. And that's it. That's pretty straight forward. Again, there's not necessarily one solution to this. One of the things I like about layouts, is that each one of them is like solving a little puzzle. All right, it's running in the emulator. And there's our new detail view with that bottom section looking exactly as we intended. It's time to look at updating our forecast view. A quick glance at the key lines gives me a sense of deja vu. We've certainly seen these metrics before. Furthermore, the entire Today view is nearly identical in layout to the top half of the detail view, except that it doesn't have the space views at center, our detail view. The extra vertical space in the app bar is the same height as our list items. Because we're somewhat space constrained, we're using a minimal 8 dp of spacing for the area between high and low temperatures in the daily forecast. And of course, we see that the Today view casts a shadow. The shadow helps create the illusion that the screen is made up of a physical material. But how do we cast this shadow? To make this easier for developers, Android L adds a new parameter into our layout language, elevation. Paraphrasing from our Material guide, elevation is the aspect of the Material Design language that helps users understand the relative importance of each element and focus their attention to the task at hand. It combines the familiar and physical materials with magical properties that designers can leverage to create delightful moments. The elevation of a view, represented by the z property, determines the visual appearance of its shadow. Views with higher z values cast larger, softer shadows. Views with higher z values also occlude views with lower z values. However, the z value of view does not affect the view's size. Elevation is used for the static state of a view. Translation z is used to create animation such as this one, where widgets temporarily rise above the new plane when performing some action. Note that this video represents Material's ideals rather than the reality of the Android implementation. Elevation animations are typically used to help signify action in response to user touch. Setting the elevation parameter on a view group will cause it to cast a shadow on other views. You have to be a bit careful as it also changes the way views clip. Higher elevation views will occlude other views, even if they appear first in the layout. The appbar_elevation dimension is four dp. We can add this to our dimensions or just include the Android design library, which defines this dimension. To make the changes to our portrait forecast view, we need to make changes in three places. First, we'll update the toolbar section to create the app bar from the design in activity_main.xml. We'll make changes to the Today view in the list_item_forecast_today layout. And we'll modify the rest of the forecast list items in the list_item_forecast layout. Before you start coding, you'll grab another code update, which includes correctly sized images, updated list selectors, and some useful dimensions. Because we have network loadable image sets, you want to constrain the width of our icon images in the forecast list to 40 dps in the list icon dimension we give to you. You can use the touch_selector_white to replace the Today touch selector. The large numbers are 32 dp, while the text view is 49 dp wide. I'm intentionally using dp instead of sp here because I don't want these numbers to change size when the system font is set to large size. I'm intentionally using dp instead of sp here because I don't want these numbers to change size when the system font is set to large size. We're pretty tight on space on narrow devices already. The app bar is pretty simple. We take advantage of the fact that the Toolbar will center its children with respect to the entire layout if we use layout gravity equals center horizontal. Therefore, we include the Imageview inside of the toolbar with a height of listPreferredItemHeight and a marginTop of actionBarSize, while having wrap_content for width to let the Toolbar center it. Update the Forecastview using Elevation adding a tall app bar. First, grab the updated code and resources from the instructor notes. Then, update the toolbar to match. Update the Today list item layout. It will look much like the detail view you just looked at. Update the forecast list item. Use the supplied dimension to fix the icon width. All right, you're done. Here's how I ended up changing the layouts in the forecast view. Let's first look at what I had to do in activity_main.xml to the toolbar. This one was pretty easy, because I already had a linear layout containing a toolbar in our image view. As well as this fragment. Basically, all I had to do was add this new margin top for action bar size and set the layout_height, or image view, to listpreferreditemheight. Then, I set the layout_gravity to center_horizontal and I have it wrap our content, rather than match parent. This will create the additional height we want for the app bar. And it'll actually center the image view inside of the entire toolbar. So if we had left this as match parent, when it tried to center the image it would've actually not known how to take into account the fact that we have an overflow menu, and so it wouldn't actually be centered. Other than that, we set the background to color primary here. That's really not helping us, because we don't really need it [LAUGH]. And finally, for the toolbar, we actually set the layout height to wrap_content. So it'll grow in response to this margin top. It's very important. And that's it, pretty straight forward for activity main. Lets look at list item forecast today. Now, if you were paying attention, you notice that this grid layout looks almost identical to the grid layout that's actually in the detail view. Now you guys didn't actually end up coding that one up, so if you took the time to code this one up, all the better. It's pretty straight forward and we covered it pretty completely in the previous lecture. We just remember we have two columns in our grid. Breaking apart our grid view, we start off with our date, which it uses to add vertical white space by about 16 pixels. All right, let's take a look at how our date text view works. It has a margin bottom and top, and that adds 16 DP of space above and below the layout. We're actually centering the text inside of the layout, rather than centering the layout itself. So we're actually going to fill the entire space horizontally. And we're going to span both columns. And then we have our icon. Once again, we're using maxHeight and maxWidth, based upon our dimensions. So that if things come in from the net, it's not going to change our layout, or at least it's not going to make our layout bigger than we want it to be. We set a column weight of 1 here, because we want to make sure that all of our columns are participating in getting extra space. Same thing here for the high textview, the forecast textview, and the low textview. These are all handled pretty much the same. So the one thing to note here is that the layout margin bottom here actually provide 16 DP of margin for the entire row, even though it's actually only a part of this particular cell. Finally, let's take a look at list item forecast. In this one we're not doing anything particularly special. We're using frame layouts and linear layouts, as we always have. The biggest difference between this and the last one is that, one, we're using proper dimensions everywhere, We've actually eliminated a linear layout that used to be in this section. As you can see, we've really tried to make sure that we're using dimensions everywhere. This helps to create a sort of style for our application that's consistent, especially since we're trying to go for material design, which is very explicit about how the spacing should be. And here's what this looks like when we run it. As you expect, it looks pretty much like our original diagrams. Nice stuff. And that's it! Pretty similar to what you came up with or different? Again, there's not necessarily a right answer. But the goal is to try and create a fairly simple layout. Our portrait forecast view looks pretty good now. The next code you're going to grab will transform the landscape tablet view from this, into this. Let's go over how we accomplish this change. First of all, you can see that we've added a linear layout for the app bar, which has the correct elevation and blue primary color background. Next, we see the toolbar, rendered with the correct themes. This is a bit interesting. We want to align the Sunshine logo with the forecast day. Rather than hard coding the calculated value, we use nested frame layouts to perform it. This is a tiny bit expensive but it makes it easy to create responsive layouts. Finally, we look into how we position the detail view. This is a nice trick for creating two even columns in a relative layout. Create a center strut view that has no width or height and ask relative lay out to center the view. We can then create the forecast fragment view to the left of this strut view and a detailed fragment to the right of the center strut view. Note that we have to make sure that the lay out elevation at least matches the app bar. Otherwise the detailed fragment would be included by the at bar rather then overlapping it and that's it. It's actually a relatively simple relative layout, given how complex it looks. Let's take a quick look on where the portrait tablet layout stands. Yikes, it's worse than before. We can fix it. Here are our red lines for what we want the portrait layout to look like. Wow, these overlapping red lines are a bit confusing. We can bring the app bar forward to analyze it. So, our app bar will be made in three sections. The top section is our tool bar with a height of action bar size. Image, with a height of listPreferredItemHeight, and the bottom section is our spacer view, with a height of details_app_bar_overlap, which we've just added for you. We use our standard 16 DP padding around the details fragment, and for our details fragment, we're actually going to use wrap_contents. All right, now it's your turn. Add layout-sw600dp-port/activity_main.xml. Start by grabbing the starting code using the instructor notes. Then use a relative layout of the root layout, using three views to make up the app bar. Have the detail view overlap just the bottom app bar view. Place the forecast view below the app bar. That's pretty much it. Note, use the dimensions in the previous slide for the height of the three views that you have to place in the app bar. All right you're done. Let me show you how I solve this one. Alright, let's first take a look at sw600dp dash port activity main. In other words, this is the layout our portrait tablet is going to use. Now as I said we're going to start with a relative layout. Inside the relative layout we begin with a toolbar. Which is pinned to the parent top. And is the width of the parent. Also it is height action bar size. Pretty reasonable. Notice that we have an elevation of appbar_elevation. All of these in this draw are going to have the same elevation, so they don't cast shadows on each other. The next thing we do is we have an image view. The ImageView is below our toolbar and it's a listPreferredItemHeight. Pretty straight forward. We center it, give it the elevation. Finally we have just a View. This View also has the same elevation with the same background color, and it's below the image view. And its height is this details_app_bar_overlap dimension which we know is 24 dp. so now if want our detail container to overlap this view all we have to do is say, instead of it being below this view, we say it is layout below the image view, which is here. That will cause it to overlap, and we inset it exactly the way we've inset everything else. We use paddingLeft and paddingRight in this case on inset material which is of course 16dp. Finally, we can put our forecast fragment just below that detail container. Pretty straightforward. Once again, here's the design we're looking to create. What's great about this view is that it uses mostly UI elements we've seen before. In order to prevent the number of complex layouts from growing explosively, we're going to take advantage of three Android layout features. The first one we've seen before. The only difference between a forecast list item on the phone and on the tablet is padding and margins around the list items. Fortunately, it's easy to add this to the forecast list. We can use dimensions to give the same layout more space in tablet layouts. In forecast list item layout, we can add a padding dimension to the outer layout. We use padding here instead of margin because we just want the content in set. If we used margin, the row selector wouldn't be drawn across the entire list item. We also use a different dimension for the space between the two temperatures. Note that we use both right and end to make sure that this layout is ready for right to left mirroring. So then in our resource's file we create a dimension that updates the extra padding and the space between the two temperatures. And that layout is updated. I'm using sw600dp-port. Which means that these changes will only be applied Portrait Orientation with devices and a view sides with at least a width of 600 dp. The second thing we take advantage of is Layout Reuse using the include tag. We can see that our portrait and landscape detail fragment use the same views. The fragment detail view contains these included lay outs already. Note that we can assign new lay out parameters when we include the lay out. We're not using this in sunshine. But we can avoid adding an extra container when we include the layout by using the merge tag in the layout to be included. Finally, we're going to continue to make use of Refs. Refs allow us to make aliases for resources. As you can see, in tablet landscape mode, the detail view should point to a vertical version of the view. We're going to create a Ref that points to fragment_detail_start and make sure that it points to the correct detail fragment for all configurations. This will come in handy in the next lecture. Let's apply some of that last lecture. Start by grabbing the starting code for this lesson. Update the list_item_forecast to have left and right list item extra padding, which will cause it to match the screenshot to the left. Add a dimension file for sw600dp-port, and sw720dp-port. See the instructor notes for the recommended spacings. Move the gridLayout from fragment_detail into detail_extras_grid, and include it. Make a refs file and create fragment_detail_start for each size and orientation. Modify DetailFragment to load from this new alias. All right, you're done. I'll show you what I did. All right, so the first thing we did was update our list item forecast to have left and right extra padding. We added a dimension file for sw600dp portrait. Note, we can have I've really, really wide padding there, because remember tablets are just huge in that direction. SW720dp is even wider, but we're not actually going to increase the padding at all. So we also took the grid layout of the fragment detail and moved it as a detail extras grid. That's pretty easy because well, we just literally moved it. All we needed to do was make sure that we added these name spaces in correctly. Under Refs, we've now created this fragment detail start layout reference, which is pretty cool. We've created it for every single size and orientation. It's always pointing to the right one. Now we use this layout inside a detail fragment rather than referencing the layout by name. We're almost there with our tablet layout. It's time to get this done. We have two problems. First, if you've tried this on a Nexus 7, or other seven-inch tablet, there's a good chance the detail view isn't rendering in landscape mode. The reason for this, is that the grid view cannot solve for the constraints we've given it. And the reason why we don't have enough room is that the design for this view calls for the toolbar to be placed in line with the detailed grid, rather than above it. The second problem is a problem with elevation. Our design calls for a shadow around our detail view, but it's just not there. Since we'd like this to have a shadow on all platforms, not just Android L, we can introduce another widget from the support library, CardView. CardView is a container that casts a shadow around a view. When we change the elevation of the card, it casts a larger shadow. Note that card view has its own version of the elevation parameter. We can also change the radius of the corners of the card view to make rounded shadowed rectangles. Note that this works best on L, due to the way we handle clipping on the compatible version. Because the card view is a layout that draws stuff around other layouts, it works a bit differently than others. You can control the background color of the layout, the background color of the card, the padding around the card frame, and the padding inside the card frame, between the card and its contents. Since CardView is rendered in Android L using elevation, it's important to understand how this impacts the rendering of views. First of all, a view at a higher elevation obscures views at lower elevations. If you have nested views, if a view will obscure the parent, you will also obscure all children of the view. Views that have transparent backgrounds don't cast shadows. Views that are contained within these transparent views will also not cast shadows. Given these constraints, it's relatively easy to create a view with elevation that doesn't render the way one expects. We're going to make extensive use of relative layout, to avoid having to add extra hierarchy, which would prevent us from creating the kind of shadows that the design requires. One more thing, on pre-L versions of android, card view doesn't clip contents to the bounds of the curved rectangle, but instead adds padding to avoid having that content overlap the shadow area. Since we have a dark background on part of our card, this makes a little white line show up. Since the corner overlap looks more benign than these white lines, I recommend setting cardPreventCornerOverlap = "false" on our card views. All right, use Cardview for detail view shadows on all platforms. So first of all grab the starting code, then add the Cardview library dependency under project structure dependencies. For tablet portrait replace the weather detail container frame layout with a Cardview, but use margins rather than padding, so the Cardview edges get properly moved in from the layout border. For tablet landscape, replace the detail fragment frame layout with a Cardview. To do this without creating additional hierarchy that prevents the shadow from rendering correctly, create a space view in the RelativeLayout to align the Cardview with. Again, a little bit tricky there. One more note: this will create an empty Cardview when nothing is selected, because by default, our detail fragment hides itself. So instead of that in our detail fragment, check to see if the parent view is a Cardview. And instead of hiding ourselves, hide that parent view instead. So that's what that this line means here, when it says hide the card view parent in the detail fragment. First of all, you'll grab the starting code. The next thing you had to do was add the library to point to the CardView, which will be nicely inside of your greater files for you if you added under project structure dependencies. For tablet portrait it was really easy. All you had to do Was replace it with currently there in the frame layout with the CardView, and it just worked. You would want to, of course, set the card elevation correctly, and say PreventCornerOverlap=False. So that on older devices you didn't end up with that little white line. Now for tablet landscape, it was slightly more complicated. So you see, what we did is, we actually added this CardView aligner here. And we set the marginRight to 64dp, and we set the alignLeft to layout_center, and this allowed us to add an additional calculation. But without adding any layout hierarchy, we still were able to add margins in this case, which is pretty cool. This allows us to the put the card view in the right place on both seven inch and ten inch tablet layouts, which is pretty cool. And the other thing we had to do was, of course, replace the frame layout that was here with the card view. So that makes sense, so you can see it's aligned with the card view aligner, and of course it has card elevation and pard prevent corner over lap false. And of course the one other note about all of this is that we needed to do something in detail fragment. And so what we're going to do is, when we are loading up instead of setting ourselves to be INVISIBLE like we did before, we're actually going to look at our parent and see oh, is our parent a CardView? If so, let's set that to being INVISIBLE instead. In onLoadFinished we're going to do the same thing. We're going to say oh If the parent of us is a card view, then let's set that to be visible. And that'll keep the same behavior of when the fragment isn't loaded, we don't see anything. Which is important especially in the case of empty view. Now we really don't want to see that kind of artifact going on. And so that's it. Pretty straight forward. That one little challenge I think with the space in the relative layout, but it's a good example of how one can use another view to do arithmetic for you. And sometimes you have to do that in Android views. Since we've been coding for a while now, I wanted to pause to check back in with Roman Nurik at our Design Center in New York City to talk a bit more about design. [SOUND] Roman, once again, thanks for your time. Do you think that every mobile app developer should strive to become a designer? Well, I don't think it's necessarily important for every developer to become a designer, and stop doing their engineering work. I do think, though, that every developer, every front end developer, should have some sense of design. And I also think that, really, as a mobile developer, you're already doing design work, right? Whether you like it or not, you are creating, you're crafting the experience for the end-user. And so what I think is important is just knowing that this is something that you're participating in. This is not something that is being handed to you, and you're just executing on. Knowing that this is something you're participating in, I think it's super important for developers to really kind of study up on it. To get as good as possible at observing the differences, observing the little details and really kind of caring about every little, I hate saying every little pixel, but every little decision here and there. And so I think rather than saying every developer should become a designer, I think every developer should really understand design. Always understanding also that you're going to be working in a team, and kind of understanding what your designers are good at and so forth. So, yes. [LAUGH] In short. For me, that's super interesting. And you can definitely see how we're using material in our cross platform experiences here at Google. While being true, in many ways, to the unique element of each platform. Design has become so much more important in building applications of all sorts. And I think it's really important for every engineer to at least be familiar with the palliative options available to them and to their designers. To that end, Roman Nurik, Nick Butcher, and James Williams, are developing a terrific course in material design, that any front end engineer should experience. It's time to look back at updating our forecast view in phone landscape mode. What we have now with a huge app bar, gives the user almost no context to use the list, and the list contains a huge amount of white space. The design that we have for the forecast landscape you eliminate, is most of the app bar. Placing it underneath the scrolling list. We're going to fix the width of our forecast list at 360 dp. This isn't as bad as it might sound, since the whole goal for this is to eliminate interior white space. And this guarantees that the interior white space is constant. We're eventually going to pad the top of the list by 16dp. But we'll save that for later. We're going to do these changes inside of the forecast fragment, inside of the layout land directory, because the next code pull moves the app bar layout into the fragment. Create a landscape version of fragment_main. So, first of all, grab the starting code, as we always do. And I recommend copying the existing fragment_main into the layout-land directory. Modify the layout to match the design. You can set the width of the included fragment_main base layout, to this new dimension that we've given you, landscape_forecast_view_width. Know they'll have to be careful about elevation and reorder the layout, since the forecast list is going to overlap the app bar. And again, don't worry about with this padding up here. We'll deal with it later. All right. You're done. I'll show you how I did it. So here's what I ended up doing. I used a relative layout as the root, which isn't really necessary in this case. You could have used a frame layout just as easily. So there's that. And you can see we have a linear layout here which contains our toolbar view, and it also contains a space. And it's colored primary. So we could have actually done all of this inside of the toolbar, but we didn't really need to. So we've created a bunch of stacking views. That's fine. And then for our fragment main base, we then just include it here and align it to the top as well. So right now both are aligned to the top. This layout also has app bar elevation. The only reason this layout here has app bar elevation is because I actually did it for you guys in the last one. But you can't actually set the elevation here. You can only set layout parameters. And elevation is not a layout parameter. So that's one minor thing with includes you should always watch out, you should always watch out for, is that the parameters that are associated with the layout you're including are actually there, except for layout parameters which you can modify on include. If we look at fragment main base, you can see that it actually has app bar elevation. Otherwise, this would not work. It has to at least have the same elevation as the thing that it's going to be layering on top of. Ideally it has a higher elevation, but in this case it's the same. And that's it. That's all we did for that one. Pretty straightforward. I hope you're getting really good at layouts now. I know that it's one of my favorite parts of doing Android. So if you don't like this part of doing Android, maybe you shouldn't be doing front-end work, because there's all that fun back-end work with content providers and stuff like that, which is also just as fun to play with. Recyclerview was added to the support library to ultimately perform many of the same functions that list view does. The addition of material design list item animations necessitated a significant change in the way adapters worked. The list view code was already exceptionally complicated. A relatively monolithic code base handled Layout, Recycling, Selection, UI decorations like dividers, Scrolling, Empty View. The decision was made to start over and produce a more flexible control. RecyclerView is focused on doing precisely what its name suggests. Managing the recycling of views. Most of the functions of ListView have been separated int separate RecyclerView components. And we've added an additional animator component. One of the exciting ways this is being used is with LayoutMangers. Which allows us to create different pluggable layout experiences. Of course, we have standard vertical list views, and horizontal lists. It's a big deal if you've been doing Android for a while. It wasn't actually easy to do a horizontal list. Grid layouts and this very cool staggered grid layout manager which lays out children of different sizes. Which supports horizontal and vertical layouts as well as the ability to layout children in reverse. One of the key features that Recyclerview supports is custom animations. So if we delete an item the default animator will nicely animate the closing of the space left behind. And because the animator, like everything else in Recyclerview is plugable. We can change it and customize it, the way it works. And, because the animator, like just about everything else in Recycler View, is pluggable, we can customize the way this works in the future. Here's a typical best practice for using ListView. You feed it with some sort of an adapter, like a CursorAdapter, which you feed with a CursorLoader and you register an OnItemClickListener with the ListView to get notified when the list item is clicked. And, you might have used a ViewHolder pattern to help you populate views with that CursorAdapter. Well, using RecyclerView, we see some familiar faces, like CursorLoader. Where ViewHolder was an optional but recommended part of the ListView pattern, it's a required and integral part of the RecyclerView pattern. Now we don't have a CursorAdapter at the moment, and that's not such a terrible thing, because now that we have CursorLoader doing the work of reloading our cursors when content changes, CursorAdapter didn't do all that much. We also don't have an OnItemClickListener. Now, one could use the OnItemTouchListener along with a gesture detector to determine when an item is clicked, but it's more common to just have your view holder implement an OnItemClickListener for the individual views that it's holding. The ViewHolder has access to the Adapter position that has been clicked. And since it is typically an inner class ViewAdapter, it would also have access to the adapter data for click handling. Let's show how this works in practice. In onCreateViewHolder from our adapter, we inflate the appropriate layout for the view type. Note that our sample ViewHolder can change references to the views. Just like we would have done in the old school ViewHolder pattern. In on create ViewHolder from our adapter, when we create the ViewHolder, we have to pass the root view into the superclass. We then can start references to the child views we want to fill out if we wish. This is also a good place to set the OnClickListener for the view, note that we have to have our viewHolder implement the OnClickListener to use this pattern in this way. And when we bind the ViewHolder, we take advantage of our ViewHolder being a non-static interclass for Adaptor, so it has access to our data. In this case, a cursor. All right. This is a pretty large quiz. We're going to convert Sunshine from using Listview to using Recyclerview. And the goal here is not to get Sunshine completely functioning again. It is just to get the list in the forecast displaying something with Recyclerview. So, you're going to grab the initial code drop. And then you're going to add the RecyclerView library as a project dependency. You'll then swap the android.support.v7 widget.RecyclerVIew for ListView in fragment_main_base. And then in ForecastFragment, swap RecyclerView for ListView. In the Forecast Fragment then your going to set the layout manager to being a linear layout manager. In the forecast adapter you're going to convert the viewholder to a recylerview.viewholder. Finally in forecast adapter you're going to add a cursor class member along with getCursor and swapCursor functions. And swapCursor should call notify data set change it's very important. So essentially in this section you're going to build a little miniature cursor adaptor. Again, make sure to look at the instructor notes to see if there's anything we have to help with this one. All right, you're done. I know that was long, but I think this is really important stuff. And RecyclerView is going to be a really great and important pattern in your future code, I am confident. All right, I'll show you how I did this. And I think it's actually pretty cool how straight forward it is in many ways to at least get this far. The first thing we did of course was to swap RecyclerView in for the listed view that was there. And I also changed the name, so that it would make more sense. And I even changed the name of our empty view here. Even though RecyclerView doesn't really have a concept of empty views. I still thought it was important to keep that parallel. Since, eventually, we're going to try to implement that using recycler view. And the next thing we want to look at and where most the changes actually happen are in forecast adapter. The biggest thing of course is that our forecast adapter is now going to ascend RecyclerVew that adapter and RecyclerVew that adapter will take a paramitertized type of the view holder, so pretty slick. Our ViewHolder is defined here. It's almost identical to the ViewHolder we had before except now we have this super class and we have this constructor that takes the view. And this looks a lot like what we had there before. The ViewHolder here is actually designed very, very much after the way that the cursor adapter worked. The RecyclerVewHolder was designed pretty much to be very similar to the way that cursor adapters work. And so we had new view, which was there before and now we have OnCreateViewHolder, which is parallel. And so the code is almost the same. We take the view type and we get the view group. Now, the interesting thing is we're actually going to have to get our layout inflater from that viewGroup, because there's no other ways to get this, there's no other context we have access to. So sort of interesting. Not something we're used to doing in Android all that much but use also has access to the context and then we replace what was BindBiew from the original cursor adapter to onBindViewHolder. And as you can see the code remained largely the same. Probably the biggest difference is that we don't actually have a cursor. We're actually using the one from the adapter so we have to use m cursor and move to position when we bind. Rather than just having a cursor that's at the right position. So that's a fairly minor change, but you can see other than that, the code looks very, very similar to what we had before for onBindViewHolder. And then here is all the code that actually implements the important cursor adapter stuff. So we have swapCursor and we have getCursor. swapCursor is really the only important thing here, truthfully. Which calls notifyDataSetChanged when the cursor is swamped, and that keeps that behavior of notifying the observers that something has changed, in tact. So there we have it. A very, very, very simple cursor adapter. We're not done yet. We still have to do some work in ForecastFragment. So ForecastFragment used to have a reference to the list view. Now we're going to store one to the RecyclerView. And just for fun we'll change position to RecyclerView.no_position. Even though it's the same value as the list you endowed position. And on create view we're now going to get a reference to the RecyclerView. And then the one thing we do have to do is give this RecyclerView a layout manager. Because a lot of layout managers there were actually people not displaying anything. It doesn't have a default layout manager. So we assign it a new linear layout manager. And then we can set the adapter. And then it pretty much works similar. Now of course, we don't have it completely working yet. But let me show you what you should have gotten working by this point. I'll run this project, and you'll see why I warned you all that it would be broken. And it's really that on click handler we don't have empty view handlers, all these nice things that list gave you for free we actually have to craft ourselves with RecyclerVew. So, first of all, you'll see that the empty view is displayed overlaid our regular view here, but we can scroll and we're getting the correct display, so that's good. But as you can see, it's we can't click on anything. So, it's definitely still pretty broken, but it's a good start. And we are now taking advantage of RecyclerView, which will allow us to use some cool stuff later on. But we still need to finish the work, which is why we have using Recycler View part two. The recycler view is set up so that a single adapter can drive multiple recycler views. To add back end support for click handling and empty views, we're going to give the recycler view adapter knowledge of our particular recycler view, which does kind of break the standard model. But it's alright, because we're not going to be driving multiple recycler views to our single adapter. So we're going to add back click handling and empty view into forecast fragment. In forecast adapter, we're going to create a forecast adapter on click handler that returns a date long, and a ForecastAdapter ViewHolder. And then we're going to add a ForecastAdapteronClickHandler member variable. We're going to update the ForecastAdapter constructor to have it take the ForecastAdapteronClickHandler and empty view. Then we'll have ForecastAdapterviewHolder implement a view.OnClickListener. And when you construct a viewHolder, set the viewHolder to be the OnClickListener for the view. So, does that make sense? You basically pass in the view to the ViewHolder when you construct it. You have the ViewHolder implement OnClickListener and then, you actually set that viewHolder to be the OnClickListener for the view at that time of construction. Then, you call the ForecastAdapter OnClickListener from your individual ViewHolder OnClickListener. If you have any questions, I'm sure we'll have some great instructor notes here. Set the visibility of the empty view In SwapCursor based upon the item count. So this is pretty simple, we're going to put back in empty view handling which is awesome. And then in the ForecastFragment, we're going to add back in empty view and onClick handling. When I say in ForecastFragment, add back in empty view and onClick handling, what I mean is we commented a whole bunch of code out in ForecastFragment. We're going to un-comment that, and then we're going to connect it up to these new mechanisms we've built to handle empty view and onClick handling. All right, you're done. You are over the hurdle. This is the hardest thing we're going to teach in this entire class, I think, in a lot of ways, or at least the most involved. Let me show you what my solution looked like. So we talked a lot about what was going to happen in ForecastAdapter. This is where most of the code for this one actually was, it was in ForecastAdapter still. So the first thing we did is we created a member variable for this ForecastAdapter onClick handler. This onClick handler's one that was designed for our specific use case, it's not just a duplicate of the framework's onClick handlers, because it actually returns a view holder. And as well as we're destroying this empty view construct, so that we can have a view that we can alter depending on how many items we have. Then we have our view holder implement view.OnClickListener, which is very, very important. Then, as I said before, when we create the view holder in the constructor, we can set an OnClickListener. So here's what we're actually going to do on this onClick handler. because this is kind of important. We're actually going to get the date, which is what we need to do actually, use onClick. And then we're going to send that blissfully away into our click handler, which is a lot nicer than actually sending the cursor in. This is a nice data abstraction thing we're doing here. And as you can see, here's the interface we created for that OnClickHandler, which is going to return a date along with our ViewHolder. And as you can see in our constructor now, we're actually taking the OnClickHandler and the emptyView, and in fact, those are both final. So if we didnt construct them here, we could not survive as a class. So one more change we do here is that in swapCursor, we have a cursor. We can check to see what the item count is, and make ourselves visible or invisible. Very nice to have that now that we have an empty view. So thats most of the work for this, actually. But there's a little bit to do in ForecastFragment as well. So again, we already had our empty view here before. Now what we're going to do is we're going to pass that into our ForecastAdapter as well as create now a ForecastAdapter OnClickHandler that gets a date and our ViewHolder. And the reason why we're getting the ViewHolder is actually because I want the adapter position. So I could've just sent the position back, but it was kind of nice to have that there. And so that'll make onClick work again. Yeah, so that's it. We didn't have to do much at all in ForecastFragment. So that's it for this using RecyclerView part two. You guys are over the hump now with RecyclerView. You're feeling confident that you can use this in your programs, hopefully. And, let's get on to the next. So I'm almost ready to talk about how, what I did in this RecyclerView Part 3, and that was to handle items, selection, and choice, which is one of those things that RecyclerView is missing. So what I did was I created this thing called ItemChoiceManager, and this is not a complete implementation of item choice and selection. It is liberally copied from what ListView actually does internally, and you can see it actually uses a whole bunch of ListView constants. But basically it takes advantage of sparse pooling arrays and long sparse arrays and it, to store the check states and the checked ID states. And the big code that it probably, you know, takes the most from ListView is actually how it deals with checking positions by ID. This list I did not write for this. Now, this is actually fairly complicated if you see what it's doing. It checks for nearby IDs and searches through the list to try to confirm these check positions, and I think this kind of code is one of the reasons why the framework team was happy to see this functionality taken out of RecyclerView, because it is really tricky to implement. And what we do actually for this, we need to know when the ViewHolder is bound. So what we do is we actually have this work together in conjunction with the code that is in the forecast adaptor. In fact, in a weird way, this is sort of a helper for the forecast adaptor far more than it is actually a helper for RecyclerView. It also does a couple of nice things here. It actually restores and saves instance states. This I did right, mostly because I was, I wanted to kind of automatically do this. And we don't automatically have a way of saving these sparse arrays into bundles, but we do have the way, a way of saving them into parcels. So I just implemented that here. Just another function that can be called, so that we are saving these checked items. And then finally, getSelectedItemPosition, very similar to ListView, returns the first item that is selected, so if you have multiple items like it, it will return one. Otherwise, it will return zero. I did not implement the modal selection stuff, so there is none of this, you know, choiceMode multiple or whatever. But I do support a multiple modal here, and you get an exception if you try to use it, but it does support both multiple and single choice, basically adding that functionality into RecyclerView. And then so the interesting stuff, of course, is also what happens inside of ForecastAdapter. And this is pretty straightforward. Whenever we bind the ViewHolder, we also have to make sure that we call ICM.onBindViewHolder, same thing with onRestoreInstanceState and on SaveInstanceState. And we also added some helper functions, so that other things didn't have to call all the way in and get access to the ItemChoiceManager. So, like, getSelectedItemPosition, et cetera, et cetera, is also supported. We also added this nice selectView function here. And this is used to implement a feature that I thought was really really important. And so it's one of the other things I sort of slid into this one. We have this concept of auto selecting a view. I kind of threw that in here, because it was really unfortunate to have views showing up. So what I do is I wait to see that we have children, like we've been doing with these OnPreDrawListeners, and then once I know we have children, then I go in SelectView, either the position, if there already is one, or if there isn't a position, then we go and select the first one, so that we have something selected, which just looks a lot nicer when you're in tablet mode. So this is just a trick or a hack or a, you know, reasonable way of doing it, depending on how you want to look at things, but, so we're also taking advantage of that, and that's the reason why we exposed that SelectView functionality. And other than that, it, you know, looks pretty nice, works pretty well. So that's a big piece of RecyclerView. Now, the reason I didn't teach this, and I didn't have you guys code this up, is because I expect, in the next year or so, we're going to have a better solution if we're doing this kind of item selection within RecyclerView. RecyclerView is under heavy development, and there's all sorts of great stuff that's gone into it in the last six months. And I suspect more and more of these things that are missing from ListView are actually going to be in RecyclerView in one way or another. So here is my stat at doing it in a reasonable way. Perhaps the framework team will come up with something better. So that is finishing our work on RecyclerView. Again, you know, take a look at those changes. There's some interesting code in there. The next thing we're going to get into is scrolling in parallel. When I say scrolling in parallel, what I'm really talking about is Parallax Scrolling. And Parallax Scrolling as in we have different layers of views scrolling at different speeds. It's one way that we create the illusion of depth in material, and it's really easy to do with Recycler view when targeting Honeycomb and above devices. Now our app will continue to work on Gingerbread, just without Parallax Scrolling. Now we're only going to add this scrolling into our phone landscape view. And it's easy to do this by creating a view that can only be found in landscape. Inside of our landscape frag bit main, we'll rename at bar to parallax bar. Then inside of our Forecast Fragment if we find parallax bar and we're on at least Honeycombe, add an on scroll listener to our Recycler view. The cool thing about recycler view is that it unlike list view actually returns the delta x or y scroll. And this is perfect because we can use this to set translation y to move our parallaxview up and down in response to the scrolling of our Recycler view. The regular list view does not actually return you these delta coordinates at all, and it's somewhat frustrating. All right, it's your turn now. You're going to add Parallax Scrolling at half the primary scroll speed to the landscape phone view. It's going to look something like that. In layout-land/fragment_main.xml you're going to rename appbar to parallax_bar, just like I did in this little lecture. And then in ForecastFragment you're going to add an onScrollListener to our Recyclerview. And then in the onScrollListener, you're going to change the translation y of the parallax bar in response to changes in scrolling. Now, we're scrolling at half speed, so you'll want to change the translation by half of the scroll deltas. And of course, you'll want to make sure that you limit the deltas to approximately the negative height of your view. Finally clear all your onScroll Listeners in onDestroy, very easy to do. All right, you're done. Let's take a look at how I did it. Now we only want this parallax scrolling to work in phones in landscape mode. So we're going to edit fragment_main in landscape. And what we did is we took app_bar and renamed it to parallax_bar. This way our code will find that, and only actually do parallax scrolling when in the landscape orientation. Everything else we're going to do is going to be inside of our actual fragment. So, inside of onCreateView, so inside of forecastfragment, we're going to look for that parallaxView, which is the view that we just renamed that's in that layout landscape for our fragment. And then, if we're on that end, we're on Honeycomb or greater because what we're going to use this setTranslationY, is only available on builds greater than Honeycomb. And we really have two options here, we could actually use these very very cool classes that do view compatibility. So I could have actually done this in here and said. You know, ViewCompat.setTranslationY, and then put parallaxView inside of this. But, since I don't want this code to run at all and waste any time for running anything less than Honeycomb, I'm just going check to see whether this build version is greater than or equal, and then if it is then we add the onScrollListener. So pretty straight forward. And then what we do, is we get onScrolled here and this actually one of the beautiful advantages of RecyclerView for us, is that it actually gives us dx and dy, for our scrolling which is much much better than what ListView does. ListView just tells us which list item we're scrolled on and then makes it rather challenging to actually calculate the dx and dy correctly. And so what we're going to do is set a max here. And we're calculating this every time. This isn't really necessary. A little bit expensive. But, not too bad. And that's going to be the max we're going to scroll. Max is here, so we just scroll it just off the screen when we're scrolling up. And this actually causes a little bit, because we set the max to the exact type, you'll notice this causes a slight bit of artifacting. Because you'll actually see the shadow is actually going to be still slightly visible on screen when we scroll up. So setting it exactly to match, probably not the best idea, but it works pretty well. And then we're going to take advantage of this function that again was added in Honeycomb called setTranslationY. Now you'll notice that these deltas are actually going to be in positive quantities, but we're actually going to be setting our translation in negative quantities. So positive means we're scrolling up, negative means we're scrolling down, in terms of the onScrolledListener, but in the case of our translation, we're actually going to be translating it the opposite direction. Not that that's particularly confusing, but you'll see what we actually do here. And just to make it a little easier I'm going to add some very nice spacing. So we're going to setTranslationY to do that, and in that case, and again, if we're greater than zero, it means we're actually scrolling it up, and so what we're going to want to do is scroll the reverse of that. So we're going to take the existing translation, subtract dy, then in order to get it to scroll half the speed of the outer view, we're going to say that divided by 2, and because of order of operations, this is actually going to turn into parallaxView.getTranslationY minus half of dy. And then when we're going in the other direction when dy is less than zero. We do the same thing, we subtract dy. Except that we're only going to scroll until we hit zero. And here we're going to scroll until we hit negative max. Pretty straight forward. And that's it. That's all the code we need to do this whole parallax scrolling, so it's actually really really simple. It looks really pretty, and this is one of the nice things about RecyclerView, again, is that it gives us the ability to do this kind of thing really, really easily. And on destroy, I do go and clear all on scroll listeners. And it's important to do this in general when we have any listener going on. It can prevent the garbage collector from being able to clean up our whole activity if we don't do this on destroy. So it's kind of important to do this. I don't know if it was really needed here, but put it there anyways. And that's it. That's all we have to do and we have beautiful parallax scrolling and let's bring that up in the emulator to take a quick look at what that should look like for you. There we are. This is the cool version of sunshine, as you can see. We now have exciting parallax scrolling which is really cool. And, you also notice we have the margin here at the top, nicely done now. That's because RecyclerView actually will respect those margins that we put into an element. So that's also kind of a nice little advantage we get there. And that's it. That is parallax scrolling. You can see it works very nicely. We scroll off, we scroll on and it actually scrolls at half the speed. Follows it quite nicely. So, pretty easy to do that kind of effect, and it's nice that we have these toolbars where we're actually scrolling the toolbar on and off as well. I'll be doing this. And actually if you notice, because translationY actually translates everything correctly, we're actually maintaining the correct position there. So then we scroll that off, we really can't click there anymore. It really is truly scrolled off, which is pretty nice. Alright, this is one of the things I've been wanting to teach you ever since we started learning about design, and this is about animating transitions. It's easy to throw in some Android L activity transition animations to spice up our application. In Android 4.4, we added our transitions framework but in Android L, we made it easy to apply these transitions when moving between activities. As you can see clicking on an item in our forecast list causes custom animations to occur as we transition into the next activity. The toolbar at the top and the bottom details move into place and everything else fades. Hitting the back key causes a slightly different animation. Just the bottom moves out, and everything else fades. This was done by first creating a transition resource. In this case, our transition resource contains a transition set for how we want our views to move. We want all these animations to play together for a duration of a half a second. We want everything to fade between the views, except for the status bar and the navigation bar. If we don't specify a target in a transition, it will apply to all views. Exclude ID tells our fade to apply to all views that aren't in another transition. Pretty handy. We're going to have our toolbars slide in from the top. And the detail pane slides in from the bottom and that's it. We could do a lot more, but too much animation can be distracting. Now we still have to tell Android how to apply the theme. I'm going to add it to our custom theme. We could specify it in code, but I recommend doing it this way. It's nice to be able to change all of this from resources. Note that we are both applying themes here, and setting a window flag to enable content transitions. Content transition must be enabled in both the starting and ending activity. And then we still have to write a tiny amount of code to enable a scene transition. When we call start activity, we need to give the system a special bundle. Fortunately, ActivityCompat will do the right thing for us. And that's it. See the instructor notes for links to learn more about animations and the transition framework. Now its your turn. Add activity transitions between the main activity and the detail activity for both portrait and landscape views. So, start by creating new themes, the main and detail activity and applying them in the android manifest. The, create enter and return transition resources for both portrait and landscape that match the video that we have playing here. Note that the animation resources for the main activity just set the window content transitions flag to true. Add the transition resources then to v21 versions of the app in detail activity styles, and the start the activity using the bundle from makeSceneTransitionAnimations. All right, you're done! Let me show you what I did. So the first thing I did was create some new themes. I created an AppTheme.Main and AppTheme.Details. And those are both derived from AppTheme. And I have put them in the main styles just so I can keep them there. And I'm mostly keeping this stuff out just because it's nice to keep all this v21 stuff out of the old, old Android Stuff. So then we go to v21, and I have actually created these styles now with name. Just turning windowContentTransitions on, and then details referencing these enter and return transitions. Which look a lot like the ones that I showed you. So if we look at our transitions we actually now have transition resources. As you can see we have two different kinds of transitions, one for v21 and one for landscape v21 which is pretty cool. So, in the case that we are in non-landscape it's pretty straight forward. It's exactly what I showed you before. We're ordering them together. It's a half second long, we're going to fade everything that's not the status bar and nav bar. We're going to slide the toolbar from the top, and we're going to slide the additional pane in from the bottom. So very, very straightforward. And for landscape, the only difference is we're going to slide the additional pane in from the right, because that looks a lot nicer. Then for the return transition, we slide that one out from the bottom in the case of portrait. And in landscape, we slide it off right. So, very, very straightforward there, in terms of adding the transition set. And then the only question really is, where do we actually go to kick off our animation? And, of course, a good spot for that is in MainActivity. MainActivity knows a lot about what's going on, but it also is a thing that actually is responsible for launching this. MainActivity, if we're not in two pane mode, is actually responsible for launching that next activity. And we just call ActivityOptionsCompat, makeSceneTransitionAnimation and then start the activity. And we are done. And we have a very, very simple transition. Material design says that motion design can effectively guide the user's attention in ways that both inform and delight. Use motion to smoothly transport users between navigational contexts. Explain changes in the arrangement of elements on a screen. And reinforce element hierarchy. We aren't really doing that yet. But we can add something that does, a shared element transition. When we talk about shared elements, we're really talking about Android views that contain content that is shared between two different activities. We animate the transition between the activities by moving and scaling the element into place, which draws the eye to the element and creates continuity between the two activities. It's relatively easy to add a shared element to the transition we've already created. We first need to tell Android which views in both activities are paired up. We start by adding a transition name to the view in the destination layout. We'll also want to add a transition name to any view that we're transitioning from. So that the system can find it again in case it has to tear down the activity, thanks to rotating the device or some other hardware change. If the shared view is filled out when the activity is first created, that's all we'd have to do. However, many activities do things like create a fragment and then need to go to the database to fetch the shared element. Both of which typically involve asynchronous tasks, and we are using best Android practices. We also want to wait for any layout to be complete. Fortunately there's a solution for that. We can ask Android to wait before beginning the transition using supportPostponeEnterTransition. And tell it we're ready by using supportStartPostponedEnterTransition. We have to a bit careful here about how long we postpone things, as we've pretty much stopped the world in motion when we do this. I.e., going out to the network while we postpone things isn't going to work well. Since I try very hard to keep display-related logic in layouts, I'm going to create an attribute to enable postponing the enter transition in forecast fragment. I then read the attribute in the onInflate method. For the detail fragment, I'll add a flag as an argument and read it during the onCreateView method. Now it's your turn. Add a shared element into the transition between the main activity and the detail view. First, create a string for the transition name and add it to the detail icon in detail today grid. Then, add a unique transition name to each icon view in ForecastAdapter. You'll want this to be the same across runs. So I recommend using the position within the adapter to make the name unique. Add the view holder to the on item selected callback, then add a pair to the make scene transition animation and mainActivity, and call support and postpone enter transition. And support stark postpone enter transition appropriately. As I mentioned before, I used an attribute in the forecast fragment to determine whether I should start postponed animations, an argument for the detail fragment. For recycler view in the forecast fragment, I recommend waiting until it has laid out its children, which we already do in the on predraw listener we add during onload finished. In the detail fragment, during onload finished is fine. All right, you're done. Let's talk about how I did this one. First thing I did was added the transition name to the detail icon. In this case, detail_icon_transition_name. Of course, non translatable, since there's no point in translating something that's used by the system. And I called it TN_DetailIcon. Which isn't particularly important. The next thing I did, and this was specific to implementation. But I suggested it so some of you might have done it. I added an attribute to the ForecastFragment stylable called sharedElementTransitions, and it's a boolean fragment. So, this way when I create the ForecastFragment which I create in XML, I can actually pass this as a parameter. And that way I'll know whether to do any shared element transitiony stuff in the fragment. All right, so you can see I actually take advantage of that attribute in activity_main. And we only have to do this of course for the non-tablet version because we are only doing these transitions for the non-tablet version. And we set sharedElementTransitions=true. That's great, because now, my fragment code can actually know that for the phone version that I actually want to execute this code for postponing, etc. Let's take a look at that fragment code. So first of all, I declare an mHoldForTransition flag. And then, in uninflate, I set this flag, based upon this stylable here. Defaulting, of course, to false. We actually use this, sort of, in on load finished. Remember, I actually want to know when the RecyclerView views are actually added. So we use this view tree observer here to find out when that happens. So if we're in mHoldForTransition state. Then, at that point once I see that I have views in my view tree for the RecyclerView, I can call support start postponed enter transition. Now not, it's actually pretty safe to call support start postponed enter transition in any case, because as you can see I'm not even using the flag in the case where there's no count. It was kind of a impressive effort for something that wasn't particularly needed. But there, you can see that's how we're using it in the case of ForecastFragment. Now, for DetailFragment we do something slightly different. So, you can see I created a string called DetailTransitionAnimation here which is a string that is package visible, inside of DetailActivity, which of course only gets called if we're not in two-pane mode, if we're in phone mode. We can add this argument for the detail transition animation to let our fragment know that it's actually going to be executing those shared element transitions. So then, inside of DetailedFragment we declare mTransitionAnimation here. And then in onCreateView you can see we're setting mTransitionAnimation. Based upon that string being set that we just created. And then, the important thing is an on-load finish. We actually call support start postponed enter transition. One thing I should mention is where we actually stop the transitioning from stop the transition from happening. That's really important. So we want to stop it as early as possible. So we actually stop it inside of detail activity right here, supportPostponeEnterTransition. And it's really, really important that after we do this we really start the transition up again. Because we are now stuck in this state. The system is waiting for that to happen and we do a similar thing inside of our MainActivity, so we do this on ActivityCreated. If we have mHoldForRransition, and not ActivityCreated inside of our Forecast Fragment, we then stop the world to wait for that transition to happen and the only time this is actually important is when we're transitioning back from. Another activity, and perhaps we've rotated the screen so we've been destroyed. So this'll give us a shot at actually having that icon transition back even though it's transitioning into a brand new activity. It's kind of cool and it works. On the other things that I did, which are probably worth mentioning is I wanted to align up the animation better. So I actually changed the duration of these animations to 250 milliseconds, which is a lot closer to what the systems actually using for these transitions, so it just lines up all the animation really nicely. And as I like to try to do, let's run this in the emulator and see what we get. So here we are, as you can see when we click on one these guys we get a nice little animation. And we can even rotate the device here. And if we're lucky, it'll animate back down, which is pretty cool. Even though you're even off the screen, it still sort of found it. So that is activity transition animations. And it really is pretty fun to play with. Now, inside of our forecastAdapter we're actually going to give that icon view a transition name of its own. And we're going to do this based upon position. And the reason why that's important is all of these have to be unique within the RecycleView. This is the name that Android will use when we return from the activity. If you try to restore the animation. As you might recall from early on, one of the things our design calls for is scrolling of the app bar. And to do this scrolling, we're going to make use of a brand new support library we've created to help with material design. The design library. This library contains tons of stuff to help you implement material patterns. It supports all sorts of app bar buttons, including collapsing toolbars with floating action buttons, collapsing toolbars with pinning, app bar scrolling with pinned list, parallax scrolling with underscroll, parallax scrolling with collapsing app bars. And it's a lot more than just app bar pattern, it also supports things like navigation views. Snackbars and floating action buttons, tab layouts with fixed and scrolling tabs, and material text input with collapsing hint texts. These tools and more open up the palette for Android developers to easily implement more material design And to do so in consistent ways. The key to how most of this functionality is implemented is the CoordinatorLayout. CoordinatorLayout is part of the design library, its basic functionality is similar to frame layout. Any views that are placed in a CoordinatorLayout overlap by default. You can use layout gravity to align the views within the layout. Similar to relative layout, views can be positioned based upon sibling views, except in a more limited way. Gravity can be applied, position of view center, up, down, left, or right, with regards to the parent view. Most interestingly, CoordinatorLayout supports behavior classes that can alter the layout. When we use a snack bar, and we have a floating action button inside of a CoordinatorLayout, the default behavior for a floating action button will check to see if there are any overlapping snack bars and automatically move the floating action button out of the way. AppBarLayout is a special kind of linear layout that works with CoordinatorLayout to animate various kinds of toolbar patterns during nested scrolling with a sibling view. Each child of AppBarLayout takes layout scroll flags, defined the behavior when nested scrolling is taking place. And the sibling to the AppBar is given the AppBar scrolling view behavior to coordinate with the AppBar. So, this is how our AppBar will scroll of the screen when we scroll our recycler view. We add the CollapsingToolbarLayout to the mix for some of those really fancy animations. It allows you some really complicated transitions. And the best thing is, you can create all this complex behavior in XML layouts without having to touch the code. All right, now it's your turn. Implement AppBar scrolling into the forecast fragment layout when in phone portrait mode. First, we're going to add the design support library into app dependencies. And then we do all the rest of the work inside of fragment_main.xml. We begin by converting the base view to a frame layout. You might be able to use Cordinarily out here, but I ran into life cycle problems when I tried that. Wrap the toolbar in RecyclerView with a Parent Coordinator Layout and then wrap just a toolbar with a Parent AppBar layout. Add the scrolling view behavior to the RecyclerView. There is a string defined for this in the design's support library. Add the scroll flags to the toolbar. I chose scroll or with Enter Always to get the behavior I wanted. Finally, we anchored the empty view to the RecyclerView, taking advantage of the frame layout type properties of Cordinarily Layout. I also set Anchor Gravity to fill, so the empty view fills the space. All right, you're done. Let me show you how I did it. So the first thing, of course, we did, we added the design library into the dependencies. Now, I did this using the user interface, but, this is actually what it did. Note that we also want to make sure we are using a compatible version of everything. If we have an old version of appcompat in there, it's not going to be compatible with design. So you want to make sure all these versions match. So it's probably good to go and look in here if you're running into trouble because they have to match. All right, hopefully it wouldn't compile if they didn't match. Now as I said, I did use a frame layout here. I ran into a bug that I couldn't work around without this. It shouldn't really be necessary. CoordinatorLayout should be able to be the outside layout. I'm using an early beta version of this library. So it might actually be fixed, but just in case, I'm leaving it in this way. We have CoordinatorLayout here, which is doing all the fun work of actually coordinating what's going on between our views. It's our nested parent. AppBarLayout is actually used to scroll the app bar. And inside of that, you can see we have our Toolbar containing our ImageView just like we had before. So, no real difference here. The only note is that we have to have scrollFlags now, scroll|enterAlways for our toolbar. And our AppBarLayout is going to use that to define behavior. We could also pin it or do one of the other cool things that AppBar can do with these flags. And then below that, we have our RecyclerView, and we had to add this layout_behavior, so app:layout_behavior = our scrolling_view_behavior. This is actually defined in the design part of the support library. And it is associated with our AppBar. And note that we are actually inside of CoordinatorLayout here, not inside of AppBarLayout. And so this is what actually connects it all together. Finally, for our TextView, which is also in our CoordinatorLayout for empty, I decided it would be cool to anchor it to our recyclerview. If you scroll while you are in the empty state, it will still scroll up the AppBar, and this will actually follow it, which is kind of nice. And so that's it. That's all we had to do was modify this XML layout, and we now have these lovely, lovely scrolling AppBars. Right now, we have material sliding through material on the same elevation, which is something the spec frowns upon. What we'd like to do is something more like this. As you can see, the app bar gains in elevation, casts a shadow, when the content slides under. Fortunately, we have a callback for when the RecyclerView is scrolling. I just realized there might be a small percentage of you that would feel intellectually compromised if you didn't get to implement this effect. This is your chance to pause the video and attempt to do it yourself before I show you the answer. Okay, last chance, and here goes. Here's how I did this. Inside of onCreateView, right after our parallax stuff, I checked to see we have an app bar. If we have one, I start by setting its elevation to 0. I then I add an OnScrollListener here. And whenever we scroll it we check the vertical offset of the RecyclerView. If it's zero then we know we're not underscrolled and we set the app bar elevation to zero. Otherwise, we're underscrolled and we actually set it to its TargetElevation, which is something that app bars do that's kind of cool. And with that, we get this nice underscrolling effect. It's a little hard to see on the tablet perhaps, but there's actually a little shadow there you can see that's being cast. It's a subtle detail, but once again, I always say when we're doing these final steps, it's that last 10% that really makes an enormous difference. And sometimes, it's the last 1%. We first went to our design team to get a design that not only better reflects material, but provides substantial improvements in utility. Weve looked at the material design specification. Specifically, how colors, elevation, and animation can be used to create delightful user experiences. We covered tools and technique to help create both material design and responsive designs, including Toolbar, CardView, Recycler view, and GridLayout. We've looked at using dimensions, graphs, and included layouts to simplify our responsive designs for tablets. Finally, we've covered some simple techniques to create L specifics and L style animations in your applications. With all of this, we've implemented a new, completely refreshed design for Sunshine that brings us much closer to a production application. All right Dan, this was obviously a lot of work, and it looks great. Hey Dan. Do you want to come up and join us? Does that mean what I think it does? I think it does. Come on up. [SOUND] [SOUND] Dan, we'd like to give this to you. We think you've earned it. Let's finish Sunshine. Because of sunshine, I ain't been sleeping. I dream of dreaming the night away. So if you happen to catch me napping, you can blame my sunshine always. Okay, so a final checklist. Yes. All right, tests are all passing. Mm-hm. And the error cases? Done. The new onboarding flow? Beautiful. Yes, and those material design guidelines? Completed. And then perf? Well, performance looks great on my new phone, but this older phone performance is a little. Don't say that word again. What performance? Behold, it is I, quote Master of Fame, wait a minute. I've been here before. And now your back. What's he doing here? If you say performance three times, he'll just magically appear. Ian, Joanna, what are we doing here at Udacity. I thought we already had a course on performance. So we do, and that's why we actually don't need you. It was an accident. The words just kind of fell out of his mouth. And we definitely don't need to you to go through any Apps. We don't have any- Whoa. Wait. What are you talking about? Do you have a bad performing application that you need help with? I knew there was something wrong here. [LAUGH] Well Cole, I don't know if you noticed the performance stuff, but. Maybe you can help? No, no, no, no, sorry, no thank you. We don't need your help. The thing is if we actually know what we're doing, and we don't need him to kind of jump in and help us because we can go through this ourselves. Joanna, Joanna, nonsense. I'm here to help. Why don't we go ahead and take a look at things. Open up your application on your phone and why don't you start by telling me what you've been seeing in some of the profiling tools that you've been running your app in. Well, we actually haven't run any tools yet. Performance has been great. Wait, are you joking? Is he joking? Seriously? Are you people punking me? Are you recording this for a gag real or something? What's going on here? Can you just give me a minute? We haven't tried any tools yet because we haven't started working on Perf yet. Madam, you insult me. Performance isn't something you just idly cast about and handle at the end of your application. When you submit your app to the play store. Users give negative feedback on it, three times more active than any other thing in your application that they actually hate. That alone means that performance isn't something that you cast off until the end. You bring it up to the front, you should be doing it the whole way. Okay, take a breath. Are you breathing? Don't you to fall. That would be a terrible shame. So what we're actually trying to get at here, is that we have all of these difference perf tools that are available to help us see a bunch of different problems. And kind of walk us through where maybe there's some issues. Right, there's like trace. Exactly, just like trace. Yeah, and we actually have a whole federation of applications you can also run on your application- Okay. Okay. Thank you for jumping in. Your knowledge is valuable. I was talking. What we're trying to say here is there's more than just trace view. It doesn't end there. We actually have a different tool for a bunch of different situations. Maybe you want to look at your rendering perf, right? [COUGH] Overdraw tool. Mm-hm. Or maybe you want to see how your memory's being used. [COUGH] Memory allocator. The point is that you have a different tool for different situations and you can actually use several tools together to narrow down where the real problems are happening so you can focus your efforts on fixing the real problem as opposed to maybe hiding. Which, by the way, we talk about in great deal in our Android Performance Course here at Udacity you can click on in the instructor notes. I know, I know. You made a course. We all know. We got the tweet. Yeah, I saw the tweet. So, Cole, we really should be testing the performance before we ship. Oh, yeah, absolutely. Some of the best engineers I've ever worked with in my career have all been performance minded. In fact, some of the greatest companies we have out there will actually create unit tests entirely focused on performance. So that they can actually find any performance regressions that occur to the line of code that's checked into their source tree. There's some really exciting stuff going on right now out there. It's so exciting, just like your mad scientist lunch that you have every month. Hey, hey, that's a little below the belt. What is your problem. I am here to help. You guys summoned me here to solve your problem that you have in performance on your application. I'm going to step out and get some water. You guys chat. And all you've done is give me grief about this. What's going on? Because I didn't summon you. You jumped in because you heard there were performance and you care a lot, except maybe some people want to do their own perf work and don't want you doing it for them, because believe it or not, I know about Android performance. And I'm good at Android performance, and I'm good enough to teach other people about it, so let me. Okay, so you think you know what you're doing, huh? I do, I do, Prove it. I will. I'm being summoned. This isn't over. [SOUND] [SOUND] Okay, so now that he's gone, I'll actually walk you through the tools, and you can see what we're talking about without him interrupting again. You might be sitting there thinking that Colt is over doing it a bit. After all, he does have a tendency to come on strong. And anyway, performance is important in that way that dental cleanings are. Everyone knows you should think about getting them, but nobody really wants too. But as any grandmother would tell you, you don't actually have to floss all of your teeth just the ones that you want to keep. And similarly, you don't need to think about performance for all of your apps, just the ones that you want to succeed. Because Colt brought up a good point. Users will complain about app performance three times as often as any other issues. So keep in mind that just because your app works beautifully in your development environment with its perfect Wi-Fi on your fancy new test phone doesn't mean it will always work well. As a developer, your goal is to keep your app rendering at 60 frames per second. This means that you have 16 milliseconds to finish all of your computation and drawing for the next frame. If you miss the 16 millisecond target, you'll have a dropped frame, which will cause your app to skip. So, you'll want to use this time wisely. A common you've probably encountered is overdraw. The idea here is that you draw a layer. Great. But then the next layer you draw obscures a portion of that initial layer. You just wasted precious time drawing all of those pixels that were drawn over immediately after. There are two ways to tackle overdraw issues. The first is to remove unnecessary backgrounds and drawables, such as a base white background on your top most layer when you're completely obscuring the layer out with other views. Or you can mark certain portions of the layer as visible or not visible. Especially with stacked views, this will help by only drawing the visible portions and ignoring the rest until it's needed. Your device has a pretty nifty developer option for showing GPU overdraw. Once you toggle back to active, you'll notice that your layouts are all drawn with a tint. A pixel drawn once is shown in its normal color. But when the pixel is drawn over itself, it's tinted. You've got blue for one overdraw, green for two, pink for three and red for four or more. Clearly, the goal here is to minimize the amount of red, and keep everything fairly blue. To see how this works, we'll look at Sunshine both before and after Dan updated it with a look inspired by Material Design. You'll notice that most things are pretty consistent, except that after material, everything is a shade or two darker on the tint scale. This is because material design focuses on beautiful components and transitions. And so it comes with a heavier drawing cost. Some events have a heavier cost as well. Clicking, for example, tends to result in a shading effect as an indicator of the action to the user. You can see this with a red overdraw on a touch event. With material design, though, we increase the number of these types of smaller overdraws with the addition of animations, such as the scroll animation or the hover action in the menu. These animation elements add a bit of magic to the app and help create a beautiful user experience, but as you've seen, there's clearly a rendering cost. Perf considerations are a trade-off. You want to do fancy things, but you might be doing too much, so use your tools to set up a regular testing process and then evaluate why your changes for the better versus how it could be improved. Some tools are built into the device, as you saw, but others work by monitoring your device during normal use, these are generally available through Android Studio. For example, consider Memory Monitor. Memory Monitor works by tracking how much memory is currently allocated, and can be a great way to see how specific actions or events can affect your heap. Here we have Sunshine, and you can see how several events claimed additional memory. These were clicks from the list view to the detail view and back, and required memory for the detail fragments. And here was a change in the location setting, which sparked a new sync for new weather data. You can also see when garbage collection events occur, as the free space increases when this memory is reclaimed. So by now, you probably believe me that there are plenty of tools out there. So let's consider a hypothetical. What if you have a screen animation that is freezing up, but all of your rendering seems to be working correctly? Which tool would you try next to narrow down the cause of the problem? TraceView to see if it's a processor issue. Memory Monitor to see if it's a memory churn issue. Or HeapViewer to see if it is a computational problem before the drawing begins. So, any one of these is actually and okay answer. That's kind of the point to perf. You may need to try several tools to narrow down the root cause of a problem and not just the symptoms. As we move forward you need to make the perf tools an essential part of your development and testing process. So to learn more about perf take a look at Colt's course. He'll walk you through several problems, and he'll teach you how to use the right tools to identify those issues so that you can understand the problem areas in your own app. Okay, great, I went over the perf-tools, and that means that we're done. Yes, performance is a check, each one of the performance tools solves one of our performance problems. [SOUND] No. Oh, come on! [NOISE]. Design. Congratulations, everyone. You've finished productionizing the Sunshine app. But isn't there always room for more sunshine? You know, there is, Dan. But now it's time for the students to go and finish their final projects. And you can find a lot of the resources you need to build a great mobile app on the Android developer site. And stay tuned for more from us, and Udacity. For now, let's celebrate with some cake. Ooh, marshmallow. Nougat. Cheers. [MUSIC] Given how important getting a location is to getting good weather information, this is a lot harder than it should be. Typing, really? Yeah, it's not good. I mean, Dan tried to fix it a bit with the whole validation stuff. But, I mean, it's really obvious to me how there are some ways you could make it even easier. Okay, so why don't you go do them? Okay, calm down. I got this. Magic moments happen when your app does something so that your user won't have to, like figuring out their location for them, so they don't have to type on that tiny little keyboard. In Sunshine we ask the user for their location, but the Google Maps platform provides location services that could allow us to get a location automatically. The Places API was released earlier this year and includes a variety of helpful location services. For example, the auto complete API offers your users the power of predictive auto complete for places with a user experience similar to the Google search box. You can also get the user's current location, get a place by ID and even add a place to the Google Places database. But for Sunshine, we're going to use the Place Picker because it provides a UI dialogue that displays an interactive map, and a list of nearby places, from geographical addresses to local businesses. Users can then choose a place that is passed back to your app. You could always develop your own location widget, but there are several advantages to using the Place Picker. First and foremost, the user experience will be consistent with other apps using the Place Picker, including both Google apps and third-party ones. This means your users will likely already know how to interact with this widget. Second, accessibility is built in, and you should already know how important that is. But finally, it saves you development time so that you can focus your efforts on the features you care the most about. Before we begin, we should take a moment to discuss API usage limits. It is important to Google that developers have access to as much capacity as they need to be successful. And so, usage of the Google Places API for Android is free and unlimited for all apps. However, to ensure fair use by all apps, there are tiered query limits on some methods. The Places API enforces a default limit of 1000 requests per 24 hour period. There's another checkpoint when your average is 150,000 requests per day. If you exceed either of these thresholds, your app may start to fail, as further API calls are denied. So to avoid this, we have a simple review process in place to be granted a higher limit. Instructions on this review process can be found in the documentation linked, in the instructor notes below. But because of these usage limits, in order to use the API, you will need an Android API Key. If you fail to provide this, you may notice that the Place Picker widget will launch, and then immediately close. It's an interesting error to try to debug. So to get properly configured, and create your API Key, you need to return to the Google Developer console. Remember how the Google repository provided access to a number of Google services, but in order to use them we needed to be certain that the user's device had the STK up to date and enabled. You want to check that this is true before attempting to make a call to any Google services. And more importantly you want to build in graceful failures. So do you recall how when we were learning Google Cloud Messaging I mentioned that there were two approaches to doing this check? For GCM we check if the SDK is available when the app activity is created. And if so, we register to receive messages. But if this registration doesn't happen, the user never gets a severe weather alert. But they also never know that they are missing out on the feature. The other approach was to perform the check at the moment when you are about to make the API call. And this could allow you to display different layouts depending on the results of that call. And that is just what we want to do for the place's API integration. Ideally, a user should not even know that they may be missing out on the place picker. That means that we need to structure our UI so this features only appears to users who can use it. So, let's take at how we can build our location preference dynamically. Currently, our setting view is a list of preferences. Dan showed you how to create a custom preference for location. But what we want to do now, is to extend that custom preference by adding a widget to launch the place picker. However, we only want to show this widget when Google Play Services is available. This way, devices without Play services can avoid displaying a broken feature. We already have a check for Google Play services in main activities OnCreate because of our GCM integration. However, we cannot assume that the user's device will not change between activity creation and the active state. So, the first thing we are going to do is to perform an additional check at the moment we display the location preference, in case something has gone wonky. Theoretically, you could move the existing GCM check from on create to on resume. But, these are two different features that are just powered by the same service. And we actually have different expectations for each feature. GCM needs to be configured at the creation of the activity. But the place picker needs to be supported each time the user enters the setting activity. So we don't want to be checking in on resume, which means that we should call is PlayServicesAvailable in our location edit text preference class. Note that we aren't handling any potential recoverable errors this time. Because, in the middle of changing a location for the weather forecast, it would be really disruptive to direct the user directly to the Google Play Store for a potential update. So, instead, our failure case is that if the SDK is not immediately available, we just use the default settings layout. However, if it is available, then we're going to add a widget to the location preference that can launch the place picker API. So, now we need to create a pref current location layout. This is going to be the icon that we're going to add to the location preference. Because we want a simple visual queue, it's best to use a system icon that the user will already be familiar with. All of the Android system icons have been updated for material design, and can actually be downloaded off of GitHub. You just need to make sure that you get the right size for each drawable density that your app supports. For Sunshine, that'd be these four. Because our place picker is intended to make it easy for a user to indicate their current location. You should retrieve the current location system icon from the map set. Then all I need to do is to drop each resource into its relevant folder. The layout that we need, then, is a simple image view of our system icon. However, our icon is very small. But, if we wrap it in a frame layout we can make a larger click space without having to scale the icon. All we need to do is reference the ID of the frame layout instead of the image view when we build our click listener. You'll also want to make sure that all of your icons are visually aligned. So to do this you'll want to set the layout_gravity. You'll also probably want icons to match in color. So just go ahead and add a color tint in order to get the icon teal instead of black. And finally don't forget your content description. You'll need to write the string and strings.XML so that it can be translated and then just reference it here. Now that our layout is ready to go, we need to set up our OnClickListener. When the location preference is created that calls onCreateView. And then this call back, we can retrieve our new layout, and set our OnClickListener. For now, just go ahead and use a Toast to test that everything is working. So to review, this first step is all about our layout. You need to create a new layout for our getting the current location. And also grab the system icons. But then you need to modify LocationEditTextPreference to issue a toast when the widget is clicked. Also, make sure you are only displaying the widget when Google Play services is available. So to see the code that we went over, check out the GitHub commit link in the instructor notes below. You'll need to implement each of these changes in your app before moving on. And once your code is ready, go ahead and just click here to let us know. Settings activity is tied to a list of preferences. And the location edit text preference is a custom preference that we have added a widget to. That widget, when clicked, should build an intent and start the place picker activity. And when that activity returns, it should have a place for us, which means that we need to process the result of the place picker called in on activity result inside of settings activity. And if we have a new place we need to store that in our location shared preference. Of course, before we can do this we have to configure our app for the places API. We need to add another dependency to our build.gradle. Recall how Google Play Services allows you to specify the bundles that you care about and ignore the others. We already have the GCM bundle but now we need to add the location one. Then, to use the place picker, we need to add a permission to our Android manifest that will give us access to location at a fine-grained detail. Now let's look at our place picker backwards. What will we do once we have the place picker response? In on Activity Result and Settings Activity, we need to parse and store the address as our new location for Sunshine. First, we should verify that this activity result is actually intended for us. And if it isn't, the place picker response will pass it along to super in order for them to handle. If it is from the place picker and a location was chosen, then we can fetch the place object from the place picker API. Then look at the address to use as a human readable location string and store this in our shared preference for location. However, if the result code is not successful, we're going to gracefully fail by not doing anything at all. The most likely cause for this is the user hitting back without choosing a place at which point, returning to an unchange setting screen is the correct thing to do. To launch the place picker we need to build an intent. But we are in a view not an activity, which means we won't be able to call start activity for a result. So, we need to cast the context to a specified activity. In this case, that would be settings activity. This will allow us to make the call to start the place picker, and by choosing settings activity, the result of the place picker ends up in the right place. I'm going to let you figure out how to build the intent and launch it however. I've shown you all of the framework for working with the Place Picker. And to see those code changes and integrate them into your own version of Sunshine, check out the GitHub commit linked in the instructor notes. Then take a look at the Place Picker documentation to determine how to build the intent, and how to launch it. And when you are done with the HP's, let us know by clicking here and here. So, this should have sounded scarier than it actually was. Building and launching the place picker intent is actually no different than building any intent in starting it. You just needed to use the place picker API to get your builder for your Intent. And then you also needed to create a request code so that your app could distinguish the place picker activity result from all other activity results. Running Sunshine at this point should show the place picker on a click but not actually do anything with that new location. This is because we haven't informed our sync adaptor of the change. So let's do that now. Unfortunately, we don't know what kind of result will be returned by the place picker. If we get a place, we know that we'll have an address, but that address could be anything, from a city name to a business name, or even empty string. So we can't reliably form a request to the weather service off of this string alone. However, a place object also contains a latitude and a longitude. And open weather map supports queries by LatLong, so what we need to do is to store the address as our location string, but store the LatLong as our location query. To do this, let's begin with the simple things. First, we need to declare two new preference keys, one for latitude and one for longitude. Then we can create new utility methods to help us out. One each to get the value of the latitude and longitude out of their preferences. And then a third method to check for the existence of these preferences. And these preferences will be our indicator that we are using a place picker location, instead of a user entered string location. If the user decides to replace their location with the string later on, we'll wipe these preferences, as a signal to stop forming the query with a LatLong. In sync adapter, instead of always building the query based off of the location string, we want to, potentially, build the query using a LatLong value. So first, we need to check if we have a LatLong to work with. And if we do, we're going to build the request using LAT and LON. However, if we don't, we're going to build it the way we were before, using our location string. The rest of the URI builder remains unchanged. However, since we are dependant on the existence of a LatLong preference, as a signal that we are using a place picker location, we need to wipe those preferences when the user enters the location string manually. So in settings activity in, onSharedPreferenceChanged, you'll need to do this whenever the location is updated. This method is an automatic callback that is invoked by the dialog preference class. Because our place picker was an intent launched by settings activity, it won't ever trigger this call back. And so, this is a safe place to reliably wipe the Place Picker LatLong, whenever we have a manual entry. Because we don't trigger their callback when returning from the Place Picker, we'll need to tell our sync adapter that something has changed in on activity result. First, we'll update the preference summary string in our settings UI, and then we'll ask our sync adapter to fetch new weather data. This should all happen after the new preferences are written. And that is why we use commit, instead of apply, when we're writing to our shared preferences. Commit ensures that the preferences are ready in time for our sync it after update, whereas, apply is asynchronous, and can't make the same guarantee. Now as for, actually, writing the long preferences, I'm leaving that to you. To see the code changes up until this point, and integrate them into your own version of Sunshine, check out the GitHub commit linked in the instructor notes. Then take a look at the place documentation to determine how to retrieve the LatLong object. >From that object, you'll need to get each value separately, and write it as a float into our preferences. When you finished, click here. Getting the latLong object is actually pretty simple. You also want to use the latitude and longitude to create a location string to display whenever the address is empty. Then, writing these values into the preferences is simple, with a reference to each field inside the latLong object. Now, Sunshine should run properly, and returning from Place Picker, should update the location string as well as the weather forecast. Also, remember to test that updating the text dialog continues to work properly as well. There is one final step that you need to consider before this place picker integration is complete, and that is attributions. When displaying data from the Google places API for Android, such as auto complete results or place name and address, there is some attribution and Google local requirements that you must comply with. The requirements apply to the Place Picker UI widget as well any programmatic API calls. So if your app has retrieved a place via the Place Picker and then shows this data on a follow up screen without a map, the app must also show attributions on this follow up screen. So we have the Powered by Google image included in the Google repository in the correct sizes that you need for Android apps. You can reference it directly by name as Powered by Google and then light or dark, depending on if you're using a light background or a dark one respectively. But note that this Powered by Google resource is just an image, and therefore, this text will not be localized. So, you can see our integration for attributions in the GitHub commit linked below, or you can feel free to play with the layouts and where you would want to place an attribution image. There are also special considerations for attributions for third party content, so be sure to check the documentation linked in the instructor notes for more information. And if you would like to see what else the Play Safe has to offer, there's a link in the instructor notes for you as well. I'll give you this much, Joanna. Clicking a button and then picking my location is so much easier than typing it in. Yup. I'm a fan. Hey, have you seen Dan? Must be around here somewhere. The tsunami is gone. Okay, so we're all done then. Features are in. Performance is good. Yep, we are production ready. I'm pretty excited. But, we should probably, actually, tell people how to publish an App. Yes. Got it. Just take me a few minutes to explain. Okay, great. I'll go find Dan. Dan? You finished your App, you swear you tested it thoroughly, and now you're ready to publish, but how? There are the obvious basics, cleaning up the code, double checking your servers, and building a final APK. Once you have your final build, you can distribute your APK through a marketplace, like the Google Play store, email, or on a website. But even knowing all of this, it's not quite clear how to get that APK. The biggest thing here is figuring out the difference, between when you run your App from Android Studio, and when it comes from something like the Google Play Store. Android Studio does a good job of hiding some of the little details that aren't relevant to development. For example, it automatically signs your APK with a debug key during development. However, you can't publish with a debug key. You need a separate private key, to sign your App with, before you can distribute it on Google Play. For this lesson, we've created a written set of instructions on how to build and sign an APK. But, as always, you can check the documentation link, in the instructor notes, for more information and details on these steps. Then mention new content. And you've learned how to publish your apps. But you may be wondering, what should I learn next? At this point, you're prepared to take most of our Android courses. But I want to draw your attention to two in particular. Our Gradle course, Gradle for Android and Java, is a great look at the build system we've been using alongside Android Studio. In that class, you learn the magic behind the Android build process. And customize your build by creating multiple app flavors, incorporating external libraries and tools, and adding units and integration tests. The other course you're now ready for, is our performance course, featuring a lot more cult. Performance is vital if you want to make that move smoothly on older devices. And get a more global audience for your app. I've added links to each class in the instructor notes below the video. Take some time to build the final project for this class first. And then choose a direction. We can't wait to see what you'll build.